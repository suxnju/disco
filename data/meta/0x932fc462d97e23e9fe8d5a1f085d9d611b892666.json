{
	"Language": "Solidity",
	"Source": "\npragma solidity ^0.4.26;\n\ncontract TewkenBank\n{\n     using SafeMath for uint256;\n\n\n    /*==============================\n    =            EVENTS            =\n    ==============================*/\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n\n    event onBuyEvent(\n        address from,\n        uint256 tokens\n    );\n\n     event onSellEvent(\n        address from,\n        uint256 tokens\n    );\n\n\n    /*==============================\n    =            MODIFIERS         =\n    ==============================*/\n\n    bool isActive = false;\n\n    modifier isActivated {\n        require(isActive == true || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyOwner\n    {\n        require (msg.sender == owner);\n        _;\n    }\n\n    modifier onlyFromGameWhiteListed\n    {\n        require (gameWhiteListed[msg.sender] == true);\n        _;\n    }\n\n    modifier onlyTokenHolders() {\n        require(myTokens() > 0);\n        _;\n    }\n\n    address public owner;\n\n    constructor () public\n    {\n        owner = address(0xC3502531f3555Ee6B283Cf1513B1C074900B144a);\n    }\n\n    /*==============================\n    =       TOKEN VARIABLES        =\n    ==============================*/\n\n    string public name = \"TewkenBank\";\n    string public symbol = \"Tewken\";\n    uint8 constant public decimals = 18;\n    uint256 constant internal magnitude = 1e18;\n\n    uint8 constant internal transferFee = 1;\n    uint8 internal buyInFee = 30;\n    uint8 internal sellOutFee = 5;\n    uint8 internal devFee = 1;\n\n    mapping(address => uint256) public investedETH;\n    mapping(address => uint256) private tokenBalanceLedger;\n\n    uint256 public totalInvestor = 0;\n    uint256 public totalDonation = 0;\n\n    uint256 private tokenSupply = 0;\n    uint256 private contractValue = 0;\n    uint256 private tokenPrice = 0.00001 ether;   //starting price\n\n\n   /*================================\n    =       TEWKEN VARIABLES         =\n    ================================*/\n\n    mapping(address => bool) private gameWhiteListed;\n\n    /*================================\n    =       PUBLIC FUNCTIONS         =\n    ================================*/\n\n     /**\n     * Fallback function to process ethereum\n     */\n    function()\n        payable\n        public\n    {\n        appreciateTokenPrice();\n    }\n\n    function addGame(address _contractAddress) public\n    onlyOwner\n    {\n        gameWhiteListed[_contractAddress] = true;\n    }\n\n    function removeGame(address _contractAddress) public\n    onlyOwner\n    {\n        gameWhiteListed[_contractAddress] = false;\n    }\n\n    function buyTokenSub(uint256 _eth , address _customerAddress) private\n    returns(uint256)\n    {\n\n        uint256 _nb_token = (_eth.mul(magnitude)) / tokenPrice;\n\n        tokenBalanceLedger[_customerAddress] =  tokenBalanceLedger[_customerAddress].add(_nb_token);\n        tokenSupply = tokenSupply.add(_nb_token);\n\n        emit onBuyEvent(_customerAddress , _nb_token);\n\n        return(_nb_token);\n\n    }\n\n    function buyTokenFromGame(address _customerAddress) public payable\n    onlyFromGameWhiteListed\n    returns(uint256)\n    {\n        uint256 _eth = msg.value;\n\n        require(_eth>=0.0001 ether);\n\n        if (getInvested() == 0)\n        {\n            totalInvestor = totalInvestor.add(1);\n        }\n\n        investedETH[msg.sender] = investedETH[msg.sender].add(_eth);\n\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\n        uint256 _fee = (_eth.mul(buyInFee)) / 100;\n\n        buyTokenSub((_devfee.mul(100-buyInFee)) / 100 , owner);\n\n        //finally buy for the buyer\n        uint256 _nb_token = buyTokenSub(_eth - _fee -_devfee, _customerAddress);\n\n        //add the value to the contract\n        contractValue = contractValue.add(_eth);\n\n        if (tokenSupply>magnitude)\n        {\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\n        }\n\n        return(_nb_token);\n\n    }\n\n\n    function buyToken() public payable\n    isActivated\n    returns(uint256)\n    {\n        if (isActive == false){\n          isActive = true;\n        }\n\n        uint256 _eth = msg.value;\n        address _customerAddress = msg.sender;\n\n        require(_eth>=0.0001 ether);\n\n        if (getInvested() == 0)\n        {\n            totalInvestor = totalInvestor.add(1);\n        }\n\n        investedETH[msg.sender] = investedETH[msg.sender].add(_eth);\n\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\n        uint256 _fee = (_eth.mul(buyInFee)) / 100;\n\n        buyTokenSub((_devfee.mul(100-buyInFee)) / 100 , owner);\n\n        //finally buy for the buyer\n        uint256 _nb_token = buyTokenSub(_eth - _fee -_devfee, _customerAddress);\n\n        //add the value to the contract\n        contractValue = contractValue.add(_eth);\n\n        if (tokenSupply>magnitude)\n        {\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\n        }\n\n        return(_nb_token);\n\n    }\n\n    function sellToken(uint256 _amount) public\n    isActivated\n    onlyTokenHolders\n    {\n        address _customerAddress = msg.sender;\n\n        uint256 balance = tokenBalanceLedger[_customerAddress];\n\n        require(_amount <= balance);\n\n        uint256 _eth = (_amount.mul(tokenPrice)) / magnitude;\n\n        uint256 _fee = (_eth.mul(sellOutFee)) / 100;\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\n\n        tokenSupply = tokenSupply.sub(_amount);\n\n        balance = balance.sub(_amount);\n\n        tokenBalanceLedger[_customerAddress] = balance;\n\n        buyTokenSub((_devfee.mul(100-sellOutFee)) / 100 , owner);\n\n        //calculate what is really leaving the contract, basically eth-fee-devfee\n        _eth = _eth - _fee - _devfee;\n\n        contractValue = contractValue.sub(_eth);\n\n        if (tokenSupply>magnitude)\n        {\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\n        }\n\n         emit onSellEvent(_customerAddress , _amount);\n\n         //finally transfer the money\n        _customerAddress.transfer(_eth);\n\n    }\n\n    //there is no fee using token to play TewkenBank powered games\n\n    function payWithToken(uint256 _eth ,address _player_address) public\n    onlyFromGameWhiteListed\n    returns(uint256)\n    {\n        require(_eth>0 && _eth <= ethBalanceOfNoFee(_player_address));\n\n        address _game_contract = msg.sender;\n\n        uint256 balance = tokenBalanceLedger[_player_address];\n\n        uint256 _nb_token = (_eth.mul(magnitude)) / tokenPrice;\n\n        require(_nb_token <= balance);\n\n        //confirm the ETH value\n        _eth = (_nb_token.mul(tokenPrice)) / magnitude;\n\n        balance = balance.sub(_nb_token);\n\n        tokenSupply = tokenSupply.sub(_nb_token);\n\n        tokenBalanceLedger[_player_address] = balance;\n\n        contractValue = contractValue.sub(_eth);\n\n        if (tokenSupply>magnitude)\n        {\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\n        }\n\n        //send the money to the game contract\n        _game_contract.transfer(_eth);\n\n        return(_eth);\n    }\n\n    function appreciateTokenPrice() public payable\n    onlyFromGameWhiteListed\n    {\n        uint256 _eth =  msg.value;\n\n        contractValue = contractValue.add(_eth);\n        totalDonation = totalDonation.add(_eth);\n\n        //we need a minimum of 1 Tewken before appreciation is activated\n        if (tokenSupply>magnitude)\n        {\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\n        }\n    }\n\n    function transferSub(address _customerAddress, address _toAddress, uint256 _amountOfTokens)\n    private\n    returns(bool)\n    {\n\n        require(_amountOfTokens <= tokenBalanceLedger[_customerAddress]);\n\n        //actually a transfer of 0 token is valid in ERC20\n        if (_amountOfTokens>0)\n        {\n            {\n                uint256 _token_fee = (_amountOfTokens.mul(transferFee)) / 100;\n\n                //now proceed the transfer\n                tokenBalanceLedger[_customerAddress] = tokenBalanceLedger[_customerAddress].sub(_amountOfTokens);\n                tokenBalanceLedger[_toAddress] = tokenBalanceLedger[_toAddress].add(_amountOfTokens - _token_fee);\n\n                //burning the other half of token to drive the price up\n                tokenSupply = tokenSupply.sub(_token_fee);\n\n                if (tokenSupply>magnitude)\n                {\n                    tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\n                }\n            }\n        }\n\n\n        // fire event\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n\n        // ERC20\n        return true;\n\n    }\n\n    function transfer(address _toAddress, uint256 _amountOfTokens) public\n    isActivated\n    returns(bool)\n    {\n        return(transferSub( msg.sender ,  _toAddress, _amountOfTokens));\n    }\n\n\n    /*================================\n    =  VIEW AND HELPERS FUNCTIONS    =\n    ================================*/\n\n\n    function totalEthereumBalance()\n        public\n        view\n        returns(uint)\n    {\n        return address(this).balance;\n    }\n\n    function totalContractBalance()\n        public\n        view\n        returns(uint)\n    {\n        return contractValue;\n    }\n\n    function totalInvestor()\n        public\n        view\n        returns(uint256)\n    {\n        return totalInvestor;\n    }\n\n    function totalDonation()\n        public\n        view\n        returns(uint256)\n    {\n        return totalDonation;\n    }\n\n    function totalSupply()\n        public\n        view\n        returns(uint256)\n    {\n        return tokenSupply;\n    }\n\n    function myTokens()\n        public\n        view\n        returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n\n    function balanceOf(address _customerAddress)\n        view\n        public\n        returns(uint256)\n    {\n        return tokenBalanceLedger[_customerAddress];\n    }\n\n    function sellingPrice( bool includeFees)\n        view\n        public\n        returns(uint256)\n    {\n        uint256 _fee = 0;\n        uint256 _devfee=0;\n\n        if (includeFees)\n        {\n            _fee = (tokenPrice.mul(sellOutFee)) / 100;\n            _devfee = (tokenPrice.mul(devFee)) / 100;\n        }\n\n        return(tokenPrice - _fee - _devfee);\n\n    }\n\n    function buyingPrice( bool includeFees)\n        view\n        public\n        returns(uint256)\n    {\n        uint256 _fee = 0;\n        uint256 _devfee=0;\n\n        if (includeFees)\n        {\n            _fee = (tokenPrice.mul(buyInFee)) / 100;\n            _devfee = (tokenPrice.mul(devFee)) / 100;\n        }\n\n        return(tokenPrice + _fee + _devfee);\n\n    }\n\n    function calculateTokensReceived(uint256 _eth) public view returns (uint256) {\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\n        uint256 _fee = (_eth.mul(buyInFee)) / 100;\n\n        uint256 _taxed_eth = _eth - _fee -_devfee;\n\n        uint256 _nb_token = (_taxed_eth.mul(magnitude)) / tokenPrice;\n\n        return(_nb_token);\n    }\n\n    function ethBalanceOf(address _customerAddress)\n        view\n        public\n        returns(uint256)\n    {\n        uint256 _price = sellingPrice(true);\n\n        uint256 _balance = tokenBalanceLedger[_customerAddress];\n\n        uint256 _value = (_balance.mul(_price)) / magnitude;\n\n        return( _value );\n    }\n\n    function myEthBalanceOf()\n        public\n        view\n        returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return ethBalanceOf(_customerAddress);\n    }\n\n    function ethBalanceOfNoFee(address _customerAddress)\n        view\n        public\n        returns(uint256)\n    {\n        uint256 _price = sellingPrice(false);\n\n        uint256 _balance = tokenBalanceLedger[_customerAddress];\n\n        uint256 _value = (_balance.mul(_price)) / magnitude;\n\n        return( _value );\n    }\n\n    function myEthBalanceOfNoFee()\n        public\n        view\n        returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return ethBalanceOfNoFee(_customerAddress);\n    }\n\n    function checkGameListed(address _contract)\n        public\n        view\n        returns(bool)\n    {\n\n        return(gameWhiteListed[ _contract]);\n    }\n\n    function getInvested()\n        public\n        view\n        returns(uint256)\n    {\n        return investedETH[msg.sender];\n    }\n\n}\n\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256 c)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256 c)\n    {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n}",
	"ContractName": "TewkenBank",
	"CompilerVersion": "v0.4.26+commit.4563c3fc"
}