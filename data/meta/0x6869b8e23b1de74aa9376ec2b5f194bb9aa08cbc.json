{
	"Language": "Solidity",
	"Source": "/**\r\n *Submitted for verification at Etherscan.io on 2019-03-18\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n/**\r\n * @title OpenAndWinEtherPotGame ver 1.0 Mainet\r\n * @dev The OpenAndWinEtherPotGame contract is an ETH Fun Game contract\r\n * that allows entries set by admin per game at the cost of some preset ETH per entry.\r\n * Winners are rewarded the pot.\r\n * Fee Paid to Contract Owner\r\n */\r\ncontract OpenAndWinEtherPotGame {\r\n    address public owner; \t\t\t\t\t// Contract Creator\r\n    uint private latestBlockNumber;         // Latest Block Number on BlockChain\r\n    bytes32 private cumulativeHash;\t\t\t\r\n    address[] private bets;\t\t\t\t\t// address list of people applied for current game\r\n    mapping(address => uint256) winners;    // Winners\r\n\t\r\n\tuint256 ownerShare = 10;\r\n\tuint256 winnerShare = 90;\r\n\tbool splitAllowed = true;\r\n\t\r\n\tuint256 public gameRunCounter = 0;\r\n\t\r\n\tuint256 incremental = 1;\r\n\t\r\n\t\r\n\tuint256 public minEntriesRequiredPerGame = 3;\r\n\tuint256 playerCount = 0;\r\n\tuint256 public potSize;\r\n\t\r\n\tbool autoDistributeWinning = true;   // when manual withdraw happens, distribute winnings also\r\n\t\r\n\tbool autoWithdrawWinner = true;   // autoWithdrawWinner and distribute winnings also\r\n\t\t\r\n\tbool isRunning = true;\r\n\t\r\n\tuint256 public minEntryInWei = (1/100) * 1e18; // 0.01 Ether\r\n \t\r\n    \r\n\t// Bet placing events\r\n    event betPlaced(address thePersonWhoBet, uint moneyInWei, uint blockNumber );\r\n    event betStarted(address thePersonWhoBet, uint moneyInWei );\r\n    event betAccepted(address thePersonWhoBet, uint moneyInWei, uint blockNumber );\r\n\tevent betNotPlaced(address thePersonWhoBet, uint moneyInWei, uint blockNumber );\r\n      \r\n\t// winner draw events\r\n    event startWinnerDraw(uint256 randomInt, address winner, uint blockNumber , uint256 amountWonByThisWinner );\t\r\n\t\r\n\t// amount won\r\n\tevent amountWonByOwner(address ownerWithdrawer,  uint256 amount);\r\n\tevent amountWonByWinner(address winnerWithdrawer,  uint256 amount);\r\n\t\r\n\t// withdraw events\r\n    event startWithDraw(address withdrawer,  uint256 amount);\r\n\tevent successWithDraw(address withdrawer,  uint256 amount);\r\n\tevent rollbackWithDraw(address withdrawer,  uint256 amount);\r\n\t\r\n    event showParticipants(address[] thePersons);\r\n    event showBetNumber(uint256 betNumber, address better);\r\n    \r\n    event calledConstructor(uint block, address owner);\r\n\t\r\n\tevent successDrawWinner(bool successFlag ); \r\n\tevent notReadyDrawWinner(bool errorFlag ); \r\n \r\n    /**\r\n\t*    @dev Constructor only called once\r\n\t**/ \r\n\tconstructor() public {\r\n        owner = msg.sender;\r\n        latestBlockNumber = block.number;\r\n        cumulativeHash = bytes32(0);\r\n        \r\n        emit calledConstructor(latestBlockNumber, owner);\r\n    }\r\n \r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\t\r\n\t\r\n\t\r\n\t\r\n    // ------------------------------------------------------------------------\r\n    // @dev Send ETHER in the pot\r\n\t// If isRunning is true\r\n\t// ETH also goes in Pot\r\n\t// if pot size >= minEntriesRequiredPerGame\r\n\t// Withdraw pot and give ether to a winner and fee to contract owner\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        \r\n\t   if( isRunning == true ) {\r\n\t\t\r\n\t\t\tuint _wei = msg.value;\r\n\t\t\t\t   \r\n\t\t\temit betStarted(msg.sender , msg.value);\r\n\t\t\t//require(_wei >= 0.1 ether);\r\n\t\t\tassert(_wei >= minEntryInWei);\r\n\t\t\tcumulativeHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber), cumulativeHash));\r\n\t\t\t\r\n\t\t\temit betPlaced(msg.sender , msg.value , block.number);\r\n\t\t\t\r\n\t\t\tlatestBlockNumber = block.number;\r\n\t\t\tbets.push(msg.sender);\r\n\t\t\t\r\n\t\t\temit betAccepted(msg.sender , msg.value , block.number);\r\n\t\t\t\r\n\t\t\tpotSize = potSize + msg.value;\r\n\t\t}else {\r\n\t\t\t\r\n\t\t\temit betNotPlaced(msg.sender , msg.value , block.number);\r\n\t\t}\r\n\t\t\r\n\t\tif( autoWithdrawWinner == true ) {\r\n\t\t\t\r\n\t\t\tif( bets.length >= minEntriesRequiredPerGame ) {\r\n\t\t\t\tbool successDrawWinnerFlag = drawAutoWinner();\r\n\t\t\t\temit successDrawWinner(successDrawWinnerFlag);\r\n\t\t\t\tgameRunCounter = gameRunCounter + incremental;\r\n\t\t\t}else {\r\n\t\t\t    emit notReadyDrawWinner(false);\r\n\t\t\t}\r\n\t\t}\r\n        \r\n    }\r\n\t\r\n \r\n    /**\r\n     * @dev Send 0.01 or more ETHER Per Play.\r\n     */\r\n    function placeBet() public payable returns (bool) {\r\n        \r\n\t\tif( isRunning == true ) {\r\n\t\t\r\n\t\t\tuint _wei = msg.value;\r\n\t\t\t\t   \r\n\t\t\temit betStarted(msg.sender , msg.value);\r\n\t\t\t//require(_wei >= 0.1 ether);\r\n\t\t\tassert(_wei >= minEntryInWei);\r\n\t\t\tcumulativeHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber), cumulativeHash));\r\n\t\t\t\r\n\t\t\temit betPlaced(msg.sender , msg.value , block.number);\r\n\t\t\t\r\n\t\t\tlatestBlockNumber = block.number;\r\n\t\t\tbets.push(msg.sender);\r\n\t\t\t\r\n\t\t\temit betAccepted(msg.sender , msg.value , block.number);\r\n\t\t\t\r\n\t\t\tpotSize = potSize + msg.value;\r\n\t\t}else {\r\n\t\t\t\r\n\t\t\temit betNotPlaced(msg.sender , msg.value , block.number);\r\n\t\t}\r\n\t\t\r\n\t\tif( autoWithdrawWinner == true ) {\r\n\t\t\t\r\n\t\t\tif( bets.length >= minEntriesRequiredPerGame ) {\r\n\t\t\t\tbool successDrawWinnerFlag = drawAutoWinner();\r\n\t\t\t\temit successDrawWinner(successDrawWinnerFlag);\r\n\t\t\t\tgameRunCounter = gameRunCounter + incremental;\r\n\t\t\t}else {\r\n\t\t\t    emit notReadyDrawWinner(false);\r\n\t\t\t}\r\n\t\t}\r\n        return true;\r\n    }\r\n \r\n    function drawAutoWinner() private returns (bool) {\r\n        \r\n\t\tbool boolSuccessFlag = false;\r\n\t\t\r\n\t\tassert( bets.length >= minEntriesRequiredPerGame );\r\n        \r\n\t\tlatestBlockNumber = block.number;\r\n        \r\n\t\tbytes32 _finalHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber-1), cumulativeHash));\r\n        \r\n\t\tuint256 _randomInt = uint256(_finalHash) % bets.length;\r\n        \r\n\t\taddress _winner = bets[_randomInt];\r\n\t\t\r\n\t\tuint256 amountWon = potSize ;\r\n        \r\n\t\tuint256 ownerAmt = amountWon * ownerShare /100 ;\r\n\t\t\r\n\t\tuint256 winnerAmt = amountWon * winnerShare / 100 ;\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif( splitAllowed == true ) {\r\n\t\t\r\n\t\t    emit startWinnerDraw(_randomInt, _winner, latestBlockNumber , winnerAmt );\r\n\t\t\twinners[_winner] = winnerAmt;\r\n\t\t\towner.transfer(ownerAmt);\r\n\t\t\temit amountWonByOwner(owner, ownerAmt);\r\n\t\t\t\r\n\t\t\tif( autoDistributeWinning == true ) {\r\n\t\t\t   \r\n\t\t\t\twinners[_winner] = 0;\r\n\t\t\t\t\r\n\t\t\t\tif( _winner.send(winnerAmt)) {\r\n\t\t\t\t   emit successWithDraw(_winner, winnerAmt);\r\n\t\t\t\t   emit amountWonByWinner(_winner, winnerAmt);\r\n\t\t\t\t   \r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t  winners[_winner] = winnerAmt;\r\n\t\t\t\t  emit rollbackWithDraw(_winner, winnerAmt);\r\n\t\t\t\t  \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\r\n\t\t    emit startWinnerDraw(_randomInt, _winner, latestBlockNumber , amountWon );\r\n\t\t\twinners[_winner] = amountWon;\r\n\t\t\t\r\n\t\t\tif( autoDistributeWinning == true ) {\r\n\t\t\t   \r\n\t\t\t\twinners[_winner] = 0;\r\n\t\t\t\t\r\n\t\t\t\tif( _winner.send(amountWon)) {\r\n\t\t\t\t   emit successWithDraw(_winner, amountWon);\r\n\t\t\t\t   emit amountWonByWinner(_winner, amountWon);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t  winners[_winner] = amountWon;\r\n\t\t\t\t  emit rollbackWithDraw(_winner, amountWon);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n        cumulativeHash = bytes32(0);\r\n        delete bets;\r\n\t\t\r\n\t\tpotSize = 0;\r\n\t\t\r\n\t\t\r\n\t\tboolSuccessFlag = true;\r\n\t\t\r\n        return boolSuccessFlag;\r\n    }\r\n\t\r\n\t\r\n\tfunction drawWinner() private onlyOwner returns (address) {\r\n        \r\n\t\tassert( bets.length >= minEntriesRequiredPerGame );\r\n        \r\n\t\tlatestBlockNumber = block.number;\r\n        \r\n\t\tbytes32 _finalHash = keccak256(abi.encodePacked(blockhash(latestBlockNumber-1), cumulativeHash));\r\n        \r\n\t\tuint256 _randomInt = uint256(_finalHash) % bets.length;\r\n        \r\n\t\taddress _winner = bets[_randomInt];\r\n\t\t\r\n\t\tuint256 amountWon = potSize ;\r\n        \r\n\t\tuint256 ownerAmt = amountWon * ownerShare /100 ;\r\n\t\t\r\n\t\tuint256 winnerAmt = amountWon * winnerShare / 100 ;\r\n\t\t\r\n\t\tif( splitAllowed == true ) {\r\n\t\t\twinners[_winner] = winnerAmt;\r\n\t\t\towner.transfer(ownerAmt);\r\n\t\t\temit amountWonByOwner(owner, ownerAmt);\r\n\t\t\t\r\n\t\t\tif( autoDistributeWinning == true ) {\r\n\t\t\t   \r\n\t\t\t\twinners[_winner] = 0;\r\n\t\t\t\t\r\n\t\t\t\tif( _winner.send(winnerAmt)) {\r\n\t\t\t\t   emit successWithDraw(_winner, winnerAmt);\r\n\t\t\t\t   emit amountWonByWinner(_winner, winnerAmt);\r\n\t\t\t\t   \r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t  winners[_winner] = winnerAmt;\r\n\t\t\t\t  emit rollbackWithDraw(_winner, winnerAmt);\r\n\t\t\t\t  \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\twinners[_winner] = amountWon;\r\n\t\t\t\r\n\t\t\tif( autoDistributeWinning == true ) {\r\n\t\t\t   \r\n\t\t\t\twinners[_winner] = 0;\r\n\t\t\t\t\r\n\t\t\t\tif( _winner.send(amountWon)) {\r\n\t\t\t\t   emit successWithDraw(_winner, amountWon);\r\n\t\t\t\t   emit amountWonByWinner(_winner, amountWon);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t  winners[_winner] = amountWon;\r\n\t\t\t\t  emit rollbackWithDraw(_winner, amountWon);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n        cumulativeHash = bytes32(0);\r\n        delete bets;\r\n\t\t\r\n\t\tpotSize = 0;\r\n\t\t\r\n\t\temit startWinnerDraw(_randomInt, _winner, latestBlockNumber , winners[_winner] );\r\n\t\t\r\n        return _winner;\r\n    }\r\n\t\r\n \r\n\t\r\n\t/**\r\n     * @dev Withdraw your winnings yourself\r\n     */\r\n    function withdraw() private returns (bool) {\r\n        uint256 amount = winners[msg.sender];\r\n\t\t\r\n\t\temit startWithDraw(msg.sender, amount);\r\n\t\t\t\r\n        winners[msg.sender] = 0;\r\n\t\t\r\n        if (msg.sender.send(amount)) {\r\n\t\t\r\n\t\t    emit successWithDraw(msg.sender, amount);\r\n            return true;\r\n        } else {\r\n            winners[msg.sender] = amount;\r\n\t\t\t\r\n\t\t\temit rollbackWithDraw(msg.sender, amount);\r\n\t\t\t\r\n            return false;\r\n        }\r\n    }\r\n \r\n\t/**\r\n     * @dev List of Participants\r\n     */\r\n    function _onlyAdmin_GetGameInformation() public onlyOwner returns (address[]) {\r\n       emit showParticipants(bets);\r\n\t   return bets;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Start / Stop the game\r\n     */\r\n\tfunction _onlyAdmin_ToggleGame() public onlyOwner returns (bool) {\r\n        \r\n       if( isRunning == false ) {\r\n\t\t\tisRunning = true;\r\n\t   }else {\r\n\t\t\tisRunning = false;\r\n\t   }\r\n\t   \r\n       return isRunning;\r\n    }\r\n \r\n    /**\r\n     * @dev Set min number of enteried - dupe entried allowed\r\n     */\r\n    function _onlyAdmin_SetMinEntriesRequiredPerGame(uint256 entries) public onlyOwner returns (bool) {\r\n        \r\n        minEntriesRequiredPerGame = entries;\r\n        return true;\r\n    }\r\n\t\r\n\t\r\n\t/**\r\n     * @dev Set Min bet in wei\r\n     */\r\n    function _onlyAdmin_setMinBetAmountInWei(uint256 amount) public onlyOwner returns (bool) {\r\n        \r\n        minEntryInWei = amount ;\r\n        return true;\r\n    }\r\n\t\r\n\t\r\n    /**\r\n     * @dev Get address for Bet\r\n     */\r\n    function getBet(uint256 betNumber) private returns (address) {\r\n        \r\n        emit showBetNumber(betNumber,bets[betNumber]);\r\n        return bets[betNumber];\r\n    }\r\n \r\n\r\n    /**\r\n     * @dev Get no of Entries in Contract\r\n     */\r\n    function getNumberOfBets() public view returns (uint256) {\r\n        return bets.length;\r\n    }\r\n\t\r\n\r\n\t/**\r\n     * @dev Get min Entries required to start the draw\r\n     */\r\n    function minEntriesRequiredPerGame() public view returns (uint256) {\r\n        return minEntriesRequiredPerGame;\r\n    }\r\n\t\r\n\r\n\t/**\r\n     * @dev Destroy Contract\r\n     */\r\n\tfunction _onlyAdmin_Destroy() onlyOwner public { \r\n\t\tuint256 potAmount =  potSize;\r\n\t\towner.transfer(potAmount);\r\n\t\tselfdestruct(owner);  \r\n\t}\r\n}",
	"ContractName": "OpenAndWinEtherPotGame",
	"CompilerVersion": "v0.4.26+commit.4563c3fc"
}