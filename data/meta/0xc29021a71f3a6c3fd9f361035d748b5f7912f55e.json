{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.18;\r\n// -------------------------------------------------\r\n// ethPoker.io EPX token - Presale & ICO token sale contract\r\n// contact admin@ethpoker.io for queries\r\n// Revision 20b\r\n// Refunds integrated, full test suite 20r passed\r\n// -------------------------------------------------\r\n// ERC Token Standard #20 interface:\r\n// https://github.com/ethereum/EIPs/issues/20\r\n// EPX contract sources:\r\n// https://github.com/EthPokerIO/ethpokerIO\r\n// ------------------------------------------------\r\n// 2018 improvements:\r\n// - Updates to comply with latest Solidity versioning (0.4.18):\r\n// -   Classification of internal/private vs public functions\r\n// -   Specification of pure functions such as SafeMath integrated functions\r\n// -   Conversion of all constant to view or pure dependant on state changed\r\n// -   Full regression test of code updates\r\n// -   Revision of block number timing for new Ethereum block times\r\n// - Removed duplicate Buy/Transfer event call in buyEPXtokens function (ethScan output verified)\r\n// - Burn event now records number of EPX tokens burned vs Refund event Eth\r\n// - Transfer event now fired when beneficiaryWallet withdraws\r\n// - Gas req optimisation for payable function to maximise compatibility\r\n// - Going live for initial Presale round 02/03/2018\r\n// -------------------------------------------------\r\n// Security reviews passed - cycle 20r\r\n// Functional reviews passed - cycle 20r\r\n// Final code revision and regression test cycle passed - cycle 20r\r\n// -------------------------------------------------\r\n\r\ncontract owned {\r\n  address public owner;\r\n\r\n  function owned() internal {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\ncontract safeMath {\r\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    safeAssert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    safeAssert(b > 0);\r\n    uint256 c = a / b;\r\n    safeAssert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    safeAssert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    safeAssert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function safeAssert(bool assertion) internal pure {\r\n    if (!assertion) revert();\r\n  }\r\n}\r\n\r\ncontract StandardToken is owned, safeMath {\r\n  function balanceOf(address who) view public returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract EPXCrowdsale is owned, safeMath {\r\n  // owner/admin & token reward\r\n  address        public admin                     = owner;    // admin address\r\n  StandardToken  public tokenReward;                          // address of the token used as reward\r\n\r\n  // deployment variables for static supply sale\r\n  uint256 private initialTokenSupply;\r\n  uint256 private tokensRemaining;\r\n\r\n  // multi-sig addresses and price variable\r\n  address private beneficiaryWallet;                           // beneficiaryMultiSig (founder group) or wallet account\r\n\r\n  // uint256 values for min,max,caps,tracking\r\n  uint256 public amountRaisedInWei;                           //\r\n  uint256 public fundingMinCapInWei;                          //\r\n\r\n  // loop control, ICO startup and limiters\r\n  string  public CurrentStatus                    = \"\";        // current crowdsale status\r\n  uint256 public fundingStartBlock;                           // crowdsale start block#\r\n  uint256 public fundingEndBlock;                             // crowdsale end block#\r\n  bool    public isCrowdSaleClosed               = false;     // crowdsale completion boolean\r\n  bool    private areFundsReleasedToBeneficiary  = false;     // boolean for founder to receive Eth or not\r\n  bool    public isCrowdSaleSetup                = false;     // boolean for crowdsale setup\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Buy(address indexed _sender, uint256 _eth, uint256 _EPX);\r\n  event Refund(address indexed _refunder, uint256 _value);\r\n  event Burn(address _from, uint256 _value);\r\n  mapping(address => uint256) balancesArray;\r\n  mapping(address => uint256) usersEPXfundValue;\r\n\r\n  // default function, map admin\r\n  function EPXCrowdsale() public onlyOwner {\r\n    admin = msg.sender;\r\n    CurrentStatus = \"Crowdsale deployed to chain\";\r\n  }\r\n\r\n  // total number of tokens initially\r\n  function initialEPXSupply() public view returns (uint256 initialEPXtokenCount) {\r\n    return safeDiv(initialTokenSupply,10000); // div by 10,000 for display normalisation (4 decimals)\r\n  }\r\n\r\n  // remaining number of tokens\r\n  function remainingEPXSupply() public view returns (uint256 remainingEPXtokenCount) {\r\n    return safeDiv(tokensRemaining,10000); // div by 10,000 for display normalisation (4 decimals)\r\n  }\r\n\r\n  // setup the CrowdSale parameters\r\n  function SetupCrowdsale(uint256 _fundingStartBlock, uint256 _fundingEndBlock) public onlyOwner returns (bytes32 response) {\r\n    if ((msg.sender == admin)\r\n    && (!(isCrowdSaleSetup))\r\n    && (!(beneficiaryWallet > 0))) {\r\n      // init addresses\r\n      beneficiaryWallet                       = 0x7A29e1343c6a107ce78199F1b3a1d2952efd77bA;\r\n      tokenReward                             = StandardToken(0x35BAA72038F127f9f8C8f9B491049f64f377914d);\r\n\r\n      // funding targets\r\n      fundingMinCapInWei                      = 30000000000000000000;                       // ETH 300 + 000000000000000000 18 dec wei\r\n\r\n      // update values\r\n      amountRaisedInWei                       = 0;\r\n      initialTokenSupply                      = 200000000000;                               // 20,000,000 + 4 dec resolution\r\n      tokensRemaining                         = initialTokenSupply;\r\n      fundingStartBlock                       = _fundingStartBlock;\r\n      fundingEndBlock                         = _fundingEndBlock;\r\n\r\n      // configure crowdsale\r\n      isCrowdSaleSetup                        = true;\r\n      isCrowdSaleClosed                       = false;\r\n      CurrentStatus                           = \"Crowdsale is setup\";\r\n      return \"Crowdsale is setup\";\r\n    } else if (msg.sender != admin) {\r\n      return \"not authorised\";\r\n    } else  {\r\n      return \"campaign cannot be changed\";\r\n    }\r\n  }\r\n\r\n  function checkPrice() internal view returns (uint256 currentPriceValue) {\r\n    if (block.number >= fundingStartBlock+177534) { // 30-day price change/final 30day change\r\n      return (7600); //30days-end   =7600EPX:1ETH\r\n    } else if (block.number >= fundingStartBlock+124274) { //3 week mark/over 21days\r\n      return (8200); //3w-30days    =8200EPX:1ETH\r\n    } else if (block.number >= fundingStartBlock) { // start [0 hrs]\r\n      return (8800); //0-3weeks     =8800EPX:1ETH\r\n    }\r\n  }\r\n\r\n  // default payable function when sending ether to this contract\r\n  function () public payable {\r\n    // 0. conditions (length, crowdsale setup, zero check, exceed funding contrib check, contract valid check, within funding block range check, balance overflow check etc)\r\n    require(!(msg.value == 0)\r\n    && (msg.data.length == 0)\r\n    && (block.number <= fundingEndBlock)\r\n    && (block.number >= fundingStartBlock)\r\n    && (tokensRemaining > 0));\r\n\r\n    // 1. vars\r\n    uint256 rewardTransferAmount    = 0;\r\n\r\n    // 2. effects\r\n    amountRaisedInWei               = safeAdd(amountRaisedInWei, msg.value);\r\n    rewardTransferAmount            = ((safeMul(msg.value, checkPrice())) / 100000000000000);\r\n\r\n    // 3. interaction\r\n    tokensRemaining                 = safeSub(tokensRemaining, rewardTransferAmount);\r\n    tokenReward.transfer(msg.sender, rewardTransferAmount);\r\n\r\n    // 4. events\r\n    usersEPXfundValue[msg.sender]   = safeAdd(usersEPXfundValue[msg.sender], msg.value);\r\n    Buy(msg.sender, msg.value, rewardTransferAmount);\r\n  }\r\n\r\n  function beneficiaryMultiSigWithdraw(uint256 _amount) public onlyOwner {\r\n    require(areFundsReleasedToBeneficiary && (amountRaisedInWei >= fundingMinCapInWei));\r\n    beneficiaryWallet.transfer(_amount);\r\n    Transfer(this, beneficiaryWallet, _amount);\r\n  }\r\n\r\n  function checkGoalReached() public onlyOwner { // return crowdfund status to owner for each result case, update public vars\r\n    // update state & status variables\r\n    require (isCrowdSaleSetup);\r\n    if ((amountRaisedInWei < fundingMinCapInWei) && (block.number <= fundingEndBlock && block.number >= fundingStartBlock)) { // ICO in progress, under softcap\r\n      areFundsReleasedToBeneficiary = false;\r\n      isCrowdSaleClosed = false;\r\n      CurrentStatus = \"In progress (Eth < Softcap)\";\r\n    } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.number < fundingStartBlock)) { // ICO has not started\r\n      areFundsReleasedToBeneficiary = false;\r\n      isCrowdSaleClosed = false;\r\n      CurrentStatus = \"Crowdsale is setup\";\r\n    } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.number > fundingEndBlock)) { // ICO ended, under softcap\r\n      areFundsReleasedToBeneficiary = false;\r\n      isCrowdSaleClosed = true;\r\n      CurrentStatus = \"Unsuccessful (Eth < Softcap)\";\r\n    } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining == 0)) { // ICO ended, all tokens bought!\r\n      areFundsReleasedToBeneficiary = true;\r\n      isCrowdSaleClosed = true;\r\n      CurrentStatus = \"Successful (EPX >= Hardcap)!\";\r\n    } else if ((amountRaisedInWei >= fundingMinCapInWei) && (block.number > fundingEndBlock) && (tokensRemaining > 0)) { // ICO ended, over softcap!\r\n      areFundsReleasedToBeneficiary = true;\r\n      isCrowdSaleClosed = true;\r\n      CurrentStatus = \"Successful (Eth >= Softcap)!\";\r\n    } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining > 0) && (block.number <= fundingEndBlock)) { // ICO in progress, over softcap!\r\n      areFundsReleasedToBeneficiary = true;\r\n      isCrowdSaleClosed = false;\r\n      CurrentStatus = \"In progress (Eth >= Softcap)!\";\r\n    }\r\n  }\r\n\r\n  function refund() public { // any contributor can call this to have their Eth returned. user's purchased EPX tokens are burned prior refund of Eth.\r\n    //require minCap not reached\r\n    require ((amountRaisedInWei < fundingMinCapInWei)\r\n    && (isCrowdSaleClosed)\r\n    && (block.number > fundingEndBlock)\r\n    && (usersEPXfundValue[msg.sender] > 0));\r\n\r\n    //burn user's token EPX token balance, refund Eth sent\r\n    uint256 ethRefund = usersEPXfundValue[msg.sender];\r\n    balancesArray[msg.sender] = 0;\r\n    usersEPXfundValue[msg.sender] = 0;\r\n\r\n    //record Burn event with number of EPX tokens burned\r\n    Burn(msg.sender, usersEPXfundValue[msg.sender]);\r\n\r\n    //send Eth back\r\n    msg.sender.transfer(ethRefund);\r\n\r\n    //record Refund event with number of Eth refunded in transaction\r\n    Refund(msg.sender, ethRefund);\r\n  }\r\n}",
	"ContractName": "EPXCrowdsale",
	"CompilerVersion": "v0.4.18+commit.9cf6e910"
}