{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.25;\r\n\r\ncontract CentWallet {\r\n\r\n    struct Wallet {\r\n        uint256 balance;\r\n        mapping(address => bool) linked;\r\n        // prevent signature replay:\r\n        uint64 debitNonce;\r\n        uint64 withdrawNonce;\r\n    }\r\n\r\n    address[] public admins;\r\n\r\n    mapping(bytes32 => Wallet) private wallets;\r\n    mapping(address => bool) private isAdmin;\r\n\r\n    uint256 private escrowBalance;\r\n\r\n    modifier onlyAdmin {\r\n        require(isAdmin[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRootAdmin {\r\n        require(msg.sender == admins[0]);\r\n        _;\r\n    }\r\n\r\n    event Deposit(\r\n        bytes32 indexed walletID,\r\n        address indexed sender,\r\n        uint256 indexed value\r\n    );\r\n\r\n    event Link(\r\n        bytes32 indexed walletID,\r\n        address indexed agent\r\n    );\r\n\r\n    event Debit(\r\n        bytes32 indexed walletID,\r\n        uint256 indexed nonce,\r\n        uint256 indexed value\r\n    );\r\n\r\n    event Settle(\r\n        bytes32 indexed walletID,\r\n        uint256 indexed requestID,\r\n        uint256 indexed value\r\n    );\r\n\r\n    event Withdraw(\r\n        bytes32 indexed walletID,\r\n        uint256 indexed nonce,\r\n        uint256 indexed value,\r\n        address recipient\r\n    );\r\n\r\n    constructor() public\r\n    {\r\n        admins.push(msg.sender);\r\n        isAdmin[msg.sender] = true;\r\n    }\r\n\r\n//  PUBLIC CALLABLE BY ANYONE\r\n    /**\r\n     * Add funds to the wallet associated with an address + username\r\n     * Create a wallet if none exists.\r\n     */\r\n    function deposit(\r\n        bytes32 walletID) payable public\r\n    {\r\n        wallets[walletID].balance += msg.value;\r\n\r\n        emit Deposit(walletID, msg.sender, msg.value);\r\n    }\r\n\r\n//  PUBLIC CALLABLE BY ADMIN\r\n    /**\r\n     * Add an authorized signer to a wallet.\r\n     */\r\n    function link(\r\n        bytes32[] walletIDs,\r\n        bytes32[] nameIDs,\r\n        address[] agents,\r\n        uint8[] v, bytes32[] r, bytes32[] s) onlyAdmin public\r\n    {\r\n        require(\r\n            walletIDs.length == nameIDs.length &&\r\n            walletIDs.length == agents.length &&\r\n            walletIDs.length == v.length &&\r\n            walletIDs.length == r.length &&\r\n            walletIDs.length == s.length\r\n        );\r\n\r\n        for (uint i = 0; i < walletIDs.length; i++) {\r\n            bytes32 walletID = walletIDs[i];\r\n            address agent = agents[i];\r\n\r\n            address signer = getMessageSigner(\r\n                getLinkDigest(walletID, agent), v[i], r[i], s[i]\r\n            );\r\n\r\n            Wallet storage wallet = wallets[walletID];\r\n\r\n            if (wallet.linked[signer] || walletID == getWalletDigest(nameIDs[i], signer)) {\r\n                wallet.linked[agent] = true;\r\n\r\n                emit Link(walletID, agent);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Debit funds from a user's balance and add them to the escrow balance.\r\n     */\r\n    function debit(\r\n        bytes32[] walletIDs,\r\n        uint256[] values,\r\n        uint64[] nonces,\r\n        uint8[] v, bytes32[] r, bytes32[] s) onlyAdmin public\r\n    {\r\n        require(\r\n            walletIDs.length == values.length &&\r\n            walletIDs.length == nonces.length &&\r\n            walletIDs.length == v.length &&\r\n            walletIDs.length == r.length &&\r\n            walletIDs.length == s.length\r\n        );\r\n\r\n        uint256 additionalEscrow = 0;\r\n\r\n        for (uint i = 0; i < walletIDs.length; i++) {\r\n            bytes32 walletID = walletIDs[i];\r\n            uint256 value = values[i];\r\n            uint64 nonce = nonces[i];\r\n\r\n            address signer = getMessageSigner(\r\n                getDebitDigest(walletID, value, nonce), v[i], r[i], s[i]\r\n            );\r\n\r\n            Wallet storage wallet = wallets[walletID];\r\n\r\n            if (\r\n                wallet.debitNonce < nonce &&\r\n                wallet.balance >= value &&\r\n                wallet.linked[signer]\r\n            ) {\r\n                wallet.debitNonce = nonce;\r\n                wallet.balance -= value;\r\n\r\n                emit Debit(walletID, nonce, value);\r\n\r\n                additionalEscrow += value;\r\n            }\r\n        }\r\n\r\n        escrowBalance += additionalEscrow;\r\n    }\r\n\r\n    /**\r\n     * Withdraws funds from this contract, debiting the user's wallet.\r\n     */\r\n    function withdraw(\r\n        bytes32[] walletIDs,\r\n        address[] recipients,\r\n        uint256[] values,\r\n        uint64[] nonces,\r\n        uint8[] v, bytes32[] r, bytes32[] s) onlyAdmin public\r\n    {\r\n        require(\r\n            walletIDs.length == recipients.length &&\r\n            walletIDs.length == values.length &&\r\n            walletIDs.length == nonces.length &&\r\n            walletIDs.length == v.length &&\r\n            walletIDs.length == r.length &&\r\n            walletIDs.length == s.length\r\n        );\r\n\r\n        for (uint i = 0; i < walletIDs.length; i++) {\r\n            bytes32 walletID = walletIDs[i];\r\n            address recipient = recipients[i];\r\n            uint256 value = values[i];\r\n            uint64 nonce = nonces[i];\r\n\r\n            address signer = getMessageSigner(\r\n                getWithdrawDigest(walletID, recipient, value, nonce), v[i], r[i], s[i]\r\n            );\r\n\r\n            Wallet storage wallet = wallets[walletID];\r\n\r\n            if (\r\n                wallet.withdrawNonce < nonce &&\r\n                wallet.balance >= value &&\r\n                wallet.linked[signer] &&\r\n                recipient.send(value)\r\n            ) {\r\n                wallet.withdrawNonce = nonce;\r\n                wallet.balance -= value;\r\n\r\n                emit Withdraw(walletID, nonce, value, recipient);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Settles funds from admin escrow into user wallets.\r\n     */\r\n    function settle(\r\n        bytes32[] walletIDs,\r\n        uint256[] requestIDs,\r\n        uint256[] values) onlyAdmin public\r\n    {\r\n        require(\r\n            walletIDs.length == requestIDs.length &&\r\n            walletIDs.length == values.length\r\n        );\r\n\r\n        uint256 remainingEscrow = escrowBalance;\r\n\r\n        for (uint i = 0; i < walletIDs.length; i++) {\r\n            bytes32 walletID = walletIDs[i];\r\n            uint256 value = values[i];\r\n\r\n            require(value <= remainingEscrow);\r\n\r\n            wallets[walletID].balance += value;\r\n            remainingEscrow -= value;\r\n\r\n            emit Settle(walletID, requestIDs[i], value);\r\n        }\r\n\r\n        escrowBalance = remainingEscrow;\r\n    }\r\n\r\n//  PURE GETTERS - FOR SIGNATURE GENERATION / VERIFICATION\r\n    function getMessageSigner(\r\n        bytes32 message,\r\n        uint8 v, bytes32 r, bytes32 s) public pure returns(address)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedMessage = keccak256(\r\n            abi.encodePacked(prefix, message)\r\n        );\r\n        return ecrecover(prefixedMessage, v, r, s);\r\n    }\r\n\r\n    function getNameDigest(\r\n        string name) public pure returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(name));\r\n    }\r\n\r\n    function getWalletDigest(\r\n        bytes32 name,\r\n        address root) public pure returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n            name, root\r\n        ));\r\n    }\r\n\r\n    function getLinkDigest(\r\n        bytes32 walletID,\r\n        address agent) public pure returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n            walletID, agent\r\n        ));\r\n    }\r\n\r\n    function getDebitDigest(\r\n        bytes32 walletID,\r\n        uint256 value,\r\n        uint64 nonce) public pure returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n            walletID, value, nonce\r\n        ));\r\n    }\r\n\r\n    function getWithdrawDigest(\r\n        bytes32 walletID,\r\n        address recipient,\r\n        uint256 value,\r\n        uint64 nonce) public pure returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n            walletID, recipient, value, nonce\r\n        ));\r\n    }\r\n\r\n//  VIEW GETTERS - READ WALLET STATE\r\n    function getDebitNonce(\r\n        bytes32 walletID) public view returns (uint256)\r\n    {\r\n        return wallets[walletID].debitNonce + 1;\r\n    }\r\n\r\n    function getWithdrawNonce(\r\n        bytes32 walletID) public view returns (uint256)\r\n    {\r\n        return wallets[walletID].withdrawNonce + 1;\r\n    }\r\n\r\n    function getLinkStatus(\r\n        bytes32 walletID,\r\n        address member) public view returns (bool)\r\n    {\r\n        return wallets[walletID].linked[member];\r\n    }\r\n\r\n    function getBalance(\r\n        bytes32 walletID) public view returns (uint256)\r\n    {\r\n        return wallets[walletID].balance;\r\n    }\r\n\r\n    function getEscrowBalance() public view returns (uint256)\r\n    {\r\n      return escrowBalance;\r\n    }\r\n\r\n//  ADMIN MANAGEMENT\r\n    function addAdmin(\r\n        address newAdmin) onlyRootAdmin public\r\n    {\r\n        require(!isAdmin[newAdmin]);\r\n\r\n        isAdmin[newAdmin] = true;\r\n        admins.push(newAdmin);\r\n    }\r\n\r\n    function removeAdmin(\r\n        address oldAdmin) onlyRootAdmin public\r\n    {\r\n        require(isAdmin[oldAdmin] && admins[0] != oldAdmin);\r\n\r\n        bool found = false;\r\n        for (uint i = 1; i < admins.length - 1; i++) {\r\n            if (!found && admins[i] == oldAdmin) {\r\n                found = true;\r\n            }\r\n            if (found) {\r\n                admins[i] = admins[i + 1];\r\n            }\r\n        }\r\n\r\n        admins.length--;\r\n        isAdmin[oldAdmin] = false;\r\n    }\r\n\r\n    function changeRootAdmin(\r\n        address newRootAdmin) onlyRootAdmin public\r\n    {\r\n        if (isAdmin[newRootAdmin] && admins[0] != newRootAdmin) {\r\n            // Remove them & shorten the array so long as they are not currently root\r\n            removeAdmin(newRootAdmin);\r\n        }\r\n        admins[0] = newRootAdmin;\r\n        isAdmin[newRootAdmin] = true;\r\n    }\r\n}",
	"ContractName": "CentWallet",
	"CompilerVersion": "v0.4.25+commit.59dbf8f1"
}