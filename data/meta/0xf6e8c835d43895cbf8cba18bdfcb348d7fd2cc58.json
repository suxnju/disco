{
	"Language": "Vyper",
	"Source": "# @title Vyper loveregister contract\r\n# @author Kevin Foesenek\r\n\r\n#Struct\r\nstruct register: \r\n    owner1: address\r\n    owner1_name: string[120]\r\n    owner2: address\r\n    owner2_name: string[120]\r\n    message: string[280]\r\n    private_message: string[280]\r\n    alive: bool\r\n\r\n# Events\r\nRegister: event({_from: indexed(address), _to: indexed(address), identifier: bytes32})\r\nSearch: event({Owner: indexed(address), _Identifier: bytes32})\r\n\r\n# Variables contract owner\r\nowner1: public(address)\r\nowner2: public(address)\r\npayment_address: public(address)\r\nprice: public(wei_value)\r\n\r\n# Variables ERC20 \r\nname: public(string[64])\r\nregister_entries: public(map(bytes32, register))\r\nregister_totalEntries: public(uint256)\r\nregister_publicmessage: public(map(uint256, string[280]))\r\nregister_identifier: map(address, bytes32)\r\n\r\n# Constructor\r\n@public\r\ndef __init__(_name: string[64], _price: wei_value):\r\n        self.name = _name\r\n        self.owner1 = msg.sender\r\n        self.price = _price\r\n        self.payment_address = msg.sender\r\n\r\n# Function to set second owner\r\n@public\r\ndef setsecondowner(newowner: address):\r\n    assert self.owner1 == msg.sender or self.owner2 == msg.sender\r\n    self.owner2 = newowner\r\n        \r\n# Function to set price\r\n@public\r\ndef setprice(newprice: wei_value):\r\n    assert self.owner1 == msg.sender or self.owner2 == msg.sender\r\n    self.price = newprice\r\n\r\n# Function to change payment address\r\n@public\r\ndef changepaymentaddress(newaddress: address):\r\n    assert self.owner1 == msg.sender or self.owner2 == msg.sender\r\n    self.payment_address = newaddress\r\n\r\n# Function to send amount of ETH to owner determined address\r\n@public\r\ndef clear_valuecontract():\r\n    assert self.owner1 == msg.sender or self.owner2 == msg.sender\r\n    receiver: address = self.payment_address\r\n    amount: wei_value = self.balance\r\n    send(receiver, amount)\r\n    \r\n# Function to register\r\n@public\r\n@payable\r\ndef newRegister(_from: address, _fromName: string[120], _for: address, _forName: string[120], message: string[280], privatenote: string[280]):\r\n    index_entries: uint256 = self.register_totalEntries\r\n    \r\n    hash_index_entries: bytes32 = sha3(convert(index_entries, bytes32))\r\n    \r\n    assert _from != ZERO_ADDRESS\r\n    assert _for != ZERO_ADDRESS\r\n    assert msg.value >= self.price\r\n    self.register_entries[hash_index_entries] = register({owner1: _from, owner1_name: _fromName, owner2: _for, owner2_name: _forName, \r\n    message: message, private_message: privatenote, alive: True})\r\n    \r\n    self.register_publicmessage[index_entries] = message\r\n    self.register_identifier[_from] = hash_index_entries\r\n    \r\n    index_entries += 1\r\n    self.register_totalEntries = index_entries\r\n    log.Register(_from, _for, hash_index_entries)\r\n    \r\n# Function to deregister -> note it only closes the entry - removal is not possible\r\n@public\r\ndef deRegister(register_entry: bytes32):\r\n    assert self.register_entries[register_entry].owner1 == msg.sender or self.register_entries[register_entry].owner2 == msg.sender\r\n    self.register_entries[register_entry].alive = False\r\n\r\n#Function to find the identifier for a relationship \r\n@public\r\ndef findIdentifier():\r\n    log.Search(msg.sender, self.register_identifier[msg.sender])",
	"ContractName": "Vyper_contract",
	"CompilerVersion": "vyper:0.1.0b8"
}