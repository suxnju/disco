{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.23;\r\n\r\n/******************************************************************\r\n * AXNET Decentralized Exchange Smart Contract * \r\n * ***************************************************************/\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    \r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract Token {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address _owner) public constant returns (uint);\r\n    function allowance(address _owner, address _spender) public constant returns (uint);\r\n    \r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;  // 18 is the most common number of decimal places\r\n}\r\n\r\n\r\ncontract AXNETDEX is SafeMath, Owned {\r\n  address public feeAccount; //the account that will receive fees\r\n\r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n\r\n  mapping (address => bool) public admins;  //admins who is responsible for trading\r\n  \r\n  //mapping of order hash to mapping of uints (amount of order that has been filled)\r\n  mapping (bytes32 => uint256) public orderFills;\r\n  \r\n  //to make sure withdraw and trade will be done only once\r\n  mapping (bytes32 => bool) public withdrawn;\r\n  mapping (bytes32 => bool) public traded;\r\n  \r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n constructor() public {\r\n    feeAccount = msg.sender;\r\n  }\r\n\r\n  function() public {\r\n    revert();\r\n  }\r\n  \r\n  function setAdmin(address admin, bool isAdmin) public onlyOwner {\r\n    admins[admin] = isAdmin;\r\n  }\r\n  \r\n  modifier onlyAdmin {\r\n    require(msg.sender == owner || admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function changeFeeAccount(address feeAccount_) public onlyOwner {\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  function deposit() payable public {\r\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\r\n    emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address token, uint amount) public {\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    require(token!=0);\r\n    assert(Token(token).transferFrom(msg.sender, this, amount));\r\n    \r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function adminWithdraw(address token, uint amount, address user, uint nonce, uint8 v, bytes32 r, bytes32 s, uint feeWithdrawal) public onlyAdmin {\r\n    bytes32 hash = sha256(this, token, amount, user, nonce);\r\n    require(!withdrawn[hash]);\r\n    withdrawn[hash] = true;\r\n    \r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user);\r\n    \r\n    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\r\n\r\n    require(tokens[token][user] >= amount);\r\n    tokens[token][user] = safeSub(tokens[token][user], amount);\r\n    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\r\n    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\r\n\r\n    if (token == address(0)) {\r\n      assert(user.send(amount));\r\n    } else {\r\n      assert(Token(token).transfer(user, amount));\r\n    }\r\n    \r\n    emit Withdraw(token, user, amount, tokens[token][user]);\r\n  }\r\n\r\n  function balanceOf(address token, address user)  public view returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n  \r\n    /* uint values\r\n         0:amountGet, 1:amountGive, 2:expires, 3:nonce, 4:amount, 5:tradeNonce, 6:feeMake, 7:feeTake\r\n       addressses\r\n         0:tokenGet, 1:tokenGive, 2:maker, 3:taker\r\n     signature binary\r\n       v[0] rs[0] rs[1] : signature for order\r\n       v[1] rs[2] rs[3] : signature for trade\r\n     */\r\n  function trade(uint[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) public onlyAdmin {\r\n    bytes32 orderHash = sha256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\r\n    bytes32 tradeHash = sha256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\r\n    \r\n    require(!traded[tradeHash]);\r\n    traded[tradeHash] = true;\r\n    \r\n    require(safeAdd(orderFills[orderHash], tradeValues[4]) <= tradeValues[0]);\r\n    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[4]);\r\n    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]));\r\n    \r\n    tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]);\r\n    tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether));\r\n    tokens[tradeAddresses[0]][feeAccount] = safeAdd(tokens[tradeAddresses[0]][feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether));\r\n    tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]);\r\n    tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\r\n    tokens[tradeAddresses[1]][feeAccount] = safeAdd(tokens[tradeAddresses[1]][feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether));\r\n    orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]);\r\n  }\r\n\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s, address user) public onlyAdmin {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, user);\r\n    assert(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user);\r\n    orderFills[hash] = amountGet;\r\n    emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s);\r\n  }\r\n}",
	"ContractName": "AXNETDEX",
	"CompilerVersion": "v0.4.23+commit.124ca40d"
}