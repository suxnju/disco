{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.5.11;\r\n\r\ncontract Owned {\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    address payable owner;\r\n    address payable newOwner;\r\n    function changeOwner(address payable _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) view public returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Token is Owned,  ERC20 {\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n    mapping (address=>uint256) balances;\r\n    mapping (address=>mapping (address=>uint256)) allowed;\r\n    \r\n    function balanceOf(address _owner) view public returns (uint256 balance) {return balances[_owner];}\r\n    \r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\r\n        balances[msg.sender]-=_amount;\r\n        balances[_to]+=_amount;\r\n        emit Transfer(msg.sender,_to,_amount);\r\n        return true;\r\n    }\r\n  \r\n    function transferFrom(address _from,address _to,uint256 _amount) public returns (bool success) {\r\n        require (balances[_from]>=_amount&&allowed[_from][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\r\n        balances[_from]-=_amount;\r\n        allowed[_from][msg.sender]-=_amount;\r\n        balances[_to]+=_amount;\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n  \r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        allowed[msg.sender][_spender]=_amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract BonusToken is Token{\r\n    \r\n    constructor() public{\r\n        symbol = \"BOT\";\r\n        name = \"BonusToken\";\r\n        decimals = 8;\r\n        totalSupply = 0;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function rate() public view returns (uint eth){\r\n        return block.number;\r\n    }\r\n    \r\n    function sell(uint256 _amount) public returns (bool ok){\r\n        require(_amount>0&&balances[msg.sender]>=_amount&&_amount*block.number<=address(this).balance);\r\n        balances[msg.sender]-=_amount;\r\n        totalSupply-=_amount;\r\n        uint256 eth = _amount*block.number;\r\n        uint256 fee = eth*1/100;\r\n        msg.sender.transfer(eth-fee);\r\n        owner.transfer(fee);\r\n        return true;\r\n    }\r\n    \r\n    function () payable external {\r\n        if (msg.value>0) {\r\n          uint256 tkn = msg.value/block.number;\r\n          totalSupply+=tkn;\r\n          balances[msg.sender]+=tkn;\r\n        }\r\n    }\r\n}",
	"ContractName": "BonusToken",
	"CompilerVersion": "v0.5.11+commit.c082d0b4"
}