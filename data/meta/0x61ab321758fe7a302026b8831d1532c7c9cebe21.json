{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.4;\r\n\r\ncontract Registry {\r\n  address owner;\r\n  mapping (address => uint) public expirations;\r\n  uint public weiPerBlock;\r\n  uint public minBlockPurchase;\r\n\r\n  function Registry() {\r\n    owner = msg.sender;\r\n    // works out to about $7 per month\r\n    weiPerBlock = 100000000000;\r\n    // roughly 1 day worth of blocks at 20 sec transaction time\r\n    minBlockPurchase = 4320;\r\n  }\r\n\r\n  function () payable {\r\n    uint senderExpirationBlock = expirations[msg.sender];\r\n    if (senderExpirationBlock > 0 && senderExpirationBlock < block.number) {\r\n      // The sender already has credit, add to it\r\n      expirations[msg.sender] = senderExpirationBlock + blocksForWei(msg.value);\r\n    } else {\r\n      // The senders credit has either expired or the sender is unregistered\r\n      // Give them block credits starting from the current block\r\n      expirations[msg.sender] = block.number + blocksForWei(msg.value);\r\n    }\r\n  }\r\n\r\n  function blocksForWei(uint weiValue) returns (uint) {\r\n    assert(weiValue >= weiPerBlock * minBlockPurchase);\r\n    return weiValue / weiPerBlock;\r\n  }\r\n\r\n  function setWeiPerBlock(uint newWeiPerBlock) {\r\n    if (msg.sender == owner) weiPerBlock = newWeiPerBlock;\r\n  }\r\n\r\n  function setMinBlockPurchase(uint newMinBlockPurchase) {\r\n    if (msg.sender == owner) minBlockPurchase = newMinBlockPurchase;\r\n  }\r\n\r\n  function withdraw(uint weiValue) {\r\n    if (msg.sender == owner) owner.transfer(weiValue);\r\n  }\r\n\r\n}",
	"ContractName": "Registry",
	"CompilerVersion": "v0.4.13+commit.fb4cb1a"
}