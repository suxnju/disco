{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.22;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n  string public symbol;\r\n}\r\n\r\ncontract TradexOne is SafeMath {\r\n  address public admin; //the admin address\r\n  address public feeAccount; //the account that will receive fees\r\n  mapping (address => uint) public feeMake; //percentage times (1 ether) (sell fee)\r\n  mapping (address => uint) public feeTake; //percentage times (1 ether) (buy fee)\r\n  mapping (address => uint) public feeDeposit; //percentage times (1 ether)\r\n  mapping (address => uint) public feeWithdraw; //percentage times (1 ether)\r\n  \r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  mapping (address => bool) public activeTokens;\r\n  mapping (address => uint) public tokensMinAmountBuy;\r\n  mapping (address => uint) public tokensMinAmountSell;\r\n\r\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n  event ActivateToken(address token, string symbol);\r\n  event DeactivateToken(address token, string symbol);\r\n\r\n  function TradexOne(address admin_, address feeAccount_) {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  function() {\r\n    throw;\r\n  }\r\n  \r\n  \r\n  function activateToken(address token) {\r\n    if (msg.sender != admin) throw;\r\n    activeTokens[token] = true;\r\n    ActivateToken(token, Token(token).symbol());\r\n  }\r\n  function deactivateToken(address token) {\r\n    if (msg.sender != admin) throw;\r\n    activeTokens[token] = false;\r\n    DeactivateToken(token, Token(token).symbol());\r\n  }\r\n  function isTokenActive(address token) constant returns(bool) {\r\n    if (token == 0)\r\n      return true; // eth is always active\r\n    return activeTokens[token];\r\n  }\r\n  \r\n  function setTokenMinAmountBuy(address token, uint amount) {\r\n    if (msg.sender != admin) throw;\r\n    tokensMinAmountBuy[token] = amount;\r\n  }\r\n  function setTokenMinAmountSell(address token, uint amount) {\r\n    if (msg.sender != admin) throw;\r\n    tokensMinAmountSell[token] = amount;\r\n  }\r\n  \r\n  function setTokenFeeMake(address token, uint feeMake_) {\r\n    if (msg.sender != admin) throw;\r\n    feeMake[token] = feeMake_;\r\n  }\r\n  function setTokenFeeTake(address token, uint feeTake_) {\r\n    if (msg.sender != admin) throw;\r\n    feeTake[token] = feeTake_;\r\n  }\r\n  function setTokenFeeDeposit(address token, uint feeDeposit_) {\r\n    if (msg.sender != admin) throw;\r\n    feeDeposit[token] = feeDeposit_;\r\n  }\r\n  function setTokenFeeWithdraw(address token, uint feeWithdraw_) {\r\n    if (msg.sender != admin) throw;\r\n    feeWithdraw[token] = feeWithdraw_;\r\n  }\r\n  \r\n  \r\n  function changeAdmin(address admin_) {\r\n    if (msg.sender != admin) throw;\r\n    admin = admin_;\r\n  }\r\n\r\n  function changeFeeAccount(address feeAccount_) {\r\n    if (msg.sender != admin) throw;\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  function deposit() payable {\r\n    uint feeDepositXfer = safeMul(msg.value, feeDeposit[0]) / (1 ether);\r\n    uint depositAmount = safeSub(msg.value, feeDepositXfer);\r\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], depositAmount);\r\n    tokens[0][feeAccount] = safeAdd(tokens[0][feeAccount], feeDepositXfer);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function withdraw(uint amount) {\r\n    if (tokens[0][msg.sender] < amount) throw;\r\n    uint feeWithdrawXfer = safeMul(amount, feeWithdraw[0]) / (1 ether);\r\n    uint withdrawAmount = safeSub(amount, feeWithdrawXfer);\r\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\r\n    tokens[0][feeAccount] = safeAdd(tokens[0][feeAccount], feeWithdrawXfer);\r\n    if (!msg.sender.call.value(withdrawAmount)()) throw;\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address token, uint amount) {\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    if (token==0) throw;\r\n    if (!isTokenActive(token)) throw;\r\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n    uint feeDepositXfer = safeMul(amount, feeDeposit[token]) / (1 ether);\r\n    uint depositAmount = safeSub(amount, feeDepositXfer);\r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], depositAmount);\r\n    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], feeDepositXfer);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function withdrawToken(address token, uint amount) {\r\n    if (token==0) throw;\r\n    if (tokens[token][msg.sender] < amount) throw;\r\n    uint feeWithdrawXfer = safeMul(amount, feeWithdraw[token]) / (1 ether);\r\n    uint withdrawAmount = safeSub(amount, feeWithdrawXfer);\r\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], feeWithdrawXfer);\r\n    if (!Token(token).transfer(msg.sender, withdrawAmount)) throw;\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\r\n    if (!isTokenActive(tokenGet) || !isTokenActive(tokenGive)) throw;\r\n    if (amountGet < tokensMinAmountBuy[tokenGet]) throw;\r\n    if (amountGive < tokensMinAmountSell[tokenGive]) throw;\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    orders[msg.sender][hash] = true;\r\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\r\n  }\r\n\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\r\n    if (!isTokenActive(tokenGet) || !isTokenActive(tokenGive)) throw;\r\n    //amount is in amountGet terms\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\r\n      block.number <= expires &&\r\n      safeAdd(orderFills[user][hash], amount) <= amountGet\r\n    )) throw;\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\r\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\r\n  }\r\n\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n    uint feeMakeXfer = safeMul(amount, feeMake[tokenGet]) / (1 ether);\r\n    uint feeTakeXfer = safeMul(amount, feeTake[tokenGet]) / (1 ether);\r\n    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\r\n    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(amount, feeMakeXfer));\r\n    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeAdd(feeMakeXfer, feeTakeXfer));\r\n    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\r\n    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\r\n  }\r\n\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\r\n    if (!isTokenActive(tokenGet) || !isTokenActive(tokenGive)) return false;\r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n    )) return false;\r\n    return true;\r\n  }\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\r\n      block.number <= expires\r\n    )) return 0;\r\n    uint available1 = safeSub(amountGet, orderFills[user][hash]);\r\n    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\r\n    if (available1<available2) return available1;\r\n    return available2;\r\n  }\r\n\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) throw;\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n}",
	"ContractName": "TradexOne",
	"CompilerVersion": "v0.4.25+commit.59dbf8f1"
}