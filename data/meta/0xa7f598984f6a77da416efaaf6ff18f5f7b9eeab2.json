{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.16;\r\n\r\npragma solidity ^0.4.16;\r\n\r\ncontract Permissions {\r\n\r\n\taddress ownerAddress;\r\n\taddress storageAddress;\r\n\taddress callerAddress;\r\n\r\n\tfunction Permissions() public {\r\n\t\townerAddress = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == ownerAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyCaller() {\r\n\t\trequire(msg.sender == callerAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction getOwner() view external returns (address) {\r\n\t\treturn ownerAddress;\r\n\t}\r\n\r\n\tfunction getStorageAddress() view external returns (address) {\r\n\t\treturn storageAddress;\r\n\t}\r\n\r\n\tfunction getCaller() view external returns (address) {\r\n\t\treturn callerAddress;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) external onlyOwner {\r\n\t\tif (newOwner != address(0)) {\r\n\t\t\t\townerAddress = newOwner;\r\n\t\t}\r\n\t}\r\n\tfunction newStorage(address _new) external onlyOwner {\r\n\t\tif (_new != address(0)) {\r\n\t\t\t\tstorageAddress = _new;\r\n\t\t}\r\n\t}\r\n\tfunction newCaller(address _new) external onlyOwner {\r\n\t\tif (_new != address(0)) {\r\n\t\t\t\tcallerAddress = _new;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract Creatures is Permissions {\r\n\tstruct Creature {\r\n\t\tuint16 species;\r\n\t\tuint8 subSpecies;\r\n\t\tuint8 eyeColor;\r\n\t\tuint64 timestamp;\r\n\t}\r\n\tCreature[] creatures;\r\n\r\n\tmapping (uint256 =>\taddress) public creatureIndexToOwner;\r\n\tmapping (address => uint256) ownershipTokenCount;\r\n\r\n\tevent CreateCreature(uint256 id, address indexed owner);\r\n\tevent Transfer(address _from, address _to, uint256 creatureID);\r\n\r\n\tfunction add(address _owner, uint16 _species, uint8 _subSpecies, uint8 _eyeColor) external onlyCaller {\r\n\t\t// do checks in caller function\r\n\t\tCreature memory _creature = Creature({\r\n\t\t\tspecies: _species,\r\n\t\t\tsubSpecies: _subSpecies,\r\n\t\t\teyeColor: _eyeColor,\r\n\t\t\ttimestamp: uint64(now)\r\n\t\t});\r\n\t\tuint256 newCreatureID = creatures.push(_creature) - 1;\r\n\t\ttransfer(0, _owner, newCreatureID);\r\n\t\tCreateCreature(newCreatureID, _owner);\r\n\t}\r\n\tfunction getCreature(uint256 id) external view returns (address, uint16, uint8, uint8, uint64) {\r\n\t\tCreature storage c = creatures[id];\r\n\t\taddress owner = creatureIndexToOwner[id];\r\n\t\treturn (\r\n\t\t\towner,\r\n\t\t\tc.species,\r\n\t\t\tc.subSpecies,\r\n\t\t\tc.eyeColor,\r\n\t\t\tc.timestamp\r\n\t\t);\r\n\t}\r\n\tfunction transfer(address _from, address _to, uint256 _tokenId) public onlyCaller {\r\n\t\t// do checks in caller function\r\n\t\tcreatureIndexToOwner[_tokenId] = _to;\r\n\t\tif (_from != address(0)) {\r\n\t\t\townershipTokenCount[_from]--;\r\n\t\t}\r\n\t\townershipTokenCount[_to]++;\r\n\t\tTransfer(_from, _to, _tokenId);\r\n\t}\r\n}\r\n\r\n\r\ncontract CreaturesInterface is Permissions {\r\n\r\n\tmapping (uint8 => uint256) public creatureCosts;\r\n\r\n\tfunction CreaturesInterface() public {\r\n\t\tcreatureCosts[0] = .10 ether;\r\n\t\tcreatureCosts[1] = .25 ether;\r\n\t\tcreatureCosts[2] = .12 ether;\r\n\t\tcreatureCosts[3] = .50 ether;\r\n\t\tcreatureCosts[4] = .10 ether;\r\n\t\tcreatureCosts[5] = 2.0 ether;\r\n\t\tcreatureCosts[6] = 2.0 ether;\r\n\t\tcreatureCosts[7] = 1.0 ether;\r\n\t\tcreatureCosts[8] = .01 ether;\r\n\t\tcreatureCosts[9] = .025 ether;\r\n\t}\r\n\r\n\tfunction addCreature(uint16 _species, uint8 _subSpecies, uint8 _eyeColor) external payable {\r\n\t\trequire(_species == 0); // only one species available for now\r\n\t\trequire(creatureCosts[_subSpecies] > 0);\r\n\t\trequire(msg.value >= creatureCosts[_subSpecies]);\r\n\t\tCreatures creatureStorage = Creatures(storageAddress);\r\n\t\tcreatureStorage.add(msg.sender, _species, _subSpecies, _eyeColor);\r\n\t}\r\n    function withdrawBalance() external onlyOwner {\r\n        ownerAddress.transfer(this.balance);\r\n    }\r\n}",
	"ContractName": "CreaturesInterface",
	"CompilerVersion": "v0.4.19+commit.c4cbbb05"
}