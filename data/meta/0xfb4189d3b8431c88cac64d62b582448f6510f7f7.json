{
	"Language": "Solidity",
	"Source": "pragma solidity 0.5.7;\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() onlyPendingOwner public {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\ncontract FastnFurious is Ownable {\r\n    using SafeMath for uint;\r\n    \r\n    // round => winner\r\n    mapping(uint => address payable) public winners;\r\n    \r\n    // round => gain\r\n    mapping(uint => uint) public balances;\r\n    \r\n    uint public minBet = 0.1 ether; // 0.1 ether;\r\n    \r\n    uint public startTime = 1554076800; // 04.01.2019 00:00:00\r\n    uint public roundTime = 60; // 1 min in sec\r\n    \r\n    address payable public wallet;\r\n    address payable public jackpot;\r\n    \r\n    uint public pool;\r\n    \r\n    uint public walletPercent = 20;\r\n    uint public nextRoundPercent = 15;\r\n    uint public jackpotPercent = 15;\r\n    uint public lastRound;\r\n        \r\n    constructor (address payable _wallet, address payable _jackpot) public {\r\n        require(_wallet != address(0));\r\n        require(_jackpot != address(0));\r\n        \r\n    \twallet = _wallet;\r\n    \tjackpot = _jackpot;  \r\n    }\r\n    \r\n    function () external payable {\r\n        require(gasleft() > 150000);\r\n        setBet(msg.sender);\r\n    }\r\n    \r\n    function setBet(address payable _player) public payable {\r\n        require(msg.value >= minBet);\r\n        \r\n        uint currentRound = getCurrentRound();\r\n        \r\n        if (currentRound > 1 && balances[currentRound] == 0) {\r\n            uint gain = balances[lastRound];\r\n        \tbalances[lastRound] = 0;\r\n        \tbalances[currentRound] = balances[currentRound].add(pool);\r\n        \tpool = 0;\r\n    \r\n            address payable winner = getWinner(lastRound); \r\n            winner.transfer(gain);\r\n        }\r\n        \r\n        lastRound = currentRound;\r\n        \r\n        uint amount = msg.value;\r\n        uint toWallet = amount.mul(walletPercent).div(100);\r\n        uint toNextRound = amount.mul(nextRoundPercent).div(100);\r\n        uint toJackpot = amount.mul(jackpotPercent).div(100);\r\n\r\n        winners[currentRound] = _player;\r\n        \r\n        balances[currentRound] = balances[currentRound].add(amount).sub(toWallet).sub(toNextRound).sub(toJackpot);\r\n        pool = pool.add(toNextRound);\r\n        \r\n        jackpot.transfer(toJackpot);\r\n        wallet.transfer(toWallet);\r\n    }\r\n    \r\n    function getWinner(uint _round) public view returns (address payable) {\r\n        if (winners[_round] != address(0)) return winners[_round];\r\n        else return wallet;\r\n    }\r\n\r\n    function changeRoundTime(uint _time) onlyOwner public {\r\n        roundTime = _time;\r\n    }\r\n    \r\n    function changeStartTime(uint _time) onlyOwner public {\r\n        startTime = _time;    \r\n    }\r\n    \r\n    function changeWallet(address payable _wallet) onlyOwner public {\r\n        wallet = _wallet;\r\n    }\r\n\r\n    function changeJackpot(address payable _jackpot) onlyOwner public {\r\n        jackpot = _jackpot;\r\n    }\r\n    \r\n    function changeMinimalBet(uint _minBet) onlyOwner public {\r\n        minBet = _minBet;\r\n    }\r\n    \r\n    function changePercents(uint _toWinner, uint _toNextRound, uint _toWallet, uint _toJackPot) onlyOwner public {\r\n        uint total = _toWinner.add(_toNextRound).add(_toWallet).add(_toJackPot);\r\n        require(total == 100);\r\n        \r\n        walletPercent = _toWallet;\r\n        nextRoundPercent = _toNextRound;\r\n        jackpotPercent = _toJackPot;\r\n    }\r\n    \r\n    function getCurrentRound() public view returns (uint) {\r\n        return now.sub(startTime).div(roundTime).add(1); // start round is 1\r\n    }\r\n    \r\n    function getPreviosRound() public view returns (uint) {\r\n        return getCurrentRound().sub(1);    \r\n    }\r\n    \r\n    function getRoundBalance(uint _round) public view returns (uint) {\r\n        return balances[_round];\r\n    }\r\n    \r\n    function getRoundByTime(uint _time) public view returns (uint) {\r\n        return _time.sub(startTime).div(roundTime);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}",
	"ContractName": "FastnFurious",
	"CompilerVersion": "v0.5.7+commit.6da8b019"
}