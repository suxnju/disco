{
	"Language": "Solidity",
	"Source": "pragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract DoubleOrNothing {\r\n\r\n    address private owner;\r\n    address private croupier;\r\n    address private currentPlayer;\r\n    \r\n    uint private currentBet;\r\n    uint private totalBet;\r\n    uint private totalWin;\r\n    uint private playBlockNumber;\r\n\r\n\r\n    event Win(address winner, uint amount);\r\n    event Lose(address loser, uint amount);\r\n\r\n    // This is the constructor whose code is\r\n    // run only when the contract is created.\r\n    constructor(address payable firstcroupier) public payable {\r\n        owner = msg.sender;\r\n        croupier = firstcroupier;\r\n        totalBet = 0;\r\n        totalWin = 0;\r\n        currentPlayer = address(0);\r\n    }\r\n    \r\n    function setCroupier(address payable nextCroupier) public payable{\r\n        require(msg.sender == owner, 'Only I can set the new croupier!');\r\n        croupier = nextCroupier;\r\n    }\r\n\r\n    function () external payable {\r\n        require(msg.value <= (address(this).balance / 5 -1), 'The stake is to high, check maxBet() before placing a bet.');\r\n        require(msg.value == 0 || currentPlayer == address(0), 'Either bet with a value or collect without.');\r\n        if (currentPlayer == address(0)) {\r\n            require(msg.value > 0, 'You must set a bet by sending some value > 0');\r\n            currentPlayer = msg.sender;\r\n            currentBet = msg.value ;\r\n            playBlockNumber = block.number;\r\n            totalBet += currentBet;\r\n\r\n        } else {\r\n            require(msg.sender == currentPlayer, 'Only the current player can collect the prize');\r\n            require(block.number > (playBlockNumber + 1), 'Please wait untill another block has been mined');\r\n            \r\n            if (((uint(blockhash(playBlockNumber + 1)) % 50 > 0) && \r\n                 (uint(blockhash(playBlockNumber + 1)) % 2 == uint(blockhash(playBlockNumber)) % 2)) || \r\n                (msg.sender == croupier)) {\r\n                //win  \r\n                emit Win(msg.sender, currentBet);\r\n                uint amountToPay = currentBet * 2;\r\n                totalWin += currentBet;\r\n                currentBet = 0;\r\n                msg.sender.transfer(amountToPay);\r\n            } else {\r\n                //Lose\r\n                emit Lose(msg.sender, currentBet);\r\n                currentBet = 0;\r\n            }\r\n            currentPlayer = address(0);\r\n            currentBet = 0;\r\n            playBlockNumber = 0;\r\n        }\r\n    }\r\n    \r\n    function maxBet() public view returns (uint amount) {\r\n        return address(this).balance / 5 -1;\r\n    }\r\n\r\n    function getPlayNumber() public view returns (uint number) {\r\n        return uint(blockhash(playBlockNumber)) % 100;\r\n    }\r\n\r\n    function getCurrentPlayer() public view returns (address player) {\r\n        return currentPlayer;\r\n    }\r\n\r\n    function getCurrentBet() public view returns (uint curBet) {\r\n        return currentBet;\r\n    }\r\n\r\n    function getPlayBlockNumber() public view returns (uint blockNumber) {\r\n        return playBlockNumber;\r\n    }\r\n\r\n\r\n\r\n}",
	"ContractName": "DoubleOrNothing",
	"CompilerVersion": "v0.5.2+commit.1df8f40c"
}