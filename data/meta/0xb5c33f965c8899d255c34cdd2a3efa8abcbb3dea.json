{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.11;\r\n\r\ncontract ERC20Basic\r\n{\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns(uint256);\r\n    function transfer(address to,uint256 value) public returns(bool);\r\n    event Transfer(address indexedfrom,address indexedto,uint256 value);\r\n}\r\ncontract IERC20 is ERC20Basic\r\n{\r\n    function allowance(address owner,address spender) public constant returns(uint256);\r\n    function transferFrom(address from,address to,uint256 value) public returns(bool);\r\n    function approve(address spender,uint256 value) public returns(bool);\r\n    event Approval(address indexedowner,address indexedspender,uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256){\r\n        uint256 c=a*b;\r\n        assert(a==0||c/a==b);\r\n        return c;\r\n    }\r\n    function div(uint256 a,uint256 b) internal constant returns(uint256)\r\n    {\r\n        //assert(b>0);//Solidityautomaticallythrowswhendividingby0\r\n        uint256 c=a/b;\r\n        //assert(a==b*c+a%b);//Thereisnocaseinwhichthisdoesn'thold\r\n        return c;\r\n    }\r\n    function sub(uint256 a,uint256 b) internal constant returns(uint256)\r\n    {\r\n        assert(b<=a);\r\n        return a-b;\r\n    }\r\n    function add(uint256 a,uint256 b) internal constant returns(uint256)\r\n    {\r\n        uint256 c=a+b;\r\n        assert(c>=a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract KPRToken is IERC20 {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n\r\n    \r\n    //public variables\r\n    string public constant symbol=\"KPR\"; \r\n    string public constant name=\"KPR Coin\"; \r\n    uint8 public constant decimals=18;\r\n\r\n    //1 ETH = 2,500 KPR\r\n    uint56 public  RATE = 2500;\r\n\r\n    //totalsupplyoftoken \r\n    uint public totalSupply = 100000000 * 10 ** uint(decimals);\r\n    \r\n    uint public buyabletoken = 90000000 * 10 ** uint(decimals);\r\n    //where the ETH goes \r\n    address public owner;\r\n    \r\n    //map the addresses\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    // 1514764800 : Jan 1 2018\r\n    uint phase1starttime = 1517443200; // Phase 1 Start Date Feb 1 2018\r\n    uint phase1endtime = 1519257600;  // Phase 1 End Date Feb 22 2018\r\n    uint phase2starttime = 1519862400;  // Phase 2 Start Date March 1 2018\r\n    uint phase2endtime = 1521676800; // Phase 2 End Date March 22 2018\r\n    uint phase3starttime = 1522540800;  // Phase 3 Start Date May 1 2018\r\n    uint phase3endtime = 1524355200; // Phase 3 End Date May 22 2018\r\n    \r\n  \r\n    //create token function = check\r\n\r\n    function() payable {\r\n        buyTokens();\r\n    }\r\n\r\n    function KPRToken() {\r\n        owner = msg.sender;\r\n        balances[owner] = totalSupply;\r\n    }\r\n\r\n    function buyTokens() payable {\r\n        \r\n        require(msg.value > 0);\r\n        require(now > phase1starttime && now < phase3endtime);\r\n        uint256 tokens;\r\n    \r\n        if (now > phase1starttime && now < phase1endtime){\r\n            \r\n            RATE = 3000;\r\n            setPrice(msg.sender, msg.value);\r\n        } else if(now > phase2starttime && now < phase2endtime){\r\n            RATE = 2000;\r\n            setPrice(msg.sender, msg.value);\r\n            // tokens = msg.value.mul(RATE);\r\n            // require(tokens < buyabletoken);\r\n            // balances[msg.sender]=balances[msg.sender].add(tokens);\r\n            // balances[owner] = balances[owner].sub(tokens);\r\n            // buyabletoken = buyabletoken.sub(tokens);\r\n            // owner.transfer(msg.value);\r\n            \r\n        } else if(now > phase3starttime && now < phase3endtime){\r\n            \r\n            RATE = 1000;\r\n            setPrice(msg.sender, msg.value);\r\n        }\r\n    }\r\n    \r\n    function setPrice(address receipt, uint256 value){\r\n        uint256 tokens;\r\n        tokens = value.mul(RATE);\r\n        require(tokens < buyabletoken);\r\n        balances[receipt]=balances[receipt].add(tokens);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        buyabletoken = buyabletoken.sub(tokens);\r\n        owner.transfer(value);\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns(uint256 balance) {\r\n        \r\n        return balances[_owner];\r\n        \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns(bool success) {\r\n        \r\n        //require is the same as an if statement = checks \r\n        require(balances[msg.sender] >= _value && _value > 0 );\r\n        \r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        \r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        \r\n        //checking if the spender has permission to spend and how much \r\n        require( allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);\r\n        \r\n        //updating the spenders balance \r\n        balances[_from] = balances[_from].sub(_value); \r\n        balances[_to] = balances[_to].add(_value); \r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); \r\n        Transfer(_from, _to, _value); \r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns(bool success) {\r\n        \r\n        //if above require is true,approve the spending \r\n        allowed[msg.sender][_spender] = _value; \r\n        Approval(msg.sender, _spender, _value); \r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n        \r\n        return allowed[_owner][_spender];\r\n        \r\n    }\r\n    \r\n    event Transfer(address indexed_from, address indexed_to, uint256 _value);\r\n    event Approval(address indexed_owner, address indexed_spender, uint256 _value);\r\n    \r\n    \r\n}",
	"ContractName": "KPRToken",
	"CompilerVersion": "v0.4.11+commit.68ef5810"
}