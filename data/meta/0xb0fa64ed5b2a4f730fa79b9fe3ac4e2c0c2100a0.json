{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.25;\r\n\r\ncontract IMDEX {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    function transfer(address _to, uint256 _value)public returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract IMDEXchange is SafeMath {\r\n\r\n  address public owner;\r\n  mapping (address => uint256) public invalidOrder;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function IMDEXsetOwner(address newOwner)public onlyOwner {\r\n    emit SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  function IMDEXinvalidateOrdersBefore(address user, uint256 nonce) public onlyAdmin {\r\n    require(nonce > invalidOrder[user]);\r\n    invalidOrder[user] = nonce;\r\n  }\r\n\r\n  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\r\n  mapping (address => bool) public admins;\r\n  mapping (address => uint256) public lastActiveTransaction;\r\n  address public feeAccount;\r\n  uint256 public inactivityReleasePeriod;\r\n  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give);\r\n  event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n  event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n\r\n  function IMDEXsetInactivityReleasePeriod(uint256 expiry) public onlyAdmin returns (bool success) {\r\n    require(expiry < 1000000);\r\n    inactivityReleasePeriod = expiry;\r\n    return true;\r\n  }\r\n\r\n  constructor(address feeAccount_) public {\r\n    owner = msg.sender;\r\n    feeAccount = feeAccount_;\r\n    inactivityReleasePeriod = 100000;\r\n  }\r\n\r\n  function IMDEXsetAdmin(address admin, bool isAdmin) public onlyOwner {\r\n    admins[admin] = isAdmin;\r\n  }\r\n\r\n  modifier onlyAdmin {\r\n   require(msg.sender == owner && admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function() external {\r\n    revert();\r\n  }\r\n\r\n\r\n\r\n  function IMDEXdepositToken(address token, uint256 amount) public {\r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    require(IMDEX(token).transferFrom(msg.sender, this, amount));\r\n    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function IMDEXdeposit() public payable {\r\n    tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\nfunction IMDEXwithdrawToken(address token, uint256 amount) public returns (bool) {\r\n    require(safeSub(block.number, lastActiveTransaction[msg.sender]) > inactivityReleasePeriod);\r\n    require(tokens[token][msg.sender] > amount);\r\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n    if (token == address(0)) {\r\n      msg.sender.transfer(amount);\r\n    } else {\r\n      require(IMDEX(token).transfer(msg.sender, amount));\r\n    }\r\n    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function IMDEXadminWithdraw(address token, uint256 amount, address user, uint256 feeWithdrawal) public onlyAdmin returns (bool) {\r\n    if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\r\n    require(tokens[token][user] > amount);\r\n    tokens[token][user] = safeSub(tokens[token][user], amount);\r\n    tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\r\n    amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\r\n    if (token == address(0)) {\r\n      user.transfer(amount);\r\n    } else {\r\n      require(IMDEX(token).transfer(user, amount));\r\n    }\r\n    lastActiveTransaction[user] = block.number;\r\n    emit Withdraw(token, user, amount, tokens[token][user]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) public constant returns (uint256) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  function IMDEXtrade(uint256[8] X, address[4] Y) public onlyAdmin returns (bool) {\r\n    /* amount is in amountBuy terms */\r\n    /* X\r\n       [0] amountBuy\r\n       [1] amountSell\r\n       [2] expires\r\n       [3] nonce\r\n       [4] amount\r\n       [5] tradeNonce\r\n       [6] feeMake\r\n       [7] feeTake\r\n     Y\r\n       [0] tokenBuy\r\n       [1] tokenSell\r\n       [2] maker\r\n       [3] taker\r\n     */\r\n    require(invalidOrder[Y[2]] < X[3]);\r\n    if (X[6] > 100 finney) X[6] = 100 finney;\r\n    if (X[7] > 100 finney) X[7] = 100 finney;\r\n    require(tokens[Y[0]][Y[3]] > X[4]);\r\n    require(tokens[Y[1]][Y[2]] > (safeMul(X[1], X[4]) / X[0]));\r\n    tokens[Y[0]][Y[3]] = safeSub(tokens[Y[0]][Y[3]], X[4]);\r\n    tokens[Y[0]][Y[2]] = safeAdd(tokens[Y[0]][Y[2]], safeMul(X[4], ((1 ether) - X[6])) / (1 ether));\r\n    tokens[Y[0]][feeAccount] = safeAdd(tokens[Y[0]][feeAccount], safeMul(X[4], X[6]) / (1 ether));\r\n    tokens[Y[1]][Y[2]] = safeSub(tokens[Y[1]][Y[2]], safeMul(X[1], X[4]) / X[0]);\r\n    tokens[Y[1]][Y[3]] = safeAdd(tokens[Y[1]][Y[3]], safeMul(safeMul(((1 ether) - X[7]), X[1]), X[4]) / X[0] / (1 ether));\r\n    tokens[Y[1]][feeAccount] = safeAdd(tokens[Y[1]][feeAccount], safeMul(safeMul(X[7], X[1]), X[4]) / X[0] / (1 ether));\r\n    lastActiveTransaction[Y[2]] = block.number;\r\n    lastActiveTransaction[Y[3]] = block.number;\r\n  }\r\n}",
	"ContractName": "IMDEXchange",
	"CompilerVersion": "v0.4.25+commit.59dbf8f1"
}