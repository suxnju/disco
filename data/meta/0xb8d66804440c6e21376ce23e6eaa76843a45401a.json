{
	"Language": "Solidity",
	"Source": "pragma solidity 0.5.3; /*\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n\r\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\r\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\r\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\r\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\r\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\r\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\r\n                                                                                        \r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'DeposiToken (DT10)' contract with following functionalities:\r\n//      => Higher control of owner\r\n//      => SafeMath implementation \r\n//      => Referral system - 3 level\r\n//\r\n// Name             : DeposiToken\r\n// Symbol           : DT10\r\n// Decimals         : 15\r\n//\r\n// Copyright (c) 2018 FIRST DECENTRALIZED DEPOSIT PLATFORM ( https://fddp.io )\r\n// Contract designed by: EtherAuthority ( https://EtherAuthority.io ) \r\n// ----------------------------------------------------------------------------\r\n*/ \r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function subsafe(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if(b <= a){\r\n        return a - b;\r\n    }else{\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract DepositToken_10 {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    string public constant name = \"DeposiToken\";\r\n    \r\n    string public constant symbol = \"DT10\";\r\n    \r\n    uint32 public constant decimals = 15;\r\n    \r\n    uint public _money = 0;\r\n    uint public _tokens = 0;\r\n    uint public _sellprice;\r\n    \r\n    // \u0410\u0434\u0440\u0435\u0441 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u0410\u043a\u0446\u0438\u0439\r\n    address payable public theStocksTokenContract;\r\n    \r\n    // \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0431\u0430\u043b\u0430\u043d\u0441 \u043d\u0430 \u0441\u0447\u0435\u0442\u0430\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\n    \r\n    mapping (address => uint) private balances;\r\n    \r\n    event FullEventLog(\r\n        address indexed user,\r\n        bytes32 status,\r\n        uint sellprice,\r\n        uint buyprice, \r\n        uint time,\r\n        uint tokens,\r\n        uint ethers);\r\n        \r\n    \r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value);\r\n        \r\n    // OK\r\n    constructor (address payable _tstc) public {\r\n        uint s = 10**13; // start price\r\n        _sellprice = s.mul(90).div(100);\r\n        theStocksTokenContract = _tstc;\r\n        \r\n        /* 1000 token belongs to the contract */\r\n        uint _value = 1000 * 10**15; \r\n        \r\n        _tokens += _value;\r\n        balances[address(this)] += _value;\r\n        \r\n        emit Transfer(address(0x0), address(this), _value);\r\n    }\r\n    \r\n    // OK\r\n    function totalSupply () public view returns (uint256 tokens) {\r\n        return _tokens;\r\n    }\r\n    \r\n    // OK\r\n    function balanceOf(address addr) public view returns(uint){\r\n        return balances[addr];\r\n    }\r\n    \r\n    // OK\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        address addressContract = address(this);\r\n        require(_to == addressContract);\r\n        sell(_value);\r\n        success = true;\r\n    }\r\n    \r\n    // OK\r\n    function () external payable {\r\n        buy(address(0x0));\r\n    }\r\n    \r\n    \r\n    //***************************************************//\r\n    //--------------- REFERAL SYSTEM CODE ---------------//\r\n    //***************************************************//\r\n    \r\n    /** TECHNICAL SPECIFICATIONS\r\n     * \r\n     * Because this is multi-level (3 level) referral system, we have to fix referrals.\r\n     * Which means once a user is fixed under someone as referral, then that can not be changed.\r\n     * Referral will be fixed at their first deposit.\r\n     * This also means. If a person have used referral link to deposit and got fixed. Then if he does not use any links to deposit again, referral bonus paid to their referrers.\r\n     * \r\n     * \r\n     * USE CASES\r\n     * \r\n     * Case 1: depositor have used referral links, as well as depositor has existing direct referrer.\r\n     * In this case, ether will be sent to existing referrer, it will ignore the new link he used.\r\n     * \r\n     * Case 2: depositor has existing referrer/up-line/direct sponsor, but he did not use any referrer link or sent ether directly to smart contract.\r\n     * In this case, ether will be sent to existing referrer.\r\n     * \r\n     * Case 3: depositor does not have any existing direct referrer, but used referral link.\r\n     * In this case, referral bonus will be paid to address in the referral link.\r\n     * \r\n     * All other cases apart from above, referral bonus will not be paid to anyone.\r\n     * And Entire platform fee (5% of deposit) will be sent to stock contract.\r\n     */\r\n    \r\n    /* Mapping to track referrer. The second address is the address of referrer, the Up-line/ Sponsor */\r\n    mapping (address => address payable) public referrers;\r\n    \r\n    /* Mapping to track referrer bonus for all the referrers */\r\n    mapping (address => uint) public referrerBonusBalance;\r\n    \r\n    /* Events to track ether transfer to referrers */\r\n    event ReferrerBonus(address indexed referer, address indexed depositor, uint256 depositAmount , uint256 etherReceived, uint256 timestamp );\r\n    \r\n    /* Events to track referral bonus claims */\r\n    event ReferralBonusClaim(address indexed referrar, uint256 bonus, uint256 timestamp);\r\n    /* Function to distribute bonuses to referrers, as well as calculating finaPlatformFee */\r\n    function distributeReferrerBonus(address payable _directReferrer, uint platformFee) internal returns (uint){\r\n        \r\n        // 60% of the Platform fee will be distributed to referrers, which is 3% of deposited ether\r\n        uint finaPlatformFee = platformFee;\r\n        \r\n        // Sending ether to level 1 (direct) referrer and deducting that amount from platformFee\r\n        uint _valueLevel1 = platformFee.mul(40).div(100);\r\n        referrerBonusBalance[_directReferrer] += _valueLevel1;  //40% of Platform Fee, equivilent to 2% of deposited ether\r\n        finaPlatformFee = finaPlatformFee.sub(_valueLevel1);\r\n        emit ReferrerBonus(_directReferrer, msg.sender, msg.value , _valueLevel1, now );\r\n    \r\n        \r\n        // If there is level 2 referrer, then sending ether to him/her as well\r\n        if(referrers[_directReferrer] != address(0x0)){\r\n            // Sending ether to level 2 referrer and deducting that amount from platformFee\r\n            uint _valueLevel2 = platformFee.mul(10).div(100);\r\n            referrerBonusBalance[referrers[_directReferrer]] += _valueLevel2;  //10% of Platform Fee, equivilent to 0.5% of deposited ether\r\n            finaPlatformFee = finaPlatformFee.sub(_valueLevel2);\r\n            emit ReferrerBonus(referrers[_directReferrer], msg.sender, msg.value , _valueLevel2, now );\r\n        }\r\n        \r\n        // If there is level 3 referrer, then sending ether to him/her as well\r\n        if(referrers[referrers[_directReferrer]] != address(0x0)){\r\n            // Sending ether to level 2 referrer and deducting that amount from platformFee\r\n            uint _valueLevel3 = platformFee.mul(10).div(100);\r\n            referrerBonusBalance[referrers[referrers[_directReferrer]]] += _valueLevel3;  //10% of Platform Fee, equivilent to 0.5% of deposited ether\r\n            finaPlatformFee = finaPlatformFee.sub(_valueLevel3);\r\n            emit ReferrerBonus(referrers[referrers[_directReferrer]], msg.sender, msg.value , _valueLevel3, now );\r\n        }\r\n        \r\n        // Returns final platform fee which would be sent to stock contract\r\n        return finaPlatformFee;\r\n    }\r\n    \r\n    /* Function will allow users to withdraw their referrer bonus  */\r\n    function claimReferrerBonus() public {\r\n        uint256 referralBonus = referrerBonusBalance[msg.sender];\r\n        require(referralBonus > 0, 'Insufficient referrer bonus');\r\n        referrerBonusBalance[msg.sender] = 0;\r\n        msg.sender.transfer(referralBonus);\r\n        emit ReferralBonusClaim(msg.sender,referralBonus,now);\r\n    }\r\n    \r\n    \r\n    // OK\r\n    function buy(address payable _referrer) public payable {\r\n        uint _value = msg.value.mul(10**15).div(_sellprice.mul(100).div(90));\r\n        \r\n        // \u043e\u0431\u0449\u0438\u0439 \u0431\u0430\u043b\u0430\u043d\u0441 \u042d\u0444\u0438\u0440\u043e\u0432 \u043d\u0430 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0435\r\n        _money = _money.add(msg.value.mul(95).div(100));\r\n        \r\n        // Platform fee - 5% of the ether deposit\r\n        uint platformFee = msg.value.mul(50).div(1000);\r\n        \r\n        // Final platform Fee, is after all the referrer payout deductions (as many as applicable).\r\n        uint finaPlatformFee; \r\n        \r\n        \r\n        /** Processing referral system fund distribution **/\r\n        // Case 1: depositor have used referral links, as well as depositor has existing direct referrer\r\n        // In this case, ether will be sent to existing referrer, it will ignore the new link he used.\r\n        if(_referrer != address(0x0) && referrers[msg.sender] != address(0x0)){\r\n            finaPlatformFee = distributeReferrerBonus(referrers[msg.sender], platformFee);\r\n        }\r\n        \r\n        // Case 2: depositor has existing referrer/up-line/direct sponsor, but he did not use any referrer link or sent ether directly to smart contract\r\n        // In this case, ether will be sent to existing referrer\r\n        else if(_referrer == address(0x0) && referrers[msg.sender] != address(0x0)){\r\n            finaPlatformFee = distributeReferrerBonus(referrers[msg.sender], platformFee);\r\n        }\r\n        \r\n        // Case 3: depositor does not have any existing direct referrer, but used referral link\r\n        // In this case, referral bonus will be paid to address in the referral link\r\n        else if(_referrer != address(0x0) && referrers[msg.sender] == address(0x0)){\r\n            finaPlatformFee = distributeReferrerBonus(_referrer, platformFee);\r\n            //adding referral details in both the mappings\r\n            referrers[msg.sender]=_referrer;\r\n        }\r\n        \r\n        // All other cases apart from above, referral bonus will not be paid to anyone\r\n        // And Entire platform fee (5% of deposit) will be sent to stock contract\r\n        else {\r\n            finaPlatformFee = platformFee;\r\n        }\r\n        \r\n        // \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u043f\u0440\u0438\u0431\u044b\u043b\u044c \u043d\u0430 \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u0438\u043a\u043e\u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u044b\r\n        (bool success, ) =    theStocksTokenContract.call.value(finaPlatformFee).gas(53000)(\"\");\r\n        \r\n        // This checks if ether transfer to stock contract is successful, otherwise revert\r\n        require(success, 'Ether transfer to DA Token contract failed');\r\n        \r\n        // \u0432\u0441\u0435\u0433\u043e \u0442\u043e\u043a\u0435\u043d\u043e\u0432 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435\r\n        _tokens = _tokens.add(_value);\r\n        \r\n        // \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0442\u043e\u043a\u0435\u043d\u044b, \u043d\u0430 \u0431\u0430\u043b\u0430\u043d\u0441 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\n        balances[msg.sender] = balances[msg.sender].add(_value);\r\n        \r\n        // \u041b\u043e\u0433\u0438\u0440\u0443\u0435\u043c \u0441\u043e\u0431\u044b\u0442\u0438\u0435 \u0441 \u043a\u0443\u0440\u0441\u043e\u043c / \u0434\u0430\u0442\u043e\u0439 / \r\n        emit FullEventLog(msg.sender, \"buy\", _sellprice, _sellprice.mul(100).div(90), now, _value, msg.value);\r\n        \r\n        _sellprice = _money.mul(10**15).mul(98).div(_tokens).div(100);\r\n        \r\n        \r\n        emit Transfer(address(this), msg.sender, _value);\r\n    }\r\n\r\n    // OK\r\n    function sell (uint256 countTokens) public {\r\n        // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0431\u0430\u043b\u0430\u043d\u0441\r\n        require(balances[msg.sender] >= countTokens);\r\n        \r\n        uint _value = countTokens.mul(_sellprice).div(10**15);\r\n        \r\n        _money = _money.sub(_value);\r\n        \r\n        _tokens = _tokens.subsafe(countTokens);\r\n        \r\n        balances[msg.sender] = balances[msg.sender].subsafe(countTokens);\r\n        \r\n        emit FullEventLog(msg.sender, \"sell\", _sellprice, _sellprice.mul(100).div(90), now, countTokens, _value);\r\n        \r\n        if(_tokens > 0) {\r\n            _sellprice = _money.mul(10**15).mul(98).div(_tokens).div(100);\r\n        }\r\n\r\n    \temit Transfer(msg.sender, address(this), countTokens);\r\n        msg.sender.transfer(_value);\r\n    }\r\n    // OK\r\n    function getPrice() public view returns (uint bid, uint ask) {\r\n        bid = _sellprice.mul(100).div(90);\r\n        ask = _sellprice;\r\n    }\r\n}",
	"ContractName": "DepositToken_10",
	"CompilerVersion": "v0.5.3+commit.10d17f24"
}