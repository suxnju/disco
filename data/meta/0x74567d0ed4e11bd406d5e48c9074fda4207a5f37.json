{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath { \r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) { \r\nif (a == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 c = a * b;\r\nrequire(c / a == b);\r\n\r\nreturn c;\r\n} \r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b > 0);\r\nuint256 c = a / b; \r\nreturn c;\r\n} \r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\nreturn c;\r\n} \r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\n\r\nreturn c;\r\n} \r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b != 0);\r\nreturn a % b;\r\n}\r\n}\r\n\r\ncontract ERC20Interface {\r\nfunction totalSupply() public constant returns (uint);\r\nfunction balanceOf(address tokenOwner) public constant returns (uint balance);\r\nfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\nfunction transfer(address to, uint tokens) public returns (bool success);\r\nfunction approve(address spender, uint tokens) public returns (bool success);\r\nfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\nevent Transfer(address indexed from, address indexed to, uint tokens);\r\nevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}  \r\ncontract ApproveAndCallFallBack {\r\nfunction receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n} \r\ncontract Owned {\r\naddress public owner;\r\naddress public newOwner;\r\n\r\nevent OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\nconstructor() public {\r\nowner = msg.sender;\r\n}\r\n\r\nmodifier onlyOwner {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\n\r\nfunction transferOwnership(address _newOwner) public onlyOwner {\r\nnewOwner = _newOwner;\r\n}\r\nfunction acceptOwnership() public {\r\nrequire(msg.sender == newOwner);\r\nemit OwnershipTransferred(owner, newOwner);\r\nowner = newOwner;\r\nnewOwner = address(0);\r\n}\r\n}  \r\ncontract FixedSupplyToken is ERC20Interface, Owned {\r\nusing SafeMath for uint;\r\n\r\nstring public symbol;\r\nstring public  name;\r\nuint8 public decimals;\r\nuint _totalSupply; \r\n\r\nbool public crowdsaleEnabled;\r\nuint public ethPerToken;\r\nuint public bonusMinEth;\r\nuint public bonusPct; \r\n\r\nmapping(address => uint) balances;\r\nmapping(address => mapping(address => uint)) allowed; \r\nevent Burn(address indexed from, uint256 value);\r\nevent Bonus(address indexed from, uint256 value);  \r\nconstructor() public {\r\nsymbol = \"DN8\";\r\nname = \"PLDGR.ORG\";\r\ndecimals = 18;\r\n_totalSupply = 450000000000000000000000000;\r\n\r\n\r\ncrowdsaleEnabled = false;\r\nethPerToken = 20000;\r\nbonusMinEth = 0;\r\nbonusPct = 0; \r\n\r\nbalances[owner] = _totalSupply;\r\nemit Transfer(address(0), owner, _totalSupply);\r\n} \r\nfunction totalSupply() public view returns (uint) {\r\nreturn _totalSupply.sub(balances[address(0)]);\r\n} \r\nfunction balanceOf(address tokenOwner) public view returns (uint balance) {\r\nreturn balances[tokenOwner];\r\n} \r\nfunction transfer(address to, uint tokens) public returns (bool success) {\r\nbalances[msg.sender] = balances[msg.sender].sub(tokens);\r\nbalances[to] = balances[to].add(tokens);\r\nemit Transfer(msg.sender, to, tokens);\r\nreturn true;\r\n} \r\nfunction approve(address spender, uint tokens) public returns (bool success) {\r\nallowed[msg.sender][spender] = tokens;\r\nemit Approval(msg.sender, spender, tokens);\r\nreturn true;\r\n} \r\nfunction transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\nbalances[from] = balances[from].sub(tokens);\r\nallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\nbalances[to] = balances[to].add(tokens);\r\nemit Transfer(from, to, tokens);\r\nreturn true;\r\n} \r\nfunction allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\nreturn allowed[tokenOwner][spender];\r\n} \r\nfunction approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\nallowed[msg.sender][spender] = tokens;\r\nemit Approval(msg.sender, spender, tokens);\r\nApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\nreturn true;\r\n} \r\nfunction transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\nreturn ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n} \r\nfunction () public payable { \r\nrequire(crowdsaleEnabled);  \r\nuint ethValue = msg.value; \r\nuint tokens = ethValue.mul(ethPerToken); \r\nif(bonusPct > 0 && ethValue >= bonusMinEth){ \r\nuint bonus = tokens.div(100).mul(bonusPct); \r\nemit Bonus(msg.sender, bonus); \r\ntokens = tokens.add(bonus);\r\n} \r\nbalances[owner] = balances[owner].sub(tokens);\r\nbalances[msg.sender] = balances[msg.sender].add(tokens); \r\nemit Transfer(owner, msg.sender, tokens);\r\n}  \r\nfunction enableCrowdsale() public onlyOwner{\r\ncrowdsaleEnabled = true; \r\n} \r\nfunction disableCrowdsale() public onlyOwner{\r\ncrowdsaleEnabled = false; \r\n} \r\nfunction setTokenPrice(uint _ethPerToken) public onlyOwner{ \r\nethPerToken = _ethPerToken;\r\n}  \r\nfunction setBonus(uint _bonusPct, uint _minEth) public onlyOwner {\r\nbonusMinEth = _minEth;\r\nbonusPct = _bonusPct;\r\n} \r\nfunction burn(uint256 _value) public onlyOwner {\r\nrequire(_value > 0);\r\nrequire(_value <= balances[msg.sender]); \r\n\r\naddress burner = msg.sender; \r\nbalances[burner] = balances[burner].sub(_value); \r\n_totalSupply = _totalSupply.sub(_value);\r\n\r\nemit Burn(burner, _value); \r\n}  \r\nfunction withdraw(uint _amount) onlyOwner public {\r\nrequire(_amount > 0); \r\nrequire(_amount <= address(this).balance);     \r\n\r\nowner.transfer(_amount);\r\n}\r\n\r\n\r\n}",
	"ContractName": "FixedSupplyToken",
	"CompilerVersion": "v0.4.25+commit.59dbf8f1"
}