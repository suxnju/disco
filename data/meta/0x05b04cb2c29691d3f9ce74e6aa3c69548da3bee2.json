{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.25;\r\n\r\ncontract EtherStateEquivalentToken {\r\n    address public owner;\r\n    mapping (address => uint256) public tokenBalance;\r\n    mapping (address => uint256) public refBalance;\r\n    \r\n    uint256 public tokenPrice = 0.0004 ether; \r\n    uint256 public tokenSupply = 0;\r\n    uint256 constant public softCap =  2500000 ether;\r\n    uint256 constant public hardCap = 10000000 ether;\r\n    uint256 public start;\r\n    uint256 public softCapMoment = 0;\r\n    uint256 public softCapPeriod = 1483300; //17 * 24 * 60 * 60;\r\n    uint256 public hardCapPeriod = softCapPeriod;\r\n    uint256 public investedTotal = 0;\r\n    \r\n    bool public softCapReached = false;\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier softCapFailed {\r\n        require(now > start + softCapPeriod && !softCapReached);\r\n        _;\r\n    }\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        start = now;\r\n    }\r\n    \r\n    function() public payable {\r\n        invest(msg.sender, msg.value, 0x0, 0x0);\r\n    }\r\n    \r\n    function buy(address ref1, address ref2) public payable {\r\n        /* \r\n            Function Enhamster\r\n        */\r\n        \r\n        require(msg.value > 0);\r\n        \r\n        invest(msg.sender, msg.value, ref1, ref2);\r\n    }\r\n    \r\n    function invest(address investor, uint256 value, address ref1, address ref2) internal {\r\n        /* \r\n            \u0412\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u044f\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u043a\u0443\u043f\u043a\u0438 \u0442\u043e\u043a\u0435\u043d\u043e\u0432, \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0438\u0437 \u0433\u043e\u043b\u043e\u0432\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u0438 \u043c\u0435\u0442\u043e\u0434\u0430 buy.\r\n        */\r\n        \r\n        uint256 tokens = value / tokenPrice * 1 ether;\r\n        require (tokens + tokenSupply <= hardCap); /* \u043d\u0435\u043b\u044c\u0437\u044f \u0447\u0442\u043e\u0431\u044b \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043b\u0441\u044f tokenSupply, \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u044f\u0449\u0438\u0439 10 000 000 EST */\r\n        if (softCapMoment > 0) require(now < softCapMoment + hardCapPeriod); /* \u043f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0438\u043e\u0434\u0430 Hard Cap \u0442\u043e\u043a\u0435\u043d\u044b \u043d\u0435\u043b\u044c\u0437\u044f \u043f\u043e\u043a\u0443\u043f\u0430\u0442\u044c */\r\n        \r\n        tokenBalance[investor] += tokens;\r\n        tokenSupply += tokens;\r\n        \r\n        if (tokenSupply >= softCap) {\r\n            softCapReached = true;\r\n            softCapMoment = now;\r\n        }\r\n        \r\n        uint256 ref1Money = value * 6 / 100;\r\n        uint256 ref2Money = value * 3 / 100;\r\n        uint256 ownerMoney = value - ref1Money - ref2Money;\r\n        \r\n        if (ref1 != 0x0 && tokenBalance[ref1] >= 125 ether) {\r\n            refBalance[ref1] += ref1Money;\r\n        } else {\r\n            refBalance[owner] += ref1Money;\r\n        }\r\n        if (ref2 != 0x0 && tokenBalance[ref2] >= 125 ether) {\r\n            refBalance[ref2] += ref2Money;\r\n        } else {\r\n            refBalance[owner] += ref2Money;\r\n        }\r\n        refBalance[owner] += ownerMoney;\r\n        \r\n        investedTotal += value;\r\n         \r\n        emit OnInvest(investor, value, tokens, ref1, ref2, now);\r\n    }\r\n    \r\n    function withdraw() public {\r\n        /* \r\n            \u0412\u044b\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0441 \u0440\u0435\u0444\u0435\u0440\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430, \u0432\u043e\u0437\u043c\u043e\u0436\u0435\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u044f Soft Cap. \u042d\u0442\u043e\u0442 \u0436\u0435 \u043c\u0435\u0442\u043e\u0434 \r\n            \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f owner'\u043e\u043c \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0441\u0440\u0435\u0434\u0441\u0442\u0432.\r\n        */\r\n        \r\n        require(softCapReached);\r\n        uint256 value = refBalance[msg.sender];\r\n        require(value > 0);\r\n        \r\n        refBalance[msg.sender] = 0;\r\n        \r\n        msg.sender.transfer(value);\r\n        emit OnWithdraw(msg.sender, value, now);\r\n    }\r\n    \r\n    function withdrawAmount(uint256 amount) public {\r\n        /* \r\n            \u0412\u044b\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0441 \u0440\u0435\u0444\u0435\u0440\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430, \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u044b.\r\n        */\r\n        require(amount > 0);\r\n        require(softCapReached);\r\n        uint256 value = refBalance[msg.sender];\r\n        require(value >= amount);\r\n        \r\n        refBalance[msg.sender] = value-amount;\r\n        \r\n        msg.sender.transfer(amount);\r\n        emit OnWithdraw(msg.sender, amount, now);\r\n    }\r\n    \r\n    function withdrawAmountTo(uint256 amount, address receiver) public {\r\n        /* \r\n            \u0412\u044b\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0441 \u0440\u0435\u0444\u0435\u0440\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u044b \u0432 \u043f\u043e\u043b\u044c\u0437\u0443 \u0434\u0440\u0443\u0433\u043e\u0433\u043e \u0430\u0434\u0440\u0435\u0441\u0430.\r\n        */\r\n        require(amount > 0);\r\n        require(softCapReached);\r\n        uint256 value = refBalance[msg.sender];\r\n        require(value >= amount);\r\n        \r\n        refBalance[msg.sender] = value-amount;\r\n        \r\n        receiver.transfer(amount);\r\n        emit OnWithdrawTo(msg.sender, receiver, amount, now);\r\n    }\r\n    \r\n    function deinvest() public softCapFailed {\r\n        /* \r\n            \u0412\u044b\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0438\u043d\u0432\u0435\u0441\u0442\u043e\u0440\u0430 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043f\u0440\u043e\u0432\u0430\u043b\u0430 softCap. \u041c\u043e\u0434\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442 \u0432\u0440\u0435\u043c\u044f \u0438 \u043d\u0435 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \r\n            \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0434\u043e \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0438\u043e\u0434\u0430 softCapPeriod, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 Soft Cap \u0431\u044b\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d.\r\n        */\r\n            \r\n        uint256 tokens = tokenBalance[msg.sender];\r\n        require(tokens > 0);\r\n        \r\n        tokenBalance[msg.sender] = 0;\r\n        tokenSupply -= tokens;\r\n        uint256 money = tokens * tokenPrice / 1e18;\r\n        msg.sender.transfer(money);\r\n        emit OnDeinvest(msg.sender, tokens, money, now);\r\n    }\r\n    \r\n    function goESM() public { \r\n        /*  \r\n            \u041e\u0431\u043c\u0435\u043d \u043d\u0430 \u0442\u043e\u043a\u0435\u043d\u044b Ether State Main. \u041f\u0440\u0438 \u0432\u044b\u0437\u043e\u0432\u0435 \u044d\u0442\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430, \u0432\u0441\u0435 \u0442\u043e\u043a\u0435\u043d\u044b EST \u0431\u0443\u0434\u0443\u0442 \u0441\u043e\u0436\u0436\u0435\u043d\u044b,\r\n            \u0438 \u0441\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 Event.\r\n        */\r\n       \r\n        require(softCapReached);\r\n        uint256 tokens = tokenBalance[msg.sender];\r\n        require(tokens > 0);\r\n        \r\n        tokenBalance[msg.sender] = 0;\r\n        tokenSupply -= tokens;\r\n        emit OnExchangeForESM(msg.sender, tokens, now);\r\n    }\r\n\r\n    function transfer(address receiver) public {\r\n        uint256 tokens = tokenBalance[msg.sender];\r\n        require(tokens > 0);\r\n\r\n        tokenBalance[msg.sender] = 0;\r\n        tokenBalance[receiver] += tokens;\r\n\r\n        emit OnTransfer(msg.sender, receiver, tokens, now);\r\n    }\r\n    \r\n    event OnInvest (\r\n        address investor,\r\n        uint256 value,\r\n        uint256 tokensGranted,\r\n        address ref1,\r\n        address ref2,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event OnWithdraw (\r\n        address indexed investor,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnWithdrawTo (\r\n        address indexed investor,\r\n        address indexed receiver,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event OnDeinvest (\r\n        address indexed investor,\r\n        uint256 tokensBurned,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event OnExchangeForESM (\r\n        address indexed investor,\r\n        uint256 tokensBurned,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnTransfer (\r\n        address investorA,\r\n        address investorB,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    );\r\n}",
	"ContractName": "EtherStateEquivalentToken",
	"CompilerVersion": "v0.4.25+commit.59dbf8f1"
}