{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.4.11;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC223 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n\r\n  function name() constant returns (string _name);\r\n  function symbol() constant returns (string _symbol);\r\n  function decimals() constant returns (uint8 _decimals);\r\n  function totalSupply() constant returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) returns (bool ok);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\r\n}\r\n\r\ncontract ContractReceiver {\r\n  function tokenFallback(address _from, uint _value, bytes _data);\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  uint8   public decimals;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Radex is ContractReceiver {\r\n  using SafeMath for uint256;\r\n\r\n  struct Order {\r\n    address owner;\r\n    address sellToken;\r\n    address buyToken;\r\n    uint256 amount;\r\n    uint256 priceMul;\r\n    uint256 priceDiv;\r\n  }\r\n\r\n  // fee to be paid towards market makers\r\n  // fee amount = trade amount divided by feeMultiplier\r\n  uint256 public  feeMultiplier;\r\n  address private admin;\r\n  address private etherAddress = 0x0;\r\n\r\n  // person => token => balance\r\n  mapping(address => mapping(address => uint256)) public balances;\r\n  mapping(address => mapping(address => uint256)) public commitments;\r\n\r\n  mapping(uint256 => Order) orderBook;\r\n  uint256 public latestOrderId = 0;\r\n\r\n  event Deposit(address indexed _token, address indexed _owner, uint256 _amount, uint256 _time);\r\n  event Withdrawal(address indexed _token, address indexed _owner, uint256 _amount, uint256 _time);\r\n\r\n  event NewOrder(uint256 _id, address indexed _owner, address indexed _sellToken, address indexed _buyToken, uint256 _amount, uint256 _priceMul, uint256 _priceDiv, uint256 _time);\r\n  event OrderCancelled(uint256 indexed _id, uint256 _time);\r\n  event OrderFulfilled(uint256 indexed _id, uint256 _time);\r\n\r\n  event MarketMaker(address indexed _owner, address indexed _token, uint256 _amount, uint256 _time);\r\n  event Trade(address indexed _from, address indexed _to, uint256 indexed _orderId, uint256 _soldTokens, uint256 _boughtTokens, uint256 _time);\r\n\r\n  function Radex() {\r\n    feeMultiplier = 1000;\r\n    admin = msg.sender;\r\n  }\r\n\r\n  function createOrder(address sellToken, address buyToken, uint256 amount, uint256 priceMul, uint256 priceDiv) returns(uint256 orderId) {\r\n    if (amount == 0) { revert(); }\r\n    if (priceMul == 0) { revert(); }\r\n    if (priceDiv == 0) { revert(); }\r\n    if (sellToken == buyToken) { revert(); }\r\n    if (balances[msg.sender][sellToken] < amount) { revert(); }\r\n    if (amount.mul(priceMul).div(priceDiv) == 0) { revert(); }\r\n\r\n    orderId = latestOrderId++;\r\n    orderBook[orderId] = Order(msg.sender, sellToken, buyToken, amount, priceMul, priceDiv);\r\n\r\n    balances[msg.sender][sellToken] = balances[msg.sender][sellToken].sub(amount);\r\n    commitments[msg.sender][sellToken] = commitments[msg.sender][sellToken].add(amount);\r\n\r\n    NewOrder(orderId, msg.sender, sellToken, buyToken, amount, priceMul, priceDiv, now);\r\n  }\r\n\r\n  function cancelOrder(uint256 orderId) {\r\n    Order storage order = orderBook[orderId];\r\n    if (order.amount == 0) { revert(); }\r\n    if (msg.sender != order.owner) { revert(); }\r\n\r\n    commitments[msg.sender][order.sellToken] = commitments[msg.sender][order.sellToken].sub(order.amount);\r\n    balances[msg.sender][order.sellToken] = balances[msg.sender][order.sellToken].add(order.amount);\r\n\r\n    OrderCancelled(orderId, now);\r\n  }\r\n\r\n  function executeOrder(uint256 orderId, uint256 amount) {\r\n    if (orderId > latestOrderId) { revert(); }\r\n    Order storage order    = orderBook[orderId];\r\n    uint256 buyTokenAmount = amount.mul(order.priceMul).div(order.priceDiv);\r\n    if (amount == 0) { revert(); }\r\n    if (order.amount < amount) { revert(); }\r\n    if (msg.sender == order.owner) { revert(); }\r\n    if (balances[msg.sender][order.buyToken] < buyTokenAmount) { revert(); }\r\n\r\n    uint256 fee = amount.div(feeMultiplier);\r\n\r\n    balances[order.owner][order.buyToken]     = balances[order.owner][order.buyToken].add(buyTokenAmount);\r\n    balances[msg.sender][order.buyToken]      = balances[msg.sender][order.buyToken].sub(buyTokenAmount);\r\n    balances[msg.sender][order.sellToken]     = balances[msg.sender][order.sellToken].add(amount).sub(fee);\r\n    balances[order.owner][order.sellToken]    = balances[order.owner][order.sellToken].add(fee);\r\n\r\n    commitments[order.owner][order.sellToken] = commitments[order.owner][order.sellToken].sub(amount);\r\n    order.amount = order.amount.sub(amount);\r\n    if (order.amount == 0) { OrderFulfilled(orderId, now); }\r\n\r\n    Trade(msg.sender, order.owner, orderId, amount, buyTokenAmount, now);\r\n    MarketMaker(order.owner, order.sellToken, fee, now);\r\n  }\r\n\r\n\r\n  function redeem(address token, uint256 value) {\r\n    if (value == 0) { revert(); }\r\n    address caller = msg.sender;\r\n    if (value > balances[caller][token]) { revert(); }\r\n\r\n    balances[caller][token] = balances[caller][token].sub(value);\r\n    // ETH transfers and token transfers need to be handled differently\r\n    if (token == etherAddress) {\r\n      caller.transfer(value);\r\n    } else {\r\n      ERC223(token).transfer(caller, value);\r\n    }\r\n    Withdrawal(token, msg.sender, value, now);\r\n  }\r\n\r\n  function balanceOf(address token, address user) constant returns (uint256) {\r\n    return balances[user][token];\r\n  }\r\n\r\n  function commitmentsOf(address token, address user) constant returns (uint256) {\r\n    return commitments[user][token];\r\n  }\r\n\r\n  // deposits\r\n  // we're not using the third argument so we comment it out\r\n  // to silence solidity linter warnings\r\n  function tokenFallback(address _from, uint _value, bytes /* _data */) {\r\n    // ERC223 token deposit handler\r\n    balances[_from][msg.sender] = balances[_from][msg.sender].add(_value);\r\n    Deposit(msg.sender, _from, _value, now);\r\n  }\r\n\r\n  function fund() payable {\r\n    // ETH deposit handler\r\n    balances[msg.sender][etherAddress] = balances[msg.sender][etherAddress].add(msg.value);\r\n    Deposit(etherAddress, msg.sender, msg.value, now);\r\n  }\r\n\r\n  // register the ERC20<>ERC223 pair with the smart contract\r\n  function register(address erc20token, address erc223token) {\r\n    if (msg.sender != admin) { revert(); } // only owner\r\n    ERC20 erc20 = ERC20(erc20token);\r\n    uint256 supply = erc20.totalSupply();\r\n    erc20.approve(erc223token, supply);\r\n  }\r\n}",
	"ContractName": "Radex",
	"CompilerVersion": "v0.4.19+commit.c4cbbb05"
}