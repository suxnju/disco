{
	"Language": "Solidity",
	"Source": "/**\r\n\u201cCommons Clause\u201d License Condition v1.0\r\n\r\nThe Software is provided to you by the Licensor under the License, as defined below, subject to the following condition.\r\n\r\nWithout limiting other conditions in the License, the grant of rights under the License will not include, and the License does not grant to you, the right to Sell the Software.\r\n\r\nFor purposes of the foregoing, \u201cSell\u201d means practicing any or all of the rights granted to you under the License to provide to third parties, for a fee or other consideration (including without limitation fees for hosting or consulting/ support services related to the Software), a product or service whose value derives, entirely or substantially, from the functionality of the Software. Any license notice or attribution required by the License must also include this Commons Clause License Condition notice.\r\n\r\nSoftware: Dexpress Pay\r\n\r\nLicense: Apache 2.0 with Common Clause\r\n\r\nLicensor: Dexpress Pay\r\n\r\n\r\n *Authored by Alex George\r\n*/\r\npragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev a to power of b, throws on overflow.\r\n  */\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a ** b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n// Payd app\r\n// Authored by Alex George\r\n// https://github.com/bitbleach\r\n\r\ncontract DexPayments is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  address public feeAccount;\r\n  uint256 public inactivityReleasePeriod;\r\n  mapping (address => mapping (address => uint256)) public tokens;\r\n  mapping (address => uint256) public lastActiveTransaction;\r\n  mapping (address => bool) public hardWithdrawRequested;\r\n  mapping (address => bool) public admins;\r\n  mapping (bytes32 => bool) public withdrawn;\r\n  mapping (bytes32 => uint256) public orderFills;\r\n\r\n  event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n  event Payment(uint256 amountToPay, uint256 paymentNonce, uint256 orderExpires, address paymentToken, address merchant, address customer);\r\n  event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n  event RequestHardWithdraw(address user, bool request);\r\n  event ProcessingFeeUpdated(uint256 oldFee, uint256 newFee);\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == owner || admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  constructor(address _feeAccount, uint256 _inactivityReleasePeriod) public {\r\n    owner = msg.sender;\r\n    feeAccount = _feeAccount;\r\n    inactivityReleasePeriod = _inactivityReleasePeriod;\r\n  }\r\n\r\n  function requestHardWithdraw(bool request) public {\r\n    require(block.number.sub(lastActiveTransaction[msg.sender]) >= inactivityReleasePeriod);\r\n    hardWithdrawRequested[msg.sender] = request;\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    emit RequestHardWithdraw(msg.sender, request);\r\n  }\r\n\r\n  function withdraw(address token, uint256 amount) public returns (bool) {\r\n    require(block.number.sub(lastActiveTransaction[msg.sender]) >= inactivityReleasePeriod);\r\n    require(tokens[token][msg.sender] >= amount);\r\n    require(hardWithdrawRequested[msg.sender] == true);\r\n\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    if (token == address(0)) {\r\n      msg.sender.transfer(amount);\r\n    } else {\r\n      require(ERC20(token).transfer(msg.sender, amount));\r\n    }\r\n    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function setInactivityReleasePeriod(uint256 expire) onlyAdmin public returns (bool) {\r\n    require(expire <= 100000);\r\n    require(expire >= 6000);\r\n    inactivityReleasePeriod = expire;\r\n    return true;\r\n  }\r\n\r\n  function setAdmin(address admin, bool isAdmin) onlyOwner public {\r\n    admins[admin] = isAdmin;\r\n  }\r\n\r\n  function setFeeAccount(address newFeeAccount) onlyOwner public {\r\n    feeAccount = newFeeAccount;\r\n  }\r\n\r\n  function depositToken(address token, uint256 amount) public {\r\n    receiveTokenDeposit(token, msg.sender, amount);\r\n  }\r\n\r\n  function receiveTokenDeposit(address token, address from, uint256 amount) public {\r\n    tokens[token][from] = tokens[token][from].add(amount);\r\n    lastActiveTransaction[from] = block.number;\r\n    require(ERC20(token).transferFrom(from, address(this), amount));\r\n    emit Deposit(token, from, amount, tokens[token][from]);\r\n  }\r\n\r\n  function deposit() payable public {\r\n    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\n  function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 gasCost) onlyAdmin public returns (bool) {\r\n    //gasCost will never be more than the amount withdrawn\r\n    require(gasCost <= amount);\r\n\r\n    // user must be able to pay for gas cost\r\n    if(token == address(0)){\r\n      require(tokens[address(0)][user] >= gasCost.add(amount));\r\n    } else {\r\n      require(tokens[token][user] >= gasCost.add(amount));\r\n    }\r\n\r\n    bytes32 hash = keccak256(address(this), token, amount, user, nonce, gasCost);\r\n    require(!withdrawn[hash]);\r\n    withdrawn[hash] = true;\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user);\r\n\r\n    if(token == address(0)){\r\n      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost.add(amount));\r\n      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\r\n      user.transfer(amount);\r\n    } else {\r\n      tokens[token][user] = tokens[token][user].sub(gasCost.add(amount));\r\n      tokens[token][feeAccount] = tokens[token][feeAccount].add(gasCost);\r\n      require(ERC20(token).transfer(user, amount));\r\n    }\r\n    lastActiveTransaction[user] = block.number;\r\n    emit Withdraw(token, user, amount, tokens[token][user]);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address token, address user) view public returns (uint256) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n    /* paymentValues\r\n       [0] amountToPay\r\n       [1] paymentNonce\r\n       [2] orderExpires\r\n       [3] baseFee\r\n     paymentAddresses\r\n       [0] paymentToken\r\n       [1] merchant\r\n       [2] customer\r\n     */\r\n\r\n  function sendPayment(uint256[4] paymentValues, address[3] paymentAddresses, uint8 v, bytes32[2] rs) onlyAdmin public returns (bool) {\r\n    // prevents execution of stale orders\r\n    require(block.number < paymentValues[2]);\r\n    bytes32 paymentHash = keccak256(address(this), paymentValues[0], paymentValues[1], paymentValues[2], paymentValues[3], paymentAddresses[0], paymentAddresses[1]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", paymentHash), v, rs[0], rs[1]) == paymentAddresses[2]);\r\n\r\n    // require customer balance to be greater than transcation balance\r\n    require(tokens[paymentAddresses[0]][paymentAddresses[2]] >= paymentValues[0]);\r\n\r\n    // require baseFee to be less than amountToPay\r\n    require(paymentValues[3] <= paymentValues[0]);\r\n\r\n    //prevent double spend\r\n    require(orderFills[paymentHash].add(paymentValues[0]) <= paymentValues[0]);\r\n\r\n    //move tokens\r\n    tokens[paymentAddresses[0]][paymentAddresses[2]] = tokens[paymentAddresses[0]][paymentAddresses[2]].sub(paymentValues[0]);\r\n    tokens[paymentAddresses[0]][paymentAddresses[1]] = tokens[paymentAddresses[0]][paymentAddresses[1]].add(paymentValues[0]);\r\n\r\n    //from merchant take processing fee\r\n    tokens[paymentAddresses[0]][paymentAddresses[1]] = tokens[paymentAddresses[0]][paymentAddresses[1]].sub(paymentValues[3]);\r\n    tokens[paymentAddresses[0]][feeAccount] = tokens[paymentAddresses[0]][feeAccount].add(paymentValues[3]);\r\n\r\n    orderFills[paymentHash] = orderFills[paymentHash].add(paymentValues[0]);\r\n\r\n    emit Payment(paymentValues[0], paymentValues[1], paymentValues[2], paymentAddresses[0], paymentAddresses[1], paymentAddresses[2]);\r\n\r\n    lastActiveTransaction[paymentAddresses[1]] = block.number;\r\n    lastActiveTransaction[paymentAddresses[2]] = block.number;\r\n\r\n    return true;\r\n  }\r\n\r\n}",
	"ContractName": "DexPayments",
	"CompilerVersion": "v0.4.23+commit.124ca40d"
}