{
	"Language": "Solidity",
	"Source": "pragma solidity ^0.6.4;\r\n\r\ncontract EtherHash{\r\n    \r\n    address private owner;\r\n    mapping(bytes32=>uint256)private proof;\r\n    \r\n    function perc(uint8 _perc,uint256 sum)private pure returns(uint256){\r\n        return (sum/100)*_perc;\r\n    }\r\n    \r\n    \r\n    modifier minDeposit{\r\n        assert(msg.value>10000000000000);_;\r\n    }\r\n    \r\n    function newAccount(bytes32 _proof)public payable minDeposit{\r\n        if(proof[_proof] >=1){\r\n            revert();\r\n        }else{\r\n             proof[_proof]=msg.value;\r\n\r\n        }\r\n    }\r\n    \r\n    function deposit(bytes32 _proof)public payable minDeposit{\r\n        if(proof[_proof]>1){\r\n            proof[_proof]+=msg.value;\r\n        }else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    \r\n    function withdraw(string memory _value,address _to)public{\r\n      if( proof[sha256(abi.encodePacked((_value)))]>10000000000000){\r\n          address(uint160(_to)).transfer(proof[sha256(abi.encodePacked((_value)))]-perc(10,proof[sha256(abi.encodePacked((_value)))]));\r\n          address(uint160(owner)).transfer(perc(10,proof[sha256(abi.encodePacked((_value)))]));\r\n          proof[sha256(abi.encodePacked((_value)))]=1;\r\n      }else{\r\n          revert();\r\n      }\r\n    }\r\n\r\n\r\n\r\n    constructor()public{\r\n        owner=msg.sender;\r\n    }\r\n\r\n\r\n}",
	"ContractName": "EtherHash",
	"CompilerVersion": "v0.6.4+commit.1dca32f3"
}