{
	"address": "0xb012e882c82ef3ca0ce526f2374887b4429a7228",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Please note that decompiled code might not give the exact Solidity code, and some of the functions' names and parameters are not clear in the decompiled code you provided.\n\nBased on the code you provided, here is the Solidity version:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    uint256 private _rate;\n    uint256 private _rateT4T;\n    uint256 private _minimumInvest;\n    uint256 private _hicsTokenPrice;\n    uint256 private _capHicsToken;\n    uint256 private _softCap;\n    uint256 private _weiRaised;\n    uint256 private _t4tRaised;\n    uint256 private _totalTokensEmitted;\n    uint256 private _totalRaised;\n    address private _owner;\n    uint64 private _endTime;\n    address private _t4tToken;\n    address private _icsToken;\n    uint8 private stor_0_20_20;\n    address private _hicsToken;\n    uint64 private _endPeriodA;\n    address private _wallet;\n    uint64 private _startTime;\n    uint64 private _endPeriodB;\n    uint64 private _endPeriodC;\n    \n    mapping (uint256 => uint256) private _balances;\n    mapping (uint256 => uint256) private owner_d;\n    mapping (uint256 => uint256) private owner_e;\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event IcsTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value);\n    event HicsTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value);\n\n    // The function definitions will go here.\n\n    // This is a simplified example. You should adapt the code to your needs.\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n```\n\nPlease replace `// The function definitions will go here.` with your functions' implementation. It's not possible to provide an exact translation without knowing the original Solidity code or having more context about what each function does.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457990,
	"id": "chatcmpl-8R3Ekw87VADkta4HVOhkdQGYlc4nS",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.17 05:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x6]\nuint256 _rateT4T; // STORAGE[0x7]\nuint256 _minimumInvest; // STORAGE[0x8]\nuint256 _hicsTokenPrice; // STORAGE[0x9]\nuint256 _capHicsToken; // STORAGE[0xa]\nuint256 _softCap; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nmapping (uint256 => [uint256]) owner_e; // STORAGE[0xe]\nuint256 _weiRaised; // STORAGE[0xf]\nuint256 _t4tRaised; // STORAGE[0x10]\nuint256 _totalTokensEmitted; // STORAGE[0x11]\nuint256 _totalRaised; // STORAGE[0x12]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint64 _endTime; // STORAGE[0x4] bytes 0 to 7\naddress _t4tToken; // STORAGE[0x1] bytes 0 to 19\naddress _icsToken; // STORAGE[0x2] bytes 0 to 19\nuint8 stor_0_20_20; // STORAGE[0x0] bytes 20 to 20\naddress _hicsToken; // STORAGE[0x3] bytes 0 to 19\nuint64 _endPeriodA; // STORAGE[0x4] bytes 8 to 15\naddress _wallet; // STORAGE[0x5] bytes 0 to 19\nuint64 _startTime; // STORAGE[0x3] bytes 20 to 27\nuint64 _endPeriodB; // STORAGE[0x4] bytes 16 to 23\nuint64 _endPeriodC; // STORAGE[0x4] bytes 24 to 31\n\n// Events\nOwnershipRenounced(address);\nOwnershipTransferred(address, address);\nIcsTokenPurchase(address, address, uint256);\nHicsTokenPurchase(address, address, uint256);\n\nfunction fallback() public payable { \n    0x8c3(msg.sender);\n}\n\nfunction endPeriodC() public nonPayable { \n    return _endPeriodC;\n}\n\nfunction changeTokensOwner() public nonPayable { \n    require(msg.sender == _owner);\n    require(block.timestamp > _endTime);\n    require(_icsToken.code.size);\n    v0 = _icsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(_hicsToken.code.size);\n    v1 = _hicsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction 0x2011(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x204c(uint256 varg0, uint256 varg1) private { \n    assert(5);\n    v0 = varg0 / 5;\n    v1 = v2 = varg0 >= _hicsTokenPrice;\n    if (v2) {\n        v3 = 0x2452(v0);\n        require(_hicsToken.code.size);\n        v4, v5 = _hicsToken.totalSupply().gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v5 + v3 >= v5);\n        v1 = v6 = v5 + v3 < _capHicsToken;\n    }\n    if (!v1) {\n        0x249a(varg0, varg1);\n    } else {\n        0x249a(varg0 - v0, varg1);\n        v7 = 0x2452(v0);\n        v8 = address(varg1);\n        require(_hicsToken.code.size);\n        v9, v10 = _hicsToken.mint(v8, v7).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        emit HicsTokenPurchase(msg.sender, address(varg1), v7);\n    }\n    v11 = 0x2452(varg0);\n    assert(_totalTokensEmitted + v11 >= _totalTokensEmitted);\n    _totalTokensEmitted = _totalTokensEmitted + v11;\n    v12 = address(varg1);\n    assert(_balances[v12] + v11 >= _balances[v12]);\n    v13 = address(varg1);\n    _balances[v13] = _balances[v12] + v11;\n    v14 = _totalRaised + varg0;\n    assert(v14 >= _totalRaised);\n    _totalRaised = v14;\n    return ;\n}\n\nfunction t4tToken() public nonPayable { \n    return _t4tToken;\n}\n\nfunction 0x2452(uint256 varg0) private { \n    if (block.timestamp >= _endPeriodA) {\n        if (block.timestamp >= _endPeriodB) {\n            if (block.timestamp >= _endPeriodC) {\n                v0 = 15;\n            } else {\n                v0 = v1 = 20;\n            }\n        } else {\n            v0 = v2 = 25;\n        }\n    } else {\n        v0 = v3 = 40;\n    }\n    v4 = 0x2011(v0, varg0);\n    assert(100);\n    v5 = varg0 + v4 / 100;\n    assert(v5 >= varg0);\n    return v5;\n}\n\nfunction 0x249a(uint256 varg0, uint256 varg1) private { \n    v0 = 0x2452(varg0);\n    v1 = address(varg1);\n    require(_icsToken.code.size);\n    v2, v3 = _icsToken.mint(v1, v0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    emit IcsTokenPurchase(msg.sender, address(varg1), v0);\n    return ;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction totalTokensEmitted() public nonPayable { \n    return _totalTokensEmitted;\n}\n\nfunction finishPreSale() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    require(block.timestamp > _endTime);\n    v0 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    require(_t4tToken.code.size);\n    v1, v2 = _t4tToken.balanceOf(address(this)).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.transfer(_wallet, v2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_icsToken.code.size);\n    v5 = _icsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(_hicsToken.code.size);\n    v6 = _hicsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n}\n\nfunction manualBuy(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 >= _minimumInvest);\n    0x204c(varg1, varg0);\n}\n\nfunction capHicsToken() public nonPayable { \n    return _capHicsToken;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction t4tRaised() public nonPayable { \n    return _t4tRaised;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction refund() public nonPayable { \n    v0 = v1 = _totalRaised < _softCap;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endTime;\n    }\n    require(v0);\n    require(!stor_0_20_20);\n    stor_0_20_20 = 1;\n    owner_d[msg.sender] = 0;\n    assert(owner_d[msg.sender] <= _weiRaised);\n    _weiRaised = _weiRaised - owner_d[msg.sender];\n    v3 = msg.sender.call().value(owner_d[msg.sender]).gas(!owner_d[msg.sender] * 2300);\n    require(v3); // checks call status, propagates error data on error\n    stor_0_20_20 = 0;\n}\n\nfunction hicsToken() public nonPayable { \n    return _hicsToken;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction buyTokensT4T(address varg0) public nonPayable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(varg0 != 0);\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.allowance(varg0, address(this)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = 0x2011(_rateT4T, v4);\n    require(v5 >= _minimumInvest);\n    require(_t4tToken.code.size);\n    v6, v7 = _t4tToken.transferFrom(varg0, address(this), v4).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    0x204c(v5, varg0);\n    assert(_t4tRaised + v4 >= _t4tRaised);\n    _t4tRaised = _t4tRaised + v4;\n    assert(owner_e[varg0] + v4 >= owner_e[varg0]);\n    owner_e[varg0] = owner_e[varg0] + v4;\n}\n\nfunction endPeriodB() public nonPayable { \n    return _endPeriodB;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction softCap() public nonPayable { \n    return _softCap;\n}\n\nfunction hicsTokenPrice() public nonPayable { \n    return _hicsTokenPrice;\n}\n\nfunction buyTokensWithUpdateRate(address varg0, uint256 varg1) public payable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(msg.sender == _owner);\n    require(varg1 != 0);\n    _rate = varg1;\n    0x8c3(varg0);\n}\n\nfunction minimumInvest() public nonPayable { \n    return _minimumInvest;\n}\n\nfunction endPeriodA() public nonPayable { \n    return _endPeriodA;\n}\n\nfunction withdrawalT4T() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    require(_t4tToken.code.size);\n    v0, v1 = _t4tToken.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_t4tToken.code.size);\n    v2, v3 = _t4tToken.transfer(_wallet, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction rateT4T() public nonPayable { \n    return _rateT4T;\n}\n\nfunction totalRaised() public nonPayable { \n    return _totalRaised;\n}\n\nfunction withdrawalEth() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    v0 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction refundT4T() public nonPayable { \n    v0 = v1 = _totalRaised < _softCap;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endTime;\n    }\n    require(v0);\n    require(!stor_0_20_20);\n    stor_0_20_20 = 1;\n    owner_e[msg.sender] = 0;\n    assert(owner_e[msg.sender] <= _t4tRaised);\n    _t4tRaised = _t4tRaised - owner_e[msg.sender];\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.transfer(msg.sender, owner_e[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    stor_0_20_20 = 0;\n}\n\nfunction icsToken() public nonPayable { \n    return _icsToken;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x8c3(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    return block.timestamp > _endTime;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x8c3(uint256 varg0) private { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(address(varg0) != 0);\n    v3 = 0x2011(_rate, msg.value);\n    require(v3 >= _minimumInvest);\n    0x204c(v3, varg0);\n    assert(_weiRaised + msg.value >= _weiRaised);\n    _weiRaised = _weiRaised + msg.value;\n    v4 = address(varg0);\n    assert(owner_d[v4] + msg.value >= owner_d[v4]);\n    v5 = address(varg0);\n    owner_d[v5] = owner_d[v4] + msg.value;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xf81d248 == function_selector) {\n            endPeriodC();\n        } else if (0x1ba1648a == function_selector) {\n            changeTokensOwner();\n        } else if (0x27796092 == function_selector) {\n            t4tToken();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x3197cbb6 == function_selector) {\n            endTime();\n        } else if (0x3802d3ef == function_selector) {\n            totalTokensEmitted();\n        } else if (0x39885b23 == function_selector) {\n            finishPreSale();\n        } else if (0x39c38266 == function_selector) {\n            manualBuy(address,uint256);\n        } else if (0x3e24fcbf == function_selector) {\n            capHicsToken();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4d53c30f == function_selector) {\n            t4tRaised();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x59e5d4b5 == function_selector) {\n            hicsToken();\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8269d3c0 == function_selector) {\n            buyTokensT4T(address);\n        } else if (0x8b43234b == function_selector) {\n            endPeriodB();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x906a26e0 == function_selector) {\n            softCap();\n        } else if (0x9f03c3b8 == function_selector) {\n            hicsTokenPrice();\n        } else if (0xa2325259 == function_selector) {\n            buyTokensWithUpdateRate(address,uint256);\n        } else if (0xb10ed487 == function_selector) {\n            minimumInvest();\n        } else if (0xb80546c2 == function_selector) {\n            endPeriodA();\n        } else if (0xbe8a4737 == function_selector) {\n            withdrawalT4T();\n        } else if (0xbf2c7cbe == function_selector) {\n            rateT4T();\n        } else if (0xc5c4744c == function_selector) {\n            totalRaised();\n        } else if (0xd28f95ba == function_selector) {\n            withdrawalEth();\n        } else if (0xd6f12a6a == function_selector) {\n            refundT4T();\n        } else if (0xe87752f4 == function_selector) {\n            icsToken();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == function_selector) {\n            hasEnded();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.17 05:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x6]\nuint256 _rateT4T; // STORAGE[0x7]\nuint256 _minimumInvest; // STORAGE[0x8]\nuint256 _hicsTokenPrice; // STORAGE[0x9]\nuint256 _capHicsToken; // STORAGE[0xa]\nuint256 _softCap; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nmapping (uint256 => [uint256]) owner_e; // STORAGE[0xe]\nuint256 _weiRaised; // STORAGE[0xf]\nuint256 _t4tRaised; // STORAGE[0x10]\nuint256 _totalTokensEmitted; // STORAGE[0x11]\nuint256 _totalRaised; // STORAGE[0x12]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint64 _endTime; // STORAGE[0x4] bytes 0 to 7\naddress _t4tToken; // STORAGE[0x1] bytes 0 to 19\naddress _icsToken; // STORAGE[0x2] bytes 0 to 19\nuint8 stor_0_20_20; // STORAGE[0x0] bytes 20 to 20\naddress _hicsToken; // STORAGE[0x3] bytes 0 to 19\nuint64 _endPeriodA; // STORAGE[0x4] bytes 8 to 15\naddress _wallet; // STORAGE[0x5] bytes 0 to 19\nuint64 _startTime; // STORAGE[0x3] bytes 20 to 27\nuint64 _endPeriodB; // STORAGE[0x4] bytes 16 to 23\nuint64 _endPeriodC; // STORAGE[0x4] bytes 24 to 31\n\n// Events\nOwnershipRenounced(address);\nOwnershipTransferred(address, address);\nIcsTokenPurchase(address, address, uint256);\nHicsTokenPurchase(address, address, uint256);\n\nfunction fallback() public payable { \n    0x8c3(msg.sender);\n}\n\nfunction endPeriodC() public nonPayable { \n    return _endPeriodC;\n}\n\nfunction changeTokensOwner() public nonPayable { \n    require(msg.sender == _owner);\n    require(block.timestamp > _endTime);\n    require(_icsToken.code.size);\n    v0 = _icsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(_hicsToken.code.size);\n    v1 = _hicsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction 0x2011(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x204c(uint256 varg0, uint256 varg1) private { \n    assert(5);\n    v0 = varg0 / 5;\n    v1 = v2 = varg0 >= _hicsTokenPrice;\n    if (v2) {\n        v3 = 0x2452(v0);\n        require(_hicsToken.code.size);\n        v4, v5 = _hicsToken.totalSupply().gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v5 + v3 >= v5);\n        v1 = v6 = v5 + v3 < _capHicsToken;\n    }\n    if (!v1) {\n        0x249a(varg0, varg1);\n    } else {\n        0x249a(varg0 - v0, varg1);\n        v7 = 0x2452(v0);\n        v8 = address(varg1);\n        require(_hicsToken.code.size);\n        v9, v10 = _hicsToken.mint(v8, v7).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        emit HicsTokenPurchase(msg.sender, address(varg1), v7);\n    }\n    v11 = 0x2452(varg0);\n    assert(_totalTokensEmitted + v11 >= _totalTokensEmitted);\n    _totalTokensEmitted = _totalTokensEmitted + v11;\n    v12 = address(varg1);\n    assert(_balances[v12] + v11 >= _balances[v12]);\n    v13 = address(varg1);\n    _balances[v13] = _balances[v12] + v11;\n    v14 = _totalRaised + varg0;\n    assert(v14 >= _totalRaised);\n    _totalRaised = v14;\n    return ;\n}\n\nfunction t4tToken() public nonPayable { \n    return _t4tToken;\n}\n\nfunction 0x2452(uint256 varg0) private { \n    if (block.timestamp >= _endPeriodA) {\n        if (block.timestamp >= _endPeriodB) {\n            if (block.timestamp >= _endPeriodC) {\n                v0 = 15;\n            } else {\n                v0 = v1 = 20;\n            }\n        } else {\n            v0 = v2 = 25;\n        }\n    } else {\n        v0 = v3 = 40;\n    }\n    v4 = 0x2011(v0, varg0);\n    assert(100);\n    v5 = varg0 + v4 / 100;\n    assert(v5 >= varg0);\n    return v5;\n}\n\nfunction 0x249a(uint256 varg0, uint256 varg1) private { \n    v0 = 0x2452(varg0);\n    v1 = address(varg1);\n    require(_icsToken.code.size);\n    v2, v3 = _icsToken.mint(v1, v0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    emit IcsTokenPurchase(msg.sender, address(varg1), v0);\n    return ;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction totalTokensEmitted() public nonPayable { \n    return _totalTokensEmitted;\n}\n\nfunction finishPreSale() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    require(block.timestamp > _endTime);\n    v0 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    require(_t4tToken.code.size);\n    v1, v2 = _t4tToken.balanceOf(address(this)).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.transfer(_wallet, v2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_icsToken.code.size);\n    v5 = _icsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(_hicsToken.code.size);\n    v6 = _hicsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n}\n\nfunction manualBuy(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 >= _minimumInvest);\n    0x204c(varg1, varg0);\n}\n\nfunction capHicsToken() public nonPayable { \n    return _capHicsToken;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction t4tRaised() public nonPayable { \n    return _t4tRaised;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction refund() public nonPayable { \n    v0 = v1 = _totalRaised < _softCap;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endTime;\n    }\n    require(v0);\n    require(!stor_0_20_20);\n    stor_0_20_20 = 1;\n    owner_d[msg.sender] = 0;\n    assert(owner_d[msg.sender] <= _weiRaised);\n    _weiRaised = _weiRaised - owner_d[msg.sender];\n    v3 = msg.sender.call().value(owner_d[msg.sender]).gas(!owner_d[msg.sender] * 2300);\n    require(v3); // checks call status, propagates error data on error\n    stor_0_20_20 = 0;\n}\n\nfunction hicsToken() public nonPayable { \n    return _hicsToken;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction buyTokensT4T(address varg0) public nonPayable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(varg0 != 0);\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.allowance(varg0, address(this)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = 0x2011(_rateT4T, v4);\n    require(v5 >= _minimumInvest);\n    require(_t4tToken.code.size);\n    v6, v7 = _t4tToken.transferFrom(varg0, address(this), v4).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    0x204c(v5, varg0);\n    assert(_t4tRaised + v4 >= _t4tRaised);\n    _t4tRaised = _t4tRaised + v4;\n    assert(owner_e[varg0] + v4 >= owner_e[varg0]);\n    owner_e[varg0] = owner_e[varg0] + v4;\n}\n\nfunction endPeriodB() public nonPayable { \n    return _endPeriodB;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction softCap() public nonPayable { \n    return _softCap;\n}\n\nfunction hicsTokenPrice() public nonPayable { \n    return _hicsTokenPrice;\n}\n\nfunction buyTokensWithUpdateRate(address varg0, uint256 varg1) public payable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(msg.sender == _owner);\n    require(varg1 != 0);\n    _rate = varg1;\n    0x8c3(varg0);\n}\n\nfunction minimumInvest() public nonPayable { \n    return _minimumInvest;\n}\n\nfunction endPeriodA() public nonPayable { \n    return _endPeriodA;\n}\n\nfunction withdrawalT4T() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    require(_t4tToken.code.size);\n    v0, v1 = _t4tToken.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_t4tToken.code.size);\n    v2, v3 = _t4tToken.transfer(_wallet, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction rateT4T() public nonPayable { \n    return _rateT4T;\n}\n\nfunction totalRaised() public nonPayable { \n    return _totalRaised;\n}\n\nfunction withdrawalEth() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    v0 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction refundT4T() public nonPayable { \n    v0 = v1 = _totalRaised < _softCap;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endTime;\n    }\n    require(v0);\n    require(!stor_0_20_20);\n    stor_0_20_20 = 1;\n    owner_e[msg.sender] = 0;\n    assert(owner_e[msg.sender] <= _t4tRaised);\n    _t4tRaised = _t4tRaised - owner_e[msg.sender];\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.transfer(msg.sender, owner_e[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    stor_0_20_20 = 0;\n}\n\nfunction icsToken() public nonPayable { \n    return _icsToken;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x8c3(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    return block.timestamp > _endTime;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x8c3(uint256 varg0) private { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(address(varg0) != 0);\n    v3 = 0x2011(_rate, msg.value);\n    require(v3 >= _minimumInvest);\n    0x204c(v3, varg0);\n    assert(_weiRaised + msg.value >= _weiRaised);\n    _weiRaised = _weiRaised + msg.value;\n    v4 = address(varg0);\n    assert(owner_d[v4] + msg.value >= owner_d[v4]);\n    v5 = address(varg0);\n    owner_d[v5] = owner_d[v4] + msg.value;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xf81d248 == function_selector) {\n            endPeriodC();\n        } else if (0x1ba1648a == function_selector) {\n            changeTokensOwner();\n        } else if (0x27796092 == function_selector) {\n            t4tToken();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x3197cbb6 == function_selector) {\n            endTime();\n        } else if (0x3802d3ef == function_selector) {\n            totalTokensEmitted();\n        } else if (0x39885b23 == function_selector) {\n            finishPreSale();\n        } else if (0x39c38266 == function_selector) {\n            manualBuy(address,uint256);\n        } else if (0x3e24fcbf == function_selector) {\n            capHicsToken();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4d53c30f == function_selector) {\n            t4tRaised();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x59e5d4b5 == function_selector) {\n            hicsToken();\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8269d3c0 == function_selector) {\n            buyTokensT4T(address);\n        } else if (0x8b43234b == function_selector) {\n            endPeriodB();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x906a26e0 == function_selector) {\n            softCap();\n        } else if (0x9f03c3b8 == function_selector) {\n            hicsTokenPrice();\n        } else if (0xa2325259 == function_selector) {\n            buyTokensWithUpdateRate(address,uint256);\n        } else if (0xb10ed487 == function_selector) {\n            minimumInvest();\n        } else if (0xb80546c2 == function_selector) {\n            endPeriodA();\n        } else if (0xbe8a4737 == function_selector) {\n            withdrawalT4T();\n        } else if (0xbf2c7cbe == function_selector) {\n            rateT4T();\n        } else if (0xc5c4744c == function_selector) {\n            totalRaised();\n        } else if (0xd28f95ba == function_selector) {\n            withdrawalEth();\n        } else if (0xd6f12a6a == function_selector) {\n            refundT4T();\n        } else if (0xe87752f4 == function_selector) {\n            icsToken();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == function_selector) {\n            hasEnded();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.17 05:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x6]\nuint256 _rateT4T; // STORAGE[0x7]\nuint256 _minimumInvest; // STORAGE[0x8]\nuint256 _hicsTokenPrice; // STORAGE[0x9]\nuint256 _capHicsToken; // STORAGE[0xa]\nuint256 _softCap; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nmapping (uint256 => [uint256]) owner_e; // STORAGE[0xe]\nuint256 _weiRaised; // STORAGE[0xf]\nuint256 _t4tRaised; // STORAGE[0x10]\nuint256 _totalTokensEmitted; // STORAGE[0x11]\nuint256 _totalRaised; // STORAGE[0x12]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint64 _endTime; // STORAGE[0x4] bytes 0 to 7\naddress _t4tToken; // STORAGE[0x1] bytes 0 to 19\naddress _icsToken; // STORAGE[0x2] bytes 0 to 19\nuint8 stor_0_20_20; // STORAGE[0x0] bytes 20 to 20\naddress _hicsToken; // STORAGE[0x3] bytes 0 to 19\nuint64 _endPeriodA; // STORAGE[0x4] bytes 8 to 15\naddress _wallet; // STORAGE[0x5] bytes 0 to 19\nuint64 _startTime; // STORAGE[0x3] bytes 20 to 27\nuint64 _endPeriodB; // STORAGE[0x4] bytes 16 to 23\nuint64 _endPeriodC; // STORAGE[0x4] bytes 24 to 31\n\n// Events\nOwnershipRenounced(address);\nOwnershipTransferred(address, address);\nIcsTokenPurchase(address, address, uint256);\nHicsTokenPurchase(address, address, uint256);\n\nfunction fallback() public payable { \n    0x8c3(msg.sender);\n}\n\nfunction endPeriodC() public nonPayable { \n    return _endPeriodC;\n}\n\nfunction changeTokensOwner() public nonPayable { \n    require(msg.sender == _owner);\n    require(block.timestamp > _endTime);\n    require(_icsToken.code.size);\n    v0 = _icsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(_hicsToken.code.size);\n    v1 = _hicsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction 0x2011(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x204c(uint256 varg0, uint256 varg1) private { \n    assert(5);\n    v0 = varg0 / 5;\n    v1 = v2 = varg0 >= _hicsTokenPrice;\n    if (v2) {\n        v3 = 0x2452(v0);\n        require(_hicsToken.code.size);\n        v4, v5 = _hicsToken.totalSupply().gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v5 + v3 >= v5);\n        v1 = v6 = v5 + v3 < _capHicsToken;\n    }\n    if (!v1) {\n        0x249a(varg0, varg1);\n    } else {\n        0x249a(varg0 - v0, varg1);\n        v7 = 0x2452(v0);\n        v8 = address(varg1);\n        require(_hicsToken.code.size);\n        v9, v10 = _hicsToken.mint(v8, v7).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        emit HicsTokenPurchase(msg.sender, address(varg1), v7);\n    }\n    v11 = 0x2452(varg0);\n    assert(_totalTokensEmitted + v11 >= _totalTokensEmitted);\n    _totalTokensEmitted = _totalTokensEmitted + v11;\n    v12 = address(varg1);\n    assert(_balances[v12] + v11 >= _balances[v12]);\n    v13 = address(varg1);\n    _balances[v13] = _balances[v12] + v11;\n    v14 = _totalRaised + varg0;\n    assert(v14 >= _totalRaised);\n    _totalRaised = v14;\n    return ;\n}\n\nfunction t4tToken() public nonPayable { \n    return _t4tToken;\n}\n\nfunction 0x2452(uint256 varg0) private { \n    if (block.timestamp >= _endPeriodA) {\n        if (block.timestamp >= _endPeriodB) {\n            if (block.timestamp >= _endPeriodC) {\n                v0 = 15;\n            } else {\n                v0 = v1 = 20;\n            }\n        } else {\n            v0 = v2 = 25;\n        }\n    } else {\n        v0 = v3 = 40;\n    }\n    v4 = 0x2011(v0, varg0);\n    assert(100);\n    v5 = varg0 + v4 / 100;\n    assert(v5 >= varg0);\n    return v5;\n}\n\nfunction 0x249a(uint256 varg0, uint256 varg1) private { \n    v0 = 0x2452(varg0);\n    v1 = address(varg1);\n    require(_icsToken.code.size);\n    v2, v3 = _icsToken.mint(v1, v0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    emit IcsTokenPurchase(msg.sender, address(varg1), v0);\n    return ;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction totalTokensEmitted() public nonPayable { \n    return _totalTokensEmitted;\n}\n\nfunction finishPreSale() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    require(block.timestamp > _endTime);\n    v0 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    require(_t4tToken.code.size);\n    v1, v2 = _t4tToken.balanceOf(address(this)).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.transfer(_wallet, v2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_icsToken.code.size);\n    v5 = _icsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(_hicsToken.code.size);\n    v6 = _hicsToken.transferOwnership(_owner).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n}\n\nfunction manualBuy(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 >= _minimumInvest);\n    0x204c(varg1, varg0);\n}\n\nfunction capHicsToken() public nonPayable { \n    return _capHicsToken;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction t4tRaised() public nonPayable { \n    return _t4tRaised;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction refund() public nonPayable { \n    v0 = v1 = _totalRaised < _softCap;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endTime;\n    }\n    require(v0);\n    require(!stor_0_20_20);\n    stor_0_20_20 = 1;\n    owner_d[msg.sender] = 0;\n    assert(owner_d[msg.sender] <= _weiRaised);\n    _weiRaised = _weiRaised - owner_d[msg.sender];\n    v3 = msg.sender.call().value(owner_d[msg.sender]).gas(!owner_d[msg.sender] * 2300);\n    require(v3); // checks call status, propagates error data on error\n    stor_0_20_20 = 0;\n}\n\nfunction hicsToken() public nonPayable { \n    return _hicsToken;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction buyTokensT4T(address varg0) public nonPayable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(varg0 != 0);\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.allowance(varg0, address(this)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = 0x2011(_rateT4T, v4);\n    require(v5 >= _minimumInvest);\n    require(_t4tToken.code.size);\n    v6, v7 = _t4tToken.transferFrom(varg0, address(this), v4).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    0x204c(v5, varg0);\n    assert(_t4tRaised + v4 >= _t4tRaised);\n    _t4tRaised = _t4tRaised + v4;\n    assert(owner_e[varg0] + v4 >= owner_e[varg0]);\n    owner_e[varg0] = owner_e[varg0] + v4;\n}\n\nfunction endPeriodB() public nonPayable { \n    return _endPeriodB;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction softCap() public nonPayable { \n    return _softCap;\n}\n\nfunction hicsTokenPrice() public nonPayable { \n    return _hicsTokenPrice;\n}\n\nfunction buyTokensWithUpdateRate(address varg0, uint256 varg1) public payable { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(msg.sender == _owner);\n    require(varg1 != 0);\n    _rate = varg1;\n    0x8c3(varg0);\n}\n\nfunction minimumInvest() public nonPayable { \n    return _minimumInvest;\n}\n\nfunction endPeriodA() public nonPayable { \n    return _endPeriodA;\n}\n\nfunction withdrawalT4T() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    require(_t4tToken.code.size);\n    v0, v1 = _t4tToken.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_t4tToken.code.size);\n    v2, v3 = _t4tToken.transfer(_wallet, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction rateT4T() public nonPayable { \n    return _rateT4T;\n}\n\nfunction totalRaised() public nonPayable { \n    return _totalRaised;\n}\n\nfunction withdrawalEth() public nonPayable { \n    require(msg.sender == _owner);\n    require(_totalRaised >= _softCap);\n    v0 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction refundT4T() public nonPayable { \n    v0 = v1 = _totalRaised < _softCap;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endTime;\n    }\n    require(v0);\n    require(!stor_0_20_20);\n    stor_0_20_20 = 1;\n    owner_e[msg.sender] = 0;\n    assert(owner_e[msg.sender] <= _t4tRaised);\n    _t4tRaised = _t4tRaised - owner_e[msg.sender];\n    require(_t4tToken.code.size);\n    v3, v4 = _t4tToken.transfer(msg.sender, owner_e[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    stor_0_20_20 = 0;\n}\n\nfunction icsToken() public nonPayable { \n    return _icsToken;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x8c3(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    return block.timestamp > _endTime;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x8c3(uint256 varg0) private { \n    v0 = v1 = block.timestamp >= _startTime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endTime;\n    }\n    require(v0);\n    require(address(varg0) != 0);\n    v3 = 0x2011(_rate, msg.value);\n    require(v3 >= _minimumInvest);\n    0x204c(v3, varg0);\n    assert(_weiRaised + msg.value >= _weiRaised);\n    _weiRaised = _weiRaised + msg.value;\n    v4 = address(varg0);\n    assert(owner_d[v4] + msg.value >= owner_d[v4]);\n    v5 = address(varg0);\n    owner_d[v5] = owner_d[v4] + msg.value;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xf81d248 == function_selector) {\n            endPeriodC();\n        } else if (0x1ba1648a == function_selector) {\n            changeTokensOwner();\n        } else if (0x27796092 == function_selector) {\n            t4tToken();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x3197cbb6 == function_selector) {\n            endTime();\n        } else if (0x3802d3ef == function_selector) {\n            totalTokensEmitted();\n        } else if (0x39885b23 == function_selector) {\n            finishPreSale();\n        } else if (0x39c38266 == function_selector) {\n            manualBuy(address,uint256);\n        } else if (0x3e24fcbf == function_selector) {\n            capHicsToken();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4d53c30f == function_selector) {\n            t4tRaised();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x59e5d4b5 == function_selector) {\n            hicsToken();\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8269d3c0 == function_selector) {\n            buyTokensT4T(address);\n        } else if (0x8b43234b == function_selector) {\n            endPeriodB();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x906a26e0 == function_selector) {\n            softCap();\n        } else if (0x9f03c3b8 == function_selector) {\n            hicsTokenPrice();\n        } else if (0xa2325259 == function_selector) {\n            buyTokensWithUpdateRate(address,uint256);\n        } else if (0xb10ed487 == function_selector) {\n            minimumInvest();\n        } else if (0xb80546c2 == function_selector) {\n            endPeriodA();\n        } else if (0xbe8a4737 == function_selector) {\n            withdrawalT4T();\n        } else if (0xbf2c7cbe == function_selector) {\n            rateT4T();\n        } else if (0xc5c4744c == function_selector) {\n            totalRaised();\n        } else if (0xd28f95ba == function_selector) {\n            withdrawalEth();\n        } else if (0xd6f12a6a == function_selector) {\n            refundT4T();\n        } else if (0xe87752f4 == function_selector) {\n            icsToken();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == function_selector) {\n            hasEnded();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.6438307762146,
	"usage": {
		"completion_tokens": 464,
		"prompt_tokens": 4384,
		"total_tokens": 4848
	}
}