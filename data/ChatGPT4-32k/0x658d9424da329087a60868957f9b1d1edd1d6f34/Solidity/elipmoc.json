{
	"address": "0x658d9424da329087a60868957f9b1d1edd1d6f34",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity implementation of the above decompiled code may look as follows:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IToken {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function updateTotalSupply(uint256 newSupply) external;\n    function MAX_SUPPLY() external view returns (uint256);\n}\n\ncontract ICO {\n    uint256 private _startICOPhaseOne;\n    uint256 private _startICOPhaseTwo;\n    uint256 private _startICOPhaseThree;\n    uint256 private _endICO;\n    uint256 private _phaseOneRate;\n    uint256 private _phaseTwoRate;\n    uint256 private _phaseThreeRate;\n    uint256 private _weiRaised;\n    uint256 private _teamTokens;\n    IToken private _token;\n    uint8 private _presaleDist;\n    address payable private _wallet;\n    address private _admin;\n    uint8 private _haltSale;\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    constructor(address token, address admin, address payable wallet) public {\n        _token = IToken(token);\n        _admin = admin;\n        _wallet = wallet;\n    }\n\n    function phaseOneRate() public view returns (uint256) {\n        return _phaseOneRate;\n    }\n\n    function weiRaised() public view returns (uint256) {\n        return _weiRaised;\n    }\n\n    function presaleDist() public view returns (uint8) {\n        return _presaleDist;\n    }\n\n    // other getter functions are omitted for brevity\n\n    function distPresale(address recipient, uint256 amount) public {\n        require(_admin == msg.sender, \"Only admin can distribute presale\");\n        require(amount <= 0xac0db698068112d000000, \"Amount exceeds limit\");\n        require(_presaleDist == 0, \"Presale already distributed\");\n        _presaleDist = 1;\n        require(_token.transfer(recipient, amount), \"Transfer failed\");\n    }\n\n    // other public functions are omitted for brevity\n\n    function buyTokens(address beneficiary) public payable {\n        require(beneficiary != address(0), \"Cannot transfer to the zero address\");\n        require(msg.value > 0, \"Value cannot be 0\");\n        require(_haltSale == 0, \"Sale is halted\");\n        uint256 tokens;\n        if (block.timestamp > _startICOPhaseTwo) {\n            if (block.timestamp >= _startICOPhaseThree) {\n                tokens = _SafeMul(_phaseThreeRate, msg.value);\n            } else {\n                tokens = _SafeMul(_phaseTwoRate, msg.value);\n            }\n        } else {\n            tokens = _SafeMul(_phaseOneRate, msg.value);\n        }\n        _token.updateTotalSupply(tokens);\n        _weiRaised += msg.value;\n        require(_token.transfer(beneficiary, tokens), \"Transfer failed\");\n        emit TokenPurchase(msg.sender, beneficiary, msg.value, tokens);\n        if (address(this).balance > 1 ether) {\n            _wallet.transfer(address(this).balance);\n        }\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMul: multiplication overflow\");\n        return c;\n    }\n\n    receive() external payable {\n        buyTokens(msg.sender);\n    }\n}\n```\n\nThis is a simplified version of the decompiled code. The contract represents an Initial Coin Offering (ICO) process where tokens are sold in different phases. Please note that the actual implementation might be different based on the business requirements and other functionalities of the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462855,
	"id": "chatcmpl-8R4VDnGWNVzAwj2tgB7AqZLnIMycI",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 22:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startICOPhaseOne; // STORAGE[0x1]\nuint256 _startICOPhaseTwo; // STORAGE[0x2]\nuint256 _startICOPhaseThree; // STORAGE[0x3]\nuint256 _endICO; // STORAGE[0x4]\nuint256 _phaseOneRate; // STORAGE[0x6]\nuint256 _phaseTwoRate; // STORAGE[0x7]\nuint256 _phaseThreeRate; // STORAGE[0x8]\nuint256 _weiRaised; // STORAGE[0x9]\nuint256 _teamTokens; // STORAGE[0xb]\naddress _token; // STORAGE[0x0] bytes 0 to 19\nuint8 _presaleDist; // STORAGE[0xc] bytes 0 to 0\naddress _wallet; // STORAGE[0x5] bytes 0 to 19\naddress _admin; // STORAGE[0xa] bytes 0 to 19\nuint8 _haltSale; // STORAGE[0xa] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\n\nfunction phaseOneRate() public nonPayable { \n    return _phaseOneRate;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction presaleDist() public nonPayable { \n    return _presaleDist;\n}\n\nfunction distPresale(address varg0, uint256 varg1) public nonPayable { \n    require(_admin == msg.sender);\n    require(varg1 <= 0xac0db698068112d000000);\n    require(!_presaleDist);\n    _presaleDist = 1;\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction endICO() public nonPayable { \n    return _endICO;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction finalizeSale() public nonPayable { \n    require(_admin == msg.sender);\n    require(block.timestamp > _endICO);\n    if ((address(this)).balance > 0) {\n        v0 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v1, v2 = _token.MAX_SUPPLY().gas(msg.gas - 710);\n    require(v1);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v3, v4 = _token.totalSupply().gas(msg.gas - 710);\n    require(v3);\n    if (v4 < v2) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v5, v6 = _token.totalSupply().gas(msg.gas - 710);\n        require(v5);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v7, v8 = _token.MAX_SUPPLY().gas(msg.gas - 710);\n        require(v7);\n        assert(v6 <= v8);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v9, v10 = _token.transfer(_wallet, v8 - v6).gas(msg.gas - 710);\n        require(v9);\n        require(_token.code.size);\n        v11 = _token.updateTotalSupply(v8 - v6).gas(msg.gas - 710);\n        require(v11);\n    }\n}\n\nfunction haltSale() public nonPayable { \n    return _haltSale;\n}\n\nfunction startICOPhaseOne() public nonPayable { \n    return _startICOPhaseOne;\n}\n\nfunction phaseTwoRate() public nonPayable { \n    return _phaseTwoRate;\n}\n\nfunction startICOPhaseTwo() public nonPayable { \n    return _startICOPhaseTwo;\n}\n\nfunction withdrawTeamTokens() public nonPayable { \n    require(_admin == msg.sender);\n    require(block.timestamp >= 0x1e13380 + _startICOPhaseOne);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(_wallet, _teamTokens).gas(msg.gas - 710);\n    require(v0);\n    return 1;\n}\n\nfunction phaseThreeRate() public nonPayable { \n    return _phaseThreeRate;\n}\n\nfunction teamTokens() public nonPayable { \n    return _teamTokens;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x2b3(varg0);\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction currentRate() public nonPayable { \n    if (block.timestamp > _startICOPhaseTwo) {\n        if (block.timestamp > _startICOPhaseThree) {\n            v0 = v1 = _phaseThreeRate;\n        } else {\n            v0 = v2 = _phaseTwoRate;\n        }\n    } else {\n        v0 = v3 = _phaseOneRate;\n    }\n    return v0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x2b3(uint256 varg0) private { \n    require(address(varg0));\n    v0 = v1 = block.timestamp >= _startICOPhaseOne;\n    if (v1) {\n        v0 = block.timestamp <= _endICO;\n    }\n    v0 = v2 = msg.value;\n    require(v0);\n    require(!_haltSale);\n    if (block.timestamp > _startICOPhaseTwo) {\n        if (block.timestamp >= _startICOPhaseThree) {\n            v3 = v4 = _SafeMul(_phaseThreeRate, msg.value);\n        } else {\n            v3 = v5 = _SafeMul(_phaseTwoRate, msg.value);\n        }\n    } else {\n        v3 = v6 = _SafeMul(_phaseOneRate, msg.value);\n    }\n    require(_token.code.size);\n    v7 = _token.updateTotalSupply(v3).gas(msg.gas - 710);\n    require(v7);\n    assert(msg.value + _weiRaised >= _weiRaised);\n    _weiRaised += msg.value;\n    MEM[32 + MEM[64]] = 0;\n    v8 = address(varg0);\n    require(_token.code.size);\n    v9, v10 = _token.transfer(v8, v3).gas(msg.gas - 710);\n    require(v9);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3);\n    if ((address(this)).balance > 0xde0b6b3a7640000) {\n        v11 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v11);\n    }\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x2b3(msg.sender);\n}\n\nfunction startICOPhaseThree() public nonPayable { \n    return _startICOPhaseThree;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc65e229) {\n            startICOPhaseThree();\n        } else if (0x2540c420 == v0) {\n            phaseOneRate();\n        } else if (0x4042b66f == v0) {\n            weiRaised();\n        } else if (0x40e15134 == v0) {\n            presaleDist();\n        } else if (0x4591b8a0 == v0) {\n            distPresale(address,uint256);\n        } else if (0x4f248409 == v0) {\n            endICO();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x58a687ec == v0) {\n            finalizeSale();\n        } else if (0x5fbaa390 == v0) {\n            haltSale();\n        } else if (0x762ac19d == v0) {\n            startICOPhaseOne();\n        } else if (0x7aa356af == v0) {\n            phaseTwoRate();\n        } else if (0x8a61b26d == v0) {\n            startICOPhaseTwo();\n        } else if (0x953b7ef8 == v0) {\n            withdrawTeamTokens();\n        } else if (0xa20aede0 == v0) {\n            phaseThreeRate();\n        } else if (0xc3e3c7bc == v0) {\n            teamTokens();\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xf851a440 == v0) {\n            admin();\n        } else if (0xf9f8bdb7 == v0) {\n            currentRate();\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 22:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startICOPhaseOne; // STORAGE[0x1]\nuint256 _startICOPhaseTwo; // STORAGE[0x2]\nuint256 _startICOPhaseThree; // STORAGE[0x3]\nuint256 _endICO; // STORAGE[0x4]\nuint256 _phaseOneRate; // STORAGE[0x6]\nuint256 _phaseTwoRate; // STORAGE[0x7]\nuint256 _phaseThreeRate; // STORAGE[0x8]\nuint256 _weiRaised; // STORAGE[0x9]\nuint256 _teamTokens; // STORAGE[0xb]\naddress _token; // STORAGE[0x0] bytes 0 to 19\nuint8 _presaleDist; // STORAGE[0xc] bytes 0 to 0\naddress _wallet; // STORAGE[0x5] bytes 0 to 19\naddress _admin; // STORAGE[0xa] bytes 0 to 19\nuint8 _haltSale; // STORAGE[0xa] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\n\nfunction phaseOneRate() public nonPayable { \n    return _phaseOneRate;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction presaleDist() public nonPayable { \n    return _presaleDist;\n}\n\nfunction distPresale(address varg0, uint256 varg1) public nonPayable { \n    require(_admin == msg.sender);\n    require(varg1 <= 0xac0db698068112d000000);\n    require(!_presaleDist);\n    _presaleDist = 1;\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction endICO() public nonPayable { \n    return _endICO;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction finalizeSale() public nonPayable { \n    require(_admin == msg.sender);\n    require(block.timestamp > _endICO);\n    if ((address(this)).balance > 0) {\n        v0 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v1, v2 = _token.MAX_SUPPLY().gas(msg.gas - 710);\n    require(v1);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v3, v4 = _token.totalSupply().gas(msg.gas - 710);\n    require(v3);\n    if (v4 < v2) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v5, v6 = _token.totalSupply().gas(msg.gas - 710);\n        require(v5);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v7, v8 = _token.MAX_SUPPLY().gas(msg.gas - 710);\n        require(v7);\n        assert(v6 <= v8);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v9, v10 = _token.transfer(_wallet, v8 - v6).gas(msg.gas - 710);\n        require(v9);\n        require(_token.code.size);\n        v11 = _token.updateTotalSupply(v8 - v6).gas(msg.gas - 710);\n        require(v11);\n    }\n}\n\nfunction haltSale() public nonPayable { \n    return _haltSale;\n}\n\nfunction startICOPhaseOne() public nonPayable { \n    return _startICOPhaseOne;\n}\n\nfunction phaseTwoRate() public nonPayable { \n    return _phaseTwoRate;\n}\n\nfunction startICOPhaseTwo() public nonPayable { \n    return _startICOPhaseTwo;\n}\n\nfunction withdrawTeamTokens() public nonPayable { \n    require(_admin == msg.sender);\n    require(block.timestamp >= 0x1e13380 + _startICOPhaseOne);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(_wallet, _teamTokens).gas(msg.gas - 710);\n    require(v0);\n    return 1;\n}\n\nfunction phaseThreeRate() public nonPayable { \n    return _phaseThreeRate;\n}\n\nfunction teamTokens() public nonPayable { \n    return _teamTokens;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x2b3(varg0);\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction currentRate() public nonPayable { \n    if (block.timestamp > _startICOPhaseTwo) {\n        if (block.timestamp > _startICOPhaseThree) {\n            v0 = v1 = _phaseThreeRate;\n        } else {\n            v0 = v2 = _phaseTwoRate;\n        }\n    } else {\n        v0 = v3 = _phaseOneRate;\n    }\n    return v0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x2b3(uint256 varg0) private { \n    require(address(varg0));\n    v0 = v1 = block.timestamp >= _startICOPhaseOne;\n    if (v1) {\n        v0 = block.timestamp <= _endICO;\n    }\n    v0 = v2 = msg.value;\n    require(v0);\n    require(!_haltSale);\n    if (block.timestamp > _startICOPhaseTwo) {\n        if (block.timestamp >= _startICOPhaseThree) {\n            v3 = v4 = _SafeMul(_phaseThreeRate, msg.value);\n        } else {\n            v3 = v5 = _SafeMul(_phaseTwoRate, msg.value);\n        }\n    } else {\n        v3 = v6 = _SafeMul(_phaseOneRate, msg.value);\n    }\n    require(_token.code.size);\n    v7 = _token.updateTotalSupply(v3).gas(msg.gas - 710);\n    require(v7);\n    assert(msg.value + _weiRaised >= _weiRaised);\n    _weiRaised += msg.value;\n    MEM[32 + MEM[64]] = 0;\n    v8 = address(varg0);\n    require(_token.code.size);\n    v9, v10 = _token.transfer(v8, v3).gas(msg.gas - 710);\n    require(v9);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3);\n    if ((address(this)).balance > 0xde0b6b3a7640000) {\n        v11 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v11);\n    }\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x2b3(msg.sender);\n}\n\nfunction startICOPhaseThree() public nonPayable { \n    return _startICOPhaseThree;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc65e229) {\n            startICOPhaseThree();\n        } else if (0x2540c420 == v0) {\n            phaseOneRate();\n        } else if (0x4042b66f == v0) {\n            weiRaised();\n        } else if (0x40e15134 == v0) {\n            presaleDist();\n        } else if (0x4591b8a0 == v0) {\n            distPresale(address,uint256);\n        } else if (0x4f248409 == v0) {\n            endICO();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x58a687ec == v0) {\n            finalizeSale();\n        } else if (0x5fbaa390 == v0) {\n            haltSale();\n        } else if (0x762ac19d == v0) {\n            startICOPhaseOne();\n        } else if (0x7aa356af == v0) {\n            phaseTwoRate();\n        } else if (0x8a61b26d == v0) {\n            startICOPhaseTwo();\n        } else if (0x953b7ef8 == v0) {\n            withdrawTeamTokens();\n        } else if (0xa20aede0 == v0) {\n            phaseThreeRate();\n        } else if (0xc3e3c7bc == v0) {\n            teamTokens();\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xf851a440 == v0) {\n            admin();\n        } else if (0xf9f8bdb7 == v0) {\n            currentRate();\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 22:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startICOPhaseOne; // STORAGE[0x1]\nuint256 _startICOPhaseTwo; // STORAGE[0x2]\nuint256 _startICOPhaseThree; // STORAGE[0x3]\nuint256 _endICO; // STORAGE[0x4]\nuint256 _phaseOneRate; // STORAGE[0x6]\nuint256 _phaseTwoRate; // STORAGE[0x7]\nuint256 _phaseThreeRate; // STORAGE[0x8]\nuint256 _weiRaised; // STORAGE[0x9]\nuint256 _teamTokens; // STORAGE[0xb]\naddress _token; // STORAGE[0x0] bytes 0 to 19\nuint8 _presaleDist; // STORAGE[0xc] bytes 0 to 0\naddress _wallet; // STORAGE[0x5] bytes 0 to 19\naddress _admin; // STORAGE[0xa] bytes 0 to 19\nuint8 _haltSale; // STORAGE[0xa] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\n\nfunction phaseOneRate() public nonPayable { \n    return _phaseOneRate;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction presaleDist() public nonPayable { \n    return _presaleDist;\n}\n\nfunction distPresale(address varg0, uint256 varg1) public nonPayable { \n    require(_admin == msg.sender);\n    require(varg1 <= 0xac0db698068112d000000);\n    require(!_presaleDist);\n    _presaleDist = 1;\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction endICO() public nonPayable { \n    return _endICO;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction finalizeSale() public nonPayable { \n    require(_admin == msg.sender);\n    require(block.timestamp > _endICO);\n    if ((address(this)).balance > 0) {\n        v0 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v1, v2 = _token.MAX_SUPPLY().gas(msg.gas - 710);\n    require(v1);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v3, v4 = _token.totalSupply().gas(msg.gas - 710);\n    require(v3);\n    if (v4 < v2) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v5, v6 = _token.totalSupply().gas(msg.gas - 710);\n        require(v5);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v7, v8 = _token.MAX_SUPPLY().gas(msg.gas - 710);\n        require(v7);\n        assert(v6 <= v8);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v9, v10 = _token.transfer(_wallet, v8 - v6).gas(msg.gas - 710);\n        require(v9);\n        require(_token.code.size);\n        v11 = _token.updateTotalSupply(v8 - v6).gas(msg.gas - 710);\n        require(v11);\n    }\n}\n\nfunction haltSale() public nonPayable { \n    return _haltSale;\n}\n\nfunction startICOPhaseOne() public nonPayable { \n    return _startICOPhaseOne;\n}\n\nfunction phaseTwoRate() public nonPayable { \n    return _phaseTwoRate;\n}\n\nfunction startICOPhaseTwo() public nonPayable { \n    return _startICOPhaseTwo;\n}\n\nfunction withdrawTeamTokens() public nonPayable { \n    require(_admin == msg.sender);\n    require(block.timestamp >= 0x1e13380 + _startICOPhaseOne);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(_wallet, _teamTokens).gas(msg.gas - 710);\n    require(v0);\n    return 1;\n}\n\nfunction phaseThreeRate() public nonPayable { \n    return _phaseThreeRate;\n}\n\nfunction teamTokens() public nonPayable { \n    return _teamTokens;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x2b3(varg0);\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction currentRate() public nonPayable { \n    if (block.timestamp > _startICOPhaseTwo) {\n        if (block.timestamp > _startICOPhaseThree) {\n            v0 = v1 = _phaseThreeRate;\n        } else {\n            v0 = v2 = _phaseTwoRate;\n        }\n    } else {\n        v0 = v3 = _phaseOneRate;\n    }\n    return v0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x2b3(uint256 varg0) private { \n    require(address(varg0));\n    v0 = v1 = block.timestamp >= _startICOPhaseOne;\n    if (v1) {\n        v0 = block.timestamp <= _endICO;\n    }\n    v0 = v2 = msg.value;\n    require(v0);\n    require(!_haltSale);\n    if (block.timestamp > _startICOPhaseTwo) {\n        if (block.timestamp >= _startICOPhaseThree) {\n            v3 = v4 = _SafeMul(_phaseThreeRate, msg.value);\n        } else {\n            v3 = v5 = _SafeMul(_phaseTwoRate, msg.value);\n        }\n    } else {\n        v3 = v6 = _SafeMul(_phaseOneRate, msg.value);\n    }\n    require(_token.code.size);\n    v7 = _token.updateTotalSupply(v3).gas(msg.gas - 710);\n    require(v7);\n    assert(msg.value + _weiRaised >= _weiRaised);\n    _weiRaised += msg.value;\n    MEM[32 + MEM[64]] = 0;\n    v8 = address(varg0);\n    require(_token.code.size);\n    v9, v10 = _token.transfer(v8, v3).gas(msg.gas - 710);\n    require(v9);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3);\n    if ((address(this)).balance > 0xde0b6b3a7640000) {\n        v11 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v11);\n    }\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x2b3(msg.sender);\n}\n\nfunction startICOPhaseThree() public nonPayable { \n    return _startICOPhaseThree;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc65e229) {\n            startICOPhaseThree();\n        } else if (0x2540c420 == v0) {\n            phaseOneRate();\n        } else if (0x4042b66f == v0) {\n            weiRaised();\n        } else if (0x40e15134 == v0) {\n            presaleDist();\n        } else if (0x4591b8a0 == v0) {\n            distPresale(address,uint256);\n        } else if (0x4f248409 == v0) {\n            endICO();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x58a687ec == v0) {\n            finalizeSale();\n        } else if (0x5fbaa390 == v0) {\n            haltSale();\n        } else if (0x762ac19d == v0) {\n            startICOPhaseOne();\n        } else if (0x7aa356af == v0) {\n            phaseTwoRate();\n        } else if (0x8a61b26d == v0) {\n            startICOPhaseTwo();\n        } else if (0x953b7ef8 == v0) {\n            withdrawTeamTokens();\n        } else if (0xa20aede0 == v0) {\n            phaseThreeRate();\n        } else if (0xc3e3c7bc == v0) {\n            teamTokens();\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xf851a440 == v0) {\n            admin();\n        } else if (0xf9f8bdb7 == v0) {\n            currentRate();\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 37.369545459747314,
	"usage": {
		"completion_tokens": 809,
		"prompt_tokens": 2239,
		"total_tokens": 3048
	}
}