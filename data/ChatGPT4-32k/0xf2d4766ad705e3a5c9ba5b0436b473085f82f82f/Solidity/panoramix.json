{
	"address": "0xf2d4766ad705e3a5c9ba5b0436b473085f82f82f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity version of the provided decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyClass{\n    address public owner;\n    address public stor1;\n    mapping (address => address) public stor2;\n    mapping (address => bool) public stor3;\n    mapping (address => bool) public stor4;\n    mapping (address => Entry) public stor5;\n    mapping (address => uint256) public stor6;\n    address[] public destKeys;\n\n    struct Entry {\n        bytes32 field_0;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setDefaultSweeper(address sweeper) public onlyOwner {\n        stor1 = sweeper;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        owner = newOwner;\n    }\n\n    function authorizeAddress(address addr) public onlyOwner {\n        stor3[addr] = true;\n    }\n\n    function revokeAuthorization(address addr) public onlyOwner {\n        stor3[addr] = false;\n    }\n\n    function setSweeper(address asset, address sweeper) public onlyOwner {\n        stor2[asset] = sweeper;\n    }\n\n    function sweeperOf(address _token) public view returns(address) {\n        if (stor2[_token] != address(0)){\n            return stor2[_token];\n        }\n        return stor1;\n    }\n\n    function addDestination(address dest, bytes32 label) public onlyOwner {\n        require(!stor4[dest]);\n        stor4[dest] = true;\n        stor6[dest] = destKeys.length;\n        destKeys.push(dest);\n        stor5[dest].field_0 = label;\n    }\n\n    function removeDestination(address dest) public onlyOwner {\n        require(stor4[dest]);\n        stor4[dest] = false;\n        stor5[dest].field_0 = bytes32(0);\n        require(stor6[dest] < destKeys.length);\n        destKeys[stor6[dest]] = address(0);\n        stor6[dest] = 0;\n    }\n\n    function destinationLabel(address dest) public view returns(bytes32) {\n        return stor5[dest].field_0;\n    }\n\n    function() external payable {\n        require(stor3[msg.sender]);\n        require(stor4[msg.sender]);\n        if (stor2[msg.sender] != address(0)) {\n            stor2[msg.sender].delegatecall(msg.data);\n        } else {\n            stor1.delegatecall(msg.data);\n        }\n    }\n}\n```\n\nPlease note that this is just a rough conversion and might not fully represent the logic of the decompiled code. The fallback function is especially complex and might not work as expected.",
				"role": "assistant"
			}
		}
	],
	"created": 1700470591,
	"id": "chatcmpl-8MuMxB1HEJrkujB7Dea80dd7fxREz",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is address at storage 1\n  stor2 is mapping of address at storage 2\n  stor3 is mapping of uint8 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  stor5 is mapping of struct at storage 5\n  stor6 is mapping of uint256 at storage 6\n  destKeys is array of address at storage 7\n\ndef owner(): # not payable\n  return owner\n\ndef isDestination(address dest): # not payable\n  return bool(stor4[address(dest)])\n\ndef destKeys(uint256 _param1): # not payable\n  require _param1 < destKeys.length\n  return destKeys[_param1]\n\ndef isAuthorized(address adr): # not payable\n  return bool(stor3[address(adr)])\n\n#\n#  Regular functions\n#\n\ndef setDefaultSweeper(address sweeper): # not payable\n  require caller == owner\n  stor1 = sweeper\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  owner = newOwner\n\ndef authorizeAddress(address addr): # not payable\n  require caller == owner\n  stor3[address(addr)] = 1\n\ndef revokeAuthorization(address _address): # not payable\n  require caller == owner\n  stor3[address(_address)] = 0\n\ndef setSweeper(address asset, address sweeper): # not payable\n  require caller == owner\n  stor2[address(asset)] = sweeper\n\ndef sweeperOf(address _token): # not payable\n  if stor2[address(_token)]:\n      return stor2[address(_token)]\n  return stor1\n\ndef addDestination(address dest, bytes32 label): # not payable\n  require caller == owner\n  require not stor4[address(dest)]\n  stor4[address(dest)] = 1\n  stor6[address(dest)] = destKeys.length\n  destKeys.length++\n  destKeys[destKeys.length] = dest\n  stor5[address(dest)].field_0 = label\n\ndef removeDestination(address dest): # not payable\n  require caller == owner\n  require 1 == bool(stor4[address(dest)])\n  stor4[address(dest)] = 0\n  stor5[address(dest)].field_0 = 0\n  require stor6[address(dest)] < destKeys.length\n  destKeys[stor6[address(dest)]] = 0\n  stor6[address(dest)] = 0\n\ndef destinationLabel(address dest): # not payable\n  mem[128 len 1024] = code.data[2334 len 1024]\n  idx = 0\n  while idx < 32:\n      mem[0] = dest\n      mem[32] = 5\n      require idx < 32\n      mem[idx + 128 len 8] = Mask(8, -(('mask_shl', 8, ('add', 256, ('mul', -1, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0))), ('add', -11, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0)), ('var', 0)), 0) + 256, 0) << (('mask_shl', 8, ('add', 256, ('mul', -1, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0))), ('add', -11, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0)), ('var', 0)), 0) - 256\n      idx = idx + 1\n      continue \n  return 32, 32, mem[128]\n\ndef _fallback(?) payable: # default function\n  if call.value:\n      stop\n  if bool(stor3[caller]) != 1:\n      stop\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  require 1 == bool(stor4[mem[176 len 20]])\n  mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]\n  if stor2[mem[ceil32(calldata.size) + 176 len 20]]:\n      require stor2[address(mem[ceil32(calldata.size) + 164])]\n      delegate stor2[address(mem[ceil32(calldata.size) + 164])] with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n  else:\n      require stor1\n      delegate stor1 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is address at storage 1\n  stor2 is mapping of address at storage 2\n  stor3 is mapping of uint8 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  stor5 is mapping of struct at storage 5\n  stor6 is mapping of uint256 at storage 6\n  destKeys is array of address at storage 7\n\ndef owner(): # not payable\n  return owner\n\ndef isDestination(address dest): # not payable\n  return bool(stor4[address(dest)])\n\ndef destKeys(uint256 _param1): # not payable\n  require _param1 < destKeys.length\n  return destKeys[_param1]\n\ndef isAuthorized(address adr): # not payable\n  return bool(stor3[address(adr)])\n\n#\n#  Regular functions\n#\n\ndef setDefaultSweeper(address sweeper): # not payable\n  require caller == owner\n  stor1 = sweeper\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  owner = newOwner\n\ndef authorizeAddress(address addr): # not payable\n  require caller == owner\n  stor3[address(addr)] = 1\n\ndef revokeAuthorization(address _address): # not payable\n  require caller == owner\n  stor3[address(_address)] = 0\n\ndef setSweeper(address asset, address sweeper): # not payable\n  require caller == owner\n  stor2[address(asset)] = sweeper\n\ndef sweeperOf(address _token): # not payable\n  if stor2[address(_token)]:\n      return stor2[address(_token)]\n  return stor1\n\ndef addDestination(address dest, bytes32 label): # not payable\n  require caller == owner\n  require not stor4[address(dest)]\n  stor4[address(dest)] = 1\n  stor6[address(dest)] = destKeys.length\n  destKeys.length++\n  destKeys[destKeys.length] = dest\n  stor5[address(dest)].field_0 = label\n\ndef removeDestination(address dest): # not payable\n  require caller == owner\n  require 1 == bool(stor4[address(dest)])\n  stor4[address(dest)] = 0\n  stor5[address(dest)].field_0 = 0\n  require stor6[address(dest)] < destKeys.length\n  destKeys[stor6[address(dest)]] = 0\n  stor6[address(dest)] = 0\n\ndef destinationLabel(address dest): # not payable\n  mem[128 len 1024] = code.data[2334 len 1024]\n  idx = 0\n  while idx < 32:\n      mem[0] = dest\n      mem[32] = 5\n      require idx < 32\n      mem[idx + 128 len 8] = Mask(8, -(('mask_shl', 8, ('add', 256, ('mul', -1, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0))), ('add', -11, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0)), ('var', 0)), 0) + 256, 0) << (('mask_shl', 8, ('add', 256, ('mul', -1, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0))), ('add', -11, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0)), ('var', 0)), 0) - 256\n      idx = idx + 1\n      continue \n  return 32, 32, mem[128]\n\ndef _fallback(?) payable: # default function\n  if call.value:\n      stop\n  if bool(stor3[caller]) != 1:\n      stop\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  require 1 == bool(stor4[mem[176 len 20]])\n  mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]\n  if stor2[mem[ceil32(calldata.size) + 176 len 20]]:\n      require stor2[address(mem[ceil32(calldata.size) + 164])]\n      delegate stor2[address(mem[ceil32(calldata.size) + 164])] with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n  else:\n      require stor1\n      delegate stor1 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is address at storage 1\n  stor2 is mapping of address at storage 2\n  stor3 is mapping of uint8 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  stor5 is mapping of struct at storage 5\n  stor6 is mapping of uint256 at storage 6\n  destKeys is array of address at storage 7\n\ndef owner(): # not payable\n  return owner\n\ndef isDestination(address dest): # not payable\n  return bool(stor4[address(dest)])\n\ndef destKeys(uint256 _param1): # not payable\n  require _param1 < destKeys.length\n  return destKeys[_param1]\n\ndef isAuthorized(address adr): # not payable\n  return bool(stor3[address(adr)])\n\n#\n#  Regular functions\n#\n\ndef setDefaultSweeper(address sweeper): # not payable\n  require caller == owner\n  stor1 = sweeper\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  owner = newOwner\n\ndef authorizeAddress(address addr): # not payable\n  require caller == owner\n  stor3[address(addr)] = 1\n\ndef revokeAuthorization(address _address): # not payable\n  require caller == owner\n  stor3[address(_address)] = 0\n\ndef setSweeper(address asset, address sweeper): # not payable\n  require caller == owner\n  stor2[address(asset)] = sweeper\n\ndef sweeperOf(address _token): # not payable\n  if stor2[address(_token)]:\n      return stor2[address(_token)]\n  return stor1\n\ndef addDestination(address dest, bytes32 label): # not payable\n  require caller == owner\n  require not stor4[address(dest)]\n  stor4[address(dest)] = 1\n  stor6[address(dest)] = destKeys.length\n  destKeys.length++\n  destKeys[destKeys.length] = dest\n  stor5[address(dest)].field_0 = label\n\ndef removeDestination(address dest): # not payable\n  require caller == owner\n  require 1 == bool(stor4[address(dest)])\n  stor4[address(dest)] = 0\n  stor5[address(dest)].field_0 = 0\n  require stor6[address(dest)] < destKeys.length\n  destKeys[stor6[address(dest)]] = 0\n  stor6[address(dest)] = 0\n\ndef destinationLabel(address dest): # not payable\n  mem[128 len 1024] = code.data[2334 len 1024]\n  idx = 0\n  while idx < 32:\n      mem[0] = dest\n      mem[32] = 5\n      require idx < 32\n      mem[idx + 128 len 8] = Mask(8, -(('mask_shl', 8, ('add', 256, ('mul', -1, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0))), ('add', -11, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0)), ('var', 0)), 0) + 256, 0) << (('mask_shl', 8, ('add', 256, ('mul', -1, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0))), ('add', -11, (('field', 3, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'dest')), ('name', 'stor5', 5)))), 0)), ('var', 0)), 0) - 256\n      idx = idx + 1\n      continue \n  return 32, 32, mem[128]\n\ndef _fallback(?) payable: # default function\n  if call.value:\n      stop\n  if bool(stor3[caller]) != 1:\n      stop\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  require 1 == bool(stor4[mem[176 len 20]])\n  mem[ceil32(calldata.size) + 160 len calldata.size] = call.data[0 len calldata.size]\n  if stor2[mem[ceil32(calldata.size) + 176 len 20]]:\n      require stor2[address(mem[ceil32(calldata.size) + 164])]\n      delegate stor2[address(mem[ceil32(calldata.size) + 164])] with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n  else:\n      require stor1\n      delegate stor1 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\n.",
	"status": "1",
	"time_cost": 40.20752143859863,
	"usage": {
		"completion_tokens": 576,
		"prompt_tokens": 1236,
		"total_tokens": 1812
	}
}