{
	"address": "0xf2d4766ad705e3a5c9ba5b0436b473085f82f82f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code corresponding to the decompiled code:\n\n```solidity\npragma solidity ^0.7.0; \n\ncontract Contract {\n    mapping (uint256 => uint256) private map_2;\n    mapping (uint256 => uint256) private _isAuthorized;\n    mapping (uint256 => uint256) private _isDestination;\n    mapping (uint256 => uint256) private _destinationLabel;\n    mapping (uint256 => uint256) private map_6;\n    uint256[] private _destKeys;\n    address private _owner;\n    address private stor_1_0_19;\n\n    function sweeperOf(address varg0) public view returns (address) {\n        uint256 v0 = uint256(keccak256(abi.encodePacked(varg0)));\n        return address(v0);\n    }\n\n    function authorizeAddress(address varg0) public {\n        require(msg.sender == _owner);\n        _isAuthorized[uint256(varg0)] = 1;\n    }\n\n    function removeDestination(address varg0) public {\n        require(msg.sender == _owner);\n        require(_isDestination[uint256(varg0)] == 1);\n        _isDestination[uint256(varg0)] = 0;\n        require(map_6[uint256(varg0)] < _destKeys.length);\n        _destKeys[map_6[uint256(varg0)]] = 0;\n        map_6[uint256(varg0)] = 0;\n    }\n\n    function addDestination(address varg0, bytes32 varg1) public {\n        require(msg.sender == _owner);\n        require(_isDestination[uint256(varg0)] == 0);\n        _isDestination[uint256(varg0)] = 1;\n        map_6[uint256(varg0)] = _destKeys.length;\n        _destKeys.push(uint256(varg0));\n        _destinationLabel[uint256(varg0)] = uint256(varg1);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function setDefaultSweeper(address varg0) public {\n        require(msg.sender == _owner);\n        stor_1_0_19 = varg0;\n    }\n\n    function isDestination(address varg0) public view returns (uint256) {\n        return _isDestination[uint256(varg0)];\n    }\n\n    function revokeAuthorization(address varg0) public {\n        require(msg.sender == _owner);\n        _isAuthorized[uint256(varg0)] = 0;\n    }\n\n    function setSweeper(address varg0, address varg1) public {\n        require(msg.sender == _owner);\n        map_2[uint256(varg0)] = uint256(varg1);\n    }\n\n    function destinationLabel(address varg0) public view returns (bytes32) {\n        return bytes32(_destinationLabel[uint256(varg0)]);\n    }\n\n    function destKeys(uint256 varg0) public view returns (address) {\n        require(varg0 < _destKeys.length);\n        return address(_destKeys[varg0]);\n    }\n\n    function transferOwnership(address varg0) public {\n        require(msg.sender == _owner);\n        require(varg0 != address(0));\n        _owner = varg0;\n    }\n\n    function isAuthorized(address varg0) public view returns (uint256) {\n        return _isAuthorized[uint256(varg0)];\n    }\n\n    fallback() external payable {\n        require(_isAuthorized[uint256(msg.sender)] == 1);\n        require(_isDestination[uint256(tx.origin)] == 1);\n        address(uint256(keccak256(abi.encodePacked(tx.origin)))).delegatecall(msg.data);\n    }\n}\n```\n\nPlease note that this code may not work exactly as the original contract depending on the specific implementation details and the Solidity compiler version used. It is always recommended to thoroughly test all contract functionality.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038568,
	"id": "chatcmpl-8ChgmxRNsKjtv6rpd9g08X4I2vFAB",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 19:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) map_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _isAuthorized; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isDestination; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _destinationLabel; // STORAGE[0x5]\nmapping (uint256 => [uint256]) map_6; // STORAGE[0x6]\nuint256[] _destKeys; // STORAGE[0x7]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction sweeperOf(address varg0) public nonPayable { \n    v0 = 0x46d(varg0);\n    return address(v0);\n}\n\nfunction authorizeAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _isAuthorized[varg0] = 0x1 | ~0xff & _isAuthorized[varg0];\n}\n\nfunction removeDestination(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(1 == 0xff & _isDestination[varg0]);\n    _isDestination[varg0] = ~0xff & _isDestination[varg0];\n    _isDestination[varg0] = 0;\n    assert(map_6[varg0] < _destKeys.length);\n    _destKeys[map_6[varg0]] = ~0xffffffffffffffffffffffffffffffffffffffff & _destKeys[map_6[varg0]];\n    map_6[varg0] = 0;\n}\n\nfunction addDestination(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(!(0xff & _isDestination[varg0]));\n    v0 = varg0;\n    _isDestination[v0] = 0x1 | ~0xff & _isDestination[v0];\n    map_6[v0] = _destKeys.length;\n    _destKeys.length = _destKeys.length + 1;\n    STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _destKeys.length] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _destKeys.length];\n    map_6[v0] = varg1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setDefaultSweeper(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    stor_1_0_19 = varg0;\n}\n\nfunction isDestination(address varg0) public nonPayable { \n    return 0xff & _isDestination[varg0];\n}\n\nfunction revokeAuthorization(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _isAuthorized[varg0] = ~0xff & _isAuthorized[varg0];\n}\n\nfunction setSweeper(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    map_2[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & map_2[varg0];\n}\n\nfunction destinationLabel(address varg0) public nonPayable { \n    v0 = new bytes[](32);\n    v1 = v2 = 0;\n    while (v1 < 32) {\n        assert(v1 < 32);\n        assert(v1 < v0.length);\n        MEM8[v0.data + v1] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(_destinationLabel[varg0], v1)) << 248, 0x0)) & 0xFF;\n        v1 += 1;\n    }\n    v3 = new array[](v0.length);\n    v4 = v5 = 0;\n    while (v4 < v0.length) {\n        MEM[v4 + v3.data] = MEM[v4 + v0.data];\n        v4 += 32;\n    }\n    v6 = v7 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v3;\n}\n\nfunction destKeys(uint256 varg0) public nonPayable { \n    assert(varg0 < _destKeys.length);\n    return address(_destKeys[varg0]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    _owner = varg0;\n}\n\nfunction isAuthorized(address varg0) public nonPayable { \n    return 0xff & _isAuthorized[varg0];\n}\n\nfunction 0x46d(uint256 varg0) private { \n    v0 = address(varg0);\n    if (address(map_2[v0])) {\n        v1 = address(varg0);\n        v2 = v3 = address(map_2[v1]);\n    } else {\n        v2 = v4 = stor_1_0_19;\n    }\n    return v2;\n}\n\nfunction fallback() public payable { \n    v0 = v1 = !msg.value;\n    if (v1) {\n        v0 = v2 = 1 == 0xff & _isAuthorized[msg.sender];\n    }\n    if (!v0) {\n        exit;\n    } else {\n        v3 = new bytes[](msg.data.length);\n        CALLDATACOPY(v3.data, 0, msg.data.length);\n        require(1 == 0xff & _isDestination[address(MEM[68 + v3])]);\n        v4 = new bytes[](msg.data.length);\n        CALLDATACOPY(v4.data, 0, msg.data.length);\n        v5 = 0x46d(MEM[4 + v4.data]);\n        require(address(v5));\n        v6 = new bytes[](msg.data.length);\n        v7 = v5.delegatecall(MEM[(v6.data) len (v6.length)], MEM[0 len 0]).gas(msg.gas);\n        require(v7, MEM[64], RETURNDATASIZE());\n        return MEM[(MEM[64]) len (RETURNDATASIZE())];\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x3c18d318) {\n            sweeperOf(address);\n        } else if (0x4a5db3b5 == function_selector) {\n            authorizeAddress(address);\n        } else if (0x5cadd08d == function_selector) {\n            removeDestination(address);\n        } else if (0x66f40931 == function_selector) {\n            addDestination(address,bytes32);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8dd9596a == function_selector) {\n            setDefaultSweeper(address);\n        } else if (0xaaaae342 == function_selector) {\n            isDestination(address);\n        } else if (0xb48028e3 == function_selector) {\n            revokeAuthorization(address);\n        } else if (0xd288034f == function_selector) {\n            setSweeper(address,address);\n        } else if (0xd3107f4d == function_selector) {\n            destinationLabel(address);\n        } else if (0xd78e830c == function_selector) {\n            destKeys(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfe9fbb80 == function_selector) {\n            isAuthorized(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 19:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) map_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _isAuthorized; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isDestination; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _destinationLabel; // STORAGE[0x5]\nmapping (uint256 => [uint256]) map_6; // STORAGE[0x6]\nuint256[] _destKeys; // STORAGE[0x7]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction sweeperOf(address varg0) public nonPayable { \n    v0 = 0x46d(varg0);\n    return address(v0);\n}\n\nfunction authorizeAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _isAuthorized[varg0] = 0x1 | ~0xff & _isAuthorized[varg0];\n}\n\nfunction removeDestination(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(1 == 0xff & _isDestination[varg0]);\n    _isDestination[varg0] = ~0xff & _isDestination[varg0];\n    _isDestination[varg0] = 0;\n    assert(map_6[varg0] < _destKeys.length);\n    _destKeys[map_6[varg0]] = ~0xffffffffffffffffffffffffffffffffffffffff & _destKeys[map_6[varg0]];\n    map_6[varg0] = 0;\n}\n\nfunction addDestination(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(!(0xff & _isDestination[varg0]));\n    v0 = varg0;\n    _isDestination[v0] = 0x1 | ~0xff & _isDestination[v0];\n    map_6[v0] = _destKeys.length;\n    _destKeys.length = _destKeys.length + 1;\n    STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _destKeys.length] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _destKeys.length];\n    map_6[v0] = varg1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setDefaultSweeper(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    stor_1_0_19 = varg0;\n}\n\nfunction isDestination(address varg0) public nonPayable { \n    return 0xff & _isDestination[varg0];\n}\n\nfunction revokeAuthorization(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _isAuthorized[varg0] = ~0xff & _isAuthorized[varg0];\n}\n\nfunction setSweeper(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    map_2[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & map_2[varg0];\n}\n\nfunction destinationLabel(address varg0) public nonPayable { \n    v0 = new bytes[](32);\n    v1 = v2 = 0;\n    while (v1 < 32) {\n        assert(v1 < 32);\n        assert(v1 < v0.length);\n        MEM8[v0.data + v1] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(_destinationLabel[varg0], v1)) << 248, 0x0)) & 0xFF;\n        v1 += 1;\n    }\n    v3 = new array[](v0.length);\n    v4 = v5 = 0;\n    while (v4 < v0.length) {\n        MEM[v4 + v3.data] = MEM[v4 + v0.data];\n        v4 += 32;\n    }\n    v6 = v7 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v3;\n}\n\nfunction destKeys(uint256 varg0) public nonPayable { \n    assert(varg0 < _destKeys.length);\n    return address(_destKeys[varg0]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    _owner = varg0;\n}\n\nfunction isAuthorized(address varg0) public nonPayable { \n    return 0xff & _isAuthorized[varg0];\n}\n\nfunction 0x46d(uint256 varg0) private { \n    v0 = address(varg0);\n    if (address(map_2[v0])) {\n        v1 = address(varg0);\n        v2 = v3 = address(map_2[v1]);\n    } else {\n        v2 = v4 = stor_1_0_19;\n    }\n    return v2;\n}\n\nfunction fallback() public payable { \n    v0 = v1 = !msg.value;\n    if (v1) {\n        v0 = v2 = 1 == 0xff & _isAuthorized[msg.sender];\n    }\n    if (!v0) {\n        exit;\n    } else {\n        v3 = new bytes[](msg.data.length);\n        CALLDATACOPY(v3.data, 0, msg.data.length);\n        require(1 == 0xff & _isDestination[address(MEM[68 + v3])]);\n        v4 = new bytes[](msg.data.length);\n        CALLDATACOPY(v4.data, 0, msg.data.length);\n        v5 = 0x46d(MEM[4 + v4.data]);\n        require(address(v5));\n        v6 = new bytes[](msg.data.length);\n        v7 = v5.delegatecall(MEM[(v6.data) len (v6.length)], MEM[0 len 0]).gas(msg.gas);\n        require(v7, MEM[64], RETURNDATASIZE());\n        return MEM[(MEM[64]) len (RETURNDATASIZE())];\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x3c18d318) {\n            sweeperOf(address);\n        } else if (0x4a5db3b5 == function_selector) {\n            authorizeAddress(address);\n        } else if (0x5cadd08d == function_selector) {\n            removeDestination(address);\n        } else if (0x66f40931 == function_selector) {\n            addDestination(address,bytes32);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8dd9596a == function_selector) {\n            setDefaultSweeper(address);\n        } else if (0xaaaae342 == function_selector) {\n            isDestination(address);\n        } else if (0xb48028e3 == function_selector) {\n            revokeAuthorization(address);\n        } else if (0xd288034f == function_selector) {\n            setSweeper(address,address);\n        } else if (0xd3107f4d == function_selector) {\n            destinationLabel(address);\n        } else if (0xd78e830c == function_selector) {\n            destKeys(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfe9fbb80 == function_selector) {\n            isAuthorized(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 19:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) map_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _isAuthorized; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isDestination; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _destinationLabel; // STORAGE[0x5]\nmapping (uint256 => [uint256]) map_6; // STORAGE[0x6]\nuint256[] _destKeys; // STORAGE[0x7]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction sweeperOf(address varg0) public nonPayable { \n    v0 = 0x46d(varg0);\n    return address(v0);\n}\n\nfunction authorizeAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _isAuthorized[varg0] = 0x1 | ~0xff & _isAuthorized[varg0];\n}\n\nfunction removeDestination(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(1 == 0xff & _isDestination[varg0]);\n    _isDestination[varg0] = ~0xff & _isDestination[varg0];\n    _isDestination[varg0] = 0;\n    assert(map_6[varg0] < _destKeys.length);\n    _destKeys[map_6[varg0]] = ~0xffffffffffffffffffffffffffffffffffffffff & _destKeys[map_6[varg0]];\n    map_6[varg0] = 0;\n}\n\nfunction addDestination(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(!(0xff & _isDestination[varg0]));\n    v0 = varg0;\n    _isDestination[v0] = 0x1 | ~0xff & _isDestination[v0];\n    map_6[v0] = _destKeys.length;\n    _destKeys.length = _destKeys.length + 1;\n    STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _destKeys.length] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _destKeys.length];\n    map_6[v0] = varg1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setDefaultSweeper(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    stor_1_0_19 = varg0;\n}\n\nfunction isDestination(address varg0) public nonPayable { \n    return 0xff & _isDestination[varg0];\n}\n\nfunction revokeAuthorization(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _isAuthorized[varg0] = ~0xff & _isAuthorized[varg0];\n}\n\nfunction setSweeper(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    map_2[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & map_2[varg0];\n}\n\nfunction destinationLabel(address varg0) public nonPayable { \n    v0 = new bytes[](32);\n    v1 = v2 = 0;\n    while (v1 < 32) {\n        assert(v1 < 32);\n        assert(v1 < v0.length);\n        MEM8[v0.data + v1] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(_destinationLabel[varg0], v1)) << 248, 0x0)) & 0xFF;\n        v1 += 1;\n    }\n    v3 = new array[](v0.length);\n    v4 = v5 = 0;\n    while (v4 < v0.length) {\n        MEM[v4 + v3.data] = MEM[v4 + v0.data];\n        v4 += 32;\n    }\n    v6 = v7 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v3;\n}\n\nfunction destKeys(uint256 varg0) public nonPayable { \n    assert(varg0 < _destKeys.length);\n    return address(_destKeys[varg0]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    _owner = varg0;\n}\n\nfunction isAuthorized(address varg0) public nonPayable { \n    return 0xff & _isAuthorized[varg0];\n}\n\nfunction 0x46d(uint256 varg0) private { \n    v0 = address(varg0);\n    if (address(map_2[v0])) {\n        v1 = address(varg0);\n        v2 = v3 = address(map_2[v1]);\n    } else {\n        v2 = v4 = stor_1_0_19;\n    }\n    return v2;\n}\n\nfunction fallback() public payable { \n    v0 = v1 = !msg.value;\n    if (v1) {\n        v0 = v2 = 1 == 0xff & _isAuthorized[msg.sender];\n    }\n    if (!v0) {\n        exit;\n    } else {\n        v3 = new bytes[](msg.data.length);\n        CALLDATACOPY(v3.data, 0, msg.data.length);\n        require(1 == 0xff & _isDestination[address(MEM[68 + v3])]);\n        v4 = new bytes[](msg.data.length);\n        CALLDATACOPY(v4.data, 0, msg.data.length);\n        v5 = 0x46d(MEM[4 + v4.data]);\n        require(address(v5));\n        v6 = new bytes[](msg.data.length);\n        v7 = v5.delegatecall(MEM[(v6.data) len (v6.length)], MEM[0 len 0]).gas(msg.gas);\n        require(v7, MEM[64], RETURNDATASIZE());\n        return MEM[(MEM[64]) len (RETURNDATASIZE())];\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x3c18d318) {\n            sweeperOf(address);\n        } else if (0x4a5db3b5 == function_selector) {\n            authorizeAddress(address);\n        } else if (0x5cadd08d == function_selector) {\n            removeDestination(address);\n        } else if (0x66f40931 == function_selector) {\n            addDestination(address,bytes32);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8dd9596a == function_selector) {\n            setDefaultSweeper(address);\n        } else if (0xaaaae342 == function_selector) {\n            isDestination(address);\n        } else if (0xb48028e3 == function_selector) {\n            revokeAuthorization(address);\n        } else if (0xd288034f == function_selector) {\n            setSweeper(address,address);\n        } else if (0xd3107f4d == function_selector) {\n            destinationLabel(address);\n        } else if (0xd78e830c == function_selector) {\n            destKeys(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfe9fbb80 == function_selector) {\n            isAuthorized(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 45.46694898605347,
	"usage": {
		"completion_tokens": 830,
		"prompt_tokens": 1904,
		"total_tokens": 2734
	}
}