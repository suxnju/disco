{
	"address": "0x780b6e67925e35b98b6ff8a1b2653572af73b8f9",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  m_required is uint256 at storage 0\n  m_numOwners is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is array of struct at storage 3\n  stor258 is mapping of uint256 at storage 258\n  stor259 is mapping of struct at storage 259\n  stor260 is array of uint256 at storage 260\n  m_dailyLimit is uint256 at storage 261\n  m_spentToday is uint256 at storage 262\n  m_lastDay is uint256 at storage 263\n  version is uint256 at storage 264\n  erc20Address is address at storage 265\n  stor266 is mapping of struct at storage 266\n\ndef m_numOwners(): # not payable\n  return m_numOwners\n\ndef m_lastDay(): # not payable\n  return m_lastDay\n\ndef version(): # not payable\n  return version\n\ndef m_spentToday(): # not payable\n  return m_spentToday\n\ndef m_required(): # not payable\n  return m_required\n\ndef erc20(): # not payable\n  return erc20Address\n\ndef m_dailyLimit(): # not payable\n  return m_dailyLimit\n\n#\n#  Regular functions\n#\n\ndef kill(address target): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if not stor258[caller]:\n      stop\n  if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n      stor260.length++\n      if stor260.length > stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n  if stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 and 2^stor258[caller]:\n      stop\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n  if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n      stop\n  require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n  stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n  selfdestruct(target)\n\ndef isOwner(address account): # not payable\n  return (stor258[address(account)] > 0)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef hasConfirmed(bytes32 _operation, address _owner): # not payable\n  if stor258[address(_owner)]:\n      if stor259[_operation].field_256 and 2^stor258[address(_owner)]:\n          return 1\n      else:\n          return 0\n  else:\n      return 0\n\ndef revoke(bytes32 _operation): # not payable\n  if stor258[caller]:\n      if 2^stor258[caller] and stor259[_operation].field_256 > 0:\n          stor259[_operation].field_0++\n          stor259[_operation].field_256 -= 2^stor258[caller]\n          log Revoke(\n                address owner=caller,\n                bytes32 operation=_operation)\n\ndef confirmETH(bytes32 _h): # not payable\n  if not stor258[caller]:\n      return 0\n  if not stor259[_h].field_0:\n      stor259[_h].field_0 = m_required\n      stor259[_h].field_256 = 0\n      stor260.length++\n      if stor260.length > stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[_h].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = _h\n  if stor259[_h].field_256 and 2^stor258[caller]:\n      return 0\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=_h)\n  if 1 < stor259[_h].field_0:\n      stor259[_h].field_0--\n      stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n      return 0\n  require stor259[_h].field_512 < stor260.length\n  stor260[stor259[_h].field_512] = 0\n  stor259[_h].field_0 = 0\n  stor259[_h].field_256 = 0\n  stor259[_h].field_512 = 0\n  if not stor266[_h].field_0:\n      return 0\n  call stor266[_h].field_0 with:\n     value stor266[_h].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log MultiTransact(\n        address owner=caller,\n        bytes32 operation=_h,\n        uint256 value=stor266[_h].field_256,\n        address to=stor266[_h].field_0)\n  stor266[_h].field_0 = 0\n  stor266[_h].field_256 = 0\n  stor266[_h].field_512 = 0\n  return 1\n\ndef confirmERC20(bytes32 _h): # not payable\n  if not stor258[caller]:\n      return 0\n  if not stor259[_h].field_0:\n      stor259[_h].field_0 = m_required\n      stor259[_h].field_256 = 0\n      stor260.length++\n      if stor260.length > stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[_h].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = _h\n  if stor259[_h].field_256 and 2^stor258[caller]:\n      return 0\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=_h)\n  if 1 < stor259[_h].field_0:\n      stor259[_h].field_0--\n      stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n      return 0\n  require stor259[_h].field_512 < stor260.length\n  stor260[stor259[_h].field_512] = 0\n  stor259[_h].field_0 = 0\n  stor259[_h].field_256 = 0\n  stor259[_h].field_512 = 0\n  if not stor266[_h].field_0:\n      return 0\n  require ext_code.size(stor266[_h].field_512)\n  call stor266[_h].field_512.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args stor266[_h].field_0, stor266[_h].field_256\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  log MultiTransact(\n        address owner=caller,\n        bytes32 operation=_h,\n        uint256 value=stor266[_h].field_256,\n        address to=stor266[_h].field_0)\n  stor266[_h].field_0 = 0\n  stor266[_h].field_256 = 0\n  stor266[_h].field_512 = 0\n  return 1\n\ndef resetSpentToday(): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n          else:\n              require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n              m_spentToday = 0\n\ndef changeERC20(address _erc20): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n          else:\n              require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n              erc20Address = _erc20\n\ndef setDailyLimit(uint256 _dailyLimit): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n          else:\n              require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n              m_dailyLimit = _dailyLimit\n\ndef changeRequirement(uint256 _required): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n          else:\n              require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n              if _required <= m_numOwners:\n                  m_required = _required\n                  idx = 0\n                  while idx < stor260.length:\n                      mem[0] = stor260[idx]\n                      mem[32] = 266\n                      stor266[stor260[idx]].field_0 = 0\n                      stor266[stor260[idx]].field_256 = 0\n                      stor266[stor260[idx]].field_512 = 0\n                      idx = idx + 1\n                      continue \n                  idx = 0\n                  while idx < stor260.length:\n                      mem[0] = 260\n                      if stor260[idx]:\n                          require idx < stor260.length\n                          mem[0] = stor260[idx]\n                          mem[32] = 259\n                          stor259[stor260[idx]].field_0 = 0\n                          stor259[stor260[idx]].field_256 = 0\n                          stor259[stor260[idx]].field_512 = 0\n                      idx = idx + 1\n                      continue \n                  stor260.length = 0\n                  idx = 0\n                  while stor260.length > idx:\n                      stor260[idx] = 0\n                      idx = idx + 1\n                      continue \n                  log RequirementChanged(uint256 newRequirement=_required)\n\ndef changeOwner(address _from, address _to): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n          else:\n              require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n              if stor258[address(_to)] <= 0:\n                  if stor258[address(_from)]:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 266\n                          stor266[stor260[idx]].field_0 = 0\n                          stor266[stor260[idx]].field_256 = 0\n                          stor266[stor260[idx]].field_512 = 0\n                          idx = idx + 1\n                          continue \n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = 260\n                          if stor260[idx]:\n                              require idx < stor260.length\n                              mem[0] = stor260[idx]\n                              mem[32] = 259\n                              stor259[stor260[idx]].field_0 = 0\n                              stor259[stor260[idx]].field_256 = 0\n                              stor259[stor260[idx]].field_512 = 0\n                          idx = idx + 1\n                          continue \n                      stor260.length = 0\n                      idx = 0\n                      while stor260.length > idx:\n                          stor260[idx] = 0\n                          idx = idx + 1\n                          continue \n                      require stor258[address(_from)] < 256\n                      stor2[stor258[address(_from)]].field_0 = _to\n                      stor2[stor258[address(_from)]].field_160 = 0\n                      stor258[address(_from)] = 0\n                      stor258[_to] = stor258[address(_from)]\n                      log OwnerChanged(\n                            address oldOwner=address(_from),\n                            address newOwner=_to)\n\ndef removeOwner(address owner): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          if stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 and 2^stor258[caller]:\n              stop\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n              stop\n          require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n          stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n          if not stor258[address(owner)]:\n              stop\n          if m_required > m_numOwners - 1:\n              stop\n          require stor258[address(owner)] < 256\n          stor2[stor258[address(owner)]].field_0 = 0\n          stor258[address(owner)] = 0\n          idx = 0\n          while idx < stor260.length:\n              mem[0] = stor260[idx]\n              mem[32] = 266\n              stor266[stor260[idx]].field_0 = 0\n              stor266[stor260[idx]].field_256 = 0\n              stor266[stor260[idx]].field_512 = 0\n              idx = idx + 1\n              continue \n          idx = 0\n          while idx < stor260.length:\n              mem[0] = 260\n              if stor260[idx]:\n                  require idx < stor260.length\n                  mem[0] = stor260[idx]\n                  mem[32] = 259\n                  stor259[stor260[idx]].field_0 = 0\n                  stor259[stor260[idx]].field_256 = 0\n                  stor259[stor260[idx]].field_512 = 0\n              idx = idx + 1\n              continue \n          stor260.length = 0\n          idx = 0\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n      stor260.length++\n      if stor260.length <= stor260.length + 1:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n          if stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 and 2^stor258[caller]:\n              stop\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n              stop\n          require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n          stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n          if not stor258[address(owner)]:\n              stop\n          if m_required > m_numOwners - 1:\n              stop\n          require stor258[address(owner)] < 256\n          stor2[stor258[address(owner)]].field_0 = 0\n          stor258[address(owner)] = 0\n          idx = 0\n          while idx < stor260.length:\n              mem[0] = stor260[idx]\n              mem[32] = 266\n              stor266[stor260[idx]].field_0 = 0\n              stor266[stor260[idx]].field_256 = 0\n              stor266[stor260[idx]].field_512 = 0\n              idx = idx + 1\n              continue \n          idx = 0\n          while idx < stor260.length:\n              mem[0] = 260\n              if stor260[idx]:\n                  require idx < stor260.length\n                  mem[0] = stor260[idx]\n                  mem[32] = 259\n                  stor259[stor260[idx]].field_0 = 0\n                  stor259[stor260[idx]].field_256 = 0\n                  stor259[stor260[idx]].field_512 = 0\n              idx = idx + 1\n              continue \n          stor260.length = 0\n          idx = 0\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      idx = stor260.length + 1\n      while stor260.length > idx:\n          stor260[idx] = 0\n          idx = idx + 1\n          continue \n      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n      if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n          if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n          else:\n              require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n              if stor258[address(owner)]:\n                  if m_required <= m_numOwners - 1:\n                      require stor258[address(owner)] < 256\n                      stor2[stor258[address(owner)]].field_0 = 0\n                      stor258[address(owner)] = 0\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 266\n                          stor266[stor260[idx]].field_0 = 0\n                          stor266[stor260[idx]].field_256 = 0\n                          stor266[stor260[idx]].field_512 = 0\n                          idx = idx + 1\n                          continue \n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = 260\n                          if stor260[idx]:\n                              require idx < stor260.length\n                              mem[0] = stor260[idx]\n                              mem[32] = 259\n                              stor259[stor260[idx]].field_0 = 0\n                              stor259[stor260[idx]].field_256 = 0\n                              stor259[stor260[idx]].field_512 = 0\n                          idx = idx + 1\n                          continue \n                      stor260.length = 0\n                      idx = 0\n                      while stor260.length > idx:\n                          stor260[idx] = 0\n                          idx = idx + 1\n                          continue \n                      if 1 < m_numOwners:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log OwnerRemoved(address oldOwner=owner)\n\ndef addOwner(address owner): # not payable\n  mem[128 len calldata.size] = call.data[0 len calldata.size]\n  mem[calldata.size + 128 len floor32(calldata.size)] = call.data[0 len floor32(calldata.size)]\n  mem[(2 * floor32(calldata.size)) + 160 len calldata.size % 32] = mem[floor32(calldata.size) + -(calldata.size % 32) + 160 len calldata.size % 32]\n  if stor258[caller]:\n      if stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n          if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n              if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n                  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n                  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n              else:\n                  require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n                  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n                  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n                  stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n                  if stor258[address(owner)] <= 0:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 266\n                          stor266[stor260[idx]].field_0 = 0\n                          stor266[stor260[idx]].field_256 = 0\n                          stor266[stor260[idx]].field_512 = 0\n                          idx = idx + 1\n                          continue \n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = 260\n                          if stor260[idx]:\n                              require idx < stor260.length\n                              mem[0] = stor260[idx]\n                              mem[32] = 259\n                              stor259[stor260[idx]].field_0 = 0\n                              stor259[stor260[idx]].field_256 = 0\n                              stor259[stor260[idx]].field_512 = 0\n                          idx = idx + 1\n                          continue \n                      stor260.length = 0\n                      idx = 0\n                      while stor260.length > idx:\n                          stor260[idx] = 0\n                          idx = idx + 1\n                          continue \n                      if 250 <= m_numOwners:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      m_numOwners++\n                      require m_numOwners + 1 < 256\n                      stor3[stor1].field_0 = owner\n                      stor3[stor1].field_160 = 0\n                      stor258[address(owner)] = m_numOwners\n                      log OwnerAdded(address newOwner=owner)\n      else:\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = m_required\n          stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n          stor260.length++\n          if stor260.length <= stor260.length + 1:\n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n              if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n                  if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n                  else:\n                      require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 266\n                              stor266[stor260[idx]].field_0 = 0\n                              stor266[stor260[idx]].field_256 = 0\n                              stor266[stor260[idx]].field_512 = 0\n                              idx = idx + 1\n                              continue \n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = 260\n                              if stor260[idx]:\n                                  require idx < stor260.length\n                                  mem[0] = stor260[idx]\n                                  mem[32] = 259\n                                  stor259[stor260[idx]].field_0 = 0\n                                  stor259[stor260[idx]].field_256 = 0\n                                  stor259[stor260[idx]].field_512 = 0\n                              idx = idx + 1\n                              continue \n                          stor260.length = 0\n                          idx = 0\n                          while stor260.length > idx:\n                              stor260[idx] = 0\n                              idx = idx + 1\n                              continue \n                          if 250 <= m_numOwners:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          stor3[stor1].field_0 = owner\n                          stor3[stor1].field_160 = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n          else:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32])\n              if not stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len floor32(calldata.size)], mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]))\n                  if 1 < stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0:\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0--\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256\n                  else:\n                      require stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512] = 0\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_0 = 0\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_256 = 0\n                      stor259[call.data[0 len floor32(calldata.size)]][mem[calldata.size + floor32(calldata.size) + 128 len calldata.size % 32]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 266\n                              stor266[stor260[idx]].field_0 = 0\n                              stor266[stor260[idx]].field_256 = 0\n                              stor266[stor260[idx]].field_512 = 0\n                              idx = idx + 1\n                              continue \n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = 260\n                              if stor260[idx]:\n                                  require idx < stor260.length\n                                  mem[0] = stor260[idx]\n                                  mem[32] = 259\n                                  stor259[stor260[idx]].field_0 = 0\n                                  stor259[stor260[idx]].field_256 = 0\n                                  stor259[stor260[idx]].field_512 = 0\n                              idx = idx + 1\n                              continue \n                          stor260.length = 0\n                          idx = 0\n                          while stor260.length > idx:\n                              stor260[idx] = 0\n                              idx = idx + 1\n                              continue \n                          if 250 > m_numOwners:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              stor3[stor1].field_0 = owner\n                              stor3[stor1].field_160 = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n                          else:\n                              if 1 < m_numOwners:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 250 > m_numOwners:\n                                  m_numOwners++\n                                  require m_numOwners + 1 < 256\n                                  stor3[stor1].field_0 = owner\n                                  stor3[stor1].field_160 = 0\n                                  stor258[address(owner)] = m_numOwners\n                                  log OwnerAdded(address newOwner=owner)\n\ndef transferETH(address to, uint256 amount): # not payable\n  if stor258[caller] <= 0:\n      return 0\n  if stor258[caller] > 0:\n      if block.timestamp / 24 * 3600 <= m_lastDay:\n          if m_spentToday + amount < m_spentToday:\n              mem[calldata.size + 128] = block.number\n              mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n              mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[-(calldata.size + 32 % 32) + floor32(calldata.size + 32) + 160 len calldata.size + 32 % 32]\n              if not stor258[caller]:\n                  if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                      log ConfirmationETHNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                            address initiator=caller,\n                            uint256 value=amount,\n                            address to=to)\n              else:\n                  if not stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                      stor260.length++\n                      if stor260.length > stor260.length + 1:\n                          idx = stor260.length + 1\n                          while stor260.length > idx:\n                              stor260[idx] = 0\n                              idx = idx + 1\n                              continue \n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n                  if stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n                      if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                          log ConfirmationETHNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                address initiator=caller,\n                                uint256 value=amount,\n                                address to=to)\n                  else:\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n                      if 1 < stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                          stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n                          stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n                          if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                              log ConfirmationETHNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                    address initiator=caller,\n                                    uint256 value=amount,\n                                    address to=to)\n                      else:\n                          require stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n                          stor260[stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n                          stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                          stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                          stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n                          if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                              if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n                                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                                  log ConfirmationETHNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                        address initiator=caller,\n                                        uint256 value=amount,\n                                        address to=to)\n                          else:\n                              call stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 with:\n                                 value stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              log MultiTransact(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                    uint256 value=stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256,\n                                    address to=stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0)\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n              return sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n          if m_spentToday + amount <= m_dailyLimit:\n              m_spentToday += amount\n              log SingleTransact(\n                    address owner=caller,\n                    uint256 value=amount,\n                    address to=to)\n              call to with:\n                 value amount wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              else:\n                  return 0\n      else:\n          m_spentToday = 0\n          m_lastDay = block.timestamp / 24 * 3600\n          if m_spentToday + amount >= m_spentToday:\n              if m_spentToday + amount <= m_dailyLimit:\n                  m_spentToday += amount\n                  log SingleTransact(\n                        address owner=caller,\n                        uint256 value=amount,\n                        address to=to)\n                  call to with:\n                     value amount wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  else:\n                      return 0\n  mem[calldata.size + 128] = block.number\n  mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n  mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 160 len calldata.size + 32 % 32]\n  if not stor258[caller]:\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n          log ConfirmationETHNeeded(\n                bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                address initiator=caller,\n                uint256 value=amount,\n                address to=to)\n  else:\n      if not stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              log ConfirmationETHNeeded(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=to)\n      else:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n          if 1 < stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n              stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n              if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                  stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n                  stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                  log ConfirmationETHNeeded(\n                        bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                        address initiator=caller,\n                        uint256 value=amount,\n                        address to=to)\n          else:\n              require stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n              stor260[stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n              stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n              stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n              stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n              if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                  if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = to\n                      stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                      log ConfirmationETHNeeded(\n                            bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                            address initiator=caller,\n                            uint256 value=amount,\n                            address to=to)\n              else:\n                  call stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 with:\n                     value stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  log MultiTransact(\n                        address owner=caller,\n                        bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                        uint256 value=stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256,\n                        address to=stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0)\n                  stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                  stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                  stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n  return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n\ndef transferERC20(address token, uint256 amount): # not payable\n  if stor258[caller] <= 0:\n      return 0\n  if stor258[caller] <= 0:\n      mem[calldata.size + 128] = block.number\n      mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n      mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 160 len calldata.size + 32 % 32]\n      _732 = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if not stor258[caller]:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if not stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n      if 1 < stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      require stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n      stor260[stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      mem[calldata.size + 164] = stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0\n      require ext_code.size(stor266[_732].field_512)\n      call stor266[_732].field_512.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining wei\n          args mem[calldata.size + 164], stor266[_732].field_256\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      log MultiTransact(\n            address owner=caller,\n            bytes32 operation=_732,\n            uint256 value=stor266[_732].field_256,\n            address to=stor266[_732].field_0)\n      stor266[_732].field_0 = 0\n      stor266[_732].field_256 = 0\n      stor266[_732].field_512 = 0\n      return _732\n  if block.timestamp / 24 * 3600 <= m_lastDay:\n      if m_spentToday + amount < m_spentToday:\n          mem[calldata.size + 128] = block.number\n          mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n          mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[-(calldata.size + 32 % 32) + floor32(calldata.size + 32) + 160 len calldata.size + 32 % 32]\n          if not stor258[caller]:\n              if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                  log ConfirmationERC20Needed(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                        address initiator=caller,\n                        uint256 value=amount,\n                        address to=address(token),\n                        address token=erc20Address)\n          else:\n              if not stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                  stor260.length++\n                  if stor260.length > stor260.length + 1:\n                      idx = stor260.length + 1\n                      while stor260.length > idx:\n                          stor260[idx] = 0\n                          idx = idx + 1\n                          continue \n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n                  require stor260.length < stor260.length\n                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n              if stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n                  if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                      log ConfirmationERC20Needed(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                            address initiator=caller,\n                            uint256 value=amount,\n                            address to=address(token),\n                            address token=erc20Address)\n              else:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n                  if 1 < stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n                      if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                          log ConfirmationERC20Needed(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                address initiator=caller,\n                                uint256 value=amount,\n                                address to=address(token),\n                                address token=erc20Address)\n                  else:\n                      require stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n                      if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                          if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                              log ConfirmationERC20Needed(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                    address initiator=caller,\n                                    uint256 value=amount,\n                                    address to=address(token),\n                                    address token=erc20Address)\n                      else:\n                          require ext_code.size(stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512)\n                          call stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0, stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log MultiTransact(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                uint256 value=stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256,\n                                address to=stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0)\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n          return sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if m_spentToday + amount <= m_dailyLimit:\n          m_spentToday += amount\n          log SingleTransact(\n                address owner=caller,\n                uint256 value=amount,\n                address to=token)\n          require ext_code.size(erc20Address)\n          call erc20Address.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining wei\n              args address(token), amount\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require return_data.size >= 32\n          return 0\n      mem[calldata.size + 128] = block.number\n      mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n      mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 160 len calldata.size + 32 % 32]\n      _742 = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if not stor258[caller]:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if not stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n          stor260.length++\n          if stor260.length > stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      if stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n      if 1 < stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n          stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      require stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n      stor260[stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n          return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n      mem[calldata.size + 164] = stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0\n      require ext_code.size(stor266[_742].field_512)\n      call stor266[_742].field_512.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining wei\n          args mem[calldata.size + 164], stor266[_742].field_256\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      log MultiTransact(\n            address owner=caller,\n            bytes32 operation=_742,\n            uint256 value=stor266[_742].field_256,\n            address to=stor266[_742].field_0)\n      stor266[_742].field_0 = 0\n      stor266[_742].field_256 = 0\n      stor266[_742].field_512 = 0\n      return _742\n  m_spentToday = 0\n  m_lastDay = block.timestamp / 24 * 3600\n  if m_spentToday + amount < m_spentToday:\n      mem[calldata.size + 128] = block.number\n      mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n      mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[-(calldata.size + 32 % 32) + floor32(calldata.size + 32) + 160 len calldata.size + 32 % 32]\n      if not stor258[caller]:\n          if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n              stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n              log ConfirmationERC20Needed(\n                    bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                    address initiator=caller,\n                    uint256 value=amount,\n                    address to=address(token),\n                    address token=erc20Address)\n      else:\n          if not stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n              stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n              stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n              stor260.length++\n              if stor260.length > stor260.length + 1:\n                  idx = stor260.length + 1\n                  while stor260.length > idx:\n                      stor260[idx] = 0\n                      idx = idx + 1\n                      continue \n              stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n          if stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n              if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                  stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                  log ConfirmationERC20Needed(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                        address initiator=caller,\n                        uint256 value=amount,\n                        address to=address(token),\n                        address token=erc20Address)\n          else:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n              if 1 < stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n                  if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                      log ConfirmationERC20Needed(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                            address initiator=caller,\n                            uint256 value=amount,\n                            address to=address(token),\n                            address token=erc20Address)\n              else:\n                  require stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n                  if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                      if not stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n                          stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n                          log ConfirmationERC20Needed(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                                address initiator=caller,\n                                uint256 value=amount,\n                                address to=address(token),\n                                address token=erc20Address)\n                  else:\n                      require ext_code.size(stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512)\n                      call stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0, stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      log MultiTransact(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                            uint256 value=stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256,\n                            address to=stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0)\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n                      stor266[call.data[0 len calldata.size]][Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n      return sha3(call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  if m_spentToday + amount <= m_dailyLimit:\n      m_spentToday += amount\n      log SingleTransact(\n            address owner=caller,\n            uint256 value=amount,\n            address to=token)\n      require ext_code.size(erc20Address)\n      call erc20Address.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining wei\n          args address(token), amount\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      return 0\n  mem[calldata.size + 128] = block.number\n  mem[calldata.size + 160 len floor32(calldata.size + 32)] = call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256\n  mem[calldata.size + floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 192 len calldata.size + 32 % 32] = mem[floor32(calldata.size + 32) + -(calldata.size + 32 % 32) + 160 len calldata.size + 32 % 32]\n  _752 = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  if not stor258[caller]:\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n          log ConfirmationERC20Needed(\n                bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                address initiator=caller,\n                uint256 value=amount,\n                address to=address(token),\n                address token=erc20Address)\n      return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  if not stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = m_required\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n      stor260.length++\n      if stor260.length > stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  if stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 and 2^stor258[caller]:\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n          log ConfirmationERC20Needed(\n                bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                address initiator=caller,\n                uint256 value=amount,\n                address to=address(token),\n                address token=erc20Address)\n      return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]))\n  if 1 < stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0--\n      stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 2^stor258[caller] or stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n          log ConfirmationERC20Needed(\n                bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                address initiator=caller,\n                uint256 value=amount,\n                address to=address(token),\n                address token=erc20Address)\n      return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  require stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 < stor260.length\n  stor260[stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512] = 0\n  stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = 0\n  stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = 0\n  stor259[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = 0\n  if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n      if not stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0:\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0 = token\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_256 = amount\n          stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_512 = erc20Address\n          log ConfirmationERC20Needed(\n                bytes32 operation=sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]),\n                address initiator=caller,\n                uint256 value=amount,\n                address to=address(token),\n                address token=erc20Address)\n      return sha3(Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> -(8 * floor32(calldata.size + 32) - calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256, mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32])\n  mem[calldata.size + 164] = stor266[Mask(8 * floor32(calldata.size + 32), -(8 * floor32(calldata.size + 32)) + 256, call.data[0 len calldata.size], Mask(8 * floor32(calldata.size + 32) - calldata.size, -(8 * floor32(calldata.size + 32) - calldata.size) + 256, block.number) >> (8 * -floor32(calldata.size + 32)) + (8 * calldata.size) + 256) << (8 * floor32(calldata.size + 32)) - 256][mem[calldata.size + floor32(calldata.size + 32) + 160 len calldata.size + -floor32(calldata.size + 32) + 32]].field_0\n  require ext_code.size(stor266[_752].field_512)\n  call stor266[_752].field_512.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args mem[calldata.size + 164], stor266[_752].field_256\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  log MultiTransact(\n        address owner=caller,\n        bytes32 operation=_752,\n        uint256 value=stor266[_752].field_256,\n        address to=stor266[_752].field_0)\n  stor266[_752].field_0 = 0\n  stor266[_752].field_256 = 0\n  stor266[_752].field_512 = 0\n  return _752\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 64487 tokens. Please reduce the length of the messages."
}