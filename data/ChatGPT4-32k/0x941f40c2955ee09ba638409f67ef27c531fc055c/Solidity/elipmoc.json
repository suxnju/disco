{
	"address": "0x941f40c2955ee09ba638409f67ef27c531fc055c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity code inspired by the decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MultiSend {\n    address private _owner;\n    uint256 private _sendTokenFee;\n    uint256 private _sendEthFee;\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == _owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function multiSendEther(address payable[] memory recipients, uint256[] memory amounts) public payable {\n        require(recipients.length == amounts.length, \"Recipients and amounts arrays must have the same length\");\n        require(msg.value >= _sendEthFee, \"Insufficient ETH to cover transaction fee.\");\n\n        for (uint i = 0; i < recipients.length; i++) {\n            recipients[i].transfer(amounts[i]);\n        }\n\n        uint256 remainder = msg.value - _sendEthFee;\n        if (remainder > 0) {\n            msg.sender.transfer(remainder);\n        }\n    }\n\n    function multiSendToken(address token, address[] memory recipients, uint256[] memory amounts) public payable {\n        require(recipients.length == amounts.length, \"Recipients and amounts arrays must have the same length\");\n        require(msg.value >= _sendTokenFee, \"Insufficient ETH to cover transaction fee.\");\n\n        for (uint i = 0; i < recipients.length; i++) {\n            bool success = IERC20(token).transferFrom(msg.sender, recipients[i], amounts[i]);\n            require(success, \"Token transfer failed.\");\n        }\n\n        uint256 remainder = msg.value - _sendTokenFee;\n        if (remainder > 0) {\n            msg.sender.transfer(remainder);\n        }\n    }\n\n    function setSendTokenFee(uint256 fee) public onlyOwner {\n        _sendTokenFee = fee;\n    }\n\n    function setSendEthFee(uint256 fee) public onlyOwner {\n        _sendEthFee = fee;\n    }\n\n    function getBalance(address token) public view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    function calc_total(uint256[] memory amounts) public pure returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i < amounts.length; i++) {\n            total += amounts[i];\n        }\n        return total;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function sendTokenFee() public view returns (uint256) {\n        return _sendTokenFee;\n    }\n\n    function sendEthFee() public view returns (uint256) {\n        return _sendEthFee;\n    }\n\n    function withdrawEther(uint256 amount) public onlyOwner {\n        msg.sender.transfer(amount);\n    }\n\n    function withdrawToken(address token, uint256 amount) public onlyOwner {\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        require(success, \"Token transfer failed.\");\n    }\n\n    function destroy() public onlyOwner {\n        selfdestruct(msg.sender);\n    }\n}\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\nPlease review and test thoroughly before use. It's also recommended to have this contract audited by a security professional before deploying it to the mainnet.",
				"role": "assistant"
			}
		}
	],
	"created": 1698041591,
	"id": "chatcmpl-8CiTXfDJKTTJdzJt2WAM09SzyJZcJ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.03 03:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0]\nuint256 _sendTokenFee; // STORAGE[0x1]\nuint256 _sendEthFee; // STORAGE[0x2]\n\n\nfunction multiSendEther(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13, uint256 varg14, uint256 varg15, uint256 varg16, uint256 varg17, uint256 varg18, uint256 varg19, uint256 varg20, uint256 varg21, uint256 varg22, uint256 varg23, uint256 varg24, uint256 varg25, uint256 varg26, uint256 varg27, uint256 varg28, uint256 varg29, uint256 varg30, uint256 varg31, uint256 varg32, uint256 varg33, uint256 varg34, uint256 varg35, uint256 varg36, uint256 varg37, uint256 varg38, uint256 varg39, uint256 varg40, uint256 varg41, uint256 varg42, uint256 varg43, uint256 varg44, uint256 varg45, uint256 varg46, uint256 varg47, uint256 varg48, uint256 varg49, uint256 varg50, uint256 varg51, uint256 varg52, uint256 varg53, uint256 varg54, uint256 varg55, uint256 varg56, uint256 varg57, uint256 varg58, uint256 varg59, uint256 varg60, uint256 varg61, uint256 varg62, uint256 varg63, uint256 varg64, uint256 varg65, uint256 varg66, uint256 varg67, uint256 varg68, uint256 varg69, uint256 varg70, uint256 varg71, uint256 varg72, uint256 varg73, uint256 varg74, uint256 varg75, uint256 varg76, uint256 varg77, uint256 varg78, uint256 varg79, uint256 varg80, uint256 varg81, uint256 varg82, uint256 varg83, uint256 varg84, uint256 varg85, uint256 varg86, uint256 varg87, uint256 varg88, uint256 varg89, uint256 varg90, uint256 varg91, uint256 varg92, uint256 varg93, uint256 varg94, uint256 varg95, uint256 varg96, uint256 varg97, uint256 varg98, uint256 varg99) public payable { \n    CALLDATACOPY(320, 4, 6400);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(varg2 < MEM[32]);\n    require(varg3 < MEM[32]);\n    require(varg4 < MEM[32]);\n    require(varg5 < MEM[32]);\n    require(varg6 < MEM[32]);\n    require(varg7 < MEM[32]);\n    require(varg8 < MEM[32]);\n    require(varg9 < MEM[32]);\n    require(varg10 < MEM[32]);\n    require(varg11 < MEM[32]);\n    require(varg12 < MEM[32]);\n    require(varg13 < MEM[32]);\n    require(varg14 < MEM[32]);\n    require(varg15 < MEM[32]);\n    require(varg16 < MEM[32]);\n    require(varg17 < MEM[32]);\n    require(varg18 < MEM[32]);\n    require(varg19 < MEM[32]);\n    require(varg20 < MEM[32]);\n    require(varg21 < MEM[32]);\n    require(varg22 < MEM[32]);\n    require(varg23 < MEM[32]);\n    require(varg24 < MEM[32]);\n    require(varg25 < MEM[32]);\n    require(varg26 < MEM[32]);\n    require(varg27 < MEM[32]);\n    require(varg28 < MEM[32]);\n    require(varg29 < MEM[32]);\n    require(varg30 < MEM[32]);\n    require(varg31 < MEM[32]);\n    require(varg32 < MEM[32]);\n    require(varg33 < MEM[32]);\n    require(varg34 < MEM[32]);\n    require(varg35 < MEM[32]);\n    require(varg36 < MEM[32]);\n    require(varg37 < MEM[32]);\n    require(varg38 < MEM[32]);\n    require(varg39 < MEM[32]);\n    require(varg40 < MEM[32]);\n    require(varg41 < MEM[32]);\n    require(varg42 < MEM[32]);\n    require(varg43 < MEM[32]);\n    require(varg44 < MEM[32]);\n    require(varg45 < MEM[32]);\n    require(varg46 < MEM[32]);\n    require(varg47 < MEM[32]);\n    require(varg48 < MEM[32]);\n    require(varg49 < MEM[32]);\n    require(varg50 < MEM[32]);\n    require(varg51 < MEM[32]);\n    require(varg52 < MEM[32]);\n    require(varg53 < MEM[32]);\n    require(varg54 < MEM[32]);\n    require(varg55 < MEM[32]);\n    require(varg56 < MEM[32]);\n    require(varg57 < MEM[32]);\n    require(varg58 < MEM[32]);\n    require(varg59 < MEM[32]);\n    require(varg60 < MEM[32]);\n    require(varg61 < MEM[32]);\n    require(varg62 < MEM[32]);\n    require(varg63 < MEM[32]);\n    require(varg64 < MEM[32]);\n    require(varg65 < MEM[32]);\n    require(varg66 < MEM[32]);\n    require(varg67 < MEM[32]);\n    require(varg68 < MEM[32]);\n    require(varg69 < MEM[32]);\n    require(varg70 < MEM[32]);\n    require(varg71 < MEM[32]);\n    require(varg72 < MEM[32]);\n    require(varg73 < MEM[32]);\n    require(varg74 < MEM[32]);\n    require(varg75 < MEM[32]);\n    require(varg76 < MEM[32]);\n    require(varg77 < MEM[32]);\n    require(varg78 < MEM[32]);\n    require(varg79 < MEM[32]);\n    require(varg80 < MEM[32]);\n    require(varg81 < MEM[32]);\n    require(varg82 < MEM[32]);\n    require(varg83 < MEM[32]);\n    require(varg84 < MEM[32]);\n    require(varg85 < MEM[32]);\n    require(varg86 < MEM[32]);\n    require(varg87 < MEM[32]);\n    require(varg88 < MEM[32]);\n    require(varg89 < MEM[32]);\n    require(varg90 < MEM[32]);\n    require(varg91 < MEM[32]);\n    require(varg92 < MEM[32]);\n    require(varg93 < MEM[32]);\n    require(varg94 < MEM[32]);\n    require(varg95 < MEM[32]);\n    require(varg96 < MEM[32]);\n    require(varg97 < MEM[32]);\n    require(varg98 < MEM[32]);\n    require(varg99 < MEM[32]);\n    while (0 >= 100) {\n        if (MEM[3520] > 0) {\n            require(0 < 100);\n            require(0 + MEM[3520] >= 0);\n            require(0 < 100);\n            MEM[6752] = 0 + MEM[3520];\n            MEM[6848] = 1;\n            if (100 != 1) {\n                break;\n            }\n        }\n    }\n    revert();\n    require(MEM[6752] + _sendEthFee >= MEM[6752]);\n    require(msg.value >= MEM[6752] + _sendEthFee);\n    while (0 >= 100) {\n        if (MEM[3520] > 0) {\n            require(0 < 100);\n            require(0 < 100);\n            v0 = MEM[0x140].call().value(MEM[3520]);\n            require(v0);\n            MEM[6912] = 1;\n            if (100 != 1) {\n                break;\n            }\n        }\n    }\n    revert();\n    if (msg.value > MEM[6752] + _sendEthFee) {\n        require(msg.value >= MEM[6752] + _sendEthFee);\n        v1 = msg.sender.call().value(msg.value - (MEM[6752] + _sendEthFee));\n        require(v1);\n    }\n    return 1;\n}\n\nfunction multiSendToken(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13, uint256 varg14, uint256 varg15, uint256 varg16, uint256 varg17, uint256 varg18, uint256 varg19, uint256 varg20, uint256 varg21, uint256 varg22, uint256 varg23, uint256 varg24, uint256 varg25, uint256 varg26, uint256 varg27, uint256 varg28, uint256 varg29, uint256 varg30, uint256 varg31, uint256 varg32, uint256 varg33, uint256 varg34, uint256 varg35, uint256 varg36, uint256 varg37, uint256 varg38, uint256 varg39, uint256 varg40, uint256 varg41, uint256 varg42, uint256 varg43, uint256 varg44, uint256 varg45, uint256 varg46, uint256 varg47, uint256 varg48, uint256 varg49, uint256 varg50, uint256 varg51, uint256 varg52, uint256 varg53, uint256 varg54, uint256 varg55, uint256 varg56, uint256 varg57, uint256 varg58, uint256 varg59, uint256 varg60, uint256 varg61, uint256 varg62, uint256 varg63, uint256 varg64, uint256 varg65, uint256 varg66, uint256 varg67, uint256 varg68, uint256 varg69, uint256 varg70, uint256 varg71, uint256 varg72, uint256 varg73, uint256 varg74, uint256 varg75, uint256 varg76, uint256 varg77, uint256 varg78, uint256 varg79, uint256 varg80, uint256 varg81, uint256 varg82, uint256 varg83, uint256 varg84, uint256 varg85, uint256 varg86, uint256 varg87, uint256 varg88, uint256 varg89, uint256 varg90, uint256 varg91, uint256 varg92, uint256 varg93, uint256 varg94, uint256 varg95, uint256 varg96, uint256 varg97, uint256 varg98, uint256 varg99, uint256 varg100) public payable { \n    CALLDATACOPY(320, 4, 6432);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(varg2 < MEM[32]);\n    require(varg3 < MEM[32]);\n    require(varg4 < MEM[32]);\n    require(varg5 < MEM[32]);\n    require(varg6 < MEM[32]);\n    require(varg7 < MEM[32]);\n    require(varg8 < MEM[32]);\n    require(varg9 < MEM[32]);\n    require(varg10 < MEM[32]);\n    require(varg11 < MEM[32]);\n    require(varg12 < MEM[32]);\n    require(varg13 < MEM[32]);\n    require(varg14 < MEM[32]);\n    require(varg15 < MEM[32]);\n    require(varg16 < MEM[32]);\n    require(varg17 < MEM[32]);\n    require(varg18 < MEM[32]);\n    require(varg19 < MEM[32]);\n    require(varg20 < MEM[32]);\n    require(varg21 < MEM[32]);\n    require(varg22 < MEM[32]);\n    require(varg23 < MEM[32]);\n    require(varg24 < MEM[32]);\n    require(varg25 < MEM[32]);\n    require(varg26 < MEM[32]);\n    require(varg27 < MEM[32]);\n    require(varg28 < MEM[32]);\n    require(varg29 < MEM[32]);\n    require(varg30 < MEM[32]);\n    require(varg31 < MEM[32]);\n    require(varg32 < MEM[32]);\n    require(varg33 < MEM[32]);\n    require(varg34 < MEM[32]);\n    require(varg35 < MEM[32]);\n    require(varg36 < MEM[32]);\n    require(varg37 < MEM[32]);\n    require(varg38 < MEM[32]);\n    require(varg39 < MEM[32]);\n    require(varg40 < MEM[32]);\n    require(varg41 < MEM[32]);\n    require(varg42 < MEM[32]);\n    require(varg43 < MEM[32]);\n    require(varg44 < MEM[32]);\n    require(varg45 < MEM[32]);\n    require(varg46 < MEM[32]);\n    require(varg47 < MEM[32]);\n    require(varg48 < MEM[32]);\n    require(varg49 < MEM[32]);\n    require(varg50 < MEM[32]);\n    require(varg51 < MEM[32]);\n    require(varg52 < MEM[32]);\n    require(varg53 < MEM[32]);\n    require(varg54 < MEM[32]);\n    require(varg55 < MEM[32]);\n    require(varg56 < MEM[32]);\n    require(varg57 < MEM[32]);\n    require(varg58 < MEM[32]);\n    require(varg59 < MEM[32]);\n    require(varg60 < MEM[32]);\n    require(varg61 < MEM[32]);\n    require(varg62 < MEM[32]);\n    require(varg63 < MEM[32]);\n    require(varg64 < MEM[32]);\n    require(varg65 < MEM[32]);\n    require(varg66 < MEM[32]);\n    require(varg67 < MEM[32]);\n    require(varg68 < MEM[32]);\n    require(varg69 < MEM[32]);\n    require(varg70 < MEM[32]);\n    require(varg71 < MEM[32]);\n    require(varg72 < MEM[32]);\n    require(varg73 < MEM[32]);\n    require(varg74 < MEM[32]);\n    require(varg75 < MEM[32]);\n    require(varg76 < MEM[32]);\n    require(varg77 < MEM[32]);\n    require(varg78 < MEM[32]);\n    require(varg79 < MEM[32]);\n    require(varg80 < MEM[32]);\n    require(varg81 < MEM[32]);\n    require(varg82 < MEM[32]);\n    require(varg83 < MEM[32]);\n    require(varg84 < MEM[32]);\n    require(varg85 < MEM[32]);\n    require(varg86 < MEM[32]);\n    require(varg87 < MEM[32]);\n    require(varg88 < MEM[32]);\n    require(varg89 < MEM[32]);\n    require(varg90 < MEM[32]);\n    require(varg91 < MEM[32]);\n    require(varg92 < MEM[32]);\n    require(varg93 < MEM[32]);\n    require(varg94 < MEM[32]);\n    require(varg95 < MEM[32]);\n    require(varg96 < MEM[32]);\n    require(varg97 < MEM[32]);\n    require(varg98 < MEM[32]);\n    require(varg99 < MEM[32]);\n    require(varg100 < MEM[32]);\n    while (MEM[3552] > MEM[64]) {\n        if (MEM[3552] >= MEM[96]) {\n            break;\n        }\n        require(MEM[3552] >= MEM[96]);\n        if (0 + MEM[3552] <= MEM[64]) {\n            break;\n        }\n        require(0 + MEM[3552] <= MEM[64]);\n        if (0 + MEM[3552] >= MEM[96]) {\n            break;\n        }\n        require(0 + MEM[3552] >= MEM[96]);\n        MEM[6880] = 1;\n        if (100 != 1) {\n            break;\n        }\n        if (100 == 1) {\n            require(msg.value >= _sendTokenFee);\n            require(0 + MEM[3552] >= 0);\n            require((MEM[320]).code.size);\n            require(this != MEM[320]);\n            v0 = MEM[0x140].allowance(msg.sender, this).gas(msg.gas);\n            require(v0);\n            require(MEM[7104] >= 0 + MEM[3552]);\n            while (0 >= 100) {\n                if (MEM[3552] > 0) {\n                    require((MEM[320]).code.size);\n                    require(this != MEM[320]);\n                    require(0 < 100);\n                    require(0 < 100);\n                    v1 = MEM[0x140].transferFrom(msg.sender, MEM[352], MEM[3552]).gas(msg.gas);\n                    require(v1);\n                    require(MEM[7360]);\n                    MEM[7136] = 1;\n                    if (100 != 1) {\n                        break;\n                    }\n                }\n            }\n            revert();\n            if (msg.value > _sendTokenFee) {\n                require(msg.value >= _sendTokenFee);\n                v2 = msg.sender.call().value(msg.value - _sendTokenFee);\n                require(v2);\n            }\n            return 1;\n        }\n    }\n    revert();\n}\n\nfunction getBalance(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return (MEM[320]).balance;\n}\n\nfunction calc_total() public payable { \n    CALLDATACOPY(320, 4, 3200);\n    require(!msg.value);\n    while (MEM[320] <= 0) {\n        require(0 + MEM[320] >= 0);\n        MEM[3520] = 0 + MEM[320];\n        MEM[3616] = 1;\n        if (100 != 1) {\n            break;\n        }\n    }\n    return MEM[3520];\n}\n\nfunction find(uint256[100] varg0) public payable { \n    CALLDATACOPY(320, 4, 3232);\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(MEM[3520] < 100);\n    return MEM[(MEM[3520] << 5) + 320];\n}\n\nfunction deposit() public payable { \n    return 1;\n}\n\nfunction withdrawEther(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    v0 = MEM[0x140].call().value(MEM[352]);\n    require(v0);\n    return 1;\n}\n\nfunction withdrawToken(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 96);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(msg.sender == _owner);\n    require((MEM[320]).code.size);\n    require(this != MEM[320]);\n    v0 = MEM[0x140].transfer(MEM[352], MEM[384]).gas(msg.gas);\n    require(v0);\n    require(MEM[576]);\n    return 1;\n}\n\nfunction setSendTokenFee() public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(msg.sender == _owner);\n    _sendTokenFee = MEM[320];\n    return 1;\n}\n\nfunction setSendEthFee() public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(msg.sender == _owner);\n    _sendEthFee = MEM[320];\n    return 1;\n}\n\nfunction destroy(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    selfdestruct(MEM[320]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction sendTokenFee() public nonPayable { \n    return _sendTokenFee;\n}\n\nfunction sendEthFee() public nonPayable { \n    return _sendEthFee;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0x85e37c33) {\n        if (function_selector != 0xab8fc59d) {\n            if (function_selector != 0xf8b2cb4f) {\n                if (function_selector != 0xa4521d32) {\n                    if (function_selector != 0xb372b854) {\n                        if (function_selector != 0xd0e30db0) {\n                            if (function_selector != 0x522f6815) {\n                                if (function_selector != 0x1e33667) {\n                                    if (function_selector != 0xd74f2b76) {\n                                        if (function_selector != 0x7903b0d5) {\n                                            if (function_selector != 0xf55d9d) {\n                                                if (function_selector != 0x8da5cb5b) {\n                                                    if (function_selector != 0x1f6b81ce) {\n                                                        require(function_selector == 0x8de5bc40);\n                                                        sendEthFee();\n                                                    } else {\n                                                        sendTokenFee();\n                                                    }\n                                                } else {\n                                                    owner();\n                                                }\n                                            } else {\n                                                destroy(address);\n                                            }\n                                        } else {\n                                            setSendEthFee(uint256);\n                                        }\n                                    } else {\n                                        setSendTokenFee(uint256);\n                                    }\n                                } else {\n                                    withdrawToken(address,address,uint256);\n                                }\n                            } else {\n                                withdrawEther(address,uint256);\n                            }\n                        } else {\n                            deposit();\n                        }\n                    } else {\n                        find(uint256[100],int128);\n                    }\n                } else {\n                    calc_total(uint256[100]);\n                }\n            } else {\n                getBalance(address);\n            }\n        } else {\n            multiSendToken(address,address[100],uint256[100]);\n        }\n    } else {\n        multiSendEther(address[100],uint256[100]);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.03 03:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0]\nuint256 _sendTokenFee; // STORAGE[0x1]\nuint256 _sendEthFee; // STORAGE[0x2]\n\n\nfunction multiSendEther(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13, uint256 varg14, uint256 varg15, uint256 varg16, uint256 varg17, uint256 varg18, uint256 varg19, uint256 varg20, uint256 varg21, uint256 varg22, uint256 varg23, uint256 varg24, uint256 varg25, uint256 varg26, uint256 varg27, uint256 varg28, uint256 varg29, uint256 varg30, uint256 varg31, uint256 varg32, uint256 varg33, uint256 varg34, uint256 varg35, uint256 varg36, uint256 varg37, uint256 varg38, uint256 varg39, uint256 varg40, uint256 varg41, uint256 varg42, uint256 varg43, uint256 varg44, uint256 varg45, uint256 varg46, uint256 varg47, uint256 varg48, uint256 varg49, uint256 varg50, uint256 varg51, uint256 varg52, uint256 varg53, uint256 varg54, uint256 varg55, uint256 varg56, uint256 varg57, uint256 varg58, uint256 varg59, uint256 varg60, uint256 varg61, uint256 varg62, uint256 varg63, uint256 varg64, uint256 varg65, uint256 varg66, uint256 varg67, uint256 varg68, uint256 varg69, uint256 varg70, uint256 varg71, uint256 varg72, uint256 varg73, uint256 varg74, uint256 varg75, uint256 varg76, uint256 varg77, uint256 varg78, uint256 varg79, uint256 varg80, uint256 varg81, uint256 varg82, uint256 varg83, uint256 varg84, uint256 varg85, uint256 varg86, uint256 varg87, uint256 varg88, uint256 varg89, uint256 varg90, uint256 varg91, uint256 varg92, uint256 varg93, uint256 varg94, uint256 varg95, uint256 varg96, uint256 varg97, uint256 varg98, uint256 varg99) public payable { \n    CALLDATACOPY(320, 4, 6400);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(varg2 < MEM[32]);\n    require(varg3 < MEM[32]);\n    require(varg4 < MEM[32]);\n    require(varg5 < MEM[32]);\n    require(varg6 < MEM[32]);\n    require(varg7 < MEM[32]);\n    require(varg8 < MEM[32]);\n    require(varg9 < MEM[32]);\n    require(varg10 < MEM[32]);\n    require(varg11 < MEM[32]);\n    require(varg12 < MEM[32]);\n    require(varg13 < MEM[32]);\n    require(varg14 < MEM[32]);\n    require(varg15 < MEM[32]);\n    require(varg16 < MEM[32]);\n    require(varg17 < MEM[32]);\n    require(varg18 < MEM[32]);\n    require(varg19 < MEM[32]);\n    require(varg20 < MEM[32]);\n    require(varg21 < MEM[32]);\n    require(varg22 < MEM[32]);\n    require(varg23 < MEM[32]);\n    require(varg24 < MEM[32]);\n    require(varg25 < MEM[32]);\n    require(varg26 < MEM[32]);\n    require(varg27 < MEM[32]);\n    require(varg28 < MEM[32]);\n    require(varg29 < MEM[32]);\n    require(varg30 < MEM[32]);\n    require(varg31 < MEM[32]);\n    require(varg32 < MEM[32]);\n    require(varg33 < MEM[32]);\n    require(varg34 < MEM[32]);\n    require(varg35 < MEM[32]);\n    require(varg36 < MEM[32]);\n    require(varg37 < MEM[32]);\n    require(varg38 < MEM[32]);\n    require(varg39 < MEM[32]);\n    require(varg40 < MEM[32]);\n    require(varg41 < MEM[32]);\n    require(varg42 < MEM[32]);\n    require(varg43 < MEM[32]);\n    require(varg44 < MEM[32]);\n    require(varg45 < MEM[32]);\n    require(varg46 < MEM[32]);\n    require(varg47 < MEM[32]);\n    require(varg48 < MEM[32]);\n    require(varg49 < MEM[32]);\n    require(varg50 < MEM[32]);\n    require(varg51 < MEM[32]);\n    require(varg52 < MEM[32]);\n    require(varg53 < MEM[32]);\n    require(varg54 < MEM[32]);\n    require(varg55 < MEM[32]);\n    require(varg56 < MEM[32]);\n    require(varg57 < MEM[32]);\n    require(varg58 < MEM[32]);\n    require(varg59 < MEM[32]);\n    require(varg60 < MEM[32]);\n    require(varg61 < MEM[32]);\n    require(varg62 < MEM[32]);\n    require(varg63 < MEM[32]);\n    require(varg64 < MEM[32]);\n    require(varg65 < MEM[32]);\n    require(varg66 < MEM[32]);\n    require(varg67 < MEM[32]);\n    require(varg68 < MEM[32]);\n    require(varg69 < MEM[32]);\n    require(varg70 < MEM[32]);\n    require(varg71 < MEM[32]);\n    require(varg72 < MEM[32]);\n    require(varg73 < MEM[32]);\n    require(varg74 < MEM[32]);\n    require(varg75 < MEM[32]);\n    require(varg76 < MEM[32]);\n    require(varg77 < MEM[32]);\n    require(varg78 < MEM[32]);\n    require(varg79 < MEM[32]);\n    require(varg80 < MEM[32]);\n    require(varg81 < MEM[32]);\n    require(varg82 < MEM[32]);\n    require(varg83 < MEM[32]);\n    require(varg84 < MEM[32]);\n    require(varg85 < MEM[32]);\n    require(varg86 < MEM[32]);\n    require(varg87 < MEM[32]);\n    require(varg88 < MEM[32]);\n    require(varg89 < MEM[32]);\n    require(varg90 < MEM[32]);\n    require(varg91 < MEM[32]);\n    require(varg92 < MEM[32]);\n    require(varg93 < MEM[32]);\n    require(varg94 < MEM[32]);\n    require(varg95 < MEM[32]);\n    require(varg96 < MEM[32]);\n    require(varg97 < MEM[32]);\n    require(varg98 < MEM[32]);\n    require(varg99 < MEM[32]);\n    while (0 >= 100) {\n        if (MEM[3520] > 0) {\n            require(0 < 100);\n            require(0 + MEM[3520] >= 0);\n            require(0 < 100);\n            MEM[6752] = 0 + MEM[3520];\n            MEM[6848] = 1;\n            if (100 != 1) {\n                break;\n            }\n        }\n    }\n    revert();\n    require(MEM[6752] + _sendEthFee >= MEM[6752]);\n    require(msg.value >= MEM[6752] + _sendEthFee);\n    while (0 >= 100) {\n        if (MEM[3520] > 0) {\n            require(0 < 100);\n            require(0 < 100);\n            v0 = MEM[0x140].call().value(MEM[3520]);\n            require(v0);\n            MEM[6912] = 1;\n            if (100 != 1) {\n                break;\n            }\n        }\n    }\n    revert();\n    if (msg.value > MEM[6752] + _sendEthFee) {\n        require(msg.value >= MEM[6752] + _sendEthFee);\n        v1 = msg.sender.call().value(msg.value - (MEM[6752] + _sendEthFee));\n        require(v1);\n    }\n    return 1;\n}\n\nfunction multiSendToken(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13, uint256 varg14, uint256 varg15, uint256 varg16, uint256 varg17, uint256 varg18, uint256 varg19, uint256 varg20, uint256 varg21, uint256 varg22, uint256 varg23, uint256 varg24, uint256 varg25, uint256 varg26, uint256 varg27, uint256 varg28, uint256 varg29, uint256 varg30, uint256 varg31, uint256 varg32, uint256 varg33, uint256 varg34, uint256 varg35, uint256 varg36, uint256 varg37, uint256 varg38, uint256 varg39, uint256 varg40, uint256 varg41, uint256 varg42, uint256 varg43, uint256 varg44, uint256 varg45, uint256 varg46, uint256 varg47, uint256 varg48, uint256 varg49, uint256 varg50, uint256 varg51, uint256 varg52, uint256 varg53, uint256 varg54, uint256 varg55, uint256 varg56, uint256 varg57, uint256 varg58, uint256 varg59, uint256 varg60, uint256 varg61, uint256 varg62, uint256 varg63, uint256 varg64, uint256 varg65, uint256 varg66, uint256 varg67, uint256 varg68, uint256 varg69, uint256 varg70, uint256 varg71, uint256 varg72, uint256 varg73, uint256 varg74, uint256 varg75, uint256 varg76, uint256 varg77, uint256 varg78, uint256 varg79, uint256 varg80, uint256 varg81, uint256 varg82, uint256 varg83, uint256 varg84, uint256 varg85, uint256 varg86, uint256 varg87, uint256 varg88, uint256 varg89, uint256 varg90, uint256 varg91, uint256 varg92, uint256 varg93, uint256 varg94, uint256 varg95, uint256 varg96, uint256 varg97, uint256 varg98, uint256 varg99, uint256 varg100) public payable { \n    CALLDATACOPY(320, 4, 6432);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(varg2 < MEM[32]);\n    require(varg3 < MEM[32]);\n    require(varg4 < MEM[32]);\n    require(varg5 < MEM[32]);\n    require(varg6 < MEM[32]);\n    require(varg7 < MEM[32]);\n    require(varg8 < MEM[32]);\n    require(varg9 < MEM[32]);\n    require(varg10 < MEM[32]);\n    require(varg11 < MEM[32]);\n    require(varg12 < MEM[32]);\n    require(varg13 < MEM[32]);\n    require(varg14 < MEM[32]);\n    require(varg15 < MEM[32]);\n    require(varg16 < MEM[32]);\n    require(varg17 < MEM[32]);\n    require(varg18 < MEM[32]);\n    require(varg19 < MEM[32]);\n    require(varg20 < MEM[32]);\n    require(varg21 < MEM[32]);\n    require(varg22 < MEM[32]);\n    require(varg23 < MEM[32]);\n    require(varg24 < MEM[32]);\n    require(varg25 < MEM[32]);\n    require(varg26 < MEM[32]);\n    require(varg27 < MEM[32]);\n    require(varg28 < MEM[32]);\n    require(varg29 < MEM[32]);\n    require(varg30 < MEM[32]);\n    require(varg31 < MEM[32]);\n    require(varg32 < MEM[32]);\n    require(varg33 < MEM[32]);\n    require(varg34 < MEM[32]);\n    require(varg35 < MEM[32]);\n    require(varg36 < MEM[32]);\n    require(varg37 < MEM[32]);\n    require(varg38 < MEM[32]);\n    require(varg39 < MEM[32]);\n    require(varg40 < MEM[32]);\n    require(varg41 < MEM[32]);\n    require(varg42 < MEM[32]);\n    require(varg43 < MEM[32]);\n    require(varg44 < MEM[32]);\n    require(varg45 < MEM[32]);\n    require(varg46 < MEM[32]);\n    require(varg47 < MEM[32]);\n    require(varg48 < MEM[32]);\n    require(varg49 < MEM[32]);\n    require(varg50 < MEM[32]);\n    require(varg51 < MEM[32]);\n    require(varg52 < MEM[32]);\n    require(varg53 < MEM[32]);\n    require(varg54 < MEM[32]);\n    require(varg55 < MEM[32]);\n    require(varg56 < MEM[32]);\n    require(varg57 < MEM[32]);\n    require(varg58 < MEM[32]);\n    require(varg59 < MEM[32]);\n    require(varg60 < MEM[32]);\n    require(varg61 < MEM[32]);\n    require(varg62 < MEM[32]);\n    require(varg63 < MEM[32]);\n    require(varg64 < MEM[32]);\n    require(varg65 < MEM[32]);\n    require(varg66 < MEM[32]);\n    require(varg67 < MEM[32]);\n    require(varg68 < MEM[32]);\n    require(varg69 < MEM[32]);\n    require(varg70 < MEM[32]);\n    require(varg71 < MEM[32]);\n    require(varg72 < MEM[32]);\n    require(varg73 < MEM[32]);\n    require(varg74 < MEM[32]);\n    require(varg75 < MEM[32]);\n    require(varg76 < MEM[32]);\n    require(varg77 < MEM[32]);\n    require(varg78 < MEM[32]);\n    require(varg79 < MEM[32]);\n    require(varg80 < MEM[32]);\n    require(varg81 < MEM[32]);\n    require(varg82 < MEM[32]);\n    require(varg83 < MEM[32]);\n    require(varg84 < MEM[32]);\n    require(varg85 < MEM[32]);\n    require(varg86 < MEM[32]);\n    require(varg87 < MEM[32]);\n    require(varg88 < MEM[32]);\n    require(varg89 < MEM[32]);\n    require(varg90 < MEM[32]);\n    require(varg91 < MEM[32]);\n    require(varg92 < MEM[32]);\n    require(varg93 < MEM[32]);\n    require(varg94 < MEM[32]);\n    require(varg95 < MEM[32]);\n    require(varg96 < MEM[32]);\n    require(varg97 < MEM[32]);\n    require(varg98 < MEM[32]);\n    require(varg99 < MEM[32]);\n    require(varg100 < MEM[32]);\n    while (MEM[3552] > MEM[64]) {\n        if (MEM[3552] >= MEM[96]) {\n            break;\n        }\n        require(MEM[3552] >= MEM[96]);\n        if (0 + MEM[3552] <= MEM[64]) {\n            break;\n        }\n        require(0 + MEM[3552] <= MEM[64]);\n        if (0 + MEM[3552] >= MEM[96]) {\n            break;\n        }\n        require(0 + MEM[3552] >= MEM[96]);\n        MEM[6880] = 1;\n        if (100 != 1) {\n            break;\n        }\n        if (100 == 1) {\n            require(msg.value >= _sendTokenFee);\n            require(0 + MEM[3552] >= 0);\n            require((MEM[320]).code.size);\n            require(this != MEM[320]);\n            v0 = MEM[0x140].allowance(msg.sender, this).gas(msg.gas);\n            require(v0);\n            require(MEM[7104] >= 0 + MEM[3552]);\n            while (0 >= 100) {\n                if (MEM[3552] > 0) {\n                    require((MEM[320]).code.size);\n                    require(this != MEM[320]);\n                    require(0 < 100);\n                    require(0 < 100);\n                    v1 = MEM[0x140].transferFrom(msg.sender, MEM[352], MEM[3552]).gas(msg.gas);\n                    require(v1);\n                    require(MEM[7360]);\n                    MEM[7136] = 1;\n                    if (100 != 1) {\n                        break;\n                    }\n                }\n            }\n            revert();\n            if (msg.value > _sendTokenFee) {\n                require(msg.value >= _sendTokenFee);\n                v2 = msg.sender.call().value(msg.value - _sendTokenFee);\n                require(v2);\n            }\n            return 1;\n        }\n    }\n    revert();\n}\n\nfunction getBalance(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return (MEM[320]).balance;\n}\n\nfunction calc_total() public payable { \n    CALLDATACOPY(320, 4, 3200);\n    require(!msg.value);\n    while (MEM[320] <= 0) {\n        require(0 + MEM[320] >= 0);\n        MEM[3520] = 0 + MEM[320];\n        MEM[3616] = 1;\n        if (100 != 1) {\n            break;\n        }\n    }\n    return MEM[3520];\n}\n\nfunction find(uint256[100] varg0) public payable { \n    CALLDATACOPY(320, 4, 3232);\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(MEM[3520] < 100);\n    return MEM[(MEM[3520] << 5) + 320];\n}\n\nfunction deposit() public payable { \n    return 1;\n}\n\nfunction withdrawEther(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    v0 = MEM[0x140].call().value(MEM[352]);\n    require(v0);\n    return 1;\n}\n\nfunction withdrawToken(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 96);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(msg.sender == _owner);\n    require((MEM[320]).code.size);\n    require(this != MEM[320]);\n    v0 = MEM[0x140].transfer(MEM[352], MEM[384]).gas(msg.gas);\n    require(v0);\n    require(MEM[576]);\n    return 1;\n}\n\nfunction setSendTokenFee() public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(msg.sender == _owner);\n    _sendTokenFee = MEM[320];\n    return 1;\n}\n\nfunction setSendEthFee() public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(msg.sender == _owner);\n    _sendEthFee = MEM[320];\n    return 1;\n}\n\nfunction destroy(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    selfdestruct(MEM[320]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction sendTokenFee() public nonPayable { \n    return _sendTokenFee;\n}\n\nfunction sendEthFee() public nonPayable { \n    return _sendEthFee;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0x85e37c33) {\n        if (function_selector != 0xab8fc59d) {\n            if (function_selector != 0xf8b2cb4f) {\n                if (function_selector != 0xa4521d32) {\n                    if (function_selector != 0xb372b854) {\n                        if (function_selector != 0xd0e30db0) {\n                            if (function_selector != 0x522f6815) {\n                                if (function_selector != 0x1e33667) {\n                                    if (function_selector != 0xd74f2b76) {\n                                        if (function_selector != 0x7903b0d5) {\n                                            if (function_selector != 0xf55d9d) {\n                                                if (function_selector != 0x8da5cb5b) {\n                                                    if (function_selector != 0x1f6b81ce) {\n                                                        require(function_selector == 0x8de5bc40);\n                                                        sendEthFee();\n                                                    } else {\n                                                        sendTokenFee();\n                                                    }\n                                                } else {\n                                                    owner();\n                                                }\n                                            } else {\n                                                destroy(address);\n                                            }\n                                        } else {\n                                            setSendEthFee(uint256);\n                                        }\n                                    } else {\n                                        setSendTokenFee(uint256);\n                                    }\n                                } else {\n                                    withdrawToken(address,address,uint256);\n                                }\n                            } else {\n                                withdrawEther(address,uint256);\n                            }\n                        } else {\n                            deposit();\n                        }\n                    } else {\n                        find(uint256[100],int128);\n                    }\n                } else {\n                    calc_total(uint256[100]);\n                }\n            } else {\n                getBalance(address);\n            }\n        } else {\n            multiSendToken(address,address[100],uint256[100]);\n        }\n    } else {\n        multiSendEther(address[100],uint256[100]);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.03 03:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0]\nuint256 _sendTokenFee; // STORAGE[0x1]\nuint256 _sendEthFee; // STORAGE[0x2]\n\n\nfunction multiSendEther(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13, uint256 varg14, uint256 varg15, uint256 varg16, uint256 varg17, uint256 varg18, uint256 varg19, uint256 varg20, uint256 varg21, uint256 varg22, uint256 varg23, uint256 varg24, uint256 varg25, uint256 varg26, uint256 varg27, uint256 varg28, uint256 varg29, uint256 varg30, uint256 varg31, uint256 varg32, uint256 varg33, uint256 varg34, uint256 varg35, uint256 varg36, uint256 varg37, uint256 varg38, uint256 varg39, uint256 varg40, uint256 varg41, uint256 varg42, uint256 varg43, uint256 varg44, uint256 varg45, uint256 varg46, uint256 varg47, uint256 varg48, uint256 varg49, uint256 varg50, uint256 varg51, uint256 varg52, uint256 varg53, uint256 varg54, uint256 varg55, uint256 varg56, uint256 varg57, uint256 varg58, uint256 varg59, uint256 varg60, uint256 varg61, uint256 varg62, uint256 varg63, uint256 varg64, uint256 varg65, uint256 varg66, uint256 varg67, uint256 varg68, uint256 varg69, uint256 varg70, uint256 varg71, uint256 varg72, uint256 varg73, uint256 varg74, uint256 varg75, uint256 varg76, uint256 varg77, uint256 varg78, uint256 varg79, uint256 varg80, uint256 varg81, uint256 varg82, uint256 varg83, uint256 varg84, uint256 varg85, uint256 varg86, uint256 varg87, uint256 varg88, uint256 varg89, uint256 varg90, uint256 varg91, uint256 varg92, uint256 varg93, uint256 varg94, uint256 varg95, uint256 varg96, uint256 varg97, uint256 varg98, uint256 varg99) public payable { \n    CALLDATACOPY(320, 4, 6400);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(varg2 < MEM[32]);\n    require(varg3 < MEM[32]);\n    require(varg4 < MEM[32]);\n    require(varg5 < MEM[32]);\n    require(varg6 < MEM[32]);\n    require(varg7 < MEM[32]);\n    require(varg8 < MEM[32]);\n    require(varg9 < MEM[32]);\n    require(varg10 < MEM[32]);\n    require(varg11 < MEM[32]);\n    require(varg12 < MEM[32]);\n    require(varg13 < MEM[32]);\n    require(varg14 < MEM[32]);\n    require(varg15 < MEM[32]);\n    require(varg16 < MEM[32]);\n    require(varg17 < MEM[32]);\n    require(varg18 < MEM[32]);\n    require(varg19 < MEM[32]);\n    require(varg20 < MEM[32]);\n    require(varg21 < MEM[32]);\n    require(varg22 < MEM[32]);\n    require(varg23 < MEM[32]);\n    require(varg24 < MEM[32]);\n    require(varg25 < MEM[32]);\n    require(varg26 < MEM[32]);\n    require(varg27 < MEM[32]);\n    require(varg28 < MEM[32]);\n    require(varg29 < MEM[32]);\n    require(varg30 < MEM[32]);\n    require(varg31 < MEM[32]);\n    require(varg32 < MEM[32]);\n    require(varg33 < MEM[32]);\n    require(varg34 < MEM[32]);\n    require(varg35 < MEM[32]);\n    require(varg36 < MEM[32]);\n    require(varg37 < MEM[32]);\n    require(varg38 < MEM[32]);\n    require(varg39 < MEM[32]);\n    require(varg40 < MEM[32]);\n    require(varg41 < MEM[32]);\n    require(varg42 < MEM[32]);\n    require(varg43 < MEM[32]);\n    require(varg44 < MEM[32]);\n    require(varg45 < MEM[32]);\n    require(varg46 < MEM[32]);\n    require(varg47 < MEM[32]);\n    require(varg48 < MEM[32]);\n    require(varg49 < MEM[32]);\n    require(varg50 < MEM[32]);\n    require(varg51 < MEM[32]);\n    require(varg52 < MEM[32]);\n    require(varg53 < MEM[32]);\n    require(varg54 < MEM[32]);\n    require(varg55 < MEM[32]);\n    require(varg56 < MEM[32]);\n    require(varg57 < MEM[32]);\n    require(varg58 < MEM[32]);\n    require(varg59 < MEM[32]);\n    require(varg60 < MEM[32]);\n    require(varg61 < MEM[32]);\n    require(varg62 < MEM[32]);\n    require(varg63 < MEM[32]);\n    require(varg64 < MEM[32]);\n    require(varg65 < MEM[32]);\n    require(varg66 < MEM[32]);\n    require(varg67 < MEM[32]);\n    require(varg68 < MEM[32]);\n    require(varg69 < MEM[32]);\n    require(varg70 < MEM[32]);\n    require(varg71 < MEM[32]);\n    require(varg72 < MEM[32]);\n    require(varg73 < MEM[32]);\n    require(varg74 < MEM[32]);\n    require(varg75 < MEM[32]);\n    require(varg76 < MEM[32]);\n    require(varg77 < MEM[32]);\n    require(varg78 < MEM[32]);\n    require(varg79 < MEM[32]);\n    require(varg80 < MEM[32]);\n    require(varg81 < MEM[32]);\n    require(varg82 < MEM[32]);\n    require(varg83 < MEM[32]);\n    require(varg84 < MEM[32]);\n    require(varg85 < MEM[32]);\n    require(varg86 < MEM[32]);\n    require(varg87 < MEM[32]);\n    require(varg88 < MEM[32]);\n    require(varg89 < MEM[32]);\n    require(varg90 < MEM[32]);\n    require(varg91 < MEM[32]);\n    require(varg92 < MEM[32]);\n    require(varg93 < MEM[32]);\n    require(varg94 < MEM[32]);\n    require(varg95 < MEM[32]);\n    require(varg96 < MEM[32]);\n    require(varg97 < MEM[32]);\n    require(varg98 < MEM[32]);\n    require(varg99 < MEM[32]);\n    while (0 >= 100) {\n        if (MEM[3520] > 0) {\n            require(0 < 100);\n            require(0 + MEM[3520] >= 0);\n            require(0 < 100);\n            MEM[6752] = 0 + MEM[3520];\n            MEM[6848] = 1;\n            if (100 != 1) {\n                break;\n            }\n        }\n    }\n    revert();\n    require(MEM[6752] + _sendEthFee >= MEM[6752]);\n    require(msg.value >= MEM[6752] + _sendEthFee);\n    while (0 >= 100) {\n        if (MEM[3520] > 0) {\n            require(0 < 100);\n            require(0 < 100);\n            v0 = MEM[0x140].call().value(MEM[3520]);\n            require(v0);\n            MEM[6912] = 1;\n            if (100 != 1) {\n                break;\n            }\n        }\n    }\n    revert();\n    if (msg.value > MEM[6752] + _sendEthFee) {\n        require(msg.value >= MEM[6752] + _sendEthFee);\n        v1 = msg.sender.call().value(msg.value - (MEM[6752] + _sendEthFee));\n        require(v1);\n    }\n    return 1;\n}\n\nfunction multiSendToken(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13, uint256 varg14, uint256 varg15, uint256 varg16, uint256 varg17, uint256 varg18, uint256 varg19, uint256 varg20, uint256 varg21, uint256 varg22, uint256 varg23, uint256 varg24, uint256 varg25, uint256 varg26, uint256 varg27, uint256 varg28, uint256 varg29, uint256 varg30, uint256 varg31, uint256 varg32, uint256 varg33, uint256 varg34, uint256 varg35, uint256 varg36, uint256 varg37, uint256 varg38, uint256 varg39, uint256 varg40, uint256 varg41, uint256 varg42, uint256 varg43, uint256 varg44, uint256 varg45, uint256 varg46, uint256 varg47, uint256 varg48, uint256 varg49, uint256 varg50, uint256 varg51, uint256 varg52, uint256 varg53, uint256 varg54, uint256 varg55, uint256 varg56, uint256 varg57, uint256 varg58, uint256 varg59, uint256 varg60, uint256 varg61, uint256 varg62, uint256 varg63, uint256 varg64, uint256 varg65, uint256 varg66, uint256 varg67, uint256 varg68, uint256 varg69, uint256 varg70, uint256 varg71, uint256 varg72, uint256 varg73, uint256 varg74, uint256 varg75, uint256 varg76, uint256 varg77, uint256 varg78, uint256 varg79, uint256 varg80, uint256 varg81, uint256 varg82, uint256 varg83, uint256 varg84, uint256 varg85, uint256 varg86, uint256 varg87, uint256 varg88, uint256 varg89, uint256 varg90, uint256 varg91, uint256 varg92, uint256 varg93, uint256 varg94, uint256 varg95, uint256 varg96, uint256 varg97, uint256 varg98, uint256 varg99, uint256 varg100) public payable { \n    CALLDATACOPY(320, 4, 6432);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(varg2 < MEM[32]);\n    require(varg3 < MEM[32]);\n    require(varg4 < MEM[32]);\n    require(varg5 < MEM[32]);\n    require(varg6 < MEM[32]);\n    require(varg7 < MEM[32]);\n    require(varg8 < MEM[32]);\n    require(varg9 < MEM[32]);\n    require(varg10 < MEM[32]);\n    require(varg11 < MEM[32]);\n    require(varg12 < MEM[32]);\n    require(varg13 < MEM[32]);\n    require(varg14 < MEM[32]);\n    require(varg15 < MEM[32]);\n    require(varg16 < MEM[32]);\n    require(varg17 < MEM[32]);\n    require(varg18 < MEM[32]);\n    require(varg19 < MEM[32]);\n    require(varg20 < MEM[32]);\n    require(varg21 < MEM[32]);\n    require(varg22 < MEM[32]);\n    require(varg23 < MEM[32]);\n    require(varg24 < MEM[32]);\n    require(varg25 < MEM[32]);\n    require(varg26 < MEM[32]);\n    require(varg27 < MEM[32]);\n    require(varg28 < MEM[32]);\n    require(varg29 < MEM[32]);\n    require(varg30 < MEM[32]);\n    require(varg31 < MEM[32]);\n    require(varg32 < MEM[32]);\n    require(varg33 < MEM[32]);\n    require(varg34 < MEM[32]);\n    require(varg35 < MEM[32]);\n    require(varg36 < MEM[32]);\n    require(varg37 < MEM[32]);\n    require(varg38 < MEM[32]);\n    require(varg39 < MEM[32]);\n    require(varg40 < MEM[32]);\n    require(varg41 < MEM[32]);\n    require(varg42 < MEM[32]);\n    require(varg43 < MEM[32]);\n    require(varg44 < MEM[32]);\n    require(varg45 < MEM[32]);\n    require(varg46 < MEM[32]);\n    require(varg47 < MEM[32]);\n    require(varg48 < MEM[32]);\n    require(varg49 < MEM[32]);\n    require(varg50 < MEM[32]);\n    require(varg51 < MEM[32]);\n    require(varg52 < MEM[32]);\n    require(varg53 < MEM[32]);\n    require(varg54 < MEM[32]);\n    require(varg55 < MEM[32]);\n    require(varg56 < MEM[32]);\n    require(varg57 < MEM[32]);\n    require(varg58 < MEM[32]);\n    require(varg59 < MEM[32]);\n    require(varg60 < MEM[32]);\n    require(varg61 < MEM[32]);\n    require(varg62 < MEM[32]);\n    require(varg63 < MEM[32]);\n    require(varg64 < MEM[32]);\n    require(varg65 < MEM[32]);\n    require(varg66 < MEM[32]);\n    require(varg67 < MEM[32]);\n    require(varg68 < MEM[32]);\n    require(varg69 < MEM[32]);\n    require(varg70 < MEM[32]);\n    require(varg71 < MEM[32]);\n    require(varg72 < MEM[32]);\n    require(varg73 < MEM[32]);\n    require(varg74 < MEM[32]);\n    require(varg75 < MEM[32]);\n    require(varg76 < MEM[32]);\n    require(varg77 < MEM[32]);\n    require(varg78 < MEM[32]);\n    require(varg79 < MEM[32]);\n    require(varg80 < MEM[32]);\n    require(varg81 < MEM[32]);\n    require(varg82 < MEM[32]);\n    require(varg83 < MEM[32]);\n    require(varg84 < MEM[32]);\n    require(varg85 < MEM[32]);\n    require(varg86 < MEM[32]);\n    require(varg87 < MEM[32]);\n    require(varg88 < MEM[32]);\n    require(varg89 < MEM[32]);\n    require(varg90 < MEM[32]);\n    require(varg91 < MEM[32]);\n    require(varg92 < MEM[32]);\n    require(varg93 < MEM[32]);\n    require(varg94 < MEM[32]);\n    require(varg95 < MEM[32]);\n    require(varg96 < MEM[32]);\n    require(varg97 < MEM[32]);\n    require(varg98 < MEM[32]);\n    require(varg99 < MEM[32]);\n    require(varg100 < MEM[32]);\n    while (MEM[3552] > MEM[64]) {\n        if (MEM[3552] >= MEM[96]) {\n            break;\n        }\n        require(MEM[3552] >= MEM[96]);\n        if (0 + MEM[3552] <= MEM[64]) {\n            break;\n        }\n        require(0 + MEM[3552] <= MEM[64]);\n        if (0 + MEM[3552] >= MEM[96]) {\n            break;\n        }\n        require(0 + MEM[3552] >= MEM[96]);\n        MEM[6880] = 1;\n        if (100 != 1) {\n            break;\n        }\n        if (100 == 1) {\n            require(msg.value >= _sendTokenFee);\n            require(0 + MEM[3552] >= 0);\n            require((MEM[320]).code.size);\n            require(this != MEM[320]);\n            v0 = MEM[0x140].allowance(msg.sender, this).gas(msg.gas);\n            require(v0);\n            require(MEM[7104] >= 0 + MEM[3552]);\n            while (0 >= 100) {\n                if (MEM[3552] > 0) {\n                    require((MEM[320]).code.size);\n                    require(this != MEM[320]);\n                    require(0 < 100);\n                    require(0 < 100);\n                    v1 = MEM[0x140].transferFrom(msg.sender, MEM[352], MEM[3552]).gas(msg.gas);\n                    require(v1);\n                    require(MEM[7360]);\n                    MEM[7136] = 1;\n                    if (100 != 1) {\n                        break;\n                    }\n                }\n            }\n            revert();\n            if (msg.value > _sendTokenFee) {\n                require(msg.value >= _sendTokenFee);\n                v2 = msg.sender.call().value(msg.value - _sendTokenFee);\n                require(v2);\n            }\n            return 1;\n        }\n    }\n    revert();\n}\n\nfunction getBalance(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return (MEM[320]).balance;\n}\n\nfunction calc_total() public payable { \n    CALLDATACOPY(320, 4, 3200);\n    require(!msg.value);\n    while (MEM[320] <= 0) {\n        require(0 + MEM[320] >= 0);\n        MEM[3520] = 0 + MEM[320];\n        MEM[3616] = 1;\n        if (100 != 1) {\n            break;\n        }\n    }\n    return MEM[3520];\n}\n\nfunction find(uint256[100] varg0) public payable { \n    CALLDATACOPY(320, 4, 3232);\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(MEM[3520] < 100);\n    return MEM[(MEM[3520] << 5) + 320];\n}\n\nfunction deposit() public payable { \n    return 1;\n}\n\nfunction withdrawEther(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    v0 = MEM[0x140].call().value(MEM[352]);\n    require(v0);\n    return 1;\n}\n\nfunction withdrawToken(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 96);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(msg.sender == _owner);\n    require((MEM[320]).code.size);\n    require(this != MEM[320]);\n    v0 = MEM[0x140].transfer(MEM[352], MEM[384]).gas(msg.gas);\n    require(v0);\n    require(MEM[576]);\n    return 1;\n}\n\nfunction setSendTokenFee() public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(msg.sender == _owner);\n    _sendTokenFee = MEM[320];\n    return 1;\n}\n\nfunction setSendEthFee() public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(msg.sender == _owner);\n    _sendEthFee = MEM[320];\n    return 1;\n}\n\nfunction destroy(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    selfdestruct(MEM[320]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction sendTokenFee() public nonPayable { \n    return _sendTokenFee;\n}\n\nfunction sendEthFee() public nonPayable { \n    return _sendEthFee;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0x85e37c33) {\n        if (function_selector != 0xab8fc59d) {\n            if (function_selector != 0xf8b2cb4f) {\n                if (function_selector != 0xa4521d32) {\n                    if (function_selector != 0xb372b854) {\n                        if (function_selector != 0xd0e30db0) {\n                            if (function_selector != 0x522f6815) {\n                                if (function_selector != 0x1e33667) {\n                                    if (function_selector != 0xd74f2b76) {\n                                        if (function_selector != 0x7903b0d5) {\n                                            if (function_selector != 0xf55d9d) {\n                                                if (function_selector != 0x8da5cb5b) {\n                                                    if (function_selector != 0x1f6b81ce) {\n                                                        require(function_selector == 0x8de5bc40);\n                                                        sendEthFee();\n                                                    } else {\n                                                        sendTokenFee();\n                                                    }\n                                                } else {\n                                                    owner();\n                                                }\n                                            } else {\n                                                destroy(address);\n                                            }\n                                        } else {\n                                            setSendEthFee(uint256);\n                                        }\n                                    } else {\n                                        setSendTokenFee(uint256);\n                                    }\n                                } else {\n                                    withdrawToken(address,address,uint256);\n                                }\n                            } else {\n                                withdrawEther(address,uint256);\n                            }\n                        } else {\n                            deposit();\n                        }\n                    } else {\n                        find(uint256[100],int128);\n                    }\n                } else {\n                    calc_total(uint256[100]);\n                }\n            } else {\n                getBalance(address);\n            }\n        } else {\n            multiSendToken(address,address[100],uint256[100]);\n        }\n    } else {\n        multiSendEther(address[100],uint256[100]);\n    }\n}\n.",
	"status": "1",
	"time_cost": 32.829277992248535,
	"usage": {
		"completion_tokens": 720,
		"prompt_tokens": 5332,
		"total_tokens": 6052
	}
}