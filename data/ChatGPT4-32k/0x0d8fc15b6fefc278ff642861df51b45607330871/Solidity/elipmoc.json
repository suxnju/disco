{
	"address": "0x0d8fc15b6fefc278ff642861df51b45607330871",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the corresponding Solidity contract:\n\n```Solidity\npragma solidity ^0.5.0;\n\ncontract MyToken {\n    mapping (address => uint256) private _balances;\n    mapping (address => bool) private _issuers;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _blacklist;\n\n    uint256 private _totalSupply;\n    bool private _contractFrozen;\n    address private _freezeContract;\n\n    event Appointed(address indexed account);\n    event Blacklisted(address indexed account);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function contractFrozen() public view returns (bool) {\n        return _contractFrozen;\n    }\n\n    function isIssuer(address account) public view returns (bool) {\n        return _issuers[account];\n    }\n\n    function setIssuer(address account, bool _isIssuer) public {\n        require(msg.sender == _freezeContract, \"Not freeze contract\");\n        require(_isIssuer != _issuers[account], \"Already set\");\n        _issuers[account] = _isIssuer;\n        emit Appointed(account);\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function blacklist(address account) public {\n        require(msg.sender == _freezeContract, \"Not freeze contract\");\n        _blacklist[account] = true;\n        emit Blacklisted(account);\n    }\n\n    function freezeContract(bool freeze) public {\n        require(msg.sender == _freezeContract, \"Not freeze contract\");\n        _contractFrozen = freeze;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_blacklist[msg.sender] == false, \"Sender is blacklisted\");\n        require(_contractFrozen == false, \"Contract is frozen\");\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_blacklist[msg.sender] == false, \"Sender is blacklisted\");\n        require(_contractFrozen == false, \"Contract is frozen\");\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(_blacklist[msg.sender] == false, \"Owner is blacklisted\");\n        require(_contractFrozen == false, \"Contract is frozen\");\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function mint(address account, uint256 amount) public {\n        require(_issuers[msg.sender] == true, \"Not issuer\");\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function redeem(uint256 amount) public {\n        require(_issuers[msg.sender] == true, \"Not issuer\");\n        _totalSupply = _totalSupply - amount;\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) public {\n        require(_issuers[msg.sender] == true, \"Not issuer\");\n        _totalSupply = _totalSupply - amount;\n        _balances[account] = _balances[account] - amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function blacklisted(address account) public view returns (bool) {\n        return _blacklist[account];\n    }\n}\n```\n\nPlease note that this Solidity contract is a simple interpretation based on the decompiled code you provided. There may be additional functionalities that are not covered in this contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701485538,
	"id": "chatcmpl-8RAP4q8K6Xa6Y3lAG4mqjDGOfN9KH",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.19 04:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _freezeContract; // STORAGE[0x6]\nuint256 _contractFrozen; // STORAGE[0x7]\n\n// Events\nAppointed(address);\nBlacklisted(address);\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction contractFrozen() public nonPayable { \n    return _contractFrozen;\n}\n\nfunction isIssuer(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(9, varg0)];\n}\n\nfunction setIssuer(address varg0, bool varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < 2);\n    require(msg.sender == _freezeContract);\n    require(STORAGE[keccak256(0x9, varg0)] ^ varg1);\n    STORAGE[keccak256(9, varg0)] = varg1;\n    emit Appointed(varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(4, varg0), varg1)];\n}\n\nfunction blacklist(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(msg.sender == _freezeContract);\n    MEM[320] = 0xa20623ce;\n    require(varg0 ^ 0x0);\n    STORAGE[keccak256(8, varg0)] = 1;\n    emit Blacklisted(varg0);\n}\n\nfunction freezeContract(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _freezeContract);\n    _contractFrozen = varg0;\n    return varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    require(STORAGE[keccak256(3, msg.sender)] >= varg1);\n    STORAGE[keccak256(3, msg.sender)] = STORAGE[keccak256(3, msg.sender)] - varg1;\n    require(STORAGE[keccak256(3, varg0)] + varg1 >= STORAGE[keccak256(3, varg0)]);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    require(STORAGE[keccak256(3, varg0)] >= varg2);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] - varg2;\n    require(STORAGE[keccak256(3, varg1)] + varg2 >= STORAGE[keccak256(3, varg1)]);\n    STORAGE[keccak256(3, varg1)] = STORAGE[keccak256(3, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(4, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(4, varg0), msg.sender)] = STORAGE[keccak256(keccak256(4, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    STORAGE[keccak256(keccak256(4, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction mint(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    require(varg0 ^ 0x0);\n    require(_totalSupply + varg1 >= _totalSupply);\n    _totalSupply = _totalSupply + varg1;\n    require(STORAGE[keccak256(3, varg0)] + varg1 >= STORAGE[keccak256(3, varg0)]);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] + varg1;\n    emit Transfer(0, varg0, varg1);\n}\n\nfunction redeem(uint256 varg0) public nonPayable { \n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    MEM[320] = 0x6161eb18;\n    require(msg.sender ^ 0x0);\n    require(_totalSupply >= varg0);\n    _totalSupply = _totalSupply - varg0;\n    require(STORAGE[keccak256(3, msg.sender)] >= varg0);\n    STORAGE[keccak256(3, msg.sender)] = STORAGE[keccak256(3, msg.sender)] - varg0;\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    MEM[320] = 0x6161eb18;\n    require(varg0 ^ 0x0);\n    require(_totalSupply >= varg1);\n    _totalSupply = _totalSupply - varg1;\n    require(STORAGE[keccak256(3, varg0)] >= varg1);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] - varg1;\n    emit Transfer(varg0, 0, varg1);\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(3, varg0)];\n}\n\nfunction blacklisted(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, varg0)];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0xc79bad43) {\n                if (function_selector != 0x877b9a67) {\n                    if (function_selector != 0x495289be) {\n                        if (function_selector != 0xdd62ed3e) {\n                            if (function_selector != 0xf9f92be4) {\n                                if (function_selector != 0x6b4c0789) {\n                                    if (function_selector != 0xa9059cbb) {\n                                        if (function_selector != 0x23b872dd) {\n                                            if (function_selector != 0x95ea7b3) {\n                                                if (function_selector != 0x40c10f19) {\n                                                    if (function_selector != 0xdb006a75) {\n                                                        if (function_selector != 0x79cc6790) {\n                                                            if (function_selector != 0x6fdde03) {\n                                                                if (function_selector != 0x95d89b41) {\n                                                                    if (function_selector != 0x313ce567) {\n                                                                        if (function_selector != 0x70a08231) {\n                                                                            if (function_selector == 0xdbac26e9) {\n                                                                                blacklisted(address);\n                                                                            }\n                                                                        } else {\n                                                                            balanceOf(address);\n                                                                        }\n                                                                    } else {\n                                                                        decimals();\n                                                                    }\n                                                                } else {\n                                                                    symbol();\n                                                                }\n                                                            } else {\n                                                                name();\n                                                            }\n                                                        } else {\n                                                            burnFrom(address,uint256);\n                                                        }\n                                                    } else {\n                                                        redeem(uint256);\n                                                    }\n                                                } else {\n                                                    mint(address,uint256);\n                                                }\n                                            } else {\n                                                approve(address,uint256);\n                                            }\n                                        } else {\n                                            transferFrom(address,address,uint256);\n                                        }\n                                    } else {\n                                        transfer(address,uint256);\n                                    }\n                                } else {\n                                    freezeContract(bool);\n                                }\n                            } else {\n                                blacklist(address);\n                            }\n                        } else {\n                            allowance(address,address);\n                        }\n                    } else {\n                        setIssuer(address,bool);\n                    }\n                } else {\n                    isIssuer(address);\n                }\n            } else {\n                contractFrozen();\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.19 04:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _freezeContract; // STORAGE[0x6]\nuint256 _contractFrozen; // STORAGE[0x7]\n\n// Events\nAppointed(address);\nBlacklisted(address);\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction contractFrozen() public nonPayable { \n    return _contractFrozen;\n}\n\nfunction isIssuer(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(9, varg0)];\n}\n\nfunction setIssuer(address varg0, bool varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < 2);\n    require(msg.sender == _freezeContract);\n    require(STORAGE[keccak256(0x9, varg0)] ^ varg1);\n    STORAGE[keccak256(9, varg0)] = varg1;\n    emit Appointed(varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(4, varg0), varg1)];\n}\n\nfunction blacklist(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(msg.sender == _freezeContract);\n    MEM[320] = 0xa20623ce;\n    require(varg0 ^ 0x0);\n    STORAGE[keccak256(8, varg0)] = 1;\n    emit Blacklisted(varg0);\n}\n\nfunction freezeContract(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _freezeContract);\n    _contractFrozen = varg0;\n    return varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    require(STORAGE[keccak256(3, msg.sender)] >= varg1);\n    STORAGE[keccak256(3, msg.sender)] = STORAGE[keccak256(3, msg.sender)] - varg1;\n    require(STORAGE[keccak256(3, varg0)] + varg1 >= STORAGE[keccak256(3, varg0)]);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    require(STORAGE[keccak256(3, varg0)] >= varg2);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] - varg2;\n    require(STORAGE[keccak256(3, varg1)] + varg2 >= STORAGE[keccak256(3, varg1)]);\n    STORAGE[keccak256(3, varg1)] = STORAGE[keccak256(3, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(4, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(4, varg0), msg.sender)] = STORAGE[keccak256(keccak256(4, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    STORAGE[keccak256(keccak256(4, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction mint(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    require(varg0 ^ 0x0);\n    require(_totalSupply + varg1 >= _totalSupply);\n    _totalSupply = _totalSupply + varg1;\n    require(STORAGE[keccak256(3, varg0)] + varg1 >= STORAGE[keccak256(3, varg0)]);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] + varg1;\n    emit Transfer(0, varg0, varg1);\n}\n\nfunction redeem(uint256 varg0) public nonPayable { \n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    MEM[320] = 0x6161eb18;\n    require(msg.sender ^ 0x0);\n    require(_totalSupply >= varg0);\n    _totalSupply = _totalSupply - varg0;\n    require(STORAGE[keccak256(3, msg.sender)] >= varg0);\n    STORAGE[keccak256(3, msg.sender)] = STORAGE[keccak256(3, msg.sender)] - varg0;\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    MEM[320] = 0x6161eb18;\n    require(varg0 ^ 0x0);\n    require(_totalSupply >= varg1);\n    _totalSupply = _totalSupply - varg1;\n    require(STORAGE[keccak256(3, varg0)] >= varg1);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] - varg1;\n    emit Transfer(varg0, 0, varg1);\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(3, varg0)];\n}\n\nfunction blacklisted(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, varg0)];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0xc79bad43) {\n                if (function_selector != 0x877b9a67) {\n                    if (function_selector != 0x495289be) {\n                        if (function_selector != 0xdd62ed3e) {\n                            if (function_selector != 0xf9f92be4) {\n                                if (function_selector != 0x6b4c0789) {\n                                    if (function_selector != 0xa9059cbb) {\n                                        if (function_selector != 0x23b872dd) {\n                                            if (function_selector != 0x95ea7b3) {\n                                                if (function_selector != 0x40c10f19) {\n                                                    if (function_selector != 0xdb006a75) {\n                                                        if (function_selector != 0x79cc6790) {\n                                                            if (function_selector != 0x6fdde03) {\n                                                                if (function_selector != 0x95d89b41) {\n                                                                    if (function_selector != 0x313ce567) {\n                                                                        if (function_selector != 0x70a08231) {\n                                                                            if (function_selector == 0xdbac26e9) {\n                                                                                blacklisted(address);\n                                                                            }\n                                                                        } else {\n                                                                            balanceOf(address);\n                                                                        }\n                                                                    } else {\n                                                                        decimals();\n                                                                    }\n                                                                } else {\n                                                                    symbol();\n                                                                }\n                                                            } else {\n                                                                name();\n                                                            }\n                                                        } else {\n                                                            burnFrom(address,uint256);\n                                                        }\n                                                    } else {\n                                                        redeem(uint256);\n                                                    }\n                                                } else {\n                                                    mint(address,uint256);\n                                                }\n                                            } else {\n                                                approve(address,uint256);\n                                            }\n                                        } else {\n                                            transferFrom(address,address,uint256);\n                                        }\n                                    } else {\n                                        transfer(address,uint256);\n                                    }\n                                } else {\n                                    freezeContract(bool);\n                                }\n                            } else {\n                                blacklist(address);\n                            }\n                        } else {\n                            allowance(address,address);\n                        }\n                    } else {\n                        setIssuer(address,bool);\n                    }\n                } else {\n                    isIssuer(address);\n                }\n            } else {\n                contractFrozen();\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.19 04:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _freezeContract; // STORAGE[0x6]\nuint256 _contractFrozen; // STORAGE[0x7]\n\n// Events\nAppointed(address);\nBlacklisted(address);\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction contractFrozen() public nonPayable { \n    return _contractFrozen;\n}\n\nfunction isIssuer(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(9, varg0)];\n}\n\nfunction setIssuer(address varg0, bool varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < 2);\n    require(msg.sender == _freezeContract);\n    require(STORAGE[keccak256(0x9, varg0)] ^ varg1);\n    STORAGE[keccak256(9, varg0)] = varg1;\n    emit Appointed(varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(4, varg0), varg1)];\n}\n\nfunction blacklist(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(msg.sender == _freezeContract);\n    MEM[320] = 0xa20623ce;\n    require(varg0 ^ 0x0);\n    STORAGE[keccak256(8, varg0)] = 1;\n    emit Blacklisted(varg0);\n}\n\nfunction freezeContract(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _freezeContract);\n    _contractFrozen = varg0;\n    return varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    require(STORAGE[keccak256(3, msg.sender)] >= varg1);\n    STORAGE[keccak256(3, msg.sender)] = STORAGE[keccak256(3, msg.sender)] - varg1;\n    require(STORAGE[keccak256(3, varg0)] + varg1 >= STORAGE[keccak256(3, varg0)]);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    require(STORAGE[keccak256(3, varg0)] >= varg2);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] - varg2;\n    require(STORAGE[keccak256(3, varg1)] + varg2 >= STORAGE[keccak256(3, varg1)]);\n    STORAGE[keccak256(3, varg1)] = STORAGE[keccak256(3, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(4, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(4, varg0), msg.sender)] = STORAGE[keccak256(keccak256(4, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(0x8, msg.sender)] ^ 0x1);\n    require(_contractFrozen ^ 0x1);\n    STORAGE[keccak256(keccak256(4, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction mint(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    require(varg0 ^ 0x0);\n    require(_totalSupply + varg1 >= _totalSupply);\n    _totalSupply = _totalSupply + varg1;\n    require(STORAGE[keccak256(3, varg0)] + varg1 >= STORAGE[keccak256(3, varg0)]);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] + varg1;\n    emit Transfer(0, varg0, varg1);\n}\n\nfunction redeem(uint256 varg0) public nonPayable { \n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    MEM[320] = 0x6161eb18;\n    require(msg.sender ^ 0x0);\n    require(_totalSupply >= varg0);\n    _totalSupply = _totalSupply - varg0;\n    require(STORAGE[keccak256(3, msg.sender)] >= varg0);\n    STORAGE[keccak256(3, msg.sender)] = STORAGE[keccak256(3, msg.sender)] - varg0;\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(9, msg.sender)] == 1);\n    MEM[320] = 0x6161eb18;\n    require(varg0 ^ 0x0);\n    require(_totalSupply >= varg1);\n    _totalSupply = _totalSupply - varg1;\n    require(STORAGE[keccak256(3, varg0)] >= varg1);\n    STORAGE[keccak256(3, varg0)] = STORAGE[keccak256(3, varg0)] - varg1;\n    emit Transfer(varg0, 0, varg1);\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(3, varg0)];\n}\n\nfunction blacklisted(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, varg0)];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0xc79bad43) {\n                if (function_selector != 0x877b9a67) {\n                    if (function_selector != 0x495289be) {\n                        if (function_selector != 0xdd62ed3e) {\n                            if (function_selector != 0xf9f92be4) {\n                                if (function_selector != 0x6b4c0789) {\n                                    if (function_selector != 0xa9059cbb) {\n                                        if (function_selector != 0x23b872dd) {\n                                            if (function_selector != 0x95ea7b3) {\n                                                if (function_selector != 0x40c10f19) {\n                                                    if (function_selector != 0xdb006a75) {\n                                                        if (function_selector != 0x79cc6790) {\n                                                            if (function_selector != 0x6fdde03) {\n                                                                if (function_selector != 0x95d89b41) {\n                                                                    if (function_selector != 0x313ce567) {\n                                                                        if (function_selector != 0x70a08231) {\n                                                                            if (function_selector == 0xdbac26e9) {\n                                                                                blacklisted(address);\n                                                                            }\n                                                                        } else {\n                                                                            balanceOf(address);\n                                                                        }\n                                                                    } else {\n                                                                        decimals();\n                                                                    }\n                                                                } else {\n                                                                    symbol();\n                                                                }\n                                                            } else {\n                                                                name();\n                                                            }\n                                                        } else {\n                                                            burnFrom(address,uint256);\n                                                        }\n                                                    } else {\n                                                        redeem(uint256);\n                                                    }\n                                                } else {\n                                                    mint(address,uint256);\n                                                }\n                                            } else {\n                                                approve(address,uint256);\n                                            }\n                                        } else {\n                                            transferFrom(address,address,uint256);\n                                        }\n                                    } else {\n                                        transfer(address,uint256);\n                                    }\n                                } else {\n                                    freezeContract(bool);\n                                }\n                            } else {\n                                blacklist(address);\n                            }\n                        } else {\n                            allowance(address,address);\n                        }\n                    } else {\n                        setIssuer(address,bool);\n                    }\n                } else {\n                    isIssuer(address);\n                }\n            } else {\n                contractFrozen();\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 34.71025466918945,
	"usage": {
		"completion_tokens": 941,
		"prompt_tokens": 2550,
		"total_tokens": 3491
	}
}