{
	"address": "0x042a277368cb43a70b06361e7ab7d1d0a2096b0e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code based on the decompiled code:\n\n```solidity\npragma solidity ^0.7.0;\n\ncontract BonusContract {\n    mapping (address => uint256) private _ownedBonus;\n    mapping (address => uint256) private _investorsAccounts;\n    uint256 private _finalTimestampOfBonusPeriod;\n    address private owner_3_0_19;\n    address private _fundariaTokenBuyAddress;\n    address private _setFundariaTokenBuyAddress;\n    \n    event AccountFilledWithBonus(address indexed _address, uint256 value, uint256 total);\n    event BonusWithdrawn(address indexed _address, uint256 value);\n    \n    function ownedBonus(address _address) public view returns (uint256) {\n        return _ownedBonus[_address];\n    }\n\n    function setFinalTimestampOfBonusPeriod(uint256 _timestamp) public {\n        require(_setFundariaTokenBuyAddress == msg.sender, \"Unauthorized\");\n        require(_timestamp < _finalTimestampOfBonusPeriod || _finalTimestampOfBonusPeriod == 0, \"Invalid timestamp\");\n        _finalTimestampOfBonusPeriod = _timestamp;\n    }\n\n    function fillInvestorAccountWithBonus(address _address) public {\n        require(_ownedBonus[msg.sender] > 0, \"No bonus owned\");\n        require(_investorsAccounts[_address] > 0 || _investorsAccounts[_address] == ~uint256(0), \"Invalid account\");\n        _ownedBonus[msg.sender] = 0;\n        _investorsAccounts[_address] += _ownedBonus[msg.sender];\n        emit AccountFilledWithBonus(_address, _ownedBonus[msg.sender], _ownedBonus[msg.sender] + _investorsAccounts[_address]);\n        (bool success,) = _address.call{value: _ownedBonus[msg.sender]}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function investorsAccounts(address _address) public view returns (uint256) {\n        return _investorsAccounts[_address];\n    }\n\n    function finalTimestampOfBonusPeriod() public view returns (uint256) {\n        return _finalTimestampOfBonusPeriod;\n    }\n\n    function withdrawBonus() public {\n        require(_ownedBonus[msg.sender] > 0, \"No bonus owned\");\n        require(block.timestamp > _finalTimestampOfBonusPeriod, \"Cannot withdraw bonus now\");\n        uint256 amount = _ownedBonus[msg.sender];\n        _ownedBonus[msg.sender] = 0;\n        emit BonusWithdrawn(msg.sender, amount);\n        (bool success,) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function setRegisteringContractAddress(address _address) public {\n        require(_setFundariaTokenBuyAddress == msg.sender, \"Unauthorized\");\n        owner_3_0_19 = _address;\n    }\n\n    function setOwnedBonus() public payable {\n        require(_fundariaTokenBuyAddress == msg.sender, \"Unauthorized\");\n        _ownedBonus[tx.origin] += msg.value;\n    }\n\n    function registerInvestorAccount(address _address) public {\n        require(_setFundariaTokenBuyAddress == msg.sender || owner_3_0_19 == msg.sender, \"Unauthorized\");\n        _investorsAccounts[_address] = ~uint256(0);\n    }\n\n    function setFundariaTokenBuyAddress(address _address) public {\n        require(_setFundariaTokenBuyAddress == msg.sender, \"Unauthorized\");\n        _fundariaTokenBuyAddress = _address;\n    }\n\n    function fundariaTokenBuyAddress() public view returns (address) {\n        return _fundariaTokenBuyAddress;\n    }\n}\n```\n\nPlease note that the Solidity version used in the contract might need to be adjusted according to your development environment. Also, the __function_selector__ function is not implemented as it is not a standard Solidity function and was likely used for decompiling purposes.",
				"role": "assistant"
			}
		}
	],
	"created": 1701466583,
	"id": "chatcmpl-8R5TLK2ZDzOD6tysRCwCzT7f8Hb73",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 19:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ownedBonus; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _investorsAccounts; // STORAGE[0x1]\nuint256 _finalTimestampOfBonusPeriod; // STORAGE[0x2]\naddress owner_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress _fundariaTokenBuyAddress; // STORAGE[0x4] bytes 0 to 19\naddress _setFundariaTokenBuyAddress; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nAccountFilledWithBonus(address, uint256, int256);\nBonusWithdrawn(address, uint256);\n\nfunction ownedBonus(address varg0) public payable { \n    assert(!msg.value);\n    return _ownedBonus[varg0];\n}\n\nfunction setFinalTimestampOfBonusPeriod(uint256 varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        v0 = v1 = !_finalTimestampOfBonusPeriod;\n        if (_finalTimestampOfBonusPeriod) {\n            v0 = varg0 < _finalTimestampOfBonusPeriod;\n        }\n        if (v0) {\n            _finalTimestampOfBonusPeriod = varg0;\n            goto 0xca0x144;\n        }\n    }\n}\n\nfunction fillInvestorAccountWithBonus(address varg0) public payable { \n    assert(!msg.value);\n    if (_ownedBonus[msg.sender] > 0) {\n        v0 = v1 = ~0 == _investorsAccounts[varg0];\n        if (~0 != _investorsAccounts[varg0]) {\n            v0 = _investorsAccounts[varg0] > 0;\n        }\n        if (v0) {\n            _ownedBonus[msg.sender] = 0;\n            if (~0 == _investorsAccounts[varg0]) {\n                MEM[0] = varg0;\n                MEM[32] = 1;\n            }\n            _investorsAccounts[varg0] += _ownedBonus[msg.sender];\n            emit AccountFilledWithBonus(varg0, _ownedBonus[msg.sender], _ownedBonus[msg.sender] + _investorsAccounts[varg0]);\n            v2 = varg0.call().value(_ownedBonus[msg.sender]).gas(2300 * !_ownedBonus[msg.sender]);\n            assert(v2);\n        }\n    }\n}\n\nfunction investorsAccounts(address varg0) public payable { \n    assert(!msg.value);\n    return _investorsAccounts[varg0];\n}\n\nfunction finalTimestampOfBonusPeriod() public payable { \n    assert(!msg.value);\n    return _finalTimestampOfBonusPeriod;\n}\n\nfunction withdrawBonus() public payable { \n    assert(!msg.value);\n    if (_ownedBonus[msg.sender] > 0) {\n        if (block.timestamp > _finalTimestampOfBonusPeriod) {\n            _ownedBonus[msg.sender] = 0;\n            emit BonusWithdrawn(msg.sender, _ownedBonus[msg.sender]);\n            v0 = msg.sender.call().value(_ownedBonus[msg.sender]).gas(2300 * !_ownedBonus[msg.sender]);\n            assert(v0);\n        }\n    }\n}\n\nfunction setRegisteringContractAddress(address varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        owner_3_0_19 = varg0;\n        goto 0xca0x1d9;\n    }\n}\n\nfunction setOwnedBonus() public payable { \n    if (_fundariaTokenBuyAddress == msg.sender) {\n        _ownedBonus[address(tx.origin)] += msg.value;\n    }\n}\n\nfunction registerInvestorAccount(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _setFundariaTokenBuyAddress == msg.sender;\n    if (_setFundariaTokenBuyAddress != msg.sender) {\n        v0 = owner_3_0_19 == msg.sender;\n    }\n    if (v0) {\n        _investorsAccounts[varg0] = ~0;\n    }\n}\n\nfunction setFundariaTokenBuyAddress(address varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        _fundariaTokenBuyAddress = varg0;\n        goto 0xca0xcc;\n    }\n}\n\nfunction fundariaTokenBuyAddress() public payable { \n    assert(!msg.value);\n    return _fundariaTokenBuyAddress;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x812cfbf) {\n            registerInvestorAccount(address);\n        } else if (0x111b30a7 == function_selector) {\n            setFundariaTokenBuyAddress(address);\n        } else if (0x280a3382 == function_selector) {\n            fundariaTokenBuyAddress();\n        } else if (0x2d20fbf3 == function_selector) {\n            ownedBonus(address);\n        } else if (0x36199817 == function_selector) {\n            setFinalTimestampOfBonusPeriod(uint256);\n        } else if (0x3ad9248c == function_selector) {\n            fillInvestorAccountWithBonus(address);\n        } else if (0x3f4e95d7 == function_selector) {\n            investorsAccounts(address);\n        } else if (0x50c4ebc4 == function_selector) {\n            finalTimestampOfBonusPeriod();\n        } else if (0x66de84ec == function_selector) {\n            withdrawBonus();\n        } else if (0x68be948d == function_selector) {\n            setRegisteringContractAddress(address);\n        } else if (0x7db91595 == function_selector) {\n            setOwnedBonus();\n        }\n    }\n    throw();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 19:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ownedBonus; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _investorsAccounts; // STORAGE[0x1]\nuint256 _finalTimestampOfBonusPeriod; // STORAGE[0x2]\naddress owner_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress _fundariaTokenBuyAddress; // STORAGE[0x4] bytes 0 to 19\naddress _setFundariaTokenBuyAddress; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nAccountFilledWithBonus(address, uint256, int256);\nBonusWithdrawn(address, uint256);\n\nfunction ownedBonus(address varg0) public payable { \n    assert(!msg.value);\n    return _ownedBonus[varg0];\n}\n\nfunction setFinalTimestampOfBonusPeriod(uint256 varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        v0 = v1 = !_finalTimestampOfBonusPeriod;\n        if (_finalTimestampOfBonusPeriod) {\n            v0 = varg0 < _finalTimestampOfBonusPeriod;\n        }\n        if (v0) {\n            _finalTimestampOfBonusPeriod = varg0;\n            goto 0xca0x144;\n        }\n    }\n}\n\nfunction fillInvestorAccountWithBonus(address varg0) public payable { \n    assert(!msg.value);\n    if (_ownedBonus[msg.sender] > 0) {\n        v0 = v1 = ~0 == _investorsAccounts[varg0];\n        if (~0 != _investorsAccounts[varg0]) {\n            v0 = _investorsAccounts[varg0] > 0;\n        }\n        if (v0) {\n            _ownedBonus[msg.sender] = 0;\n            if (~0 == _investorsAccounts[varg0]) {\n                MEM[0] = varg0;\n                MEM[32] = 1;\n            }\n            _investorsAccounts[varg0] += _ownedBonus[msg.sender];\n            emit AccountFilledWithBonus(varg0, _ownedBonus[msg.sender], _ownedBonus[msg.sender] + _investorsAccounts[varg0]);\n            v2 = varg0.call().value(_ownedBonus[msg.sender]).gas(2300 * !_ownedBonus[msg.sender]);\n            assert(v2);\n        }\n    }\n}\n\nfunction investorsAccounts(address varg0) public payable { \n    assert(!msg.value);\n    return _investorsAccounts[varg0];\n}\n\nfunction finalTimestampOfBonusPeriod() public payable { \n    assert(!msg.value);\n    return _finalTimestampOfBonusPeriod;\n}\n\nfunction withdrawBonus() public payable { \n    assert(!msg.value);\n    if (_ownedBonus[msg.sender] > 0) {\n        if (block.timestamp > _finalTimestampOfBonusPeriod) {\n            _ownedBonus[msg.sender] = 0;\n            emit BonusWithdrawn(msg.sender, _ownedBonus[msg.sender]);\n            v0 = msg.sender.call().value(_ownedBonus[msg.sender]).gas(2300 * !_ownedBonus[msg.sender]);\n            assert(v0);\n        }\n    }\n}\n\nfunction setRegisteringContractAddress(address varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        owner_3_0_19 = varg0;\n        goto 0xca0x1d9;\n    }\n}\n\nfunction setOwnedBonus() public payable { \n    if (_fundariaTokenBuyAddress == msg.sender) {\n        _ownedBonus[address(tx.origin)] += msg.value;\n    }\n}\n\nfunction registerInvestorAccount(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _setFundariaTokenBuyAddress == msg.sender;\n    if (_setFundariaTokenBuyAddress != msg.sender) {\n        v0 = owner_3_0_19 == msg.sender;\n    }\n    if (v0) {\n        _investorsAccounts[varg0] = ~0;\n    }\n}\n\nfunction setFundariaTokenBuyAddress(address varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        _fundariaTokenBuyAddress = varg0;\n        goto 0xca0xcc;\n    }\n}\n\nfunction fundariaTokenBuyAddress() public payable { \n    assert(!msg.value);\n    return _fundariaTokenBuyAddress;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x812cfbf) {\n            registerInvestorAccount(address);\n        } else if (0x111b30a7 == function_selector) {\n            setFundariaTokenBuyAddress(address);\n        } else if (0x280a3382 == function_selector) {\n            fundariaTokenBuyAddress();\n        } else if (0x2d20fbf3 == function_selector) {\n            ownedBonus(address);\n        } else if (0x36199817 == function_selector) {\n            setFinalTimestampOfBonusPeriod(uint256);\n        } else if (0x3ad9248c == function_selector) {\n            fillInvestorAccountWithBonus(address);\n        } else if (0x3f4e95d7 == function_selector) {\n            investorsAccounts(address);\n        } else if (0x50c4ebc4 == function_selector) {\n            finalTimestampOfBonusPeriod();\n        } else if (0x66de84ec == function_selector) {\n            withdrawBonus();\n        } else if (0x68be948d == function_selector) {\n            setRegisteringContractAddress(address);\n        } else if (0x7db91595 == function_selector) {\n            setOwnedBonus();\n        }\n    }\n    throw();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 19:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ownedBonus; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _investorsAccounts; // STORAGE[0x1]\nuint256 _finalTimestampOfBonusPeriod; // STORAGE[0x2]\naddress owner_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress _fundariaTokenBuyAddress; // STORAGE[0x4] bytes 0 to 19\naddress _setFundariaTokenBuyAddress; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nAccountFilledWithBonus(address, uint256, int256);\nBonusWithdrawn(address, uint256);\n\nfunction ownedBonus(address varg0) public payable { \n    assert(!msg.value);\n    return _ownedBonus[varg0];\n}\n\nfunction setFinalTimestampOfBonusPeriod(uint256 varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        v0 = v1 = !_finalTimestampOfBonusPeriod;\n        if (_finalTimestampOfBonusPeriod) {\n            v0 = varg0 < _finalTimestampOfBonusPeriod;\n        }\n        if (v0) {\n            _finalTimestampOfBonusPeriod = varg0;\n            goto 0xca0x144;\n        }\n    }\n}\n\nfunction fillInvestorAccountWithBonus(address varg0) public payable { \n    assert(!msg.value);\n    if (_ownedBonus[msg.sender] > 0) {\n        v0 = v1 = ~0 == _investorsAccounts[varg0];\n        if (~0 != _investorsAccounts[varg0]) {\n            v0 = _investorsAccounts[varg0] > 0;\n        }\n        if (v0) {\n            _ownedBonus[msg.sender] = 0;\n            if (~0 == _investorsAccounts[varg0]) {\n                MEM[0] = varg0;\n                MEM[32] = 1;\n            }\n            _investorsAccounts[varg0] += _ownedBonus[msg.sender];\n            emit AccountFilledWithBonus(varg0, _ownedBonus[msg.sender], _ownedBonus[msg.sender] + _investorsAccounts[varg0]);\n            v2 = varg0.call().value(_ownedBonus[msg.sender]).gas(2300 * !_ownedBonus[msg.sender]);\n            assert(v2);\n        }\n    }\n}\n\nfunction investorsAccounts(address varg0) public payable { \n    assert(!msg.value);\n    return _investorsAccounts[varg0];\n}\n\nfunction finalTimestampOfBonusPeriod() public payable { \n    assert(!msg.value);\n    return _finalTimestampOfBonusPeriod;\n}\n\nfunction withdrawBonus() public payable { \n    assert(!msg.value);\n    if (_ownedBonus[msg.sender] > 0) {\n        if (block.timestamp > _finalTimestampOfBonusPeriod) {\n            _ownedBonus[msg.sender] = 0;\n            emit BonusWithdrawn(msg.sender, _ownedBonus[msg.sender]);\n            v0 = msg.sender.call().value(_ownedBonus[msg.sender]).gas(2300 * !_ownedBonus[msg.sender]);\n            assert(v0);\n        }\n    }\n}\n\nfunction setRegisteringContractAddress(address varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        owner_3_0_19 = varg0;\n        goto 0xca0x1d9;\n    }\n}\n\nfunction setOwnedBonus() public payable { \n    if (_fundariaTokenBuyAddress == msg.sender) {\n        _ownedBonus[address(tx.origin)] += msg.value;\n    }\n}\n\nfunction registerInvestorAccount(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _setFundariaTokenBuyAddress == msg.sender;\n    if (_setFundariaTokenBuyAddress != msg.sender) {\n        v0 = owner_3_0_19 == msg.sender;\n    }\n    if (v0) {\n        _investorsAccounts[varg0] = ~0;\n    }\n}\n\nfunction setFundariaTokenBuyAddress(address varg0) public payable { \n    assert(!msg.value);\n    if (_setFundariaTokenBuyAddress == msg.sender) {\n        _fundariaTokenBuyAddress = varg0;\n        goto 0xca0xcc;\n    }\n}\n\nfunction fundariaTokenBuyAddress() public payable { \n    assert(!msg.value);\n    return _fundariaTokenBuyAddress;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x812cfbf) {\n            registerInvestorAccount(address);\n        } else if (0x111b30a7 == function_selector) {\n            setFundariaTokenBuyAddress(address);\n        } else if (0x280a3382 == function_selector) {\n            fundariaTokenBuyAddress();\n        } else if (0x2d20fbf3 == function_selector) {\n            ownedBonus(address);\n        } else if (0x36199817 == function_selector) {\n            setFinalTimestampOfBonusPeriod(uint256);\n        } else if (0x3ad9248c == function_selector) {\n            fillInvestorAccountWithBonus(address);\n        } else if (0x3f4e95d7 == function_selector) {\n            investorsAccounts(address);\n        } else if (0x50c4ebc4 == function_selector) {\n            finalTimestampOfBonusPeriod();\n        } else if (0x66de84ec == function_selector) {\n            withdrawBonus();\n        } else if (0x68be948d == function_selector) {\n            setRegisteringContractAddress(address);\n        } else if (0x7db91595 == function_selector) {\n            setOwnedBonus();\n        }\n    }\n    throw();\n}\n.",
	"status": "1",
	"time_cost": 32.883861780166626,
	"usage": {
		"completion_tokens": 792,
		"prompt_tokens": 1358,
		"total_tokens": 2150
	}
}