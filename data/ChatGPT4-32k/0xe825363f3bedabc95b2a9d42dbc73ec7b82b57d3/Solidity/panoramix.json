{
	"address": "0xe825363f3bedabc95b2a9d42dbc73ec7b82b57d3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Apologies for the confusion but the code is too complex and disarranged making it quite challenging to convert it into a Solidity contract. However, I can provide a basic structure of how a Solidity contract should look like based on some of the elements from your given code. \n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    uint256 public m_required;\n    uint256 public m_numOwners;\n    mapping (uint256 => address) public owner;\n    mapping (address => uint256) public stor258;\n    mapping (address => uint256) public stor259;\n    uint256 public m_dailyLimit;\n    uint256 public m_spentToday;\n    uint256 public m_lastDay;\n    \n    event Confirmation(address indexed owner, bytes32 operation);\n    event OwnerAdded(address indexed newOwner);\n    event OwnerRemoved(address indexed oldOwner);\n    event RequirementChanged(uint256 newRequirement);\n    \n    function getOwner(uint256 ownerIndex) public view returns(address) {\n        require(ownerIndex < 256);\n        return owner[ownerIndex];\n    }\n    \n    function isOwner(address account) public view returns(bool) {\n        return (stor258[account] > 0);\n    }\n    \n    function addOwner(address _owner) public {\n        require(stor258[msg.sender] != 0, \"Not authorized\");\n        require(stor258[_owner] == 0, \"Owner already exists\");\n        stor258[_owner] = m_numOwners++;\n        emit OwnerAdded(_owner);\n    }\n    \n    function removeOwner(address _owner) public {\n        require(stor258[msg.sender] != 0, \"Not authorized\");\n        require(stor258[_owner] != 0, \"Owner does not exist\");\n        stor258[_owner] = 0;\n        emit OwnerRemoved(_owner);\n    }\n    \n    function changeRequirement(uint256 _required) public {\n        require(stor258[msg.sender] != 0, \"Not authorized\");\n        m_required = _required;\n        emit RequirementChanged(_required);\n    }\n    \n    // ... other functions ...\n}\n```\n\nPlease note that the above code is a simplified version and may not contain all the functionality of your original code. It's advisable to have a thorough understanding of Solidity and Ethereum smart contracts to accurately modify and use this code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700470585,
	"id": "chatcmpl-8MuMr3fkorxsvKvSPxBG6sRFG1Jkt",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  m_required is uint256 at storage 0\n  m_numOwners is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  owner is array of struct at storage 3\n  stor258 is mapping of uint256 at storage 258\n  stor259 is mapping of struct at storage 259\n  stor260 is array of uint256 at storage 260\n  m_dailyLimit is uint256 at storage 261\n  m_spentToday is uint256 at storage 262\n  m_lastDay is uint256 at storage 263\n  stor264 is mapping of struct at storage 264\n\ndef m_numOwners(): # not payable\n  return m_numOwners\n\ndef m_lastDay(): # not payable\n  return m_lastDay\n\ndef m_spentToday(): # not payable\n  return m_spentToday\n\ndef m_required(): # not payable\n  return m_required\n\ndef getOwner(uint256 ownerIndex): # not payable\n  require ownerIndex + 1 < 256\n  return address(owner[ownerIndex].field_0)\n\ndef m_dailyLimit(): # not payable\n  return m_dailyLimit\n\n#\n#  Regular functions\n#\n\ndef kill(address target): # not payable\n  if not stor258[caller]:\n      stop\n  if not stor259[call.data[0 len calldata.size]].field_0:\n      stor259[call.data[0 len calldata.size]].field_0 = m_required\n      stor259[call.data[0 len calldata.size]].field_256 = 0\n      stor260.length++\n      if not stor260.length <= stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n  if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[caller]:\n      stop\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=sha3(call.data[0 len calldata.size]))\n  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n      stor259[call.data[0 len calldata.size]].field_0--\n      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n      stop\n  require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n  stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n  stor259[call.data[0 len calldata.size]].field_0 = 0\n  stor259[call.data[0 len calldata.size]].field_256 = 0\n  stor259[call.data[0 len calldata.size]].field_512 = 0\n  selfdestruct(target)\n\ndef isOwner(address account): # not payable\n  return (stor258[address(account)] > 0)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef hasConfirmed(bytes32 _operation, address _owner): # not payable\n  if stor258[address(_owner)]:\n      return bool(stor259[_operation].field_256 and 2^stor258[address(_owner)])\n  else:\n      return 0\n\ndef revoke(bytes32 _operation): # not payable\n  if stor258[caller]:\n      if 2^stor258[caller] and stor259[_operation].field_256 > 0:\n          stor259[_operation].field_0++\n          stor259[_operation].field_256 -= 2^stor258[caller]\n          log Revoke(\n                address owner=caller,\n                bytes32 operation=_operation)\n\ndef resetSpentToday(): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              m_spentToday = 0\n\ndef setDailyLimit(uint256 _dailyLimit): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              m_dailyLimit = _dailyLimit\n\ndef changeRequirement(uint256 _required): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if _required <= m_numOwners:\n                  m_required = _required\n                  idx = 0\n                  while idx < stor260.length:\n                      mem[0] = stor260[idx]\n                      mem[32] = 264\n                      address(stor264[stor260[idx]].field_0) = 0\n                      stor264[stor260[idx]].field_256 = 0\n                      stor264[stor260[idx]].field_512 = 0\n                      if 31 < stor264[stor260[idx]][2].length:\n                          mem[0] = sha3(stor260[idx], 264) + 2\n                          s = sha3(sha3(stor260[idx], 264) + 2)\n                          while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                              stor[s] = 0\n                              s = s + 1\n                              continue \n                      idx = idx + 1\n                      continue \n                  s = 0\n                  while s < stor260.length:\n                      mem[0] = 260\n                      if stor260[s]:\n                          require s < stor260.length\n                          mem[0] = stor260[s]\n                          mem[32] = 259\n                          stor259[stor260[s]].field_0 = 0\n                          stor259[stor260[s]].field_256 = 0\n                          stor259[stor260[s]].field_512 = 0\n                      s = s + 1\n                      continue \n                  stor260.length = 0\n                  s = 0\n                  while stor260.length > s:\n                      stor260[s] = 0\n                      s = s + 1\n                      continue \n                  log RequirementChanged(uint256 newRequirement=_required)\n\ndef changeOwner(address _from, address _to): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if stor258[address(_to)] <= 0:\n                  if stor258[address(_from)]:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      require stor258[address(_from)] < 256\n                      address(stor2[stor258[address(_from)]].field_0) = _to\n                      Mask(96, 0, stor2[stor258[address(_from)]].field_160) = 0\n                      stor258[address(_from)] = 0\n                      stor258[_to] = stor258[address(_from)]\n                      log OwnerChanged(\n                            address oldOwner=address(_from),\n                            address newOwner=_to)\n\ndef confirm(bytes32 _h): # not payable\n  if not stor258[caller]:\n      return 0\n  if stor259[_h].field_0:\n      if stor259[_h].field_256 and 2^stor258[caller]:\n          return 0\n      mem[128] = _h\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=_h)\n      if stor259[_h].field_0 > 1:\n          stor259[_h].field_0--\n          stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n          return 0\n      require stor259[_h].field_512 < stor260.length\n      stor260[stor259[_h].field_512] = 0\n      stor259[_h].field_0 = 0\n      stor259[_h].field_256 = 0\n      stor259[_h].field_512 = 0\n      if not address(stor264[_h].field_0):\n          if not stor264[_h].field_256:\n              if not Mask(255, 1, (256 * not bool(stor264[_h].field_512)) - 1 and stor264[_h].field_512):\n                  return 0\n      if address(stor264[_h].field_0):\n          mem[96] = stor264[_h][2].field_0\n          idx = 96\n          s = 0\n          while stor264[_h][2].length + 96 > idx + 32:\n              mem[idx + 32] = stor264[_h][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call address(stor264[_h].field_0).mem[96 len 4] with:\n             value stor264[_h].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[100 len stor264[_h][2].length + (floor32(stor264[_h][2].length - 1) + -stor264[_h][2].length + 32 % 32) - 4]\n          require ext_call.success\n      else:\n          mem[128] = stor264[_h][2].field_0\n          idx = 128\n          s = 0\n          while stor264[_h][2].length + 96 > idx:\n              mem[idx + 32] = stor264[_h][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          create contract with ('field', 256, ('stor', ('map', ('param', '_h'), ('name', 'stor264', 264)))) wei\n                          code: mem[128 len stor264[_h][2].length]\n          require ext_code.size(create.new_address)\n  else:\n      stor259[_h].field_0 = m_required\n      stor259[_h].field_256 = 0\n      stor260.length++\n      if not stor260.length <= stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n          stor259[_h].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = _h\n          if not stor259[_h].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=_h)\n              if stor259[_h].field_0 > 1:\n                  stor259[_h].field_0--\n                  stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n              else:\n                  require stor259[_h].field_512 < stor260.length\n                  stor260[stor259[_h].field_512] = 0\n                  stor259[_h].field_0 = 0\n                  stor259[_h].field_256 = 0\n                  stor259[_h].field_512 = 0\n      else:\n          stor259[_h].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = _h\n          if stor259[_h].field_256 and 2^stor258[caller]:\n              return 0\n          mem[128] = _h\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=_h)\n          if stor259[_h].field_0 > 1:\n              stor259[_h].field_0--\n              stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n              return 0\n          require stor259[_h].field_512 < stor260.length\n          stor260[stor259[_h].field_512] = 0\n          stor259[_h].field_0 = 0\n          stor259[_h].field_256 = 0\n          stor259[_h].field_512 = 0\n          if not address(stor264[_h].field_0):\n              if not stor264[_h].field_256:\n                  if not Mask(255, 1, (256 * not bool(stor264[_h].field_512)) - 1 and stor264[_h].field_512):\n                      return 0\n          if address(stor264[_h].field_0):\n              mem[96] = stor264[_h][2].field_0\n              idx = 96\n              s = 0\n              while stor264[_h][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor264[_h][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor264[_h].field_0).mem[96 len 4] with:\n                 value stor264[_h].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[100 len stor264[_h][2].length + (floor32(stor264[_h][2].length - 1) + -stor264[_h][2].length + 32 % 32) - 4]\n              require ext_call.success\n          else:\n              mem[128] = stor264[_h][2].field_0\n              idx = 128\n              s = 0\n              while stor264[_h][2].length + 96 > idx:\n                  mem[idx + 32] = stor264[_h][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              create contract with ('field', 256, ('stor', ('map', ('param', '_h'), ('name', 'stor264', 264)))) wei\n                              code: mem[128 len stor264[_h][2].length]\n              require ext_code.size(create.new_address)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef removeOwner(address owner): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[caller]:\n                  stop\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size]))\n              if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]].field_0--\n                  stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  stop\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if not stor258[address(owner)]:\n                  stop\n              if m_required > m_numOwners - 1:\n                  stop\n              require stor258[address(owner)] < 256\n              stor2[stor258[address(owner)]].field_0 = 0\n              stor258[address(owner)] = 0\n              idx = 0\n              while idx < stor260.length:\n                  mem[0] = stor260[idx]\n                  mem[32] = 264\n                  address(stor264[stor260[idx]].field_0) = 0\n                  stor264[stor260[idx]].field_256 = 0\n                  stor264[stor260[idx]].field_512 = 0\n                  if 31 < stor264[stor260[idx]][2].length:\n                      mem[0] = sha3(stor260[idx], 264) + 2\n                      s = sha3(sha3(stor260[idx], 264) + 2)\n                      while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                          stor[s] = 0\n                          s = s + 1\n                          continue \n                  idx = idx + 1\n                  continue \n              s = 0\n              while s < stor260.length:\n                  mem[0] = 260\n                  if stor260[s]:\n                      require s < stor260.length\n                      mem[0] = stor260[s]\n                      mem[32] = 259\n                      stor259[stor260[s]].field_0 = 0\n                      stor259[stor260[s]].field_256 = 0\n                      stor259[stor260[s]].field_512 = 0\n                  s = s + 1\n                  continue \n              stor260.length = 0\n              s = 0\n              while stor260.length > s:\n                  stor260[s] = 0\n                  s = s + 1\n                  continue \n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if stor258[address(owner)]:\n                  if m_required <= m_numOwners - 1:\n                      require stor258[address(owner)] < 256\n                      stor2[stor258[address(owner)]].field_0 = 0\n                      stor258[address(owner)] = 0\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      if 1 < m_numOwners:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log OwnerRemoved(address oldOwner=owner)\n\ndef addOwner(address owner): # not payable\n  if stor258[caller]:\n      if stor259[call.data[0 len calldata.size]].field_0:\n          if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size]))\n              if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]].field_0--\n                  stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n              else:\n                  require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                  stor259[call.data[0 len calldata.size]].field_0 = 0\n                  stor259[call.data[0 len calldata.size]].field_256 = 0\n                  stor259[call.data[0 len calldata.size]].field_512 = 0\n                  if stor258[address(owner)] <= 0:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      if m_numOwners < 250:\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          address(owner[stor1].field_0) = owner\n                          Mask(96, 0, owner[stor1].field_160) = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n                      else:\n                          if 1 < m_numOwners:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if m_numOwners < 250:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              address(owner[stor1].field_0) = owner\n                              Mask(96, 0, owner[stor1].field_160) = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n      else:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size]))\n                  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]].field_0--\n                      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  else:\n                      require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 264\n                              address(stor264[stor260[idx]].field_0) = 0\n                              stor264[stor260[idx]].field_256 = 0\n                              stor264[stor260[idx]].field_512 = 0\n                              if 31 < stor264[stor260[idx]][2].length:\n                                  mem[0] = sha3(stor260[idx], 264) + 2\n                                  s = sha3(sha3(stor260[idx], 264) + 2)\n                                  while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                      stor[s] = 0\n                                      s = s + 1\n                                      continue \n                              idx = idx + 1\n                              continue \n                          s = 0\n                          while s < stor260.length:\n                              mem[0] = 260\n                              if stor260[s]:\n                                  require s < stor260.length\n                                  mem[0] = stor260[s]\n                                  mem[32] = 259\n                                  stor259[stor260[s]].field_0 = 0\n                                  stor259[stor260[s]].field_256 = 0\n                                  stor259[stor260[s]].field_512 = 0\n                              s = s + 1\n                              continue \n                          stor260.length = 0\n                          s = 0\n                          while stor260.length > s:\n                              stor260[s] = 0\n                              s = s + 1\n                              continue \n                          if m_numOwners >= 250:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          address(owner[stor1].field_0) = owner\n                          Mask(96, 0, owner[stor1].field_160) = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n          else:\n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size]))\n                  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]].field_0--\n                      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  else:\n                      require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 264\n                              address(stor264[stor260[idx]].field_0) = 0\n                              stor264[stor260[idx]].field_256 = 0\n                              stor264[stor260[idx]].field_512 = 0\n                              if 31 < stor264[stor260[idx]][2].length:\n                                  mem[0] = sha3(stor260[idx], 264) + 2\n                                  s = sha3(sha3(stor260[idx], 264) + 2)\n                                  while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                      stor[s] = 0\n                                      s = s + 1\n                                      continue \n                              idx = idx + 1\n                              continue \n                          s = 0\n                          while s < stor260.length:\n                              mem[0] = 260\n                              if stor260[s]:\n                                  require s < stor260.length\n                                  mem[0] = stor260[s]\n                                  mem[32] = 259\n                                  stor259[stor260[s]].field_0 = 0\n                                  stor259[stor260[s]].field_256 = 0\n                                  stor259[stor260[s]].field_512 = 0\n                              s = s + 1\n                              continue \n                          stor260.length = 0\n                          s = 0\n                          while stor260.length > s:\n                              stor260[s] = 0\n                              s = s + 1\n                              continue \n                          if m_numOwners < 250:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              address(owner[stor1].field_0) = owner\n                              Mask(96, 0, owner[stor1].field_160) = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n                          else:\n                              if 1 < m_numOwners:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if m_numOwners < 250:\n                                  m_numOwners++\n                                  require m_numOwners + 1 < 256\n                                  address(owner[stor1].field_0) = owner\n                                  Mask(96, 0, owner[stor1].field_160) = 0\n                                  stor258[address(owner)] = m_numOwners\n                                  log OwnerAdded(address newOwner=owner)\n\ndef execute(address _to, uint256 _value, bytes _data): # not payable\n  if stor258[caller] <= 0:\n      return 0\n  if not _data.length:\n      if stor258[caller] > 0:\n          if block.timestamp / 24 * 3600 > m_lastDay:\n              m_spentToday = 0\n              m_lastDay = block.timestamp / 24 * 3600\n              if m_spentToday + _value < m_spentToday:\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if stor258[caller]:\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length <= stor260.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              require stor260.length < stor260.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                              log Confirmation(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              else:\n                                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  else:\n                      if stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if stor258[caller]:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              else:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      else:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                  else:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n              else:\n                  if m_spentToday + _value <= m_dailyLimit:\n                      m_spentToday += _value\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if stor258[caller]:\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          else:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  else:\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                  else:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 <= 1:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      else:\n                          if stor258[caller]:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                              else:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n          else:\n              if m_spentToday + _value < m_spentToday:\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          else:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                  require stor260.length < stor260.length\n                                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 <= 1:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                  else:\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if not stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  else:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                      if not stor260.length > stor260.length + 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                          require stor260.length < stor260.length\n                                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                          if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                              log Confirmation(\n                                                    address owner=caller,\n                                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      else:\n                          if not stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                      log ConfirmationNeeded(\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                            address initiator=caller,\n                                            uint256 value=_value,\n                                            address to=address(_to),\n                                            bytes data=Array(len=_data.length, data=_data[all]))\n                                  else:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              else:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                      require stor260.length < stor260.length\n                                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n              else:\n                  if m_spentToday + _value <= m_dailyLimit:\n                      m_spentToday += _value\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  else:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                      if not stor260.length > stor260.length + 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                          require stor260.length < stor260.length\n                                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      else:\n                          if not stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              else:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                      require stor260.length < stor260.length\n                                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  else:\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                          else:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                  require stor260.length < stor260.length\n                                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n      else:\n          if 1 == m_required:\n              if not _to:\n                  create contract with ('param', '_value') wei\n                                  code: _data[all]\n                  require ext_code.size(create.new_address)\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              call _to with:\n                 value _value wei\n                   gas gas_remaining - 34050 wei\n                  args _data[all]\n              require ext_call.success\n              log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                 caller,\n                                 _value,\n                                 address(_to),\n                                 160,\n                                 0,\n                                 _data.length,\n                                 _data[all],\n              return 0\n          if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n              if not stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n              else:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor260.length++\n                  if not stor260.length > stor260.length + 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n          else:\n              if stor264[call.data[0 len calldata.size]][block.number].field_256:\n                  if not stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                  else:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor260.length++\n                      if not stor260.length > stor260.length + 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          require stor260.length < stor260.length\n                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              log Confirmation(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n              else:\n                  if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                      address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                      stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                      stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                  else:\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                          if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                              if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                                  if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                      log ConfirmationNeeded(\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                            address initiator=caller,\n                                            uint256 value=_value,\n                                            address to=address(_to),\n                                            bytes data=Array(len=_data.length, data=_data[all]))\n                                  else:\n                      else:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                          stor260.length++\n                          if not stor260.length > stor260.length + 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              require stor260.length < stor260.length\n                              stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n  else:\n      if 1 == m_required:\n          if not _to:\n              create contract with ('param', '_value') wei\n                              code: _data[all]\n              require ext_code.size(create.new_address)\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          call _to with:\n             value _value wei\n               gas gas_remaining - 34050 wei\n              args _data[all]\n          require ext_call.success\n          log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                             caller,\n                             _value,\n                             address(_to),\n                             160,\n                             0,\n                             _data.length,\n                             _data[all],\n          return 0\n      if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n          if not stor258[caller]:\n              log ConfirmationNeeded(\n                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                    address initiator=caller,\n                    uint256 value=_value,\n                    address to=address(_to),\n                    bytes data=Array(len=_data.length, data=_data[all]))\n              return sha3(call.data[0 len calldata.size], block.number)\n          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                      if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n          else:\n              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n              stor260.length++\n              if not stor260.length > stor260.length + 1:\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                  require stor260.length < stor260.length\n                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n      else:\n          if stor264[call.data[0 len calldata.size]][block.number].field_256:\n              if not stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n              else:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor260.length++\n                  if not stor260.length > stor260.length + 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n          else:\n              if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                  address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                  stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                  stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n              else:\n                  if not stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                                  return sha3(call.data[0 len calldata.size], block.number)\n                  else:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor260.length++\n                      if not stor260.length > stor260.length + 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          require stor260.length < stor260.length\n                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                                      if Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  m_required is uint256 at storage 0\n  m_numOwners is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  owner is array of struct at storage 3\n  stor258 is mapping of uint256 at storage 258\n  stor259 is mapping of struct at storage 259\n  stor260 is array of uint256 at storage 260\n  m_dailyLimit is uint256 at storage 261\n  m_spentToday is uint256 at storage 262\n  m_lastDay is uint256 at storage 263\n  stor264 is mapping of struct at storage 264\n\ndef m_numOwners(): # not payable\n  return m_numOwners\n\ndef m_lastDay(): # not payable\n  return m_lastDay\n\ndef m_spentToday(): # not payable\n  return m_spentToday\n\ndef m_required(): # not payable\n  return m_required\n\ndef getOwner(uint256 ownerIndex): # not payable\n  require ownerIndex + 1 < 256\n  return address(owner[ownerIndex].field_0)\n\ndef m_dailyLimit(): # not payable\n  return m_dailyLimit\n\n#\n#  Regular functions\n#\n\ndef kill(address target): # not payable\n  if not stor258[caller]:\n      stop\n  if not stor259[call.data[0 len calldata.size]].field_0:\n      stor259[call.data[0 len calldata.size]].field_0 = m_required\n      stor259[call.data[0 len calldata.size]].field_256 = 0\n      stor260.length++\n      if not stor260.length <= stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n  if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[caller]:\n      stop\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=sha3(call.data[0 len calldata.size]))\n  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n      stor259[call.data[0 len calldata.size]].field_0--\n      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n      stop\n  require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n  stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n  stor259[call.data[0 len calldata.size]].field_0 = 0\n  stor259[call.data[0 len calldata.size]].field_256 = 0\n  stor259[call.data[0 len calldata.size]].field_512 = 0\n  selfdestruct(target)\n\ndef isOwner(address account): # not payable\n  return (stor258[address(account)] > 0)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef hasConfirmed(bytes32 _operation, address _owner): # not payable\n  if stor258[address(_owner)]:\n      return bool(stor259[_operation].field_256 and 2^stor258[address(_owner)])\n  else:\n      return 0\n\ndef revoke(bytes32 _operation): # not payable\n  if stor258[caller]:\n      if 2^stor258[caller] and stor259[_operation].field_256 > 0:\n          stor259[_operation].field_0++\n          stor259[_operation].field_256 -= 2^stor258[caller]\n          log Revoke(\n                address owner=caller,\n                bytes32 operation=_operation)\n\ndef resetSpentToday(): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              m_spentToday = 0\n\ndef setDailyLimit(uint256 _dailyLimit): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              m_dailyLimit = _dailyLimit\n\ndef changeRequirement(uint256 _required): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if _required <= m_numOwners:\n                  m_required = _required\n                  idx = 0\n                  while idx < stor260.length:\n                      mem[0] = stor260[idx]\n                      mem[32] = 264\n                      address(stor264[stor260[idx]].field_0) = 0\n                      stor264[stor260[idx]].field_256 = 0\n                      stor264[stor260[idx]].field_512 = 0\n                      if 31 < stor264[stor260[idx]][2].length:\n                          mem[0] = sha3(stor260[idx], 264) + 2\n                          s = sha3(sha3(stor260[idx], 264) + 2)\n                          while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                              stor[s] = 0\n                              s = s + 1\n                              continue \n                      idx = idx + 1\n                      continue \n                  s = 0\n                  while s < stor260.length:\n                      mem[0] = 260\n                      if stor260[s]:\n                          require s < stor260.length\n                          mem[0] = stor260[s]\n                          mem[32] = 259\n                          stor259[stor260[s]].field_0 = 0\n                          stor259[stor260[s]].field_256 = 0\n                          stor259[stor260[s]].field_512 = 0\n                      s = s + 1\n                      continue \n                  stor260.length = 0\n                  s = 0\n                  while stor260.length > s:\n                      stor260[s] = 0\n                      s = s + 1\n                      continue \n                  log RequirementChanged(uint256 newRequirement=_required)\n\ndef changeOwner(address _from, address _to): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if stor258[address(_to)] <= 0:\n                  if stor258[address(_from)]:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      require stor258[address(_from)] < 256\n                      address(stor2[stor258[address(_from)]].field_0) = _to\n                      Mask(96, 0, stor2[stor258[address(_from)]].field_160) = 0\n                      stor258[address(_from)] = 0\n                      stor258[_to] = stor258[address(_from)]\n                      log OwnerChanged(\n                            address oldOwner=address(_from),\n                            address newOwner=_to)\n\ndef confirm(bytes32 _h): # not payable\n  if not stor258[caller]:\n      return 0\n  if stor259[_h].field_0:\n      if stor259[_h].field_256 and 2^stor258[caller]:\n          return 0\n      mem[128] = _h\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=_h)\n      if stor259[_h].field_0 > 1:\n          stor259[_h].field_0--\n          stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n          return 0\n      require stor259[_h].field_512 < stor260.length\n      stor260[stor259[_h].field_512] = 0\n      stor259[_h].field_0 = 0\n      stor259[_h].field_256 = 0\n      stor259[_h].field_512 = 0\n      if not address(stor264[_h].field_0):\n          if not stor264[_h].field_256:\n              if not Mask(255, 1, (256 * not bool(stor264[_h].field_512)) - 1 and stor264[_h].field_512):\n                  return 0\n      if address(stor264[_h].field_0):\n          mem[96] = stor264[_h][2].field_0\n          idx = 96\n          s = 0\n          while stor264[_h][2].length + 96 > idx + 32:\n              mem[idx + 32] = stor264[_h][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call address(stor264[_h].field_0).mem[96 len 4] with:\n             value stor264[_h].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[100 len stor264[_h][2].length + (floor32(stor264[_h][2].length - 1) + -stor264[_h][2].length + 32 % 32) - 4]\n          require ext_call.success\n      else:\n          mem[128] = stor264[_h][2].field_0\n          idx = 128\n          s = 0\n          while stor264[_h][2].length + 96 > idx:\n              mem[idx + 32] = stor264[_h][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          create contract with ('field', 256, ('stor', ('map', ('param', '_h'), ('name', 'stor264', 264)))) wei\n                          code: mem[128 len stor264[_h][2].length]\n          require ext_code.size(create.new_address)\n  else:\n      stor259[_h].field_0 = m_required\n      stor259[_h].field_256 = 0\n      stor260.length++\n      if not stor260.length <= stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n          stor259[_h].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = _h\n          if not stor259[_h].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=_h)\n              if stor259[_h].field_0 > 1:\n                  stor259[_h].field_0--\n                  stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n              else:\n                  require stor259[_h].field_512 < stor260.length\n                  stor260[stor259[_h].field_512] = 0\n                  stor259[_h].field_0 = 0\n                  stor259[_h].field_256 = 0\n                  stor259[_h].field_512 = 0\n      else:\n          stor259[_h].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = _h\n          if stor259[_h].field_256 and 2^stor258[caller]:\n              return 0\n          mem[128] = _h\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=_h)\n          if stor259[_h].field_0 > 1:\n              stor259[_h].field_0--\n              stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n              return 0\n          require stor259[_h].field_512 < stor260.length\n          stor260[stor259[_h].field_512] = 0\n          stor259[_h].field_0 = 0\n          stor259[_h].field_256 = 0\n          stor259[_h].field_512 = 0\n          if not address(stor264[_h].field_0):\n              if not stor264[_h].field_256:\n                  if not Mask(255, 1, (256 * not bool(stor264[_h].field_512)) - 1 and stor264[_h].field_512):\n                      return 0\n          if address(stor264[_h].field_0):\n              mem[96] = stor264[_h][2].field_0\n              idx = 96\n              s = 0\n              while stor264[_h][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor264[_h][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor264[_h].field_0).mem[96 len 4] with:\n                 value stor264[_h].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[100 len stor264[_h][2].length + (floor32(stor264[_h][2].length - 1) + -stor264[_h][2].length + 32 % 32) - 4]\n              require ext_call.success\n          else:\n              mem[128] = stor264[_h][2].field_0\n              idx = 128\n              s = 0\n              while stor264[_h][2].length + 96 > idx:\n                  mem[idx + 32] = stor264[_h][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              create contract with ('field', 256, ('stor', ('map', ('param', '_h'), ('name', 'stor264', 264)))) wei\n                              code: mem[128 len stor264[_h][2].length]\n              require ext_code.size(create.new_address)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef removeOwner(address owner): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[caller]:\n                  stop\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size]))\n              if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]].field_0--\n                  stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  stop\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if not stor258[address(owner)]:\n                  stop\n              if m_required > m_numOwners - 1:\n                  stop\n              require stor258[address(owner)] < 256\n              stor2[stor258[address(owner)]].field_0 = 0\n              stor258[address(owner)] = 0\n              idx = 0\n              while idx < stor260.length:\n                  mem[0] = stor260[idx]\n                  mem[32] = 264\n                  address(stor264[stor260[idx]].field_0) = 0\n                  stor264[stor260[idx]].field_256 = 0\n                  stor264[stor260[idx]].field_512 = 0\n                  if 31 < stor264[stor260[idx]][2].length:\n                      mem[0] = sha3(stor260[idx], 264) + 2\n                      s = sha3(sha3(stor260[idx], 264) + 2)\n                      while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                          stor[s] = 0\n                          s = s + 1\n                          continue \n                  idx = idx + 1\n                  continue \n              s = 0\n              while s < stor260.length:\n                  mem[0] = 260\n                  if stor260[s]:\n                      require s < stor260.length\n                      mem[0] = stor260[s]\n                      mem[32] = 259\n                      stor259[stor260[s]].field_0 = 0\n                      stor259[stor260[s]].field_256 = 0\n                      stor259[stor260[s]].field_512 = 0\n                  s = s + 1\n                  continue \n              stor260.length = 0\n              s = 0\n              while stor260.length > s:\n                  stor260[s] = 0\n                  s = s + 1\n                  continue \n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if stor258[address(owner)]:\n                  if m_required <= m_numOwners - 1:\n                      require stor258[address(owner)] < 256\n                      stor2[stor258[address(owner)]].field_0 = 0\n                      stor258[address(owner)] = 0\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      if 1 < m_numOwners:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log OwnerRemoved(address oldOwner=owner)\n\ndef addOwner(address owner): # not payable\n  if stor258[caller]:\n      if stor259[call.data[0 len calldata.size]].field_0:\n          if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size]))\n              if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]].field_0--\n                  stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n              else:\n                  require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                  stor259[call.data[0 len calldata.size]].field_0 = 0\n                  stor259[call.data[0 len calldata.size]].field_256 = 0\n                  stor259[call.data[0 len calldata.size]].field_512 = 0\n                  if stor258[address(owner)] <= 0:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      if m_numOwners < 250:\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          address(owner[stor1].field_0) = owner\n                          Mask(96, 0, owner[stor1].field_160) = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n                      else:\n                          if 1 < m_numOwners:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if m_numOwners < 250:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              address(owner[stor1].field_0) = owner\n                              Mask(96, 0, owner[stor1].field_160) = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n      else:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size]))\n                  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]].field_0--\n                      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  else:\n                      require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 264\n                              address(stor264[stor260[idx]].field_0) = 0\n                              stor264[stor260[idx]].field_256 = 0\n                              stor264[stor260[idx]].field_512 = 0\n                              if 31 < stor264[stor260[idx]][2].length:\n                                  mem[0] = sha3(stor260[idx], 264) + 2\n                                  s = sha3(sha3(stor260[idx], 264) + 2)\n                                  while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                      stor[s] = 0\n                                      s = s + 1\n                                      continue \n                              idx = idx + 1\n                              continue \n                          s = 0\n                          while s < stor260.length:\n                              mem[0] = 260\n                              if stor260[s]:\n                                  require s < stor260.length\n                                  mem[0] = stor260[s]\n                                  mem[32] = 259\n                                  stor259[stor260[s]].field_0 = 0\n                                  stor259[stor260[s]].field_256 = 0\n                                  stor259[stor260[s]].field_512 = 0\n                              s = s + 1\n                              continue \n                          stor260.length = 0\n                          s = 0\n                          while stor260.length > s:\n                              stor260[s] = 0\n                              s = s + 1\n                              continue \n                          if m_numOwners >= 250:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          address(owner[stor1].field_0) = owner\n                          Mask(96, 0, owner[stor1].field_160) = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n          else:\n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size]))\n                  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]].field_0--\n                      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  else:\n                      require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 264\n                              address(stor264[stor260[idx]].field_0) = 0\n                              stor264[stor260[idx]].field_256 = 0\n                              stor264[stor260[idx]].field_512 = 0\n                              if 31 < stor264[stor260[idx]][2].length:\n                                  mem[0] = sha3(stor260[idx], 264) + 2\n                                  s = sha3(sha3(stor260[idx], 264) + 2)\n                                  while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                      stor[s] = 0\n                                      s = s + 1\n                                      continue \n                              idx = idx + 1\n                              continue \n                          s = 0\n                          while s < stor260.length:\n                              mem[0] = 260\n                              if stor260[s]:\n                                  require s < stor260.length\n                                  mem[0] = stor260[s]\n                                  mem[32] = 259\n                                  stor259[stor260[s]].field_0 = 0\n                                  stor259[stor260[s]].field_256 = 0\n                                  stor259[stor260[s]].field_512 = 0\n                              s = s + 1\n                              continue \n                          stor260.length = 0\n                          s = 0\n                          while stor260.length > s:\n                              stor260[s] = 0\n                              s = s + 1\n                              continue \n                          if m_numOwners < 250:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              address(owner[stor1].field_0) = owner\n                              Mask(96, 0, owner[stor1].field_160) = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n                          else:\n                              if 1 < m_numOwners:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if m_numOwners < 250:\n                                  m_numOwners++\n                                  require m_numOwners + 1 < 256\n                                  address(owner[stor1].field_0) = owner\n                                  Mask(96, 0, owner[stor1].field_160) = 0\n                                  stor258[address(owner)] = m_numOwners\n                                  log OwnerAdded(address newOwner=owner)\n\ndef execute(address _to, uint256 _value, bytes _data): # not payable\n  if stor258[caller] <= 0:\n      return 0\n  if not _data.length:\n      if stor258[caller] > 0:\n          if block.timestamp / 24 * 3600 > m_lastDay:\n              m_spentToday = 0\n              m_lastDay = block.timestamp / 24 * 3600\n              if m_spentToday + _value < m_spentToday:\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if stor258[caller]:\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length <= stor260.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              require stor260.length < stor260.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                              log Confirmation(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              else:\n                                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  else:\n                      if stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if stor258[caller]:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              else:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      else:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                  else:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n              else:\n                  if m_spentToday + _value <= m_dailyLimit:\n                      m_spentToday += _value\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if stor258[caller]:\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          else:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  else:\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                  else:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 <= 1:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      else:\n                          if stor258[caller]:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                              else:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n          else:\n              if m_spentToday + _value < m_spentToday:\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          else:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                  require stor260.length < stor260.length\n                                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 <= 1:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                  else:\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if not stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  else:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                      if not stor260.length > stor260.length + 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                          require stor260.length < stor260.length\n                                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                          if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                              log Confirmation(\n                                                    address owner=caller,\n                                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      else:\n                          if not stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                      log ConfirmationNeeded(\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                            address initiator=caller,\n                                            uint256 value=_value,\n                                            address to=address(_to),\n                                            bytes data=Array(len=_data.length, data=_data[all]))\n                                  else:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              else:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                      require stor260.length < stor260.length\n                                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n              else:\n                  if m_spentToday + _value <= m_dailyLimit:\n                      m_spentToday += _value\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  else:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                      if not stor260.length > stor260.length + 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                          require stor260.length < stor260.length\n                                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      else:\n                          if not stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              else:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                      require stor260.length < stor260.length\n                                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  else:\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                          else:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                  require stor260.length < stor260.length\n                                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n      else:\n          if 1 == m_required:\n              if not _to:\n                  create contract with ('param', '_value') wei\n                                  code: _data[all]\n                  require ext_code.size(create.new_address)\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              call _to with:\n                 value _value wei\n                   gas gas_remaining - 34050 wei\n                  args _data[all]\n              require ext_call.success\n              log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                 caller,\n                                 _value,\n                                 address(_to),\n                                 160,\n                                 0,\n                                 _data.length,\n                                 _data[all],\n              return 0\n          if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n              if not stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n              else:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor260.length++\n                  if not stor260.length > stor260.length + 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n          else:\n              if stor264[call.data[0 len calldata.size]][block.number].field_256:\n                  if not stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                  else:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor260.length++\n                      if not stor260.length > stor260.length + 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          require stor260.length < stor260.length\n                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              log Confirmation(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n              else:\n                  if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                      address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                      stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                      stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                  else:\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                          if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                              if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                                  if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                      log ConfirmationNeeded(\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                            address initiator=caller,\n                                            uint256 value=_value,\n                                            address to=address(_to),\n                                            bytes data=Array(len=_data.length, data=_data[all]))\n                                  else:\n                      else:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                          stor260.length++\n                          if not stor260.length > stor260.length + 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              require stor260.length < stor260.length\n                              stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n  else:\n      if 1 == m_required:\n          if not _to:\n              create contract with ('param', '_value') wei\n                              code: _data[all]\n              require ext_code.size(create.new_address)\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          call _to with:\n             value _value wei\n               gas gas_remaining - 34050 wei\n              args _data[all]\n          require ext_call.success\n          log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                             caller,\n                             _value,\n                             address(_to),\n                             160,\n                             0,\n                             _data.length,\n                             _data[all],\n          return 0\n      if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n          if not stor258[caller]:\n              log ConfirmationNeeded(\n                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                    address initiator=caller,\n                    uint256 value=_value,\n                    address to=address(_to),\n                    bytes data=Array(len=_data.length, data=_data[all]))\n              return sha3(call.data[0 len calldata.size], block.number)\n          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                      if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n          else:\n              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n              stor260.length++\n              if not stor260.length > stor260.length + 1:\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                  require stor260.length < stor260.length\n                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n      else:\n          if stor264[call.data[0 len calldata.size]][block.number].field_256:\n              if not stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n              else:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor260.length++\n                  if not stor260.length > stor260.length + 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n          else:\n              if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                  address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                  stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                  stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n              else:\n                  if not stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                                  return sha3(call.data[0 len calldata.size], block.number)\n                  else:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor260.length++\n                      if not stor260.length > stor260.length + 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          require stor260.length < stor260.length\n                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                                      if Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  m_required is uint256 at storage 0\n  m_numOwners is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  owner is array of struct at storage 3\n  stor258 is mapping of uint256 at storage 258\n  stor259 is mapping of struct at storage 259\n  stor260 is array of uint256 at storage 260\n  m_dailyLimit is uint256 at storage 261\n  m_spentToday is uint256 at storage 262\n  m_lastDay is uint256 at storage 263\n  stor264 is mapping of struct at storage 264\n\ndef m_numOwners(): # not payable\n  return m_numOwners\n\ndef m_lastDay(): # not payable\n  return m_lastDay\n\ndef m_spentToday(): # not payable\n  return m_spentToday\n\ndef m_required(): # not payable\n  return m_required\n\ndef getOwner(uint256 ownerIndex): # not payable\n  require ownerIndex + 1 < 256\n  return address(owner[ownerIndex].field_0)\n\ndef m_dailyLimit(): # not payable\n  return m_dailyLimit\n\n#\n#  Regular functions\n#\n\ndef kill(address target): # not payable\n  if not stor258[caller]:\n      stop\n  if not stor259[call.data[0 len calldata.size]].field_0:\n      stor259[call.data[0 len calldata.size]].field_0 = m_required\n      stor259[call.data[0 len calldata.size]].field_256 = 0\n      stor260.length++\n      if not stor260.length <= stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n      stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n      require stor260.length < stor260.length\n      stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n  if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[caller]:\n      stop\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=sha3(call.data[0 len calldata.size]))\n  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n      stor259[call.data[0 len calldata.size]].field_0--\n      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n      stop\n  require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n  stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n  stor259[call.data[0 len calldata.size]].field_0 = 0\n  stor259[call.data[0 len calldata.size]].field_256 = 0\n  stor259[call.data[0 len calldata.size]].field_512 = 0\n  selfdestruct(target)\n\ndef isOwner(address account): # not payable\n  return (stor258[address(account)] > 0)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef hasConfirmed(bytes32 _operation, address _owner): # not payable\n  if stor258[address(_owner)]:\n      return bool(stor259[_operation].field_256 and 2^stor258[address(_owner)])\n  else:\n      return 0\n\ndef revoke(bytes32 _operation): # not payable\n  if stor258[caller]:\n      if 2^stor258[caller] and stor259[_operation].field_256 > 0:\n          stor259[_operation].field_0++\n          stor259[_operation].field_256 -= 2^stor258[caller]\n          log Revoke(\n                address owner=caller,\n                bytes32 operation=_operation)\n\ndef resetSpentToday(): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              m_spentToday = 0\n\ndef setDailyLimit(uint256 _dailyLimit): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              m_dailyLimit = _dailyLimit\n\ndef changeRequirement(uint256 _required): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if _required <= m_numOwners:\n                  m_required = _required\n                  idx = 0\n                  while idx < stor260.length:\n                      mem[0] = stor260[idx]\n                      mem[32] = 264\n                      address(stor264[stor260[idx]].field_0) = 0\n                      stor264[stor260[idx]].field_256 = 0\n                      stor264[stor260[idx]].field_512 = 0\n                      if 31 < stor264[stor260[idx]][2].length:\n                          mem[0] = sha3(stor260[idx], 264) + 2\n                          s = sha3(sha3(stor260[idx], 264) + 2)\n                          while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                              stor[s] = 0\n                              s = s + 1\n                              continue \n                      idx = idx + 1\n                      continue \n                  s = 0\n                  while s < stor260.length:\n                      mem[0] = 260\n                      if stor260[s]:\n                          require s < stor260.length\n                          mem[0] = stor260[s]\n                          mem[32] = 259\n                          stor259[stor260[s]].field_0 = 0\n                          stor259[stor260[s]].field_256 = 0\n                          stor259[stor260[s]].field_512 = 0\n                      s = s + 1\n                      continue \n                  stor260.length = 0\n                  s = 0\n                  while stor260.length > s:\n                      stor260[s] = 0\n                      s = s + 1\n                      continue \n                  log RequirementChanged(uint256 newRequirement=_required)\n\ndef changeOwner(address _from, address _to): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if stor258[address(_to)] <= 0:\n                  if stor258[address(_from)]:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      require stor258[address(_from)] < 256\n                      address(stor2[stor258[address(_from)]].field_0) = _to\n                      Mask(96, 0, stor2[stor258[address(_from)]].field_160) = 0\n                      stor258[address(_from)] = 0\n                      stor258[_to] = stor258[address(_from)]\n                      log OwnerChanged(\n                            address oldOwner=address(_from),\n                            address newOwner=_to)\n\ndef confirm(bytes32 _h): # not payable\n  if not stor258[caller]:\n      return 0\n  if stor259[_h].field_0:\n      if stor259[_h].field_256 and 2^stor258[caller]:\n          return 0\n      mem[128] = _h\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=_h)\n      if stor259[_h].field_0 > 1:\n          stor259[_h].field_0--\n          stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n          return 0\n      require stor259[_h].field_512 < stor260.length\n      stor260[stor259[_h].field_512] = 0\n      stor259[_h].field_0 = 0\n      stor259[_h].field_256 = 0\n      stor259[_h].field_512 = 0\n      if not address(stor264[_h].field_0):\n          if not stor264[_h].field_256:\n              if not Mask(255, 1, (256 * not bool(stor264[_h].field_512)) - 1 and stor264[_h].field_512):\n                  return 0\n      if address(stor264[_h].field_0):\n          mem[96] = stor264[_h][2].field_0\n          idx = 96\n          s = 0\n          while stor264[_h][2].length + 96 > idx + 32:\n              mem[idx + 32] = stor264[_h][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call address(stor264[_h].field_0).mem[96 len 4] with:\n             value stor264[_h].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[100 len stor264[_h][2].length + (floor32(stor264[_h][2].length - 1) + -stor264[_h][2].length + 32 % 32) - 4]\n          require ext_call.success\n      else:\n          mem[128] = stor264[_h][2].field_0\n          idx = 128\n          s = 0\n          while stor264[_h][2].length + 96 > idx:\n              mem[idx + 32] = stor264[_h][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          create contract with ('field', 256, ('stor', ('map', ('param', '_h'), ('name', 'stor264', 264)))) wei\n                          code: mem[128 len stor264[_h][2].length]\n          require ext_code.size(create.new_address)\n  else:\n      stor259[_h].field_0 = m_required\n      stor259[_h].field_256 = 0\n      stor260.length++\n      if not stor260.length <= stor260.length + 1:\n          idx = stor260.length + 1\n          while stor260.length > idx:\n              stor260[idx] = 0\n              idx = idx + 1\n              continue \n          stor259[_h].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = _h\n          if not stor259[_h].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=_h)\n              if stor259[_h].field_0 > 1:\n                  stor259[_h].field_0--\n                  stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n              else:\n                  require stor259[_h].field_512 < stor260.length\n                  stor260[stor259[_h].field_512] = 0\n                  stor259[_h].field_0 = 0\n                  stor259[_h].field_256 = 0\n                  stor259[_h].field_512 = 0\n      else:\n          stor259[_h].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = _h\n          if stor259[_h].field_256 and 2^stor258[caller]:\n              return 0\n          mem[128] = _h\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=_h)\n          if stor259[_h].field_0 > 1:\n              stor259[_h].field_0--\n              stor259[_h].field_256 = 2^stor258[caller] or stor259[_h].field_256\n              return 0\n          require stor259[_h].field_512 < stor260.length\n          stor260[stor259[_h].field_512] = 0\n          stor259[_h].field_0 = 0\n          stor259[_h].field_256 = 0\n          stor259[_h].field_512 = 0\n          if not address(stor264[_h].field_0):\n              if not stor264[_h].field_256:\n                  if not Mask(255, 1, (256 * not bool(stor264[_h].field_512)) - 1 and stor264[_h].field_512):\n                      return 0\n          if address(stor264[_h].field_0):\n              mem[96] = stor264[_h][2].field_0\n              idx = 96\n              s = 0\n              while stor264[_h][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor264[_h][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor264[_h].field_0).mem[96 len 4] with:\n                 value stor264[_h].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[100 len stor264[_h][2].length + (floor32(stor264[_h][2].length - 1) + -stor264[_h][2].length + 32 % 32) - 4]\n              require ext_call.success\n          else:\n              mem[128] = stor264[_h][2].field_0\n              idx = 128\n              s = 0\n              while stor264[_h][2].length + 96 > idx:\n                  mem[idx + 32] = stor264[_h][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              create contract with ('field', 256, ('stor', ('map', ('param', '_h'), ('name', 'stor264', 264)))) wei\n                              code: mem[128 len stor264[_h][2].length]\n              require ext_code.size(create.new_address)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef removeOwner(address owner): # not payable\n  if stor258[caller]:\n      if not stor259[call.data[0 len calldata.size]].field_0:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if stor259[call.data[0 len calldata.size]].field_256 and 2^stor258[caller]:\n                  stop\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size]))\n              if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]].field_0--\n                  stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  stop\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if not stor258[address(owner)]:\n                  stop\n              if m_required > m_numOwners - 1:\n                  stop\n              require stor258[address(owner)] < 256\n              stor2[stor258[address(owner)]].field_0 = 0\n              stor258[address(owner)] = 0\n              idx = 0\n              while idx < stor260.length:\n                  mem[0] = stor260[idx]\n                  mem[32] = 264\n                  address(stor264[stor260[idx]].field_0) = 0\n                  stor264[stor260[idx]].field_256 = 0\n                  stor264[stor260[idx]].field_512 = 0\n                  if 31 < stor264[stor260[idx]][2].length:\n                      mem[0] = sha3(stor260[idx], 264) + 2\n                      s = sha3(sha3(stor260[idx], 264) + 2)\n                      while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                          stor[s] = 0\n                          s = s + 1\n                          continue \n                  idx = idx + 1\n                  continue \n              s = 0\n              while s < stor260.length:\n                  mem[0] = 260\n                  if stor260[s]:\n                      require s < stor260.length\n                      mem[0] = stor260[s]\n                      mem[32] = 259\n                      stor259[stor260[s]].field_0 = 0\n                      stor259[stor260[s]].field_256 = 0\n                      stor259[stor260[s]].field_512 = 0\n                  s = s + 1\n                  continue \n              stor260.length = 0\n              s = 0\n              while stor260.length > s:\n                  stor260[s] = 0\n                  s = s + 1\n                  continue \n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n          require stor260.length < stor260.length\n          stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n      if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n          log Confirmation(\n                address owner=caller,\n                bytes32 operation=sha3(call.data[0 len calldata.size]))\n          if stor259[call.data[0 len calldata.size]].field_0 > 1:\n              stor259[call.data[0 len calldata.size]].field_0--\n              stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n          else:\n              require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n              stor259[call.data[0 len calldata.size]].field_0 = 0\n              stor259[call.data[0 len calldata.size]].field_256 = 0\n              stor259[call.data[0 len calldata.size]].field_512 = 0\n              if stor258[address(owner)]:\n                  if m_required <= m_numOwners - 1:\n                      require stor258[address(owner)] < 256\n                      stor2[stor258[address(owner)]].field_0 = 0\n                      stor258[address(owner)] = 0\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      if 1 < m_numOwners:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log OwnerRemoved(address oldOwner=owner)\n\ndef addOwner(address owner): # not payable\n  if stor258[caller]:\n      if stor259[call.data[0 len calldata.size]].field_0:\n          if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size]))\n              if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]].field_0--\n                  stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n              else:\n                  require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                  stor259[call.data[0 len calldata.size]].field_0 = 0\n                  stor259[call.data[0 len calldata.size]].field_256 = 0\n                  stor259[call.data[0 len calldata.size]].field_512 = 0\n                  if stor258[address(owner)] <= 0:\n                      idx = 0\n                      while idx < stor260.length:\n                          mem[0] = stor260[idx]\n                          mem[32] = 264\n                          address(stor264[stor260[idx]].field_0) = 0\n                          stor264[stor260[idx]].field_256 = 0\n                          stor264[stor260[idx]].field_512 = 0\n                          if 31 < stor264[stor260[idx]][2].length:\n                              mem[0] = sha3(stor260[idx], 264) + 2\n                              s = sha3(sha3(stor260[idx], 264) + 2)\n                              while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                  stor[s] = 0\n                                  s = s + 1\n                                  continue \n                          idx = idx + 1\n                          continue \n                      s = 0\n                      while s < stor260.length:\n                          mem[0] = 260\n                          if stor260[s]:\n                              require s < stor260.length\n                              mem[0] = stor260[s]\n                              mem[32] = 259\n                              stor259[stor260[s]].field_0 = 0\n                              stor259[stor260[s]].field_256 = 0\n                              stor259[stor260[s]].field_512 = 0\n                          s = s + 1\n                          continue \n                      stor260.length = 0\n                      s = 0\n                      while stor260.length > s:\n                          stor260[s] = 0\n                          s = s + 1\n                          continue \n                      if m_numOwners < 250:\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          address(owner[stor1].field_0) = owner\n                          Mask(96, 0, owner[stor1].field_160) = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n                      else:\n                          if 1 < m_numOwners:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if m_numOwners < 250:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              address(owner[stor1].field_0) = owner\n                              Mask(96, 0, owner[stor1].field_160) = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n      else:\n          stor259[call.data[0 len calldata.size]].field_0 = m_required\n          stor259[call.data[0 len calldata.size]].field_256 = 0\n          stor260.length++\n          if not stor260.length <= stor260.length + 1:\n              idx = stor260.length + 1\n              while stor260.length > idx:\n                  stor260[idx] = 0\n                  idx = idx + 1\n                  continue \n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size]))\n                  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]].field_0--\n                      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  else:\n                      require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 264\n                              address(stor264[stor260[idx]].field_0) = 0\n                              stor264[stor260[idx]].field_256 = 0\n                              stor264[stor260[idx]].field_512 = 0\n                              if 31 < stor264[stor260[idx]][2].length:\n                                  mem[0] = sha3(stor260[idx], 264) + 2\n                                  s = sha3(sha3(stor260[idx], 264) + 2)\n                                  while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                      stor[s] = 0\n                                      s = s + 1\n                                      continue \n                              idx = idx + 1\n                              continue \n                          s = 0\n                          while s < stor260.length:\n                              mem[0] = 260\n                              if stor260[s]:\n                                  require s < stor260.length\n                                  mem[0] = stor260[s]\n                                  mem[32] = 259\n                                  stor259[stor260[s]].field_0 = 0\n                                  stor259[stor260[s]].field_256 = 0\n                                  stor259[stor260[s]].field_512 = 0\n                              s = s + 1\n                              continue \n                          stor260.length = 0\n                          s = 0\n                          while stor260.length > s:\n                              stor260[s] = 0\n                              s = s + 1\n                              continue \n                          if m_numOwners >= 250:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          m_numOwners++\n                          require m_numOwners + 1 < 256\n                          address(owner[stor1].field_0) = owner\n                          Mask(96, 0, owner[stor1].field_160) = 0\n                          stor258[address(owner)] = m_numOwners\n                          log OwnerAdded(address newOwner=owner)\n          else:\n              stor259[call.data[0 len calldata.size]].field_512 = stor260.length\n              require stor260.length < stor260.length\n              stor260[stor260.length] = sha3(call.data[0 len calldata.size])\n              if not stor259[call.data[0 len calldata.size]].field_256 or not 2^stor258[caller]:\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size]))\n                  if stor259[call.data[0 len calldata.size]].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]].field_0--\n                      stor259[call.data[0 len calldata.size]].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]].field_256\n                  else:\n                      require stor259[call.data[0 len calldata.size]].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]].field_512] = 0\n                      stor259[call.data[0 len calldata.size]].field_0 = 0\n                      stor259[call.data[0 len calldata.size]].field_256 = 0\n                      stor259[call.data[0 len calldata.size]].field_512 = 0\n                      if stor258[address(owner)] <= 0:\n                          idx = 0\n                          while idx < stor260.length:\n                              mem[0] = stor260[idx]\n                              mem[32] = 264\n                              address(stor264[stor260[idx]].field_0) = 0\n                              stor264[stor260[idx]].field_256 = 0\n                              stor264[stor260[idx]].field_512 = 0\n                              if 31 < stor264[stor260[idx]][2].length:\n                                  mem[0] = sha3(stor260[idx], 264) + 2\n                                  s = sha3(sha3(stor260[idx], 264) + 2)\n                                  while sha3(sha3(stor260[idx], 264) + 2) + (stor264[stor260[idx]][2].length + 31 / 32) > s:\n                                      stor[s] = 0\n                                      s = s + 1\n                                      continue \n                              idx = idx + 1\n                              continue \n                          s = 0\n                          while s < stor260.length:\n                              mem[0] = 260\n                              if stor260[s]:\n                                  require s < stor260.length\n                                  mem[0] = stor260[s]\n                                  mem[32] = 259\n                                  stor259[stor260[s]].field_0 = 0\n                                  stor259[stor260[s]].field_256 = 0\n                                  stor259[stor260[s]].field_512 = 0\n                              s = s + 1\n                              continue \n                          stor260.length = 0\n                          s = 0\n                          while stor260.length > s:\n                              stor260[s] = 0\n                              s = s + 1\n                              continue \n                          if m_numOwners < 250:\n                              m_numOwners++\n                              require m_numOwners + 1 < 256\n                              address(owner[stor1].field_0) = owner\n                              Mask(96, 0, owner[stor1].field_160) = 0\n                              stor258[address(owner)] = m_numOwners\n                              log OwnerAdded(address newOwner=owner)\n                          else:\n                              if 1 < m_numOwners:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if m_numOwners < 250:\n                                  m_numOwners++\n                                  require m_numOwners + 1 < 256\n                                  address(owner[stor1].field_0) = owner\n                                  Mask(96, 0, owner[stor1].field_160) = 0\n                                  stor258[address(owner)] = m_numOwners\n                                  log OwnerAdded(address newOwner=owner)\n\ndef execute(address _to, uint256 _value, bytes _data): # not payable\n  if stor258[caller] <= 0:\n      return 0\n  if not _data.length:\n      if stor258[caller] > 0:\n          if block.timestamp / 24 * 3600 > m_lastDay:\n              m_spentToday = 0\n              m_lastDay = block.timestamp / 24 * 3600\n              if m_spentToday + _value < m_spentToday:\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if stor258[caller]:\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length <= stor260.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              require stor260.length < stor260.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                              log Confirmation(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              else:\n                                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  else:\n                      if stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if stor258[caller]:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              else:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      else:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                  else:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n              else:\n                  if m_spentToday + _value <= m_dailyLimit:\n                      m_spentToday += _value\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if stor258[caller]:\n                          if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          else:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  else:\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                  else:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 <= 1:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      else:\n                          if stor258[caller]:\n                              if not stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                              else:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n          else:\n              if m_spentToday + _value < m_spentToday:\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          else:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                  require stor260.length < stor260.length\n                                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 <= 1:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                  else:\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if not stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  else:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                      if not stor260.length > stor260.length + 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                          require stor260.length < stor260.length\n                                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                          if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                              log Confirmation(\n                                                    address owner=caller,\n                                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      else:\n                          if not stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                      log ConfirmationNeeded(\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                            address initiator=caller,\n                                            uint256 value=_value,\n                                            address to=address(_to),\n                                            bytes data=Array(len=_data.length, data=_data[all]))\n                                  else:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              else:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                      require stor260.length < stor260.length\n                                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n              else:\n                  if m_spentToday + _value <= m_dailyLimit:\n                      m_spentToday += _value\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if 1 == m_required:\n                      if not _to:\n                          create contract with ('param', '_value') wei\n                                          code: _data[all]\n                          require ext_code.size(create.new_address)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      call _to with:\n                         value _value wei\n                           gas gas_remaining - 34050 wei\n                          args _data[all]\n                      require ext_call.success\n                      log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                         caller,\n                                         _value,\n                                         address(_to),\n                                         160,\n                                         0,\n                                         _data.length,\n                                         _data[all],\n                      return 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                              address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                              stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                              stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                          else:\n                              if stor258[caller]:\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                          else:\n                                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  else:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor260.length++\n                                      if not stor260.length > stor260.length + 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                          require stor260.length < stor260.length\n                                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      else:\n                          if not stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                      else:\n                                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              else:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor260.length++\n                                  if not stor260.length > stor260.length + 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                      require stor260.length < stor260.length\n                                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                      if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                          log Confirmation(\n                                                address owner=caller,\n                                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  else:\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                          else:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor260.length++\n                              if not stor260.length > stor260.length + 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                                  require stor260.length < stor260.length\n                                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                                  if not stor259[call.data[0 len calldata.size]][block.number].field_256 or not 2^stor258[caller]:\n                                      log Confirmation(\n                                            address owner=caller,\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n      else:\n          if 1 == m_required:\n              if not _to:\n                  create contract with ('param', '_value') wei\n                                  code: _data[all]\n                  require ext_code.size(create.new_address)\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              call _to with:\n                 value _value wei\n                   gas gas_remaining - 34050 wei\n                  args _data[all]\n              require ext_call.success\n              log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                                 caller,\n                                 _value,\n                                 address(_to),\n                                 160,\n                                 0,\n                                 _data.length,\n                                 _data[all],\n              return 0\n          if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n              if not stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n              else:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor260.length++\n                  if not stor260.length > stor260.length + 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                      else:\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n          else:\n              if stor264[call.data[0 len calldata.size]][block.number].field_256:\n                  if not stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                  else:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor260.length++\n                      if not stor260.length > stor260.length + 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          require stor260.length < stor260.length\n                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              log Confirmation(\n                                    address owner=caller,\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n              else:\n                  if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                      address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                      stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                      stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n                  else:\n                      if not stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                          stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                          if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                              if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                                  if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                      log ConfirmationNeeded(\n                                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                            address initiator=caller,\n                                            uint256 value=_value,\n                                            address to=address(_to),\n                                            bytes data=Array(len=_data.length, data=_data[all]))\n                                  else:\n                      else:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                          stor260.length++\n                          if not stor260.length > stor260.length + 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                              require stor260.length < stor260.length\n                              stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                              else:\n                                  log Confirmation(\n                                        address owner=caller,\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                                  else:\n                                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n  else:\n      if 1 == m_required:\n          if not _to:\n              create contract with ('param', '_value') wei\n                              code: _data[all]\n              require ext_code.size(create.new_address)\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          call _to with:\n             value _value wei\n               gas gas_remaining - 34050 wei\n              args _data[all]\n          require ext_call.success\n          log SingleTransact(address owner, uint256 value, address to, bytes data, address created):\n                             caller,\n                             _value,\n                             address(_to),\n                             160,\n                             0,\n                             _data.length,\n                             _data[all],\n          return 0\n      if address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n          if not stor258[caller]:\n              log ConfirmationNeeded(\n                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                    address initiator=caller,\n                    uint256 value=_value,\n                    address to=address(_to),\n                    bytes data=Array(len=_data.length, data=_data[all]))\n              return sha3(call.data[0 len calldata.size], block.number)\n          if stor259[call.data[0 len calldata.size]][block.number].field_0:\n              if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              log Confirmation(\n                    address owner=caller,\n                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n              if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0--\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                      if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n          else:\n              stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n              stor260.length++\n              if not stor260.length > stor260.length + 1:\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                  require stor260.length < stor260.length\n                  stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n      else:\n          if stor264[call.data[0 len calldata.size]][block.number].field_256:\n              if not stor258[caller]:\n                  log ConfirmationNeeded(\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                        address initiator=caller,\n                        uint256 value=_value,\n                        address to=address(_to),\n                        bytes data=Array(len=_data.length, data=_data[all]))\n                  return sha3(call.data[0 len calldata.size], block.number)\n              if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                  if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  log Confirmation(\n                        address owner=caller,\n                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0--\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                  stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                  if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                      if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                          if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n              else:\n                  stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                  stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                  stor260.length++\n                  if not stor260.length > stor260.length + 1:\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                      require stor260.length < stor260.length\n                      stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n          else:\n              if not stor264[call.data[0 len calldata.size]][block.number][2].length:\n                  address(stor264[call.data[0 len calldata.size]][block.number].field_0) = _to\n                  stor264[call.data[0 len calldata.size]][block.number].field_256 = _value\n                  stor264[call.data[0 len calldata.size]][block.number].field_512 = (2 * _data.length) + 1\n              else:\n                  if not stor258[caller]:\n                      log ConfirmationNeeded(\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                            address initiator=caller,\n                            uint256 value=_value,\n                            address to=address(_to),\n                            bytes data=Array(len=_data.length, data=_data[all]))\n                      return sha3(call.data[0 len calldata.size], block.number)\n                  if stor259[call.data[0 len calldata.size]][block.number].field_0:\n                      if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      log Confirmation(\n                            address owner=caller,\n                            bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                      if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_0--\n                          stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                          log ConfirmationNeeded(\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                address initiator=caller,\n                                uint256 value=_value,\n                                address to=address(_to),\n                                bytes data=Array(len=_data.length, data=_data[all]))\n                          return sha3(call.data[0 len calldata.size], block.number)\n                      require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                      stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                      if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                          if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                              if not Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n                                  log ConfirmationNeeded(\n                                        bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                        address initiator=caller,\n                                        uint256 value=_value,\n                                        address to=address(_to),\n                                        bytes data=Array(len=_data.length, data=_data[all]))\n                                  return sha3(call.data[0 len calldata.size], block.number)\n                  else:\n                      stor259[call.data[0 len calldata.size]][block.number].field_0 = m_required\n                      stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                      stor260.length++\n                      if not stor260.length > stor260.length + 1:\n                          stor259[call.data[0 len calldata.size]][block.number].field_512 = stor260.length\n                          require stor260.length < stor260.length\n                          stor260[stor260.length] = sha3(call.data[0 len calldata.size], block.number)\n                          if stor259[call.data[0 len calldata.size]][block.number].field_256 and 2^stor258[caller]:\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                              return sha3(call.data[0 len calldata.size], block.number)\n                          log Confirmation(\n                                address owner=caller,\n                                bytes32 operation=sha3(call.data[0 len calldata.size], block.number))\n                          if stor259[call.data[0 len calldata.size]][block.number].field_0 > 1:\n                              stor259[call.data[0 len calldata.size]][block.number].field_0--\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 2^stor258[caller] or stor259[call.data[0 len calldata.size]][block.number].field_256\n                              log ConfirmationNeeded(\n                                    bytes32 operation=sha3(call.data[0 len calldata.size], block.number),\n                                    address initiator=caller,\n                                    uint256 value=_value,\n                                    address to=address(_to),\n                                    bytes data=Array(len=_data.length, data=_data[all]))\n                          else:\n                              require stor259[call.data[0 len calldata.size]][block.number].field_512 < stor260.length\n                              stor260[stor259[call.data[0 len calldata.size]][block.number].field_512] = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_0 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_256 = 0\n                              stor259[call.data[0 len calldata.size]][block.number].field_512 = 0\n                              if not address(stor264[call.data[0 len calldata.size]][block.number].field_0):\n                                  if not stor264[call.data[0 len calldata.size]][block.number].field_256:\n                                      if Mask(255, 1, (256 * not bool(stor264[call.data[0 len calldata.size]][block.number].field_512)) - 1 and stor264[call.data[0 len calldata.size]][block.number].field_512):\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
	"status": "1",
	"time_cost": 44.448115825653076,
	"usage": {
		"completion_tokens": 476,
		"prompt_tokens": 25538,
		"total_tokens": 26014
	}
}