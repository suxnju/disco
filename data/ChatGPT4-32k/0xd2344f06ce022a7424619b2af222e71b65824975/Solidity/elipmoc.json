{
	"address": "0xd2344f06ce022a7424619b2af222e71b65824975",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity equivalent for the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _pusherTracker_;\n    mapping (address => uint256[]) private _pushers_;\n    uint256 private _rateLimiter_;\n\n    event onDistribute(address indexed sender, uint256 value1, uint256 value2, uint256 balance, uint256 value3);\n\n    function deposit() public payable { \n    }\n\n    function pushers_(address _address) public view returns(uint256[] memory) { \n        return _pushers_[_address];\n    }\n\n    function pusherTracker_() public view returns(uint256) { \n        return _pusherTracker_;\n    }\n\n    function balances() public view returns(uint256) { \n        return address(this).balance;\n    }\n\n    function distribute(uint256 _value) public view { \n        // Logic goes here\n    }\n\n    function rateLimiter_() public view returns(uint256) { \n        return _rateLimiter_;\n    }\n\n    fallback() external payable {\n        revert();\n    }\n}\n```\n\nPlease note that the original EVM Bytecode seems to interact with another contract (possibly an ERC20 token) at address `0x97550ce17666bb49349ef0e50f9fdb88353edb64` and calls its functions such as `stakingRequirement()`, `balanceOf()`, `buy()`, `sell()`, `dividendsOf()`, `reinvest()`, and `withdraw()`. However, without the contract's ABI or source code, it is difficult to represent these interactions precisely in Solidity. \n\nAlso, functions `0x134()`, `0xa26()`, `0xa9d()`, and `0xc0e()` do not have clear equivalents in Solidity, as they seem to be internal functions with specific calculations and logic. \n\nThis Solidity code is a simplified version and may not behave exactly as the original EVM bytecode. It's recommended to have the original Solidity source code to fully understand the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040356,
	"id": "chatcmpl-8Ci9cWF74xXyWnqE7GAB5qMCsQrjM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 10:45 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _pusherTracker_; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _pushers_; // STORAGE[0x1]\nuint256 _rateLimiter_; // STORAGE[0x2]\n\n// Events\nonDistribute(address, uint256, uint256, uint256, uint256);\n\nfunction deposit() public payable { \n}\n\nfunction 0x134() private { \n    v0 = v1 = 0;\n    v0 = v2 = msg.sender;\n    require(v2 == tx.origin);\n    v0 = v3 = v2.code.size;\n    require(!v3, 'sorry humans only');\n    v4 = v5 = v0 > 0;\n    if (v5) {\n        v4 = v6 = v0 < 100;\n    }\n    require(v4, 'please pick a percent between 1 and 99');\n    v7 = v8 = this.balance;\n    require(100 <= _pusherTracker_, 'SafeMath sub failed');\n    v9 = v10 = _pushers_[msg.sender] <= _pusherTracker_ - 100;\n    if (_pushers_[msg.sender] <= _pusherTracker_ - 100) {\n        require(3600 + _pushers_[msg.sender][1] >= _pushers_[msg.sender][1], 'SafeMath add failed');\n        v9 = v11 = 3600 + _pushers_[msg.sender][1] < block.timestamp;\n    }\n    if (!v9) {\n        v0 = v12 = 0xa9d(47, 47, 1, v1, 2143, v3, v2);\n    } else {\n        _pushers_[msg.sender] = _pusherTracker_;\n        _pusherTracker_ = _pusherTracker_ + 1;\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v13, v14 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.stakingRequirement().gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v15, v16 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.balanceOf(msg.sender).gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (v16 >= v14) {\n            v0 = v17 = v8 / 10 / 3;\n        }\n        v18 = 0xa26(100 - v0, v8);\n        assert(100);\n        v7 = v19 = v18 / 100;\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v20 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.buy(msg.sender).value(v8).gas(msg.gas);\n        require(v20); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v21, v22 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.balanceOf(this).gas(msg.gas);\n        require(v21); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v23 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.sell(v22).gas(msg.gas);\n        require(v23); // checks call status, propagates error data on error\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v24, v0 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.dividendsOf(this).gas(msg.gas);\n        require(v24); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        while (v0 >= v19) {\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v25 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.reinvest().gas(msg.gas);\n            require(v25); // checks call status, propagates error data on error\n            MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v26 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.call(v27, this).gas(msg.gas);\n            require(v26); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            MEM[MEM[64]] = 0xe4849b3200000000000000000000000000000000000000000000000000000000;\n            MEM[MEM[64] + 4] = MEM[MEM[64]];\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v28 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.call(MEM[(MEM[64]) len 36], MEM[(MEM[64]) len 0]).gas(msg.gas);\n            require(v28); // checks call status, propagates error data on error\n            v29 = 0xa26(81, v0);\n            assert(100);\n            v0 = v29 / 100;\n        }\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v30 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.withdraw().gas(msg.gas);\n        require(v30); // checks call status, propagates error data on error\n    }\n    _pushers_[msg.sender][1] = block.timestamp;\n    v31 = 0xa9d(14, 0, block.timestamp, v0, 2198, v0, v0);\n    v32 = v27 & 0xffffffffffffffffffffffffffffffffffffffff;\n    v33 = 0xa9d(29, 15, _pushers_[v32], v31, 2247, v7, v0);\n    v34 = 0xa9d(44, 30, _pusherTracker_, v33, 2274, v8, v31);\n    v35 = 0xa9d(46, 45, v27, v34, 2296, v27, v33);\n    v36 = v27 & 0xffffffffffffffffffffffffffffffffffffffff;\n    emit onDistribute(v36, v27, v27, this.balance, v35);\n    return;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction pushers_(address varg0) public nonPayable { \n    return _pushers_[varg0], _pushers_[varg0][1];\n}\n\nfunction pusherTracker_() public nonPayable { \n    return _pusherTracker_;\n}\n\nfunction 0xa26(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0xa9d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0 < 77;\n    if (v3) {\n        v2 = v4 = varg1 < 77;\n    }\n    require(v2, 'start/end must be less than 77');\n    require(varg0 >= varg1, 'end must be >= start');\n    v5 = 0xc0e(varg0);\n    v0 = v6 = 0xa26(10, v5);\n    v0 = v7 = 0xc0e(varg1);\n    assert(v7);\n    require(varg2 < v6 / v7);\n    if (varg2 > 0) {\n        v0 = v8 = 0xa26(v7, varg2);\n    }\n    v0 = v9 = 3077;\n    v0 = v10 = 3030;\n    assert(v6);\n    while (1) {\n        v11 = v0 / v0;\n        if (v11) {\n            v0 = v0 * v11;\n            assert(v11);\n            require(v0 / v11 == v0, 'SafeMath mul failed');\n        } else {\n            v0 = v12 = 0;\n        }\n        while (1) {\n            goto {'0xc050xa9d', '0xbec', '0xbf9', '0xbd6'};\n            require(v0 <= v0, 'SafeMath sub failed');\n            v0 = v0 - v0;\n            v0 += v0;\n            require(v0 >= v0, 'SafeMath add failed');\n        }\n        v0 = v13 = 3065;\n        v0 = v14 = 3065;\n        v0 = v15 = 3052;\n        assert(v0);\n    }\n    return v0;\n}\n\nfunction 0xc0e(uint256 varg0) private { \n    v0 = v1 = 10;\n    if (v1) {\n        if (varg0) {\n            v2 = v3 = 1;\n            while (v2 < varg0) {\n                v0 = 0xa26(v1, v0);\n                v2 += 1;\n            }\n        } else {\n            v0 = v4 = 1;\n        }\n    } else {\n        v0 = v5 = 0;\n    }\n    return v0;\n}\n\nfunction balances() public nonPayable { \n    return this.balance;\n}\n\nfunction distribute(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x134();\n}\n\nfunction rateLimiter_() public nonPayable { \n    return _rateLimiter_;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x1f75c390) {\n            pushers_(address);\n        } else if (0x521ceba7 == uint32(function_selector >> 224)) {\n            pusherTracker_();\n        } else if (0x7bb98a68 == uint32(function_selector >> 224)) {\n            balances();\n        } else if (0x91c05b0b == uint32(function_selector >> 224)) {\n            distribute(uint256);\n        } else if (0xb519cf31 == uint32(function_selector >> 224)) {\n            rateLimiter_();\n        } else if (0xd0e30db0 == uint32(function_selector >> 224)) {\n            deposit();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 10:45 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _pusherTracker_; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _pushers_; // STORAGE[0x1]\nuint256 _rateLimiter_; // STORAGE[0x2]\n\n// Events\nonDistribute(address, uint256, uint256, uint256, uint256);\n\nfunction deposit() public payable { \n}\n\nfunction 0x134() private { \n    v0 = v1 = 0;\n    v0 = v2 = msg.sender;\n    require(v2 == tx.origin);\n    v0 = v3 = v2.code.size;\n    require(!v3, 'sorry humans only');\n    v4 = v5 = v0 > 0;\n    if (v5) {\n        v4 = v6 = v0 < 100;\n    }\n    require(v4, 'please pick a percent between 1 and 99');\n    v7 = v8 = this.balance;\n    require(100 <= _pusherTracker_, 'SafeMath sub failed');\n    v9 = v10 = _pushers_[msg.sender] <= _pusherTracker_ - 100;\n    if (_pushers_[msg.sender] <= _pusherTracker_ - 100) {\n        require(3600 + _pushers_[msg.sender][1] >= _pushers_[msg.sender][1], 'SafeMath add failed');\n        v9 = v11 = 3600 + _pushers_[msg.sender][1] < block.timestamp;\n    }\n    if (!v9) {\n        v0 = v12 = 0xa9d(47, 47, 1, v1, 2143, v3, v2);\n    } else {\n        _pushers_[msg.sender] = _pusherTracker_;\n        _pusherTracker_ = _pusherTracker_ + 1;\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v13, v14 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.stakingRequirement().gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v15, v16 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.balanceOf(msg.sender).gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (v16 >= v14) {\n            v0 = v17 = v8 / 10 / 3;\n        }\n        v18 = 0xa26(100 - v0, v8);\n        assert(100);\n        v7 = v19 = v18 / 100;\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v20 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.buy(msg.sender).value(v8).gas(msg.gas);\n        require(v20); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v21, v22 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.balanceOf(this).gas(msg.gas);\n        require(v21); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v23 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.sell(v22).gas(msg.gas);\n        require(v23); // checks call status, propagates error data on error\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v24, v0 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.dividendsOf(this).gas(msg.gas);\n        require(v24); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        while (v0 >= v19) {\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v25 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.reinvest().gas(msg.gas);\n            require(v25); // checks call status, propagates error data on error\n            MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v26 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.call(v27, this).gas(msg.gas);\n            require(v26); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            MEM[MEM[64]] = 0xe4849b3200000000000000000000000000000000000000000000000000000000;\n            MEM[MEM[64] + 4] = MEM[MEM[64]];\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v28 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.call(MEM[(MEM[64]) len 36], MEM[(MEM[64]) len 0]).gas(msg.gas);\n            require(v28); // checks call status, propagates error data on error\n            v29 = 0xa26(81, v0);\n            assert(100);\n            v0 = v29 / 100;\n        }\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v30 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.withdraw().gas(msg.gas);\n        require(v30); // checks call status, propagates error data on error\n    }\n    _pushers_[msg.sender][1] = block.timestamp;\n    v31 = 0xa9d(14, 0, block.timestamp, v0, 2198, v0, v0);\n    v32 = v27 & 0xffffffffffffffffffffffffffffffffffffffff;\n    v33 = 0xa9d(29, 15, _pushers_[v32], v31, 2247, v7, v0);\n    v34 = 0xa9d(44, 30, _pusherTracker_, v33, 2274, v8, v31);\n    v35 = 0xa9d(46, 45, v27, v34, 2296, v27, v33);\n    v36 = v27 & 0xffffffffffffffffffffffffffffffffffffffff;\n    emit onDistribute(v36, v27, v27, this.balance, v35);\n    return;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction pushers_(address varg0) public nonPayable { \n    return _pushers_[varg0], _pushers_[varg0][1];\n}\n\nfunction pusherTracker_() public nonPayable { \n    return _pusherTracker_;\n}\n\nfunction 0xa26(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0xa9d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0 < 77;\n    if (v3) {\n        v2 = v4 = varg1 < 77;\n    }\n    require(v2, 'start/end must be less than 77');\n    require(varg0 >= varg1, 'end must be >= start');\n    v5 = 0xc0e(varg0);\n    v0 = v6 = 0xa26(10, v5);\n    v0 = v7 = 0xc0e(varg1);\n    assert(v7);\n    require(varg2 < v6 / v7);\n    if (varg2 > 0) {\n        v0 = v8 = 0xa26(v7, varg2);\n    }\n    v0 = v9 = 3077;\n    v0 = v10 = 3030;\n    assert(v6);\n    while (1) {\n        v11 = v0 / v0;\n        if (v11) {\n            v0 = v0 * v11;\n            assert(v11);\n            require(v0 / v11 == v0, 'SafeMath mul failed');\n        } else {\n            v0 = v12 = 0;\n        }\n        while (1) {\n            goto {'0xc050xa9d', '0xbec', '0xbf9', '0xbd6'};\n            require(v0 <= v0, 'SafeMath sub failed');\n            v0 = v0 - v0;\n            v0 += v0;\n            require(v0 >= v0, 'SafeMath add failed');\n        }\n        v0 = v13 = 3065;\n        v0 = v14 = 3065;\n        v0 = v15 = 3052;\n        assert(v0);\n    }\n    return v0;\n}\n\nfunction 0xc0e(uint256 varg0) private { \n    v0 = v1 = 10;\n    if (v1) {\n        if (varg0) {\n            v2 = v3 = 1;\n            while (v2 < varg0) {\n                v0 = 0xa26(v1, v0);\n                v2 += 1;\n            }\n        } else {\n            v0 = v4 = 1;\n        }\n    } else {\n        v0 = v5 = 0;\n    }\n    return v0;\n}\n\nfunction balances() public nonPayable { \n    return this.balance;\n}\n\nfunction distribute(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x134();\n}\n\nfunction rateLimiter_() public nonPayable { \n    return _rateLimiter_;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x1f75c390) {\n            pushers_(address);\n        } else if (0x521ceba7 == uint32(function_selector >> 224)) {\n            pusherTracker_();\n        } else if (0x7bb98a68 == uint32(function_selector >> 224)) {\n            balances();\n        } else if (0x91c05b0b == uint32(function_selector >> 224)) {\n            distribute(uint256);\n        } else if (0xb519cf31 == uint32(function_selector >> 224)) {\n            rateLimiter_();\n        } else if (0xd0e30db0 == uint32(function_selector >> 224)) {\n            deposit();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 10:45 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _pusherTracker_; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _pushers_; // STORAGE[0x1]\nuint256 _rateLimiter_; // STORAGE[0x2]\n\n// Events\nonDistribute(address, uint256, uint256, uint256, uint256);\n\nfunction deposit() public payable { \n}\n\nfunction 0x134() private { \n    v0 = v1 = 0;\n    v0 = v2 = msg.sender;\n    require(v2 == tx.origin);\n    v0 = v3 = v2.code.size;\n    require(!v3, 'sorry humans only');\n    v4 = v5 = v0 > 0;\n    if (v5) {\n        v4 = v6 = v0 < 100;\n    }\n    require(v4, 'please pick a percent between 1 and 99');\n    v7 = v8 = this.balance;\n    require(100 <= _pusherTracker_, 'SafeMath sub failed');\n    v9 = v10 = _pushers_[msg.sender] <= _pusherTracker_ - 100;\n    if (_pushers_[msg.sender] <= _pusherTracker_ - 100) {\n        require(3600 + _pushers_[msg.sender][1] >= _pushers_[msg.sender][1], 'SafeMath add failed');\n        v9 = v11 = 3600 + _pushers_[msg.sender][1] < block.timestamp;\n    }\n    if (!v9) {\n        v0 = v12 = 0xa9d(47, 47, 1, v1, 2143, v3, v2);\n    } else {\n        _pushers_[msg.sender] = _pusherTracker_;\n        _pusherTracker_ = _pusherTracker_ + 1;\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v13, v14 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.stakingRequirement().gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v15, v16 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.balanceOf(msg.sender).gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (v16 >= v14) {\n            v0 = v17 = v8 / 10 / 3;\n        }\n        v18 = 0xa26(100 - v0, v8);\n        assert(100);\n        v7 = v19 = v18 / 100;\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v20 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.buy(msg.sender).value(v8).gas(msg.gas);\n        require(v20); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v21, v22 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.balanceOf(this).gas(msg.gas);\n        require(v21); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v23 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.sell(v22).gas(msg.gas);\n        require(v23); // checks call status, propagates error data on error\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v24, v0 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.dividendsOf(this).gas(msg.gas);\n        require(v24); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        while (v0 >= v19) {\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v25 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.reinvest().gas(msg.gas);\n            require(v25); // checks call status, propagates error data on error\n            MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v26 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.call(v27, this).gas(msg.gas);\n            require(v26); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            MEM[MEM[64]] = 0xe4849b3200000000000000000000000000000000000000000000000000000000;\n            MEM[MEM[64] + 4] = MEM[MEM[64]];\n            require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n            v28 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.call(MEM[(MEM[64]) len 36], MEM[(MEM[64]) len 0]).gas(msg.gas);\n            require(v28); // checks call status, propagates error data on error\n            v29 = 0xa26(81, v0);\n            assert(100);\n            v0 = v29 / 100;\n        }\n        require(0x97550ce17666bb49349ef0e50f9fdb88353edb64.code.size);\n        v30 = 0x97550ce17666bb49349ef0e50f9fdb88353edb64.withdraw().gas(msg.gas);\n        require(v30); // checks call status, propagates error data on error\n    }\n    _pushers_[msg.sender][1] = block.timestamp;\n    v31 = 0xa9d(14, 0, block.timestamp, v0, 2198, v0, v0);\n    v32 = v27 & 0xffffffffffffffffffffffffffffffffffffffff;\n    v33 = 0xa9d(29, 15, _pushers_[v32], v31, 2247, v7, v0);\n    v34 = 0xa9d(44, 30, _pusherTracker_, v33, 2274, v8, v31);\n    v35 = 0xa9d(46, 45, v27, v34, 2296, v27, v33);\n    v36 = v27 & 0xffffffffffffffffffffffffffffffffffffffff;\n    emit onDistribute(v36, v27, v27, this.balance, v35);\n    return;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction pushers_(address varg0) public nonPayable { \n    return _pushers_[varg0], _pushers_[varg0][1];\n}\n\nfunction pusherTracker_() public nonPayable { \n    return _pusherTracker_;\n}\n\nfunction 0xa26(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0xa9d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0 < 77;\n    if (v3) {\n        v2 = v4 = varg1 < 77;\n    }\n    require(v2, 'start/end must be less than 77');\n    require(varg0 >= varg1, 'end must be >= start');\n    v5 = 0xc0e(varg0);\n    v0 = v6 = 0xa26(10, v5);\n    v0 = v7 = 0xc0e(varg1);\n    assert(v7);\n    require(varg2 < v6 / v7);\n    if (varg2 > 0) {\n        v0 = v8 = 0xa26(v7, varg2);\n    }\n    v0 = v9 = 3077;\n    v0 = v10 = 3030;\n    assert(v6);\n    while (1) {\n        v11 = v0 / v0;\n        if (v11) {\n            v0 = v0 * v11;\n            assert(v11);\n            require(v0 / v11 == v0, 'SafeMath mul failed');\n        } else {\n            v0 = v12 = 0;\n        }\n        while (1) {\n            goto {'0xc050xa9d', '0xbec', '0xbf9', '0xbd6'};\n            require(v0 <= v0, 'SafeMath sub failed');\n            v0 = v0 - v0;\n            v0 += v0;\n            require(v0 >= v0, 'SafeMath add failed');\n        }\n        v0 = v13 = 3065;\n        v0 = v14 = 3065;\n        v0 = v15 = 3052;\n        assert(v0);\n    }\n    return v0;\n}\n\nfunction 0xc0e(uint256 varg0) private { \n    v0 = v1 = 10;\n    if (v1) {\n        if (varg0) {\n            v2 = v3 = 1;\n            while (v2 < varg0) {\n                v0 = 0xa26(v1, v0);\n                v2 += 1;\n            }\n        } else {\n            v0 = v4 = 1;\n        }\n    } else {\n        v0 = v5 = 0;\n    }\n    return v0;\n}\n\nfunction balances() public nonPayable { \n    return this.balance;\n}\n\nfunction distribute(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x134();\n}\n\nfunction rateLimiter_() public nonPayable { \n    return _rateLimiter_;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x1f75c390) {\n            pushers_(address);\n        } else if (0x521ceba7 == uint32(function_selector >> 224)) {\n            pusherTracker_();\n        } else if (0x7bb98a68 == uint32(function_selector >> 224)) {\n            balances();\n        } else if (0x91c05b0b == uint32(function_selector >> 224)) {\n            distribute(uint256);\n        } else if (0xb519cf31 == uint32(function_selector >> 224)) {\n            rateLimiter_();\n        } else if (0xd0e30db0 == uint32(function_selector >> 224)) {\n            deposit();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 19.87557864189148,
	"usage": {
		"completion_tokens": 432,
		"prompt_tokens": 2795,
		"total_tokens": 3227
	}
}