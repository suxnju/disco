{
	"address": "0x195b6dc3c79185e53d97b443c0769f1d9bd3b7fb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code you provided seems to be incorrect as it contains many invalid syntaxes and unidentified functions (like 0x59f). However, I can provide an outline of a Solidity contract based on the function names and variables mentioned in your code:\n\n```Solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract ContractName {\n    mapping (address => uint256) private _holding;\n    mapping (address => uint256) private _percentage;\n    mapping (address => uint256) private _time_stamp;\n    uint256 private _marketing_percent;\n    uint256 private _max_contribution;\n    uint256 private _max_percentage;\n    uint256 private _referral_percent;\n    uint256 private _hourly_percentage;\n    uint256 private _payment_delay;\n    uint256 private _count_investors;\n    address private _marketing_wallet;\n\n    function max_contribution() public view returns (uint256){\n        return _max_contribution;\n    }\n\n    function holding(address account) public view returns (uint256){\n        return _holding[account];\n    }\n\n    function marketing_wallet() public view returns (address){\n        return _marketing_wallet;\n    }\n\n    // The logic inside the below functions are not clear in your question, so I'm leaving them as examples\n    function getBonus(uint256 varg0) public view returns (uint256){\n        return varg0;\n    }\n\n    function elapsedTime() public view returns (uint256){\n        return block.timestamp - _time_stamp[msg.sender];\n    }\n\n    function time_stamp(address account) public view returns (uint256){\n        return _time_stamp[account];\n    }\n\n    function count_investors() public view returns (uint256){\n        return _count_investors;\n    }\n\n    function max_percentage() public view returns (uint256){\n        return _max_percentage;\n    }\n\n    function percentage(address account) public view returns (uint256){\n        return _percentage[account];\n    }\n\n    function hourly_percentage() public view returns (uint256){\n        return _hourly_percentage;\n    }\n\n    function marketing_percent() public view returns (uint256){\n        return _marketing_percent;\n    }\n\n    function referral_percent() public view returns (uint256){\n        return _referral_percent;\n    }\n\n    function payment_delay() public view returns (uint256){\n        return _payment_delay;\n    }\n\n    fallback() external payable {\n        // Logic for fallback function\n    }\n\n}\n```\n\nThis is a basic contract structure based on your provided decompiled code. The actual implementation may vary depending on the business logic you want to achieve. I'd suggest providing more details on the functionality you want to implement for more accurate assistance.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462954,
	"id": "chatcmpl-8R4WolMUFCkpjZUxCj779EMzArqcm",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 21:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _holding; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _percentage; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _time_stamp; // STORAGE[0x2]\nuint256 _marketing_percent; // STORAGE[0x4]\nuint256 _max_contribution; // STORAGE[0x5]\nuint256 _max_percentage; // STORAGE[0x6]\nuint256 _referral_percent; // STORAGE[0x7]\nuint256 _hourly_percentage; // STORAGE[0x8]\nuint256 _payment_delay; // STORAGE[0x9]\nuint256 _count_investors; // STORAGE[0xa]\nuint8 stor_9_0_0; // STORAGE[0x9] bytes 0 to 0\naddress _marketing_wallet; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction max_contribution() public nonPayable { \n    return _max_contribution;\n}\n\nfunction holding(address varg0) public nonPayable { \n    return _holding[varg0];\n}\n\nfunction marketing_wallet() public nonPayable { \n    return _marketing_wallet;\n}\n\nfunction getBonus(uint256 varg0) public nonPayable { \n    v0 = 0x7b7(varg0);\n    return v0;\n}\n\nfunction elapsedTime() public nonPayable { \n    v0 = 0x86a();\n    return v0;\n}\n\nfunction time_stamp(address varg0) public nonPayable { \n    return _time_stamp[varg0];\n}\n\nfunction count_investors() public nonPayable { \n    return _count_investors;\n}\n\nfunction max_percentage() public nonPayable { \n    return _max_percentage;\n}\n\nfunction percentage(address varg0) public nonPayable { \n    return _percentage[varg0];\n}\n\nfunction hourly_percentage() public nonPayable { \n    return _hourly_percentage;\n}\n\nfunction marketing_percent() public nonPayable { \n    return _marketing_percent;\n}\n\nfunction referral_percent() public nonPayable { \n    return _referral_percent;\n}\n\nfunction payment_delay() public nonPayable { \n    return _payment_delay;\n}\n\nfunction 0x59f() private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v2 = v4 = 0x86a();\n    require(v4 > 0, 'You can receive payment 1 time per hour');\n    v0 = v5 = 1655;\n    v6 = v7 = 759;\n    v8 = v9 = 0xf4240;\n    v10 = v11 = 0x8e1(_hourly_percentage, _holding[msg.sender]);\n    while (v8 <= 0) {\n        require(v8 > 0);\n        if (v8) {\n            break;\n        }\n        assert(v8);\n        if (v2 <= v10 / v8) {\n            _percentage[msg.sender] += v0;\n            _time_stamp[msg.sender] = block.timestamp;\n            v12 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v12); // checks call status, propagates error data on error\n        } else {\n            _holding[msg.sender] = 0;\n            _time_stamp[msg.sender] = 0;\n            _time_stamp[msg.sender] = 0;\n            require(v2 - v10 / v8 <= v2);\n            v13 = msg.sender.call().value(v2 - (v2 - v10 / v8)).gas(2300 * !(v2 - (v2 - v10 / v8)));\n            require(v13); // checks call status, propagates error data on error\n        }\n        return v4;\n        goto {'0x2f70x59f', '0x6c7'};\n        v0 = v14 = 0x8e1(v2, v10 / v8);\n        v2 = _SafeAdd(v14, _percentage[msg.sender]);\n        v6 = v15 = 1735;\n        v8 = v16 = 100;\n        v10 = v17 = 0x8e1(_max_percentage, _holding[msg.sender]);\n    }\n}\n\nfunction 0x7b7(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = varg0 < 0x8ac7230489e80000;\n    v3 = v4 = varg0 >= 0x8ac7230489e80000;\n    if (varg0 >= 0x8ac7230489e80000) {\n        v3 = v5 = varg0 < 0x15af1d78b58c40000;\n    }\n    if (!v3) {\n        v6 = v7 = varg0 >= 0x15af1d78b58c40000;\n        if (v7) {\n            v6 = v8 = varg0 < 0x2b5e3af16b1880000;\n        }\n        if (!v6) {\n            if (0x2b5e3af16b1880000 == varg0) {\n                v9 = v10 = 2145;\n                v11 = v12 = 100;\n                v13 = v14 = 0x8e1(1, varg0);\n            }\n        } else {\n            v9 = v15 = 2038;\n            v11 = v16 = 10000;\n            v13 = v17 = 0x8e1(75, varg0);\n        }\n    } else {\n        v9 = v18 = 2038;\n        v11 = v19 = 1000;\n        v13 = v20 = 0x8e1(5, varg0);\n    }\n    require(v11 > 0);\n    assert(v11);\n    v0 = v13 / v11;\n    goto {'0x861', '0x7f6'};\n    return v0;\n}\n\nfunction 0x86a() private { \n    require(_time_stamp[msg.sender] <= block.timestamp);\n    require(_payment_delay > 0);\n    assert(stor_9_0_0);\n    return (block.timestamp - _time_stamp[msg.sender]) / _payment_delay;\n}\n\nfunction 0x8e1(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x05f5e100() public payable { \n    v0 = v1 = 0;\n    v2 = v3 = 0x86a();\n    v4 = v5 = 0 < _holding[msg.sender];\n    if (v5) {\n        v4 = v6 = v3 > 0;\n    }\n    require(v4);\n    v7 = v8 = 771;\n    v9 = v10 = 759;\n    v11 = v12 = 0xf4240;\n    v13 = v14 = 0x8e1(_hourly_percentage, _holding[msg.sender]);\n    while (v11 <= 0) {\n        require(v11 > 0);\n        if (v11) {\n            break;\n        }\n        assert(v11);\n        v15 = v7.call().value(v13 / v11).gas(v2 * !(v13 / v11));\n        require(v15); // checks call status, propagates error data on error\n        _holding[msg.sender] += v0;\n        _time_stamp[msg.sender] = block.timestamp;\n        exit;\n        goto {'0x2f70x9ab', '0x332'};\n        v0 = v16 = 0x8e1(v2, v13 / v11);\n        v7 = v17 = _marketing_wallet;\n        v2 = v18 = 2300;\n        v9 = v19 = 818;\n        v11 = v20 = 100;\n        v13 = 0x8e1(_marketing_percent, v16);\n    }\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        if (!msg.value) {\n            require(_holding[msg.sender] > 0);\n            v0 = 0x59f();\n        }\n    } else if (0x5f5e100 != msg.value) {\n        v1 = v2 = 238;\n        v1 = v3 = 0;\n        v4 = _SafeAdd(msg.value, _holding[msg.sender]);\n        require(v4 <= _max_contribution, 'Maximum Deposit 50 ether');\n        v5 = v6 = _holding[msg.sender] > 0;\n        if (v6) {\n            v7 = 0x86a();\n            v5 = v8 = v7 > 0;\n        }\n        if (v5) {\n            v9 = 0x59f();\n        }\n        if (msg.data.length == 20) {\n            v10 = new bytes[](msg.data.length);\n            CALLDATACOPY(v10.data, 0, msg.data.length);\n            if (msg.sender != address(MEM[20 + v10])) {\n                v11 = v12 = address(MEM[20 + v10]);\n                v13 = v14 = 2300;\n                v15 = v16 = 1217;\n                v17 = v18 = 100;\n                v19 = v20 = 0x8e1(_referral_percent, msg.value);\n            }\n        }\n        if (!_holding[msg.sender]) {\n            _count_investors += 1;\n        }\n        v11 = v21 = _marketing_wallet;\n        v13 = v22 = 2300;\n        v15 = v23 = 1337;\n        v17 = v24 = 100;\n        v19 = v25 = 0x8e1(_marketing_percent, msg.value);\n        require(v17 > 0);\n        assert(v17);\n        goto {'0x539', '0x4c1'};\n        v26 = v11.call().value(v19 / v17).gas(v13 * !(v19 / v17));\n        require(v26); // checks call status, propagates error data on error\n        v27 = v11.call().value(v19 / v17).gas(v13 * !(v19 / v17));\n        require(v27); // checks call status, propagates error data on error\n        v28 = 0x7b7(msg.value);\n        v29 = _SafeAdd(v28, msg.value);\n        _holding[msg.sender] += v29;\n        _time_stamp[msg.sender] = block.timestamp;\n    } else {\n        0x05f5e100();\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x14580027) {\n            max_contribution();\n        } else if (0x39166ee9 == function_selector) {\n            holding(address);\n        } else if (0x40e19609 == function_selector) {\n            marketing_wallet();\n        } else if (0x4aa66b28 == function_selector) {\n            getBonus(uint256);\n        } else if (0x51453f9d == function_selector) {\n            elapsedTime();\n        } else if (0x77a86b76 == function_selector) {\n            time_stamp(address);\n        } else if (0x96b10cdf == function_selector) {\n            count_investors();\n        } else if (0x98fbba9f == function_selector) {\n            max_percentage();\n        } else if (0xa7b7b087 == function_selector) {\n            percentage(address);\n        } else if (0xacb109b4 == function_selector) {\n            hourly_percentage();\n        } else if (0xb1f30979 == function_selector) {\n            marketing_percent();\n        } else if (0xe28bbe62 == function_selector) {\n            referral_percent();\n        } else if (0xe775ec02 == function_selector) {\n            payment_delay();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 21:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _holding; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _percentage; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _time_stamp; // STORAGE[0x2]\nuint256 _marketing_percent; // STORAGE[0x4]\nuint256 _max_contribution; // STORAGE[0x5]\nuint256 _max_percentage; // STORAGE[0x6]\nuint256 _referral_percent; // STORAGE[0x7]\nuint256 _hourly_percentage; // STORAGE[0x8]\nuint256 _payment_delay; // STORAGE[0x9]\nuint256 _count_investors; // STORAGE[0xa]\nuint8 stor_9_0_0; // STORAGE[0x9] bytes 0 to 0\naddress _marketing_wallet; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction max_contribution() public nonPayable { \n    return _max_contribution;\n}\n\nfunction holding(address varg0) public nonPayable { \n    return _holding[varg0];\n}\n\nfunction marketing_wallet() public nonPayable { \n    return _marketing_wallet;\n}\n\nfunction getBonus(uint256 varg0) public nonPayable { \n    v0 = 0x7b7(varg0);\n    return v0;\n}\n\nfunction elapsedTime() public nonPayable { \n    v0 = 0x86a();\n    return v0;\n}\n\nfunction time_stamp(address varg0) public nonPayable { \n    return _time_stamp[varg0];\n}\n\nfunction count_investors() public nonPayable { \n    return _count_investors;\n}\n\nfunction max_percentage() public nonPayable { \n    return _max_percentage;\n}\n\nfunction percentage(address varg0) public nonPayable { \n    return _percentage[varg0];\n}\n\nfunction hourly_percentage() public nonPayable { \n    return _hourly_percentage;\n}\n\nfunction marketing_percent() public nonPayable { \n    return _marketing_percent;\n}\n\nfunction referral_percent() public nonPayable { \n    return _referral_percent;\n}\n\nfunction payment_delay() public nonPayable { \n    return _payment_delay;\n}\n\nfunction 0x59f() private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v2 = v4 = 0x86a();\n    require(v4 > 0, 'You can receive payment 1 time per hour');\n    v0 = v5 = 1655;\n    v6 = v7 = 759;\n    v8 = v9 = 0xf4240;\n    v10 = v11 = 0x8e1(_hourly_percentage, _holding[msg.sender]);\n    while (v8 <= 0) {\n        require(v8 > 0);\n        if (v8) {\n            break;\n        }\n        assert(v8);\n        if (v2 <= v10 / v8) {\n            _percentage[msg.sender] += v0;\n            _time_stamp[msg.sender] = block.timestamp;\n            v12 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v12); // checks call status, propagates error data on error\n        } else {\n            _holding[msg.sender] = 0;\n            _time_stamp[msg.sender] = 0;\n            _time_stamp[msg.sender] = 0;\n            require(v2 - v10 / v8 <= v2);\n            v13 = msg.sender.call().value(v2 - (v2 - v10 / v8)).gas(2300 * !(v2 - (v2 - v10 / v8)));\n            require(v13); // checks call status, propagates error data on error\n        }\n        return v4;\n        goto {'0x2f70x59f', '0x6c7'};\n        v0 = v14 = 0x8e1(v2, v10 / v8);\n        v2 = _SafeAdd(v14, _percentage[msg.sender]);\n        v6 = v15 = 1735;\n        v8 = v16 = 100;\n        v10 = v17 = 0x8e1(_max_percentage, _holding[msg.sender]);\n    }\n}\n\nfunction 0x7b7(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = varg0 < 0x8ac7230489e80000;\n    v3 = v4 = varg0 >= 0x8ac7230489e80000;\n    if (varg0 >= 0x8ac7230489e80000) {\n        v3 = v5 = varg0 < 0x15af1d78b58c40000;\n    }\n    if (!v3) {\n        v6 = v7 = varg0 >= 0x15af1d78b58c40000;\n        if (v7) {\n            v6 = v8 = varg0 < 0x2b5e3af16b1880000;\n        }\n        if (!v6) {\n            if (0x2b5e3af16b1880000 == varg0) {\n                v9 = v10 = 2145;\n                v11 = v12 = 100;\n                v13 = v14 = 0x8e1(1, varg0);\n            }\n        } else {\n            v9 = v15 = 2038;\n            v11 = v16 = 10000;\n            v13 = v17 = 0x8e1(75, varg0);\n        }\n    } else {\n        v9 = v18 = 2038;\n        v11 = v19 = 1000;\n        v13 = v20 = 0x8e1(5, varg0);\n    }\n    require(v11 > 0);\n    assert(v11);\n    v0 = v13 / v11;\n    goto {'0x861', '0x7f6'};\n    return v0;\n}\n\nfunction 0x86a() private { \n    require(_time_stamp[msg.sender] <= block.timestamp);\n    require(_payment_delay > 0);\n    assert(stor_9_0_0);\n    return (block.timestamp - _time_stamp[msg.sender]) / _payment_delay;\n}\n\nfunction 0x8e1(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x05f5e100() public payable { \n    v0 = v1 = 0;\n    v2 = v3 = 0x86a();\n    v4 = v5 = 0 < _holding[msg.sender];\n    if (v5) {\n        v4 = v6 = v3 > 0;\n    }\n    require(v4);\n    v7 = v8 = 771;\n    v9 = v10 = 759;\n    v11 = v12 = 0xf4240;\n    v13 = v14 = 0x8e1(_hourly_percentage, _holding[msg.sender]);\n    while (v11 <= 0) {\n        require(v11 > 0);\n        if (v11) {\n            break;\n        }\n        assert(v11);\n        v15 = v7.call().value(v13 / v11).gas(v2 * !(v13 / v11));\n        require(v15); // checks call status, propagates error data on error\n        _holding[msg.sender] += v0;\n        _time_stamp[msg.sender] = block.timestamp;\n        exit;\n        goto {'0x2f70x9ab', '0x332'};\n        v0 = v16 = 0x8e1(v2, v13 / v11);\n        v7 = v17 = _marketing_wallet;\n        v2 = v18 = 2300;\n        v9 = v19 = 818;\n        v11 = v20 = 100;\n        v13 = 0x8e1(_marketing_percent, v16);\n    }\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        if (!msg.value) {\n            require(_holding[msg.sender] > 0);\n            v0 = 0x59f();\n        }\n    } else if (0x5f5e100 != msg.value) {\n        v1 = v2 = 238;\n        v1 = v3 = 0;\n        v4 = _SafeAdd(msg.value, _holding[msg.sender]);\n        require(v4 <= _max_contribution, 'Maximum Deposit 50 ether');\n        v5 = v6 = _holding[msg.sender] > 0;\n        if (v6) {\n            v7 = 0x86a();\n            v5 = v8 = v7 > 0;\n        }\n        if (v5) {\n            v9 = 0x59f();\n        }\n        if (msg.data.length == 20) {\n            v10 = new bytes[](msg.data.length);\n            CALLDATACOPY(v10.data, 0, msg.data.length);\n            if (msg.sender != address(MEM[20 + v10])) {\n                v11 = v12 = address(MEM[20 + v10]);\n                v13 = v14 = 2300;\n                v15 = v16 = 1217;\n                v17 = v18 = 100;\n                v19 = v20 = 0x8e1(_referral_percent, msg.value);\n            }\n        }\n        if (!_holding[msg.sender]) {\n            _count_investors += 1;\n        }\n        v11 = v21 = _marketing_wallet;\n        v13 = v22 = 2300;\n        v15 = v23 = 1337;\n        v17 = v24 = 100;\n        v19 = v25 = 0x8e1(_marketing_percent, msg.value);\n        require(v17 > 0);\n        assert(v17);\n        goto {'0x539', '0x4c1'};\n        v26 = v11.call().value(v19 / v17).gas(v13 * !(v19 / v17));\n        require(v26); // checks call status, propagates error data on error\n        v27 = v11.call().value(v19 / v17).gas(v13 * !(v19 / v17));\n        require(v27); // checks call status, propagates error data on error\n        v28 = 0x7b7(msg.value);\n        v29 = _SafeAdd(v28, msg.value);\n        _holding[msg.sender] += v29;\n        _time_stamp[msg.sender] = block.timestamp;\n    } else {\n        0x05f5e100();\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x14580027) {\n            max_contribution();\n        } else if (0x39166ee9 == function_selector) {\n            holding(address);\n        } else if (0x40e19609 == function_selector) {\n            marketing_wallet();\n        } else if (0x4aa66b28 == function_selector) {\n            getBonus(uint256);\n        } else if (0x51453f9d == function_selector) {\n            elapsedTime();\n        } else if (0x77a86b76 == function_selector) {\n            time_stamp(address);\n        } else if (0x96b10cdf == function_selector) {\n            count_investors();\n        } else if (0x98fbba9f == function_selector) {\n            max_percentage();\n        } else if (0xa7b7b087 == function_selector) {\n            percentage(address);\n        } else if (0xacb109b4 == function_selector) {\n            hourly_percentage();\n        } else if (0xb1f30979 == function_selector) {\n            marketing_percent();\n        } else if (0xe28bbe62 == function_selector) {\n            referral_percent();\n        } else if (0xe775ec02 == function_selector) {\n            payment_delay();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 21:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _holding; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _percentage; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _time_stamp; // STORAGE[0x2]\nuint256 _marketing_percent; // STORAGE[0x4]\nuint256 _max_contribution; // STORAGE[0x5]\nuint256 _max_percentage; // STORAGE[0x6]\nuint256 _referral_percent; // STORAGE[0x7]\nuint256 _hourly_percentage; // STORAGE[0x8]\nuint256 _payment_delay; // STORAGE[0x9]\nuint256 _count_investors; // STORAGE[0xa]\nuint8 stor_9_0_0; // STORAGE[0x9] bytes 0 to 0\naddress _marketing_wallet; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction max_contribution() public nonPayable { \n    return _max_contribution;\n}\n\nfunction holding(address varg0) public nonPayable { \n    return _holding[varg0];\n}\n\nfunction marketing_wallet() public nonPayable { \n    return _marketing_wallet;\n}\n\nfunction getBonus(uint256 varg0) public nonPayable { \n    v0 = 0x7b7(varg0);\n    return v0;\n}\n\nfunction elapsedTime() public nonPayable { \n    v0 = 0x86a();\n    return v0;\n}\n\nfunction time_stamp(address varg0) public nonPayable { \n    return _time_stamp[varg0];\n}\n\nfunction count_investors() public nonPayable { \n    return _count_investors;\n}\n\nfunction max_percentage() public nonPayable { \n    return _max_percentage;\n}\n\nfunction percentage(address varg0) public nonPayable { \n    return _percentage[varg0];\n}\n\nfunction hourly_percentage() public nonPayable { \n    return _hourly_percentage;\n}\n\nfunction marketing_percent() public nonPayable { \n    return _marketing_percent;\n}\n\nfunction referral_percent() public nonPayable { \n    return _referral_percent;\n}\n\nfunction payment_delay() public nonPayable { \n    return _payment_delay;\n}\n\nfunction 0x59f() private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v2 = v4 = 0x86a();\n    require(v4 > 0, 'You can receive payment 1 time per hour');\n    v0 = v5 = 1655;\n    v6 = v7 = 759;\n    v8 = v9 = 0xf4240;\n    v10 = v11 = 0x8e1(_hourly_percentage, _holding[msg.sender]);\n    while (v8 <= 0) {\n        require(v8 > 0);\n        if (v8) {\n            break;\n        }\n        assert(v8);\n        if (v2 <= v10 / v8) {\n            _percentage[msg.sender] += v0;\n            _time_stamp[msg.sender] = block.timestamp;\n            v12 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v12); // checks call status, propagates error data on error\n        } else {\n            _holding[msg.sender] = 0;\n            _time_stamp[msg.sender] = 0;\n            _time_stamp[msg.sender] = 0;\n            require(v2 - v10 / v8 <= v2);\n            v13 = msg.sender.call().value(v2 - (v2 - v10 / v8)).gas(2300 * !(v2 - (v2 - v10 / v8)));\n            require(v13); // checks call status, propagates error data on error\n        }\n        return v4;\n        goto {'0x2f70x59f', '0x6c7'};\n        v0 = v14 = 0x8e1(v2, v10 / v8);\n        v2 = _SafeAdd(v14, _percentage[msg.sender]);\n        v6 = v15 = 1735;\n        v8 = v16 = 100;\n        v10 = v17 = 0x8e1(_max_percentage, _holding[msg.sender]);\n    }\n}\n\nfunction 0x7b7(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = varg0 < 0x8ac7230489e80000;\n    v3 = v4 = varg0 >= 0x8ac7230489e80000;\n    if (varg0 >= 0x8ac7230489e80000) {\n        v3 = v5 = varg0 < 0x15af1d78b58c40000;\n    }\n    if (!v3) {\n        v6 = v7 = varg0 >= 0x15af1d78b58c40000;\n        if (v7) {\n            v6 = v8 = varg0 < 0x2b5e3af16b1880000;\n        }\n        if (!v6) {\n            if (0x2b5e3af16b1880000 == varg0) {\n                v9 = v10 = 2145;\n                v11 = v12 = 100;\n                v13 = v14 = 0x8e1(1, varg0);\n            }\n        } else {\n            v9 = v15 = 2038;\n            v11 = v16 = 10000;\n            v13 = v17 = 0x8e1(75, varg0);\n        }\n    } else {\n        v9 = v18 = 2038;\n        v11 = v19 = 1000;\n        v13 = v20 = 0x8e1(5, varg0);\n    }\n    require(v11 > 0);\n    assert(v11);\n    v0 = v13 / v11;\n    goto {'0x861', '0x7f6'};\n    return v0;\n}\n\nfunction 0x86a() private { \n    require(_time_stamp[msg.sender] <= block.timestamp);\n    require(_payment_delay > 0);\n    assert(stor_9_0_0);\n    return (block.timestamp - _time_stamp[msg.sender]) / _payment_delay;\n}\n\nfunction 0x8e1(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x05f5e100() public payable { \n    v0 = v1 = 0;\n    v2 = v3 = 0x86a();\n    v4 = v5 = 0 < _holding[msg.sender];\n    if (v5) {\n        v4 = v6 = v3 > 0;\n    }\n    require(v4);\n    v7 = v8 = 771;\n    v9 = v10 = 759;\n    v11 = v12 = 0xf4240;\n    v13 = v14 = 0x8e1(_hourly_percentage, _holding[msg.sender]);\n    while (v11 <= 0) {\n        require(v11 > 0);\n        if (v11) {\n            break;\n        }\n        assert(v11);\n        v15 = v7.call().value(v13 / v11).gas(v2 * !(v13 / v11));\n        require(v15); // checks call status, propagates error data on error\n        _holding[msg.sender] += v0;\n        _time_stamp[msg.sender] = block.timestamp;\n        exit;\n        goto {'0x2f70x9ab', '0x332'};\n        v0 = v16 = 0x8e1(v2, v13 / v11);\n        v7 = v17 = _marketing_wallet;\n        v2 = v18 = 2300;\n        v9 = v19 = 818;\n        v11 = v20 = 100;\n        v13 = 0x8e1(_marketing_percent, v16);\n    }\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        if (!msg.value) {\n            require(_holding[msg.sender] > 0);\n            v0 = 0x59f();\n        }\n    } else if (0x5f5e100 != msg.value) {\n        v1 = v2 = 238;\n        v1 = v3 = 0;\n        v4 = _SafeAdd(msg.value, _holding[msg.sender]);\n        require(v4 <= _max_contribution, 'Maximum Deposit 50 ether');\n        v5 = v6 = _holding[msg.sender] > 0;\n        if (v6) {\n            v7 = 0x86a();\n            v5 = v8 = v7 > 0;\n        }\n        if (v5) {\n            v9 = 0x59f();\n        }\n        if (msg.data.length == 20) {\n            v10 = new bytes[](msg.data.length);\n            CALLDATACOPY(v10.data, 0, msg.data.length);\n            if (msg.sender != address(MEM[20 + v10])) {\n                v11 = v12 = address(MEM[20 + v10]);\n                v13 = v14 = 2300;\n                v15 = v16 = 1217;\n                v17 = v18 = 100;\n                v19 = v20 = 0x8e1(_referral_percent, msg.value);\n            }\n        }\n        if (!_holding[msg.sender]) {\n            _count_investors += 1;\n        }\n        v11 = v21 = _marketing_wallet;\n        v13 = v22 = 2300;\n        v15 = v23 = 1337;\n        v17 = v24 = 100;\n        v19 = v25 = 0x8e1(_marketing_percent, msg.value);\n        require(v17 > 0);\n        assert(v17);\n        goto {'0x539', '0x4c1'};\n        v26 = v11.call().value(v19 / v17).gas(v13 * !(v19 / v17));\n        require(v26); // checks call status, propagates error data on error\n        v27 = v11.call().value(v19 / v17).gas(v13 * !(v19 / v17));\n        require(v27); // checks call status, propagates error data on error\n        v28 = 0x7b7(msg.value);\n        v29 = _SafeAdd(v28, msg.value);\n        _holding[msg.sender] += v29;\n        _time_stamp[msg.sender] = block.timestamp;\n    } else {\n        0x05f5e100();\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x14580027) {\n            max_contribution();\n        } else if (0x39166ee9 == function_selector) {\n            holding(address);\n        } else if (0x40e19609 == function_selector) {\n            marketing_wallet();\n        } else if (0x4aa66b28 == function_selector) {\n            getBonus(uint256);\n        } else if (0x51453f9d == function_selector) {\n            elapsedTime();\n        } else if (0x77a86b76 == function_selector) {\n            time_stamp(address);\n        } else if (0x96b10cdf == function_selector) {\n            count_investors();\n        } else if (0x98fbba9f == function_selector) {\n            max_percentage();\n        } else if (0xa7b7b087 == function_selector) {\n            percentage(address);\n        } else if (0xacb109b4 == function_selector) {\n            hourly_percentage();\n        } else if (0xb1f30979 == function_selector) {\n            marketing_percent();\n        } else if (0xe28bbe62 == function_selector) {\n            referral_percent();\n        } else if (0xe775ec02 == function_selector) {\n            payment_delay();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 20.399643659591675,
	"usage": {
		"completion_tokens": 553,
		"prompt_tokens": 2829,
		"total_tokens": 3382
	}
}