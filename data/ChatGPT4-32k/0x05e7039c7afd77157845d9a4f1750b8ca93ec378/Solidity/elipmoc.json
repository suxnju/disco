{
	"address": "0x05e7039c7afd77157845d9a4f1750b8ca93ec378",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the equivalent Solidity contract code:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract Bankroll {\n    mapping (uint256 => uint256) private _getUserDeposit;\n    address private _owner;\n    bool private _isStopped;\n    \n    event LOG_Bankroll(address indexed owner, uint256 amount);\n    event LOG_ContractStopped();\n    event LOG_Deposit(bytes32 indexed varg0, bytes32 indexed varg1, address sender, uint256 amount);\n    event LOG_Withdraw(address indexed user, uint256 amount);\n    event OwnershipRenounced(address indexed previousOwner);\n    event LOG_ContractResumed();\n    event LOG_OwnerWithdraw(address indexed owner, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner);\n        _;\n    }\n\n    function getUserDeposit(bytes32 varg0, bytes32 varg1) public view returns(uint256) { \n        return _getUserDeposit[uint256(keccak256(abi.encodePacked(varg0, varg1)))];\n    }\n\n    function userWithdraw(address varg0, uint256 varg1) public onlyOwner { \n        require(!_isStopped);\n        require(varg0.send(varg1));\n        emit LOG_Withdraw(varg0, varg1);\n    }\n\n    function isStopped() public view returns(bool) { \n        return _isStopped;\n    }\n\n    function renounceOwnership() public onlyOwner { \n        emit OwnershipRenounced(_owner);\n        _owner = address(0);\n    }\n\n    function owner() public view returns(address) { \n        return _owner;\n    }\n\n    function resumeContract() public onlyOwner { \n        require(_isStopped);\n        _isStopped = false;\n        emit LOG_ContractResumed();\n    }\n\n    function ownerWithdraw(address varg0, uint256 varg1) public onlyOwner { \n        require(address(this).balance > varg1);\n        require(varg0.send(varg1));\n        emit LOG_OwnerWithdraw(varg0, varg1);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner { \n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function() public payable { \n        revert();\n    }\n\n    function bankroll() public payable onlyOwner  { \n        emit LOG_Bankroll(msg.sender, msg.value);\n    }\n\n    function stopContract() public onlyOwner { \n        require(!_isStopped);\n        _isStopped = true;\n        emit LOG_ContractStopped();\n    }\n\n    function userDeposit(bytes32 varg0, bytes32 varg1) public payable { \n        require(!_isStopped);\n        _getUserDeposit[uint256(keccak256(abi.encodePacked(varg0, varg1)))] = msg.value;\n        emit LOG_Deposit(varg0, varg1, msg.sender, msg.value);\n    }\n}\n```\n\nNote: This contract is implemented using Solidity version 0.4.24. Please ensure to use the appropriate compiler version when deploying this contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461255,
	"id": "chatcmpl-8R45P6OLST9D4pNoWpFTpHCpNUl8C",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 17:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getUserDeposit; // STORAGE[0x1]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _isStopped; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nLOG_Bankroll(address, uint256);\nLOG_ContractStopped();\nLOG_Deposit(bytes32, bytes32, address, uint256);\nLOG_Withdraw(address, uint256);\nOwnershipRenounced(address);\nLOG_ContractResumed();\nLOG_OwnerWithdraw(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction getUserDeposit(bytes32 varg0, bytes32 varg1) public nonPayable { \n    return _getUserDeposit[~0x0 & (~0x0 & (~0x0 & varg1))];\n}\n\nfunction userWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(!_isStopped);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit LOG_Withdraw(varg0, varg1);\n}\n\nfunction isStopped() public nonPayable { \n    return _isStopped;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction resumeContract() public nonPayable { \n    require(msg.sender == _owner);\n    require(_isStopped);\n    _isStopped = 0;\n    emit LOG_ContractResumed();\n}\n\nfunction ownerWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance > varg1);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit LOG_OwnerWithdraw(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction bankroll() public payable { \n    require(msg.sender == _owner);\n    emit LOG_Bankroll(msg.sender, msg.value);\n}\n\nfunction stopContract() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_isStopped);\n    _isStopped = 1;\n    emit LOG_ContractStopped();\n}\n\nfunction userDeposit(bytes32 varg0, bytes32 varg1) public payable { \n    require(!_isStopped);\n    _getUserDeposit[~0x0 & (~0x0 & (~0x0 & varg1))] = msg.value;\n    emit LOG_Deposit(~0x0 & (~0x0 & (~0x0 & varg0)), ~0x0 & (~0x0 & (~0x0 & varg1)), msg.sender, msg.value);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xc657eb0 == function_selector) {\n            bankroll();\n        } else if (0x12253a6c == function_selector) {\n            stopContract();\n        } else if (0x12ba0598 == function_selector) {\n            userDeposit(bytes32,bytes32);\n        } else if (0x370f8b48 == function_selector) {\n            getUserDeposit(bytes32,bytes32);\n        } else if (0x3e458a8e == function_selector) {\n            userWithdraw(address,uint256);\n        } else if (0x3f683b6a == function_selector) {\n            isStopped();\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc4bc5da5 == function_selector) {\n            resumeContract();\n        } else if (0xd9c88e14 == function_selector) {\n            ownerWithdraw(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 17:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getUserDeposit; // STORAGE[0x1]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _isStopped; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nLOG_Bankroll(address, uint256);\nLOG_ContractStopped();\nLOG_Deposit(bytes32, bytes32, address, uint256);\nLOG_Withdraw(address, uint256);\nOwnershipRenounced(address);\nLOG_ContractResumed();\nLOG_OwnerWithdraw(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction getUserDeposit(bytes32 varg0, bytes32 varg1) public nonPayable { \n    return _getUserDeposit[~0x0 & (~0x0 & (~0x0 & varg1))];\n}\n\nfunction userWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(!_isStopped);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit LOG_Withdraw(varg0, varg1);\n}\n\nfunction isStopped() public nonPayable { \n    return _isStopped;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction resumeContract() public nonPayable { \n    require(msg.sender == _owner);\n    require(_isStopped);\n    _isStopped = 0;\n    emit LOG_ContractResumed();\n}\n\nfunction ownerWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance > varg1);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit LOG_OwnerWithdraw(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction bankroll() public payable { \n    require(msg.sender == _owner);\n    emit LOG_Bankroll(msg.sender, msg.value);\n}\n\nfunction stopContract() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_isStopped);\n    _isStopped = 1;\n    emit LOG_ContractStopped();\n}\n\nfunction userDeposit(bytes32 varg0, bytes32 varg1) public payable { \n    require(!_isStopped);\n    _getUserDeposit[~0x0 & (~0x0 & (~0x0 & varg1))] = msg.value;\n    emit LOG_Deposit(~0x0 & (~0x0 & (~0x0 & varg0)), ~0x0 & (~0x0 & (~0x0 & varg1)), msg.sender, msg.value);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xc657eb0 == function_selector) {\n            bankroll();\n        } else if (0x12253a6c == function_selector) {\n            stopContract();\n        } else if (0x12ba0598 == function_selector) {\n            userDeposit(bytes32,bytes32);\n        } else if (0x370f8b48 == function_selector) {\n            getUserDeposit(bytes32,bytes32);\n        } else if (0x3e458a8e == function_selector) {\n            userWithdraw(address,uint256);\n        } else if (0x3f683b6a == function_selector) {\n            isStopped();\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc4bc5da5 == function_selector) {\n            resumeContract();\n        } else if (0xd9c88e14 == function_selector) {\n            ownerWithdraw(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 17:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getUserDeposit; // STORAGE[0x1]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _isStopped; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nLOG_Bankroll(address, uint256);\nLOG_ContractStopped();\nLOG_Deposit(bytes32, bytes32, address, uint256);\nLOG_Withdraw(address, uint256);\nOwnershipRenounced(address);\nLOG_ContractResumed();\nLOG_OwnerWithdraw(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction getUserDeposit(bytes32 varg0, bytes32 varg1) public nonPayable { \n    return _getUserDeposit[~0x0 & (~0x0 & (~0x0 & varg1))];\n}\n\nfunction userWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(!_isStopped);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit LOG_Withdraw(varg0, varg1);\n}\n\nfunction isStopped() public nonPayable { \n    return _isStopped;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction resumeContract() public nonPayable { \n    require(msg.sender == _owner);\n    require(_isStopped);\n    _isStopped = 0;\n    emit LOG_ContractResumed();\n}\n\nfunction ownerWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance > varg1);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit LOG_OwnerWithdraw(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction bankroll() public payable { \n    require(msg.sender == _owner);\n    emit LOG_Bankroll(msg.sender, msg.value);\n}\n\nfunction stopContract() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_isStopped);\n    _isStopped = 1;\n    emit LOG_ContractStopped();\n}\n\nfunction userDeposit(bytes32 varg0, bytes32 varg1) public payable { \n    require(!_isStopped);\n    _getUserDeposit[~0x0 & (~0x0 & (~0x0 & varg1))] = msg.value;\n    emit LOG_Deposit(~0x0 & (~0x0 & (~0x0 & varg0)), ~0x0 & (~0x0 & (~0x0 & varg1)), msg.sender, msg.value);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xc657eb0 == function_selector) {\n            bankroll();\n        } else if (0x12253a6c == function_selector) {\n            stopContract();\n        } else if (0x12ba0598 == function_selector) {\n            userDeposit(bytes32,bytes32);\n        } else if (0x370f8b48 == function_selector) {\n            getUserDeposit(bytes32,bytes32);\n        } else if (0x3e458a8e == function_selector) {\n            userWithdraw(address,uint256);\n        } else if (0x3f683b6a == function_selector) {\n            isStopped();\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc4bc5da5 == function_selector) {\n            resumeContract();\n        } else if (0xd9c88e14 == function_selector) {\n            ownerWithdraw(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 35.81332445144653,
	"usage": {
		"completion_tokens": 661,
		"prompt_tokens": 1102,
		"total_tokens": 1763
	}
}