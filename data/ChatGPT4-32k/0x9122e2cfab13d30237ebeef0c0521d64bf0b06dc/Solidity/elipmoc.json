{
	"address": "0x9122e2cfab13d30237ebeef0c0521d64bf0b06dc",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code based on the decompiled code:\n\n```solidity\npragma solidity ^0.5.17;\n\ncontract Lottery {\n    address owner;\n    uint256 prizePool;\n    mapping (uint256 => uint256[]) public gameDetails;\n    uint256 currentGameId;\n    mapping (uint256 => mapping(address => uint256[])) public userTickets;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function closeContract() public {\n        require(msg.sender == owner, \"Only owner can close contract\");\n        selfdestruct(msg.sender);\n    }\n\n    function getTicketPrice() public pure returns(uint256) {\n        return 0.01 ether;\n    }\n\n    function getGameDetails(uint256 _gameId) public view returns(uint256, uint256, uint256[] memory, uint256) {\n        return (gameDetails[_gameId][2], gameDetails[_gameId][11], gameDetails[_gameId], gameDetails[_gameId][1]);\n    }\n\n    function setNewOwner(address _newOwner) public {\n        require(msg.sender == owner, \"Only owner can set new owner\");\n        owner = _newOwner;\n    }\n\n    function addFunds() public payable {\n        require(msg.sender == owner, \"Only owner can add funds\");\n    }\n\n    function getCurrentGameId() public view returns(uint256) {\n        return currentGameId;\n    }\n\n    function purchaseTicket(uint256 _gameId, uint256 _numberOfTickets) public payable {\n        require(msg.value >= getTicketPrice() * _numberOfTickets, \"Insufficient ether to buy tickets\");\n        for(uint256 i = 0; i < _numberOfTickets; i++) {\n            userTickets[_gameId][msg.sender].push(block.timestamp);\n        }\n    }\n\n    function claimPrize(uint256 _gameId) public {\n        require(block.timestamp > gameDetails[_gameId][1], \"Game is still in progress\");\n        // Logic to distribute prize\n    }\n\n    function checkBalance(address _address) public view returns(uint256) {\n        return _address.balance;\n    }\n\n    function checkTickets(address _address, uint256 _gameId, uint256 _ticketNumber) public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        return (userTickets[_gameId][_address][_ticketNumber], 0, 0, 0, 0, 0, 0);\n    }\n\n    function startDraw(string memory _secretKey, bytes32 _newSecretKeyHash) public {\n        require(msg.sender == owner, \"Only owner can start draw\");\n        // Logic to start draw\n    }\n\n    function getFee() public payable {\n        require(msg.sender == owner, \"Only owner can get fee\");\n    }\n\n    function drawError() public {\n        require(msg.sender == owner, \"Only owner can declare draw error\");\n    }\n\n    function getContractStatus() public view returns(uint256) {\n        return owner.balance;\n    }\n\n    function getDrawDetails(uint256 _gameId) public view returns(uint256, uint256, uint256[] memory, uint256) {\n        return (gameDetails[_gameId][2], gameDetails[_gameId][11], gameDetails[_gameId], gameDetails[_gameId][1]);\n    }\n}\n```\n\nPlease note that this is a rough translation based on the decompiled code. Some functionality (such as the logic to distribute prizes and start draws) is not clear from the decompiled code and has been omitted. You may need to modify this to suit your exact requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039381,
	"id": "chatcmpl-8ChttWqyutjY5KpMz5xRGTYHwhFiY",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 15:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 owner_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_5; // STORAGE[0x5]\naddress owner_0_0_19; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction AdminCloseContract() public payable { \n    assert(msg.sender == owner_0_0_19);\n    if (0xff & owner_1 >> 160) {\n        owner_1 = ~0xff0000000000000000000000000000000000000000 & owner_1;\n    } else {\n        assert(owner_3[stor_4][11] == 0);\n        v0 = v1 = (address(this)).balance;\n        v2 = v3 = 0;\n        while (v2 < stor_4) {\n            v0 = v0 - owner_3[v2][7];\n            v2 += 1;\n        }\n        v4 = owner_0_0_19.call().value(~0x56bc75e2d630fffff + (v0 + owner_3[v2][2]));\n        assert(0 != v4);\n        stor_2 = 0;\n    }\n}\n\nfunction ticketPrice() public payable { \n    return 0x2386f26fc10000;\n}\n\nfunction GameDetails(uint256 GameId) public payable { \n    return owner_3[GameId][2], owner_3[GameId][11], owner_3[GameId], owner_3[GameId][1];\n}\n\nfunction Information() public payable { \n    v0 = new array[](v1.length);\n    v2 = v1.data;\n    v3, v4 = dataCopy('http://c.ethereumlottery.net');\n    if (28) {\n        MEM[v0.data] = ~0xffffffff & v4;\n    }\n    return v0;\n}\n\nfunction AdminSetDrawer(address NewDrawer) public payable { \n    assert(msg.sender == owner_0_0_19);\n    owner_1 = NewDrawer | ~0xffffffffffffffffffffffffffffffffffffffff & owner_1;\n}\n\nfunction AdminDrawProcess() public payable { \n    v0 = msg.sender != address(owner_1);\n    if (msg.sender != address(owner_1)) {\n        v0 = v1 = msg.sender != owner_0_0_19;\n    }\n    assert(!v0);\n    assert(1 == 0xff & owner_3[stor_4][0x8]);\n    v2 = v3 = 80;\n    if (owner_3[stor_4][12] < owner_3[stor_4][11]) {\n        v4 = STORAGE[12 + keccak256(stor_4, 3)];\n        while (v4 <= owner_3[stor_4][11]) {\n            if (0 != v2) {\n                v5 = v6 = 0;\n                while (v5 < 5) {\n                    v7 = v8 = 0;\n                    while (v7 < 5) {\n                        assert(v7 < 5);\n                        if (STORAGE[5 + keccak256(stor_4, 3) + (v7 >> 5)] / 256 ** (v7 % 32) & 0xff == 0xff & (0xffffffffff & STORAGE[1 + keccak256(v4, 10 + keccak256(stor_4))] << 216 >> 216) / 256 ** v5) {\n                            owner_3[stor_4] += 1;\n                        }\n                        v7 += 1;\n                    }\n                    v5 += 1;\n                }\n                owner_3[stor_4][12] += 1;\n                v2 += ~0;\n                v4 += 1;\n                continue;\n            }\n        }\n    }\n    if (owner_3[stor_4][12] >= owner_3[stor_4][11]) {\n        v9 = v10 = 0;\n        while (v9 < owner_3[stor_4][11]) {\n            if (3 != STORAGE[keccak256(v9, 10 + keccak256(stor_4, 3))]) {\n                if (owner_3[stor_4] != 4) {\n                    if (5 == owner_3[stor_4]) {\n                        owner_3[stor_4][1] += 1;\n                    }\n                } else {\n                    owner_3[stor_4][1] += 1;\n                }\n            } else {\n                owner_3[stor_4][1] += 1;\n            }\n            v9 += 1;\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = 35 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = 25 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = owner_3[stor_4][2] / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] != 0) {\n            v11 = v12 = 0x56bc75e2d63100000;\n        } else {\n            v11 = 40 * owner_3[stor_4][7] / 100 + owner_3[stor_4][2];\n        }\n        owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n        stor_4 += 1;\n        owner_3[1 + stor_4] = block.number;\n        owner_3[1 + stor_4][2] = v11;\n        owner_3[1 + stor_4][3] = owner_3[stor_4][13];\n        owner_3[1 + stor_4][8] = ~0xff & owner_3[1 + stor_4][0x8];\n        goto 0x1c9b0x26c;\n    }\n}\n\nfunction AdminAddFunds() public payable { \n    assert(msg.sender == owner_0_0_19);\n}\n\nfunction CurrentGameId() public payable { \n    return stor_4;\n}\n\nfunction UserAddTicket(bytes5[] tickets) public payable { \n    assert(0xff & owner_1 >> 160);\n    assert(0xff & owner_3[stor_4][0x8] == 0);\n    assert((?).length <= 70);\n    assert(msg.value >= (?).length * 0x2386f26fc10000);\n    if (msg.value > (?).length * 0x2386f26fc10000) {\n        v0 = msg.sender.call().value(msg.value - (?).length * 0x2386f26fc10000);\n        assert(0 != v0);\n    }\n    v1 = v2 = 0;\n    while (v1 < (?).length) {\n        assert(v1 < (?).length);\n        v3 = v4 = MEM[64];\n        MEM[64] = v4 + 160;\n        v5 = v6 = 5;\n        do {\n            MEM[v3] = 0;\n            v3 += 32;\n            v5 = v5 - 1;\n        } while (!v5);\n        MEM[v4] = 0xff & ((0xffffffffff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8) >> 8 & 0xffffffffff) >> 8;\n        MEM[v4 + 32] = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8) >> 8;\n        MEM[v4 + 64] = 0xff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8;\n        MEM[v4 + 96] = 0xff & (0xffffffffff & (?)[v1] >> 216) >> 8;\n        MEM[v4 + 128] = (?)[v1] >> 216 & 0xff;\n        v7 = v8 = 0;\n        while (0xff & v7 < 5) {\n            assert(0xff & v7 < 5);\n            v9 = v10 = 0xff & MEM[((0xff & v7) << 5) + v4] < 1;\n            if (0xff & MEM[((0xff & v7) << 5) + v4] >= 1) {\n                assert(v7 & 0xff < 5);\n                v9 = v11 = 0xff & MEM[((v7 & 0xff) << 5) + v4] > 30;\n            }\n            if (!v9) {\n                v12 = v13 = 0;\n                while (0xff & v12 < 5) {\n                    assert(0xff & v12 < 5);\n                    assert(0xff & v7 < 5);\n                    v14 = v15 = 0xff & MEM[((0xff & v7) << 5) + v4] == 0xff & MEM[((0xff & v12) << 5) + v4];\n                    if (v15) {\n                        v14 = v16 = 0xff & v7 != 0xff & v12;\n                    }\n                    if (!v14) {\n                        v12 += 1;\n                    } else {\n                        v17 = v18 = 0;\n                        goto 0x104e0x2dd;\n                    }\n                }\n                v7 += 1;\n            } else {\n                v17 = v19 = 0;\n                goto 0x104e0x2dd;\n            }\n        }\n        v17 = v20 = 1;\n        assert(v17);\n        owner_3[stor_4][11] += 1;\n        assert(v1 < (?).length);\n        STORAGE[1 + keccak256(STORAGE[keccak256(stor_4, 3) + 11], 10 + keccak256(stor_4, 3))] = (?)[v1] >> 216 | ~0xffffffffff & STORAGE[1 + keccak256(STORAGE[keccak256(stor_4, 3) + 11], 10 + keccak256(stor_4, 3))];\n        owner_5[stor_4][1] = owner_5[stor_4][1] + 1;\n        if (!owner_5[stor_4][1] <= owner_5[stor_4][1] + 1) {\n            v21 = v22 = keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5))) + (owner_5[stor_4][1] + 1);\n            while (keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5))) + owner_5[stor_4][1] > v21) {\n                STORAGE[v21] = 0;\n                v21 += 1;\n            }\n        }\n        assert(owner_3[msg.sender][1] + ~0 < owner_3[msg.sender][1]);\n        STORAGE[owner_3[msg.sender][1] + ~0 + keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5)))] = owner_3[stor_4][11];\n        v1 += 1;\n    }\n}\n\nfunction UserGetPrize() public payable { \n    v0 = v1 = 0;\n    while (v0 < stor_4) {\n        if (0xff & owner_5[v0] == 0) {\n            if (2 != 0xff & owner_3[v0][0x8]) {\n                if (0xff & owner_3[v0][0x8] == 3) {\n                    v0 = v2 = v0 + 0x2386f26fc10000 * owner_5[v0][1];\n                }\n            } else {\n                v3 = v4 = 0;\n                while (v3 < owner_5[v0][1]) {\n                    assert(v3 < owner_3[v0][1]);\n                    if (3 != STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                        assert(v3 < owner_3[v0][1]);\n                        if (4 != STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                            assert(v3 < owner_3[v0][1]);\n                            if (5 == STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                                v0 = v0 + owner_3[v0];\n                            }\n                        } else {\n                            v0 = v0 + owner_3[v0];\n                        }\n                    } else {\n                        v0 = v0 + owner_3[v0][0];\n                    }\n                    v3 += 1;\n                }\n                goto 0x1268;\n            }\n            v0 = v5 = 0;\n            owner_5[v0] = 0x1 | ~0xff & owner_5[v0];\n            owner_3[v0][7] = owner_3[v0][7] - v0;\n            v0 += v0;\n        }\n        v0 += 1;\n    }\n    assert(v0 > 0);\n    v6 = msg.sender.call().value(v0);\n    assert(0 != v6);\n}\n\nfunction UserCheckBalance(address addr) public payable { \n    v0 = v1 = 0;\n    while (v0 < stor_4) {\n        if (0xff & owner_5[v0] == 0) {\n            if (2 != 0xff & owner_3[v0][0x8]) {\n                if (0xff & owner_3[v0][0x8] == 3) {\n                    v0 = v0 + 0x2386f26fc10000 * owner_5[v0][1];\n                }\n            } else {\n                v2 = v3 = 0;\n                while (v2 < owner_5[v0][1]) {\n                    assert(v2 < owner_3[v0][1]);\n                    if (3 != STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                        assert(v2 < owner_3[v0][1]);\n                        if (4 != STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                            assert(v2 < owner_3[v0][1]);\n                            if (5 == STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                                v0 = v0 + owner_3[v0];\n                            }\n                        } else {\n                            v0 = v0 + owner_3[v0];\n                        }\n                    } else {\n                        v0 = v0 + owner_3[v0];\n                    }\n                    v2 += 1;\n                }\n            }\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction CheckTickets(address Address, uint256 GameId, uint256 TicketNumber) public payable { \n    v0 = v1 = MEM[64];\n    v2 = v3 = 5;\n    do {\n        MEM[v0] = 0;\n        v0 += 32;\n        v2 = v2 - 1;\n    } while (!v2);\n    v4 = v5 = 0;\n    assert(TicketNumber < owner_5[Address][1]);\n    if (STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))] > v5) {\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(0 < 5);\n        v6 = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & (0xffffffffff & STORAGE[1 + keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], 10 + keccak256(GameId, 3))] << 216 >> 216) >> 8) >> 8) >> 8) >> 8;\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(1 < 5);\n        v7 = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & STORAGE[1 + keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], keccak256(GameId, 3) + 10)] << 216 >> 216) >> 8) >> 8) >> 8;\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(TicketNumber < owner_3[Address][1]);\n        v8 = v9 = MEM[64];\n        v10 = v11 = 5;\n        do {\n            MEM[v8] = 0;\n            v8 += 32;\n            v10 = v10 - 1;\n        } while (!v10);\n        v12 = v13 = 0;\n        while (0xff & v12 < 5) {\n            v14 = 1 + v12;\n            while (0xff & v14 < 5) {\n                assert(0xff & v14 < 5);\n                assert(0xff & v12 < 5);\n                if (0xff & MEM[((0xff & v12) << 5) + v1] > 0xff & MEM[((0xff & v14) << 5) + v1]) {\n                    assert(0xff & v12 < 5);\n                    assert(v14 & 0xff < 5);\n                    assert(v12 & 0xff < 5);\n                    MEM[v1 + ((v12 & 0xff) << 5)] = 0xff & MEM[((v14 & 0xff) << 5) + v1];\n                    assert(v14 & 0xff < 5);\n                    MEM[((v14 & 0xff) << 5) + v1] = 0xff & MEM[v1 + ((0xff & v12) << 5)];\n                }\n                v14 += 1;\n            }\n            v12 += 1;\n        }\n        assert(TicketNumber < owner_3[Address][1]);\n        v4 = v15 = STORAGE[keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], 10 + keccak256(GameId, 3))];\n        v4 = v16 = 0xff & owner_5[Address];\n    }\n    return v17, v17, v17, v17, v17, v4, v4;\n}\n\nfunction AdminStartDraw(string secret_Key, bytes32 New_secret_Key_Hash) public payable { \n    v0 = v1 = secret_Key + 36;\n    v2 = v3 = msg.sender != address(owner_1);\n    if (msg.sender != address(owner_1)) {\n        v2 = v4 = msg.sender != owner_0_0_19;\n    }\n    assert(!v2);\n    assert(0xff & owner_3[stor_4][0x8] == 0);\n    owner_3[stor_4][1] = block.number;\n    CALLDATACOPY(v5.data, v1, (?).length);\n    if (keccak256(v5.data) == owner_3[stor_4][3]) {\n        owner_3[stor_4][8] = 0x1 | ~0xff & owner_3[stor_4][0x8];\n        owner_3[stor_4][13] = New_secret_Key_Hash;\n        if (31 < (?).length) {\n            owner_3[stor_4][4] = 1 + ((?).length + (?).length);\n            if ((?).length) {\n                while (v1 + (?).length > v0) {\n                    STORAGE[v6] = msg.data[v0];\n                    v0 += 32;\n                    v6 += 1;\n                }\n            }\n        } else {\n            owner_3[stor_4][4] = (?).length + (?).length | ~0xff & msg.data[v1];\n        }\n        while (v7 + (31 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) >> 5) > v6) {\n            STORAGE[v6] = 0;\n            v6 += 1;\n        }\n        v8 = v9 = v9.data;\n        if ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) {\n            if (31 < (owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) {\n                v8 = v10 = v9 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1);\n                do {\n                    MEM[v8] = STORAGE[v11];\n                    v11 += 1;\n                    v8 += 32;\n                } while (v10 <= v8);\n            } else {\n                MEM[v9] = owner_3[stor_4][4] >> 8 << 8;\n                v8 = v12 = ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) + v9;\n            }\n        }\n        MEM[v8] = owner_3[stor_4][3];\n        MEM[32 + v8] = owner_3[stor_4][11];\n        MEM[64 + v8] = block.timestamp;\n        v13 = v14 = v9.data;\n        owner_3[stor_4][9] = keccak256(v9);\n        v15 = v16 = owner_3[stor_4][9];\n        v17 = v18 = 5;\n        do {\n            MEM[v13] = 0;\n            v13 += 32;\n            v17 = v17 - 1;\n        } while (!v17);\n        v19 = v20 = 0;\n        while (0xff & v19 < 5) {\n            while (1) {\n                v21 = v22 = 1;\n                if (v19 != 32) {\n                    goto 0x1f88;\n                }\n                v15 = v23 = keccak256(v15);\n                v19 = v24 = 0;\n                v19 += 1;\n                v25 = v26 = 0;\n                while (0xff & v25 < 5) {\n                    assert(0xff & v25 < 5);\n                    if (0xff & MEM[((0xff & v25) << 5) + v14] != 0xff & 1 + (0xff & v15 * 2 ** (v19 << 3) >> 248 << 248 >> 248) % 30) {\n                        v25 += 1;\n                    } else {\n                        v21 = v27 = 0;\n                    }\n                }\n                if (1 != v21) {\n                    continue;\n                } else {\n                    assert(0xff & v19 < 5);\n                    MEM[((0xff & v19) << 5) + v14] = 0xff & 1 + (0xff & v15 * 2 ** (v19 << 3) >> 248 << 248 >> 248) % 30;\n                    v19 += 1;\n                    continue;\n                }\n            }\n        }\n        v28 = v29 = MEM[64];\n        MEM[64] = v29 + 160;\n        v30 = v31 = 5;\n        do {\n            MEM[v28] = 0;\n            v28 += 32;\n            v30 = v30 - 1;\n        } while (!v30);\n        v32 = v33 = 0;\n        while (0xff & v32 < 5) {\n            v34 = 1 + v32;\n            while (0xff & v34 < 5) {\n                assert(0xff & v34 < 5);\n                assert(0xff & v32 < 5);\n                if (0xff & MEM[((0xff & v32) << 5) + v14] > 0xff & MEM[((0xff & v34) << 5) + v14]) {\n                    assert(0xff & v32 < 5);\n                    assert(v34 & 0xff < 5);\n                    assert(v32 & 0xff < 5);\n                    MEM[v14 + ((v32 & 0xff) << 5)] = 0xff & MEM[((v34 & 0xff) << 5) + v14];\n                    assert(v34 & 0xff < 5);\n                    MEM[((v34 & 0xff) << 5) + v14] = 0xff & MEM[v14 + ((0xff & v32) << 5)];\n                }\n                v34 += 1;\n            }\n            v32 += 1;\n        }\n        v35 = v36 = 0;\n        v37 = v38 = keccak256(stor_4, 3) + 5;\n        while (v14 + 160 > v13) {\n            STORAGE[v37] = MEM[v13] * 256 ** v35 | ~(255 * 256 ** v35) & STORAGE[v37];\n            v13 += 32;\n            v37 += 1 + v35 >> 5;\n            v35 = (1 - (1 + v35 >> 5)) * (1 + v35);\n        }\n        while (v35) {\n            STORAGE[v37] = ~(255 * 256 ** v35) & STORAGE[v37];\n            v37 += 1 + v35 >> 5;\n            v35 = (1 - (1 + v35 >> 5)) * (1 + v35);\n        }\n        v39 = v40 = 8387;\n        while (6 + keccak256(stor_4, 3) > v37) {\n            STORAGE[v37] = ~0xff & STORAGE[v37];\n            v37 += 1;\n        }\n    } else {\n        owner_3[stor_4][7] = 0x2386f26fc10000 * owner_3[stor_4][11];\n        owner_3[stor_4][8] = 0x3 | ~0xff & owner_3[stor_4][0x8];\n        if (31 < (?).length) {\n            owner_3[stor_4][4] = 1 + ((?).length + (?).length);\n            if ((?).length) {\n                while (v1 + (?).length > v0) {\n                    STORAGE[v41] = msg.data[v0];\n                    v0 += 32;\n                    v41 += 1;\n                }\n            }\n        } else {\n            owner_3[stor_4][4] = ~0xff & msg.data[v1] | (?).length + (?).length;\n        }\n        v39 = v42 = 7680;\n        while (v43 + (31 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) >> 5) > v41) {\n            STORAGE[v41] = 0;\n            v41 += 1;\n        }\n    }\n    goto {'0x1e00', '0x20c3'};\n    stor_4 += 1;\n    owner_3[1 + stor_4] = block.number;\n    owner_3[stor_4][2] = owner_3[stor_4][2];\n    owner_3[stor_4][3] = New_secret_Key_Hash;\n    owner_3[stor_4][8] = ~0xff & owner_3[stor_4][0x8];\n    return 0;\n    if (owner_3[stor_4][11] <= 1) {\n        owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n    } else {\n        stor_2 = stor_2 + STORAGE[keccak256(stor_4, 3) + 11] * 0x3311fc80a570000 / 100;\n        STORAGE[7 + keccak256(stor_4, 3)] = 0x2386f26fc10000 * STORAGE[keccak256(stor_4, 3) + 11] - (stor_2 + STORAGE[keccak256(stor_4, 3) + 11] * 0x3311fc80a570000 / 100);\n        v44 = v45 = msg.sender != address(owner_1);\n        if (msg.sender != address(owner_1)) {\n            v44 = v46 = msg.sender != owner_0_0_19;\n        }\n        assert(!v44);\n        assert(1 == 0xff & owner_3[stor_4][0x8]);\n        v47 = v48 = 80;\n        if (owner_3[stor_4][12] < owner_3[stor_4][11]) {\n            v49 = v50 = STORAGE[12 + keccak256(stor_4, 3)];\n            while (v49 <= owner_3[stor_4][11]) {\n                if (0 != v47) {\n                    v51 = v52 = 0;\n                    while (v51 < 5) {\n                        v53 = v54 = 0;\n                        while (v53 < 5) {\n                            assert(v53 < 5);\n                            if (STORAGE[5 + keccak256(stor_4, 3) + (v53 >> 5)] / 256 ** (v53 % 32) & 0xff == 0xff & (0xffffffffff & STORAGE[1 + keccak256(v49, 10 + keccak256(stor_4))] << 216 >> 216) / 256 ** v51) {\n                                owner_3[stor_4] += 1;\n                            }\n                            v53 += 1;\n                        }\n                        v51 += 1;\n                    }\n                    owner_3[stor_4][12] += 1;\n                    v47 += ~0;\n                    v49 += 1;\n                    continue;\n                }\n            }\n        }\n        if (owner_3[stor_4][12] >= owner_3[stor_4][11]) {\n            v55 = v56 = 0;\n            while (v55 < owner_3[stor_4][11]) {\n                if (3 != STORAGE[keccak256(v55, 10 + keccak256(stor_4, 3))]) {\n                    if (owner_3[stor_4] != 4) {\n                        if (5 == owner_3[stor_4]) {\n                            owner_3[stor_4][1] += 1;\n                        }\n                    } else {\n                        owner_3[stor_4][1] += 1;\n                    }\n                } else {\n                    owner_3[stor_4][1] += 1;\n                }\n                v55 += 1;\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = 35 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = 25 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = owner_3[stor_4][2] / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] != 0) {\n                v57 = v58 = 0x56bc75e2d63100000;\n            } else {\n                v57 = v59 = 40 * owner_3[stor_4][7] / 100 + owner_3[stor_4][2];\n            }\n            owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n            stor_4 += 1;\n            owner_3[1 + stor_4] = block.number;\n            owner_3[1 + stor_4][2] = v57;\n            owner_3[1 + stor_4][3] = owner_3[stor_4][13];\n            owner_3[1 + stor_4][8] = ~0xff & owner_3[1 + stor_4][0x8];\n            goto 0x1c9b0x270B0x20e4;\n        }\n        goto 0x1e21;\n    }\n}\n\nfunction AdminGetFee() public payable { \n    assert(msg.sender == owner_0_0_19);\n    v0 = owner_0_0_19.call().value(stor_2);\n    assert(0 != v0);\n    stor_2 = 0;\n}\n\nfunction AdminDrawError() public payable { \n    v0 = v1 = address(owner_1) != msg.sender;\n    if (address(owner_1) != msg.sender) {\n        v0 = v2 = msg.sender != owner_0_0_19;\n    }\n    assert(!v0);\n    assert(1 == 0xff & owner_3[stor_4][0x8]);\n    owner_3[stor_4][7] = 0x2386f26fc10000 * owner_3[stor_4][11];\n    owner_3[stor_4][8] = 0x3 | ~0xff & owner_3[stor_4][0x8];\n    stor_4 += 1;\n    owner_3[1 + stor_4] = block.number;\n    owner_3[stor_4][2] = owner_3[stor_4][2];\n    owner_3[stor_4][3] = owner_3[stor_4][13];\n    owner_3[stor_4][8] = ~0xff & owner_3[stor_4][0x8];\n}\n\nfunction ContractStatus() public payable { \n    return 0xff & owner_1 >> 160;\n}\n\nfunction DrawDetails(uint256 GameId) public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 5;\n    do {\n        MEM[v0] = 0;\n        v0 += 32;\n        v2 = v2 - 1;\n    } while (!v2);\n    v4 = v5 = MEM[64];\n    MEM[v5] = 0;\n    if (0xff & owner_3[GameId][0x8] != 0) {\n        if (0xff & owner_3[GameId][0x8] != 1) {\n            if (0xff & owner_3[GameId][0x8] != 2) {\n                if (0xff & owner_3[GameId][0x8] == 3) {\n                    v4 = v6 = 'Failed';\n                    goto 0xc96;\n                }\n            } else {\n                v4 = v7 = 0x446f6e6500000000000000000000000000000000000000000000000000000000;\n            }\n        } else {\n            v4 = v8 = 'In Process';\n        }\n    } else {\n        v4 = v9 = 0x5761697400000000000000000000000000000000000000000000000000000000;\n    }\n    if (0xff & owner_3[GameId][0x8] == 0) {\n        v10 = v11 = MEM[64];\n        v12 = v13 = 0;\n        MEM[v11] = v13;\n        v14 = v15 = MEM[64];\n        MEM[v15] = v13;\n        MEM[v15 + 32] = v13;\n        MEM[v15 + 64] = v13;\n        MEM[v15 + 96] = v13;\n        MEM[v15 + 128] = v13;\n    } else {\n        v10 = v16 = new bytes[](v17);\n        v17 = (STORAGE[4 + keccak256(GameId, 3)] & ~0 + (!(STORAGE[4 + keccak256(GameId, 3)] & 0x1) << 8)) >> 1;\n        v18 = v19 = v16.data;\n        if (v17) {\n            if (31 < v17) {\n                do {\n                    MEM[v18] = STORAGE[v20];\n                    v20 += 1;\n                    v18 += 32;\n                } while (v19 + v17 <= v18);\n            } else {\n                MEM[v19] = STORAGE[4 + keccak256(GameId, 3)] >> 8 << 8;\n            }\n        }\n        v21 = v22 = 0;\n        v14 = v23 = MEM[64];\n        v24 = v25 = 5 + keccak256(GameId, 3);\n        do {\n            MEM[v14] = 0xff & STORAGE[v24] / 256 ** v21;\n            v24 += 1 + v21 >> 5;\n            v21 = (1 + v21) * (1 - (1 + v21 >> 5));\n            v14 += 32;\n        } while (v23 + 160 <= v14);\n        v12 = v26 = owner_3[3][1];\n        v12 = v27 = owner_3[4][1];\n        v12 = v28 = owner_3[5][1];\n        v12 = v29 = owner_3[3][0];\n        v12 = v30 = owner_3[4][0];\n        v12 = v31 = owner_3[5][0];\n        v12 = v32 = owner_3[5][9];\n        goto 0xd72;\n    }\n    MEM[MEM[64]] = owner_3[GameId][3];\n    MEM[MEM[64] + 96] = v12;\n    v33 = dataCopy(MEM[v14 len 160], MEM[(MEM[64] + 128) len 160]);\n    MEM[160 + (MEM[64] + 128)] = v12;\n    MEM[192 + (MEM[64] + 128)] = v12;\n    MEM[224 + (MEM[64] + 128)] = v12;\n    MEM[256 + (MEM[64] + 128)] = v12;\n    MEM[288 + (MEM[64] + 128)] = v12;\n    MEM[320 + (MEM[64] + 128)] = v12;\n    MEM[MEM[64] + 32] = 480;\n    MEM[352 + (MEM[64] + 128)] = MEM[v10];\n    v34 = dataCopy(MEM[(32 + v10) len (MEM[v10])], MEM[(384 + (MEM[64] + 128)) len (MEM[v10])]);\n    v35 = v36 = MEM[v10] + (384 + (MEM[64] + 128));\n    if (0x1f & MEM[v10]) {\n        MEM[v36 - (0x1f & MEM[v10])] = ~(256 ** (32 - (0x1f & MEM[v10])) - 1) & MEM[v36 - (0x1f & MEM[v10])];\n        v35 = v37 = 32 + (v36 - (0x1f & MEM[v10]));\n    }\n    MEM[MEM[64] + 64] = v35 - MEM[64];\n    MEM[v35] = MEM[v4];\n    v38 = dataCopy(MEM[(32 + v4) len (MEM[v4])], MEM[(32 + v35) len (MEM[v4])]);\n    v39 = v40 = MEM[v4] + (32 + v35);\n    if (0x1f & MEM[v4]) {\n        MEM[v40 - (0x1f & MEM[v4])] = ~(256 ** (32 - (0x1f & MEM[v4])) - 1) & MEM[v40 - (0x1f & MEM[v4])];\n        v39 = v41 = 32 + (v40 - (0x1f & MEM[v4]));\n    }\n    return MEM[(MEM[64]) len (v39 - MEM[64])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x68c966b) {\n            0x068c966b();\n        } else if (0xacf473b == function_selector >> 224) {\n            0x0acf473b();\n        } else if (0x1209b1f6 == function_selector >> 224) {\n            ticketPrice();\n        } else if (0x269975d0 == function_selector >> 224) {\n            0x269975d0();\n        } else if (0x26e770e9 == function_selector >> 224) {\n            Information();\n        } else if (0x370b6939 == function_selector >> 224) {\n            0x370b6939();\n        } else if (0x3e0663e0 == function_selector >> 224) {\n            0x3e0663e0();\n        } else if (0x3fa6497f == function_selector >> 224) {\n            0x3fa6497f();\n        } else if (0x69a8c3bf == function_selector >> 224) {\n            0x69a8c3bf();\n        } else if (0x6a907a78 == function_selector >> 224) {\n            0x6a907a78();\n        } else if (0x78e80b39 == function_selector >> 224) {\n            0x78e80b39();\n        } else if (0x7bc25372 == function_selector >> 224) {\n            0x7bc25372();\n        } else if (0x86e4e178 == function_selector >> 224) {\n            0x86e4e178();\n        } else if (0xa837aeb2 == function_selector >> 224) {\n            0xa837aeb2();\n        } else if (0xb6294bde == function_selector >> 224) {\n            0xb6294bde();\n        } else if (0xd96de4ce == function_selector >> 224) {\n            0xd96de4ce();\n        } else if (0xdd36e18b == function_selector >> 224) {\n            0xdd36e18b();\n        }\n    }\n    throw();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 15:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 owner_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_5; // STORAGE[0x5]\naddress owner_0_0_19; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction AdminCloseContract() public payable { \n    assert(msg.sender == owner_0_0_19);\n    if (0xff & owner_1 >> 160) {\n        owner_1 = ~0xff0000000000000000000000000000000000000000 & owner_1;\n    } else {\n        assert(owner_3[stor_4][11] == 0);\n        v0 = v1 = (address(this)).balance;\n        v2 = v3 = 0;\n        while (v2 < stor_4) {\n            v0 = v0 - owner_3[v2][7];\n            v2 += 1;\n        }\n        v4 = owner_0_0_19.call().value(~0x56bc75e2d630fffff + (v0 + owner_3[v2][2]));\n        assert(0 != v4);\n        stor_2 = 0;\n    }\n}\n\nfunction ticketPrice() public payable { \n    return 0x2386f26fc10000;\n}\n\nfunction GameDetails(uint256 GameId) public payable { \n    return owner_3[GameId][2], owner_3[GameId][11], owner_3[GameId], owner_3[GameId][1];\n}\n\nfunction Information() public payable { \n    v0 = new array[](v1.length);\n    v2 = v1.data;\n    v3, v4 = dataCopy('http://c.ethereumlottery.net');\n    if (28) {\n        MEM[v0.data] = ~0xffffffff & v4;\n    }\n    return v0;\n}\n\nfunction AdminSetDrawer(address NewDrawer) public payable { \n    assert(msg.sender == owner_0_0_19);\n    owner_1 = NewDrawer | ~0xffffffffffffffffffffffffffffffffffffffff & owner_1;\n}\n\nfunction AdminDrawProcess() public payable { \n    v0 = msg.sender != address(owner_1);\n    if (msg.sender != address(owner_1)) {\n        v0 = v1 = msg.sender != owner_0_0_19;\n    }\n    assert(!v0);\n    assert(1 == 0xff & owner_3[stor_4][0x8]);\n    v2 = v3 = 80;\n    if (owner_3[stor_4][12] < owner_3[stor_4][11]) {\n        v4 = STORAGE[12 + keccak256(stor_4, 3)];\n        while (v4 <= owner_3[stor_4][11]) {\n            if (0 != v2) {\n                v5 = v6 = 0;\n                while (v5 < 5) {\n                    v7 = v8 = 0;\n                    while (v7 < 5) {\n                        assert(v7 < 5);\n                        if (STORAGE[5 + keccak256(stor_4, 3) + (v7 >> 5)] / 256 ** (v7 % 32) & 0xff == 0xff & (0xffffffffff & STORAGE[1 + keccak256(v4, 10 + keccak256(stor_4))] << 216 >> 216) / 256 ** v5) {\n                            owner_3[stor_4] += 1;\n                        }\n                        v7 += 1;\n                    }\n                    v5 += 1;\n                }\n                owner_3[stor_4][12] += 1;\n                v2 += ~0;\n                v4 += 1;\n                continue;\n            }\n        }\n    }\n    if (owner_3[stor_4][12] >= owner_3[stor_4][11]) {\n        v9 = v10 = 0;\n        while (v9 < owner_3[stor_4][11]) {\n            if (3 != STORAGE[keccak256(v9, 10 + keccak256(stor_4, 3))]) {\n                if (owner_3[stor_4] != 4) {\n                    if (5 == owner_3[stor_4]) {\n                        owner_3[stor_4][1] += 1;\n                    }\n                } else {\n                    owner_3[stor_4][1] += 1;\n                }\n            } else {\n                owner_3[stor_4][1] += 1;\n            }\n            v9 += 1;\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = 35 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = 25 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = owner_3[stor_4][2] / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] != 0) {\n            v11 = v12 = 0x56bc75e2d63100000;\n        } else {\n            v11 = 40 * owner_3[stor_4][7] / 100 + owner_3[stor_4][2];\n        }\n        owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n        stor_4 += 1;\n        owner_3[1 + stor_4] = block.number;\n        owner_3[1 + stor_4][2] = v11;\n        owner_3[1 + stor_4][3] = owner_3[stor_4][13];\n        owner_3[1 + stor_4][8] = ~0xff & owner_3[1 + stor_4][0x8];\n        goto 0x1c9b0x26c;\n    }\n}\n\nfunction AdminAddFunds() public payable { \n    assert(msg.sender == owner_0_0_19);\n}\n\nfunction CurrentGameId() public payable { \n    return stor_4;\n}\n\nfunction UserAddTicket(bytes5[] tickets) public payable { \n    assert(0xff & owner_1 >> 160);\n    assert(0xff & owner_3[stor_4][0x8] == 0);\n    assert((?).length <= 70);\n    assert(msg.value >= (?).length * 0x2386f26fc10000);\n    if (msg.value > (?).length * 0x2386f26fc10000) {\n        v0 = msg.sender.call().value(msg.value - (?).length * 0x2386f26fc10000);\n        assert(0 != v0);\n    }\n    v1 = v2 = 0;\n    while (v1 < (?).length) {\n        assert(v1 < (?).length);\n        v3 = v4 = MEM[64];\n        MEM[64] = v4 + 160;\n        v5 = v6 = 5;\n        do {\n            MEM[v3] = 0;\n            v3 += 32;\n            v5 = v5 - 1;\n        } while (!v5);\n        MEM[v4] = 0xff & ((0xffffffffff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8) >> 8 & 0xffffffffff) >> 8;\n        MEM[v4 + 32] = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8) >> 8;\n        MEM[v4 + 64] = 0xff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8;\n        MEM[v4 + 96] = 0xff & (0xffffffffff & (?)[v1] >> 216) >> 8;\n        MEM[v4 + 128] = (?)[v1] >> 216 & 0xff;\n        v7 = v8 = 0;\n        while (0xff & v7 < 5) {\n            assert(0xff & v7 < 5);\n            v9 = v10 = 0xff & MEM[((0xff & v7) << 5) + v4] < 1;\n            if (0xff & MEM[((0xff & v7) << 5) + v4] >= 1) {\n                assert(v7 & 0xff < 5);\n                v9 = v11 = 0xff & MEM[((v7 & 0xff) << 5) + v4] > 30;\n            }\n            if (!v9) {\n                v12 = v13 = 0;\n                while (0xff & v12 < 5) {\n                    assert(0xff & v12 < 5);\n                    assert(0xff & v7 < 5);\n                    v14 = v15 = 0xff & MEM[((0xff & v7) << 5) + v4] == 0xff & MEM[((0xff & v12) << 5) + v4];\n                    if (v15) {\n                        v14 = v16 = 0xff & v7 != 0xff & v12;\n                    }\n                    if (!v14) {\n                        v12 += 1;\n                    } else {\n                        v17 = v18 = 0;\n                        goto 0x104e0x2dd;\n                    }\n                }\n                v7 += 1;\n            } else {\n                v17 = v19 = 0;\n                goto 0x104e0x2dd;\n            }\n        }\n        v17 = v20 = 1;\n        assert(v17);\n        owner_3[stor_4][11] += 1;\n        assert(v1 < (?).length);\n        STORAGE[1 + keccak256(STORAGE[keccak256(stor_4, 3) + 11], 10 + keccak256(stor_4, 3))] = (?)[v1] >> 216 | ~0xffffffffff & STORAGE[1 + keccak256(STORAGE[keccak256(stor_4, 3) + 11], 10 + keccak256(stor_4, 3))];\n        owner_5[stor_4][1] = owner_5[stor_4][1] + 1;\n        if (!owner_5[stor_4][1] <= owner_5[stor_4][1] + 1) {\n            v21 = v22 = keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5))) + (owner_5[stor_4][1] + 1);\n            while (keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5))) + owner_5[stor_4][1] > v21) {\n                STORAGE[v21] = 0;\n                v21 += 1;\n            }\n        }\n        assert(owner_3[msg.sender][1] + ~0 < owner_3[msg.sender][1]);\n        STORAGE[owner_3[msg.sender][1] + ~0 + keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5)))] = owner_3[stor_4][11];\n        v1 += 1;\n    }\n}\n\nfunction UserGetPrize() public payable { \n    v0 = v1 = 0;\n    while (v0 < stor_4) {\n        if (0xff & owner_5[v0] == 0) {\n            if (2 != 0xff & owner_3[v0][0x8]) {\n                if (0xff & owner_3[v0][0x8] == 3) {\n                    v0 = v2 = v0 + 0x2386f26fc10000 * owner_5[v0][1];\n                }\n            } else {\n                v3 = v4 = 0;\n                while (v3 < owner_5[v0][1]) {\n                    assert(v3 < owner_3[v0][1]);\n                    if (3 != STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                        assert(v3 < owner_3[v0][1]);\n                        if (4 != STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                            assert(v3 < owner_3[v0][1]);\n                            if (5 == STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                                v0 = v0 + owner_3[v0];\n                            }\n                        } else {\n                            v0 = v0 + owner_3[v0];\n                        }\n                    } else {\n                        v0 = v0 + owner_3[v0][0];\n                    }\n                    v3 += 1;\n                }\n                goto 0x1268;\n            }\n            v0 = v5 = 0;\n            owner_5[v0] = 0x1 | ~0xff & owner_5[v0];\n            owner_3[v0][7] = owner_3[v0][7] - v0;\n            v0 += v0;\n        }\n        v0 += 1;\n    }\n    assert(v0 > 0);\n    v6 = msg.sender.call().value(v0);\n    assert(0 != v6);\n}\n\nfunction UserCheckBalance(address addr) public payable { \n    v0 = v1 = 0;\n    while (v0 < stor_4) {\n        if (0xff & owner_5[v0] == 0) {\n            if (2 != 0xff & owner_3[v0][0x8]) {\n                if (0xff & owner_3[v0][0x8] == 3) {\n                    v0 = v0 + 0x2386f26fc10000 * owner_5[v0][1];\n                }\n            } else {\n                v2 = v3 = 0;\n                while (v2 < owner_5[v0][1]) {\n                    assert(v2 < owner_3[v0][1]);\n                    if (3 != STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                        assert(v2 < owner_3[v0][1]);\n                        if (4 != STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                            assert(v2 < owner_3[v0][1]);\n                            if (5 == STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                                v0 = v0 + owner_3[v0];\n                            }\n                        } else {\n                            v0 = v0 + owner_3[v0];\n                        }\n                    } else {\n                        v0 = v0 + owner_3[v0];\n                    }\n                    v2 += 1;\n                }\n            }\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction CheckTickets(address Address, uint256 GameId, uint256 TicketNumber) public payable { \n    v0 = v1 = MEM[64];\n    v2 = v3 = 5;\n    do {\n        MEM[v0] = 0;\n        v0 += 32;\n        v2 = v2 - 1;\n    } while (!v2);\n    v4 = v5 = 0;\n    assert(TicketNumber < owner_5[Address][1]);\n    if (STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))] > v5) {\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(0 < 5);\n        v6 = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & (0xffffffffff & STORAGE[1 + keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], 10 + keccak256(GameId, 3))] << 216 >> 216) >> 8) >> 8) >> 8) >> 8;\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(1 < 5);\n        v7 = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & STORAGE[1 + keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], keccak256(GameId, 3) + 10)] << 216 >> 216) >> 8) >> 8) >> 8;\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(TicketNumber < owner_3[Address][1]);\n        v8 = v9 = MEM[64];\n        v10 = v11 = 5;\n        do {\n            MEM[v8] = 0;\n            v8 += 32;\n            v10 = v10 - 1;\n        } while (!v10);\n        v12 = v13 = 0;\n        while (0xff & v12 < 5) {\n            v14 = 1 + v12;\n            while (0xff & v14 < 5) {\n                assert(0xff & v14 < 5);\n                assert(0xff & v12 < 5);\n                if (0xff & MEM[((0xff & v12) << 5) + v1] > 0xff & MEM[((0xff & v14) << 5) + v1]) {\n                    assert(0xff & v12 < 5);\n                    assert(v14 & 0xff < 5);\n                    assert(v12 & 0xff < 5);\n                    MEM[v1 + ((v12 & 0xff) << 5)] = 0xff & MEM[((v14 & 0xff) << 5) + v1];\n                    assert(v14 & 0xff < 5);\n                    MEM[((v14 & 0xff) << 5) + v1] = 0xff & MEM[v1 + ((0xff & v12) << 5)];\n                }\n                v14 += 1;\n            }\n            v12 += 1;\n        }\n        assert(TicketNumber < owner_3[Address][1]);\n        v4 = v15 = STORAGE[keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], 10 + keccak256(GameId, 3))];\n        v4 = v16 = 0xff & owner_5[Address];\n    }\n    return v17, v17, v17, v17, v17, v4, v4;\n}\n\nfunction AdminStartDraw(string secret_Key, bytes32 New_secret_Key_Hash) public payable { \n    v0 = v1 = secret_Key + 36;\n    v2 = v3 = msg.sender != address(owner_1);\n    if (msg.sender != address(owner_1)) {\n        v2 = v4 = msg.sender != owner_0_0_19;\n    }\n    assert(!v2);\n    assert(0xff & owner_3[stor_4][0x8] == 0);\n    owner_3[stor_4][1] = block.number;\n    CALLDATACOPY(v5.data, v1, (?).length);\n    if (keccak256(v5.data) == owner_3[stor_4][3]) {\n        owner_3[stor_4][8] = 0x1 | ~0xff & owner_3[stor_4][0x8];\n        owner_3[stor_4][13] = New_secret_Key_Hash;\n        if (31 < (?).length) {\n            owner_3[stor_4][4] = 1 + ((?).length + (?).length);\n            if ((?).length) {\n                while (v1 + (?).length > v0) {\n                    STORAGE[v6] = msg.data[v0];\n                    v0 += 32;\n                    v6 += 1;\n                }\n            }\n        } else {\n            owner_3[stor_4][4] = (?).length + (?).length | ~0xff & msg.data[v1];\n        }\n        while (v7 + (31 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) >> 5) > v6) {\n            STORAGE[v6] = 0;\n            v6 += 1;\n        }\n        v8 = v9 = v9.data;\n        if ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) {\n            if (31 < (owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) {\n                v8 = v10 = v9 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1);\n                do {\n                    MEM[v8] = STORAGE[v11];\n                    v11 += 1;\n                    v8 += 32;\n                } while (v10 <= v8);\n            } else {\n                MEM[v9] = owner_3[stor_4][4] >> 8 << 8;\n                v8 = v12 = ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) + v9;\n            }\n        }\n        MEM[v8] = owner_3[stor_4][3];\n        MEM[32 + v8] = owner_3[stor_4][11];\n        MEM[64 + v8] = block.timestamp;\n        v13 = v14 = v9.data;\n        owner_3[stor_4][9] = keccak256(v9);\n        v15 = v16 = owner_3[stor_4][9];\n        v17 = v18 = 5;\n        do {\n            MEM[v13] = 0;\n            v13 += 32;\n            v17 = v17 - 1;\n        } while (!v17);\n        v19 = v20 = 0;\n        while (0xff & v19 < 5) {\n            while (1) {\n                v21 = v22 = 1;\n                if (v19 != 32) {\n                    goto 0x1f88;\n                }\n                v15 = v23 = keccak256(v15);\n                v19 = v24 = 0;\n                v19 += 1;\n                v25 = v26 = 0;\n                while (0xff & v25 < 5) {\n                    assert(0xff & v25 < 5);\n                    if (0xff & MEM[((0xff & v25) << 5) + v14] != 0xff & 1 + (0xff & v15 * 2 ** (v19 << 3) >> 248 << 248 >> 248) % 30) {\n                        v25 += 1;\n                    } else {\n                        v21 = v27 = 0;\n                    }\n                }\n                if (1 != v21) {\n                    continue;\n                } else {\n                    assert(0xff & v19 < 5);\n                    MEM[((0xff & v19) << 5) + v14] = 0xff & 1 + (0xff & v15 * 2 ** (v19 << 3) >> 248 << 248 >> 248) % 30;\n                    v19 += 1;\n                    continue;\n                }\n            }\n        }\n        v28 = v29 = MEM[64];\n        MEM[64] = v29 + 160;\n        v30 = v31 = 5;\n        do {\n            MEM[v28] = 0;\n            v28 += 32;\n            v30 = v30 - 1;\n        } while (!v30);\n        v32 = v33 = 0;\n        while (0xff & v32 < 5) {\n            v34 = 1 + v32;\n            while (0xff & v34 < 5) {\n                assert(0xff & v34 < 5);\n                assert(0xff & v32 < 5);\n                if (0xff & MEM[((0xff & v32) << 5) + v14] > 0xff & MEM[((0xff & v34) << 5) + v14]) {\n                    assert(0xff & v32 < 5);\n                    assert(v34 & 0xff < 5);\n                    assert(v32 & 0xff < 5);\n                    MEM[v14 + ((v32 & 0xff) << 5)] = 0xff & MEM[((v34 & 0xff) << 5) + v14];\n                    assert(v34 & 0xff < 5);\n                    MEM[((v34 & 0xff) << 5) + v14] = 0xff & MEM[v14 + ((0xff & v32) << 5)];\n                }\n                v34 += 1;\n            }\n            v32 += 1;\n        }\n        v35 = v36 = 0;\n        v37 = v38 = keccak256(stor_4, 3) + 5;\n        while (v14 + 160 > v13) {\n            STORAGE[v37] = MEM[v13] * 256 ** v35 | ~(255 * 256 ** v35) & STORAGE[v37];\n            v13 += 32;\n            v37 += 1 + v35 >> 5;\n            v35 = (1 - (1 + v35 >> 5)) * (1 + v35);\n        }\n        while (v35) {\n            STORAGE[v37] = ~(255 * 256 ** v35) & STORAGE[v37];\n            v37 += 1 + v35 >> 5;\n            v35 = (1 - (1 + v35 >> 5)) * (1 + v35);\n        }\n        v39 = v40 = 8387;\n        while (6 + keccak256(stor_4, 3) > v37) {\n            STORAGE[v37] = ~0xff & STORAGE[v37];\n            v37 += 1;\n        }\n    } else {\n        owner_3[stor_4][7] = 0x2386f26fc10000 * owner_3[stor_4][11];\n        owner_3[stor_4][8] = 0x3 | ~0xff & owner_3[stor_4][0x8];\n        if (31 < (?).length) {\n            owner_3[stor_4][4] = 1 + ((?).length + (?).length);\n            if ((?).length) {\n                while (v1 + (?).length > v0) {\n                    STORAGE[v41] = msg.data[v0];\n                    v0 += 32;\n                    v41 += 1;\n                }\n            }\n        } else {\n            owner_3[stor_4][4] = ~0xff & msg.data[v1] | (?).length + (?).length;\n        }\n        v39 = v42 = 7680;\n        while (v43 + (31 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) >> 5) > v41) {\n            STORAGE[v41] = 0;\n            v41 += 1;\n        }\n    }\n    goto {'0x1e00', '0x20c3'};\n    stor_4 += 1;\n    owner_3[1 + stor_4] = block.number;\n    owner_3[stor_4][2] = owner_3[stor_4][2];\n    owner_3[stor_4][3] = New_secret_Key_Hash;\n    owner_3[stor_4][8] = ~0xff & owner_3[stor_4][0x8];\n    return 0;\n    if (owner_3[stor_4][11] <= 1) {\n        owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n    } else {\n        stor_2 = stor_2 + STORAGE[keccak256(stor_4, 3) + 11] * 0x3311fc80a570000 / 100;\n        STORAGE[7 + keccak256(stor_4, 3)] = 0x2386f26fc10000 * STORAGE[keccak256(stor_4, 3) + 11] - (stor_2 + STORAGE[keccak256(stor_4, 3) + 11] * 0x3311fc80a570000 / 100);\n        v44 = v45 = msg.sender != address(owner_1);\n        if (msg.sender != address(owner_1)) {\n            v44 = v46 = msg.sender != owner_0_0_19;\n        }\n        assert(!v44);\n        assert(1 == 0xff & owner_3[stor_4][0x8]);\n        v47 = v48 = 80;\n        if (owner_3[stor_4][12] < owner_3[stor_4][11]) {\n            v49 = v50 = STORAGE[12 + keccak256(stor_4, 3)];\n            while (v49 <= owner_3[stor_4][11]) {\n                if (0 != v47) {\n                    v51 = v52 = 0;\n                    while (v51 < 5) {\n                        v53 = v54 = 0;\n                        while (v53 < 5) {\n                            assert(v53 < 5);\n                            if (STORAGE[5 + keccak256(stor_4, 3) + (v53 >> 5)] / 256 ** (v53 % 32) & 0xff == 0xff & (0xffffffffff & STORAGE[1 + keccak256(v49, 10 + keccak256(stor_4))] << 216 >> 216) / 256 ** v51) {\n                                owner_3[stor_4] += 1;\n                            }\n                            v53 += 1;\n                        }\n                        v51 += 1;\n                    }\n                    owner_3[stor_4][12] += 1;\n                    v47 += ~0;\n                    v49 += 1;\n                    continue;\n                }\n            }\n        }\n        if (owner_3[stor_4][12] >= owner_3[stor_4][11]) {\n            v55 = v56 = 0;\n            while (v55 < owner_3[stor_4][11]) {\n                if (3 != STORAGE[keccak256(v55, 10 + keccak256(stor_4, 3))]) {\n                    if (owner_3[stor_4] != 4) {\n                        if (5 == owner_3[stor_4]) {\n                            owner_3[stor_4][1] += 1;\n                        }\n                    } else {\n                        owner_3[stor_4][1] += 1;\n                    }\n                } else {\n                    owner_3[stor_4][1] += 1;\n                }\n                v55 += 1;\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = 35 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = 25 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = owner_3[stor_4][2] / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] != 0) {\n                v57 = v58 = 0x56bc75e2d63100000;\n            } else {\n                v57 = v59 = 40 * owner_3[stor_4][7] / 100 + owner_3[stor_4][2];\n            }\n            owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n            stor_4 += 1;\n            owner_3[1 + stor_4] = block.number;\n            owner_3[1 + stor_4][2] = v57;\n            owner_3[1 + stor_4][3] = owner_3[stor_4][13];\n            owner_3[1 + stor_4][8] = ~0xff & owner_3[1 + stor_4][0x8];\n            goto 0x1c9b0x270B0x20e4;\n        }\n        goto 0x1e21;\n    }\n}\n\nfunction AdminGetFee() public payable { \n    assert(msg.sender == owner_0_0_19);\n    v0 = owner_0_0_19.call().value(stor_2);\n    assert(0 != v0);\n    stor_2 = 0;\n}\n\nfunction AdminDrawError() public payable { \n    v0 = v1 = address(owner_1) != msg.sender;\n    if (address(owner_1) != msg.sender) {\n        v0 = v2 = msg.sender != owner_0_0_19;\n    }\n    assert(!v0);\n    assert(1 == 0xff & owner_3[stor_4][0x8]);\n    owner_3[stor_4][7] = 0x2386f26fc10000 * owner_3[stor_4][11];\n    owner_3[stor_4][8] = 0x3 | ~0xff & owner_3[stor_4][0x8];\n    stor_4 += 1;\n    owner_3[1 + stor_4] = block.number;\n    owner_3[stor_4][2] = owner_3[stor_4][2];\n    owner_3[stor_4][3] = owner_3[stor_4][13];\n    owner_3[stor_4][8] = ~0xff & owner_3[stor_4][0x8];\n}\n\nfunction ContractStatus() public payable { \n    return 0xff & owner_1 >> 160;\n}\n\nfunction DrawDetails(uint256 GameId) public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 5;\n    do {\n        MEM[v0] = 0;\n        v0 += 32;\n        v2 = v2 - 1;\n    } while (!v2);\n    v4 = v5 = MEM[64];\n    MEM[v5] = 0;\n    if (0xff & owner_3[GameId][0x8] != 0) {\n        if (0xff & owner_3[GameId][0x8] != 1) {\n            if (0xff & owner_3[GameId][0x8] != 2) {\n                if (0xff & owner_3[GameId][0x8] == 3) {\n                    v4 = v6 = 'Failed';\n                    goto 0xc96;\n                }\n            } else {\n                v4 = v7 = 0x446f6e6500000000000000000000000000000000000000000000000000000000;\n            }\n        } else {\n            v4 = v8 = 'In Process';\n        }\n    } else {\n        v4 = v9 = 0x5761697400000000000000000000000000000000000000000000000000000000;\n    }\n    if (0xff & owner_3[GameId][0x8] == 0) {\n        v10 = v11 = MEM[64];\n        v12 = v13 = 0;\n        MEM[v11] = v13;\n        v14 = v15 = MEM[64];\n        MEM[v15] = v13;\n        MEM[v15 + 32] = v13;\n        MEM[v15 + 64] = v13;\n        MEM[v15 + 96] = v13;\n        MEM[v15 + 128] = v13;\n    } else {\n        v10 = v16 = new bytes[](v17);\n        v17 = (STORAGE[4 + keccak256(GameId, 3)] & ~0 + (!(STORAGE[4 + keccak256(GameId, 3)] & 0x1) << 8)) >> 1;\n        v18 = v19 = v16.data;\n        if (v17) {\n            if (31 < v17) {\n                do {\n                    MEM[v18] = STORAGE[v20];\n                    v20 += 1;\n                    v18 += 32;\n                } while (v19 + v17 <= v18);\n            } else {\n                MEM[v19] = STORAGE[4 + keccak256(GameId, 3)] >> 8 << 8;\n            }\n        }\n        v21 = v22 = 0;\n        v14 = v23 = MEM[64];\n        v24 = v25 = 5 + keccak256(GameId, 3);\n        do {\n            MEM[v14] = 0xff & STORAGE[v24] / 256 ** v21;\n            v24 += 1 + v21 >> 5;\n            v21 = (1 + v21) * (1 - (1 + v21 >> 5));\n            v14 += 32;\n        } while (v23 + 160 <= v14);\n        v12 = v26 = owner_3[3][1];\n        v12 = v27 = owner_3[4][1];\n        v12 = v28 = owner_3[5][1];\n        v12 = v29 = owner_3[3][0];\n        v12 = v30 = owner_3[4][0];\n        v12 = v31 = owner_3[5][0];\n        v12 = v32 = owner_3[5][9];\n        goto 0xd72;\n    }\n    MEM[MEM[64]] = owner_3[GameId][3];\n    MEM[MEM[64] + 96] = v12;\n    v33 = dataCopy(MEM[v14 len 160], MEM[(MEM[64] + 128) len 160]);\n    MEM[160 + (MEM[64] + 128)] = v12;\n    MEM[192 + (MEM[64] + 128)] = v12;\n    MEM[224 + (MEM[64] + 128)] = v12;\n    MEM[256 + (MEM[64] + 128)] = v12;\n    MEM[288 + (MEM[64] + 128)] = v12;\n    MEM[320 + (MEM[64] + 128)] = v12;\n    MEM[MEM[64] + 32] = 480;\n    MEM[352 + (MEM[64] + 128)] = MEM[v10];\n    v34 = dataCopy(MEM[(32 + v10) len (MEM[v10])], MEM[(384 + (MEM[64] + 128)) len (MEM[v10])]);\n    v35 = v36 = MEM[v10] + (384 + (MEM[64] + 128));\n    if (0x1f & MEM[v10]) {\n        MEM[v36 - (0x1f & MEM[v10])] = ~(256 ** (32 - (0x1f & MEM[v10])) - 1) & MEM[v36 - (0x1f & MEM[v10])];\n        v35 = v37 = 32 + (v36 - (0x1f & MEM[v10]));\n    }\n    MEM[MEM[64] + 64] = v35 - MEM[64];\n    MEM[v35] = MEM[v4];\n    v38 = dataCopy(MEM[(32 + v4) len (MEM[v4])], MEM[(32 + v35) len (MEM[v4])]);\n    v39 = v40 = MEM[v4] + (32 + v35);\n    if (0x1f & MEM[v4]) {\n        MEM[v40 - (0x1f & MEM[v4])] = ~(256 ** (32 - (0x1f & MEM[v4])) - 1) & MEM[v40 - (0x1f & MEM[v4])];\n        v39 = v41 = 32 + (v40 - (0x1f & MEM[v4]));\n    }\n    return MEM[(MEM[64]) len (v39 - MEM[64])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x68c966b) {\n            0x068c966b();\n        } else if (0xacf473b == function_selector >> 224) {\n            0x0acf473b();\n        } else if (0x1209b1f6 == function_selector >> 224) {\n            ticketPrice();\n        } else if (0x269975d0 == function_selector >> 224) {\n            0x269975d0();\n        } else if (0x26e770e9 == function_selector >> 224) {\n            Information();\n        } else if (0x370b6939 == function_selector >> 224) {\n            0x370b6939();\n        } else if (0x3e0663e0 == function_selector >> 224) {\n            0x3e0663e0();\n        } else if (0x3fa6497f == function_selector >> 224) {\n            0x3fa6497f();\n        } else if (0x69a8c3bf == function_selector >> 224) {\n            0x69a8c3bf();\n        } else if (0x6a907a78 == function_selector >> 224) {\n            0x6a907a78();\n        } else if (0x78e80b39 == function_selector >> 224) {\n            0x78e80b39();\n        } else if (0x7bc25372 == function_selector >> 224) {\n            0x7bc25372();\n        } else if (0x86e4e178 == function_selector >> 224) {\n            0x86e4e178();\n        } else if (0xa837aeb2 == function_selector >> 224) {\n            0xa837aeb2();\n        } else if (0xb6294bde == function_selector >> 224) {\n            0xb6294bde();\n        } else if (0xd96de4ce == function_selector >> 224) {\n            0xd96de4ce();\n        } else if (0xdd36e18b == function_selector >> 224) {\n            0xdd36e18b();\n        }\n    }\n    throw();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 15:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 owner_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_5; // STORAGE[0x5]\naddress owner_0_0_19; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction AdminCloseContract() public payable { \n    assert(msg.sender == owner_0_0_19);\n    if (0xff & owner_1 >> 160) {\n        owner_1 = ~0xff0000000000000000000000000000000000000000 & owner_1;\n    } else {\n        assert(owner_3[stor_4][11] == 0);\n        v0 = v1 = (address(this)).balance;\n        v2 = v3 = 0;\n        while (v2 < stor_4) {\n            v0 = v0 - owner_3[v2][7];\n            v2 += 1;\n        }\n        v4 = owner_0_0_19.call().value(~0x56bc75e2d630fffff + (v0 + owner_3[v2][2]));\n        assert(0 != v4);\n        stor_2 = 0;\n    }\n}\n\nfunction ticketPrice() public payable { \n    return 0x2386f26fc10000;\n}\n\nfunction GameDetails(uint256 GameId) public payable { \n    return owner_3[GameId][2], owner_3[GameId][11], owner_3[GameId], owner_3[GameId][1];\n}\n\nfunction Information() public payable { \n    v0 = new array[](v1.length);\n    v2 = v1.data;\n    v3, v4 = dataCopy('http://c.ethereumlottery.net');\n    if (28) {\n        MEM[v0.data] = ~0xffffffff & v4;\n    }\n    return v0;\n}\n\nfunction AdminSetDrawer(address NewDrawer) public payable { \n    assert(msg.sender == owner_0_0_19);\n    owner_1 = NewDrawer | ~0xffffffffffffffffffffffffffffffffffffffff & owner_1;\n}\n\nfunction AdminDrawProcess() public payable { \n    v0 = msg.sender != address(owner_1);\n    if (msg.sender != address(owner_1)) {\n        v0 = v1 = msg.sender != owner_0_0_19;\n    }\n    assert(!v0);\n    assert(1 == 0xff & owner_3[stor_4][0x8]);\n    v2 = v3 = 80;\n    if (owner_3[stor_4][12] < owner_3[stor_4][11]) {\n        v4 = STORAGE[12 + keccak256(stor_4, 3)];\n        while (v4 <= owner_3[stor_4][11]) {\n            if (0 != v2) {\n                v5 = v6 = 0;\n                while (v5 < 5) {\n                    v7 = v8 = 0;\n                    while (v7 < 5) {\n                        assert(v7 < 5);\n                        if (STORAGE[5 + keccak256(stor_4, 3) + (v7 >> 5)] / 256 ** (v7 % 32) & 0xff == 0xff & (0xffffffffff & STORAGE[1 + keccak256(v4, 10 + keccak256(stor_4))] << 216 >> 216) / 256 ** v5) {\n                            owner_3[stor_4] += 1;\n                        }\n                        v7 += 1;\n                    }\n                    v5 += 1;\n                }\n                owner_3[stor_4][12] += 1;\n                v2 += ~0;\n                v4 += 1;\n                continue;\n            }\n        }\n    }\n    if (owner_3[stor_4][12] >= owner_3[stor_4][11]) {\n        v9 = v10 = 0;\n        while (v9 < owner_3[stor_4][11]) {\n            if (3 != STORAGE[keccak256(v9, 10 + keccak256(stor_4, 3))]) {\n                if (owner_3[stor_4] != 4) {\n                    if (5 == owner_3[stor_4]) {\n                        owner_3[stor_4][1] += 1;\n                    }\n                } else {\n                    owner_3[stor_4][1] += 1;\n                }\n            } else {\n                owner_3[stor_4][1] += 1;\n            }\n            v9 += 1;\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = 35 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = 25 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] > 0) {\n            owner_3[stor_4] = owner_3[stor_4][2] / owner_3[stor_4][1];\n        }\n        if (owner_3[stor_4][1] != 0) {\n            v11 = v12 = 0x56bc75e2d63100000;\n        } else {\n            v11 = 40 * owner_3[stor_4][7] / 100 + owner_3[stor_4][2];\n        }\n        owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n        stor_4 += 1;\n        owner_3[1 + stor_4] = block.number;\n        owner_3[1 + stor_4][2] = v11;\n        owner_3[1 + stor_4][3] = owner_3[stor_4][13];\n        owner_3[1 + stor_4][8] = ~0xff & owner_3[1 + stor_4][0x8];\n        goto 0x1c9b0x26c;\n    }\n}\n\nfunction AdminAddFunds() public payable { \n    assert(msg.sender == owner_0_0_19);\n}\n\nfunction CurrentGameId() public payable { \n    return stor_4;\n}\n\nfunction UserAddTicket(bytes5[] tickets) public payable { \n    assert(0xff & owner_1 >> 160);\n    assert(0xff & owner_3[stor_4][0x8] == 0);\n    assert((?).length <= 70);\n    assert(msg.value >= (?).length * 0x2386f26fc10000);\n    if (msg.value > (?).length * 0x2386f26fc10000) {\n        v0 = msg.sender.call().value(msg.value - (?).length * 0x2386f26fc10000);\n        assert(0 != v0);\n    }\n    v1 = v2 = 0;\n    while (v1 < (?).length) {\n        assert(v1 < (?).length);\n        v3 = v4 = MEM[64];\n        MEM[64] = v4 + 160;\n        v5 = v6 = 5;\n        do {\n            MEM[v3] = 0;\n            v3 += 32;\n            v5 = v5 - 1;\n        } while (!v5);\n        MEM[v4] = 0xff & ((0xffffffffff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8) >> 8 & 0xffffffffff) >> 8;\n        MEM[v4 + 32] = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8) >> 8;\n        MEM[v4 + 64] = 0xff & (0xffffffffff & (0xffffffffff & (?)[v1] >> 216) >> 8) >> 8;\n        MEM[v4 + 96] = 0xff & (0xffffffffff & (?)[v1] >> 216) >> 8;\n        MEM[v4 + 128] = (?)[v1] >> 216 & 0xff;\n        v7 = v8 = 0;\n        while (0xff & v7 < 5) {\n            assert(0xff & v7 < 5);\n            v9 = v10 = 0xff & MEM[((0xff & v7) << 5) + v4] < 1;\n            if (0xff & MEM[((0xff & v7) << 5) + v4] >= 1) {\n                assert(v7 & 0xff < 5);\n                v9 = v11 = 0xff & MEM[((v7 & 0xff) << 5) + v4] > 30;\n            }\n            if (!v9) {\n                v12 = v13 = 0;\n                while (0xff & v12 < 5) {\n                    assert(0xff & v12 < 5);\n                    assert(0xff & v7 < 5);\n                    v14 = v15 = 0xff & MEM[((0xff & v7) << 5) + v4] == 0xff & MEM[((0xff & v12) << 5) + v4];\n                    if (v15) {\n                        v14 = v16 = 0xff & v7 != 0xff & v12;\n                    }\n                    if (!v14) {\n                        v12 += 1;\n                    } else {\n                        v17 = v18 = 0;\n                        goto 0x104e0x2dd;\n                    }\n                }\n                v7 += 1;\n            } else {\n                v17 = v19 = 0;\n                goto 0x104e0x2dd;\n            }\n        }\n        v17 = v20 = 1;\n        assert(v17);\n        owner_3[stor_4][11] += 1;\n        assert(v1 < (?).length);\n        STORAGE[1 + keccak256(STORAGE[keccak256(stor_4, 3) + 11], 10 + keccak256(stor_4, 3))] = (?)[v1] >> 216 | ~0xffffffffff & STORAGE[1 + keccak256(STORAGE[keccak256(stor_4, 3) + 11], 10 + keccak256(stor_4, 3))];\n        owner_5[stor_4][1] = owner_5[stor_4][1] + 1;\n        if (!owner_5[stor_4][1] <= owner_5[stor_4][1] + 1) {\n            v21 = v22 = keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5))) + (owner_5[stor_4][1] + 1);\n            while (keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5))) + owner_5[stor_4][1] > v21) {\n                STORAGE[v21] = 0;\n                v21 += 1;\n            }\n        }\n        assert(owner_3[msg.sender][1] + ~0 < owner_3[msg.sender][1]);\n        STORAGE[owner_3[msg.sender][1] + ~0 + keccak256(1 + keccak256(stor_4, keccak256(msg.sender, 5)))] = owner_3[stor_4][11];\n        v1 += 1;\n    }\n}\n\nfunction UserGetPrize() public payable { \n    v0 = v1 = 0;\n    while (v0 < stor_4) {\n        if (0xff & owner_5[v0] == 0) {\n            if (2 != 0xff & owner_3[v0][0x8]) {\n                if (0xff & owner_3[v0][0x8] == 3) {\n                    v0 = v2 = v0 + 0x2386f26fc10000 * owner_5[v0][1];\n                }\n            } else {\n                v3 = v4 = 0;\n                while (v3 < owner_5[v0][1]) {\n                    assert(v3 < owner_3[v0][1]);\n                    if (3 != STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                        assert(v3 < owner_3[v0][1]);\n                        if (4 != STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                            assert(v3 < owner_3[v0][1]);\n                            if (5 == STORAGE[keccak256(STORAGE[v3 + keccak256(1 + keccak256(v0, keccak256(msg.sender, 5)))], 10 + keccak256(v0, 3))]) {\n                                v0 = v0 + owner_3[v0];\n                            }\n                        } else {\n                            v0 = v0 + owner_3[v0];\n                        }\n                    } else {\n                        v0 = v0 + owner_3[v0][0];\n                    }\n                    v3 += 1;\n                }\n                goto 0x1268;\n            }\n            v0 = v5 = 0;\n            owner_5[v0] = 0x1 | ~0xff & owner_5[v0];\n            owner_3[v0][7] = owner_3[v0][7] - v0;\n            v0 += v0;\n        }\n        v0 += 1;\n    }\n    assert(v0 > 0);\n    v6 = msg.sender.call().value(v0);\n    assert(0 != v6);\n}\n\nfunction UserCheckBalance(address addr) public payable { \n    v0 = v1 = 0;\n    while (v0 < stor_4) {\n        if (0xff & owner_5[v0] == 0) {\n            if (2 != 0xff & owner_3[v0][0x8]) {\n                if (0xff & owner_3[v0][0x8] == 3) {\n                    v0 = v0 + 0x2386f26fc10000 * owner_5[v0][1];\n                }\n            } else {\n                v2 = v3 = 0;\n                while (v2 < owner_5[v0][1]) {\n                    assert(v2 < owner_3[v0][1]);\n                    if (3 != STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                        assert(v2 < owner_3[v0][1]);\n                        if (4 != STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                            assert(v2 < owner_3[v0][1]);\n                            if (5 == STORAGE[keccak256(STORAGE[v2 + keccak256(1 + keccak256(v0, keccak256(addr, 5)))], 10 + keccak256(v0, 3))]) {\n                                v0 = v0 + owner_3[v0];\n                            }\n                        } else {\n                            v0 = v0 + owner_3[v0];\n                        }\n                    } else {\n                        v0 = v0 + owner_3[v0];\n                    }\n                    v2 += 1;\n                }\n            }\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction CheckTickets(address Address, uint256 GameId, uint256 TicketNumber) public payable { \n    v0 = v1 = MEM[64];\n    v2 = v3 = 5;\n    do {\n        MEM[v0] = 0;\n        v0 += 32;\n        v2 = v2 - 1;\n    } while (!v2);\n    v4 = v5 = 0;\n    assert(TicketNumber < owner_5[Address][1]);\n    if (STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))] > v5) {\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(0 < 5);\n        v6 = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & (0xffffffffff & STORAGE[1 + keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], 10 + keccak256(GameId, 3))] << 216 >> 216) >> 8) >> 8) >> 8) >> 8;\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(1 < 5);\n        v7 = 0xff & (0xffffffffff & (0xffffffffff & (0xffffffffff & STORAGE[1 + keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], keccak256(GameId, 3) + 10)] << 216 >> 216) >> 8) >> 8) >> 8;\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(TicketNumber < owner_3[Address][1]);\n        assert(TicketNumber < owner_3[Address][1]);\n        v8 = v9 = MEM[64];\n        v10 = v11 = 5;\n        do {\n            MEM[v8] = 0;\n            v8 += 32;\n            v10 = v10 - 1;\n        } while (!v10);\n        v12 = v13 = 0;\n        while (0xff & v12 < 5) {\n            v14 = 1 + v12;\n            while (0xff & v14 < 5) {\n                assert(0xff & v14 < 5);\n                assert(0xff & v12 < 5);\n                if (0xff & MEM[((0xff & v12) << 5) + v1] > 0xff & MEM[((0xff & v14) << 5) + v1]) {\n                    assert(0xff & v12 < 5);\n                    assert(v14 & 0xff < 5);\n                    assert(v12 & 0xff < 5);\n                    MEM[v1 + ((v12 & 0xff) << 5)] = 0xff & MEM[((v14 & 0xff) << 5) + v1];\n                    assert(v14 & 0xff < 5);\n                    MEM[((v14 & 0xff) << 5) + v1] = 0xff & MEM[v1 + ((0xff & v12) << 5)];\n                }\n                v14 += 1;\n            }\n            v12 += 1;\n        }\n        assert(TicketNumber < owner_3[Address][1]);\n        v4 = v15 = STORAGE[keccak256(STORAGE[TicketNumber + keccak256(1 + keccak256(GameId, keccak256(Address, 5)))], 10 + keccak256(GameId, 3))];\n        v4 = v16 = 0xff & owner_5[Address];\n    }\n    return v17, v17, v17, v17, v17, v4, v4;\n}\n\nfunction AdminStartDraw(string secret_Key, bytes32 New_secret_Key_Hash) public payable { \n    v0 = v1 = secret_Key + 36;\n    v2 = v3 = msg.sender != address(owner_1);\n    if (msg.sender != address(owner_1)) {\n        v2 = v4 = msg.sender != owner_0_0_19;\n    }\n    assert(!v2);\n    assert(0xff & owner_3[stor_4][0x8] == 0);\n    owner_3[stor_4][1] = block.number;\n    CALLDATACOPY(v5.data, v1, (?).length);\n    if (keccak256(v5.data) == owner_3[stor_4][3]) {\n        owner_3[stor_4][8] = 0x1 | ~0xff & owner_3[stor_4][0x8];\n        owner_3[stor_4][13] = New_secret_Key_Hash;\n        if (31 < (?).length) {\n            owner_3[stor_4][4] = 1 + ((?).length + (?).length);\n            if ((?).length) {\n                while (v1 + (?).length > v0) {\n                    STORAGE[v6] = msg.data[v0];\n                    v0 += 32;\n                    v6 += 1;\n                }\n            }\n        } else {\n            owner_3[stor_4][4] = (?).length + (?).length | ~0xff & msg.data[v1];\n        }\n        while (v7 + (31 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) >> 5) > v6) {\n            STORAGE[v6] = 0;\n            v6 += 1;\n        }\n        v8 = v9 = v9.data;\n        if ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) {\n            if (31 < (owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) {\n                v8 = v10 = v9 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1);\n                do {\n                    MEM[v8] = STORAGE[v11];\n                    v11 += 1;\n                    v8 += 32;\n                } while (v10 <= v8);\n            } else {\n                MEM[v9] = owner_3[stor_4][4] >> 8 << 8;\n                v8 = v12 = ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) + v9;\n            }\n        }\n        MEM[v8] = owner_3[stor_4][3];\n        MEM[32 + v8] = owner_3[stor_4][11];\n        MEM[64 + v8] = block.timestamp;\n        v13 = v14 = v9.data;\n        owner_3[stor_4][9] = keccak256(v9);\n        v15 = v16 = owner_3[stor_4][9];\n        v17 = v18 = 5;\n        do {\n            MEM[v13] = 0;\n            v13 += 32;\n            v17 = v17 - 1;\n        } while (!v17);\n        v19 = v20 = 0;\n        while (0xff & v19 < 5) {\n            while (1) {\n                v21 = v22 = 1;\n                if (v19 != 32) {\n                    goto 0x1f88;\n                }\n                v15 = v23 = keccak256(v15);\n                v19 = v24 = 0;\n                v19 += 1;\n                v25 = v26 = 0;\n                while (0xff & v25 < 5) {\n                    assert(0xff & v25 < 5);\n                    if (0xff & MEM[((0xff & v25) << 5) + v14] != 0xff & 1 + (0xff & v15 * 2 ** (v19 << 3) >> 248 << 248 >> 248) % 30) {\n                        v25 += 1;\n                    } else {\n                        v21 = v27 = 0;\n                    }\n                }\n                if (1 != v21) {\n                    continue;\n                } else {\n                    assert(0xff & v19 < 5);\n                    MEM[((0xff & v19) << 5) + v14] = 0xff & 1 + (0xff & v15 * 2 ** (v19 << 3) >> 248 << 248 >> 248) % 30;\n                    v19 += 1;\n                    continue;\n                }\n            }\n        }\n        v28 = v29 = MEM[64];\n        MEM[64] = v29 + 160;\n        v30 = v31 = 5;\n        do {\n            MEM[v28] = 0;\n            v28 += 32;\n            v30 = v30 - 1;\n        } while (!v30);\n        v32 = v33 = 0;\n        while (0xff & v32 < 5) {\n            v34 = 1 + v32;\n            while (0xff & v34 < 5) {\n                assert(0xff & v34 < 5);\n                assert(0xff & v32 < 5);\n                if (0xff & MEM[((0xff & v32) << 5) + v14] > 0xff & MEM[((0xff & v34) << 5) + v14]) {\n                    assert(0xff & v32 < 5);\n                    assert(v34 & 0xff < 5);\n                    assert(v32 & 0xff < 5);\n                    MEM[v14 + ((v32 & 0xff) << 5)] = 0xff & MEM[((v34 & 0xff) << 5) + v14];\n                    assert(v34 & 0xff < 5);\n                    MEM[((v34 & 0xff) << 5) + v14] = 0xff & MEM[v14 + ((0xff & v32) << 5)];\n                }\n                v34 += 1;\n            }\n            v32 += 1;\n        }\n        v35 = v36 = 0;\n        v37 = v38 = keccak256(stor_4, 3) + 5;\n        while (v14 + 160 > v13) {\n            STORAGE[v37] = MEM[v13] * 256 ** v35 | ~(255 * 256 ** v35) & STORAGE[v37];\n            v13 += 32;\n            v37 += 1 + v35 >> 5;\n            v35 = (1 - (1 + v35 >> 5)) * (1 + v35);\n        }\n        while (v35) {\n            STORAGE[v37] = ~(255 * 256 ** v35) & STORAGE[v37];\n            v37 += 1 + v35 >> 5;\n            v35 = (1 - (1 + v35 >> 5)) * (1 + v35);\n        }\n        v39 = v40 = 8387;\n        while (6 + keccak256(stor_4, 3) > v37) {\n            STORAGE[v37] = ~0xff & STORAGE[v37];\n            v37 += 1;\n        }\n    } else {\n        owner_3[stor_4][7] = 0x2386f26fc10000 * owner_3[stor_4][11];\n        owner_3[stor_4][8] = 0x3 | ~0xff & owner_3[stor_4][0x8];\n        if (31 < (?).length) {\n            owner_3[stor_4][4] = 1 + ((?).length + (?).length);\n            if ((?).length) {\n                while (v1 + (?).length > v0) {\n                    STORAGE[v41] = msg.data[v0];\n                    v0 += 32;\n                    v41 += 1;\n                }\n            }\n        } else {\n            owner_3[stor_4][4] = ~0xff & msg.data[v1] | (?).length + (?).length;\n        }\n        v39 = v42 = 7680;\n        while (v43 + (31 + ((owner_3[stor_4][0x4] & ~0 + (!(owner_3[stor_4][0x4] & 0x1) << 8)) >> 1) >> 5) > v41) {\n            STORAGE[v41] = 0;\n            v41 += 1;\n        }\n    }\n    goto {'0x1e00', '0x20c3'};\n    stor_4 += 1;\n    owner_3[1 + stor_4] = block.number;\n    owner_3[stor_4][2] = owner_3[stor_4][2];\n    owner_3[stor_4][3] = New_secret_Key_Hash;\n    owner_3[stor_4][8] = ~0xff & owner_3[stor_4][0x8];\n    return 0;\n    if (owner_3[stor_4][11] <= 1) {\n        owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n    } else {\n        stor_2 = stor_2 + STORAGE[keccak256(stor_4, 3) + 11] * 0x3311fc80a570000 / 100;\n        STORAGE[7 + keccak256(stor_4, 3)] = 0x2386f26fc10000 * STORAGE[keccak256(stor_4, 3) + 11] - (stor_2 + STORAGE[keccak256(stor_4, 3) + 11] * 0x3311fc80a570000 / 100);\n        v44 = v45 = msg.sender != address(owner_1);\n        if (msg.sender != address(owner_1)) {\n            v44 = v46 = msg.sender != owner_0_0_19;\n        }\n        assert(!v44);\n        assert(1 == 0xff & owner_3[stor_4][0x8]);\n        v47 = v48 = 80;\n        if (owner_3[stor_4][12] < owner_3[stor_4][11]) {\n            v49 = v50 = STORAGE[12 + keccak256(stor_4, 3)];\n            while (v49 <= owner_3[stor_4][11]) {\n                if (0 != v47) {\n                    v51 = v52 = 0;\n                    while (v51 < 5) {\n                        v53 = v54 = 0;\n                        while (v53 < 5) {\n                            assert(v53 < 5);\n                            if (STORAGE[5 + keccak256(stor_4, 3) + (v53 >> 5)] / 256 ** (v53 % 32) & 0xff == 0xff & (0xffffffffff & STORAGE[1 + keccak256(v49, 10 + keccak256(stor_4))] << 216 >> 216) / 256 ** v51) {\n                                owner_3[stor_4] += 1;\n                            }\n                            v53 += 1;\n                        }\n                        v51 += 1;\n                    }\n                    owner_3[stor_4][12] += 1;\n                    v47 += ~0;\n                    v49 += 1;\n                    continue;\n                }\n            }\n        }\n        if (owner_3[stor_4][12] >= owner_3[stor_4][11]) {\n            v55 = v56 = 0;\n            while (v55 < owner_3[stor_4][11]) {\n                if (3 != STORAGE[keccak256(v55, 10 + keccak256(stor_4, 3))]) {\n                    if (owner_3[stor_4] != 4) {\n                        if (5 == owner_3[stor_4]) {\n                            owner_3[stor_4][1] += 1;\n                        }\n                    } else {\n                        owner_3[stor_4][1] += 1;\n                    }\n                } else {\n                    owner_3[stor_4][1] += 1;\n                }\n                v55 += 1;\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = 35 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = 25 * owner_3[stor_4][7] / 100 / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] > 0) {\n                owner_3[stor_4] = owner_3[stor_4][2] / owner_3[stor_4][1];\n            }\n            if (owner_3[stor_4][1] != 0) {\n                v57 = v58 = 0x56bc75e2d63100000;\n            } else {\n                v57 = v59 = 40 * owner_3[stor_4][7] / 100 + owner_3[stor_4][2];\n            }\n            owner_3[stor_4][8] = 0x2 | ~0xff & owner_3[stor_4][0x8];\n            stor_4 += 1;\n            owner_3[1 + stor_4] = block.number;\n            owner_3[1 + stor_4][2] = v57;\n            owner_3[1 + stor_4][3] = owner_3[stor_4][13];\n            owner_3[1 + stor_4][8] = ~0xff & owner_3[1 + stor_4][0x8];\n            goto 0x1c9b0x270B0x20e4;\n        }\n        goto 0x1e21;\n    }\n}\n\nfunction AdminGetFee() public payable { \n    assert(msg.sender == owner_0_0_19);\n    v0 = owner_0_0_19.call().value(stor_2);\n    assert(0 != v0);\n    stor_2 = 0;\n}\n\nfunction AdminDrawError() public payable { \n    v0 = v1 = address(owner_1) != msg.sender;\n    if (address(owner_1) != msg.sender) {\n        v0 = v2 = msg.sender != owner_0_0_19;\n    }\n    assert(!v0);\n    assert(1 == 0xff & owner_3[stor_4][0x8]);\n    owner_3[stor_4][7] = 0x2386f26fc10000 * owner_3[stor_4][11];\n    owner_3[stor_4][8] = 0x3 | ~0xff & owner_3[stor_4][0x8];\n    stor_4 += 1;\n    owner_3[1 + stor_4] = block.number;\n    owner_3[stor_4][2] = owner_3[stor_4][2];\n    owner_3[stor_4][3] = owner_3[stor_4][13];\n    owner_3[stor_4][8] = ~0xff & owner_3[stor_4][0x8];\n}\n\nfunction ContractStatus() public payable { \n    return 0xff & owner_1 >> 160;\n}\n\nfunction DrawDetails(uint256 GameId) public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 5;\n    do {\n        MEM[v0] = 0;\n        v0 += 32;\n        v2 = v2 - 1;\n    } while (!v2);\n    v4 = v5 = MEM[64];\n    MEM[v5] = 0;\n    if (0xff & owner_3[GameId][0x8] != 0) {\n        if (0xff & owner_3[GameId][0x8] != 1) {\n            if (0xff & owner_3[GameId][0x8] != 2) {\n                if (0xff & owner_3[GameId][0x8] == 3) {\n                    v4 = v6 = 'Failed';\n                    goto 0xc96;\n                }\n            } else {\n                v4 = v7 = 0x446f6e6500000000000000000000000000000000000000000000000000000000;\n            }\n        } else {\n            v4 = v8 = 'In Process';\n        }\n    } else {\n        v4 = v9 = 0x5761697400000000000000000000000000000000000000000000000000000000;\n    }\n    if (0xff & owner_3[GameId][0x8] == 0) {\n        v10 = v11 = MEM[64];\n        v12 = v13 = 0;\n        MEM[v11] = v13;\n        v14 = v15 = MEM[64];\n        MEM[v15] = v13;\n        MEM[v15 + 32] = v13;\n        MEM[v15 + 64] = v13;\n        MEM[v15 + 96] = v13;\n        MEM[v15 + 128] = v13;\n    } else {\n        v10 = v16 = new bytes[](v17);\n        v17 = (STORAGE[4 + keccak256(GameId, 3)] & ~0 + (!(STORAGE[4 + keccak256(GameId, 3)] & 0x1) << 8)) >> 1;\n        v18 = v19 = v16.data;\n        if (v17) {\n            if (31 < v17) {\n                do {\n                    MEM[v18] = STORAGE[v20];\n                    v20 += 1;\n                    v18 += 32;\n                } while (v19 + v17 <= v18);\n            } else {\n                MEM[v19] = STORAGE[4 + keccak256(GameId, 3)] >> 8 << 8;\n            }\n        }\n        v21 = v22 = 0;\n        v14 = v23 = MEM[64];\n        v24 = v25 = 5 + keccak256(GameId, 3);\n        do {\n            MEM[v14] = 0xff & STORAGE[v24] / 256 ** v21;\n            v24 += 1 + v21 >> 5;\n            v21 = (1 + v21) * (1 - (1 + v21 >> 5));\n            v14 += 32;\n        } while (v23 + 160 <= v14);\n        v12 = v26 = owner_3[3][1];\n        v12 = v27 = owner_3[4][1];\n        v12 = v28 = owner_3[5][1];\n        v12 = v29 = owner_3[3][0];\n        v12 = v30 = owner_3[4][0];\n        v12 = v31 = owner_3[5][0];\n        v12 = v32 = owner_3[5][9];\n        goto 0xd72;\n    }\n    MEM[MEM[64]] = owner_3[GameId][3];\n    MEM[MEM[64] + 96] = v12;\n    v33 = dataCopy(MEM[v14 len 160], MEM[(MEM[64] + 128) len 160]);\n    MEM[160 + (MEM[64] + 128)] = v12;\n    MEM[192 + (MEM[64] + 128)] = v12;\n    MEM[224 + (MEM[64] + 128)] = v12;\n    MEM[256 + (MEM[64] + 128)] = v12;\n    MEM[288 + (MEM[64] + 128)] = v12;\n    MEM[320 + (MEM[64] + 128)] = v12;\n    MEM[MEM[64] + 32] = 480;\n    MEM[352 + (MEM[64] + 128)] = MEM[v10];\n    v34 = dataCopy(MEM[(32 + v10) len (MEM[v10])], MEM[(384 + (MEM[64] + 128)) len (MEM[v10])]);\n    v35 = v36 = MEM[v10] + (384 + (MEM[64] + 128));\n    if (0x1f & MEM[v10]) {\n        MEM[v36 - (0x1f & MEM[v10])] = ~(256 ** (32 - (0x1f & MEM[v10])) - 1) & MEM[v36 - (0x1f & MEM[v10])];\n        v35 = v37 = 32 + (v36 - (0x1f & MEM[v10]));\n    }\n    MEM[MEM[64] + 64] = v35 - MEM[64];\n    MEM[v35] = MEM[v4];\n    v38 = dataCopy(MEM[(32 + v4) len (MEM[v4])], MEM[(32 + v35) len (MEM[v4])]);\n    v39 = v40 = MEM[v4] + (32 + v35);\n    if (0x1f & MEM[v4]) {\n        MEM[v40 - (0x1f & MEM[v4])] = ~(256 ** (32 - (0x1f & MEM[v4])) - 1) & MEM[v40 - (0x1f & MEM[v4])];\n        v39 = v41 = 32 + (v40 - (0x1f & MEM[v4]));\n    }\n    return MEM[(MEM[64]) len (v39 - MEM[64])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x68c966b) {\n            0x068c966b();\n        } else if (0xacf473b == function_selector >> 224) {\n            0x0acf473b();\n        } else if (0x1209b1f6 == function_selector >> 224) {\n            ticketPrice();\n        } else if (0x269975d0 == function_selector >> 224) {\n            0x269975d0();\n        } else if (0x26e770e9 == function_selector >> 224) {\n            Information();\n        } else if (0x370b6939 == function_selector >> 224) {\n            0x370b6939();\n        } else if (0x3e0663e0 == function_selector >> 224) {\n            0x3e0663e0();\n        } else if (0x3fa6497f == function_selector >> 224) {\n            0x3fa6497f();\n        } else if (0x69a8c3bf == function_selector >> 224) {\n            0x69a8c3bf();\n        } else if (0x6a907a78 == function_selector >> 224) {\n            0x6a907a78();\n        } else if (0x78e80b39 == function_selector >> 224) {\n            0x78e80b39();\n        } else if (0x7bc25372 == function_selector >> 224) {\n            0x7bc25372();\n        } else if (0x86e4e178 == function_selector >> 224) {\n            0x86e4e178();\n        } else if (0xa837aeb2 == function_selector >> 224) {\n            0xa837aeb2();\n        } else if (0xb6294bde == function_selector >> 224) {\n            0xb6294bde();\n        } else if (0xd96de4ce == function_selector >> 224) {\n            0xd96de4ce();\n        } else if (0xdd36e18b == function_selector >> 224) {\n            0xdd36e18b();\n        }\n    }\n    throw();\n}\n.",
	"status": "1",
	"time_cost": 39.435516595840454,
	"usage": {
		"completion_tokens": 741,
		"prompt_tokens": 9980,
		"total_tokens": 10721
	}
}