{
	"address": "0x04f062809b244e37e7fdc21d9409469c989c2342",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code contains a lot of complex logic, but I'll try to re-write it in Solidity code format. Please note that the decompiled code is not complete, and some parts are obfuscated or unclear, so the following Solidity code might not be entirely accurate or complete.\n\nHere's a simplified Solidity contract based on the provided decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract SampleContract {\n    mapping (address => uint256) private _balances;\n    mapping (address => bool) private _isAdmin;\n    address private _owner;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdraw(address indexed withdrawer, uint256 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Not contract owner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(_isAdmin[msg.sender], \"Not admin\");\n        _;\n    }\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function deposit() public payable {\n        _balances[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n        _balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function transferForAdmin(address from, address to, uint256 amount) public onlyAdmin {\n        require(_balances[from] >= amount, \"Insufficient balance\");\n        _balances[from] -= amount;\n        _balances[to] += amount;\n    }\n\n    function addToAdmin(address admin) public onlyOwner {\n        _isAdmin[admin] = true;\n    }\n\n    function removeFromAdmin(address admin) public onlyOwner {\n        _isAdmin[admin] = false;\n    }\n}\n```\n\nThis code includes some basic functions like deposit, withdraw and transferForAdmin. However, the decompiled code includes a lot of additional logic that is not implemented in this simplified contract, like the `changeLockPeriod` function, the `tokenId2Address` mapping, and so on.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039202,
	"id": "chatcmpl-8Chr0IwkbXjj3kJCEUkLLugBwncvF",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.14 12:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getBalance; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _userLock; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userNonce; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _usedHash; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _isAdmin; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _tokenId2Address; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _userId2Address; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _userAddress2Id; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokenAddress2Id; // STORAGE[0xa]\nuint256 _lockPeriod; // STORAGE[0xd]\nuint256 _userCount; // STORAGE[0xe]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _tradeEventEnabled; // STORAGE[0xf] bytes 0 to 0\nuint256 _joysoWallet; // STORAGE[0xb] bytes 0 to 19\nuint256 _joyToken; // STORAGE[0xc] bytes 0 to 19\nmapping (uint256 => [uint256]) _depositEther; // STORAGE[0xa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb49]\n\n// Events\nDeposit(address, address, uint256, uint256);\nWithdraw(address, address, uint256, uint256);\nLock(address, uint256);\nOwnershipTransferred(address, address);\nTradeSuccess(address, uint256, uint256, bool, uint256);\nNewUser(address, uint256);\n\nfunction () public payable { \n    revert();\n}\n\nfunction registerToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    require(varg1 > 1);\n    require(!_tokenAddress2Id[varg0]);\n    require(!address(_tokenId2Address[varg1]));\n    _tokenAddress2Id[varg0] = varg1;\n    _tokenAddress2Id[varg0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _tokenAddress2Id[varg0];\n}\n\nfunction userCount() public nonPayable { \n    return _userCount;\n}\n\nfunction transferForAdmin(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    require(_tokenAddress2Id[varg0]);\n    require(_userAddress2Id[msg.sender]);\n    0x2d2c(varg1);\n    require(varg2 <= _getBalance[msg.sender]);\n    _getBalance[msg.sender] = _getBalance[msg.sender] - varg2;\n    v3 = _SafeAdd(varg2, _getBalance[varg1]);\n    _getBalance[varg1] = v3;\n}\n\nfunction addToAdmin(address varg0, bool varg1) public nonPayable { \n    require(_owner == msg.sender);\n    _isAdmin[varg0] = varg1 | ~0xff & _isAdmin[varg0];\n}\n\nfunction joysoWallet() public nonPayable { \n    return _joysoWallet;\n}\n\nfunction 0x2a2e(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0);\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction isAdmin(address varg0) public nonPayable { \n    return 0xff & _isAdmin[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x2d2c(uint256 varg0) private { \n    v0 = address(varg0);\n    if (!_userAddress2Id[v0]) {\n        _userCount += 1;\n        v1 = address(varg0);\n        _userAddress2Id[v1] = 1 + _userCount;\n        _userAddress2Id[v1] = v1 | ~0xffffffffffffffffffffffffffffffffffffffff & _userAddress2Id[v1];\n        v2 = address(varg0);\n        emit NewUser(v2, _userCount);\n    }\n    return ;\n}\n\nfunction 0x2de0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    if (!varg1) {\n    }\n    v0 = _orderFills[varg0];\n    require(v0 <= varg4);\n    varg2 = v1 = varg4 - v0;\n    require(v1 > 0);\n    if (v1 < varg2) {\n    }\n    return varg2;\n}\n\nfunction 0x2e3d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg1) {\n        v0 = 0x2a2e(varg3, varg0);\n        assert(varg2);\n        v1 = v2 = v0 / varg2;\n    } else {\n        v3 = 0x2a2e(varg2, varg0);\n        assert(varg3);\n        v1 = v4 = v3 / varg3;\n    }\n    return v1;\n}\n\nfunction 0x2e89(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { \n    if (_orderFills[varg2]) {\n        varg5 = v0 = 0;\n    }\n    if (varg1) {\n        v1 = v2 = (varg4 & 0xffff0000000000000000000000000000000000000000000000000000) >> 208;\n    } else {\n        v1 = v3 = (varg4 & 0xffff000000000000000000000000000000000000000000000000) >> 192;\n    }\n    if (varg3) {\n        v4 = v1 * varg3;\n        assert(varg3);\n        require(v4 / varg3 == v1);\n    } else {\n        v4 = v5 = 0;\n    }\n    assert(10000);\n    v6 = v7 = v4 / 10000;\n    if (varg0) {\n        v8 = v9 = (varg4 & 0xfffffff00000000000000000000000000000000000000000) >> 164;\n    } else {\n        v8 = v10 = (varg4 & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n    }\n    if (v8) {\n        if (varg0) {\n            assert(v8);\n            v6 = v11 = v7 / 0x186a0 / v8;\n        } else {\n            assert(v8);\n            v6 = v12 = 0xe8d4a51000 * v7 / v8;\n        }\n    }\n    v13 = _SafeAdd(v6, varg5);\n    return v13;\n}\n\nfunction userNonce(address varg0) public nonPayable { \n    return _userNonce[varg0];\n}\n\nfunction 0x3003(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = uint32(varg6);\n    varg2 = v1 = 0;\n    if (!address(varg0)) {\n        v2 = v3 = (varg6 & 0xfffffff00000000000000000000000000000000000000000) >> 164;\n    } else {\n        v2 = v4 = (varg6 & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n    }\n    if (v2) {\n        varg2 = v5 = 0;\n    }\n    if (!varg5) {\n        v6 = address(varg0);\n        v7 = _SafeAdd(varg4, _getBalance[address(_userId2Address[v0])]);\n        require(varg2 <= v7);\n        v8 = address(varg0);\n        _getBalance[address(_userId2Address[v0])] = v7 - varg2;\n        v9 = address(varg1);\n        require(varg3 <= _getBalance[v9]);\n        v10 = address(varg1);\n        _getBalance[address(_userId2Address[v0])] = _getBalance[v9] - varg3;\n    } else {\n        v11 = address(varg0);\n        require(varg4 <= _getBalance[address(_userId2Address[v0])]);\n        v12 = _getBalance[address(_userId2Address[v0])] - varg4;\n        require(varg2 <= v12);\n        v13 = address(varg0);\n        _getBalance[address(_userId2Address[v0])] = v12 - varg2;\n        v14 = address(varg1);\n        v15 = _SafeAdd(varg3, _getBalance[v14]);\n        v16 = address(varg1);\n        _getBalance[address(_userId2Address[v0])] = v15;\n    }\n    if (!varg2) {\n        v17 = address(varg0);\n        v18 = _SafeAdd(varg2, _getBalance[_joysoWallet]);\n        v19 = address(varg0);\n        _getBalance[_joysoWallet] = v18;\n        return ;\n    } else {\n        require(varg2 <= _getBalance[address(_userId2Address[v0])]);\n        _getBalance[address(_userId2Address[v0])] = _getBalance[address(_userId2Address[v0])] - varg2;\n        v20 = _SafeAdd(varg2, _getBalance[_joysoWallet]);\n        _getBalance[_joysoWallet] = v20;\n        return ;\n    }\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    require(_tokenAddress2Id[varg0]);\n    0x2d2c(msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    v2 = _SafeAdd(varg1, _getBalance[msg.sender]);\n    _getBalance[msg.sender] = v2;\n    emit Deposit(varg0, msg.sender, varg1, v2);\n}\n\nfunction lockPeriod() public nonPayable { \n    return _lockPeriod;\n}\n\nfunction usedHash(bytes32 varg0) public nonPayable { \n    return 0xff & _usedHash[varg0];\n}\n\nfunction userLock(address varg0) public nonPayable { \n    return _userLock[varg0];\n}\n\nfunction collectFee(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(_getBalance[_joysoWallet] > 0);\n    _getBalance[_joysoWallet] = 0;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, _getBalance[_joysoWallet]).gas(msg.gas - 710);\n        require(v0);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(_getBalance[_joysoWallet]).gas(2300 * !_getBalance[_joysoWallet]);\n        require(v2);\n    }\n    emit Withdraw(varg0, _joysoWallet, _getBalance[_joysoWallet], 0);\n}\n\nfunction unlockMe() public nonPayable { \n    require(_userAddress2Id[msg.sender]);\n    _userLock[msg.sender] = 0;\n    emit Lock(msg.sender, 0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction userId2Address(uint256 varg0) public nonPayable { \n    return address(_userId2Address[varg0]);\n}\n\nfunction setTradeEventEnabled(bool varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _tradeEventEnabled = varg0;\n}\n\nfunction depositEther() public payable { \n    require(msg.value > 0);\n    0x2d2c(msg.sender);\n    v0 = _SafeAdd(msg.value, _depositEther[msg.sender]);\n    _depositEther[msg.sender] = v0;\n    emit Deposit(0, msg.sender, msg.value, v0);\n}\n\nfunction joyToken() public nonPayable { \n    return _joyToken;\n}\n\nfunction changeLockPeriod(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = v1 = varg0 <= 30;\n    if (v1) {\n        v0 = v2 = varg0 >= 1;\n    }\n    require(v0);\n    _lockPeriod = 0x15180 * varg0;\n}\n\nfunction tokenAddress2Id(address varg0) public nonPayable { \n    return _tokenAddress2Id[varg0];\n}\n\nfunction getBalance(address varg0, address varg1) public nonPayable { \n    return _getBalance[varg1];\n}\n\nfunction tradeEventEnabled() public nonPayable { \n    return _tradeEventEnabled;\n}\n\nfunction cancelByAdmin(uint256[] varg0) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    assert(1 < varg0.length);\n    require(varg0[32] >> 224 > _userNonce[address(_userId2Address[uint32(varg0[32])])]);\n    assert(0 < varg0.length);\n    if (!(varg0[32] & 0xf000000000000000000000000000000000000000)) {\n        v3 = v4 = 27;\n    } else {\n        v3 = v5 = 28;\n    }\n    assert(2 < varg0.length);\n    assert(3 < varg0.length);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v6, v7 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', keccak256(address(this), varg0[0], varg0[32] & ~0xffffffffffffffffffffffffffffffffffffffff)), 0xff & v3 & 0xff, varg0[64], varg0[96]);\n    require(v6);\n    require(address(MEM[MEM[64] - 32]) == address(_userId2Address[uint32(varg0[32])]));\n    v8 = v9 = 0;\n    if (0x10000000000000000000000000000000000000000 == varg0[32] & 0xf0000000000000000000000000000000000000000) {\n        v8 = v10 = _joyToken;\n    }\n    require(_getBalance[address(_userId2Address[uint32(varg0[32])])] >= varg0[0]);\n    require(varg0[0] <= _getBalance[address(_userId2Address[uint32(varg0[32])])]);\n    _getBalance[address(_userId2Address[uint32(varg0[32])])] = _getBalance[address(_userId2Address[uint32(varg0[32])])] - varg0[0];\n    v11 = _SafeAdd(varg0[0], _getBalance[_joysoWallet]);\n    _getBalance[_joysoWallet] = v11;\n    _userNonce[address(_userId2Address[uint32(varg0[32])])] = varg0[32] >> 224;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    v0 = v1 = block.timestamp > _userLock[msg.sender];\n    if (v1) {\n        v0 = v2 = _userLock[msg.sender];\n    }\n    require(v0);\n    require(varg1 <= _getBalance[msg.sender]);\n    _getBalance[msg.sender] = _getBalance[msg.sender] - varg1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v3, v4 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v3);\n        require(v4);\n    } else {\n        v5 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v5);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _getBalance[msg.sender]);\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction lockMe() public nonPayable { \n    require(_userAddress2Id[msg.sender]);\n    _userLock[msg.sender] = block.timestamp + _lockPeriod;\n    emit Lock(msg.sender, block.timestamp + _lockPeriod);\n}\n\nfunction tokenId2Address(uint256 varg0) public nonPayable { \n    return address(_tokenId2Address[varg0]);\n}\n\nfunction userAddress2Id(address varg0) public nonPayable { \n    return _userAddress2Id[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 51) {\n            require(!msg.value);\n            v1 = v2 = 415;\n            v1 = v3 = varg1 + 36;\n            v1 = v4 = varg1.length;\n            v1 = v5 = 0;\n            v1 = v6 = 0;\n            v1 = v7 = 0;\n            v1 = v8 = 0;\n            v1 = v9 = 0;\n            v10 = v11 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v10 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v10);\n            v12 = v13 = 8;\n            v14 = v15 = 0;\n            v16 = v17 = 1462;\n            v18 = v19 = 3;\n            assert(v19 < v4);\n            while (1) {\n                v20 = uint32(msg.data[(v18 << 5) + v1]);\n                goto {'0x5b6B0x18c', '0x7ed0x531B0x18c'};\n                MEM[v14] = v20;\n                MEM[v14 + 32] = v12;\n                v1 = v21 = address(STORAGE[keccak256(MEM[0x0 len (64 + v14)])]);\n                assert(v1 + 3 < v1);\n                require(msg.data[(v1 + 3 << 5) + v1] >> 224 > _userNonce[v21]);\n                v22 = 2189;\n                v23 = new uint256[](v1);\n                CALLDATACOPY(v23.data, v1, v1 << 5);\n                v24 = v25 = 3 + v1;\n                assert(v25 < v1);\n                v26 = msg.data[(v24 << 5) + v1];\n                if (v1 < MEM[v23]) {\n                    break;\n                }\n                assert(v1 < MEM[v23]);\n                if (1 + v1 < MEM[v23]) {\n                    break;\n                }\n                assert(1 + v1 < MEM[v23]);\n                if (2 + v1 < MEM[v23]) {\n                    break;\n                }\n                assert(2 + v1 < MEM[v23]);\n                v27 = address(v1) | v26 & ~0xffffffffffffffffffffffffffffffffffffffff;\n                v1 = v28 = keccak256(address(this), MEM[(v1 << 5) + (32 + v23)], MEM[(1 + v1 << 5) + (32 + v23)], MEM[(2 + v1 << 5) + (32 + v23)], v27, address(v1), (v26 & 0xfffffffffffffffffffffff0000000000000000) >> 64);\n                goto {'0x88d0x531B0x18c', '0x683B0x18c'};\n                v29 = 2254;\n                v30 = 2214;\n                v31 = v32 = v1 + 3;\n                assert(v32 < v1);\n                if (!(msg.data[(v31 << 5) + v1] & 0xf000000000000000000000000000000000000000)) {\n                    v33 = 27;\n                } else {\n                    v33 = v34 = 28;\n                }\n                v35 = v36 = 0xff & v33;\n                goto {'0x8a60x531B0x18c', '0x6a60x531B0x18c'};\n                assert(4 < v1);\n                v37 = msg.data[128 + v1];\n                v38 = 5;\n                assert(v38 < v1);\n                v39 = msg.data[(v38 << 5) + v1];\n                MEM[MEM[64]] = 0;\n                MEM[64] += 32;\n                MEM[32 + MEM[64]] = 0;\n                v40 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v1), v35 & 0xff, v37, v39);\n                require(v40);\n                goto {'0x8ce0x531B0x18c', '0x6d9B0x18c', '0xdda0x531B0x18c'};\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                v41 = v42 = 2370;\n                assert(v1 < v1);\n                v43 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v44 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v45 = msg.data[(2 + v1 << 5) + v1];\n                assert(3 + v1 < v1);\n                v1 = v46 = msg.data[(3 + v1 << 5) + v1];\n                v47 = 0x2de0(v1, v1, v1, v44, v43);\n                v48 = 0x2e3d(v47, v1, v44, v43);\n                v49 = 0x2e89(!address(v1), 0, v1, v48, v1, v45);\n                0x3003(v1, v1, v49, v47, v48, v1, v1);\n                v50 = _SafeAdd(v47, _orderFills[v1]);\n                _orderFills[v1] = v50;\n                require(v47 <= v1);\n                v1 = v1 - v47;\n                v1 = _SafeAdd(v48, v1);\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v1)]), v48, v47, v1, v49);\n                }\n                goto {'0xe380x531B0x18c', '0x9420x531B0x18c'};\n                v1 += 6;\n                goto 0x7540x531B0x18c;\n                v1 += 6;\n                if (v1 >= v1) {\n                    v51 = v52 = !v1;\n                    if (v52) {\n                        v53 = v54 = 3704;\n                        v55 = v56 = 1;\n                        assert(v56 < v1);\n                    } else {\n                        v53 = v57 = 3682;\n                        v55 = v58 = 0;\n                        assert(v58 < v1);\n                    }\n                } else {\n                    v59 = v60 = v1 > 0;\n                    if (v60) {\n                        v61 = v62 = 3170;\n                        assert(v1 < v1);\n                    }\n                }\n                require(v59);\n                assert(v1 + 3 < v1);\n                v1 = v63 = msg.data[(v1 + 3 << 5) + v1];\n                v1 = v64 = address(_userId2Address[uint32(v63)]);\n                require(v63 >> 224 > _userNonce[uint32(v63)]);\n                assert(v1 < v1);\n                v65 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v66 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v67 = msg.data[(2 + v1 << 5) + v1];\n                if (v1) {\n                    v68 = 0x10000000000000000000000000000000000000000;\n                } else {\n                    v68 = v69 = 0;\n                }\n                v70 = v63 & ~0xfffffffffffffffffffffffffffffffffffffffff | v68 | address(v1);\n                v1 = v71 = keccak256(address(this), v65, v66, v67, v70);\n                v29 = v72 = 3546;\n                if (0 == v63 & 0xf000000000000000000000000000000000000000) {\n                    v35 = 27;\n                    v73 = v74 = v1 + 4;\n                    assert(v74 < v1);\n                } else {\n                    v35 = v75 = 28;\n                }\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                v41 = v76 = 3640;\n                assert(v1 < v1);\n                v43 = v77 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v44 = v78 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v45 = v79 = msg.data[(2 + v1 << 5) + v1];\n                v1 = v80 = 0;\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                if (v1) {\n                    assert(1 < v1);\n                    v81 = msg.data[32 + v1];\n                } else {\n                    assert(0 < v1);\n                    v81 = v82 = msg.data[0 + v1];\n                }\n                require(_orderFills[v1] <= v81);\n                v1 = v83 = v81 - _orderFills[v1];\n                require(v83);\n                v1 = !v1;\n                v1 = v84 = 0;\n                v1 = v85 = 6;\n                if (v1 >= v1) {\n                    v51 = !v1;\n                    if (v51) {\n                        v53 = v86 = 2455;\n                        v55 = v87 = 1;\n                        assert(v87 < v1);\n                    } else {\n                        v53 = v88 = 2433;\n                        v55 = v89 = 0;\n                        assert(v89 < v1);\n                    }\n                } else {\n                    v90 = v91 = v1 > 0;\n                    if (v91) {\n                        v61 = v92 = 1953;\n                        assert(v1 < v1);\n                    }\n                }\n                v93 = msg.data[(v1 << 5) + v1];\n                v94 = 0;\n                assert(v94 < v1);\n                while (1) {\n                    v95 = msg.data[(v94 << 5) + v1];\n                    if (v95) {\n                        v1 = v96 = v93 * v95;\n                        assert(v95);\n                        require(v96 / v95 == v93);\n                    } else {\n                        v1 = v97 = 0;\n                    }\n                    goto {'0x7c90x531B0x18c', '0xc620x531B0x18c', '0xc740x531B0x18c', '0x7a10x531B0x18c'};\n                    v61 = v98 = 1993;\n                    v99 = v1 + 1;\n                    assert(v99 < v1);\n                    v93 = v100 = msg.data[(v99 << 5) + v1];\n                    v94 = v101 = 1;\n                    assert(v101 < v1);\n                    v61 = v102 = 3188;\n                    v99 = v103 = v1 + 1;\n                    assert(v103 < v1);\n                }\n                v90 = v1 <= v1;\n                v59 = v1 <= v1;\n                require(v90);\n                v12 = 8;\n                v14 = 0;\n                v16 = 2029;\n                v18 = v104 = v1 + 3;\n                assert(v104 < v1);\n                v105 = msg.data[(v55 << 5) + v1];\n                require(v1 <= v105);\n                goto {'0xe780x531B0x18c', '0x9970x531B0x18c', '0xe620x531B0x18c', '0x9810x531B0x18c'};\n                require(_orderFills[v1] <= v105 - v1);\n                v106 = v107 = v105 - v1 - _orderFills[v1];\n                v108 = v109 = 2548;\n                assert(2 < v1);\n                v110 = msg.data[64 + v1];\n                assert(3 < v1);\n                v111 = msg.data[96 + v1];\n                v112 = 0x2e89(!address(v1), 1, v1, v1, v111, v110);\n                0x3003(v1, v1, v112, v106, v1, v51, v111);\n                v113 = _SafeAdd(v106, _orderFills[v1]);\n                _orderFills[v1] = v113;\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v111)]), v1, v106, v51, v112);\n                }\n                goto 0x19f;\n                require(_orderFills[v1] <= v105 - v1);\n                v106 = v105 - v1 - _orderFills[v1];\n                v108 = v114 = 2548;\n                assert(2 < v1);\n                v110 = v115 = msg.data[64 + v1];\n                assert(3 < v1);\n                v111 = v116 = msg.data[96 + v1];\n                v1 = v117 = 0;\n                v73 = v1 + 4;\n                assert(v73 < v1);\n                v37 = v118 = msg.data[(v73 << 5) + v1];\n                v38 = v119 = v1 + 5;\n                assert(v119 < v1);\n                v29 = v120 = 1753;\n                v30 = v121 = 1702;\n                v31 = v122 = 3;\n                assert(v122 < v1);\n                MEM[v14] = v20;\n                MEM[v14 + 32] = v12;\n                v1 = v123 = address(STORAGE[keccak256(MEM[0x0 len (64 + v14)])]);\n                assert(3 < v1);\n                require(msg.data[96 + v1] >> 224 > _userNonce[v123]);\n                assert(3 < v1);\n                v124 = msg.data[96 + v1];\n                v1 = v125 = 0x10000000000000000000000000000000000000000 == v124 & 0xf0000000000000000000000000000000000000000;\n                if (0x10000000000000000000000000000000000000000 != v124 & 0xf0000000000000000000000000000000000000000) {\n                    v1 = v126 = address(_tokenId2Address[(v124 & 0xffff000000000000) >> 48]);\n                    v1 = v127 = address(_tokenId2Address[(v124 & 0xffff00000000) >> 32]);\n                } else {\n                    v1 = v128 = address(_tokenId2Address[(v124 & 0xffff00000000) >> 32]);\n                    v1 = v129 = address(_tokenId2Address[(v124 & 0xffff000000000000) >> 48]);\n                }\n                v22 = v130 = 1667;\n                v23 = v131 = new uint256[](v1);\n                CALLDATACOPY(v131.data, v1, v1 << 5);\n                v1 = v132 = 0;\n                v24 = v133 = 3;\n                assert(v133 < v1);\n            }\n        } else if (182 == v0) {\n            require(!msg.value);\n            v134 = v135 = 415;\n            v134 = v136 = varg1 + 36;\n            v134 = v137 = varg1.length;\n            v134 = v138 = 0;\n            v134 = v139 = 0;\n            v134 = v140 = 0;\n            v141 = v142 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v141 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v141);\n            assert(3 < v137);\n            v134 = v143 = varg1[96];\n            v134 = v144 = address(_userId2Address[uint32(v143)]);\n            require(v143 >> 224 > _userNonce[v144]);\n            v134 = v145 = 0;\n            if ((v143 & 0xffff000000000000) >> 48) {\n                v134 = v146 = address(_tokenId2Address[(v143 & 0xffff000000000000) >> 48]);\n            } else {\n                v134 = v147 = address(_tokenId2Address[(v143 & 0xffff00000000) >> 32]);\n                v134 = v148 = 1;\n            }\n            assert(0 < v137);\n            assert(1 < v137);\n            assert(2 < v137);\n            if (v149) {\n                v150 = v151 = 0x10000000000000000000000000000000000000000;\n            } else {\n                v150 = v152 = 0;\n            }\n            v134 = v153 = keccak256(address(this), varg1[0], varg1[32], varg1[64], v143 & ~0xfffffffffffffffffffffffffffffffffffffffff | v150 | address(v154));\n            v155 = v156 = 3013;\n            if (0 == v143 & 0xf000000000000000000000000000000000000000) {\n                v157 = v158 = 27;\n                v159 = v160 = 4;\n                assert(v160 < v137);\n            } else {\n                v157 = v161 = 28;\n                v159 = 4;\n                assert(v159 < v137);\n            }\n            v162 = varg1[v159 << 5];\n            v163 = 5;\n            assert(v163 < v137);\n            while (1) {\n                v164 = msg.data[(v163 << 5) + v134];\n                MEM[MEM[64]] = 0;\n                MEM[32 + MEM[64]] = 0;\n                v165, v166 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v134), v157 & 0xff, v162, v164);\n                if (v165) {\n                    break;\n                }\n                require(v165);\n                v167 = msg.data[(v168 << 5) + v134];\n                require(v134 <= v167);\n                goto {'0xe780xa01B0x1ac', '0xe620xa01B0x1ac', '0x9810xa01B0x1ac', '0x9970xa01B0x1ac'};\n                require(_orderFills[v134] <= v167 - v134);\n                v169 = v170 = v167 - v134 - _orderFills[v134];\n                v171 = v172 = 2548;\n                assert(2 < v134);\n                v173 = msg.data[64 + v134];\n                assert(3 < v134);\n                v174 = msg.data[96 + v134];\n                v175 = 0x2e89(!address(v134), 1, v134, v134, v174, v173);\n                0x3003(v134, v134, v175, v169, v134, v176, v174);\n                v177 = _SafeAdd(v169, _orderFills[v134]);\n                _orderFills[v134] = v177;\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v174)]), v134, v169, v176, v175);\n                }\n                require(_orderFills[v134] <= v167 - v134);\n                v169 = v167 - v134 - _orderFills[v134];\n                v171 = v178 = 2548;\n                assert(2 < v134);\n                v173 = v179 = msg.data[64 + v134];\n                assert(3 < v134);\n                v174 = v180 = msg.data[96 + v134];\n                v134 = v181 = 0;\n                goto {'0xbc5B0x1ac', '0x8ce0xa01B0x1ac', '0xdda0xa01B0x1ac'};\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                v182 = v183 = 2370;\n                assert(v134 < v134);\n                v184 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v185 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v186 = msg.data[(2 + v134 << 5) + v134];\n                assert(3 + v134 < v134);\n                v134 = v187 = msg.data[(3 + v134 << 5) + v134];\n                v188 = 0x2de0(v134, v134, v134, v185, v184);\n                v189 = 0x2e3d(v188, v134, v185, v184);\n                v190 = 0x2e89(!address(v134), 0, v134, v189, v134, v186);\n                0x3003(v134, v134, v190, v188, v189, v134, v134);\n                v191 = _SafeAdd(v188, _orderFills[v134]);\n                _orderFills[v134] = v191;\n                require(v188 <= v134);\n                v134 = v134 - v188;\n                v134 = _SafeAdd(v189, v134);\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v134)]), v189, v188, v134, v190);\n                }\n                goto {'0x9420xa01B0x1ac', '0xe380xa01B0x1ac'};\n                v134 += 6;\n                if (v134 >= v134) {\n                    v176 = !v134;\n                    if (v176) {\n                        v192 = v193 = 2455;\n                        v168 = v194 = 1;\n                        assert(v194 < v134);\n                    } else {\n                        v192 = v195 = 2433;\n                        v168 = v196 = 0;\n                        assert(v196 < v134);\n                    }\n                } else {\n                    v197 = v198 = v134 > 0;\n                    if (v198) {\n                        v199 = v200 = 1953;\n                        assert(v134 < v134);\n                    }\n                }\n                v134 += 6;\n                goto 0xc400xa01B0x1ac;\n                require(v197);\n                assert(v134 + 3 < v134);\n                v201 = uint32(msg.data[(v134 + 3 << 5) + v134]);\n                v134 = v202 = address(_userId2Address[v201]);\n                assert(v134 + 3 < v134);\n                require(msg.data[(v134 + 3 << 5) + v134] >> 224 > _userNonce[v202]);\n                v203 = new uint256[](v134);\n                CALLDATACOPY(v203.data, v134, v134 << 5);\n                assert(3 + v134 < v134);\n                assert(v134 < v203.length);\n                assert(1 + v134 < v203.length);\n                assert(2 + v134 < v203.length);\n                v204 = address(v134) | msg.data[(3 + v134 << 5) + v134] & ~0xffffffffffffffffffffffffffffffffffffffff;\n                v205 = (msg.data[(3 + v134 << 5) + v134] & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n                v134 = v206 = keccak256(address(this), v203[v134 << 5], v203[1 + v134], v203[2 + v134], v204, address(v134), v205);\n                v155 = 2254;\n                assert(v134 + 3 < v134);\n                if (!(msg.data[(v134 + 3 << 5) + v134] & 0xf000000000000000000000000000000000000000)) {\n                    v207 = 27;\n                } else {\n                    v207 = v208 = 28;\n                }\n                v157 = v209 = 0xff & v207;\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                v182 = v210 = 3640;\n                assert(v134 < v134);\n                v184 = v211 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v185 = v212 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v186 = v213 = msg.data[(2 + v134 << 5) + v134];\n                v134 = v214 = 0;\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                if (v134) {\n                    assert(1 < v134);\n                    v215 = msg.data[32 + v134];\n                } else {\n                    assert(0 < v134);\n                    v215 = v216 = msg.data[0 + v134];\n                }\n                require(_orderFills[v134] <= v215);\n                v134 = v217 = v215 - _orderFills[v134];\n                require(v217);\n                v134 = !v134;\n                v134 = v218 = 0;\n                v134 = v219 = 6;\n                if (v134 >= v134) {\n                    v176 = v220 = !v134;\n                    if (v220) {\n                        v192 = v221 = 3704;\n                        v168 = v222 = 1;\n                        assert(v222 < v134);\n                    } else {\n                        v192 = v223 = 3682;\n                        v168 = v224 = 0;\n                        assert(v224 < v134);\n                    }\n                } else {\n                    v225 = v226 = v134 > 0;\n                    if (v226) {\n                        v199 = v227 = 3170;\n                        assert(v134 < v134);\n                    }\n                }\n                v228 = msg.data[(v134 << 5) + v134];\n                v229 = 0;\n                assert(v229 < v134);\n                while (1) {\n                    v230 = msg.data[(v229 << 5) + v134];\n                    if (v230) {\n                        v134 = v231 = v228 * v230;\n                        assert(v230);\n                        require(v231 / v230 == v228);\n                    } else {\n                        v134 = v232 = 0;\n                    }\n                    goto {'0x7c90xa01B0x1ac', '0xc620xa01B0x1ac', '0xc740xa01B0x1ac', '0x7a10xa01B0x1ac'};\n                    v199 = v233 = 1993;\n                    v234 = v134 + 1;\n                    assert(v234 < v134);\n                    v228 = v235 = msg.data[(v234 << 5) + v134];\n                    v229 = v236 = 1;\n                    assert(v236 < v134);\n                    v199 = v237 = 3188;\n                    v234 = v238 = v134 + 1;\n                    assert(v238 < v134);\n                }\n                v197 = v134 <= v134;\n                v225 = v134 <= v134;\n                require(v225);\n                assert(v134 + 3 < v134);\n                v134 = v239 = msg.data[(v134 + 3 << 5) + v134];\n                v134 = v240 = address(_userId2Address[uint32(v239)]);\n                require(v239 >> 224 > _userNonce[uint32(v239)]);\n                assert(v134 < v134);\n                v241 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v242 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v243 = msg.data[(2 + v134 << 5) + v134];\n                if (v134) {\n                    v244 = 0x10000000000000000000000000000000000000000;\n                } else {\n                    v244 = v245 = 0;\n                }\n                v246 = v239 & ~0xfffffffffffffffffffffffffffffffffffffffff | v244 | address(v134);\n                v134 = v247 = keccak256(address(this), v241, v242, v243, v246);\n                v155 = v248 = 3546;\n                if (0 == v239 & 0xf000000000000000000000000000000000000000) {\n                    v157 = 27;\n                    v249 = v250 = v134 + 4;\n                    assert(v250 < v134);\n                } else {\n                    v157 = v251 = 28;\n                }\n                v249 = v134 + 4;\n                assert(v249 < v134);\n                v162 = v252 = msg.data[(v249 << 5) + v134];\n                v163 = v253 = v134 + 5;\n                assert(v253 < v134);\n            }\n        } else if (199 == v0) {\n            require(!msg.value);\n            v254 = v255 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v254 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v254);\n            assert(0 < varg1.length);\n            assert(1 < varg1.length);\n            assert(2 < varg1.length);\n            v256 = v257 = address(_tokenId2Address[(varg1[64] & 0xffff00000000) >> 32]);\n            v258 = keccak256(address(this), varg1[0], varg1[32], v257 | varg1[64] & ~0xffffffffffffffffffffffffffffffffffffffff);\n            require(!(0xff & _userId2Address[v258]));\n            if (!(varg1[64] & 0xf000000000000000000000000000000000000000)) {\n                v259 = v260 = 27;\n            } else {\n                v259 = v261 = 28;\n            }\n            assert(3 < varg1.length);\n            assert(4 < varg1.length);\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            v262, v263 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v258), v259 & 0xff, varg1[96], varg1[128]);\n            require(v262);\n            require(address(MEM[MEM[64] - 32]) == address(_userId2Address[uint32(varg1[64])]));\n            v256 = v264 = 0;\n            if (varg1[64] & 0xf0000000000000000000000000000000000000000 == 0x10000000000000000000000000000000000000000) {\n                v256 = _joyToken;\n            }\n            if (address(v256) != address(v257)) {\n                require(varg1[0] <= _getBalance[address(_userId2Address[uint32(varg1[64])])]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(_userId2Address[uint32(varg1[64])])] - varg1[0];\n                require(varg1[32] <= _getBalance[address(v256)]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(v256)] - varg1[32];\n            } else {\n                v265 = _SafeAdd(varg1[32], varg1[0]);\n                require(v265 <= _getBalance[address(_userId2Address[uint32(varg1[64])])]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(_userId2Address[uint32(varg1[64])])] - v265;\n            }\n            v266 = _SafeAdd(varg1[32], _getBalance[_joysoWallet]);\n            _getBalance[_joysoWallet] = v266;\n            _usedHash[_joysoWallet] = 0x1 | ~0xff & _usedHash[_joysoWallet];\n            if (address(v257)) {\n                MEM[32 + MEM[64]] = 0;\n                require((address(v257)).code.size);\n                v267, v268 = address(v257).transfer(address(_userId2Address[uint32(varg1[64])]), varg1[0]).gas(msg.gas - 710);\n                require(v267);\n                require(v268);\n                goto 0x33ad;\n            } else {\n                v269 = address(_userId2Address[uint32(varg1[64])]).call().value(varg1[0]).gas(2300 * !varg1[0]);\n                require(v269);\n            }\n            exit;\n        } else if (44723 == v0) {\n            require(!msg.value);\n            v270 = v271 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v270 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v270);\n            assert(2 < varg1.length);\n            v272 = address(_tokenId2Address[(varg1[0x40] & 0xffff00000000) >> 32]);\n            assert(0 < varg1.length);\n            v273 = v274 = 1;\n            while (v273 < varg1.length) {\n                if (v273 < varg1.length) {\n                    break;\n                }\n                assert(v273 < varg1.length);\n                if (1 + v273 < varg1.length) {\n                    break;\n                }\n                assert(1 + v273 < varg1.length);\n                v275 = address(_userId2Address[uint32(varg1[1 + v273 << 5])]);\n                v276 = varg1[1 + v273 << 5] & ~0xffffffffffffffffffffffffffffffffffffffff | address(v272);\n                if (0 == varg1[1 + v273 << 5] & 0xf000000000000000000000000000000000000000) {\n                    v277 = v278 = 27;\n                } else {\n                    v277 = v279 = 28;\n                }\n                assert(v273 + 2 < varg1.length);\n                assert(v273 + 3 < varg1.length);\n                MEM[MEM[64]] = 0;\n                MEM[32 + MEM[64]] = 0;\n                v280, v281 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', keccak256(address(this), varg1[v273], v276, address(varg1[0x0]))), v277 & 0xff, varg1[v273 + 2 << 5], varg1[v273 + 3 << 5]);\n                require(v280);\n                require(address(MEM[MEM[64] - 32]) == address(v275));\n                if (varg1[v273] > 0) {\n                    if (varg1[1 + v273 << 5] & 0xf0000000000000000000000000000000000000000 != 0x10000000000000000000000000000000000000000) {\n                        if (varg1[1 + v273 << 5] & 0xf0000000000000000000000000000000000000000 != 0x20000000000000000000000000000000000000000) {\n                            require(varg1[v273] <= _depositEther[address(v275)]);\n                            _depositEther[address(v275)] = _depositEther[address(v275)] - varg1[v273];\n                            v282 = _SafeAdd(varg1[v273], _depositEther[_joysoWallet]);\n                            _depositEther[_joysoWallet] = v282;\n                        } else {\n                            require(varg1[v273] <= _getBalance[address(v275)]);\n                            _getBalance[address(v275)] = _getBalance[address(v275)] - varg1[v273];\n                            v283 = _SafeAdd(varg1[v273], _getBalance[_joysoWallet]);\n                            _getBalance[_joysoWallet] = v283;\n                        }\n                    } else {\n                        require(varg1[v273] <= _getBalance[address(v275)]);\n                        _getBalance[address(v275)] = _getBalance[address(v275)] - varg1[v273];\n                        v284 = _SafeAdd(varg1[v273], _getBalance[_joysoWallet]);\n                        _getBalance[_joysoWallet] = v284;\n                    }\n                }\n                _getBalance[address(v275)] = 0;\n                if (address(v272)) {\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x95ea7b300000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(varg1[0x0]);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    require((address(v272)).code.size);\n                    v285 = address(v272).call(v286, v276).gas(msg.gas - 710);\n                    require(v285);\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x3b9ca2d000000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(v275);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    MEM[MEM[64] + 68] = address(v272);\n                    require((address(varg1[0x0])).code.size);\n                    v287 = address(varg1[0x0]).call(v286, v276, varg1[v273 + 2 << 5]).gas(msg.gas - 710);\n                    require(v287);\n                } else {\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x3b9ca2d000000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(v275);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    MEM[MEM[64] + 68] = address(v272);\n                    require((address(varg1[0x0])).code.size);\n                    v288 = address(varg1[0x0]).call(v286, v276, varg1[v273 + 2 << 5]).value(_getBalance[address(v275)]).gas(msg.gas - 9710);\n                    require(v288);\n                }\n                v273 = v273 + 4;\n            }\n            exit;\n        } else if (0x2ca5994 == v0) {\n            registerToken(address,uint256);\n        } else if (0x7973ccf == v0) {\n            userCount();\n        } else if (0x7c4d580 == v0) {\n            transferForAdmin(address,address,uint256);\n        } else if (0xf7c9085 == v0) {\n            addToAdmin(address,bool);\n        } else if (0x135a2474 == v0) {\n            joysoWallet();\n        } else if (0x24d7806c == v0) {\n            isAdmin(address);\n        } else if (0x2e04b8e7 == v0) {\n            userNonce(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3fd8b02f == v0) {\n            lockPeriod();\n        } else if (0x560ebbd1 == v0) {\n            usedHash(bytes32);\n        } else if (0x5617a6e8 == v0) {\n            userLock(address);\n        } else if (0x69b59e75 == v0) {\n            collectFee(address);\n        } else if (0x774bafdf == v0) {\n            unlockMe();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x934e1666 == v0) {\n            userId2Address(uint256);\n        } else if (0x98a36ebf == v0) {\n            setTradeEventEnabled(bool);\n        } else if (0x98ea5fca == v0) {\n            depositEther();\n        } else if (0xa64968ac == v0) {\n            joyToken();\n        } else if (0xc25cf1d0 == v0) {\n            changeLockPeriod(uint256);\n        } else if (0xc8799b37 == v0) {\n            tokenAddress2Id(address);\n        } else if (0xd4fac45d == v0) {\n            getBalance(address,address);\n        } else if (0xd5893bb2 == v0) {\n            tradeEventEnabled();\n        } else if (0xd86bc1b0 == v0) {\n            cancelByAdmin(uint256[]);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf912ed00 == v0) {\n            lockMe();\n        } else if (0xfa769257 == v0) {\n            tokenId2Address(uint256);\n        } else if (0xffc69ab1 == v0) {\n            userAddress2Id(address);\n        }\n        exit;\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.14 12:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getBalance; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _userLock; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userNonce; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _usedHash; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _isAdmin; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _tokenId2Address; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _userId2Address; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _userAddress2Id; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokenAddress2Id; // STORAGE[0xa]\nuint256 _lockPeriod; // STORAGE[0xd]\nuint256 _userCount; // STORAGE[0xe]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _tradeEventEnabled; // STORAGE[0xf] bytes 0 to 0\nuint256 _joysoWallet; // STORAGE[0xb] bytes 0 to 19\nuint256 _joyToken; // STORAGE[0xc] bytes 0 to 19\nmapping (uint256 => [uint256]) _depositEther; // STORAGE[0xa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb49]\n\n// Events\nDeposit(address, address, uint256, uint256);\nWithdraw(address, address, uint256, uint256);\nLock(address, uint256);\nOwnershipTransferred(address, address);\nTradeSuccess(address, uint256, uint256, bool, uint256);\nNewUser(address, uint256);\n\nfunction () public payable { \n    revert();\n}\n\nfunction registerToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    require(varg1 > 1);\n    require(!_tokenAddress2Id[varg0]);\n    require(!address(_tokenId2Address[varg1]));\n    _tokenAddress2Id[varg0] = varg1;\n    _tokenAddress2Id[varg0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _tokenAddress2Id[varg0];\n}\n\nfunction userCount() public nonPayable { \n    return _userCount;\n}\n\nfunction transferForAdmin(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    require(_tokenAddress2Id[varg0]);\n    require(_userAddress2Id[msg.sender]);\n    0x2d2c(varg1);\n    require(varg2 <= _getBalance[msg.sender]);\n    _getBalance[msg.sender] = _getBalance[msg.sender] - varg2;\n    v3 = _SafeAdd(varg2, _getBalance[varg1]);\n    _getBalance[varg1] = v3;\n}\n\nfunction addToAdmin(address varg0, bool varg1) public nonPayable { \n    require(_owner == msg.sender);\n    _isAdmin[varg0] = varg1 | ~0xff & _isAdmin[varg0];\n}\n\nfunction joysoWallet() public nonPayable { \n    return _joysoWallet;\n}\n\nfunction 0x2a2e(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0);\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction isAdmin(address varg0) public nonPayable { \n    return 0xff & _isAdmin[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x2d2c(uint256 varg0) private { \n    v0 = address(varg0);\n    if (!_userAddress2Id[v0]) {\n        _userCount += 1;\n        v1 = address(varg0);\n        _userAddress2Id[v1] = 1 + _userCount;\n        _userAddress2Id[v1] = v1 | ~0xffffffffffffffffffffffffffffffffffffffff & _userAddress2Id[v1];\n        v2 = address(varg0);\n        emit NewUser(v2, _userCount);\n    }\n    return ;\n}\n\nfunction 0x2de0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    if (!varg1) {\n    }\n    v0 = _orderFills[varg0];\n    require(v0 <= varg4);\n    varg2 = v1 = varg4 - v0;\n    require(v1 > 0);\n    if (v1 < varg2) {\n    }\n    return varg2;\n}\n\nfunction 0x2e3d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg1) {\n        v0 = 0x2a2e(varg3, varg0);\n        assert(varg2);\n        v1 = v2 = v0 / varg2;\n    } else {\n        v3 = 0x2a2e(varg2, varg0);\n        assert(varg3);\n        v1 = v4 = v3 / varg3;\n    }\n    return v1;\n}\n\nfunction 0x2e89(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { \n    if (_orderFills[varg2]) {\n        varg5 = v0 = 0;\n    }\n    if (varg1) {\n        v1 = v2 = (varg4 & 0xffff0000000000000000000000000000000000000000000000000000) >> 208;\n    } else {\n        v1 = v3 = (varg4 & 0xffff000000000000000000000000000000000000000000000000) >> 192;\n    }\n    if (varg3) {\n        v4 = v1 * varg3;\n        assert(varg3);\n        require(v4 / varg3 == v1);\n    } else {\n        v4 = v5 = 0;\n    }\n    assert(10000);\n    v6 = v7 = v4 / 10000;\n    if (varg0) {\n        v8 = v9 = (varg4 & 0xfffffff00000000000000000000000000000000000000000) >> 164;\n    } else {\n        v8 = v10 = (varg4 & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n    }\n    if (v8) {\n        if (varg0) {\n            assert(v8);\n            v6 = v11 = v7 / 0x186a0 / v8;\n        } else {\n            assert(v8);\n            v6 = v12 = 0xe8d4a51000 * v7 / v8;\n        }\n    }\n    v13 = _SafeAdd(v6, varg5);\n    return v13;\n}\n\nfunction userNonce(address varg0) public nonPayable { \n    return _userNonce[varg0];\n}\n\nfunction 0x3003(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = uint32(varg6);\n    varg2 = v1 = 0;\n    if (!address(varg0)) {\n        v2 = v3 = (varg6 & 0xfffffff00000000000000000000000000000000000000000) >> 164;\n    } else {\n        v2 = v4 = (varg6 & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n    }\n    if (v2) {\n        varg2 = v5 = 0;\n    }\n    if (!varg5) {\n        v6 = address(varg0);\n        v7 = _SafeAdd(varg4, _getBalance[address(_userId2Address[v0])]);\n        require(varg2 <= v7);\n        v8 = address(varg0);\n        _getBalance[address(_userId2Address[v0])] = v7 - varg2;\n        v9 = address(varg1);\n        require(varg3 <= _getBalance[v9]);\n        v10 = address(varg1);\n        _getBalance[address(_userId2Address[v0])] = _getBalance[v9] - varg3;\n    } else {\n        v11 = address(varg0);\n        require(varg4 <= _getBalance[address(_userId2Address[v0])]);\n        v12 = _getBalance[address(_userId2Address[v0])] - varg4;\n        require(varg2 <= v12);\n        v13 = address(varg0);\n        _getBalance[address(_userId2Address[v0])] = v12 - varg2;\n        v14 = address(varg1);\n        v15 = _SafeAdd(varg3, _getBalance[v14]);\n        v16 = address(varg1);\n        _getBalance[address(_userId2Address[v0])] = v15;\n    }\n    if (!varg2) {\n        v17 = address(varg0);\n        v18 = _SafeAdd(varg2, _getBalance[_joysoWallet]);\n        v19 = address(varg0);\n        _getBalance[_joysoWallet] = v18;\n        return ;\n    } else {\n        require(varg2 <= _getBalance[address(_userId2Address[v0])]);\n        _getBalance[address(_userId2Address[v0])] = _getBalance[address(_userId2Address[v0])] - varg2;\n        v20 = _SafeAdd(varg2, _getBalance[_joysoWallet]);\n        _getBalance[_joysoWallet] = v20;\n        return ;\n    }\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    require(_tokenAddress2Id[varg0]);\n    0x2d2c(msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    v2 = _SafeAdd(varg1, _getBalance[msg.sender]);\n    _getBalance[msg.sender] = v2;\n    emit Deposit(varg0, msg.sender, varg1, v2);\n}\n\nfunction lockPeriod() public nonPayable { \n    return _lockPeriod;\n}\n\nfunction usedHash(bytes32 varg0) public nonPayable { \n    return 0xff & _usedHash[varg0];\n}\n\nfunction userLock(address varg0) public nonPayable { \n    return _userLock[varg0];\n}\n\nfunction collectFee(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(_getBalance[_joysoWallet] > 0);\n    _getBalance[_joysoWallet] = 0;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, _getBalance[_joysoWallet]).gas(msg.gas - 710);\n        require(v0);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(_getBalance[_joysoWallet]).gas(2300 * !_getBalance[_joysoWallet]);\n        require(v2);\n    }\n    emit Withdraw(varg0, _joysoWallet, _getBalance[_joysoWallet], 0);\n}\n\nfunction unlockMe() public nonPayable { \n    require(_userAddress2Id[msg.sender]);\n    _userLock[msg.sender] = 0;\n    emit Lock(msg.sender, 0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction userId2Address(uint256 varg0) public nonPayable { \n    return address(_userId2Address[varg0]);\n}\n\nfunction setTradeEventEnabled(bool varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _tradeEventEnabled = varg0;\n}\n\nfunction depositEther() public payable { \n    require(msg.value > 0);\n    0x2d2c(msg.sender);\n    v0 = _SafeAdd(msg.value, _depositEther[msg.sender]);\n    _depositEther[msg.sender] = v0;\n    emit Deposit(0, msg.sender, msg.value, v0);\n}\n\nfunction joyToken() public nonPayable { \n    return _joyToken;\n}\n\nfunction changeLockPeriod(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = v1 = varg0 <= 30;\n    if (v1) {\n        v0 = v2 = varg0 >= 1;\n    }\n    require(v0);\n    _lockPeriod = 0x15180 * varg0;\n}\n\nfunction tokenAddress2Id(address varg0) public nonPayable { \n    return _tokenAddress2Id[varg0];\n}\n\nfunction getBalance(address varg0, address varg1) public nonPayable { \n    return _getBalance[varg1];\n}\n\nfunction tradeEventEnabled() public nonPayable { \n    return _tradeEventEnabled;\n}\n\nfunction cancelByAdmin(uint256[] varg0) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    assert(1 < varg0.length);\n    require(varg0[32] >> 224 > _userNonce[address(_userId2Address[uint32(varg0[32])])]);\n    assert(0 < varg0.length);\n    if (!(varg0[32] & 0xf000000000000000000000000000000000000000)) {\n        v3 = v4 = 27;\n    } else {\n        v3 = v5 = 28;\n    }\n    assert(2 < varg0.length);\n    assert(3 < varg0.length);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v6, v7 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', keccak256(address(this), varg0[0], varg0[32] & ~0xffffffffffffffffffffffffffffffffffffffff)), 0xff & v3 & 0xff, varg0[64], varg0[96]);\n    require(v6);\n    require(address(MEM[MEM[64] - 32]) == address(_userId2Address[uint32(varg0[32])]));\n    v8 = v9 = 0;\n    if (0x10000000000000000000000000000000000000000 == varg0[32] & 0xf0000000000000000000000000000000000000000) {\n        v8 = v10 = _joyToken;\n    }\n    require(_getBalance[address(_userId2Address[uint32(varg0[32])])] >= varg0[0]);\n    require(varg0[0] <= _getBalance[address(_userId2Address[uint32(varg0[32])])]);\n    _getBalance[address(_userId2Address[uint32(varg0[32])])] = _getBalance[address(_userId2Address[uint32(varg0[32])])] - varg0[0];\n    v11 = _SafeAdd(varg0[0], _getBalance[_joysoWallet]);\n    _getBalance[_joysoWallet] = v11;\n    _userNonce[address(_userId2Address[uint32(varg0[32])])] = varg0[32] >> 224;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    v0 = v1 = block.timestamp > _userLock[msg.sender];\n    if (v1) {\n        v0 = v2 = _userLock[msg.sender];\n    }\n    require(v0);\n    require(varg1 <= _getBalance[msg.sender]);\n    _getBalance[msg.sender] = _getBalance[msg.sender] - varg1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v3, v4 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v3);\n        require(v4);\n    } else {\n        v5 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v5);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _getBalance[msg.sender]);\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction lockMe() public nonPayable { \n    require(_userAddress2Id[msg.sender]);\n    _userLock[msg.sender] = block.timestamp + _lockPeriod;\n    emit Lock(msg.sender, block.timestamp + _lockPeriod);\n}\n\nfunction tokenId2Address(uint256 varg0) public nonPayable { \n    return address(_tokenId2Address[varg0]);\n}\n\nfunction userAddress2Id(address varg0) public nonPayable { \n    return _userAddress2Id[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 51) {\n            require(!msg.value);\n            v1 = v2 = 415;\n            v1 = v3 = varg1 + 36;\n            v1 = v4 = varg1.length;\n            v1 = v5 = 0;\n            v1 = v6 = 0;\n            v1 = v7 = 0;\n            v1 = v8 = 0;\n            v1 = v9 = 0;\n            v10 = v11 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v10 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v10);\n            v12 = v13 = 8;\n            v14 = v15 = 0;\n            v16 = v17 = 1462;\n            v18 = v19 = 3;\n            assert(v19 < v4);\n            while (1) {\n                v20 = uint32(msg.data[(v18 << 5) + v1]);\n                goto {'0x5b6B0x18c', '0x7ed0x531B0x18c'};\n                MEM[v14] = v20;\n                MEM[v14 + 32] = v12;\n                v1 = v21 = address(STORAGE[keccak256(MEM[0x0 len (64 + v14)])]);\n                assert(v1 + 3 < v1);\n                require(msg.data[(v1 + 3 << 5) + v1] >> 224 > _userNonce[v21]);\n                v22 = 2189;\n                v23 = new uint256[](v1);\n                CALLDATACOPY(v23.data, v1, v1 << 5);\n                v24 = v25 = 3 + v1;\n                assert(v25 < v1);\n                v26 = msg.data[(v24 << 5) + v1];\n                if (v1 < MEM[v23]) {\n                    break;\n                }\n                assert(v1 < MEM[v23]);\n                if (1 + v1 < MEM[v23]) {\n                    break;\n                }\n                assert(1 + v1 < MEM[v23]);\n                if (2 + v1 < MEM[v23]) {\n                    break;\n                }\n                assert(2 + v1 < MEM[v23]);\n                v27 = address(v1) | v26 & ~0xffffffffffffffffffffffffffffffffffffffff;\n                v1 = v28 = keccak256(address(this), MEM[(v1 << 5) + (32 + v23)], MEM[(1 + v1 << 5) + (32 + v23)], MEM[(2 + v1 << 5) + (32 + v23)], v27, address(v1), (v26 & 0xfffffffffffffffffffffff0000000000000000) >> 64);\n                goto {'0x88d0x531B0x18c', '0x683B0x18c'};\n                v29 = 2254;\n                v30 = 2214;\n                v31 = v32 = v1 + 3;\n                assert(v32 < v1);\n                if (!(msg.data[(v31 << 5) + v1] & 0xf000000000000000000000000000000000000000)) {\n                    v33 = 27;\n                } else {\n                    v33 = v34 = 28;\n                }\n                v35 = v36 = 0xff & v33;\n                goto {'0x8a60x531B0x18c', '0x6a60x531B0x18c'};\n                assert(4 < v1);\n                v37 = msg.data[128 + v1];\n                v38 = 5;\n                assert(v38 < v1);\n                v39 = msg.data[(v38 << 5) + v1];\n                MEM[MEM[64]] = 0;\n                MEM[64] += 32;\n                MEM[32 + MEM[64]] = 0;\n                v40 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v1), v35 & 0xff, v37, v39);\n                require(v40);\n                goto {'0x8ce0x531B0x18c', '0x6d9B0x18c', '0xdda0x531B0x18c'};\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                v41 = v42 = 2370;\n                assert(v1 < v1);\n                v43 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v44 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v45 = msg.data[(2 + v1 << 5) + v1];\n                assert(3 + v1 < v1);\n                v1 = v46 = msg.data[(3 + v1 << 5) + v1];\n                v47 = 0x2de0(v1, v1, v1, v44, v43);\n                v48 = 0x2e3d(v47, v1, v44, v43);\n                v49 = 0x2e89(!address(v1), 0, v1, v48, v1, v45);\n                0x3003(v1, v1, v49, v47, v48, v1, v1);\n                v50 = _SafeAdd(v47, _orderFills[v1]);\n                _orderFills[v1] = v50;\n                require(v47 <= v1);\n                v1 = v1 - v47;\n                v1 = _SafeAdd(v48, v1);\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v1)]), v48, v47, v1, v49);\n                }\n                goto {'0xe380x531B0x18c', '0x9420x531B0x18c'};\n                v1 += 6;\n                goto 0x7540x531B0x18c;\n                v1 += 6;\n                if (v1 >= v1) {\n                    v51 = v52 = !v1;\n                    if (v52) {\n                        v53 = v54 = 3704;\n                        v55 = v56 = 1;\n                        assert(v56 < v1);\n                    } else {\n                        v53 = v57 = 3682;\n                        v55 = v58 = 0;\n                        assert(v58 < v1);\n                    }\n                } else {\n                    v59 = v60 = v1 > 0;\n                    if (v60) {\n                        v61 = v62 = 3170;\n                        assert(v1 < v1);\n                    }\n                }\n                require(v59);\n                assert(v1 + 3 < v1);\n                v1 = v63 = msg.data[(v1 + 3 << 5) + v1];\n                v1 = v64 = address(_userId2Address[uint32(v63)]);\n                require(v63 >> 224 > _userNonce[uint32(v63)]);\n                assert(v1 < v1);\n                v65 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v66 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v67 = msg.data[(2 + v1 << 5) + v1];\n                if (v1) {\n                    v68 = 0x10000000000000000000000000000000000000000;\n                } else {\n                    v68 = v69 = 0;\n                }\n                v70 = v63 & ~0xfffffffffffffffffffffffffffffffffffffffff | v68 | address(v1);\n                v1 = v71 = keccak256(address(this), v65, v66, v67, v70);\n                v29 = v72 = 3546;\n                if (0 == v63 & 0xf000000000000000000000000000000000000000) {\n                    v35 = 27;\n                    v73 = v74 = v1 + 4;\n                    assert(v74 < v1);\n                } else {\n                    v35 = v75 = 28;\n                }\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                v41 = v76 = 3640;\n                assert(v1 < v1);\n                v43 = v77 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v44 = v78 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v45 = v79 = msg.data[(2 + v1 << 5) + v1];\n                v1 = v80 = 0;\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                if (v1) {\n                    assert(1 < v1);\n                    v81 = msg.data[32 + v1];\n                } else {\n                    assert(0 < v1);\n                    v81 = v82 = msg.data[0 + v1];\n                }\n                require(_orderFills[v1] <= v81);\n                v1 = v83 = v81 - _orderFills[v1];\n                require(v83);\n                v1 = !v1;\n                v1 = v84 = 0;\n                v1 = v85 = 6;\n                if (v1 >= v1) {\n                    v51 = !v1;\n                    if (v51) {\n                        v53 = v86 = 2455;\n                        v55 = v87 = 1;\n                        assert(v87 < v1);\n                    } else {\n                        v53 = v88 = 2433;\n                        v55 = v89 = 0;\n                        assert(v89 < v1);\n                    }\n                } else {\n                    v90 = v91 = v1 > 0;\n                    if (v91) {\n                        v61 = v92 = 1953;\n                        assert(v1 < v1);\n                    }\n                }\n                v93 = msg.data[(v1 << 5) + v1];\n                v94 = 0;\n                assert(v94 < v1);\n                while (1) {\n                    v95 = msg.data[(v94 << 5) + v1];\n                    if (v95) {\n                        v1 = v96 = v93 * v95;\n                        assert(v95);\n                        require(v96 / v95 == v93);\n                    } else {\n                        v1 = v97 = 0;\n                    }\n                    goto {'0x7c90x531B0x18c', '0xc620x531B0x18c', '0xc740x531B0x18c', '0x7a10x531B0x18c'};\n                    v61 = v98 = 1993;\n                    v99 = v1 + 1;\n                    assert(v99 < v1);\n                    v93 = v100 = msg.data[(v99 << 5) + v1];\n                    v94 = v101 = 1;\n                    assert(v101 < v1);\n                    v61 = v102 = 3188;\n                    v99 = v103 = v1 + 1;\n                    assert(v103 < v1);\n                }\n                v90 = v1 <= v1;\n                v59 = v1 <= v1;\n                require(v90);\n                v12 = 8;\n                v14 = 0;\n                v16 = 2029;\n                v18 = v104 = v1 + 3;\n                assert(v104 < v1);\n                v105 = msg.data[(v55 << 5) + v1];\n                require(v1 <= v105);\n                goto {'0xe780x531B0x18c', '0x9970x531B0x18c', '0xe620x531B0x18c', '0x9810x531B0x18c'};\n                require(_orderFills[v1] <= v105 - v1);\n                v106 = v107 = v105 - v1 - _orderFills[v1];\n                v108 = v109 = 2548;\n                assert(2 < v1);\n                v110 = msg.data[64 + v1];\n                assert(3 < v1);\n                v111 = msg.data[96 + v1];\n                v112 = 0x2e89(!address(v1), 1, v1, v1, v111, v110);\n                0x3003(v1, v1, v112, v106, v1, v51, v111);\n                v113 = _SafeAdd(v106, _orderFills[v1]);\n                _orderFills[v1] = v113;\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v111)]), v1, v106, v51, v112);\n                }\n                goto 0x19f;\n                require(_orderFills[v1] <= v105 - v1);\n                v106 = v105 - v1 - _orderFills[v1];\n                v108 = v114 = 2548;\n                assert(2 < v1);\n                v110 = v115 = msg.data[64 + v1];\n                assert(3 < v1);\n                v111 = v116 = msg.data[96 + v1];\n                v1 = v117 = 0;\n                v73 = v1 + 4;\n                assert(v73 < v1);\n                v37 = v118 = msg.data[(v73 << 5) + v1];\n                v38 = v119 = v1 + 5;\n                assert(v119 < v1);\n                v29 = v120 = 1753;\n                v30 = v121 = 1702;\n                v31 = v122 = 3;\n                assert(v122 < v1);\n                MEM[v14] = v20;\n                MEM[v14 + 32] = v12;\n                v1 = v123 = address(STORAGE[keccak256(MEM[0x0 len (64 + v14)])]);\n                assert(3 < v1);\n                require(msg.data[96 + v1] >> 224 > _userNonce[v123]);\n                assert(3 < v1);\n                v124 = msg.data[96 + v1];\n                v1 = v125 = 0x10000000000000000000000000000000000000000 == v124 & 0xf0000000000000000000000000000000000000000;\n                if (0x10000000000000000000000000000000000000000 != v124 & 0xf0000000000000000000000000000000000000000) {\n                    v1 = v126 = address(_tokenId2Address[(v124 & 0xffff000000000000) >> 48]);\n                    v1 = v127 = address(_tokenId2Address[(v124 & 0xffff00000000) >> 32]);\n                } else {\n                    v1 = v128 = address(_tokenId2Address[(v124 & 0xffff00000000) >> 32]);\n                    v1 = v129 = address(_tokenId2Address[(v124 & 0xffff000000000000) >> 48]);\n                }\n                v22 = v130 = 1667;\n                v23 = v131 = new uint256[](v1);\n                CALLDATACOPY(v131.data, v1, v1 << 5);\n                v1 = v132 = 0;\n                v24 = v133 = 3;\n                assert(v133 < v1);\n            }\n        } else if (182 == v0) {\n            require(!msg.value);\n            v134 = v135 = 415;\n            v134 = v136 = varg1 + 36;\n            v134 = v137 = varg1.length;\n            v134 = v138 = 0;\n            v134 = v139 = 0;\n            v134 = v140 = 0;\n            v141 = v142 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v141 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v141);\n            assert(3 < v137);\n            v134 = v143 = varg1[96];\n            v134 = v144 = address(_userId2Address[uint32(v143)]);\n            require(v143 >> 224 > _userNonce[v144]);\n            v134 = v145 = 0;\n            if ((v143 & 0xffff000000000000) >> 48) {\n                v134 = v146 = address(_tokenId2Address[(v143 & 0xffff000000000000) >> 48]);\n            } else {\n                v134 = v147 = address(_tokenId2Address[(v143 & 0xffff00000000) >> 32]);\n                v134 = v148 = 1;\n            }\n            assert(0 < v137);\n            assert(1 < v137);\n            assert(2 < v137);\n            if (v149) {\n                v150 = v151 = 0x10000000000000000000000000000000000000000;\n            } else {\n                v150 = v152 = 0;\n            }\n            v134 = v153 = keccak256(address(this), varg1[0], varg1[32], varg1[64], v143 & ~0xfffffffffffffffffffffffffffffffffffffffff | v150 | address(v154));\n            v155 = v156 = 3013;\n            if (0 == v143 & 0xf000000000000000000000000000000000000000) {\n                v157 = v158 = 27;\n                v159 = v160 = 4;\n                assert(v160 < v137);\n            } else {\n                v157 = v161 = 28;\n                v159 = 4;\n                assert(v159 < v137);\n            }\n            v162 = varg1[v159 << 5];\n            v163 = 5;\n            assert(v163 < v137);\n            while (1) {\n                v164 = msg.data[(v163 << 5) + v134];\n                MEM[MEM[64]] = 0;\n                MEM[32 + MEM[64]] = 0;\n                v165, v166 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v134), v157 & 0xff, v162, v164);\n                if (v165) {\n                    break;\n                }\n                require(v165);\n                v167 = msg.data[(v168 << 5) + v134];\n                require(v134 <= v167);\n                goto {'0xe780xa01B0x1ac', '0xe620xa01B0x1ac', '0x9810xa01B0x1ac', '0x9970xa01B0x1ac'};\n                require(_orderFills[v134] <= v167 - v134);\n                v169 = v170 = v167 - v134 - _orderFills[v134];\n                v171 = v172 = 2548;\n                assert(2 < v134);\n                v173 = msg.data[64 + v134];\n                assert(3 < v134);\n                v174 = msg.data[96 + v134];\n                v175 = 0x2e89(!address(v134), 1, v134, v134, v174, v173);\n                0x3003(v134, v134, v175, v169, v134, v176, v174);\n                v177 = _SafeAdd(v169, _orderFills[v134]);\n                _orderFills[v134] = v177;\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v174)]), v134, v169, v176, v175);\n                }\n                require(_orderFills[v134] <= v167 - v134);\n                v169 = v167 - v134 - _orderFills[v134];\n                v171 = v178 = 2548;\n                assert(2 < v134);\n                v173 = v179 = msg.data[64 + v134];\n                assert(3 < v134);\n                v174 = v180 = msg.data[96 + v134];\n                v134 = v181 = 0;\n                goto {'0xbc5B0x1ac', '0x8ce0xa01B0x1ac', '0xdda0xa01B0x1ac'};\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                v182 = v183 = 2370;\n                assert(v134 < v134);\n                v184 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v185 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v186 = msg.data[(2 + v134 << 5) + v134];\n                assert(3 + v134 < v134);\n                v134 = v187 = msg.data[(3 + v134 << 5) + v134];\n                v188 = 0x2de0(v134, v134, v134, v185, v184);\n                v189 = 0x2e3d(v188, v134, v185, v184);\n                v190 = 0x2e89(!address(v134), 0, v134, v189, v134, v186);\n                0x3003(v134, v134, v190, v188, v189, v134, v134);\n                v191 = _SafeAdd(v188, _orderFills[v134]);\n                _orderFills[v134] = v191;\n                require(v188 <= v134);\n                v134 = v134 - v188;\n                v134 = _SafeAdd(v189, v134);\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v134)]), v189, v188, v134, v190);\n                }\n                goto {'0x9420xa01B0x1ac', '0xe380xa01B0x1ac'};\n                v134 += 6;\n                if (v134 >= v134) {\n                    v176 = !v134;\n                    if (v176) {\n                        v192 = v193 = 2455;\n                        v168 = v194 = 1;\n                        assert(v194 < v134);\n                    } else {\n                        v192 = v195 = 2433;\n                        v168 = v196 = 0;\n                        assert(v196 < v134);\n                    }\n                } else {\n                    v197 = v198 = v134 > 0;\n                    if (v198) {\n                        v199 = v200 = 1953;\n                        assert(v134 < v134);\n                    }\n                }\n                v134 += 6;\n                goto 0xc400xa01B0x1ac;\n                require(v197);\n                assert(v134 + 3 < v134);\n                v201 = uint32(msg.data[(v134 + 3 << 5) + v134]);\n                v134 = v202 = address(_userId2Address[v201]);\n                assert(v134 + 3 < v134);\n                require(msg.data[(v134 + 3 << 5) + v134] >> 224 > _userNonce[v202]);\n                v203 = new uint256[](v134);\n                CALLDATACOPY(v203.data, v134, v134 << 5);\n                assert(3 + v134 < v134);\n                assert(v134 < v203.length);\n                assert(1 + v134 < v203.length);\n                assert(2 + v134 < v203.length);\n                v204 = address(v134) | msg.data[(3 + v134 << 5) + v134] & ~0xffffffffffffffffffffffffffffffffffffffff;\n                v205 = (msg.data[(3 + v134 << 5) + v134] & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n                v134 = v206 = keccak256(address(this), v203[v134 << 5], v203[1 + v134], v203[2 + v134], v204, address(v134), v205);\n                v155 = 2254;\n                assert(v134 + 3 < v134);\n                if (!(msg.data[(v134 + 3 << 5) + v134] & 0xf000000000000000000000000000000000000000)) {\n                    v207 = 27;\n                } else {\n                    v207 = v208 = 28;\n                }\n                v157 = v209 = 0xff & v207;\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                v182 = v210 = 3640;\n                assert(v134 < v134);\n                v184 = v211 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v185 = v212 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v186 = v213 = msg.data[(2 + v134 << 5) + v134];\n                v134 = v214 = 0;\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                if (v134) {\n                    assert(1 < v134);\n                    v215 = msg.data[32 + v134];\n                } else {\n                    assert(0 < v134);\n                    v215 = v216 = msg.data[0 + v134];\n                }\n                require(_orderFills[v134] <= v215);\n                v134 = v217 = v215 - _orderFills[v134];\n                require(v217);\n                v134 = !v134;\n                v134 = v218 = 0;\n                v134 = v219 = 6;\n                if (v134 >= v134) {\n                    v176 = v220 = !v134;\n                    if (v220) {\n                        v192 = v221 = 3704;\n                        v168 = v222 = 1;\n                        assert(v222 < v134);\n                    } else {\n                        v192 = v223 = 3682;\n                        v168 = v224 = 0;\n                        assert(v224 < v134);\n                    }\n                } else {\n                    v225 = v226 = v134 > 0;\n                    if (v226) {\n                        v199 = v227 = 3170;\n                        assert(v134 < v134);\n                    }\n                }\n                v228 = msg.data[(v134 << 5) + v134];\n                v229 = 0;\n                assert(v229 < v134);\n                while (1) {\n                    v230 = msg.data[(v229 << 5) + v134];\n                    if (v230) {\n                        v134 = v231 = v228 * v230;\n                        assert(v230);\n                        require(v231 / v230 == v228);\n                    } else {\n                        v134 = v232 = 0;\n                    }\n                    goto {'0x7c90xa01B0x1ac', '0xc620xa01B0x1ac', '0xc740xa01B0x1ac', '0x7a10xa01B0x1ac'};\n                    v199 = v233 = 1993;\n                    v234 = v134 + 1;\n                    assert(v234 < v134);\n                    v228 = v235 = msg.data[(v234 << 5) + v134];\n                    v229 = v236 = 1;\n                    assert(v236 < v134);\n                    v199 = v237 = 3188;\n                    v234 = v238 = v134 + 1;\n                    assert(v238 < v134);\n                }\n                v197 = v134 <= v134;\n                v225 = v134 <= v134;\n                require(v225);\n                assert(v134 + 3 < v134);\n                v134 = v239 = msg.data[(v134 + 3 << 5) + v134];\n                v134 = v240 = address(_userId2Address[uint32(v239)]);\n                require(v239 >> 224 > _userNonce[uint32(v239)]);\n                assert(v134 < v134);\n                v241 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v242 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v243 = msg.data[(2 + v134 << 5) + v134];\n                if (v134) {\n                    v244 = 0x10000000000000000000000000000000000000000;\n                } else {\n                    v244 = v245 = 0;\n                }\n                v246 = v239 & ~0xfffffffffffffffffffffffffffffffffffffffff | v244 | address(v134);\n                v134 = v247 = keccak256(address(this), v241, v242, v243, v246);\n                v155 = v248 = 3546;\n                if (0 == v239 & 0xf000000000000000000000000000000000000000) {\n                    v157 = 27;\n                    v249 = v250 = v134 + 4;\n                    assert(v250 < v134);\n                } else {\n                    v157 = v251 = 28;\n                }\n                v249 = v134 + 4;\n                assert(v249 < v134);\n                v162 = v252 = msg.data[(v249 << 5) + v134];\n                v163 = v253 = v134 + 5;\n                assert(v253 < v134);\n            }\n        } else if (199 == v0) {\n            require(!msg.value);\n            v254 = v255 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v254 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v254);\n            assert(0 < varg1.length);\n            assert(1 < varg1.length);\n            assert(2 < varg1.length);\n            v256 = v257 = address(_tokenId2Address[(varg1[64] & 0xffff00000000) >> 32]);\n            v258 = keccak256(address(this), varg1[0], varg1[32], v257 | varg1[64] & ~0xffffffffffffffffffffffffffffffffffffffff);\n            require(!(0xff & _userId2Address[v258]));\n            if (!(varg1[64] & 0xf000000000000000000000000000000000000000)) {\n                v259 = v260 = 27;\n            } else {\n                v259 = v261 = 28;\n            }\n            assert(3 < varg1.length);\n            assert(4 < varg1.length);\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            v262, v263 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v258), v259 & 0xff, varg1[96], varg1[128]);\n            require(v262);\n            require(address(MEM[MEM[64] - 32]) == address(_userId2Address[uint32(varg1[64])]));\n            v256 = v264 = 0;\n            if (varg1[64] & 0xf0000000000000000000000000000000000000000 == 0x10000000000000000000000000000000000000000) {\n                v256 = _joyToken;\n            }\n            if (address(v256) != address(v257)) {\n                require(varg1[0] <= _getBalance[address(_userId2Address[uint32(varg1[64])])]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(_userId2Address[uint32(varg1[64])])] - varg1[0];\n                require(varg1[32] <= _getBalance[address(v256)]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(v256)] - varg1[32];\n            } else {\n                v265 = _SafeAdd(varg1[32], varg1[0]);\n                require(v265 <= _getBalance[address(_userId2Address[uint32(varg1[64])])]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(_userId2Address[uint32(varg1[64])])] - v265;\n            }\n            v266 = _SafeAdd(varg1[32], _getBalance[_joysoWallet]);\n            _getBalance[_joysoWallet] = v266;\n            _usedHash[_joysoWallet] = 0x1 | ~0xff & _usedHash[_joysoWallet];\n            if (address(v257)) {\n                MEM[32 + MEM[64]] = 0;\n                require((address(v257)).code.size);\n                v267, v268 = address(v257).transfer(address(_userId2Address[uint32(varg1[64])]), varg1[0]).gas(msg.gas - 710);\n                require(v267);\n                require(v268);\n                goto 0x33ad;\n            } else {\n                v269 = address(_userId2Address[uint32(varg1[64])]).call().value(varg1[0]).gas(2300 * !varg1[0]);\n                require(v269);\n            }\n            exit;\n        } else if (44723 == v0) {\n            require(!msg.value);\n            v270 = v271 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v270 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v270);\n            assert(2 < varg1.length);\n            v272 = address(_tokenId2Address[(varg1[0x40] & 0xffff00000000) >> 32]);\n            assert(0 < varg1.length);\n            v273 = v274 = 1;\n            while (v273 < varg1.length) {\n                if (v273 < varg1.length) {\n                    break;\n                }\n                assert(v273 < varg1.length);\n                if (1 + v273 < varg1.length) {\n                    break;\n                }\n                assert(1 + v273 < varg1.length);\n                v275 = address(_userId2Address[uint32(varg1[1 + v273 << 5])]);\n                v276 = varg1[1 + v273 << 5] & ~0xffffffffffffffffffffffffffffffffffffffff | address(v272);\n                if (0 == varg1[1 + v273 << 5] & 0xf000000000000000000000000000000000000000) {\n                    v277 = v278 = 27;\n                } else {\n                    v277 = v279 = 28;\n                }\n                assert(v273 + 2 < varg1.length);\n                assert(v273 + 3 < varg1.length);\n                MEM[MEM[64]] = 0;\n                MEM[32 + MEM[64]] = 0;\n                v280, v281 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', keccak256(address(this), varg1[v273], v276, address(varg1[0x0]))), v277 & 0xff, varg1[v273 + 2 << 5], varg1[v273 + 3 << 5]);\n                require(v280);\n                require(address(MEM[MEM[64] - 32]) == address(v275));\n                if (varg1[v273] > 0) {\n                    if (varg1[1 + v273 << 5] & 0xf0000000000000000000000000000000000000000 != 0x10000000000000000000000000000000000000000) {\n                        if (varg1[1 + v273 << 5] & 0xf0000000000000000000000000000000000000000 != 0x20000000000000000000000000000000000000000) {\n                            require(varg1[v273] <= _depositEther[address(v275)]);\n                            _depositEther[address(v275)] = _depositEther[address(v275)] - varg1[v273];\n                            v282 = _SafeAdd(varg1[v273], _depositEther[_joysoWallet]);\n                            _depositEther[_joysoWallet] = v282;\n                        } else {\n                            require(varg1[v273] <= _getBalance[address(v275)]);\n                            _getBalance[address(v275)] = _getBalance[address(v275)] - varg1[v273];\n                            v283 = _SafeAdd(varg1[v273], _getBalance[_joysoWallet]);\n                            _getBalance[_joysoWallet] = v283;\n                        }\n                    } else {\n                        require(varg1[v273] <= _getBalance[address(v275)]);\n                        _getBalance[address(v275)] = _getBalance[address(v275)] - varg1[v273];\n                        v284 = _SafeAdd(varg1[v273], _getBalance[_joysoWallet]);\n                        _getBalance[_joysoWallet] = v284;\n                    }\n                }\n                _getBalance[address(v275)] = 0;\n                if (address(v272)) {\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x95ea7b300000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(varg1[0x0]);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    require((address(v272)).code.size);\n                    v285 = address(v272).call(v286, v276).gas(msg.gas - 710);\n                    require(v285);\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x3b9ca2d000000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(v275);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    MEM[MEM[64] + 68] = address(v272);\n                    require((address(varg1[0x0])).code.size);\n                    v287 = address(varg1[0x0]).call(v286, v276, varg1[v273 + 2 << 5]).gas(msg.gas - 710);\n                    require(v287);\n                } else {\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x3b9ca2d000000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(v275);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    MEM[MEM[64] + 68] = address(v272);\n                    require((address(varg1[0x0])).code.size);\n                    v288 = address(varg1[0x0]).call(v286, v276, varg1[v273 + 2 << 5]).value(_getBalance[address(v275)]).gas(msg.gas - 9710);\n                    require(v288);\n                }\n                v273 = v273 + 4;\n            }\n            exit;\n        } else if (0x2ca5994 == v0) {\n            registerToken(address,uint256);\n        } else if (0x7973ccf == v0) {\n            userCount();\n        } else if (0x7c4d580 == v0) {\n            transferForAdmin(address,address,uint256);\n        } else if (0xf7c9085 == v0) {\n            addToAdmin(address,bool);\n        } else if (0x135a2474 == v0) {\n            joysoWallet();\n        } else if (0x24d7806c == v0) {\n            isAdmin(address);\n        } else if (0x2e04b8e7 == v0) {\n            userNonce(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3fd8b02f == v0) {\n            lockPeriod();\n        } else if (0x560ebbd1 == v0) {\n            usedHash(bytes32);\n        } else if (0x5617a6e8 == v0) {\n            userLock(address);\n        } else if (0x69b59e75 == v0) {\n            collectFee(address);\n        } else if (0x774bafdf == v0) {\n            unlockMe();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x934e1666 == v0) {\n            userId2Address(uint256);\n        } else if (0x98a36ebf == v0) {\n            setTradeEventEnabled(bool);\n        } else if (0x98ea5fca == v0) {\n            depositEther();\n        } else if (0xa64968ac == v0) {\n            joyToken();\n        } else if (0xc25cf1d0 == v0) {\n            changeLockPeriod(uint256);\n        } else if (0xc8799b37 == v0) {\n            tokenAddress2Id(address);\n        } else if (0xd4fac45d == v0) {\n            getBalance(address,address);\n        } else if (0xd5893bb2 == v0) {\n            tradeEventEnabled();\n        } else if (0xd86bc1b0 == v0) {\n            cancelByAdmin(uint256[]);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf912ed00 == v0) {\n            lockMe();\n        } else if (0xfa769257 == v0) {\n            tokenId2Address(uint256);\n        } else if (0xffc69ab1 == v0) {\n            userAddress2Id(address);\n        }\n        exit;\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.14 12:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getBalance; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _userLock; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userNonce; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _usedHash; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _isAdmin; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _tokenId2Address; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _userId2Address; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _userAddress2Id; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokenAddress2Id; // STORAGE[0xa]\nuint256 _lockPeriod; // STORAGE[0xd]\nuint256 _userCount; // STORAGE[0xe]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _tradeEventEnabled; // STORAGE[0xf] bytes 0 to 0\nuint256 _joysoWallet; // STORAGE[0xb] bytes 0 to 19\nuint256 _joyToken; // STORAGE[0xc] bytes 0 to 19\nmapping (uint256 => [uint256]) _depositEther; // STORAGE[0xa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb49]\n\n// Events\nDeposit(address, address, uint256, uint256);\nWithdraw(address, address, uint256, uint256);\nLock(address, uint256);\nOwnershipTransferred(address, address);\nTradeSuccess(address, uint256, uint256, bool, uint256);\nNewUser(address, uint256);\n\nfunction () public payable { \n    revert();\n}\n\nfunction registerToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    require(varg1 > 1);\n    require(!_tokenAddress2Id[varg0]);\n    require(!address(_tokenId2Address[varg1]));\n    _tokenAddress2Id[varg0] = varg1;\n    _tokenAddress2Id[varg0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _tokenAddress2Id[varg0];\n}\n\nfunction userCount() public nonPayable { \n    return _userCount;\n}\n\nfunction transferForAdmin(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    require(_tokenAddress2Id[varg0]);\n    require(_userAddress2Id[msg.sender]);\n    0x2d2c(varg1);\n    require(varg2 <= _getBalance[msg.sender]);\n    _getBalance[msg.sender] = _getBalance[msg.sender] - varg2;\n    v3 = _SafeAdd(varg2, _getBalance[varg1]);\n    _getBalance[varg1] = v3;\n}\n\nfunction addToAdmin(address varg0, bool varg1) public nonPayable { \n    require(_owner == msg.sender);\n    _isAdmin[varg0] = varg1 | ~0xff & _isAdmin[varg0];\n}\n\nfunction joysoWallet() public nonPayable { \n    return _joysoWallet;\n}\n\nfunction 0x2a2e(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0);\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction isAdmin(address varg0) public nonPayable { \n    return 0xff & _isAdmin[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x2d2c(uint256 varg0) private { \n    v0 = address(varg0);\n    if (!_userAddress2Id[v0]) {\n        _userCount += 1;\n        v1 = address(varg0);\n        _userAddress2Id[v1] = 1 + _userCount;\n        _userAddress2Id[v1] = v1 | ~0xffffffffffffffffffffffffffffffffffffffff & _userAddress2Id[v1];\n        v2 = address(varg0);\n        emit NewUser(v2, _userCount);\n    }\n    return ;\n}\n\nfunction 0x2de0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    if (!varg1) {\n    }\n    v0 = _orderFills[varg0];\n    require(v0 <= varg4);\n    varg2 = v1 = varg4 - v0;\n    require(v1 > 0);\n    if (v1 < varg2) {\n    }\n    return varg2;\n}\n\nfunction 0x2e3d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg1) {\n        v0 = 0x2a2e(varg3, varg0);\n        assert(varg2);\n        v1 = v2 = v0 / varg2;\n    } else {\n        v3 = 0x2a2e(varg2, varg0);\n        assert(varg3);\n        v1 = v4 = v3 / varg3;\n    }\n    return v1;\n}\n\nfunction 0x2e89(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { \n    if (_orderFills[varg2]) {\n        varg5 = v0 = 0;\n    }\n    if (varg1) {\n        v1 = v2 = (varg4 & 0xffff0000000000000000000000000000000000000000000000000000) >> 208;\n    } else {\n        v1 = v3 = (varg4 & 0xffff000000000000000000000000000000000000000000000000) >> 192;\n    }\n    if (varg3) {\n        v4 = v1 * varg3;\n        assert(varg3);\n        require(v4 / varg3 == v1);\n    } else {\n        v4 = v5 = 0;\n    }\n    assert(10000);\n    v6 = v7 = v4 / 10000;\n    if (varg0) {\n        v8 = v9 = (varg4 & 0xfffffff00000000000000000000000000000000000000000) >> 164;\n    } else {\n        v8 = v10 = (varg4 & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n    }\n    if (v8) {\n        if (varg0) {\n            assert(v8);\n            v6 = v11 = v7 / 0x186a0 / v8;\n        } else {\n            assert(v8);\n            v6 = v12 = 0xe8d4a51000 * v7 / v8;\n        }\n    }\n    v13 = _SafeAdd(v6, varg5);\n    return v13;\n}\n\nfunction userNonce(address varg0) public nonPayable { \n    return _userNonce[varg0];\n}\n\nfunction 0x3003(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = uint32(varg6);\n    varg2 = v1 = 0;\n    if (!address(varg0)) {\n        v2 = v3 = (varg6 & 0xfffffff00000000000000000000000000000000000000000) >> 164;\n    } else {\n        v2 = v4 = (varg6 & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n    }\n    if (v2) {\n        varg2 = v5 = 0;\n    }\n    if (!varg5) {\n        v6 = address(varg0);\n        v7 = _SafeAdd(varg4, _getBalance[address(_userId2Address[v0])]);\n        require(varg2 <= v7);\n        v8 = address(varg0);\n        _getBalance[address(_userId2Address[v0])] = v7 - varg2;\n        v9 = address(varg1);\n        require(varg3 <= _getBalance[v9]);\n        v10 = address(varg1);\n        _getBalance[address(_userId2Address[v0])] = _getBalance[v9] - varg3;\n    } else {\n        v11 = address(varg0);\n        require(varg4 <= _getBalance[address(_userId2Address[v0])]);\n        v12 = _getBalance[address(_userId2Address[v0])] - varg4;\n        require(varg2 <= v12);\n        v13 = address(varg0);\n        _getBalance[address(_userId2Address[v0])] = v12 - varg2;\n        v14 = address(varg1);\n        v15 = _SafeAdd(varg3, _getBalance[v14]);\n        v16 = address(varg1);\n        _getBalance[address(_userId2Address[v0])] = v15;\n    }\n    if (!varg2) {\n        v17 = address(varg0);\n        v18 = _SafeAdd(varg2, _getBalance[_joysoWallet]);\n        v19 = address(varg0);\n        _getBalance[_joysoWallet] = v18;\n        return ;\n    } else {\n        require(varg2 <= _getBalance[address(_userId2Address[v0])]);\n        _getBalance[address(_userId2Address[v0])] = _getBalance[address(_userId2Address[v0])] - varg2;\n        v20 = _SafeAdd(varg2, _getBalance[_joysoWallet]);\n        _getBalance[_joysoWallet] = v20;\n        return ;\n    }\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    require(_tokenAddress2Id[varg0]);\n    0x2d2c(msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    v2 = _SafeAdd(varg1, _getBalance[msg.sender]);\n    _getBalance[msg.sender] = v2;\n    emit Deposit(varg0, msg.sender, varg1, v2);\n}\n\nfunction lockPeriod() public nonPayable { \n    return _lockPeriod;\n}\n\nfunction usedHash(bytes32 varg0) public nonPayable { \n    return 0xff & _usedHash[varg0];\n}\n\nfunction userLock(address varg0) public nonPayable { \n    return _userLock[varg0];\n}\n\nfunction collectFee(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(_getBalance[_joysoWallet] > 0);\n    _getBalance[_joysoWallet] = 0;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, _getBalance[_joysoWallet]).gas(msg.gas - 710);\n        require(v0);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(_getBalance[_joysoWallet]).gas(2300 * !_getBalance[_joysoWallet]);\n        require(v2);\n    }\n    emit Withdraw(varg0, _joysoWallet, _getBalance[_joysoWallet], 0);\n}\n\nfunction unlockMe() public nonPayable { \n    require(_userAddress2Id[msg.sender]);\n    _userLock[msg.sender] = 0;\n    emit Lock(msg.sender, 0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction userId2Address(uint256 varg0) public nonPayable { \n    return address(_userId2Address[varg0]);\n}\n\nfunction setTradeEventEnabled(bool varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _tradeEventEnabled = varg0;\n}\n\nfunction depositEther() public payable { \n    require(msg.value > 0);\n    0x2d2c(msg.sender);\n    v0 = _SafeAdd(msg.value, _depositEther[msg.sender]);\n    _depositEther[msg.sender] = v0;\n    emit Deposit(0, msg.sender, msg.value, v0);\n}\n\nfunction joyToken() public nonPayable { \n    return _joyToken;\n}\n\nfunction changeLockPeriod(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = v1 = varg0 <= 30;\n    if (v1) {\n        v0 = v2 = varg0 >= 1;\n    }\n    require(v0);\n    _lockPeriod = 0x15180 * varg0;\n}\n\nfunction tokenAddress2Id(address varg0) public nonPayable { \n    return _tokenAddress2Id[varg0];\n}\n\nfunction getBalance(address varg0, address varg1) public nonPayable { \n    return _getBalance[varg1];\n}\n\nfunction tradeEventEnabled() public nonPayable { \n    return _tradeEventEnabled;\n}\n\nfunction cancelByAdmin(uint256[] varg0) public nonPayable { \n    v0 = v1 = _owner == msg.sender;\n    if (_owner != msg.sender) {\n        v0 = v2 = 0xff & _isAdmin[msg.sender];\n    }\n    require(v0);\n    assert(1 < varg0.length);\n    require(varg0[32] >> 224 > _userNonce[address(_userId2Address[uint32(varg0[32])])]);\n    assert(0 < varg0.length);\n    if (!(varg0[32] & 0xf000000000000000000000000000000000000000)) {\n        v3 = v4 = 27;\n    } else {\n        v3 = v5 = 28;\n    }\n    assert(2 < varg0.length);\n    assert(3 < varg0.length);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v6, v7 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', keccak256(address(this), varg0[0], varg0[32] & ~0xffffffffffffffffffffffffffffffffffffffff)), 0xff & v3 & 0xff, varg0[64], varg0[96]);\n    require(v6);\n    require(address(MEM[MEM[64] - 32]) == address(_userId2Address[uint32(varg0[32])]));\n    v8 = v9 = 0;\n    if (0x10000000000000000000000000000000000000000 == varg0[32] & 0xf0000000000000000000000000000000000000000) {\n        v8 = v10 = _joyToken;\n    }\n    require(_getBalance[address(_userId2Address[uint32(varg0[32])])] >= varg0[0]);\n    require(varg0[0] <= _getBalance[address(_userId2Address[uint32(varg0[32])])]);\n    _getBalance[address(_userId2Address[uint32(varg0[32])])] = _getBalance[address(_userId2Address[uint32(varg0[32])])] - varg0[0];\n    v11 = _SafeAdd(varg0[0], _getBalance[_joysoWallet]);\n    _getBalance[_joysoWallet] = v11;\n    _userNonce[address(_userId2Address[uint32(varg0[32])])] = varg0[32] >> 224;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    v0 = v1 = block.timestamp > _userLock[msg.sender];\n    if (v1) {\n        v0 = v2 = _userLock[msg.sender];\n    }\n    require(v0);\n    require(varg1 <= _getBalance[msg.sender]);\n    _getBalance[msg.sender] = _getBalance[msg.sender] - varg1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v3, v4 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v3);\n        require(v4);\n    } else {\n        v5 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v5);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _getBalance[msg.sender]);\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction lockMe() public nonPayable { \n    require(_userAddress2Id[msg.sender]);\n    _userLock[msg.sender] = block.timestamp + _lockPeriod;\n    emit Lock(msg.sender, block.timestamp + _lockPeriod);\n}\n\nfunction tokenId2Address(uint256 varg0) public nonPayable { \n    return address(_tokenId2Address[varg0]);\n}\n\nfunction userAddress2Id(address varg0) public nonPayable { \n    return _userAddress2Id[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 51) {\n            require(!msg.value);\n            v1 = v2 = 415;\n            v1 = v3 = varg1 + 36;\n            v1 = v4 = varg1.length;\n            v1 = v5 = 0;\n            v1 = v6 = 0;\n            v1 = v7 = 0;\n            v1 = v8 = 0;\n            v1 = v9 = 0;\n            v10 = v11 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v10 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v10);\n            v12 = v13 = 8;\n            v14 = v15 = 0;\n            v16 = v17 = 1462;\n            v18 = v19 = 3;\n            assert(v19 < v4);\n            while (1) {\n                v20 = uint32(msg.data[(v18 << 5) + v1]);\n                goto {'0x5b6B0x18c', '0x7ed0x531B0x18c'};\n                MEM[v14] = v20;\n                MEM[v14 + 32] = v12;\n                v1 = v21 = address(STORAGE[keccak256(MEM[0x0 len (64 + v14)])]);\n                assert(v1 + 3 < v1);\n                require(msg.data[(v1 + 3 << 5) + v1] >> 224 > _userNonce[v21]);\n                v22 = 2189;\n                v23 = new uint256[](v1);\n                CALLDATACOPY(v23.data, v1, v1 << 5);\n                v24 = v25 = 3 + v1;\n                assert(v25 < v1);\n                v26 = msg.data[(v24 << 5) + v1];\n                if (v1 < MEM[v23]) {\n                    break;\n                }\n                assert(v1 < MEM[v23]);\n                if (1 + v1 < MEM[v23]) {\n                    break;\n                }\n                assert(1 + v1 < MEM[v23]);\n                if (2 + v1 < MEM[v23]) {\n                    break;\n                }\n                assert(2 + v1 < MEM[v23]);\n                v27 = address(v1) | v26 & ~0xffffffffffffffffffffffffffffffffffffffff;\n                v1 = v28 = keccak256(address(this), MEM[(v1 << 5) + (32 + v23)], MEM[(1 + v1 << 5) + (32 + v23)], MEM[(2 + v1 << 5) + (32 + v23)], v27, address(v1), (v26 & 0xfffffffffffffffffffffff0000000000000000) >> 64);\n                goto {'0x88d0x531B0x18c', '0x683B0x18c'};\n                v29 = 2254;\n                v30 = 2214;\n                v31 = v32 = v1 + 3;\n                assert(v32 < v1);\n                if (!(msg.data[(v31 << 5) + v1] & 0xf000000000000000000000000000000000000000)) {\n                    v33 = 27;\n                } else {\n                    v33 = v34 = 28;\n                }\n                v35 = v36 = 0xff & v33;\n                goto {'0x8a60x531B0x18c', '0x6a60x531B0x18c'};\n                assert(4 < v1);\n                v37 = msg.data[128 + v1];\n                v38 = 5;\n                assert(v38 < v1);\n                v39 = msg.data[(v38 << 5) + v1];\n                MEM[MEM[64]] = 0;\n                MEM[64] += 32;\n                MEM[32 + MEM[64]] = 0;\n                v40 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v1), v35 & 0xff, v37, v39);\n                require(v40);\n                goto {'0x8ce0x531B0x18c', '0x6d9B0x18c', '0xdda0x531B0x18c'};\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                v41 = v42 = 2370;\n                assert(v1 < v1);\n                v43 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v44 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v45 = msg.data[(2 + v1 << 5) + v1];\n                assert(3 + v1 < v1);\n                v1 = v46 = msg.data[(3 + v1 << 5) + v1];\n                v47 = 0x2de0(v1, v1, v1, v44, v43);\n                v48 = 0x2e3d(v47, v1, v44, v43);\n                v49 = 0x2e89(!address(v1), 0, v1, v48, v1, v45);\n                0x3003(v1, v1, v49, v47, v48, v1, v1);\n                v50 = _SafeAdd(v47, _orderFills[v1]);\n                _orderFills[v1] = v50;\n                require(v47 <= v1);\n                v1 = v1 - v47;\n                v1 = _SafeAdd(v48, v1);\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v1)]), v48, v47, v1, v49);\n                }\n                goto {'0xe380x531B0x18c', '0x9420x531B0x18c'};\n                v1 += 6;\n                goto 0x7540x531B0x18c;\n                v1 += 6;\n                if (v1 >= v1) {\n                    v51 = v52 = !v1;\n                    if (v52) {\n                        v53 = v54 = 3704;\n                        v55 = v56 = 1;\n                        assert(v56 < v1);\n                    } else {\n                        v53 = v57 = 3682;\n                        v55 = v58 = 0;\n                        assert(v58 < v1);\n                    }\n                } else {\n                    v59 = v60 = v1 > 0;\n                    if (v60) {\n                        v61 = v62 = 3170;\n                        assert(v1 < v1);\n                    }\n                }\n                require(v59);\n                assert(v1 + 3 < v1);\n                v1 = v63 = msg.data[(v1 + 3 << 5) + v1];\n                v1 = v64 = address(_userId2Address[uint32(v63)]);\n                require(v63 >> 224 > _userNonce[uint32(v63)]);\n                assert(v1 < v1);\n                v65 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v66 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v67 = msg.data[(2 + v1 << 5) + v1];\n                if (v1) {\n                    v68 = 0x10000000000000000000000000000000000000000;\n                } else {\n                    v68 = v69 = 0;\n                }\n                v70 = v63 & ~0xfffffffffffffffffffffffffffffffffffffffff | v68 | address(v1);\n                v1 = v71 = keccak256(address(this), v65, v66, v67, v70);\n                v29 = v72 = 3546;\n                if (0 == v63 & 0xf000000000000000000000000000000000000000) {\n                    v35 = 27;\n                    v73 = v74 = v1 + 4;\n                    assert(v74 < v1);\n                } else {\n                    v35 = v75 = 28;\n                }\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                v41 = v76 = 3640;\n                assert(v1 < v1);\n                v43 = v77 = msg.data[(v1 << 5) + v1];\n                assert(1 + v1 < v1);\n                v44 = v78 = msg.data[(1 + v1 << 5) + v1];\n                assert(2 + v1 < v1);\n                v45 = v79 = msg.data[(2 + v1 << 5) + v1];\n                v1 = v80 = 0;\n                require(address(MEM[MEM[64] - 32]) == address(v1));\n                if (v1) {\n                    assert(1 < v1);\n                    v81 = msg.data[32 + v1];\n                } else {\n                    assert(0 < v1);\n                    v81 = v82 = msg.data[0 + v1];\n                }\n                require(_orderFills[v1] <= v81);\n                v1 = v83 = v81 - _orderFills[v1];\n                require(v83);\n                v1 = !v1;\n                v1 = v84 = 0;\n                v1 = v85 = 6;\n                if (v1 >= v1) {\n                    v51 = !v1;\n                    if (v51) {\n                        v53 = v86 = 2455;\n                        v55 = v87 = 1;\n                        assert(v87 < v1);\n                    } else {\n                        v53 = v88 = 2433;\n                        v55 = v89 = 0;\n                        assert(v89 < v1);\n                    }\n                } else {\n                    v90 = v91 = v1 > 0;\n                    if (v91) {\n                        v61 = v92 = 1953;\n                        assert(v1 < v1);\n                    }\n                }\n                v93 = msg.data[(v1 << 5) + v1];\n                v94 = 0;\n                assert(v94 < v1);\n                while (1) {\n                    v95 = msg.data[(v94 << 5) + v1];\n                    if (v95) {\n                        v1 = v96 = v93 * v95;\n                        assert(v95);\n                        require(v96 / v95 == v93);\n                    } else {\n                        v1 = v97 = 0;\n                    }\n                    goto {'0x7c90x531B0x18c', '0xc620x531B0x18c', '0xc740x531B0x18c', '0x7a10x531B0x18c'};\n                    v61 = v98 = 1993;\n                    v99 = v1 + 1;\n                    assert(v99 < v1);\n                    v93 = v100 = msg.data[(v99 << 5) + v1];\n                    v94 = v101 = 1;\n                    assert(v101 < v1);\n                    v61 = v102 = 3188;\n                    v99 = v103 = v1 + 1;\n                    assert(v103 < v1);\n                }\n                v90 = v1 <= v1;\n                v59 = v1 <= v1;\n                require(v90);\n                v12 = 8;\n                v14 = 0;\n                v16 = 2029;\n                v18 = v104 = v1 + 3;\n                assert(v104 < v1);\n                v105 = msg.data[(v55 << 5) + v1];\n                require(v1 <= v105);\n                goto {'0xe780x531B0x18c', '0x9970x531B0x18c', '0xe620x531B0x18c', '0x9810x531B0x18c'};\n                require(_orderFills[v1] <= v105 - v1);\n                v106 = v107 = v105 - v1 - _orderFills[v1];\n                v108 = v109 = 2548;\n                assert(2 < v1);\n                v110 = msg.data[64 + v1];\n                assert(3 < v1);\n                v111 = msg.data[96 + v1];\n                v112 = 0x2e89(!address(v1), 1, v1, v1, v111, v110);\n                0x3003(v1, v1, v112, v106, v1, v51, v111);\n                v113 = _SafeAdd(v106, _orderFills[v1]);\n                _orderFills[v1] = v113;\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v111)]), v1, v106, v51, v112);\n                }\n                goto 0x19f;\n                require(_orderFills[v1] <= v105 - v1);\n                v106 = v105 - v1 - _orderFills[v1];\n                v108 = v114 = 2548;\n                assert(2 < v1);\n                v110 = v115 = msg.data[64 + v1];\n                assert(3 < v1);\n                v111 = v116 = msg.data[96 + v1];\n                v1 = v117 = 0;\n                v73 = v1 + 4;\n                assert(v73 < v1);\n                v37 = v118 = msg.data[(v73 << 5) + v1];\n                v38 = v119 = v1 + 5;\n                assert(v119 < v1);\n                v29 = v120 = 1753;\n                v30 = v121 = 1702;\n                v31 = v122 = 3;\n                assert(v122 < v1);\n                MEM[v14] = v20;\n                MEM[v14 + 32] = v12;\n                v1 = v123 = address(STORAGE[keccak256(MEM[0x0 len (64 + v14)])]);\n                assert(3 < v1);\n                require(msg.data[96 + v1] >> 224 > _userNonce[v123]);\n                assert(3 < v1);\n                v124 = msg.data[96 + v1];\n                v1 = v125 = 0x10000000000000000000000000000000000000000 == v124 & 0xf0000000000000000000000000000000000000000;\n                if (0x10000000000000000000000000000000000000000 != v124 & 0xf0000000000000000000000000000000000000000) {\n                    v1 = v126 = address(_tokenId2Address[(v124 & 0xffff000000000000) >> 48]);\n                    v1 = v127 = address(_tokenId2Address[(v124 & 0xffff00000000) >> 32]);\n                } else {\n                    v1 = v128 = address(_tokenId2Address[(v124 & 0xffff00000000) >> 32]);\n                    v1 = v129 = address(_tokenId2Address[(v124 & 0xffff000000000000) >> 48]);\n                }\n                v22 = v130 = 1667;\n                v23 = v131 = new uint256[](v1);\n                CALLDATACOPY(v131.data, v1, v1 << 5);\n                v1 = v132 = 0;\n                v24 = v133 = 3;\n                assert(v133 < v1);\n            }\n        } else if (182 == v0) {\n            require(!msg.value);\n            v134 = v135 = 415;\n            v134 = v136 = varg1 + 36;\n            v134 = v137 = varg1.length;\n            v134 = v138 = 0;\n            v134 = v139 = 0;\n            v134 = v140 = 0;\n            v141 = v142 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v141 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v141);\n            assert(3 < v137);\n            v134 = v143 = varg1[96];\n            v134 = v144 = address(_userId2Address[uint32(v143)]);\n            require(v143 >> 224 > _userNonce[v144]);\n            v134 = v145 = 0;\n            if ((v143 & 0xffff000000000000) >> 48) {\n                v134 = v146 = address(_tokenId2Address[(v143 & 0xffff000000000000) >> 48]);\n            } else {\n                v134 = v147 = address(_tokenId2Address[(v143 & 0xffff00000000) >> 32]);\n                v134 = v148 = 1;\n            }\n            assert(0 < v137);\n            assert(1 < v137);\n            assert(2 < v137);\n            if (v149) {\n                v150 = v151 = 0x10000000000000000000000000000000000000000;\n            } else {\n                v150 = v152 = 0;\n            }\n            v134 = v153 = keccak256(address(this), varg1[0], varg1[32], varg1[64], v143 & ~0xfffffffffffffffffffffffffffffffffffffffff | v150 | address(v154));\n            v155 = v156 = 3013;\n            if (0 == v143 & 0xf000000000000000000000000000000000000000) {\n                v157 = v158 = 27;\n                v159 = v160 = 4;\n                assert(v160 < v137);\n            } else {\n                v157 = v161 = 28;\n                v159 = 4;\n                assert(v159 < v137);\n            }\n            v162 = varg1[v159 << 5];\n            v163 = 5;\n            assert(v163 < v137);\n            while (1) {\n                v164 = msg.data[(v163 << 5) + v134];\n                MEM[MEM[64]] = 0;\n                MEM[32 + MEM[64]] = 0;\n                v165, v166 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v134), v157 & 0xff, v162, v164);\n                if (v165) {\n                    break;\n                }\n                require(v165);\n                v167 = msg.data[(v168 << 5) + v134];\n                require(v134 <= v167);\n                goto {'0xe780xa01B0x1ac', '0xe620xa01B0x1ac', '0x9810xa01B0x1ac', '0x9970xa01B0x1ac'};\n                require(_orderFills[v134] <= v167 - v134);\n                v169 = v170 = v167 - v134 - _orderFills[v134];\n                v171 = v172 = 2548;\n                assert(2 < v134);\n                v173 = msg.data[64 + v134];\n                assert(3 < v134);\n                v174 = msg.data[96 + v134];\n                v175 = 0x2e89(!address(v134), 1, v134, v134, v174, v173);\n                0x3003(v134, v134, v175, v169, v134, v176, v174);\n                v177 = _SafeAdd(v169, _orderFills[v134]);\n                _orderFills[v134] = v177;\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v174)]), v134, v169, v176, v175);\n                }\n                require(_orderFills[v134] <= v167 - v134);\n                v169 = v167 - v134 - _orderFills[v134];\n                v171 = v178 = 2548;\n                assert(2 < v134);\n                v173 = v179 = msg.data[64 + v134];\n                assert(3 < v134);\n                v174 = v180 = msg.data[96 + v134];\n                v134 = v181 = 0;\n                goto {'0xbc5B0x1ac', '0x8ce0xa01B0x1ac', '0xdda0xa01B0x1ac'};\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                v182 = v183 = 2370;\n                assert(v134 < v134);\n                v184 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v185 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v186 = msg.data[(2 + v134 << 5) + v134];\n                assert(3 + v134 < v134);\n                v134 = v187 = msg.data[(3 + v134 << 5) + v134];\n                v188 = 0x2de0(v134, v134, v134, v185, v184);\n                v189 = 0x2e3d(v188, v134, v185, v184);\n                v190 = 0x2e89(!address(v134), 0, v134, v189, v134, v186);\n                0x3003(v134, v134, v190, v188, v189, v134, v134);\n                v191 = _SafeAdd(v188, _orderFills[v134]);\n                _orderFills[v134] = v191;\n                require(v188 <= v134);\n                v134 = v134 - v188;\n                v134 = _SafeAdd(v189, v134);\n                if (_tradeEventEnabled) {\n                    emit TradeSuccess(address(_userId2Address[uint32(v134)]), v189, v188, v134, v190);\n                }\n                goto {'0x9420xa01B0x1ac', '0xe380xa01B0x1ac'};\n                v134 += 6;\n                if (v134 >= v134) {\n                    v176 = !v134;\n                    if (v176) {\n                        v192 = v193 = 2455;\n                        v168 = v194 = 1;\n                        assert(v194 < v134);\n                    } else {\n                        v192 = v195 = 2433;\n                        v168 = v196 = 0;\n                        assert(v196 < v134);\n                    }\n                } else {\n                    v197 = v198 = v134 > 0;\n                    if (v198) {\n                        v199 = v200 = 1953;\n                        assert(v134 < v134);\n                    }\n                }\n                v134 += 6;\n                goto 0xc400xa01B0x1ac;\n                require(v197);\n                assert(v134 + 3 < v134);\n                v201 = uint32(msg.data[(v134 + 3 << 5) + v134]);\n                v134 = v202 = address(_userId2Address[v201]);\n                assert(v134 + 3 < v134);\n                require(msg.data[(v134 + 3 << 5) + v134] >> 224 > _userNonce[v202]);\n                v203 = new uint256[](v134);\n                CALLDATACOPY(v203.data, v134, v134 << 5);\n                assert(3 + v134 < v134);\n                assert(v134 < v203.length);\n                assert(1 + v134 < v203.length);\n                assert(2 + v134 < v203.length);\n                v204 = address(v134) | msg.data[(3 + v134 << 5) + v134] & ~0xffffffffffffffffffffffffffffffffffffffff;\n                v205 = (msg.data[(3 + v134 << 5) + v134] & 0xfffffffffffffffffffffff0000000000000000) >> 64;\n                v134 = v206 = keccak256(address(this), v203[v134 << 5], v203[1 + v134], v203[2 + v134], v204, address(v134), v205);\n                v155 = 2254;\n                assert(v134 + 3 < v134);\n                if (!(msg.data[(v134 + 3 << 5) + v134] & 0xf000000000000000000000000000000000000000)) {\n                    v207 = 27;\n                } else {\n                    v207 = v208 = 28;\n                }\n                v157 = v209 = 0xff & v207;\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                v182 = v210 = 3640;\n                assert(v134 < v134);\n                v184 = v211 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v185 = v212 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v186 = v213 = msg.data[(2 + v134 << 5) + v134];\n                v134 = v214 = 0;\n                require(address(MEM[MEM[64] - 32]) == address(v134));\n                if (v134) {\n                    assert(1 < v134);\n                    v215 = msg.data[32 + v134];\n                } else {\n                    assert(0 < v134);\n                    v215 = v216 = msg.data[0 + v134];\n                }\n                require(_orderFills[v134] <= v215);\n                v134 = v217 = v215 - _orderFills[v134];\n                require(v217);\n                v134 = !v134;\n                v134 = v218 = 0;\n                v134 = v219 = 6;\n                if (v134 >= v134) {\n                    v176 = v220 = !v134;\n                    if (v220) {\n                        v192 = v221 = 3704;\n                        v168 = v222 = 1;\n                        assert(v222 < v134);\n                    } else {\n                        v192 = v223 = 3682;\n                        v168 = v224 = 0;\n                        assert(v224 < v134);\n                    }\n                } else {\n                    v225 = v226 = v134 > 0;\n                    if (v226) {\n                        v199 = v227 = 3170;\n                        assert(v134 < v134);\n                    }\n                }\n                v228 = msg.data[(v134 << 5) + v134];\n                v229 = 0;\n                assert(v229 < v134);\n                while (1) {\n                    v230 = msg.data[(v229 << 5) + v134];\n                    if (v230) {\n                        v134 = v231 = v228 * v230;\n                        assert(v230);\n                        require(v231 / v230 == v228);\n                    } else {\n                        v134 = v232 = 0;\n                    }\n                    goto {'0x7c90xa01B0x1ac', '0xc620xa01B0x1ac', '0xc740xa01B0x1ac', '0x7a10xa01B0x1ac'};\n                    v199 = v233 = 1993;\n                    v234 = v134 + 1;\n                    assert(v234 < v134);\n                    v228 = v235 = msg.data[(v234 << 5) + v134];\n                    v229 = v236 = 1;\n                    assert(v236 < v134);\n                    v199 = v237 = 3188;\n                    v234 = v238 = v134 + 1;\n                    assert(v238 < v134);\n                }\n                v197 = v134 <= v134;\n                v225 = v134 <= v134;\n                require(v225);\n                assert(v134 + 3 < v134);\n                v134 = v239 = msg.data[(v134 + 3 << 5) + v134];\n                v134 = v240 = address(_userId2Address[uint32(v239)]);\n                require(v239 >> 224 > _userNonce[uint32(v239)]);\n                assert(v134 < v134);\n                v241 = msg.data[(v134 << 5) + v134];\n                assert(1 + v134 < v134);\n                v242 = msg.data[(1 + v134 << 5) + v134];\n                assert(2 + v134 < v134);\n                v243 = msg.data[(2 + v134 << 5) + v134];\n                if (v134) {\n                    v244 = 0x10000000000000000000000000000000000000000;\n                } else {\n                    v244 = v245 = 0;\n                }\n                v246 = v239 & ~0xfffffffffffffffffffffffffffffffffffffffff | v244 | address(v134);\n                v134 = v247 = keccak256(address(this), v241, v242, v243, v246);\n                v155 = v248 = 3546;\n                if (0 == v239 & 0xf000000000000000000000000000000000000000) {\n                    v157 = 27;\n                    v249 = v250 = v134 + 4;\n                    assert(v250 < v134);\n                } else {\n                    v157 = v251 = 28;\n                }\n                v249 = v134 + 4;\n                assert(v249 < v134);\n                v162 = v252 = msg.data[(v249 << 5) + v134];\n                v163 = v253 = v134 + 5;\n                assert(v253 < v134);\n            }\n        } else if (199 == v0) {\n            require(!msg.value);\n            v254 = v255 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v254 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v254);\n            assert(0 < varg1.length);\n            assert(1 < varg1.length);\n            assert(2 < varg1.length);\n            v256 = v257 = address(_tokenId2Address[(varg1[64] & 0xffff00000000) >> 32]);\n            v258 = keccak256(address(this), varg1[0], varg1[32], v257 | varg1[64] & ~0xffffffffffffffffffffffffffffffffffffffff);\n            require(!(0xff & _userId2Address[v258]));\n            if (!(varg1[64] & 0xf000000000000000000000000000000000000000)) {\n                v259 = v260 = 27;\n            } else {\n                v259 = v261 = 28;\n            }\n            assert(3 < varg1.length);\n            assert(4 < varg1.length);\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            v262, v263 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v258), v259 & 0xff, varg1[96], varg1[128]);\n            require(v262);\n            require(address(MEM[MEM[64] - 32]) == address(_userId2Address[uint32(varg1[64])]));\n            v256 = v264 = 0;\n            if (varg1[64] & 0xf0000000000000000000000000000000000000000 == 0x10000000000000000000000000000000000000000) {\n                v256 = _joyToken;\n            }\n            if (address(v256) != address(v257)) {\n                require(varg1[0] <= _getBalance[address(_userId2Address[uint32(varg1[64])])]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(_userId2Address[uint32(varg1[64])])] - varg1[0];\n                require(varg1[32] <= _getBalance[address(v256)]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(v256)] - varg1[32];\n            } else {\n                v265 = _SafeAdd(varg1[32], varg1[0]);\n                require(v265 <= _getBalance[address(_userId2Address[uint32(varg1[64])])]);\n                _getBalance[address(_userId2Address[uint32(varg1[64])])] = _getBalance[address(_userId2Address[uint32(varg1[64])])] - v265;\n            }\n            v266 = _SafeAdd(varg1[32], _getBalance[_joysoWallet]);\n            _getBalance[_joysoWallet] = v266;\n            _usedHash[_joysoWallet] = 0x1 | ~0xff & _usedHash[_joysoWallet];\n            if (address(v257)) {\n                MEM[32 + MEM[64]] = 0;\n                require((address(v257)).code.size);\n                v267, v268 = address(v257).transfer(address(_userId2Address[uint32(varg1[64])]), varg1[0]).gas(msg.gas - 710);\n                require(v267);\n                require(v268);\n                goto 0x33ad;\n            } else {\n                v269 = address(_userId2Address[uint32(varg1[64])]).call().value(varg1[0]).gas(2300 * !varg1[0]);\n                require(v269);\n            }\n            exit;\n        } else if (44723 == v0) {\n            require(!msg.value);\n            v270 = v271 = msg.sender == _owner;\n            if (msg.sender != _owner) {\n                v270 = 0xff & _isAdmin[msg.sender];\n            }\n            require(v270);\n            assert(2 < varg1.length);\n            v272 = address(_tokenId2Address[(varg1[0x40] & 0xffff00000000) >> 32]);\n            assert(0 < varg1.length);\n            v273 = v274 = 1;\n            while (v273 < varg1.length) {\n                if (v273 < varg1.length) {\n                    break;\n                }\n                assert(v273 < varg1.length);\n                if (1 + v273 < varg1.length) {\n                    break;\n                }\n                assert(1 + v273 < varg1.length);\n                v275 = address(_userId2Address[uint32(varg1[1 + v273 << 5])]);\n                v276 = varg1[1 + v273 << 5] & ~0xffffffffffffffffffffffffffffffffffffffff | address(v272);\n                if (0 == varg1[1 + v273 << 5] & 0xf000000000000000000000000000000000000000) {\n                    v277 = v278 = 27;\n                } else {\n                    v277 = v279 = 28;\n                }\n                assert(v273 + 2 < varg1.length);\n                assert(v273 + 3 < varg1.length);\n                MEM[MEM[64]] = 0;\n                MEM[32 + MEM[64]] = 0;\n                v280, v281 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', keccak256(address(this), varg1[v273], v276, address(varg1[0x0]))), v277 & 0xff, varg1[v273 + 2 << 5], varg1[v273 + 3 << 5]);\n                require(v280);\n                require(address(MEM[MEM[64] - 32]) == address(v275));\n                if (varg1[v273] > 0) {\n                    if (varg1[1 + v273 << 5] & 0xf0000000000000000000000000000000000000000 != 0x10000000000000000000000000000000000000000) {\n                        if (varg1[1 + v273 << 5] & 0xf0000000000000000000000000000000000000000 != 0x20000000000000000000000000000000000000000) {\n                            require(varg1[v273] <= _depositEther[address(v275)]);\n                            _depositEther[address(v275)] = _depositEther[address(v275)] - varg1[v273];\n                            v282 = _SafeAdd(varg1[v273], _depositEther[_joysoWallet]);\n                            _depositEther[_joysoWallet] = v282;\n                        } else {\n                            require(varg1[v273] <= _getBalance[address(v275)]);\n                            _getBalance[address(v275)] = _getBalance[address(v275)] - varg1[v273];\n                            v283 = _SafeAdd(varg1[v273], _getBalance[_joysoWallet]);\n                            _getBalance[_joysoWallet] = v283;\n                        }\n                    } else {\n                        require(varg1[v273] <= _getBalance[address(v275)]);\n                        _getBalance[address(v275)] = _getBalance[address(v275)] - varg1[v273];\n                        v284 = _SafeAdd(varg1[v273], _getBalance[_joysoWallet]);\n                        _getBalance[_joysoWallet] = v284;\n                    }\n                }\n                _getBalance[address(v275)] = 0;\n                if (address(v272)) {\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x95ea7b300000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(varg1[0x0]);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    require((address(v272)).code.size);\n                    v285 = address(v272).call(v286, v276).gas(msg.gas - 710);\n                    require(v285);\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x3b9ca2d000000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(v275);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    MEM[MEM[64] + 68] = address(v272);\n                    require((address(varg1[0x0])).code.size);\n                    v287 = address(varg1[0x0]).call(v286, v276, varg1[v273 + 2 << 5]).gas(msg.gas - 710);\n                    require(v287);\n                } else {\n                    MEM[32 + MEM[64]] = 0;\n                    MEM[MEM[64]] = 0x3b9ca2d000000000000000000000000000000000000000000000000000000000;\n                    MEM[MEM[64] + 4] = address(v275);\n                    MEM[MEM[64] + 36] = _getBalance[address(v275)];\n                    MEM[MEM[64] + 68] = address(v272);\n                    require((address(varg1[0x0])).code.size);\n                    v288 = address(varg1[0x0]).call(v286, v276, varg1[v273 + 2 << 5]).value(_getBalance[address(v275)]).gas(msg.gas - 9710);\n                    require(v288);\n                }\n                v273 = v273 + 4;\n            }\n            exit;\n        } else if (0x2ca5994 == v0) {\n            registerToken(address,uint256);\n        } else if (0x7973ccf == v0) {\n            userCount();\n        } else if (0x7c4d580 == v0) {\n            transferForAdmin(address,address,uint256);\n        } else if (0xf7c9085 == v0) {\n            addToAdmin(address,bool);\n        } else if (0x135a2474 == v0) {\n            joysoWallet();\n        } else if (0x24d7806c == v0) {\n            isAdmin(address);\n        } else if (0x2e04b8e7 == v0) {\n            userNonce(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3fd8b02f == v0) {\n            lockPeriod();\n        } else if (0x560ebbd1 == v0) {\n            usedHash(bytes32);\n        } else if (0x5617a6e8 == v0) {\n            userLock(address);\n        } else if (0x69b59e75 == v0) {\n            collectFee(address);\n        } else if (0x774bafdf == v0) {\n            unlockMe();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x934e1666 == v0) {\n            userId2Address(uint256);\n        } else if (0x98a36ebf == v0) {\n            setTradeEventEnabled(bool);\n        } else if (0x98ea5fca == v0) {\n            depositEther();\n        } else if (0xa64968ac == v0) {\n            joyToken();\n        } else if (0xc25cf1d0 == v0) {\n            changeLockPeriod(uint256);\n        } else if (0xc8799b37 == v0) {\n            tokenAddress2Id(address);\n        } else if (0xd4fac45d == v0) {\n            getBalance(address,address);\n        } else if (0xd5893bb2 == v0) {\n            tradeEventEnabled();\n        } else if (0xd86bc1b0 == v0) {\n            cancelByAdmin(uint256[]);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf912ed00 == v0) {\n            lockMe();\n        } else if (0xfa769257 == v0) {\n            tokenId2Address(uint256);\n        } else if (0xffc69ab1 == v0) {\n            userAddress2Id(address);\n        }\n        exit;\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 30.932557106018066,
	"usage": {
		"completion_tokens": 439,
		"prompt_tokens": 13631,
		"total_tokens": 14070
	}
}