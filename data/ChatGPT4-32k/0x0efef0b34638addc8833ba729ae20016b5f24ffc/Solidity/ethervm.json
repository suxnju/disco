{
	"address": "0x0efef0b34638addc8833ba729ae20016b5f24ffc",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity version of the contract which has been decompiled from the EVM Bytecode. Please make sure to replace all the placeholder functions with your actual implementation.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Contract {\n\n    mapping(address => uint256) balances;\n    mapping(address => uint256) depositToPayout;\n    mapping(address => uint256) skippedDeposits;\n    mapping(uint256 => Deposit) deposits;\n    address public owner;\n    address public newOwnerCandidate;\n    address public escapeHatchCaller;\n    address public escapeHatchDestination;\n    uint256 public nDeposits;\n\n    struct Deposit {\n        uint256 blockNumber;\n        address depositor;\n        uint256 value;\n        bool skipped;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyEscapeHatchCallerOrOwner {\n        require(msg.sender == escapeHatchCaller || msg.sender == owner);\n        _;\n    }\n\n    function newEtherDeposit(uint256 blockNumber) public payable onlyOwner {\n        // Implementation goes here\n    }\n\n    function canWithdraw(address depositor) public view returns (bool) {\n        // Implementation goes here\n    }\n\n    function changeOwnership(address newOwner) public onlyOwner {\n        // Implementation goes here\n    }\n\n    function withdraw() public onlyOwner {\n        // Implementation goes here\n    }\n\n    function skipPayment(uint256 depositId, bool status) public onlyOwner {\n        // Implementation goes here\n    }\n\n    function newTokenDeposit(address depositor, uint256 value, uint256 blockNumber) public onlyOwner returns (uint256) {\n        // Implementation goes here\n    }\n\n    function nextDepositToPayout(address depositor) public view returns (uint256) {\n        // Implementation goes here\n    }\n\n    function removeOwnership(address oldOwner) public onlyOwner {\n        // Implementation goes here\n    }\n\n    function proposeOwnership(address ownerCandidate) public onlyOwner {\n        // Implementation goes here\n    }\n\n    function acceptOwnership() public {\n        // Implementation goes here\n    }\n\n    function isTokenEscapable(address token) public view returns (bool) {\n        // Implementation goes here\n    }\n\n    function escapeHatch(address to) public onlyEscapeHatchCallerOrOwner {\n        // Implementation goes here\n    }\n\n    function isDepositSkiped(address depositor, uint256 depositId) public view returns (bool) {\n        // Implementation goes here\n    }\n\n    function getPendingReward(address depositor, address token) public view returns (uint256) {\n        // Implementation goes here\n    }\n\n    function changeHatchEscapeCaller(address newEscapeHatchCaller) public onlyOwner {\n        // Implementation goes here\n    }\n\n    function cancelPaymentGlobally(uint256 depositId) public onlyOwner {\n        // Implementation goes here\n    }\n    \n    // Other methods...\n}\n```\n\nEach function signature corresponds to the decompiled function in your EVM Bytecode. However, please note that the actual logic inside each function should be written by you as per your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471667,
	"id": "chatcmpl-8MueJxVL5UOpBB7fG2al7T4SUWbvg",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (msg.data.length < 0x04) {\n        label_010E:\n            var var0 = 0x0118;\n            var var1 = 0x00;\n            var0 = newEtherDeposit(var1);\n            stop();\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x02 ** 0xe0 & 0xffffffff;\n        \n            if (var0 == 0x19262d30) {\n                // Dispatch table entry for canWithdraw(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = canWithdraw(var2);\n            \n            label_013A:\n                var temp0 = memory[0x40:0x60];\n                memory[temp0:temp0 + 0x20] = !!var1;\n                var temp1 = memory[0x40:0x60];\n                return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n            } else if (var0 == 0x1f6eb6e7) {\n                // Dispatch table entry for escapeHatchCaller()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = escapeHatchCaller();\n            \n            label_0161:\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp3 = memory[0x40:0x60];\n                return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n            } else if (var0 == 0x2af4c31e) {\n                // Dispatch table entry for changeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                changeOwnership(var2);\n                stop();\n            } else if (var0 == 0x3ccfd60b) {\n                // Dispatch table entry for withdraw()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                withdraw();\n                stop();\n            } else if (var0 == 0x4147e891) {\n                // Dispatch table entry for skipPayment(uint256,bool)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24];\n                var var3 = !!msg.data[0x24:0x44];\n                skipPayment(var2, var3);\n                stop();\n            } else if (var0 == 0x44ab1409) {\n                // Dispatch table entry for newTokenDeposit(address,uint256,uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var3 = msg.data[0x24:0x44];\n                var var4 = msg.data[0x44:0x64];\n                var1 = newTokenDeposit(var2, var3, var4);\n            \n            label_01F1:\n                var temp4 = memory[0x40:0x60];\n                memory[temp4:temp4 + 0x20] = var1;\n                var temp5 = memory[0x40:0x60];\n                return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n            } else if (var0 == 0x5bd693d4) {\n                // Dispatch table entry for nextDepositToPayout(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var2 = nextDepositToPayout(var2);\n                goto label_01F1;\n            } else if (var0 == 0x666a3427) {\n                // Dispatch table entry for removeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                removeOwnership(var2);\n                stop();\n            } else if (var0 == 0x710bf322) {\n                // Dispatch table entry for proposeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                proposeOwnership(var2);\n                stop();\n            } else if (var0 == 0x79ba5097) {\n                // Dispatch table entry for acceptOwnership()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                acceptOwnership();\n                stop();\n            } else if (var0 == 0x892db057) {\n                // Dispatch table entry for isTokenEscapable(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = isTokenEscapable(var2);\n                goto label_013A;\n            } else if (var0 == 0x8da5cb5b) {\n                // Dispatch table entry for owner()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = owner();\n                goto label_0161;\n            } else if (var0 == 0x9cff53e0) {\n                // Dispatch table entry for nDeposits()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var1 = nDeposits();\n                goto label_01F1;\n            } else if (var0 == 0xa142d608) {\n                // Dispatch table entry for escapeHatch(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                escapeHatch(var2);\n                stop();\n            } else if (var0 == 0xa3e7247a) {\n                // Dispatch table entry for isDepositSkiped(address,uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var3 = msg.data[0x24:0x44];\n                var1 = isDepositSkiped(var2, var3);\n                goto label_013A;\n            } else if (var0 == 0xb02c43d0) {\n                // Dispatch table entry for deposits(uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x030f;\n                var2 = msg.data[0x04:0x24];\n                var var5;\n                var2, var3, var4, var5 = deposits(var2);\n                var temp6 = memory[0x40:0x60];\n                memory[temp6:temp6 + 0x20] = var2;\n                memory[temp6 + 0x20:temp6 + 0x20 + 0x20] = var3 & 0x02 ** 0xa0 - 0x01;\n                memory[temp6 + 0x40:temp6 + 0x40 + 0x20] = var4;\n                memory[temp6 + 0x60:temp6 + 0x60 + 0x20] = !!var5;\n                var temp7 = memory[0x40:0x60];\n                return memory[temp7:temp7 + (temp6 + 0x80) - temp7];\n            } else if (var0 == 0xd0782461) {\n                // Dispatch table entry for newEtherDeposit(uint256)\n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24];\n                var1 = newEtherDeposit(var2);\n                goto label_01F1;\n            } else if (var0 == 0xd091b550) {\n                // Dispatch table entry for newOwnerCandidate()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = newOwnerCandidate();\n                goto label_0161;\n            } else if (var0 == 0xd836fbe8) {\n                // Dispatch table entry for changeHatchEscapeCaller(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                changeHatchEscapeCaller(var2);\n                stop();\n            } else if (var0 == 0xd8f5e6c9) {\n                // Dispatch table entry for cancelPaymentGlobally(uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24];\n                cancelPaymentGlobally(var2);\n                stop();\n            } else if (var0 == 0xf5b61230) {\n                // Dispatch table entry for escapeHatchDestination()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = escapeHatchDestination();\n                goto label_0161;\n            } else if (var0 == 0xfe0f3a13) {\n                // Dispatch table entry for getPendingReward(address,address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var temp8 = 0x02 ** 0xa0 - 0x01;\n                var2 = temp8 & msg.data[0x04:0x24];\n                var3 = msg.data[0x24:0x44] & temp8;\n                var1 = getPendingReward(var2, var3);\n                goto label_01F1;\n            } else { goto label_010E; }\n        }\n    }\n    \n    function newEtherDeposit(var arg0) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var1] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (msg.value <= 0x00) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 >= block.number) { revert(memory[0x00:0x00]); }\n    \n        var var2 = storage[0x05];\n        var var4 = 0x05;\n        var var3 = 0x0417;\n        var var5 = var2 + 0x01;\n        func_13DA(var4, var5);\n        var temp1 = var2;\n        var0 = temp1;\n        var2 = 0x05;\n        var3 = var0;\n    \n        if (var3 >= storage[var2]) { assert(); }\n    \n        memory[0x00:0x20] = var2;\n        var1 = var3 * 0x04 + keccak256(memory[0x00:0x20]);\n    \n        if (arg0 == 0x00) {\n            var temp2 = var1;\n            storage[temp2] = block.number - 0x01;\n            var temp3 = temp2 + 0x01;\n            storage[temp3] = storage[temp3] & ~(0x02 ** 0xa0 - 0x01);\n            var temp4 = msg.value;\n            storage[temp2 + 0x02] = temp4;\n            var temp5 = memory[0x40:0x60];\n            memory[temp5:temp5 + 0x20] = temp4;\n            var temp6 = memory[0x40:0x60];\n            log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-2], 0x00]);\n            return var0;\n        } else {\n            var2 = arg0;\n            var temp7 = var1;\n            storage[temp7] = var2;\n            var temp8 = temp7 + 0x01;\n            storage[temp8] = storage[temp8] & ~(0x02 ** 0xa0 - 0x01);\n            var temp9 = msg.value;\n            storage[temp7 + 0x02] = temp9;\n            var temp10 = memory[0x40:0x60];\n            memory[temp10:temp10 + 0x20] = temp9;\n            var temp11 = memory[0x40:0x60];\n            log(memory[temp11:temp11 + (temp10 + 0x20) - temp11], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-3], 0x00]);\n            return var0;\n        }\n    }\n    \n    function canWithdraw(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x07;\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = var2;\n    \n        if (storage[keccak256(memory[var3:var3 + 0x40])] != storage[0x05]) {\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x07;\n            var1 = storage[keccak256(memory[0x00:0x40])];\n        \n            if (var1 >= storage[0x05]) {\n            label_065F:\n                return 0x00;\n            } else {\n            label_04FF:\n                var var4 = 0x05;\n                var var5 = var1;\n            \n                if (var5 >= storage[var4]) { assert(); }\n            \n                memory[0x00:0x20] = var4;\n                var2 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n                var4 = !(storage[var2 + 0x03] & 0xff);\n            \n                if (!var4) {\n                label_053B:\n                \n                    if (!var4) {\n                    label_0654:\n                        var3 = var3;\n                        var1 = var1 + 0x01;\n                    \n                        if (var1 >= storage[0x05]) { goto label_065F; }\n                        else { goto label_04FF; }\n                    } else {\n                        var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                        var5 = 0x981b24d0;\n                        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                        var temp0 = memory[0x40:0x60];\n                        memory[temp0:temp0 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                        memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = storage[var2];\n                        var var6 = temp0 + 0x24;\n                        var var7 = 0x20;\n                        var var8 = memory[0x40:0x60];\n                        var var9 = var6 - var8;\n                        var var10 = var8;\n                        var var11 = 0x00;\n                        var var12 = var4;\n                    \n                        if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                    \n                        var temp1;\n                        temp1, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                    \n                        if (!temp1) { revert(memory[0x00:0x00]); }\n                    \n                        var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                        var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                        var6 = 0x4ee2cd7e;\n                        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                        var temp2 = memory[0x40:0x60];\n                        memory[temp2:temp2 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                        memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                        memory[temp2 + 0x24:temp2 + 0x24 + 0x20] = storage[var2];\n                        var7 = temp2 + 0x44;\n                        var8 = 0x20;\n                        var9 = memory[0x40:0x60];\n                        var10 = var7 - var9;\n                        var11 = var9;\n                        var12 = 0x00;\n                        var var13 = var5;\n                    \n                        if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                    \n                        var temp3;\n                        temp3, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                    \n                        if (!temp3) { revert(memory[0x00:0x00]); }\n                    \n                        var5 = storage[var2 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                    \n                        if (!var4) { assert(); }\n                    \n                        var3 = var5 / var4;\n                    \n                        if (var3 <= 0x00) { goto label_0654; }\n                    \n                        var0 = 0x01;\n                    \n                    label_0664:\n                        return var0;\n                    }\n                } else {\n                    var4 = 0x0539;\n                    var5 = arg0;\n                    var6 = var1;\n                    var4 = isDepositSkiped(var5, var6);\n                    var4 = !var4;\n                    goto label_053B;\n                }\n            }\n        } else {\n            var0 = 0x00;\n            goto label_0664;\n        }\n    }\n    \n    function escapeHatchCaller() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function changeOwnership(var arg0) {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var0] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = storage[0x00];\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        var temp3 = ~(0x02 ** 0xa0 - 0x01);\n        var temp4 = (temp1 & temp3) | (temp2 & arg0);\n        storage[0x00] = temp4;\n        storage[0x01] = temp3 & storage[0x01];\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + memory[0x40:0x60] - temp5], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, ((storage[0x00] & ~(0x02 ** 0xa0 - 0x01)) | (stack[-2] & 0x02 ** 0xa0 - 0x01)) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function withdraw() {\n        var var0 = 0x00;\n        memory[var0:var0 + 0x20] = msg.sender;\n        memory[0x20:0x40] = 0x07;\n        var var1 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var2 = var0;\n        var var3 = var2;\n    \n        if (var1 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        var var4 = 0x05;\n        var var5 = var1;\n    \n        if (var5 >= storage[var4]) { assert(); }\n    \n        memory[0x00:0x20] = var4;\n        var2 = storage[var5 * 0x04 + keccak256(memory[0x00:0x20]) + 0x01] & 0x02 ** 0xa0 - 0x01;\n    \n        if (msg.gas <= 0x024608) { revert(memory[0x00:0x00]); }\n    \n    label_0776:\n        var4 = var1 < storage[0x05];\n    \n        if (!var4) {\n            if (!var4) {\n            label_0965:\n                memory[0x00:0x20] = msg.sender;\n                memory[0x20:0x40] = 0x07;\n                var temp0 = var1;\n                storage[keccak256(memory[0x00:0x40])] = temp0;\n                var4 = 0x0992;\n                var5 = temp0 + ~0x00;\n                var var6 = msg.sender;\n                var var7 = var2;\n                var var8 = var0;\n                var4 = func_12A6(var5, var6, var7, var8);\n            \n                if (!var4) { revert(memory[0x00:0x00]); }\n            \n                memory[0x00:0x20] = msg.sender;\n                memory[0x20:0x40] = 0x07;\n            \n                if (var1 == storage[keccak256(memory[0x00:0x40])]) { return; }\n                else { assert(); }\n            } else {\n            label_078F:\n                var4 = 0x05;\n                var5 = var1;\n            \n                if (var5 >= storage[var4]) { assert(); }\n            \n                memory[0x00:0x20] = var4;\n                var3 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n                var4 = !(storage[var3 + 0x03] & 0xff);\n            \n                if (!var4) {\n                label_07CB:\n                \n                    if (!var4) {\n                    label_095A:\n                        var3 = var3;\n                        var1 = var1 + 0x01;\n                        goto label_0776;\n                    } else {\n                        var temp1 = 0x02 ** 0xa0 - 0x01;\n                    \n                        if (storage[var3 + 0x01] & temp1 == temp1 & var2) {\n                        label_0855:\n                            var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                            var5 = 0x981b24d0;\n                            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                            var temp2 = memory[0x40:0x60];\n                            memory[temp2:temp2 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                            memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = storage[var3];\n                            var6 = temp2 + 0x24;\n                            var7 = 0x20;\n                            var8 = memory[0x40:0x60];\n                            var var9 = var6 - var8;\n                            var var10 = var8;\n                            var var11 = 0x00;\n                            var var12 = var4;\n                        \n                            if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                        \n                            var temp3;\n                            temp3, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                        \n                            if (!temp3) { revert(memory[0x00:0x00]); }\n                        \n                            var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                            var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                            var6 = 0x4ee2cd7e;\n                            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                            var temp4 = memory[0x40:0x60];\n                            memory[temp4:temp4 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                            memory[temp4 + 0x04:temp4 + 0x04 + 0x20] = msg.sender;\n                            memory[temp4 + 0x24:temp4 + 0x24 + 0x20] = storage[var3];\n                            var7 = temp4 + 0x44;\n                            var8 = 0x20;\n                            var9 = memory[0x40:0x60];\n                            var10 = var7 - var9;\n                            var11 = var9;\n                            var12 = 0x00;\n                            var var13 = var5;\n                        \n                            if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                        \n                            var temp5;\n                            temp5, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                        \n                            if (!temp5) { revert(memory[0x00:0x00]); }\n                        \n                            var5 = storage[var3 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                        \n                            if (!var4) { assert(); }\n                        \n                            var0 = var0 + var5 / var4;\n                            goto label_095A;\n                        } else {\n                            memory[0x00:0x20] = msg.sender;\n                            memory[0x20:0x40] = 0x07;\n                            var temp6 = var1;\n                            storage[keccak256(memory[0x00:0x40])] = temp6;\n                            var4 = 0x0814;\n                            var5 = temp6 + ~0x00;\n                            var6 = msg.sender;\n                            var7 = var2;\n                            var8 = var0;\n                            var4 = func_12A6(var5, var6, var7, var8);\n                        \n                            if (!var4) { revert(memory[0x00:0x00]); }\n                        \n                            memory[0x00:0x20] = msg.sender;\n                            memory[0x20:0x40] = 0x07;\n                        \n                            if (var1 != storage[keccak256(memory[0x00:0x40])]) { assert(); }\n                        \n                            var0 = 0x00;\n                            var2 = storage[var3 + 0x01] & 0x02 ** 0xa0 - 0x01;\n                            goto label_0855;\n                        }\n                    }\n                } else {\n                    var4 = 0x07c9;\n                    var5 = msg.sender;\n                    var6 = var1;\n                    var4 = isDepositSkiped(var5, var6);\n                    var4 = !var4;\n                    goto label_07CB;\n                }\n            }\n        } else if (msg.gas <= 0x024220) { goto label_0965; }\n        else { goto label_078F; }\n    }\n    \n    function skipPayment(var arg0, var arg1) {\n        if (arg0 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x08;\n        var temp0 = keccak256(memory[0x00:0x40]);\n        var temp1 = arg0;\n        memory[0x00:0x20] = temp1;\n        memory[0x20:0x40] = temp0;\n        var temp2 = keccak256(memory[0x00:0x40]);\n        var temp3 = arg1;\n        storage[temp2] = !!temp3 | (storage[temp2] & ~0xff);\n        var temp4 = memory[0x40:0x60];\n        memory[temp4:temp4 + 0x20] = !!temp3;\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + (temp4 + 0x20) - temp5], [0xd6149459fde27a6c662cc59dbb1674a711ddb77e342754978130b5b3bd0cba1e, stack[-2]]);\n    }\n    \n    function newTokenDeposit(var arg0, var arg1, var arg2) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var1] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg1 <= 0x00) { revert(memory[0x00:0x00]); }\n    \n        if (arg2 >= block.number) { revert(memory[0x00:0x00]); }\n    \n        var var2 = arg0 & 0x02 ** 0xa0 - 0x01;\n        var var3 = 0x23b872dd;\n        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = temp2 & msg.sender;\n        memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = temp2 & address(this);\n        memory[temp1 + 0x44:temp1 + 0x44 + 0x20] = arg1;\n        var var4 = temp1 + 0x64;\n        var var5 = 0x20;\n        var var6 = memory[0x40:0x60];\n        var var7 = var4 - var6;\n        var var8 = var6;\n        var var9 = 0x00;\n        var var10 = var2;\n    \n        if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n    \n        var temp3;\n        temp3, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n    \n        if (!temp3) { revert(memory[0x00:0x00]); }\n    \n        if (!memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20]) { revert(memory[0x00:0x00]); }\n    \n        var2 = storage[0x05];\n        var4 = 0x05;\n        var3 = 0x0b17;\n        var5 = var2 + 0x01;\n        func_13DA(var4, var5);\n        var temp4 = var2;\n        var0 = temp4;\n        var2 = 0x05;\n        var3 = var0;\n    \n        if (var3 >= storage[var2]) { assert(); }\n    \n        memory[0x00:0x20] = var2;\n        var1 = var3 * 0x04 + keccak256(memory[0x00:0x20]);\n    \n        if (arg2 == 0x00) {\n            var temp5 = var1;\n            storage[temp5] = block.number - 0x01;\n            var temp6 = temp5 + 0x01;\n            var temp7 = arg0 & 0x02 ** 0xa0 - 0x01;\n            storage[temp6] = temp7 | (storage[temp6] & ~(0x02 ** 0xa0 - 0x01));\n            var temp8 = arg1;\n            storage[temp5 + 0x02] = temp8;\n            var temp9 = memory[0x40:0x60];\n            memory[temp9:temp9 + 0x20] = temp8;\n            var temp10 = memory[0x40:0x60];\n            log(memory[temp10:temp10 + (temp9 + 0x20) - temp10], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-2], stack[-5] & 0x02 ** 0xa0 - 0x01]);\n            return var0;\n        } else {\n            var2 = arg2;\n            var temp11 = var1;\n            storage[temp11] = var2;\n            var temp12 = temp11 + 0x01;\n            var temp13 = arg0 & 0x02 ** 0xa0 - 0x01;\n            storage[temp12] = temp13 | (storage[temp12] & ~(0x02 ** 0xa0 - 0x01));\n            var temp14 = arg1;\n            storage[temp11 + 0x02] = temp14;\n            var temp15 = memory[0x40:0x60];\n            memory[temp15:temp15 + 0x20] = temp14;\n            var temp16 = memory[0x40:0x60];\n            log(memory[temp16:temp16 + (temp15 + 0x20) - temp16], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-3], stack[-6] & 0x02 ** 0xa0 - 0x01]);\n            return var0;\n        }\n    }\n    \n    function nextDepositToPayout(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x07;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function removeOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 & 0x02 ** 0xa0 - 0x01 != 0x0dac) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = ~(0x02 ** 0xa0 - 0x01);\n        storage[0x00] = temp1 & storage[0x00];\n        storage[0x01] = temp1 & storage[0x01];\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + memory[0x40:0x60] - temp2], [0x94e8b32e01b9eedfddd778ffbd051a7718cdc14781702884561162dca6f74dbb]);\n    }\n    \n    function proposeOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = (temp1 & arg0) | (storage[0x01] & ~(0x02 ** 0xa0 - 0x01));\n        storage[0x01] = temp2;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x13a4b3bc0d5234dd3d87c9f1557d8faefa37986da62c36ba49309e2fb2c9aec4, msg.sender, ((stack[-1] & 0x02 ** 0xa0 - 0x01) | (storage[0x01] & ~(0x02 ** 0xa0 - 0x01))) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function acceptOwnership() {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x01] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = storage[0x00];\n        var temp2 = storage[0x01];\n        var temp3 = ~(0x02 ** 0xa0 - 0x01);\n        var temp4 = 0x02 ** 0xa0 - 0x01;\n        var temp5 = (temp4 & temp2) | (temp1 & temp3);\n        storage[0x00] = temp5;\n        storage[0x01] = temp2 & temp3;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + memory[0x40:0x60] - temp6], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, ((storage[0x01] & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~(0x02 ** 0xa0 - 0x01))) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function isTokenEscapable(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x04;\n        return !(storage[keccak256(memory[0x00:0x40])] & 0xff);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function nDeposits() returns (var r0) { return storage[0x05]; }\n    \n    function func_0D62(var arg0) returns (var r0) { return arg0; }\n    \n    function escapeHatch(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var var2 = storage[0x02] & temp0 == temp0 & msg.sender;\n    \n        if (!var2) {\n            var temp15 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp15 == temp15 & msg.sender) { goto label_0DA0; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var2) {\n        label_0DA0:\n            memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n            memory[0x20:0x40] = 0x04;\n        \n            if (storage[keccak256(memory[0x00:0x40])] & 0xff) { revert(memory[0x00:0x00]); }\n        \n            if (arg0 & 0x02 ** 0xa0 - 0x01) {\n                var1 = arg0;\n                var2 = var1 & 0x02 ** 0xa0 - 0x01;\n                var var3 = 0x70a08231;\n                memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n                memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = address(this);\n                var var4 = temp1 + 0x24;\n                var var5 = 0x20;\n                var var6 = memory[0x40:0x60];\n                var var7 = var4 - var6;\n                var var8 = var6;\n                var var9 = 0x00;\n                var var10 = var2;\n            \n                if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n            \n                var temp2;\n                temp2, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n            \n                if (!temp2) { revert(memory[0x00:0x00]); }\n            \n                var temp3 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                var0 = temp3;\n                var temp4 = 0x02 ** 0xa0 - 0x01;\n                var2 = var1 & temp4;\n                var3 = 0xa9059cbb;\n                memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                var temp5 = memory[0x40:0x60];\n                memory[temp5:temp5 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n                memory[temp5 + 0x04:temp5 + 0x04 + 0x20] = storage[0x03] & temp4 & 0x02 ** 0xa0 - 0x01;\n                memory[temp5 + 0x24:temp5 + 0x24 + 0x20] = var0;\n                var4 = temp5 + 0x44;\n                var5 = 0x20;\n                var6 = memory[0x40:0x60];\n                var7 = var4 - var6;\n                var8 = var6;\n                var9 = 0x00;\n                var10 = var2;\n            \n                if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n            \n                var temp6;\n                temp6, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n            \n                if (!temp6) { revert(memory[0x00:0x00]); }\n            \n                var temp7 = memory[0x40:0x60];\n                memory[temp7:temp7 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                memory[temp7 + 0x20:temp7 + 0x20 + 0x20] = var0;\n                var temp8 = memory[0x40:0x60];\n                log(memory[temp8:temp8 + (temp7 + 0x40) - temp8], [0xa50dde912fa22ea0d215a0236093ac45b4d55d6ef0c604c319f900029c5d10f2]);\n            \n            label_0F92:\n                return;\n            } else {\n                var temp9 = 0x02 ** 0xa0 - 0x01;\n                var temp10 = address(temp9 & address(this)).balance;\n                var0 = temp10;\n                var temp11 = memory[0x40:0x60];\n                var temp12;\n                temp12, memory[temp11:temp11 + 0x00] = address(temp9 & storage[0x03]).call.gas(!var0 * 0x08fc).value(var0)(memory[temp11:temp11 + memory[0x40:0x60] - temp11]);\n            \n                if (!temp12) { revert(memory[0x00:0x00]); }\n            \n                var temp13 = memory[0x40:0x60];\n                memory[temp13:temp13 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                memory[temp13 + 0x20:temp13 + 0x20 + 0x20] = var0;\n                var temp14 = memory[0x40:0x60];\n                log(memory[temp14:temp14 + (temp13 + 0x40) - temp14], [0xa50dde912fa22ea0d215a0236093ac45b4d55d6ef0c604c319f900029c5d10f2]);\n                goto label_0F92;\n            }\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function isDepositSkiped(var arg0, var arg1) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x08;\n        var temp0 = keccak256(memory[0x00:0x40]);\n        memory[0x00:0x20] = arg1;\n        memory[0x20:0x40] = temp0;\n        return storage[keccak256(memory[0x00:0x40])] & 0xff;\n    }\n    \n    function deposits(var arg0) returns (var arg0, var r1, var r2, var r3) {\n        r1 = 0x05;\n        r2 = arg0;\n    \n        if (r2 >= storage[r1]) { assert(); }\n    \n        memory[0x00:0x20] = r1;\n        var temp0 = r2 * 0x04 + keccak256(memory[0x00:0x20]);\n        arg0 = storage[temp0];\n        r1 = storage[temp0 + 0x01] & 0x02 ** 0xa0 - 0x01;\n        r2 = storage[temp0 + 0x02];\n        r3 = storage[temp0 + 0x03] & 0xff;\n        return arg0, r1, r2, r3;\n    }\n    \n    function newOwnerCandidate() returns (var r0) { return storage[0x01] & 0x02 ** 0xa0 - 0x01; }\n    \n    function changeHatchEscapeCaller(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var var0 = storage[0x02] & temp0 == temp0 & msg.sender;\n    \n        if (!var0) {\n            var temp1 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp1 == temp1 & msg.sender) { goto label_104B; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var0) {\n        label_104B:\n            storage[0x02] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x02] & ~(0x02 ** 0xa0 - 0x01));\n            return;\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function cancelPaymentGlobally(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x01;\n        var var1 = 0x05;\n        var var2 = arg0;\n    \n        if (var2 >= storage[var1]) { assert(); }\n    \n        memory[0x00:0x20] = var1;\n        var temp1 = var2 * 0x04 + keccak256(memory[0x00:0x20]) + 0x03;\n        storage[temp1] = !!var0 | (storage[temp1] & ~0xff);\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + memory[0x40:0x60] - temp2], [0xa3d465f21dc4259cc4c67491949fc38ff4518179cd78b168bff44bc412115005, stack[-4]]);\n    }\n    \n    function escapeHatchDestination() returns (var r0) { return storage[0x03] & 0x02 ** 0xa0 - 0x01; }\n    \n    function getPendingReward(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        memory[var0:var0 + 0x20] = msg.sender;\n        memory[0x20:0x40] = 0x07;\n        var var2 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var1 = var0;\n        var var3 = var1;\n    \n        if (var2 >= storage[0x05]) {\n        label_129C:\n            return var1;\n        } else {\n        label_1130:\n            var var4 = 0x05;\n            var var5 = var2;\n        \n            if (var5 >= storage[var4]) { assert(); }\n        \n            memory[0x00:0x20] = var4;\n            var3 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n            var temp0 = 0x02 ** 0xa0 - 0x01;\n            var4 = storage[var3 + 0x01] & temp0 == temp0 & arg0;\n        \n            if (var4) {\n                var4 = !(storage[var3 + 0x03] & 0xff);\n            \n                if (!var4) { goto label_1187; }\n                else { goto label_117B; }\n            } else if (!var4) {\n            label_1187:\n            \n                if (!var4) {\n                label_1291:\n                    var3 = var3;\n                    var2 = var2 + 0x01;\n                \n                    if (var2 >= storage[0x05]) { goto label_129C; }\n                    else { goto label_1130; }\n                } else {\n                    var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                    var5 = 0x981b24d0;\n                    memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                    var temp1 = memory[0x40:0x60];\n                    memory[temp1:temp1 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                    memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = storage[var3];\n                    var var6 = temp1 + 0x24;\n                    var var7 = 0x20;\n                    var var8 = memory[0x40:0x60];\n                    var var9 = var6 - var8;\n                    var var10 = var8;\n                    var var11 = 0x00;\n                    var var12 = var4;\n                \n                    if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                \n                    var temp2;\n                    temp2, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                \n                    if (!temp2) { revert(memory[0x00:0x00]); }\n                \n                    var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                    var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                    var6 = 0x4ee2cd7e;\n                    memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                    var temp3 = memory[0x40:0x60];\n                    memory[temp3:temp3 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                    memory[temp3 + 0x04:temp3 + 0x04 + 0x20] = arg1 & 0x02 ** 0xa0 - 0x01;\n                    memory[temp3 + 0x24:temp3 + 0x24 + 0x20] = storage[var3];\n                    var7 = temp3 + 0x44;\n                    var8 = 0x20;\n                    var9 = memory[0x40:0x60];\n                    var10 = var7 - var9;\n                    var11 = var9;\n                    var12 = 0x00;\n                    var var13 = var5;\n                \n                    if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                \n                    var temp4;\n                    temp4, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                \n                    if (!temp4) { revert(memory[0x00:0x00]); }\n                \n                    var5 = storage[var3 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                \n                    if (!var4) { assert(); }\n                \n                    var1 = var1 + var5 / var4;\n                    goto label_1291;\n                }\n            } else {\n            label_117B:\n                var4 = 0x1185;\n                var5 = arg1;\n                var6 = var2;\n                var4 = isDepositSkiped(var5, var6);\n                var4 = !var4;\n                goto label_1187;\n            }\n        }\n    }\n    \n    function func_12A6(var arg0, var arg1, var arg2, var arg3) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (!arg3) {\n            var0 = 0x01;\n            goto label_13D2;\n        } else if (arg2 & 0x02 ** 0xa0 - 0x01) {\n            var var1 = arg2 & 0x02 ** 0xa0 - 0x01;\n            var var2 = 0xa9059cbb;\n            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = (var2 & 0xffffffff) * 0x02 ** 0xe0;\n            memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = arg1 & 0x02 ** 0xa0 - 0x01;\n            memory[temp0 + 0x24:temp0 + 0x24 + 0x20] = arg3;\n            var var3 = temp0 + 0x44;\n            var var4 = 0x20;\n            var var5 = memory[0x40:0x60];\n            var var6 = var3 - var5;\n            var var7 = var5;\n            var var8 = 0x00;\n            var var9 = var1;\n        \n            if (!address(var9).code.length) { revert(memory[0x00:0x00]); }\n        \n            var temp1;\n            temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas - 0x02c6).value(var8)(memory[var7:var7 + var6]);\n        \n            if (!temp1) { revert(memory[0x00:0x00]); }\n        \n            if (memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20]) {\n            label_1386:\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = arg3;\n                var temp3 = memory[0x40:0x60];\n                log(memory[temp3:temp3 + (temp2 + 0x20) - temp3], [0xfeb2000dca3e617cd6f3a8bbb63014bb54a124aac6ccbf73ee7229b4cd01f120, stack[-5], stack[-4] & 0x02 ** 0xa0 - 0x01, stack[-3] & 0x02 ** 0xa0 - 0x01]);\n                var0 = 0x01;\n            \n            label_13D2:\n                return var0;\n            } else {\n                var0 = 0x00;\n                goto label_13D2;\n            }\n        } else {\n            var temp4 = arg3;\n            var temp5 = memory[0x40:0x60];\n            var temp6;\n            temp6, memory[temp5:temp5 + 0x00] = address(arg1 & 0x02 ** 0xa0 - 0x01).call.gas(!temp4 * 0x08fc).value(temp4)(memory[temp5:temp5 + memory[0x40:0x60] - temp5]);\n        \n            if (temp6) { goto label_1386; }\n        \n            var0 = 0x00;\n            goto label_13D2;\n        }\n    }\n    \n    function func_13DA(var arg0, var arg1) {\n        var temp0 = arg0;\n        var temp1 = storage[temp0];\n        var var0 = temp1;\n        var temp2 = arg1;\n        storage[temp0] = temp2;\n    \n        if (!var0 > temp2) {\n        label_0F92:\n            return;\n        } else {\n            memory[0x00:0x20] = arg0;\n            var temp3 = keccak256(memory[0x00:0x20]);\n            var temp4 = var0;\n            var0 = 0x0f92;\n            var var1 = 0x0d62;\n            var var2 = temp3 + temp4 * 0x04;\n            var var3 = arg1 * 0x04 + temp3;\n        \n            if (var2 <= var3) {\n                var1 = var2;\n                // Error: Could not resolve jump destination!\n            } else {\n                var1 = func_140D(var2, var3);\n                var0 = func_0D62(var1);\n                goto label_0F92;\n            }\n        }\n    }\n    \n    function func_140D(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg1;\n        storage[temp0] = 0x00;\n        var temp1 = temp0 + 0x01;\n        storage[temp1] = storage[temp1] & ~(0x02 ** 0xa0 - 0x01);\n        storage[temp0 + 0x02] = 0x00;\n        var temp2 = temp0 + 0x03;\n        storage[temp2] = storage[temp2] & ~0xff;\n        arg1 = temp0 + 0x04;\n    \n        if (arg0 <= arg1) { return arg0; }\n    \n        r0 = func_140D(arg0, arg1);\n        // Error: Could not resolve method call return address!\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (msg.data.length < 0x04) {\n        label_010E:\n            var var0 = 0x0118;\n            var var1 = 0x00;\n            var0 = newEtherDeposit(var1);\n            stop();\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x02 ** 0xe0 & 0xffffffff;\n        \n            if (var0 == 0x19262d30) {\n                // Dispatch table entry for canWithdraw(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = canWithdraw(var2);\n            \n            label_013A:\n                var temp0 = memory[0x40:0x60];\n                memory[temp0:temp0 + 0x20] = !!var1;\n                var temp1 = memory[0x40:0x60];\n                return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n            } else if (var0 == 0x1f6eb6e7) {\n                // Dispatch table entry for escapeHatchCaller()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = escapeHatchCaller();\n            \n            label_0161:\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp3 = memory[0x40:0x60];\n                return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n            } else if (var0 == 0x2af4c31e) {\n                // Dispatch table entry for changeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                changeOwnership(var2);\n                stop();\n            } else if (var0 == 0x3ccfd60b) {\n                // Dispatch table entry for withdraw()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                withdraw();\n                stop();\n            } else if (var0 == 0x4147e891) {\n                // Dispatch table entry for skipPayment(uint256,bool)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24];\n                var var3 = !!msg.data[0x24:0x44];\n                skipPayment(var2, var3);\n                stop();\n            } else if (var0 == 0x44ab1409) {\n                // Dispatch table entry for newTokenDeposit(address,uint256,uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var3 = msg.data[0x24:0x44];\n                var var4 = msg.data[0x44:0x64];\n                var1 = newTokenDeposit(var2, var3, var4);\n            \n            label_01F1:\n                var temp4 = memory[0x40:0x60];\n                memory[temp4:temp4 + 0x20] = var1;\n                var temp5 = memory[0x40:0x60];\n                return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n            } else if (var0 == 0x5bd693d4) {\n                // Dispatch table entry for nextDepositToPayout(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var2 = nextDepositToPayout(var2);\n                goto label_01F1;\n            } else if (var0 == 0x666a3427) {\n                // Dispatch table entry for removeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                removeOwnership(var2);\n                stop();\n            } else if (var0 == 0x710bf322) {\n                // Dispatch table entry for proposeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                proposeOwnership(var2);\n                stop();\n            } else if (var0 == 0x79ba5097) {\n                // Dispatch table entry for acceptOwnership()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                acceptOwnership();\n                stop();\n            } else if (var0 == 0x892db057) {\n                // Dispatch table entry for isTokenEscapable(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = isTokenEscapable(var2);\n                goto label_013A;\n            } else if (var0 == 0x8da5cb5b) {\n                // Dispatch table entry for owner()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = owner();\n                goto label_0161;\n            } else if (var0 == 0x9cff53e0) {\n                // Dispatch table entry for nDeposits()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var1 = nDeposits();\n                goto label_01F1;\n            } else if (var0 == 0xa142d608) {\n                // Dispatch table entry for escapeHatch(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                escapeHatch(var2);\n                stop();\n            } else if (var0 == 0xa3e7247a) {\n                // Dispatch table entry for isDepositSkiped(address,uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var3 = msg.data[0x24:0x44];\n                var1 = isDepositSkiped(var2, var3);\n                goto label_013A;\n            } else if (var0 == 0xb02c43d0) {\n                // Dispatch table entry for deposits(uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x030f;\n                var2 = msg.data[0x04:0x24];\n                var var5;\n                var2, var3, var4, var5 = deposits(var2);\n                var temp6 = memory[0x40:0x60];\n                memory[temp6:temp6 + 0x20] = var2;\n                memory[temp6 + 0x20:temp6 + 0x20 + 0x20] = var3 & 0x02 ** 0xa0 - 0x01;\n                memory[temp6 + 0x40:temp6 + 0x40 + 0x20] = var4;\n                memory[temp6 + 0x60:temp6 + 0x60 + 0x20] = !!var5;\n                var temp7 = memory[0x40:0x60];\n                return memory[temp7:temp7 + (temp6 + 0x80) - temp7];\n            } else if (var0 == 0xd0782461) {\n                // Dispatch table entry for newEtherDeposit(uint256)\n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24];\n                var1 = newEtherDeposit(var2);\n                goto label_01F1;\n            } else if (var0 == 0xd091b550) {\n                // Dispatch table entry for newOwnerCandidate()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = newOwnerCandidate();\n                goto label_0161;\n            } else if (var0 == 0xd836fbe8) {\n                // Dispatch table entry for changeHatchEscapeCaller(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                changeHatchEscapeCaller(var2);\n                stop();\n            } else if (var0 == 0xd8f5e6c9) {\n                // Dispatch table entry for cancelPaymentGlobally(uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24];\n                cancelPaymentGlobally(var2);\n                stop();\n            } else if (var0 == 0xf5b61230) {\n                // Dispatch table entry for escapeHatchDestination()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = escapeHatchDestination();\n                goto label_0161;\n            } else if (var0 == 0xfe0f3a13) {\n                // Dispatch table entry for getPendingReward(address,address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var temp8 = 0x02 ** 0xa0 - 0x01;\n                var2 = temp8 & msg.data[0x04:0x24];\n                var3 = msg.data[0x24:0x44] & temp8;\n                var1 = getPendingReward(var2, var3);\n                goto label_01F1;\n            } else { goto label_010E; }\n        }\n    }\n    \n    function newEtherDeposit(var arg0) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var1] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (msg.value <= 0x00) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 >= block.number) { revert(memory[0x00:0x00]); }\n    \n        var var2 = storage[0x05];\n        var var4 = 0x05;\n        var var3 = 0x0417;\n        var var5 = var2 + 0x01;\n        func_13DA(var4, var5);\n        var temp1 = var2;\n        var0 = temp1;\n        var2 = 0x05;\n        var3 = var0;\n    \n        if (var3 >= storage[var2]) { assert(); }\n    \n        memory[0x00:0x20] = var2;\n        var1 = var3 * 0x04 + keccak256(memory[0x00:0x20]);\n    \n        if (arg0 == 0x00) {\n            var temp2 = var1;\n            storage[temp2] = block.number - 0x01;\n            var temp3 = temp2 + 0x01;\n            storage[temp3] = storage[temp3] & ~(0x02 ** 0xa0 - 0x01);\n            var temp4 = msg.value;\n            storage[temp2 + 0x02] = temp4;\n            var temp5 = memory[0x40:0x60];\n            memory[temp5:temp5 + 0x20] = temp4;\n            var temp6 = memory[0x40:0x60];\n            log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-2], 0x00]);\n            return var0;\n        } else {\n            var2 = arg0;\n            var temp7 = var1;\n            storage[temp7] = var2;\n            var temp8 = temp7 + 0x01;\n            storage[temp8] = storage[temp8] & ~(0x02 ** 0xa0 - 0x01);\n            var temp9 = msg.value;\n            storage[temp7 + 0x02] = temp9;\n            var temp10 = memory[0x40:0x60];\n            memory[temp10:temp10 + 0x20] = temp9;\n            var temp11 = memory[0x40:0x60];\n            log(memory[temp11:temp11 + (temp10 + 0x20) - temp11], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-3], 0x00]);\n            return var0;\n        }\n    }\n    \n    function canWithdraw(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x07;\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = var2;\n    \n        if (storage[keccak256(memory[var3:var3 + 0x40])] != storage[0x05]) {\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x07;\n            var1 = storage[keccak256(memory[0x00:0x40])];\n        \n            if (var1 >= storage[0x05]) {\n            label_065F:\n                return 0x00;\n            } else {\n            label_04FF:\n                var var4 = 0x05;\n                var var5 = var1;\n            \n                if (var5 >= storage[var4]) { assert(); }\n            \n                memory[0x00:0x20] = var4;\n                var2 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n                var4 = !(storage[var2 + 0x03] & 0xff);\n            \n                if (!var4) {\n                label_053B:\n                \n                    if (!var4) {\n                    label_0654:\n                        var3 = var3;\n                        var1 = var1 + 0x01;\n                    \n                        if (var1 >= storage[0x05]) { goto label_065F; }\n                        else { goto label_04FF; }\n                    } else {\n                        var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                        var5 = 0x981b24d0;\n                        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                        var temp0 = memory[0x40:0x60];\n                        memory[temp0:temp0 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                        memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = storage[var2];\n                        var var6 = temp0 + 0x24;\n                        var var7 = 0x20;\n                        var var8 = memory[0x40:0x60];\n                        var var9 = var6 - var8;\n                        var var10 = var8;\n                        var var11 = 0x00;\n                        var var12 = var4;\n                    \n                        if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                    \n                        var temp1;\n                        temp1, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                    \n                        if (!temp1) { revert(memory[0x00:0x00]); }\n                    \n                        var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                        var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                        var6 = 0x4ee2cd7e;\n                        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                        var temp2 = memory[0x40:0x60];\n                        memory[temp2:temp2 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                        memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                        memory[temp2 + 0x24:temp2 + 0x24 + 0x20] = storage[var2];\n                        var7 = temp2 + 0x44;\n                        var8 = 0x20;\n                        var9 = memory[0x40:0x60];\n                        var10 = var7 - var9;\n                        var11 = var9;\n                        var12 = 0x00;\n                        var var13 = var5;\n                    \n                        if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                    \n                        var temp3;\n                        temp3, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                    \n                        if (!temp3) { revert(memory[0x00:0x00]); }\n                    \n                        var5 = storage[var2 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                    \n                        if (!var4) { assert(); }\n                    \n                        var3 = var5 / var4;\n                    \n                        if (var3 <= 0x00) { goto label_0654; }\n                    \n                        var0 = 0x01;\n                    \n                    label_0664:\n                        return var0;\n                    }\n                } else {\n                    var4 = 0x0539;\n                    var5 = arg0;\n                    var6 = var1;\n                    var4 = isDepositSkiped(var5, var6);\n                    var4 = !var4;\n                    goto label_053B;\n                }\n            }\n        } else {\n            var0 = 0x00;\n            goto label_0664;\n        }\n    }\n    \n    function escapeHatchCaller() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function changeOwnership(var arg0) {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var0] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = storage[0x00];\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        var temp3 = ~(0x02 ** 0xa0 - 0x01);\n        var temp4 = (temp1 & temp3) | (temp2 & arg0);\n        storage[0x00] = temp4;\n        storage[0x01] = temp3 & storage[0x01];\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + memory[0x40:0x60] - temp5], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, ((storage[0x00] & ~(0x02 ** 0xa0 - 0x01)) | (stack[-2] & 0x02 ** 0xa0 - 0x01)) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function withdraw() {\n        var var0 = 0x00;\n        memory[var0:var0 + 0x20] = msg.sender;\n        memory[0x20:0x40] = 0x07;\n        var var1 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var2 = var0;\n        var var3 = var2;\n    \n        if (var1 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        var var4 = 0x05;\n        var var5 = var1;\n    \n        if (var5 >= storage[var4]) { assert(); }\n    \n        memory[0x00:0x20] = var4;\n        var2 = storage[var5 * 0x04 + keccak256(memory[0x00:0x20]) + 0x01] & 0x02 ** 0xa0 - 0x01;\n    \n        if (msg.gas <= 0x024608) { revert(memory[0x00:0x00]); }\n    \n    label_0776:\n        var4 = var1 < storage[0x05];\n    \n        if (!var4) {\n            if (!var4) {\n            label_0965:\n                memory[0x00:0x20] = msg.sender;\n                memory[0x20:0x40] = 0x07;\n                var temp0 = var1;\n                storage[keccak256(memory[0x00:0x40])] = temp0;\n                var4 = 0x0992;\n                var5 = temp0 + ~0x00;\n                var var6 = msg.sender;\n                var var7 = var2;\n                var var8 = var0;\n                var4 = func_12A6(var5, var6, var7, var8);\n            \n                if (!var4) { revert(memory[0x00:0x00]); }\n            \n                memory[0x00:0x20] = msg.sender;\n                memory[0x20:0x40] = 0x07;\n            \n                if (var1 == storage[keccak256(memory[0x00:0x40])]) { return; }\n                else { assert(); }\n            } else {\n            label_078F:\n                var4 = 0x05;\n                var5 = var1;\n            \n                if (var5 >= storage[var4]) { assert(); }\n            \n                memory[0x00:0x20] = var4;\n                var3 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n                var4 = !(storage[var3 + 0x03] & 0xff);\n            \n                if (!var4) {\n                label_07CB:\n                \n                    if (!var4) {\n                    label_095A:\n                        var3 = var3;\n                        var1 = var1 + 0x01;\n                        goto label_0776;\n                    } else {\n                        var temp1 = 0x02 ** 0xa0 - 0x01;\n                    \n                        if (storage[var3 + 0x01] & temp1 == temp1 & var2) {\n                        label_0855:\n                            var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                            var5 = 0x981b24d0;\n                            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                            var temp2 = memory[0x40:0x60];\n                            memory[temp2:temp2 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                            memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = storage[var3];\n                            var6 = temp2 + 0x24;\n                            var7 = 0x20;\n                            var8 = memory[0x40:0x60];\n                            var var9 = var6 - var8;\n                            var var10 = var8;\n                            var var11 = 0x00;\n                            var var12 = var4;\n                        \n                            if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                        \n                            var temp3;\n                            temp3, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                        \n                            if (!temp3) { revert(memory[0x00:0x00]); }\n                        \n                            var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                            var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                            var6 = 0x4ee2cd7e;\n                            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                            var temp4 = memory[0x40:0x60];\n                            memory[temp4:temp4 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                            memory[temp4 + 0x04:temp4 + 0x04 + 0x20] = msg.sender;\n                            memory[temp4 + 0x24:temp4 + 0x24 + 0x20] = storage[var3];\n                            var7 = temp4 + 0x44;\n                            var8 = 0x20;\n                            var9 = memory[0x40:0x60];\n                            var10 = var7 - var9;\n                            var11 = var9;\n                            var12 = 0x00;\n                            var var13 = var5;\n                        \n                            if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                        \n                            var temp5;\n                            temp5, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                        \n                            if (!temp5) { revert(memory[0x00:0x00]); }\n                        \n                            var5 = storage[var3 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                        \n                            if (!var4) { assert(); }\n                        \n                            var0 = var0 + var5 / var4;\n                            goto label_095A;\n                        } else {\n                            memory[0x00:0x20] = msg.sender;\n                            memory[0x20:0x40] = 0x07;\n                            var temp6 = var1;\n                            storage[keccak256(memory[0x00:0x40])] = temp6;\n                            var4 = 0x0814;\n                            var5 = temp6 + ~0x00;\n                            var6 = msg.sender;\n                            var7 = var2;\n                            var8 = var0;\n                            var4 = func_12A6(var5, var6, var7, var8);\n                        \n                            if (!var4) { revert(memory[0x00:0x00]); }\n                        \n                            memory[0x00:0x20] = msg.sender;\n                            memory[0x20:0x40] = 0x07;\n                        \n                            if (var1 != storage[keccak256(memory[0x00:0x40])]) { assert(); }\n                        \n                            var0 = 0x00;\n                            var2 = storage[var3 + 0x01] & 0x02 ** 0xa0 - 0x01;\n                            goto label_0855;\n                        }\n                    }\n                } else {\n                    var4 = 0x07c9;\n                    var5 = msg.sender;\n                    var6 = var1;\n                    var4 = isDepositSkiped(var5, var6);\n                    var4 = !var4;\n                    goto label_07CB;\n                }\n            }\n        } else if (msg.gas <= 0x024220) { goto label_0965; }\n        else { goto label_078F; }\n    }\n    \n    function skipPayment(var arg0, var arg1) {\n        if (arg0 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x08;\n        var temp0 = keccak256(memory[0x00:0x40]);\n        var temp1 = arg0;\n        memory[0x00:0x20] = temp1;\n        memory[0x20:0x40] = temp0;\n        var temp2 = keccak256(memory[0x00:0x40]);\n        var temp3 = arg1;\n        storage[temp2] = !!temp3 | (storage[temp2] & ~0xff);\n        var temp4 = memory[0x40:0x60];\n        memory[temp4:temp4 + 0x20] = !!temp3;\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + (temp4 + 0x20) - temp5], [0xd6149459fde27a6c662cc59dbb1674a711ddb77e342754978130b5b3bd0cba1e, stack[-2]]);\n    }\n    \n    function newTokenDeposit(var arg0, var arg1, var arg2) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var1] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg1 <= 0x00) { revert(memory[0x00:0x00]); }\n    \n        if (arg2 >= block.number) { revert(memory[0x00:0x00]); }\n    \n        var var2 = arg0 & 0x02 ** 0xa0 - 0x01;\n        var var3 = 0x23b872dd;\n        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = temp2 & msg.sender;\n        memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = temp2 & address(this);\n        memory[temp1 + 0x44:temp1 + 0x44 + 0x20] = arg1;\n        var var4 = temp1 + 0x64;\n        var var5 = 0x20;\n        var var6 = memory[0x40:0x60];\n        var var7 = var4 - var6;\n        var var8 = var6;\n        var var9 = 0x00;\n        var var10 = var2;\n    \n        if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n    \n        var temp3;\n        temp3, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n    \n        if (!temp3) { revert(memory[0x00:0x00]); }\n    \n        if (!memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20]) { revert(memory[0x00:0x00]); }\n    \n        var2 = storage[0x05];\n        var4 = 0x05;\n        var3 = 0x0b17;\n        var5 = var2 + 0x01;\n        func_13DA(var4, var5);\n        var temp4 = var2;\n        var0 = temp4;\n        var2 = 0x05;\n        var3 = var0;\n    \n        if (var3 >= storage[var2]) { assert(); }\n    \n        memory[0x00:0x20] = var2;\n        var1 = var3 * 0x04 + keccak256(memory[0x00:0x20]);\n    \n        if (arg2 == 0x00) {\n            var temp5 = var1;\n            storage[temp5] = block.number - 0x01;\n            var temp6 = temp5 + 0x01;\n            var temp7 = arg0 & 0x02 ** 0xa0 - 0x01;\n            storage[temp6] = temp7 | (storage[temp6] & ~(0x02 ** 0xa0 - 0x01));\n            var temp8 = arg1;\n            storage[temp5 + 0x02] = temp8;\n            var temp9 = memory[0x40:0x60];\n            memory[temp9:temp9 + 0x20] = temp8;\n            var temp10 = memory[0x40:0x60];\n            log(memory[temp10:temp10 + (temp9 + 0x20) - temp10], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-2], stack[-5] & 0x02 ** 0xa0 - 0x01]);\n            return var0;\n        } else {\n            var2 = arg2;\n            var temp11 = var1;\n            storage[temp11] = var2;\n            var temp12 = temp11 + 0x01;\n            var temp13 = arg0 & 0x02 ** 0xa0 - 0x01;\n            storage[temp12] = temp13 | (storage[temp12] & ~(0x02 ** 0xa0 - 0x01));\n            var temp14 = arg1;\n            storage[temp11 + 0x02] = temp14;\n            var temp15 = memory[0x40:0x60];\n            memory[temp15:temp15 + 0x20] = temp14;\n            var temp16 = memory[0x40:0x60];\n            log(memory[temp16:temp16 + (temp15 + 0x20) - temp16], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-3], stack[-6] & 0x02 ** 0xa0 - 0x01]);\n            return var0;\n        }\n    }\n    \n    function nextDepositToPayout(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x07;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function removeOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 & 0x02 ** 0xa0 - 0x01 != 0x0dac) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = ~(0x02 ** 0xa0 - 0x01);\n        storage[0x00] = temp1 & storage[0x00];\n        storage[0x01] = temp1 & storage[0x01];\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + memory[0x40:0x60] - temp2], [0x94e8b32e01b9eedfddd778ffbd051a7718cdc14781702884561162dca6f74dbb]);\n    }\n    \n    function proposeOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = (temp1 & arg0) | (storage[0x01] & ~(0x02 ** 0xa0 - 0x01));\n        storage[0x01] = temp2;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x13a4b3bc0d5234dd3d87c9f1557d8faefa37986da62c36ba49309e2fb2c9aec4, msg.sender, ((stack[-1] & 0x02 ** 0xa0 - 0x01) | (storage[0x01] & ~(0x02 ** 0xa0 - 0x01))) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function acceptOwnership() {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x01] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = storage[0x00];\n        var temp2 = storage[0x01];\n        var temp3 = ~(0x02 ** 0xa0 - 0x01);\n        var temp4 = 0x02 ** 0xa0 - 0x01;\n        var temp5 = (temp4 & temp2) | (temp1 & temp3);\n        storage[0x00] = temp5;\n        storage[0x01] = temp2 & temp3;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + memory[0x40:0x60] - temp6], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, ((storage[0x01] & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~(0x02 ** 0xa0 - 0x01))) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function isTokenEscapable(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x04;\n        return !(storage[keccak256(memory[0x00:0x40])] & 0xff);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function nDeposits() returns (var r0) { return storage[0x05]; }\n    \n    function func_0D62(var arg0) returns (var r0) { return arg0; }\n    \n    function escapeHatch(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var var2 = storage[0x02] & temp0 == temp0 & msg.sender;\n    \n        if (!var2) {\n            var temp15 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp15 == temp15 & msg.sender) { goto label_0DA0; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var2) {\n        label_0DA0:\n            memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n            memory[0x20:0x40] = 0x04;\n        \n            if (storage[keccak256(memory[0x00:0x40])] & 0xff) { revert(memory[0x00:0x00]); }\n        \n            if (arg0 & 0x02 ** 0xa0 - 0x01) {\n                var1 = arg0;\n                var2 = var1 & 0x02 ** 0xa0 - 0x01;\n                var var3 = 0x70a08231;\n                memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n                memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = address(this);\n                var var4 = temp1 + 0x24;\n                var var5 = 0x20;\n                var var6 = memory[0x40:0x60];\n                var var7 = var4 - var6;\n                var var8 = var6;\n                var var9 = 0x00;\n                var var10 = var2;\n            \n                if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n            \n                var temp2;\n                temp2, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n            \n                if (!temp2) { revert(memory[0x00:0x00]); }\n            \n                var temp3 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                var0 = temp3;\n                var temp4 = 0x02 ** 0xa0 - 0x01;\n                var2 = var1 & temp4;\n                var3 = 0xa9059cbb;\n                memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                var temp5 = memory[0x40:0x60];\n                memory[temp5:temp5 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n                memory[temp5 + 0x04:temp5 + 0x04 + 0x20] = storage[0x03] & temp4 & 0x02 ** 0xa0 - 0x01;\n                memory[temp5 + 0x24:temp5 + 0x24 + 0x20] = var0;\n                var4 = temp5 + 0x44;\n                var5 = 0x20;\n                var6 = memory[0x40:0x60];\n                var7 = var4 - var6;\n                var8 = var6;\n                var9 = 0x00;\n                var10 = var2;\n            \n                if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n            \n                var temp6;\n                temp6, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n            \n                if (!temp6) { revert(memory[0x00:0x00]); }\n            \n                var temp7 = memory[0x40:0x60];\n                memory[temp7:temp7 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                memory[temp7 + 0x20:temp7 + 0x20 + 0x20] = var0;\n                var temp8 = memory[0x40:0x60];\n                log(memory[temp8:temp8 + (temp7 + 0x40) - temp8], [0xa50dde912fa22ea0d215a0236093ac45b4d55d6ef0c604c319f900029c5d10f2]);\n            \n            label_0F92:\n                return;\n            } else {\n                var temp9 = 0x02 ** 0xa0 - 0x01;\n                var temp10 = address(temp9 & address(this)).balance;\n                var0 = temp10;\n                var temp11 = memory[0x40:0x60];\n                var temp12;\n                temp12, memory[temp11:temp11 + 0x00] = address(temp9 & storage[0x03]).call.gas(!var0 * 0x08fc).value(var0)(memory[temp11:temp11 + memory[0x40:0x60] - temp11]);\n            \n                if (!temp12) { revert(memory[0x00:0x00]); }\n            \n                var temp13 = memory[0x40:0x60];\n                memory[temp13:temp13 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                memory[temp13 + 0x20:temp13 + 0x20 + 0x20] = var0;\n                var temp14 = memory[0x40:0x60];\n                log(memory[temp14:temp14 + (temp13 + 0x40) - temp14], [0xa50dde912fa22ea0d215a0236093ac45b4d55d6ef0c604c319f900029c5d10f2]);\n                goto label_0F92;\n            }\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function isDepositSkiped(var arg0, var arg1) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x08;\n        var temp0 = keccak256(memory[0x00:0x40]);\n        memory[0x00:0x20] = arg1;\n        memory[0x20:0x40] = temp0;\n        return storage[keccak256(memory[0x00:0x40])] & 0xff;\n    }\n    \n    function deposits(var arg0) returns (var arg0, var r1, var r2, var r3) {\n        r1 = 0x05;\n        r2 = arg0;\n    \n        if (r2 >= storage[r1]) { assert(); }\n    \n        memory[0x00:0x20] = r1;\n        var temp0 = r2 * 0x04 + keccak256(memory[0x00:0x20]);\n        arg0 = storage[temp0];\n        r1 = storage[temp0 + 0x01] & 0x02 ** 0xa0 - 0x01;\n        r2 = storage[temp0 + 0x02];\n        r3 = storage[temp0 + 0x03] & 0xff;\n        return arg0, r1, r2, r3;\n    }\n    \n    function newOwnerCandidate() returns (var r0) { return storage[0x01] & 0x02 ** 0xa0 - 0x01; }\n    \n    function changeHatchEscapeCaller(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var var0 = storage[0x02] & temp0 == temp0 & msg.sender;\n    \n        if (!var0) {\n            var temp1 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp1 == temp1 & msg.sender) { goto label_104B; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var0) {\n        label_104B:\n            storage[0x02] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x02] & ~(0x02 ** 0xa0 - 0x01));\n            return;\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function cancelPaymentGlobally(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x01;\n        var var1 = 0x05;\n        var var2 = arg0;\n    \n        if (var2 >= storage[var1]) { assert(); }\n    \n        memory[0x00:0x20] = var1;\n        var temp1 = var2 * 0x04 + keccak256(memory[0x00:0x20]) + 0x03;\n        storage[temp1] = !!var0 | (storage[temp1] & ~0xff);\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + memory[0x40:0x60] - temp2], [0xa3d465f21dc4259cc4c67491949fc38ff4518179cd78b168bff44bc412115005, stack[-4]]);\n    }\n    \n    function escapeHatchDestination() returns (var r0) { return storage[0x03] & 0x02 ** 0xa0 - 0x01; }\n    \n    function getPendingReward(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        memory[var0:var0 + 0x20] = msg.sender;\n        memory[0x20:0x40] = 0x07;\n        var var2 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var1 = var0;\n        var var3 = var1;\n    \n        if (var2 >= storage[0x05]) {\n        label_129C:\n            return var1;\n        } else {\n        label_1130:\n            var var4 = 0x05;\n            var var5 = var2;\n        \n            if (var5 >= storage[var4]) { assert(); }\n        \n            memory[0x00:0x20] = var4;\n            var3 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n            var temp0 = 0x02 ** 0xa0 - 0x01;\n            var4 = storage[var3 + 0x01] & temp0 == temp0 & arg0;\n        \n            if (var4) {\n                var4 = !(storage[var3 + 0x03] & 0xff);\n            \n                if (!var4) { goto label_1187; }\n                else { goto label_117B; }\n            } else if (!var4) {\n            label_1187:\n            \n                if (!var4) {\n                label_1291:\n                    var3 = var3;\n                    var2 = var2 + 0x01;\n                \n                    if (var2 >= storage[0x05]) { goto label_129C; }\n                    else { goto label_1130; }\n                } else {\n                    var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                    var5 = 0x981b24d0;\n                    memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                    var temp1 = memory[0x40:0x60];\n                    memory[temp1:temp1 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                    memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = storage[var3];\n                    var var6 = temp1 + 0x24;\n                    var var7 = 0x20;\n                    var var8 = memory[0x40:0x60];\n                    var var9 = var6 - var8;\n                    var var10 = var8;\n                    var var11 = 0x00;\n                    var var12 = var4;\n                \n                    if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                \n                    var temp2;\n                    temp2, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                \n                    if (!temp2) { revert(memory[0x00:0x00]); }\n                \n                    var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                    var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                    var6 = 0x4ee2cd7e;\n                    memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                    var temp3 = memory[0x40:0x60];\n                    memory[temp3:temp3 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                    memory[temp3 + 0x04:temp3 + 0x04 + 0x20] = arg1 & 0x02 ** 0xa0 - 0x01;\n                    memory[temp3 + 0x24:temp3 + 0x24 + 0x20] = storage[var3];\n                    var7 = temp3 + 0x44;\n                    var8 = 0x20;\n                    var9 = memory[0x40:0x60];\n                    var10 = var7 - var9;\n                    var11 = var9;\n                    var12 = 0x00;\n                    var var13 = var5;\n                \n                    if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                \n                    var temp4;\n                    temp4, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                \n                    if (!temp4) { revert(memory[0x00:0x00]); }\n                \n                    var5 = storage[var3 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                \n                    if (!var4) { assert(); }\n                \n                    var1 = var1 + var5 / var4;\n                    goto label_1291;\n                }\n            } else {\n            label_117B:\n                var4 = 0x1185;\n                var5 = arg1;\n                var6 = var2;\n                var4 = isDepositSkiped(var5, var6);\n                var4 = !var4;\n                goto label_1187;\n            }\n        }\n    }\n    \n    function func_12A6(var arg0, var arg1, var arg2, var arg3) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (!arg3) {\n            var0 = 0x01;\n            goto label_13D2;\n        } else if (arg2 & 0x02 ** 0xa0 - 0x01) {\n            var var1 = arg2 & 0x02 ** 0xa0 - 0x01;\n            var var2 = 0xa9059cbb;\n            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = (var2 & 0xffffffff) * 0x02 ** 0xe0;\n            memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = arg1 & 0x02 ** 0xa0 - 0x01;\n            memory[temp0 + 0x24:temp0 + 0x24 + 0x20] = arg3;\n            var var3 = temp0 + 0x44;\n            var var4 = 0x20;\n            var var5 = memory[0x40:0x60];\n            var var6 = var3 - var5;\n            var var7 = var5;\n            var var8 = 0x00;\n            var var9 = var1;\n        \n            if (!address(var9).code.length) { revert(memory[0x00:0x00]); }\n        \n            var temp1;\n            temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas - 0x02c6).value(var8)(memory[var7:var7 + var6]);\n        \n            if (!temp1) { revert(memory[0x00:0x00]); }\n        \n            if (memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20]) {\n            label_1386:\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = arg3;\n                var temp3 = memory[0x40:0x60];\n                log(memory[temp3:temp3 + (temp2 + 0x20) - temp3], [0xfeb2000dca3e617cd6f3a8bbb63014bb54a124aac6ccbf73ee7229b4cd01f120, stack[-5], stack[-4] & 0x02 ** 0xa0 - 0x01, stack[-3] & 0x02 ** 0xa0 - 0x01]);\n                var0 = 0x01;\n            \n            label_13D2:\n                return var0;\n            } else {\n                var0 = 0x00;\n                goto label_13D2;\n            }\n        } else {\n            var temp4 = arg3;\n            var temp5 = memory[0x40:0x60];\n            var temp6;\n            temp6, memory[temp5:temp5 + 0x00] = address(arg1 & 0x02 ** 0xa0 - 0x01).call.gas(!temp4 * 0x08fc).value(temp4)(memory[temp5:temp5 + memory[0x40:0x60] - temp5]);\n        \n            if (temp6) { goto label_1386; }\n        \n            var0 = 0x00;\n            goto label_13D2;\n        }\n    }\n    \n    function func_13DA(var arg0, var arg1) {\n        var temp0 = arg0;\n        var temp1 = storage[temp0];\n        var var0 = temp1;\n        var temp2 = arg1;\n        storage[temp0] = temp2;\n    \n        if (!var0 > temp2) {\n        label_0F92:\n            return;\n        } else {\n            memory[0x00:0x20] = arg0;\n            var temp3 = keccak256(memory[0x00:0x20]);\n            var temp4 = var0;\n            var0 = 0x0f92;\n            var var1 = 0x0d62;\n            var var2 = temp3 + temp4 * 0x04;\n            var var3 = arg1 * 0x04 + temp3;\n        \n            if (var2 <= var3) {\n                var1 = var2;\n                // Error: Could not resolve jump destination!\n            } else {\n                var1 = func_140D(var2, var3);\n                var0 = func_0D62(var1);\n                goto label_0F92;\n            }\n        }\n    }\n    \n    function func_140D(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg1;\n        storage[temp0] = 0x00;\n        var temp1 = temp0 + 0x01;\n        storage[temp1] = storage[temp1] & ~(0x02 ** 0xa0 - 0x01);\n        storage[temp0 + 0x02] = 0x00;\n        var temp2 = temp0 + 0x03;\n        storage[temp2] = storage[temp2] & ~0xff;\n        arg1 = temp0 + 0x04;\n    \n        if (arg0 <= arg1) { return arg0; }\n    \n        r0 = func_140D(arg0, arg1);\n        // Error: Could not resolve method call return address!\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (msg.data.length < 0x04) {\n        label_010E:\n            var var0 = 0x0118;\n            var var1 = 0x00;\n            var0 = newEtherDeposit(var1);\n            stop();\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x02 ** 0xe0 & 0xffffffff;\n        \n            if (var0 == 0x19262d30) {\n                // Dispatch table entry for canWithdraw(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = canWithdraw(var2);\n            \n            label_013A:\n                var temp0 = memory[0x40:0x60];\n                memory[temp0:temp0 + 0x20] = !!var1;\n                var temp1 = memory[0x40:0x60];\n                return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n            } else if (var0 == 0x1f6eb6e7) {\n                // Dispatch table entry for escapeHatchCaller()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = escapeHatchCaller();\n            \n            label_0161:\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp3 = memory[0x40:0x60];\n                return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n            } else if (var0 == 0x2af4c31e) {\n                // Dispatch table entry for changeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                changeOwnership(var2);\n                stop();\n            } else if (var0 == 0x3ccfd60b) {\n                // Dispatch table entry for withdraw()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                withdraw();\n                stop();\n            } else if (var0 == 0x4147e891) {\n                // Dispatch table entry for skipPayment(uint256,bool)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24];\n                var var3 = !!msg.data[0x24:0x44];\n                skipPayment(var2, var3);\n                stop();\n            } else if (var0 == 0x44ab1409) {\n                // Dispatch table entry for newTokenDeposit(address,uint256,uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var3 = msg.data[0x24:0x44];\n                var var4 = msg.data[0x44:0x64];\n                var1 = newTokenDeposit(var2, var3, var4);\n            \n            label_01F1:\n                var temp4 = memory[0x40:0x60];\n                memory[temp4:temp4 + 0x20] = var1;\n                var temp5 = memory[0x40:0x60];\n                return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n            } else if (var0 == 0x5bd693d4) {\n                // Dispatch table entry for nextDepositToPayout(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var2 = nextDepositToPayout(var2);\n                goto label_01F1;\n            } else if (var0 == 0x666a3427) {\n                // Dispatch table entry for removeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                removeOwnership(var2);\n                stop();\n            } else if (var0 == 0x710bf322) {\n                // Dispatch table entry for proposeOwnership(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                proposeOwnership(var2);\n                stop();\n            } else if (var0 == 0x79ba5097) {\n                // Dispatch table entry for acceptOwnership()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                acceptOwnership();\n                stop();\n            } else if (var0 == 0x892db057) {\n                // Dispatch table entry for isTokenEscapable(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = isTokenEscapable(var2);\n                goto label_013A;\n            } else if (var0 == 0x8da5cb5b) {\n                // Dispatch table entry for owner()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = owner();\n                goto label_0161;\n            } else if (var0 == 0x9cff53e0) {\n                // Dispatch table entry for nDeposits()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var1 = nDeposits();\n                goto label_01F1;\n            } else if (var0 == 0xa142d608) {\n                // Dispatch table entry for escapeHatch(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                escapeHatch(var2);\n                stop();\n            } else if (var0 == 0xa3e7247a) {\n                // Dispatch table entry for isDepositSkiped(address,uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x013a;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var3 = msg.data[0x24:0x44];\n                var1 = isDepositSkiped(var2, var3);\n                goto label_013A;\n            } else if (var0 == 0xb02c43d0) {\n                // Dispatch table entry for deposits(uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x030f;\n                var2 = msg.data[0x04:0x24];\n                var var5;\n                var2, var3, var4, var5 = deposits(var2);\n                var temp6 = memory[0x40:0x60];\n                memory[temp6:temp6 + 0x20] = var2;\n                memory[temp6 + 0x20:temp6 + 0x20 + 0x20] = var3 & 0x02 ** 0xa0 - 0x01;\n                memory[temp6 + 0x40:temp6 + 0x40 + 0x20] = var4;\n                memory[temp6 + 0x60:temp6 + 0x60 + 0x20] = !!var5;\n                var temp7 = memory[0x40:0x60];\n                return memory[temp7:temp7 + (temp6 + 0x80) - temp7];\n            } else if (var0 == 0xd0782461) {\n                // Dispatch table entry for newEtherDeposit(uint256)\n                var1 = 0x01f1;\n                var2 = msg.data[0x04:0x24];\n                var1 = newEtherDeposit(var2);\n                goto label_01F1;\n            } else if (var0 == 0xd091b550) {\n                // Dispatch table entry for newOwnerCandidate()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = newOwnerCandidate();\n                goto label_0161;\n            } else if (var0 == 0xd836fbe8) {\n                // Dispatch table entry for changeHatchEscapeCaller(address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                changeHatchEscapeCaller(var2);\n                stop();\n            } else if (var0 == 0xd8f5e6c9) {\n                // Dispatch table entry for cancelPaymentGlobally(uint256)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x019c;\n                var2 = msg.data[0x04:0x24];\n                cancelPaymentGlobally(var2);\n                stop();\n            } else if (var0 == 0xf5b61230) {\n                // Dispatch table entry for escapeHatchDestination()\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0161;\n                var2 = escapeHatchDestination();\n                goto label_0161;\n            } else if (var0 == 0xfe0f3a13) {\n                // Dispatch table entry for getPendingReward(address,address)\n                if (msg.value) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01f1;\n                var temp8 = 0x02 ** 0xa0 - 0x01;\n                var2 = temp8 & msg.data[0x04:0x24];\n                var3 = msg.data[0x24:0x44] & temp8;\n                var1 = getPendingReward(var2, var3);\n                goto label_01F1;\n            } else { goto label_010E; }\n        }\n    }\n    \n    function newEtherDeposit(var arg0) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var1] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (msg.value <= 0x00) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 >= block.number) { revert(memory[0x00:0x00]); }\n    \n        var var2 = storage[0x05];\n        var var4 = 0x05;\n        var var3 = 0x0417;\n        var var5 = var2 + 0x01;\n        func_13DA(var4, var5);\n        var temp1 = var2;\n        var0 = temp1;\n        var2 = 0x05;\n        var3 = var0;\n    \n        if (var3 >= storage[var2]) { assert(); }\n    \n        memory[0x00:0x20] = var2;\n        var1 = var3 * 0x04 + keccak256(memory[0x00:0x20]);\n    \n        if (arg0 == 0x00) {\n            var temp2 = var1;\n            storage[temp2] = block.number - 0x01;\n            var temp3 = temp2 + 0x01;\n            storage[temp3] = storage[temp3] & ~(0x02 ** 0xa0 - 0x01);\n            var temp4 = msg.value;\n            storage[temp2 + 0x02] = temp4;\n            var temp5 = memory[0x40:0x60];\n            memory[temp5:temp5 + 0x20] = temp4;\n            var temp6 = memory[0x40:0x60];\n            log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-2], 0x00]);\n            return var0;\n        } else {\n            var2 = arg0;\n            var temp7 = var1;\n            storage[temp7] = var2;\n            var temp8 = temp7 + 0x01;\n            storage[temp8] = storage[temp8] & ~(0x02 ** 0xa0 - 0x01);\n            var temp9 = msg.value;\n            storage[temp7 + 0x02] = temp9;\n            var temp10 = memory[0x40:0x60];\n            memory[temp10:temp10 + 0x20] = temp9;\n            var temp11 = memory[0x40:0x60];\n            log(memory[temp11:temp11 + (temp10 + 0x20) - temp11], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-3], 0x00]);\n            return var0;\n        }\n    }\n    \n    function canWithdraw(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x07;\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = var2;\n    \n        if (storage[keccak256(memory[var3:var3 + 0x40])] != storage[0x05]) {\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x07;\n            var1 = storage[keccak256(memory[0x00:0x40])];\n        \n            if (var1 >= storage[0x05]) {\n            label_065F:\n                return 0x00;\n            } else {\n            label_04FF:\n                var var4 = 0x05;\n                var var5 = var1;\n            \n                if (var5 >= storage[var4]) { assert(); }\n            \n                memory[0x00:0x20] = var4;\n                var2 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n                var4 = !(storage[var2 + 0x03] & 0xff);\n            \n                if (!var4) {\n                label_053B:\n                \n                    if (!var4) {\n                    label_0654:\n                        var3 = var3;\n                        var1 = var1 + 0x01;\n                    \n                        if (var1 >= storage[0x05]) { goto label_065F; }\n                        else { goto label_04FF; }\n                    } else {\n                        var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                        var5 = 0x981b24d0;\n                        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                        var temp0 = memory[0x40:0x60];\n                        memory[temp0:temp0 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                        memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = storage[var2];\n                        var var6 = temp0 + 0x24;\n                        var var7 = 0x20;\n                        var var8 = memory[0x40:0x60];\n                        var var9 = var6 - var8;\n                        var var10 = var8;\n                        var var11 = 0x00;\n                        var var12 = var4;\n                    \n                        if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                    \n                        var temp1;\n                        temp1, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                    \n                        if (!temp1) { revert(memory[0x00:0x00]); }\n                    \n                        var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                        var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                        var6 = 0x4ee2cd7e;\n                        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                        var temp2 = memory[0x40:0x60];\n                        memory[temp2:temp2 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                        memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                        memory[temp2 + 0x24:temp2 + 0x24 + 0x20] = storage[var2];\n                        var7 = temp2 + 0x44;\n                        var8 = 0x20;\n                        var9 = memory[0x40:0x60];\n                        var10 = var7 - var9;\n                        var11 = var9;\n                        var12 = 0x00;\n                        var var13 = var5;\n                    \n                        if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                    \n                        var temp3;\n                        temp3, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                    \n                        if (!temp3) { revert(memory[0x00:0x00]); }\n                    \n                        var5 = storage[var2 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                    \n                        if (!var4) { assert(); }\n                    \n                        var3 = var5 / var4;\n                    \n                        if (var3 <= 0x00) { goto label_0654; }\n                    \n                        var0 = 0x01;\n                    \n                    label_0664:\n                        return var0;\n                    }\n                } else {\n                    var4 = 0x0539;\n                    var5 = arg0;\n                    var6 = var1;\n                    var4 = isDepositSkiped(var5, var6);\n                    var4 = !var4;\n                    goto label_053B;\n                }\n            }\n        } else {\n            var0 = 0x00;\n            goto label_0664;\n        }\n    }\n    \n    function escapeHatchCaller() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function changeOwnership(var arg0) {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var0] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = storage[0x00];\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        var temp3 = ~(0x02 ** 0xa0 - 0x01);\n        var temp4 = (temp1 & temp3) | (temp2 & arg0);\n        storage[0x00] = temp4;\n        storage[0x01] = temp3 & storage[0x01];\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + memory[0x40:0x60] - temp5], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, ((storage[0x00] & ~(0x02 ** 0xa0 - 0x01)) | (stack[-2] & 0x02 ** 0xa0 - 0x01)) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function withdraw() {\n        var var0 = 0x00;\n        memory[var0:var0 + 0x20] = msg.sender;\n        memory[0x20:0x40] = 0x07;\n        var var1 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var2 = var0;\n        var var3 = var2;\n    \n        if (var1 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        var var4 = 0x05;\n        var var5 = var1;\n    \n        if (var5 >= storage[var4]) { assert(); }\n    \n        memory[0x00:0x20] = var4;\n        var2 = storage[var5 * 0x04 + keccak256(memory[0x00:0x20]) + 0x01] & 0x02 ** 0xa0 - 0x01;\n    \n        if (msg.gas <= 0x024608) { revert(memory[0x00:0x00]); }\n    \n    label_0776:\n        var4 = var1 < storage[0x05];\n    \n        if (!var4) {\n            if (!var4) {\n            label_0965:\n                memory[0x00:0x20] = msg.sender;\n                memory[0x20:0x40] = 0x07;\n                var temp0 = var1;\n                storage[keccak256(memory[0x00:0x40])] = temp0;\n                var4 = 0x0992;\n                var5 = temp0 + ~0x00;\n                var var6 = msg.sender;\n                var var7 = var2;\n                var var8 = var0;\n                var4 = func_12A6(var5, var6, var7, var8);\n            \n                if (!var4) { revert(memory[0x00:0x00]); }\n            \n                memory[0x00:0x20] = msg.sender;\n                memory[0x20:0x40] = 0x07;\n            \n                if (var1 == storage[keccak256(memory[0x00:0x40])]) { return; }\n                else { assert(); }\n            } else {\n            label_078F:\n                var4 = 0x05;\n                var5 = var1;\n            \n                if (var5 >= storage[var4]) { assert(); }\n            \n                memory[0x00:0x20] = var4;\n                var3 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n                var4 = !(storage[var3 + 0x03] & 0xff);\n            \n                if (!var4) {\n                label_07CB:\n                \n                    if (!var4) {\n                    label_095A:\n                        var3 = var3;\n                        var1 = var1 + 0x01;\n                        goto label_0776;\n                    } else {\n                        var temp1 = 0x02 ** 0xa0 - 0x01;\n                    \n                        if (storage[var3 + 0x01] & temp1 == temp1 & var2) {\n                        label_0855:\n                            var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                            var5 = 0x981b24d0;\n                            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                            var temp2 = memory[0x40:0x60];\n                            memory[temp2:temp2 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                            memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = storage[var3];\n                            var6 = temp2 + 0x24;\n                            var7 = 0x20;\n                            var8 = memory[0x40:0x60];\n                            var var9 = var6 - var8;\n                            var var10 = var8;\n                            var var11 = 0x00;\n                            var var12 = var4;\n                        \n                            if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                        \n                            var temp3;\n                            temp3, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                        \n                            if (!temp3) { revert(memory[0x00:0x00]); }\n                        \n                            var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                            var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                            var6 = 0x4ee2cd7e;\n                            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                            var temp4 = memory[0x40:0x60];\n                            memory[temp4:temp4 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                            memory[temp4 + 0x04:temp4 + 0x04 + 0x20] = msg.sender;\n                            memory[temp4 + 0x24:temp4 + 0x24 + 0x20] = storage[var3];\n                            var7 = temp4 + 0x44;\n                            var8 = 0x20;\n                            var9 = memory[0x40:0x60];\n                            var10 = var7 - var9;\n                            var11 = var9;\n                            var12 = 0x00;\n                            var var13 = var5;\n                        \n                            if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                        \n                            var temp5;\n                            temp5, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                        \n                            if (!temp5) { revert(memory[0x00:0x00]); }\n                        \n                            var5 = storage[var3 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                        \n                            if (!var4) { assert(); }\n                        \n                            var0 = var0 + var5 / var4;\n                            goto label_095A;\n                        } else {\n                            memory[0x00:0x20] = msg.sender;\n                            memory[0x20:0x40] = 0x07;\n                            var temp6 = var1;\n                            storage[keccak256(memory[0x00:0x40])] = temp6;\n                            var4 = 0x0814;\n                            var5 = temp6 + ~0x00;\n                            var6 = msg.sender;\n                            var7 = var2;\n                            var8 = var0;\n                            var4 = func_12A6(var5, var6, var7, var8);\n                        \n                            if (!var4) { revert(memory[0x00:0x00]); }\n                        \n                            memory[0x00:0x20] = msg.sender;\n                            memory[0x20:0x40] = 0x07;\n                        \n                            if (var1 != storage[keccak256(memory[0x00:0x40])]) { assert(); }\n                        \n                            var0 = 0x00;\n                            var2 = storage[var3 + 0x01] & 0x02 ** 0xa0 - 0x01;\n                            goto label_0855;\n                        }\n                    }\n                } else {\n                    var4 = 0x07c9;\n                    var5 = msg.sender;\n                    var6 = var1;\n                    var4 = isDepositSkiped(var5, var6);\n                    var4 = !var4;\n                    goto label_07CB;\n                }\n            }\n        } else if (msg.gas <= 0x024220) { goto label_0965; }\n        else { goto label_078F; }\n    }\n    \n    function skipPayment(var arg0, var arg1) {\n        if (arg0 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x08;\n        var temp0 = keccak256(memory[0x00:0x40]);\n        var temp1 = arg0;\n        memory[0x00:0x20] = temp1;\n        memory[0x20:0x40] = temp0;\n        var temp2 = keccak256(memory[0x00:0x40]);\n        var temp3 = arg1;\n        storage[temp2] = !!temp3 | (storage[temp2] & ~0xff);\n        var temp4 = memory[0x40:0x60];\n        memory[temp4:temp4 + 0x20] = !!temp3;\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + (temp4 + 0x20) - temp5], [0xd6149459fde27a6c662cc59dbb1674a711ddb77e342754978130b5b3bd0cba1e, stack[-2]]);\n    }\n    \n    function newTokenDeposit(var arg0, var arg1, var arg2) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var1] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg1 <= 0x00) { revert(memory[0x00:0x00]); }\n    \n        if (arg2 >= block.number) { revert(memory[0x00:0x00]); }\n    \n        var var2 = arg0 & 0x02 ** 0xa0 - 0x01;\n        var var3 = 0x23b872dd;\n        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = temp2 & msg.sender;\n        memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = temp2 & address(this);\n        memory[temp1 + 0x44:temp1 + 0x44 + 0x20] = arg1;\n        var var4 = temp1 + 0x64;\n        var var5 = 0x20;\n        var var6 = memory[0x40:0x60];\n        var var7 = var4 - var6;\n        var var8 = var6;\n        var var9 = 0x00;\n        var var10 = var2;\n    \n        if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n    \n        var temp3;\n        temp3, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n    \n        if (!temp3) { revert(memory[0x00:0x00]); }\n    \n        if (!memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20]) { revert(memory[0x00:0x00]); }\n    \n        var2 = storage[0x05];\n        var4 = 0x05;\n        var3 = 0x0b17;\n        var5 = var2 + 0x01;\n        func_13DA(var4, var5);\n        var temp4 = var2;\n        var0 = temp4;\n        var2 = 0x05;\n        var3 = var0;\n    \n        if (var3 >= storage[var2]) { assert(); }\n    \n        memory[0x00:0x20] = var2;\n        var1 = var3 * 0x04 + keccak256(memory[0x00:0x20]);\n    \n        if (arg2 == 0x00) {\n            var temp5 = var1;\n            storage[temp5] = block.number - 0x01;\n            var temp6 = temp5 + 0x01;\n            var temp7 = arg0 & 0x02 ** 0xa0 - 0x01;\n            storage[temp6] = temp7 | (storage[temp6] & ~(0x02 ** 0xa0 - 0x01));\n            var temp8 = arg1;\n            storage[temp5 + 0x02] = temp8;\n            var temp9 = memory[0x40:0x60];\n            memory[temp9:temp9 + 0x20] = temp8;\n            var temp10 = memory[0x40:0x60];\n            log(memory[temp10:temp10 + (temp9 + 0x20) - temp10], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-2], stack[-5] & 0x02 ** 0xa0 - 0x01]);\n            return var0;\n        } else {\n            var2 = arg2;\n            var temp11 = var1;\n            storage[temp11] = var2;\n            var temp12 = temp11 + 0x01;\n            var temp13 = arg0 & 0x02 ** 0xa0 - 0x01;\n            storage[temp12] = temp13 | (storage[temp12] & ~(0x02 ** 0xa0 - 0x01));\n            var temp14 = arg1;\n            storage[temp11 + 0x02] = temp14;\n            var temp15 = memory[0x40:0x60];\n            memory[temp15:temp15 + 0x20] = temp14;\n            var temp16 = memory[0x40:0x60];\n            log(memory[temp16:temp16 + (temp15 + 0x20) - temp16], [0xe6d83b1e0e5126a0574d0154ed77e40181534edcb74f035b158d92ed3d10a030, stack[-3], stack[-6] & 0x02 ** 0xa0 - 0x01]);\n            return var0;\n        }\n    }\n    \n    function nextDepositToPayout(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x07;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function removeOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 & 0x02 ** 0xa0 - 0x01 != 0x0dac) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = ~(0x02 ** 0xa0 - 0x01);\n        storage[0x00] = temp1 & storage[0x00];\n        storage[0x01] = temp1 & storage[0x01];\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + memory[0x40:0x60] - temp2], [0x94e8b32e01b9eedfddd778ffbd051a7718cdc14781702884561162dca6f74dbb]);\n    }\n    \n    function proposeOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = (temp1 & arg0) | (storage[0x01] & ~(0x02 ** 0xa0 - 0x01));\n        storage[0x01] = temp2;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x13a4b3bc0d5234dd3d87c9f1557d8faefa37986da62c36ba49309e2fb2c9aec4, msg.sender, ((stack[-1] & 0x02 ** 0xa0 - 0x01) | (storage[0x01] & ~(0x02 ** 0xa0 - 0x01))) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function acceptOwnership() {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x01] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = storage[0x00];\n        var temp2 = storage[0x01];\n        var temp3 = ~(0x02 ** 0xa0 - 0x01);\n        var temp4 = 0x02 ** 0xa0 - 0x01;\n        var temp5 = (temp4 & temp2) | (temp1 & temp3);\n        storage[0x00] = temp5;\n        storage[0x01] = temp2 & temp3;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + memory[0x40:0x60] - temp6], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, ((storage[0x01] & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~(0x02 ** 0xa0 - 0x01))) & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function isTokenEscapable(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x04;\n        return !(storage[keccak256(memory[0x00:0x40])] & 0xff);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function nDeposits() returns (var r0) { return storage[0x05]; }\n    \n    function func_0D62(var arg0) returns (var r0) { return arg0; }\n    \n    function escapeHatch(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var var2 = storage[0x02] & temp0 == temp0 & msg.sender;\n    \n        if (!var2) {\n            var temp15 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp15 == temp15 & msg.sender) { goto label_0DA0; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var2) {\n        label_0DA0:\n            memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n            memory[0x20:0x40] = 0x04;\n        \n            if (storage[keccak256(memory[0x00:0x40])] & 0xff) { revert(memory[0x00:0x00]); }\n        \n            if (arg0 & 0x02 ** 0xa0 - 0x01) {\n                var1 = arg0;\n                var2 = var1 & 0x02 ** 0xa0 - 0x01;\n                var var3 = 0x70a08231;\n                memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n                memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = address(this);\n                var var4 = temp1 + 0x24;\n                var var5 = 0x20;\n                var var6 = memory[0x40:0x60];\n                var var7 = var4 - var6;\n                var var8 = var6;\n                var var9 = 0x00;\n                var var10 = var2;\n            \n                if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n            \n                var temp2;\n                temp2, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n            \n                if (!temp2) { revert(memory[0x00:0x00]); }\n            \n                var temp3 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                var0 = temp3;\n                var temp4 = 0x02 ** 0xa0 - 0x01;\n                var2 = var1 & temp4;\n                var3 = 0xa9059cbb;\n                memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                var temp5 = memory[0x40:0x60];\n                memory[temp5:temp5 + 0x20] = (var3 & 0xffffffff) * 0x02 ** 0xe0;\n                memory[temp5 + 0x04:temp5 + 0x04 + 0x20] = storage[0x03] & temp4 & 0x02 ** 0xa0 - 0x01;\n                memory[temp5 + 0x24:temp5 + 0x24 + 0x20] = var0;\n                var4 = temp5 + 0x44;\n                var5 = 0x20;\n                var6 = memory[0x40:0x60];\n                var7 = var4 - var6;\n                var8 = var6;\n                var9 = 0x00;\n                var10 = var2;\n            \n                if (!address(var10).code.length) { revert(memory[0x00:0x00]); }\n            \n                var temp6;\n                temp6, memory[var6:var6 + var5] = address(var10).call.gas(msg.gas - 0x02c6).value(var9)(memory[var8:var8 + var7]);\n            \n                if (!temp6) { revert(memory[0x00:0x00]); }\n            \n                var temp7 = memory[0x40:0x60];\n                memory[temp7:temp7 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                memory[temp7 + 0x20:temp7 + 0x20 + 0x20] = var0;\n                var temp8 = memory[0x40:0x60];\n                log(memory[temp8:temp8 + (temp7 + 0x40) - temp8], [0xa50dde912fa22ea0d215a0236093ac45b4d55d6ef0c604c319f900029c5d10f2]);\n            \n            label_0F92:\n                return;\n            } else {\n                var temp9 = 0x02 ** 0xa0 - 0x01;\n                var temp10 = address(temp9 & address(this)).balance;\n                var0 = temp10;\n                var temp11 = memory[0x40:0x60];\n                var temp12;\n                temp12, memory[temp11:temp11 + 0x00] = address(temp9 & storage[0x03]).call.gas(!var0 * 0x08fc).value(var0)(memory[temp11:temp11 + memory[0x40:0x60] - temp11]);\n            \n                if (!temp12) { revert(memory[0x00:0x00]); }\n            \n                var temp13 = memory[0x40:0x60];\n                memory[temp13:temp13 + 0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n                memory[temp13 + 0x20:temp13 + 0x20 + 0x20] = var0;\n                var temp14 = memory[0x40:0x60];\n                log(memory[temp14:temp14 + (temp13 + 0x40) - temp14], [0xa50dde912fa22ea0d215a0236093ac45b4d55d6ef0c604c319f900029c5d10f2]);\n                goto label_0F92;\n            }\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function isDepositSkiped(var arg0, var arg1) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x08;\n        var temp0 = keccak256(memory[0x00:0x40]);\n        memory[0x00:0x20] = arg1;\n        memory[0x20:0x40] = temp0;\n        return storage[keccak256(memory[0x00:0x40])] & 0xff;\n    }\n    \n    function deposits(var arg0) returns (var arg0, var r1, var r2, var r3) {\n        r1 = 0x05;\n        r2 = arg0;\n    \n        if (r2 >= storage[r1]) { assert(); }\n    \n        memory[0x00:0x20] = r1;\n        var temp0 = r2 * 0x04 + keccak256(memory[0x00:0x20]);\n        arg0 = storage[temp0];\n        r1 = storage[temp0 + 0x01] & 0x02 ** 0xa0 - 0x01;\n        r2 = storage[temp0 + 0x02];\n        r3 = storage[temp0 + 0x03] & 0xff;\n        return arg0, r1, r2, r3;\n    }\n    \n    function newOwnerCandidate() returns (var r0) { return storage[0x01] & 0x02 ** 0xa0 - 0x01; }\n    \n    function changeHatchEscapeCaller(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var var0 = storage[0x02] & temp0 == temp0 & msg.sender;\n    \n        if (!var0) {\n            var temp1 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp1 == temp1 & msg.sender) { goto label_104B; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var0) {\n        label_104B:\n            storage[0x02] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x02] & ~(0x02 ** 0xa0 - 0x01));\n            return;\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function cancelPaymentGlobally(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 >= storage[0x05]) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x01;\n        var var1 = 0x05;\n        var var2 = arg0;\n    \n        if (var2 >= storage[var1]) { assert(); }\n    \n        memory[0x00:0x20] = var1;\n        var temp1 = var2 * 0x04 + keccak256(memory[0x00:0x20]) + 0x03;\n        storage[temp1] = !!var0 | (storage[temp1] & ~0xff);\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + memory[0x40:0x60] - temp2], [0xa3d465f21dc4259cc4c67491949fc38ff4518179cd78b168bff44bc412115005, stack[-4]]);\n    }\n    \n    function escapeHatchDestination() returns (var r0) { return storage[0x03] & 0x02 ** 0xa0 - 0x01; }\n    \n    function getPendingReward(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        memory[var0:var0 + 0x20] = msg.sender;\n        memory[0x20:0x40] = 0x07;\n        var var2 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var1 = var0;\n        var var3 = var1;\n    \n        if (var2 >= storage[0x05]) {\n        label_129C:\n            return var1;\n        } else {\n        label_1130:\n            var var4 = 0x05;\n            var var5 = var2;\n        \n            if (var5 >= storage[var4]) { assert(); }\n        \n            memory[0x00:0x20] = var4;\n            var3 = var5 * 0x04 + keccak256(memory[0x00:0x20]);\n            var temp0 = 0x02 ** 0xa0 - 0x01;\n            var4 = storage[var3 + 0x01] & temp0 == temp0 & arg0;\n        \n            if (var4) {\n                var4 = !(storage[var3 + 0x03] & 0xff);\n            \n                if (!var4) { goto label_1187; }\n                else { goto label_117B; }\n            } else if (!var4) {\n            label_1187:\n            \n                if (!var4) {\n                label_1291:\n                    var3 = var3;\n                    var2 = var2 + 0x01;\n                \n                    if (var2 >= storage[0x05]) { goto label_129C; }\n                    else { goto label_1130; }\n                } else {\n                    var4 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                    var5 = 0x981b24d0;\n                    memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                    var temp1 = memory[0x40:0x60];\n                    memory[temp1:temp1 + 0x20] = (var5 & 0xffffffff) * 0x02 ** 0xe0;\n                    memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = storage[var3];\n                    var var6 = temp1 + 0x24;\n                    var var7 = 0x20;\n                    var var8 = memory[0x40:0x60];\n                    var var9 = var6 - var8;\n                    var var10 = var8;\n                    var var11 = 0x00;\n                    var var12 = var4;\n                \n                    if (!address(var12).code.length) { revert(memory[0x00:0x00]); }\n                \n                    var temp2;\n                    temp2, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n                \n                    if (!temp2) { revert(memory[0x00:0x00]); }\n                \n                    var4 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                    var5 = storage[0x06] & 0x02 ** 0xa0 - 0x01;\n                    var6 = 0x4ee2cd7e;\n                    memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n                    var temp3 = memory[0x40:0x60];\n                    memory[temp3:temp3 + 0x20] = (var6 & 0xffffffff) * 0x02 ** 0xe0;\n                    memory[temp3 + 0x04:temp3 + 0x04 + 0x20] = arg1 & 0x02 ** 0xa0 - 0x01;\n                    memory[temp3 + 0x24:temp3 + 0x24 + 0x20] = storage[var3];\n                    var7 = temp3 + 0x44;\n                    var8 = 0x20;\n                    var9 = memory[0x40:0x60];\n                    var10 = var7 - var9;\n                    var11 = var9;\n                    var12 = 0x00;\n                    var var13 = var5;\n                \n                    if (!address(var13).code.length) { revert(memory[0x00:0x00]); }\n                \n                    var temp4;\n                    temp4, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n                \n                    if (!temp4) { revert(memory[0x00:0x00]); }\n                \n                    var5 = storage[var3 + 0x02] * memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n                \n                    if (!var4) { assert(); }\n                \n                    var1 = var1 + var5 / var4;\n                    goto label_1291;\n                }\n            } else {\n            label_117B:\n                var4 = 0x1185;\n                var5 = arg1;\n                var6 = var2;\n                var4 = isDepositSkiped(var5, var6);\n                var4 = !var4;\n                goto label_1187;\n            }\n        }\n    }\n    \n    function func_12A6(var arg0, var arg1, var arg2, var arg3) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (!arg3) {\n            var0 = 0x01;\n            goto label_13D2;\n        } else if (arg2 & 0x02 ** 0xa0 - 0x01) {\n            var var1 = arg2 & 0x02 ** 0xa0 - 0x01;\n            var var2 = 0xa9059cbb;\n            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = (var2 & 0xffffffff) * 0x02 ** 0xe0;\n            memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = arg1 & 0x02 ** 0xa0 - 0x01;\n            memory[temp0 + 0x24:temp0 + 0x24 + 0x20] = arg3;\n            var var3 = temp0 + 0x44;\n            var var4 = 0x20;\n            var var5 = memory[0x40:0x60];\n            var var6 = var3 - var5;\n            var var7 = var5;\n            var var8 = 0x00;\n            var var9 = var1;\n        \n            if (!address(var9).code.length) { revert(memory[0x00:0x00]); }\n        \n            var temp1;\n            temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas - 0x02c6).value(var8)(memory[var7:var7 + var6]);\n        \n            if (!temp1) { revert(memory[0x00:0x00]); }\n        \n            if (memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20]) {\n            label_1386:\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = arg3;\n                var temp3 = memory[0x40:0x60];\n                log(memory[temp3:temp3 + (temp2 + 0x20) - temp3], [0xfeb2000dca3e617cd6f3a8bbb63014bb54a124aac6ccbf73ee7229b4cd01f120, stack[-5], stack[-4] & 0x02 ** 0xa0 - 0x01, stack[-3] & 0x02 ** 0xa0 - 0x01]);\n                var0 = 0x01;\n            \n            label_13D2:\n                return var0;\n            } else {\n                var0 = 0x00;\n                goto label_13D2;\n            }\n        } else {\n            var temp4 = arg3;\n            var temp5 = memory[0x40:0x60];\n            var temp6;\n            temp6, memory[temp5:temp5 + 0x00] = address(arg1 & 0x02 ** 0xa0 - 0x01).call.gas(!temp4 * 0x08fc).value(temp4)(memory[temp5:temp5 + memory[0x40:0x60] - temp5]);\n        \n            if (temp6) { goto label_1386; }\n        \n            var0 = 0x00;\n            goto label_13D2;\n        }\n    }\n    \n    function func_13DA(var arg0, var arg1) {\n        var temp0 = arg0;\n        var temp1 = storage[temp0];\n        var var0 = temp1;\n        var temp2 = arg1;\n        storage[temp0] = temp2;\n    \n        if (!var0 > temp2) {\n        label_0F92:\n            return;\n        } else {\n            memory[0x00:0x20] = arg0;\n            var temp3 = keccak256(memory[0x00:0x20]);\n            var temp4 = var0;\n            var0 = 0x0f92;\n            var var1 = 0x0d62;\n            var var2 = temp3 + temp4 * 0x04;\n            var var3 = arg1 * 0x04 + temp3;\n        \n            if (var2 <= var3) {\n                var1 = var2;\n                // Error: Could not resolve jump destination!\n            } else {\n                var1 = func_140D(var2, var3);\n                var0 = func_0D62(var1);\n                goto label_0F92;\n            }\n        }\n    }\n    \n    function func_140D(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg1;\n        storage[temp0] = 0x00;\n        var temp1 = temp0 + 0x01;\n        storage[temp1] = storage[temp1] & ~(0x02 ** 0xa0 - 0x01);\n        storage[temp0 + 0x02] = 0x00;\n        var temp2 = temp0 + 0x03;\n        storage[temp2] = storage[temp2] & ~0xff;\n        arg1 = temp0 + 0x04;\n    \n        if (arg0 <= arg1) { return arg0; }\n    \n        r0 = func_140D(arg0, arg1);\n        // Error: Could not resolve method call return address!\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 60.472564458847046,
	"usage": {
		"completion_tokens": 630,
		"prompt_tokens": 14560,
		"total_tokens": 15190
	}
}