{
	"address": "0xff81e0f888c31b91c8ec623498cf82a5c7a37f7a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, the Solidity version of the provided code could look similar to the following:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n\n    uint256[] public _name;\n    uint256[] public _symbol;\n    uint256 public _decimals;\n    uint256 public __totalSupply;\n    uint256 public _tokens;\n    uint256 public _oneEth;\n    uint256 public _icoEndDate;\n    mapping (address => uint256) public _balanceOf;\n    mapping (address => mapping (address => uint256)) public _allowance;\n    address public _owner;\n    address public _ethFundMain;\n    bool public _stopped;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _balanceOf[_from]);\n        require(_value <= _allowance[_from][msg.sender]);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        _allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function drain() public {\n        require(msg.sender == _owner);\n        _ethFundMain.transfer(address(this).balance);\n    }\n\n    function PauseICO() public {\n        require(msg.sender == _owner);\n        _stopped = true;\n    }\n\n    function ResumeICO() public {\n        require(msg.sender == _owner);\n        _stopped = false;\n    }\n\n    function fallback() public payable {\n        require(msg.sender != _owner);\n        require(msg.value >= 1 ether);\n        require(block.timestamp <= _icoEndDate);\n        require(!_stopped);\n        _tokens = msg.value / 1 ether * _oneEth;\n        _balanceOf[msg.sender] += _tokens;\n        _balanceOf[_owner] -= _tokens;\n        emit Transfer(_owner, msg.sender, _tokens);\n    }\n}\n```\nPlease note that this code might not work as expected due to the provided pseudocode's complexity and the process of translating it to Solidity. Always test your smart contracts thoroughly before deploying them to a live network.",
				"role": "assistant"
			}
		}
	],
	"created": 1701466305,
	"id": "chatcmpl-8R5Ortw70tyyWp5JFQ748Oht47PUC",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 00:05 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 __totalSupply; // STORAGE[0x3]\nuint256 _tokens; // STORAGE[0x4]\nuint256 _oneEth; // STORAGE[0x5]\nuint256 _icoEndDate; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\naddress _owner; // STORAGE[0x7] bytes 0 to 19\naddress _ethFundMain; // STORAGE[0x8] bytes 0 to 19\nuint8 _stopped; // STORAGE[0x7] bytes 20 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.sender != _owner;\n    if (v1) {\n        v0 = v2 = msg.value >= 0x470de4df820000;\n    }\n    if (v0) {\n        v0 = v3 = block.timestamp <= _icoEndDate;\n    }\n    if (v0) {\n        v0 = v4 = _stopped == 0;\n    }\n    require(v0);\n    assert(10 ** _decimals);\n    _tokens = msg.value / 10 ** _decimals * _oneEth;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _tokens;\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokens;\n    emit Transfer(_owner, msg.sender, _tokens);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _tokens = varg1 * 10 ** _decimals;\n    _allowance[varg0] = _tokens;\n    emit Approval(msg.sender, varg0, _tokens);\n    return 1;\n}\n\nfunction oneEth() public nonPayable { \n    return _oneEth;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    _tokens = varg2 * 10 ** _decimals;\n    v0 = v1 = _balanceOf[varg0] >= _tokens;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= _tokens;\n    }\n    if (v0) {\n        v0 = v3 = _tokens >= 0;\n    }\n    require(v0);\n    _balanceOf[varg0] = _balanceOf[varg0] - _tokens;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - _tokens;\n    _balanceOf[varg1] = _balanceOf[varg1] + _tokens;\n    emit Transfer(varg0, varg1, _tokens);\n    return 1;\n}\n\nfunction icoEndDate() public nonPayable { \n    return _icoEndDate;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction ethFundMain() public nonPayable { \n    return _ethFundMain;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction stopped() public nonPayable { \n    return _stopped;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction drain() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _ethFundMain.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction tokens() public nonPayable { \n    return _tokens;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != _owner);\n    _tokens = varg1 * 10 ** _decimals;\n    _balanceOf[varg0] = _balanceOf[varg0] + _tokens;\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokens;\n    emit Transfer(_owner, varg0, _tokens);\n    return 0;\n}\n\nfunction ResumeICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stopped = 0;\n}\n\nfunction PauseICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stopped = 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    v0 = v1 = varg0 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != 0;\n    }\n    require(v0);\n    return _allowance[varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x9a8d3f5 == function_selector) {\n            oneEth();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2a62738b == function_selector) {\n            icoEndDate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x6bf82d74 == function_selector) {\n            ethFundMain();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75f12b21 == function_selector) {\n            stopped();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9890220b == function_selector) {\n            drain();\n        } else if (0x9d63848a == function_selector) {\n            tokens();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd7a2c3b == function_selector) {\n            ResumeICO();\n        } else if (0xcf5ae516 == function_selector) {\n            PauseICO();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 00:05 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 __totalSupply; // STORAGE[0x3]\nuint256 _tokens; // STORAGE[0x4]\nuint256 _oneEth; // STORAGE[0x5]\nuint256 _icoEndDate; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\naddress _owner; // STORAGE[0x7] bytes 0 to 19\naddress _ethFundMain; // STORAGE[0x8] bytes 0 to 19\nuint8 _stopped; // STORAGE[0x7] bytes 20 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.sender != _owner;\n    if (v1) {\n        v0 = v2 = msg.value >= 0x470de4df820000;\n    }\n    if (v0) {\n        v0 = v3 = block.timestamp <= _icoEndDate;\n    }\n    if (v0) {\n        v0 = v4 = _stopped == 0;\n    }\n    require(v0);\n    assert(10 ** _decimals);\n    _tokens = msg.value / 10 ** _decimals * _oneEth;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _tokens;\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokens;\n    emit Transfer(_owner, msg.sender, _tokens);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _tokens = varg1 * 10 ** _decimals;\n    _allowance[varg0] = _tokens;\n    emit Approval(msg.sender, varg0, _tokens);\n    return 1;\n}\n\nfunction oneEth() public nonPayable { \n    return _oneEth;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    _tokens = varg2 * 10 ** _decimals;\n    v0 = v1 = _balanceOf[varg0] >= _tokens;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= _tokens;\n    }\n    if (v0) {\n        v0 = v3 = _tokens >= 0;\n    }\n    require(v0);\n    _balanceOf[varg0] = _balanceOf[varg0] - _tokens;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - _tokens;\n    _balanceOf[varg1] = _balanceOf[varg1] + _tokens;\n    emit Transfer(varg0, varg1, _tokens);\n    return 1;\n}\n\nfunction icoEndDate() public nonPayable { \n    return _icoEndDate;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction ethFundMain() public nonPayable { \n    return _ethFundMain;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction stopped() public nonPayable { \n    return _stopped;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction drain() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _ethFundMain.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction tokens() public nonPayable { \n    return _tokens;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != _owner);\n    _tokens = varg1 * 10 ** _decimals;\n    _balanceOf[varg0] = _balanceOf[varg0] + _tokens;\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokens;\n    emit Transfer(_owner, varg0, _tokens);\n    return 0;\n}\n\nfunction ResumeICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stopped = 0;\n}\n\nfunction PauseICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stopped = 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    v0 = v1 = varg0 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != 0;\n    }\n    require(v0);\n    return _allowance[varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x9a8d3f5 == function_selector) {\n            oneEth();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2a62738b == function_selector) {\n            icoEndDate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x6bf82d74 == function_selector) {\n            ethFundMain();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75f12b21 == function_selector) {\n            stopped();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9890220b == function_selector) {\n            drain();\n        } else if (0x9d63848a == function_selector) {\n            tokens();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd7a2c3b == function_selector) {\n            ResumeICO();\n        } else if (0xcf5ae516 == function_selector) {\n            PauseICO();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 00:05 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 __totalSupply; // STORAGE[0x3]\nuint256 _tokens; // STORAGE[0x4]\nuint256 _oneEth; // STORAGE[0x5]\nuint256 _icoEndDate; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\naddress _owner; // STORAGE[0x7] bytes 0 to 19\naddress _ethFundMain; // STORAGE[0x8] bytes 0 to 19\nuint8 _stopped; // STORAGE[0x7] bytes 20 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.sender != _owner;\n    if (v1) {\n        v0 = v2 = msg.value >= 0x470de4df820000;\n    }\n    if (v0) {\n        v0 = v3 = block.timestamp <= _icoEndDate;\n    }\n    if (v0) {\n        v0 = v4 = _stopped == 0;\n    }\n    require(v0);\n    assert(10 ** _decimals);\n    _tokens = msg.value / 10 ** _decimals * _oneEth;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _tokens;\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokens;\n    emit Transfer(_owner, msg.sender, _tokens);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _tokens = varg1 * 10 ** _decimals;\n    _allowance[varg0] = _tokens;\n    emit Approval(msg.sender, varg0, _tokens);\n    return 1;\n}\n\nfunction oneEth() public nonPayable { \n    return _oneEth;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    _tokens = varg2 * 10 ** _decimals;\n    v0 = v1 = _balanceOf[varg0] >= _tokens;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= _tokens;\n    }\n    if (v0) {\n        v0 = v3 = _tokens >= 0;\n    }\n    require(v0);\n    _balanceOf[varg0] = _balanceOf[varg0] - _tokens;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - _tokens;\n    _balanceOf[varg1] = _balanceOf[varg1] + _tokens;\n    emit Transfer(varg0, varg1, _tokens);\n    return 1;\n}\n\nfunction icoEndDate() public nonPayable { \n    return _icoEndDate;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction ethFundMain() public nonPayable { \n    return _ethFundMain;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction stopped() public nonPayable { \n    return _stopped;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction drain() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _ethFundMain.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction tokens() public nonPayable { \n    return _tokens;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != _owner);\n    _tokens = varg1 * 10 ** _decimals;\n    _balanceOf[varg0] = _balanceOf[varg0] + _tokens;\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokens;\n    emit Transfer(_owner, varg0, _tokens);\n    return 0;\n}\n\nfunction ResumeICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stopped = 0;\n}\n\nfunction PauseICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stopped = 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    v0 = v1 = varg0 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != 0;\n    }\n    require(v0);\n    return _allowance[varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x9a8d3f5 == function_selector) {\n            oneEth();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2a62738b == function_selector) {\n            icoEndDate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x6bf82d74 == function_selector) {\n            ethFundMain();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75f12b21 == function_selector) {\n            stopped();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9890220b == function_selector) {\n            drain();\n        } else if (0x9d63848a == function_selector) {\n            tokens();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd7a2c3b == function_selector) {\n            ResumeICO();\n        } else if (0xcf5ae516 == function_selector) {\n            PauseICO();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 34.48906373977661,
	"usage": {
		"completion_tokens": 644,
		"prompt_tokens": 2188,
		"total_tokens": 2832
	}
}