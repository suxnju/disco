{
	"address": "0x954730298304a0b4b4c885244695aed5e0a8a27a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled EVM Bytecode, the following Solidity contract can be inferred:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _minWithdraw;\n    uint256 private _maxWithdraw;\n    bool private _isPause;\n    mapping (address => bool) private _isController;\n    string private _name;\n    address private _escrow;\n    address private _namiMultiSigWallet;\n\n    event Deposit(address indexed sender, uint256 amount, uint256 time);\n    event Withdraw(address indexed receiver, uint256 amount, uint256 time);\n\n    modifier onlyEscrow() {\n        require(msg.sender == _escrow, \"Only escrow can call this function.\");\n        _;\n    }\n\n    modifier onlyNamiMultiSigWallet() {\n        require(msg.sender == _namiMultiSigWallet, \"Only Nami MultiSig Wallet can call this function.\");\n        _;\n    }\n\n    function namiMultiSigWallet() public view returns(address) {\n        return _namiMultiSigWallet;\n    }\n\n    function name() public view returns(string memory) {\n        return _name;\n    }\n\n    function withdrawNac(uint256 amount) public onlyEscrow {\n        require(_isPause, \"Withdrawal is paused.\");\n        // assuming that _isPause is a token contract with balanceOf and transfer functions\n        uint256 balance = _isPause.balanceOf(address(this));\n        require(balance >= amount, \"Insufficient balance.\");\n        _isPause.transfer(_namiMultiSigWallet, amount);\n    }\n\n    function changeMaxWithdraw(uint256 amount) public onlyEscrow {\n        _maxWithdraw = amount;\n    }\n\n    function NamiAddr() public view returns(address) {\n        return address(_isPause);\n    }\n\n    function setController(address controller) public onlyEscrow {\n        _isController[controller] = true;\n    }\n\n    function withdrawToken(address to, uint256 amount) public {\n        require(_isController[msg.sender], \"Only controller can call this function.\");\n        require(amount >= _minWithdraw && amount <= _maxWithdraw, \"Amount is out of range.\");\n        (bool success,) = to.call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n        emit Withdraw(to, amount, block.timestamp);\n    }\n\n    function maxWithdraw() public view returns(uint256) {\n        return _maxWithdraw;\n    }\n\n    function isController(address controller) public view returns(bool) {\n        return _isController[controller];\n    }\n\n    function changePause() public onlyEscrow {\n        _isPause = !_isPause;\n    }\n\n    function minWithdraw() public view returns(uint256) {\n        return _minWithdraw;\n    }\n\n    function changeMinWithdraw(uint256 amount) public onlyEscrow {\n        _minWithdraw = amount;\n    }\n\n    function withdrawEther(uint256 amount, address to) public onlyEscrow {\n        (bool success,) = to.call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function changeEscrow(address newEscrow) public onlyNamiMultiSigWallet {\n        _escrow = newEscrow;\n    }\n\n    function escrow() public view returns(address) {\n        return _escrow;\n    }\n\n    function removeController(address controller) public onlyEscrow {\n        _isController[controller] = false;\n    }\n\n    function isPause() public view returns(bool) {\n        return _isPause;\n    }\n\n    receive() external payable {\n        require(msg.value > 0, \"No ether sent.\");\n        emit Deposit(msg.sender, msg.value, block.timestamp);\n    }\n}\n```\n\nPlease note that this contract is simplified and doesn't include all the details from the decompiled code. Since the decompiled code doesn't specify some contract interactions, assumptions were made. For example, it's assumed that `_isPause` is a token contract with `balanceOf` and `transfer` functions. Make sure to adjust it according to your needs and thoroughly test it before any use.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459211,
	"id": "chatcmpl-8R3YRUqxO4ZYhakp68MQERYDDlCaw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 15:25 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minWithdraw; // STORAGE[0x1]\nuint256 _maxWithdraw; // STORAGE[0x2]\nuint256 _isPause; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _isController; // STORAGE[0x5]\nuint256[] _name; // STORAGE[0x6]\naddress _escrow; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress _namiMultiSigWallet; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nDeposit(address, uint256, uint256);\nWithdraw(address, uint256, uint256);\n\nfunction namiMultiSigWallet() public nonPayable { \n    return _namiMultiSigWallet;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction withdrawNac(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(stor_3_0_0);\n    require((address(_isPause)).code.size);\n    v0, v1 = address(_isPause).balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v1 > 0) {\n        require((address(_isPause)).code.size);\n        v2 = address(_isPause).transfer(_namiMultiSigWallet, varg0).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n    }\n}\n\nfunction changeMaxWithdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg0);\n    _maxWithdraw = varg0;\n}\n\nfunction NamiAddr() public nonPayable { \n    return address(_isPause);\n}\n\nfunction setController(address varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(!(0xff & _isController[varg0]));\n    _isController[varg0] = 0x1 | ~0xff & _isController[varg0];\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(1 == 0xff & _isController[msg.sender]);\n    v0 = v1 = varg0;\n    if (varg0) {\n        v0 = v2 = varg1;\n    }\n    require(v0);\n    v3 = v4 = varg1 >= _minWithdraw;\n    if (v4) {\n        v3 = v5 = varg1 <= _maxWithdraw;\n    }\n    require(v3);\n    if (this.balance > 0) {\n        v6 = varg0.call().value(varg1).gas(2300 * !varg1);\n        require(v6); // checks call status, propagates error data on error\n    }\n    emit Withdraw(varg0, varg1, block.timestamp);\n}\n\nfunction maxWithdraw() public nonPayable { \n    return _maxWithdraw;\n}\n\nfunction isController(address varg0) public nonPayable { \n    return 0xff & _isController[varg0];\n}\n\nfunction changePause() public nonPayable { \n    require(msg.sender == _escrow);\n    _isPause = !(0xff & _isPause >> 160) << 160 | _isPause & ~0xff0000000000000000000000000000000000000000;\n}\n\nfunction minWithdraw() public nonPayable { \n    return _minWithdraw;\n}\n\nfunction changeMinWithdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg0);\n    _minWithdraw = varg0;\n}\n\nfunction withdrawEther(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg1);\n    if (this.balance > 0) {\n        v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n        require(v0); // checks call status, propagates error data on error\n        goto 0x1030x2e8;\n    }\n}\n\nfunction changeEscrow(address varg0) public nonPayable { \n    require(msg.sender == _namiMultiSigWallet);\n    require(varg0);\n    _escrow = varg0;\n}\n\nfunction escrow() public nonPayable { \n    return _escrow;\n}\n\nfunction removeController(address varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(0xff & _isController[varg0]);\n    _isController[varg0] = ~0xff & _isController[varg0];\n}\n\nfunction isPause() public nonPayable { \n    return 0xff & _isPause >> 160;\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0);\n    emit Deposit(msg.sender, msg.value, block.timestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x321f836) {\n            namiMultiSigWallet();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x12818f0c == function_selector) {\n            withdrawNac(uint256);\n        } else if (0x26e5ab38 == function_selector) {\n            changeMaxWithdraw(uint256);\n        } else if (0x439370b1 != function_selector) {\n            if (0x86e1e589 == function_selector) {\n                NamiAddr();\n            } else if (0x92eefe9b == function_selector) {\n                setController(address);\n            } else if (0x9e281a98 == function_selector) {\n                withdrawToken(address,uint256);\n            } else if (0xac7a1b5b == function_selector) {\n                maxWithdraw();\n            } else if (0xb429afeb == function_selector) {\n                isController(address);\n            } else if (0xc3defb70 == function_selector) {\n                changePause();\n            } else if (0xcc3d2721 == function_selector) {\n                minWithdraw();\n            } else if (0xcc61d0cb == function_selector) {\n                changeMinWithdraw(uint256);\n            } else if (0xce56c454 == function_selector) {\n                withdrawEther(uint256,address);\n            } else if (0xdcfcda2b == function_selector) {\n                changeEscrow(address);\n            } else if (0xe2fdcc17 == function_selector) {\n                escrow();\n            } else if (0xf6a74ed7 == function_selector) {\n                removeController(address);\n            } else if (0xff0938a7 == function_selector) {\n                isPause();\n            }\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 15:25 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minWithdraw; // STORAGE[0x1]\nuint256 _maxWithdraw; // STORAGE[0x2]\nuint256 _isPause; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _isController; // STORAGE[0x5]\nuint256[] _name; // STORAGE[0x6]\naddress _escrow; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress _namiMultiSigWallet; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nDeposit(address, uint256, uint256);\nWithdraw(address, uint256, uint256);\n\nfunction namiMultiSigWallet() public nonPayable { \n    return _namiMultiSigWallet;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction withdrawNac(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(stor_3_0_0);\n    require((address(_isPause)).code.size);\n    v0, v1 = address(_isPause).balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v1 > 0) {\n        require((address(_isPause)).code.size);\n        v2 = address(_isPause).transfer(_namiMultiSigWallet, varg0).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n    }\n}\n\nfunction changeMaxWithdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg0);\n    _maxWithdraw = varg0;\n}\n\nfunction NamiAddr() public nonPayable { \n    return address(_isPause);\n}\n\nfunction setController(address varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(!(0xff & _isController[varg0]));\n    _isController[varg0] = 0x1 | ~0xff & _isController[varg0];\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(1 == 0xff & _isController[msg.sender]);\n    v0 = v1 = varg0;\n    if (varg0) {\n        v0 = v2 = varg1;\n    }\n    require(v0);\n    v3 = v4 = varg1 >= _minWithdraw;\n    if (v4) {\n        v3 = v5 = varg1 <= _maxWithdraw;\n    }\n    require(v3);\n    if (this.balance > 0) {\n        v6 = varg0.call().value(varg1).gas(2300 * !varg1);\n        require(v6); // checks call status, propagates error data on error\n    }\n    emit Withdraw(varg0, varg1, block.timestamp);\n}\n\nfunction maxWithdraw() public nonPayable { \n    return _maxWithdraw;\n}\n\nfunction isController(address varg0) public nonPayable { \n    return 0xff & _isController[varg0];\n}\n\nfunction changePause() public nonPayable { \n    require(msg.sender == _escrow);\n    _isPause = !(0xff & _isPause >> 160) << 160 | _isPause & ~0xff0000000000000000000000000000000000000000;\n}\n\nfunction minWithdraw() public nonPayable { \n    return _minWithdraw;\n}\n\nfunction changeMinWithdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg0);\n    _minWithdraw = varg0;\n}\n\nfunction withdrawEther(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg1);\n    if (this.balance > 0) {\n        v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n        require(v0); // checks call status, propagates error data on error\n        goto 0x1030x2e8;\n    }\n}\n\nfunction changeEscrow(address varg0) public nonPayable { \n    require(msg.sender == _namiMultiSigWallet);\n    require(varg0);\n    _escrow = varg0;\n}\n\nfunction escrow() public nonPayable { \n    return _escrow;\n}\n\nfunction removeController(address varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(0xff & _isController[varg0]);\n    _isController[varg0] = ~0xff & _isController[varg0];\n}\n\nfunction isPause() public nonPayable { \n    return 0xff & _isPause >> 160;\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0);\n    emit Deposit(msg.sender, msg.value, block.timestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x321f836) {\n            namiMultiSigWallet();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x12818f0c == function_selector) {\n            withdrawNac(uint256);\n        } else if (0x26e5ab38 == function_selector) {\n            changeMaxWithdraw(uint256);\n        } else if (0x439370b1 != function_selector) {\n            if (0x86e1e589 == function_selector) {\n                NamiAddr();\n            } else if (0x92eefe9b == function_selector) {\n                setController(address);\n            } else if (0x9e281a98 == function_selector) {\n                withdrawToken(address,uint256);\n            } else if (0xac7a1b5b == function_selector) {\n                maxWithdraw();\n            } else if (0xb429afeb == function_selector) {\n                isController(address);\n            } else if (0xc3defb70 == function_selector) {\n                changePause();\n            } else if (0xcc3d2721 == function_selector) {\n                minWithdraw();\n            } else if (0xcc61d0cb == function_selector) {\n                changeMinWithdraw(uint256);\n            } else if (0xce56c454 == function_selector) {\n                withdrawEther(uint256,address);\n            } else if (0xdcfcda2b == function_selector) {\n                changeEscrow(address);\n            } else if (0xe2fdcc17 == function_selector) {\n                escrow();\n            } else if (0xf6a74ed7 == function_selector) {\n                removeController(address);\n            } else if (0xff0938a7 == function_selector) {\n                isPause();\n            }\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 15:25 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minWithdraw; // STORAGE[0x1]\nuint256 _maxWithdraw; // STORAGE[0x2]\nuint256 _isPause; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _isController; // STORAGE[0x5]\nuint256[] _name; // STORAGE[0x6]\naddress _escrow; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress _namiMultiSigWallet; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nDeposit(address, uint256, uint256);\nWithdraw(address, uint256, uint256);\n\nfunction namiMultiSigWallet() public nonPayable { \n    return _namiMultiSigWallet;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction withdrawNac(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(stor_3_0_0);\n    require((address(_isPause)).code.size);\n    v0, v1 = address(_isPause).balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v1 > 0) {\n        require((address(_isPause)).code.size);\n        v2 = address(_isPause).transfer(_namiMultiSigWallet, varg0).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n    }\n}\n\nfunction changeMaxWithdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg0);\n    _maxWithdraw = varg0;\n}\n\nfunction NamiAddr() public nonPayable { \n    return address(_isPause);\n}\n\nfunction setController(address varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(!(0xff & _isController[varg0]));\n    _isController[varg0] = 0x1 | ~0xff & _isController[varg0];\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(1 == 0xff & _isController[msg.sender]);\n    v0 = v1 = varg0;\n    if (varg0) {\n        v0 = v2 = varg1;\n    }\n    require(v0);\n    v3 = v4 = varg1 >= _minWithdraw;\n    if (v4) {\n        v3 = v5 = varg1 <= _maxWithdraw;\n    }\n    require(v3);\n    if (this.balance > 0) {\n        v6 = varg0.call().value(varg1).gas(2300 * !varg1);\n        require(v6); // checks call status, propagates error data on error\n    }\n    emit Withdraw(varg0, varg1, block.timestamp);\n}\n\nfunction maxWithdraw() public nonPayable { \n    return _maxWithdraw;\n}\n\nfunction isController(address varg0) public nonPayable { \n    return 0xff & _isController[varg0];\n}\n\nfunction changePause() public nonPayable { \n    require(msg.sender == _escrow);\n    _isPause = !(0xff & _isPause >> 160) << 160 | _isPause & ~0xff0000000000000000000000000000000000000000;\n}\n\nfunction minWithdraw() public nonPayable { \n    return _minWithdraw;\n}\n\nfunction changeMinWithdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg0);\n    _minWithdraw = varg0;\n}\n\nfunction withdrawEther(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _escrow);\n    require(varg1);\n    if (this.balance > 0) {\n        v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n        require(v0); // checks call status, propagates error data on error\n        goto 0x1030x2e8;\n    }\n}\n\nfunction changeEscrow(address varg0) public nonPayable { \n    require(msg.sender == _namiMultiSigWallet);\n    require(varg0);\n    _escrow = varg0;\n}\n\nfunction escrow() public nonPayable { \n    return _escrow;\n}\n\nfunction removeController(address varg0) public nonPayable { \n    require(msg.sender == _escrow);\n    require(0xff & _isController[varg0]);\n    _isController[varg0] = ~0xff & _isController[varg0];\n}\n\nfunction isPause() public nonPayable { \n    return 0xff & _isPause >> 160;\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0);\n    emit Deposit(msg.sender, msg.value, block.timestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x321f836) {\n            namiMultiSigWallet();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x12818f0c == function_selector) {\n            withdrawNac(uint256);\n        } else if (0x26e5ab38 == function_selector) {\n            changeMaxWithdraw(uint256);\n        } else if (0x439370b1 != function_selector) {\n            if (0x86e1e589 == function_selector) {\n                NamiAddr();\n            } else if (0x92eefe9b == function_selector) {\n                setController(address);\n            } else if (0x9e281a98 == function_selector) {\n                withdrawToken(address,uint256);\n            } else if (0xac7a1b5b == function_selector) {\n                maxWithdraw();\n            } else if (0xb429afeb == function_selector) {\n                isController(address);\n            } else if (0xc3defb70 == function_selector) {\n                changePause();\n            } else if (0xcc3d2721 == function_selector) {\n                minWithdraw();\n            } else if (0xcc61d0cb == function_selector) {\n                changeMinWithdraw(uint256);\n            } else if (0xce56c454 == function_selector) {\n                withdrawEther(uint256,address);\n            } else if (0xdcfcda2b == function_selector) {\n                changeEscrow(address);\n            } else if (0xe2fdcc17 == function_selector) {\n                escrow();\n            } else if (0xf6a74ed7 == function_selector) {\n                removeController(address);\n            } else if (0xff0938a7 == function_selector) {\n                isPause();\n            }\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 52.71849179267883,
	"usage": {
		"completion_tokens": 825,
		"prompt_tokens": 1973,
		"total_tokens": 2798
	}
}