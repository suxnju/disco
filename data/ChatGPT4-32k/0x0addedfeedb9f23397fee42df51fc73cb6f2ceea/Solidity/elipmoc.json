{
	"address": "0x0addedfeedb9f23397fee42df51fc73cb6f2ceea",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code seems to be for a contract that includes a custom token with some unique features such as price adjustment, burning tokens, and interfacing with an oracle. Here is the Solidity code for a similar contract:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    address private _owner;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _name = \"MyToken\";\n        _symbol = \"MTK\";\n        _decimals = 18;\n        _owner = msg.sender;\n        _totalSupply = 10000 * (10 ** uint256(_decimals));\n        _balances[_owner] = _totalSupply;\n        emit Transfer(address(0), _owner, _totalSupply);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function burn(uint256 amount) public {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(newOwner != address(0));\n        require(msg.sender == _owner);\n        _owner = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n}\n```\n\nThis code represents a basic ERC20 token with added functionalities like `burn` and `transferOwnership`. Please note that some features from your decompiled code, such as price adjustment and oracle interaction, are not included in this contract. They would require additional coding and possibly integration with external systems or contracts.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461145,
	"id": "chatcmpl-8R43dIsboDTyiA0WBjdVW3okT5Fa5",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 23:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _getEther; // STORAGE[0x6]\nuint256 _getNextPriceAdjustmentTime; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _getPoolBalances; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress stor_a_0_19; // STORAGE[0xa] bytes 0 to 19\n\n// Events\ngotPEG(address, uint256, uint256);\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nBurn(address, uint256);\nOwnershipTransferred(address, address);\ngotEther(address, uint256, uint256);\nFailedAdjustment();\nInflate(uint256, uint256);\nDeflate(uint256, uint256);\nNoAdjustment();\n\nfunction 0x1171() private { \n    require(stor_a_0_19.code.size);\n    v0, v1 = stor_a_0_19.peek().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    return MEM[32 + MEM[64]], v1;\n}\n\nfunction fallback() public payable { \n    v0, v1 = 0x9d9();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction 0x2105() private { \n    v0, v1 = 0x1171();\n    if (v0) {\n        v2 = _SafeMul((address(this)).balance, v1);\n        v3 = _SafeDiv(10 ** _decimals, v2);\n        if (v3 <= _getPoolBalances[address(this)] / 100 * 101) {\n            if (v3 >= _getPoolBalances[address(this)] / 100 * 99) {\n                v4 = v5 = _getPoolBalances[address(this)];\n                emit NoAdjustment();\n            } else {\n                require(v3 <= _getPoolBalances[address(this)]);\n                v6 = _SafeDiv(10, _getPoolBalances[address(this)] - v3);\n                require(v6 <= _getPoolBalances[address(this)]);\n                v4 = _getPoolBalances[address(this)] - v6;\n                emit Deflate(_getPoolBalances[address(this)], v6);\n                emit Transfer(address(this), 0, v6);\n                _getPoolBalances[address(this)] = v4;\n                require(v6 <= _totalSupply);\n                _totalSupply = _totalSupply - v6;\n            }\n        } else {\n            require(_getPoolBalances[address(this)] <= v3);\n            v7 = _SafeDiv(10, v3 - _getPoolBalances[address(this)]);\n            v4 = v8 = _getPoolBalances[address(this)] + v7;\n            require(v8 >= _getPoolBalances[address(this)]);\n            emit Inflate(_getPoolBalances[address(this)], v7);\n            emit Transfer(0, address(this), v7);\n            _getPoolBalances[address(this)] = v8;\n            require(_totalSupply + v7 >= _totalSupply);\n            _totalSupply = _totalSupply + v7;\n        }\n        _getEther = block.timestamp;\n    } else {\n        v4 = v9 = _getPoolBalances[address(this)];\n        _getEther = block.timestamp;\n        emit FailedAdjustment();\n    }\n    return v4;\n}\n\nfunction getPEG() public payable { \n    v0, v1 = 0x9d9();\n    return v1, v0;\n}\n\nfunction dumpContractCode() public nonPayable { \n    EXTCODECOPY(this, MEM[64] + 32, 0, this.code.size);\n    v0 = new array[](this.code.size);\n    v1 = v2 = 0;\n    while (v1 < this.code.size) {\n        MEM[v0.data + v1] = MEM[32 + MEM[64] + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = this.code.size + v0.data;\n    if (0x1f & this.code.size) {\n        MEM[v4 - (0x1f & this.code.size)] = ~(256 ** (32 - (0x1f & this.code.size)) - 1) & MEM[v4 - (0x1f & this.code.size)];\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg1 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != address(this);\n    }\n    require(v0);\n    require(varg2 <= _getPoolBalances[varg0]);\n    _getPoolBalances[varg0] = _getPoolBalances[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _getPoolBalances[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction getOraclePriceETH_USD() public nonPayable { \n    v0, v1 = 0x1171();\n    return v1, v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction getNextPriceAdjustmentTime() public nonPayable { \n    if (block.timestamp < _getEther + _getNextPriceAdjustmentTime) {\n        v0 = v1 = _getEther + _getNextPriceAdjustmentTime - block.timestamp;\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _getPoolBalances[msg.sender]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] - (_getPoolBalances[msg.sender] - varg0);\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction getPoolBalances() public nonPayable { \n    return (address(this)).balance, _getPoolBalances[address(this)];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _getPoolBalances[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    if (varg0 != address(this)) {\n        require(varg1 <= _getPoolBalances[msg.sender]);\n        _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] - varg1;\n        require(_getPoolBalances[varg0] + varg1 >= _getPoolBalances[varg0]);\n        _getPoolBalances[varg0] = _getPoolBalances[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    } else {\n        require(_getPoolBalances[address(this)] + varg1 >= _getPoolBalances[address(this)]);\n        v0 = _SafeMul(0x5f5e100, varg1);\n        v1 = _SafeDiv(_getPoolBalances[address(this)] + varg1, v0);\n        v2 = _SafeMul(v1, (address(this)).balance);\n        v3 = _SafeDiv(0x5f5e100, v2);\n        require(_getPoolBalances[address(this)] + varg1 >= _getPoolBalances[address(this)]);\n        _getPoolBalances[address(this)] = _getPoolBalances[address(this)] + varg1;\n        require(varg1 <= _getPoolBalances[address(this)]);\n        _getPoolBalances[msg.sender] = _getPoolBalances[address(this)] - varg1;\n        emit gotEther(msg.sender, varg1, v3);\n        emit Transfer(msg.sender, address(this), varg1);\n        v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n        require(v4); // checks call status, propagates error data on error\n        if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n            v5 = 0x2105();\n        }\n    }\n    return 1;\n}\n\nfunction inflateEtherPool() public payable { \n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferAnyERC20Token(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner);\n    require(varg0 != address(this));\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction getEther(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getPoolBalances[address(this)] + varg0 >= _getPoolBalances[address(this)]);\n    v0 = _SafeMul(0x5f5e100, varg0);\n    v1 = _SafeDiv(_getPoolBalances[address(this)] + varg0, v0);\n    v2 = _SafeMul(v1, (address(this)).balance);\n    v3 = _SafeDiv(0x5f5e100, v2);\n    require(_getPoolBalances[address(this)] + varg0 >= _getPoolBalances[address(this)]);\n    _getPoolBalances[address(this)] = _getPoolBalances[address(this)] + varg0;\n    require(varg0 <= _getPoolBalances[address(this)]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[address(this)] - varg0;\n    emit gotEther(msg.sender, varg0, v3);\n    emit Transfer(msg.sender, address(this), varg0);\n    v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n    require(v4); // checks call status, propagates error data on error\n    if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n        v5 = 0x2105();\n    }\n    return 1, v3;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction 0x9d9() private { \n    v0 = _SafeMul(0x5f5e100, msg.value);\n    v1 = _SafeDiv((address(this)).balance, v0);\n    v2 = _SafeMul(v1, _getPoolBalances[address(this)]);\n    v3 = _SafeDiv(0x5f5e100, v2);\n    require(v3 <= _getPoolBalances[address(this)]);\n    _getPoolBalances[address(this)] = _getPoolBalances[address(this)] - v3;\n    require(_getPoolBalances[msg.sender] + v3 >= _getPoolBalances[msg.sender]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] + v3;\n    emit gotPEG(msg.sender, msg.value, v3);\n    emit Transfer(address(this), msg.sender, v3);\n    if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n        v4 = 0x2105();\n    }\n    return v3, 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x9c1a71a == function_selector >> 224) {\n                    getPEG();\n                } else if (0x15c19500 == function_selector >> 224) {\n                    dumpContractCode();\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x2d740f9e == function_selector >> 224) {\n                getOraclePriceETH_USD();\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x341776d9 == function_selector >> 224) {\n                getNextPriceAdjustmentTime();\n            } else if (0x42966c68 == function_selector >> 224) {\n                burn(uint256);\n            } else if (0x52375bb1 == function_selector >> 224) {\n                getPoolBalances();\n            }\n        } else if (0xcae9ca51 > function_selector >> 224) {\n            if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else if (0x79ba5097 == function_selector >> 224) {\n                acceptOwnership();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa9059cbb == function_selector >> 224) {\n                transfer(address,uint256);\n            } else if (0xc8c8bb2a == function_selector >> 224) {\n                inflateEtherPool();\n            }\n        } else if (0xcae9ca51 == function_selector >> 224) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd4ee1d90 == function_selector >> 224) {\n            newOwner();\n        } else if (0xdc39d06d == function_selector >> 224) {\n            transferAnyERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xf04961ba == function_selector >> 224) {\n            getEther(uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 23:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _getEther; // STORAGE[0x6]\nuint256 _getNextPriceAdjustmentTime; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _getPoolBalances; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress stor_a_0_19; // STORAGE[0xa] bytes 0 to 19\n\n// Events\ngotPEG(address, uint256, uint256);\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nBurn(address, uint256);\nOwnershipTransferred(address, address);\ngotEther(address, uint256, uint256);\nFailedAdjustment();\nInflate(uint256, uint256);\nDeflate(uint256, uint256);\nNoAdjustment();\n\nfunction 0x1171() private { \n    require(stor_a_0_19.code.size);\n    v0, v1 = stor_a_0_19.peek().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    return MEM[32 + MEM[64]], v1;\n}\n\nfunction fallback() public payable { \n    v0, v1 = 0x9d9();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction 0x2105() private { \n    v0, v1 = 0x1171();\n    if (v0) {\n        v2 = _SafeMul((address(this)).balance, v1);\n        v3 = _SafeDiv(10 ** _decimals, v2);\n        if (v3 <= _getPoolBalances[address(this)] / 100 * 101) {\n            if (v3 >= _getPoolBalances[address(this)] / 100 * 99) {\n                v4 = v5 = _getPoolBalances[address(this)];\n                emit NoAdjustment();\n            } else {\n                require(v3 <= _getPoolBalances[address(this)]);\n                v6 = _SafeDiv(10, _getPoolBalances[address(this)] - v3);\n                require(v6 <= _getPoolBalances[address(this)]);\n                v4 = _getPoolBalances[address(this)] - v6;\n                emit Deflate(_getPoolBalances[address(this)], v6);\n                emit Transfer(address(this), 0, v6);\n                _getPoolBalances[address(this)] = v4;\n                require(v6 <= _totalSupply);\n                _totalSupply = _totalSupply - v6;\n            }\n        } else {\n            require(_getPoolBalances[address(this)] <= v3);\n            v7 = _SafeDiv(10, v3 - _getPoolBalances[address(this)]);\n            v4 = v8 = _getPoolBalances[address(this)] + v7;\n            require(v8 >= _getPoolBalances[address(this)]);\n            emit Inflate(_getPoolBalances[address(this)], v7);\n            emit Transfer(0, address(this), v7);\n            _getPoolBalances[address(this)] = v8;\n            require(_totalSupply + v7 >= _totalSupply);\n            _totalSupply = _totalSupply + v7;\n        }\n        _getEther = block.timestamp;\n    } else {\n        v4 = v9 = _getPoolBalances[address(this)];\n        _getEther = block.timestamp;\n        emit FailedAdjustment();\n    }\n    return v4;\n}\n\nfunction getPEG() public payable { \n    v0, v1 = 0x9d9();\n    return v1, v0;\n}\n\nfunction dumpContractCode() public nonPayable { \n    EXTCODECOPY(this, MEM[64] + 32, 0, this.code.size);\n    v0 = new array[](this.code.size);\n    v1 = v2 = 0;\n    while (v1 < this.code.size) {\n        MEM[v0.data + v1] = MEM[32 + MEM[64] + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = this.code.size + v0.data;\n    if (0x1f & this.code.size) {\n        MEM[v4 - (0x1f & this.code.size)] = ~(256 ** (32 - (0x1f & this.code.size)) - 1) & MEM[v4 - (0x1f & this.code.size)];\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg1 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != address(this);\n    }\n    require(v0);\n    require(varg2 <= _getPoolBalances[varg0]);\n    _getPoolBalances[varg0] = _getPoolBalances[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _getPoolBalances[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction getOraclePriceETH_USD() public nonPayable { \n    v0, v1 = 0x1171();\n    return v1, v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction getNextPriceAdjustmentTime() public nonPayable { \n    if (block.timestamp < _getEther + _getNextPriceAdjustmentTime) {\n        v0 = v1 = _getEther + _getNextPriceAdjustmentTime - block.timestamp;\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _getPoolBalances[msg.sender]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] - (_getPoolBalances[msg.sender] - varg0);\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction getPoolBalances() public nonPayable { \n    return (address(this)).balance, _getPoolBalances[address(this)];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _getPoolBalances[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    if (varg0 != address(this)) {\n        require(varg1 <= _getPoolBalances[msg.sender]);\n        _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] - varg1;\n        require(_getPoolBalances[varg0] + varg1 >= _getPoolBalances[varg0]);\n        _getPoolBalances[varg0] = _getPoolBalances[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    } else {\n        require(_getPoolBalances[address(this)] + varg1 >= _getPoolBalances[address(this)]);\n        v0 = _SafeMul(0x5f5e100, varg1);\n        v1 = _SafeDiv(_getPoolBalances[address(this)] + varg1, v0);\n        v2 = _SafeMul(v1, (address(this)).balance);\n        v3 = _SafeDiv(0x5f5e100, v2);\n        require(_getPoolBalances[address(this)] + varg1 >= _getPoolBalances[address(this)]);\n        _getPoolBalances[address(this)] = _getPoolBalances[address(this)] + varg1;\n        require(varg1 <= _getPoolBalances[address(this)]);\n        _getPoolBalances[msg.sender] = _getPoolBalances[address(this)] - varg1;\n        emit gotEther(msg.sender, varg1, v3);\n        emit Transfer(msg.sender, address(this), varg1);\n        v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n        require(v4); // checks call status, propagates error data on error\n        if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n            v5 = 0x2105();\n        }\n    }\n    return 1;\n}\n\nfunction inflateEtherPool() public payable { \n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferAnyERC20Token(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner);\n    require(varg0 != address(this));\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction getEther(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getPoolBalances[address(this)] + varg0 >= _getPoolBalances[address(this)]);\n    v0 = _SafeMul(0x5f5e100, varg0);\n    v1 = _SafeDiv(_getPoolBalances[address(this)] + varg0, v0);\n    v2 = _SafeMul(v1, (address(this)).balance);\n    v3 = _SafeDiv(0x5f5e100, v2);\n    require(_getPoolBalances[address(this)] + varg0 >= _getPoolBalances[address(this)]);\n    _getPoolBalances[address(this)] = _getPoolBalances[address(this)] + varg0;\n    require(varg0 <= _getPoolBalances[address(this)]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[address(this)] - varg0;\n    emit gotEther(msg.sender, varg0, v3);\n    emit Transfer(msg.sender, address(this), varg0);\n    v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n    require(v4); // checks call status, propagates error data on error\n    if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n        v5 = 0x2105();\n    }\n    return 1, v3;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction 0x9d9() private { \n    v0 = _SafeMul(0x5f5e100, msg.value);\n    v1 = _SafeDiv((address(this)).balance, v0);\n    v2 = _SafeMul(v1, _getPoolBalances[address(this)]);\n    v3 = _SafeDiv(0x5f5e100, v2);\n    require(v3 <= _getPoolBalances[address(this)]);\n    _getPoolBalances[address(this)] = _getPoolBalances[address(this)] - v3;\n    require(_getPoolBalances[msg.sender] + v3 >= _getPoolBalances[msg.sender]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] + v3;\n    emit gotPEG(msg.sender, msg.value, v3);\n    emit Transfer(address(this), msg.sender, v3);\n    if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n        v4 = 0x2105();\n    }\n    return v3, 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x9c1a71a == function_selector >> 224) {\n                    getPEG();\n                } else if (0x15c19500 == function_selector >> 224) {\n                    dumpContractCode();\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x2d740f9e == function_selector >> 224) {\n                getOraclePriceETH_USD();\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x341776d9 == function_selector >> 224) {\n                getNextPriceAdjustmentTime();\n            } else if (0x42966c68 == function_selector >> 224) {\n                burn(uint256);\n            } else if (0x52375bb1 == function_selector >> 224) {\n                getPoolBalances();\n            }\n        } else if (0xcae9ca51 > function_selector >> 224) {\n            if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else if (0x79ba5097 == function_selector >> 224) {\n                acceptOwnership();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa9059cbb == function_selector >> 224) {\n                transfer(address,uint256);\n            } else if (0xc8c8bb2a == function_selector >> 224) {\n                inflateEtherPool();\n            }\n        } else if (0xcae9ca51 == function_selector >> 224) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd4ee1d90 == function_selector >> 224) {\n            newOwner();\n        } else if (0xdc39d06d == function_selector >> 224) {\n            transferAnyERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xf04961ba == function_selector >> 224) {\n            getEther(uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 23:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _getEther; // STORAGE[0x6]\nuint256 _getNextPriceAdjustmentTime; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _getPoolBalances; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress stor_a_0_19; // STORAGE[0xa] bytes 0 to 19\n\n// Events\ngotPEG(address, uint256, uint256);\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nBurn(address, uint256);\nOwnershipTransferred(address, address);\ngotEther(address, uint256, uint256);\nFailedAdjustment();\nInflate(uint256, uint256);\nDeflate(uint256, uint256);\nNoAdjustment();\n\nfunction 0x1171() private { \n    require(stor_a_0_19.code.size);\n    v0, v1 = stor_a_0_19.peek().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    return MEM[32 + MEM[64]], v1;\n}\n\nfunction fallback() public payable { \n    v0, v1 = 0x9d9();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction 0x2105() private { \n    v0, v1 = 0x1171();\n    if (v0) {\n        v2 = _SafeMul((address(this)).balance, v1);\n        v3 = _SafeDiv(10 ** _decimals, v2);\n        if (v3 <= _getPoolBalances[address(this)] / 100 * 101) {\n            if (v3 >= _getPoolBalances[address(this)] / 100 * 99) {\n                v4 = v5 = _getPoolBalances[address(this)];\n                emit NoAdjustment();\n            } else {\n                require(v3 <= _getPoolBalances[address(this)]);\n                v6 = _SafeDiv(10, _getPoolBalances[address(this)] - v3);\n                require(v6 <= _getPoolBalances[address(this)]);\n                v4 = _getPoolBalances[address(this)] - v6;\n                emit Deflate(_getPoolBalances[address(this)], v6);\n                emit Transfer(address(this), 0, v6);\n                _getPoolBalances[address(this)] = v4;\n                require(v6 <= _totalSupply);\n                _totalSupply = _totalSupply - v6;\n            }\n        } else {\n            require(_getPoolBalances[address(this)] <= v3);\n            v7 = _SafeDiv(10, v3 - _getPoolBalances[address(this)]);\n            v4 = v8 = _getPoolBalances[address(this)] + v7;\n            require(v8 >= _getPoolBalances[address(this)]);\n            emit Inflate(_getPoolBalances[address(this)], v7);\n            emit Transfer(0, address(this), v7);\n            _getPoolBalances[address(this)] = v8;\n            require(_totalSupply + v7 >= _totalSupply);\n            _totalSupply = _totalSupply + v7;\n        }\n        _getEther = block.timestamp;\n    } else {\n        v4 = v9 = _getPoolBalances[address(this)];\n        _getEther = block.timestamp;\n        emit FailedAdjustment();\n    }\n    return v4;\n}\n\nfunction getPEG() public payable { \n    v0, v1 = 0x9d9();\n    return v1, v0;\n}\n\nfunction dumpContractCode() public nonPayable { \n    EXTCODECOPY(this, MEM[64] + 32, 0, this.code.size);\n    v0 = new array[](this.code.size);\n    v1 = v2 = 0;\n    while (v1 < this.code.size) {\n        MEM[v0.data + v1] = MEM[32 + MEM[64] + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = this.code.size + v0.data;\n    if (0x1f & this.code.size) {\n        MEM[v4 - (0x1f & this.code.size)] = ~(256 ** (32 - (0x1f & this.code.size)) - 1) & MEM[v4 - (0x1f & this.code.size)];\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg1 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != address(this);\n    }\n    require(v0);\n    require(varg2 <= _getPoolBalances[varg0]);\n    _getPoolBalances[varg0] = _getPoolBalances[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _getPoolBalances[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction getOraclePriceETH_USD() public nonPayable { \n    v0, v1 = 0x1171();\n    return v1, v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction getNextPriceAdjustmentTime() public nonPayable { \n    if (block.timestamp < _getEther + _getNextPriceAdjustmentTime) {\n        v0 = v1 = _getEther + _getNextPriceAdjustmentTime - block.timestamp;\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _getPoolBalances[msg.sender]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] - (_getPoolBalances[msg.sender] - varg0);\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction getPoolBalances() public nonPayable { \n    return (address(this)).balance, _getPoolBalances[address(this)];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _getPoolBalances[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    if (varg0 != address(this)) {\n        require(varg1 <= _getPoolBalances[msg.sender]);\n        _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] - varg1;\n        require(_getPoolBalances[varg0] + varg1 >= _getPoolBalances[varg0]);\n        _getPoolBalances[varg0] = _getPoolBalances[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    } else {\n        require(_getPoolBalances[address(this)] + varg1 >= _getPoolBalances[address(this)]);\n        v0 = _SafeMul(0x5f5e100, varg1);\n        v1 = _SafeDiv(_getPoolBalances[address(this)] + varg1, v0);\n        v2 = _SafeMul(v1, (address(this)).balance);\n        v3 = _SafeDiv(0x5f5e100, v2);\n        require(_getPoolBalances[address(this)] + varg1 >= _getPoolBalances[address(this)]);\n        _getPoolBalances[address(this)] = _getPoolBalances[address(this)] + varg1;\n        require(varg1 <= _getPoolBalances[address(this)]);\n        _getPoolBalances[msg.sender] = _getPoolBalances[address(this)] - varg1;\n        emit gotEther(msg.sender, varg1, v3);\n        emit Transfer(msg.sender, address(this), varg1);\n        v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n        require(v4); // checks call status, propagates error data on error\n        if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n            v5 = 0x2105();\n        }\n    }\n    return 1;\n}\n\nfunction inflateEtherPool() public payable { \n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferAnyERC20Token(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner);\n    require(varg0 != address(this));\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction getEther(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getPoolBalances[address(this)] + varg0 >= _getPoolBalances[address(this)]);\n    v0 = _SafeMul(0x5f5e100, varg0);\n    v1 = _SafeDiv(_getPoolBalances[address(this)] + varg0, v0);\n    v2 = _SafeMul(v1, (address(this)).balance);\n    v3 = _SafeDiv(0x5f5e100, v2);\n    require(_getPoolBalances[address(this)] + varg0 >= _getPoolBalances[address(this)]);\n    _getPoolBalances[address(this)] = _getPoolBalances[address(this)] + varg0;\n    require(varg0 <= _getPoolBalances[address(this)]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[address(this)] - varg0;\n    emit gotEther(msg.sender, varg0, v3);\n    emit Transfer(msg.sender, address(this), varg0);\n    v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n    require(v4); // checks call status, propagates error data on error\n    if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n        v5 = 0x2105();\n    }\n    return 1, v3;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction 0x9d9() private { \n    v0 = _SafeMul(0x5f5e100, msg.value);\n    v1 = _SafeDiv((address(this)).balance, v0);\n    v2 = _SafeMul(v1, _getPoolBalances[address(this)]);\n    v3 = _SafeDiv(0x5f5e100, v2);\n    require(v3 <= _getPoolBalances[address(this)]);\n    _getPoolBalances[address(this)] = _getPoolBalances[address(this)] - v3;\n    require(_getPoolBalances[msg.sender] + v3 >= _getPoolBalances[msg.sender]);\n    _getPoolBalances[msg.sender] = _getPoolBalances[msg.sender] + v3;\n    emit gotPEG(msg.sender, msg.value, v3);\n    emit Transfer(address(this), msg.sender, v3);\n    if (block.timestamp >= _getEther + _getNextPriceAdjustmentTime) {\n        v4 = 0x2105();\n    }\n    return v3, 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x9c1a71a == function_selector >> 224) {\n                    getPEG();\n                } else if (0x15c19500 == function_selector >> 224) {\n                    dumpContractCode();\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x2d740f9e == function_selector >> 224) {\n                getOraclePriceETH_USD();\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x341776d9 == function_selector >> 224) {\n                getNextPriceAdjustmentTime();\n            } else if (0x42966c68 == function_selector >> 224) {\n                burn(uint256);\n            } else if (0x52375bb1 == function_selector >> 224) {\n                getPoolBalances();\n            }\n        } else if (0xcae9ca51 > function_selector >> 224) {\n            if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else if (0x79ba5097 == function_selector >> 224) {\n                acceptOwnership();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa9059cbb == function_selector >> 224) {\n                transfer(address,uint256);\n            } else if (0xc8c8bb2a == function_selector >> 224) {\n                inflateEtherPool();\n            }\n        } else if (0xcae9ca51 == function_selector >> 224) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd4ee1d90 == function_selector >> 224) {\n            newOwner();\n        } else if (0xdc39d06d == function_selector >> 224) {\n            transferAnyERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xf04961ba == function_selector >> 224) {\n            getEther(uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 53.390055894851685,
	"usage": {
		"completion_tokens": 929,
		"prompt_tokens": 4787,
		"total_tokens": 5716
	}
}