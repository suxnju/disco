{
	"address": "0x1c381ca8112f823941c37cb9514819909ecb102d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is a simplified version in Solidity. Note that due to the decompiled nature of the code, some behaviors may not be preserved perfectly:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    address private _owner;\n    uint256 private _startICO;\n    uint256 private _startPreICO;\n    uint256 private _period;\n    uint256 private _collectedCent;\n    uint256 private stor_8;\n    uint256 private _soldTokens;\n    uint256 private _priceUSD;\n    address private _token;\n    address private stor_b_0_19;\n    address private _oracle;\n\n    event StateChanged(uint8 indexed from, uint8 indexed to);\n\n    function rateCent() public pure returns (uint256) { \n        return 0x71afd498d0000;\n    }\n\n    function setPriceUSD(uint256 varg0) public { \n        require(msg.sender == _oracle || msg.sender == _owner);\n        _priceUSD = varg0;\n    }\n\n    // ... other methods ...\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        _owner = newOwner;\n    }\n\n    function token() public view returns (address) {\n        return _token;\n    }\n\n    // ... other methods ...\n}\n```\n\nPlease note that above code is a simplified version and doesn't contain all the methods. It's also worth noting that use of low level `call` function, bitwise operations and direct manipulation of storage in the decompiled code suggests that the original contract was written in a lower level language such as Vyper or was manually optimized for gas efficiency. Therefore, the solidity version might have a different gas cost. \n\nAlso, due to the anonymous functions and hexadecimal values in the decompiled code, some behaviors might not be preserved correctly. Please make sure to thoroughly test this contract before using it.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468110,
	"id": "chatcmpl-8R5rykdwxxbB6Y3DIo8lcDxDmsMEA",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 04:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_2; // STORAGE[0x2]\nuint256 _startICO; // STORAGE[0x4]\nuint256 _startPreICO; // STORAGE[0x5]\nuint256 _period; // STORAGE[0x6]\nuint256 _collectedCent; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 _soldTokens; // STORAGE[0x9]\nuint256 _priceUSD; // STORAGE[0xa]\naddress _token; // STORAGE[0x3] bytes 0 to 19\naddress stor_b_0_19; // STORAGE[0xb] bytes 0 to 19\naddress _oracle; // STORAGE[0xc] bytes 0 to 19\n\n// Events\nStateChanged(uint8, uint8);\n\nfunction fallback() public payable { \n    0x5dc();\n}\n\nfunction rateCent() public nonPayable { \n    return 0x71afd498d0000;\n}\n\nfunction setPriceUSD(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _oracle;\n    if (msg.sender != _oracle) {\n        v0 = v2 = msg.sender == address(_owner);\n    }\n    require(v0);\n    _priceUSD = varg0;\n}\n\nfunction 0x1b30() private { \n    v0 = v1 = 0;\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        if (0xff & _owner >> 168 == 4) {\n            v0 = v2 = 0x1461b91395a4f3a800000;\n        }\n    } else {\n        v0 = v3 = 0x5d2c72a2ac16a3000000;\n    }\n    return v0;\n}\n\nfunction ICOTokenHardCap() public nonPayable { \n    return 0x1461b91395a4f3a800000;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x1c1e(uint256 varg0) private { \n    assert(varg0 <= 7);\n    _owner = varg0 << 168 | ~0xff000000000000000000000000000000000000000000 & _owner;\n    assert(0xff & _owner >> 168 <= 7);\n    assert(varg0 <= 7);\n    v0 = 0xff & varg0;\n    emit StateChanged(0xff & (0xff & _owner >> 168), v0);\n    return ;\n}\n\nfunction finishPreIco() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 1);\n    0x1c1e(3);\n    v0 = stor_b_0_19.call().value((address(this)).balance).gas(0x2dc6c0);\n    require(v0);\n}\n\nfunction pausePreSale() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 1);\n    0x1c1e(2);\n}\n\nfunction changeOracle(address varg0) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 != 0);\n    _oracle = varg0;\n}\n\nfunction pauseSale() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 4);\n    0x1c1e(5);\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction startCompanySell() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 6);\n    0x1c1e(7);\n}\n\nfunction finishMinting() public nonPayable { \n    require(msg.sender == address(_owner));\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.finishMinting().gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction oracle() public nonPayable { \n    return _oracle;\n}\n\nfunction startICO() public nonPayable { \n    return _startICO;\n}\n\nfunction owner() public nonPayable { \n    return address(_owner);\n}\n\nfunction preICOTokenHardCap() public nonPayable { \n    return 0x5d2c72a2ac16a3000000;\n}\n\nfunction priceUSD() public nonPayable { \n    return _priceUSD;\n}\n\nfunction startIco(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 > 0);\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 1;\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 5;\n    }\n    if (!v0) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = 0xff & _owner >> 168 == 3;\n    }\n    require(v0);\n    _priceUSD = varg1;\n    _startICO = block.timestamp;\n    _period = varg0 * stor_8;\n    0x1c1e(4);\n}\n\nfunction getDouble() public nonPayable { \n    require(!(0xff & _owner >> 160));\n    _owner = 0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 4;\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 7;\n    }\n    require(v0);\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        if (0xff & _owner >> 168 == 7) {\n            owner_2[msg.sender] = 0;\n            owner_2[msg.sender] = 0;\n            MEM[32 + MEM[64]] = 0;\n            require(_token.code.size);\n            v3, v4 = _token.mint(msg.sender, owner_2[msg.sender] + owner_2[msg.sender]).gas(msg.gas - 710);\n            require(v3);\n        }\n    } else {\n        owner_1[msg.sender] = 0;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v5, v6 = _token.mint(msg.sender, owner_1[msg.sender]).gas(msg.gas - 710);\n        require(v5);\n        owner_2[msg.sender] = owner_2[msg.sender] + owner_1[msg.sender];\n    }\n    _owner = 0x0 | ~0xff0000000000000000000000000000000000000000 & _owner;\n}\n\nfunction collectedCent() public nonPayable { \n    return _collectedCent;\n}\n\nfunction usdSale(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    v0 = _SafeMul(varg1 * 100, 0x71afd498d0000);\n    _collectedCent = _collectedCent + varg1 * 100;\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v1, v2 = _token.mint(varg0, v0).gas(msg.gas - 710);\n    require(v1);\n    assert(0xff & _owner >> 168 <= 7);\n    v3 = v4 = 0xff & _owner >> 168 == 4;\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        v3 = v5 = 0xff & _owner >> 168 == 3;\n    }\n    if (!v3) {\n        owner_1[varg0] = owner_1[varg0] + v0;\n    } else {\n        owner_2[varg0] = owner_2[varg0] + v0;\n    }\n    _soldTokens = _soldTokens + v0;\n}\n\nfunction startPreICO() public nonPayable { \n    return _startPreICO;\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _owner >> 168 <= 7);\n    return 0xff & (0xff & _owner >> 168);\n}\n\nfunction finishICO() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 4);\n    0x1c1e(6);\n    v0 = stor_b_0_19.call().value((address(this)).balance).gas(0x2dc6c0);\n    require(v0);\n}\n\nfunction startPreIco(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 > 0);\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 0;\n    if (0xff & _owner >> 168 != 0) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = 0xff & _owner >> 168 == 2;\n    }\n    require(v0);\n    _priceUSD = varg1;\n    _startPreICO = block.timestamp;\n    _period = varg0 * stor_8;\n    0x1c1e(1);\n}\n\nfunction mintTokens() public payable { \n    0x5dc();\n}\n\nfunction period() public nonPayable { \n    return _period;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 != 0);\n    _owner = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owner;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x5dc() private { \n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 1;\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 4;\n    }\n    if (v0) {\n        v0 = v3 = block.timestamp < _startICO + _period;\n        if (block.timestamp >= _startICO + _period) {\n            v0 = v4 = block.timestamp < _startPreICO + _period;\n        }\n    }\n    require(v0);\n    v5 = 0x1b30();\n    require(_soldTokens < v5);\n    require(!(0xff & _owner >> 160));\n    _owner = 0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    assert(_priceUSD);\n    v6 = v7 = msg.value / _priceUSD;\n    v8 = v9 = _SafeMul(v7, 0x71afd498d0000);\n    v10 = 0x1b30();\n    if (_soldTokens + v9 > v10) {\n        assert(_soldTokens <= v10);\n        v8 = v11 = v10 - _soldTokens;\n        assert(0x71afd498d0000);\n        v6 = v11 / 0x71afd498d0000;\n        v12 = _SafeMul(_priceUSD, v6);\n        v13 = msg.sender.call().value(msg.value - v12).gas(0x2dc6c0);\n        require(v13);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v14, v15 = _token.mint(msg.sender, v8).gas(msg.gas - 710);\n    require(v14);\n    _collectedCent = _collectedCent + v6;\n    _soldTokens = _soldTokens + v8;\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 1) {\n        owner_2[msg.sender] = owner_2[msg.sender] + v8;\n    } else {\n        owner_1[msg.sender] = owner_1[msg.sender] + v8;\n    }\n    _owner = 0x0 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x1c6b69b7 == function_selector) {\n            rateCent();\n        } else if (0x1eed0f27 == function_selector) {\n            setPriceUSD(uint256);\n        } else if (0x2d21ca88 == function_selector) {\n            ICOTokenHardCap();\n        } else if (0x2ea3ad74 == function_selector) {\n            finishPreIco();\n        } else if (0x4357da58 == function_selector) {\n            pausePreSale();\n        } else if (0x47c421b5 == function_selector) {\n            changeOracle(address);\n        } else if (0x55367ba9 == function_selector) {\n            pauseSale();\n        } else if (0x5ed9ebfc == function_selector) {\n            soldTokens();\n        } else if (0x70597cb1 == function_selector) {\n            startCompanySell();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x7dc0d1d0 == function_selector) {\n            oracle();\n        } else if (0x7fa8c158 == function_selector) {\n            startICO();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x928b4cd2 == function_selector) {\n            preICOTokenHardCap();\n        } else if (0x93a408d7 == function_selector) {\n            priceUSD();\n        } else if (0x986bb722 == function_selector) {\n            startIco(uint256,uint256);\n        } else if (0xa3f1bd35 == function_selector) {\n            getDouble();\n        } else if (0xada6b1d9 == function_selector) {\n            collectedCent();\n        } else if (0xb2684945 == function_selector) {\n            usdSale(address,uint256);\n        } else if (0xbc40b52a == function_selector) {\n            startPreICO();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xc4561d61 == function_selector) {\n            finishICO();\n        } else if (0xe4c19408 == function_selector) {\n            startPreIco(uint256,uint256);\n        } else if (0xeeb9635c == function_selector) {\n            mintTokens();\n        } else if (0xef78d4fd == function_selector) {\n            period();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 04:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_2; // STORAGE[0x2]\nuint256 _startICO; // STORAGE[0x4]\nuint256 _startPreICO; // STORAGE[0x5]\nuint256 _period; // STORAGE[0x6]\nuint256 _collectedCent; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 _soldTokens; // STORAGE[0x9]\nuint256 _priceUSD; // STORAGE[0xa]\naddress _token; // STORAGE[0x3] bytes 0 to 19\naddress stor_b_0_19; // STORAGE[0xb] bytes 0 to 19\naddress _oracle; // STORAGE[0xc] bytes 0 to 19\n\n// Events\nStateChanged(uint8, uint8);\n\nfunction fallback() public payable { \n    0x5dc();\n}\n\nfunction rateCent() public nonPayable { \n    return 0x71afd498d0000;\n}\n\nfunction setPriceUSD(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _oracle;\n    if (msg.sender != _oracle) {\n        v0 = v2 = msg.sender == address(_owner);\n    }\n    require(v0);\n    _priceUSD = varg0;\n}\n\nfunction 0x1b30() private { \n    v0 = v1 = 0;\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        if (0xff & _owner >> 168 == 4) {\n            v0 = v2 = 0x1461b91395a4f3a800000;\n        }\n    } else {\n        v0 = v3 = 0x5d2c72a2ac16a3000000;\n    }\n    return v0;\n}\n\nfunction ICOTokenHardCap() public nonPayable { \n    return 0x1461b91395a4f3a800000;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x1c1e(uint256 varg0) private { \n    assert(varg0 <= 7);\n    _owner = varg0 << 168 | ~0xff000000000000000000000000000000000000000000 & _owner;\n    assert(0xff & _owner >> 168 <= 7);\n    assert(varg0 <= 7);\n    v0 = 0xff & varg0;\n    emit StateChanged(0xff & (0xff & _owner >> 168), v0);\n    return ;\n}\n\nfunction finishPreIco() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 1);\n    0x1c1e(3);\n    v0 = stor_b_0_19.call().value((address(this)).balance).gas(0x2dc6c0);\n    require(v0);\n}\n\nfunction pausePreSale() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 1);\n    0x1c1e(2);\n}\n\nfunction changeOracle(address varg0) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 != 0);\n    _oracle = varg0;\n}\n\nfunction pauseSale() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 4);\n    0x1c1e(5);\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction startCompanySell() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 6);\n    0x1c1e(7);\n}\n\nfunction finishMinting() public nonPayable { \n    require(msg.sender == address(_owner));\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.finishMinting().gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction oracle() public nonPayable { \n    return _oracle;\n}\n\nfunction startICO() public nonPayable { \n    return _startICO;\n}\n\nfunction owner() public nonPayable { \n    return address(_owner);\n}\n\nfunction preICOTokenHardCap() public nonPayable { \n    return 0x5d2c72a2ac16a3000000;\n}\n\nfunction priceUSD() public nonPayable { \n    return _priceUSD;\n}\n\nfunction startIco(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 > 0);\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 1;\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 5;\n    }\n    if (!v0) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = 0xff & _owner >> 168 == 3;\n    }\n    require(v0);\n    _priceUSD = varg1;\n    _startICO = block.timestamp;\n    _period = varg0 * stor_8;\n    0x1c1e(4);\n}\n\nfunction getDouble() public nonPayable { \n    require(!(0xff & _owner >> 160));\n    _owner = 0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 4;\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 7;\n    }\n    require(v0);\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        if (0xff & _owner >> 168 == 7) {\n            owner_2[msg.sender] = 0;\n            owner_2[msg.sender] = 0;\n            MEM[32 + MEM[64]] = 0;\n            require(_token.code.size);\n            v3, v4 = _token.mint(msg.sender, owner_2[msg.sender] + owner_2[msg.sender]).gas(msg.gas - 710);\n            require(v3);\n        }\n    } else {\n        owner_1[msg.sender] = 0;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v5, v6 = _token.mint(msg.sender, owner_1[msg.sender]).gas(msg.gas - 710);\n        require(v5);\n        owner_2[msg.sender] = owner_2[msg.sender] + owner_1[msg.sender];\n    }\n    _owner = 0x0 | ~0xff0000000000000000000000000000000000000000 & _owner;\n}\n\nfunction collectedCent() public nonPayable { \n    return _collectedCent;\n}\n\nfunction usdSale(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    v0 = _SafeMul(varg1 * 100, 0x71afd498d0000);\n    _collectedCent = _collectedCent + varg1 * 100;\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v1, v2 = _token.mint(varg0, v0).gas(msg.gas - 710);\n    require(v1);\n    assert(0xff & _owner >> 168 <= 7);\n    v3 = v4 = 0xff & _owner >> 168 == 4;\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        v3 = v5 = 0xff & _owner >> 168 == 3;\n    }\n    if (!v3) {\n        owner_1[varg0] = owner_1[varg0] + v0;\n    } else {\n        owner_2[varg0] = owner_2[varg0] + v0;\n    }\n    _soldTokens = _soldTokens + v0;\n}\n\nfunction startPreICO() public nonPayable { \n    return _startPreICO;\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _owner >> 168 <= 7);\n    return 0xff & (0xff & _owner >> 168);\n}\n\nfunction finishICO() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 4);\n    0x1c1e(6);\n    v0 = stor_b_0_19.call().value((address(this)).balance).gas(0x2dc6c0);\n    require(v0);\n}\n\nfunction startPreIco(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 > 0);\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 0;\n    if (0xff & _owner >> 168 != 0) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = 0xff & _owner >> 168 == 2;\n    }\n    require(v0);\n    _priceUSD = varg1;\n    _startPreICO = block.timestamp;\n    _period = varg0 * stor_8;\n    0x1c1e(1);\n}\n\nfunction mintTokens() public payable { \n    0x5dc();\n}\n\nfunction period() public nonPayable { \n    return _period;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 != 0);\n    _owner = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owner;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x5dc() private { \n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 1;\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 4;\n    }\n    if (v0) {\n        v0 = v3 = block.timestamp < _startICO + _period;\n        if (block.timestamp >= _startICO + _period) {\n            v0 = v4 = block.timestamp < _startPreICO + _period;\n        }\n    }\n    require(v0);\n    v5 = 0x1b30();\n    require(_soldTokens < v5);\n    require(!(0xff & _owner >> 160));\n    _owner = 0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    assert(_priceUSD);\n    v6 = v7 = msg.value / _priceUSD;\n    v8 = v9 = _SafeMul(v7, 0x71afd498d0000);\n    v10 = 0x1b30();\n    if (_soldTokens + v9 > v10) {\n        assert(_soldTokens <= v10);\n        v8 = v11 = v10 - _soldTokens;\n        assert(0x71afd498d0000);\n        v6 = v11 / 0x71afd498d0000;\n        v12 = _SafeMul(_priceUSD, v6);\n        v13 = msg.sender.call().value(msg.value - v12).gas(0x2dc6c0);\n        require(v13);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v14, v15 = _token.mint(msg.sender, v8).gas(msg.gas - 710);\n    require(v14);\n    _collectedCent = _collectedCent + v6;\n    _soldTokens = _soldTokens + v8;\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 1) {\n        owner_2[msg.sender] = owner_2[msg.sender] + v8;\n    } else {\n        owner_1[msg.sender] = owner_1[msg.sender] + v8;\n    }\n    _owner = 0x0 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x1c6b69b7 == function_selector) {\n            rateCent();\n        } else if (0x1eed0f27 == function_selector) {\n            setPriceUSD(uint256);\n        } else if (0x2d21ca88 == function_selector) {\n            ICOTokenHardCap();\n        } else if (0x2ea3ad74 == function_selector) {\n            finishPreIco();\n        } else if (0x4357da58 == function_selector) {\n            pausePreSale();\n        } else if (0x47c421b5 == function_selector) {\n            changeOracle(address);\n        } else if (0x55367ba9 == function_selector) {\n            pauseSale();\n        } else if (0x5ed9ebfc == function_selector) {\n            soldTokens();\n        } else if (0x70597cb1 == function_selector) {\n            startCompanySell();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x7dc0d1d0 == function_selector) {\n            oracle();\n        } else if (0x7fa8c158 == function_selector) {\n            startICO();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x928b4cd2 == function_selector) {\n            preICOTokenHardCap();\n        } else if (0x93a408d7 == function_selector) {\n            priceUSD();\n        } else if (0x986bb722 == function_selector) {\n            startIco(uint256,uint256);\n        } else if (0xa3f1bd35 == function_selector) {\n            getDouble();\n        } else if (0xada6b1d9 == function_selector) {\n            collectedCent();\n        } else if (0xb2684945 == function_selector) {\n            usdSale(address,uint256);\n        } else if (0xbc40b52a == function_selector) {\n            startPreICO();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xc4561d61 == function_selector) {\n            finishICO();\n        } else if (0xe4c19408 == function_selector) {\n            startPreIco(uint256,uint256);\n        } else if (0xeeb9635c == function_selector) {\n            mintTokens();\n        } else if (0xef78d4fd == function_selector) {\n            period();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 04:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_2; // STORAGE[0x2]\nuint256 _startICO; // STORAGE[0x4]\nuint256 _startPreICO; // STORAGE[0x5]\nuint256 _period; // STORAGE[0x6]\nuint256 _collectedCent; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 _soldTokens; // STORAGE[0x9]\nuint256 _priceUSD; // STORAGE[0xa]\naddress _token; // STORAGE[0x3] bytes 0 to 19\naddress stor_b_0_19; // STORAGE[0xb] bytes 0 to 19\naddress _oracle; // STORAGE[0xc] bytes 0 to 19\n\n// Events\nStateChanged(uint8, uint8);\n\nfunction fallback() public payable { \n    0x5dc();\n}\n\nfunction rateCent() public nonPayable { \n    return 0x71afd498d0000;\n}\n\nfunction setPriceUSD(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _oracle;\n    if (msg.sender != _oracle) {\n        v0 = v2 = msg.sender == address(_owner);\n    }\n    require(v0);\n    _priceUSD = varg0;\n}\n\nfunction 0x1b30() private { \n    v0 = v1 = 0;\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        if (0xff & _owner >> 168 == 4) {\n            v0 = v2 = 0x1461b91395a4f3a800000;\n        }\n    } else {\n        v0 = v3 = 0x5d2c72a2ac16a3000000;\n    }\n    return v0;\n}\n\nfunction ICOTokenHardCap() public nonPayable { \n    return 0x1461b91395a4f3a800000;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x1c1e(uint256 varg0) private { \n    assert(varg0 <= 7);\n    _owner = varg0 << 168 | ~0xff000000000000000000000000000000000000000000 & _owner;\n    assert(0xff & _owner >> 168 <= 7);\n    assert(varg0 <= 7);\n    v0 = 0xff & varg0;\n    emit StateChanged(0xff & (0xff & _owner >> 168), v0);\n    return ;\n}\n\nfunction finishPreIco() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 1);\n    0x1c1e(3);\n    v0 = stor_b_0_19.call().value((address(this)).balance).gas(0x2dc6c0);\n    require(v0);\n}\n\nfunction pausePreSale() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 1);\n    0x1c1e(2);\n}\n\nfunction changeOracle(address varg0) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 != 0);\n    _oracle = varg0;\n}\n\nfunction pauseSale() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 4);\n    0x1c1e(5);\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction startCompanySell() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 6);\n    0x1c1e(7);\n}\n\nfunction finishMinting() public nonPayable { \n    require(msg.sender == address(_owner));\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.finishMinting().gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction oracle() public nonPayable { \n    return _oracle;\n}\n\nfunction startICO() public nonPayable { \n    return _startICO;\n}\n\nfunction owner() public nonPayable { \n    return address(_owner);\n}\n\nfunction preICOTokenHardCap() public nonPayable { \n    return 0x5d2c72a2ac16a3000000;\n}\n\nfunction priceUSD() public nonPayable { \n    return _priceUSD;\n}\n\nfunction startIco(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 > 0);\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 1;\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 5;\n    }\n    if (!v0) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = 0xff & _owner >> 168 == 3;\n    }\n    require(v0);\n    _priceUSD = varg1;\n    _startICO = block.timestamp;\n    _period = varg0 * stor_8;\n    0x1c1e(4);\n}\n\nfunction getDouble() public nonPayable { \n    require(!(0xff & _owner >> 160));\n    _owner = 0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 4;\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 7;\n    }\n    require(v0);\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        if (0xff & _owner >> 168 == 7) {\n            owner_2[msg.sender] = 0;\n            owner_2[msg.sender] = 0;\n            MEM[32 + MEM[64]] = 0;\n            require(_token.code.size);\n            v3, v4 = _token.mint(msg.sender, owner_2[msg.sender] + owner_2[msg.sender]).gas(msg.gas - 710);\n            require(v3);\n        }\n    } else {\n        owner_1[msg.sender] = 0;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v5, v6 = _token.mint(msg.sender, owner_1[msg.sender]).gas(msg.gas - 710);\n        require(v5);\n        owner_2[msg.sender] = owner_2[msg.sender] + owner_1[msg.sender];\n    }\n    _owner = 0x0 | ~0xff0000000000000000000000000000000000000000 & _owner;\n}\n\nfunction collectedCent() public nonPayable { \n    return _collectedCent;\n}\n\nfunction usdSale(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    v0 = _SafeMul(varg1 * 100, 0x71afd498d0000);\n    _collectedCent = _collectedCent + varg1 * 100;\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v1, v2 = _token.mint(varg0, v0).gas(msg.gas - 710);\n    require(v1);\n    assert(0xff & _owner >> 168 <= 7);\n    v3 = v4 = 0xff & _owner >> 168 == 4;\n    if (0xff & _owner >> 168 != 4) {\n        assert(0xff & _owner >> 168 <= 7);\n        v3 = v5 = 0xff & _owner >> 168 == 3;\n    }\n    if (!v3) {\n        owner_1[varg0] = owner_1[varg0] + v0;\n    } else {\n        owner_2[varg0] = owner_2[varg0] + v0;\n    }\n    _soldTokens = _soldTokens + v0;\n}\n\nfunction startPreICO() public nonPayable { \n    return _startPreICO;\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _owner >> 168 <= 7);\n    return 0xff & (0xff & _owner >> 168);\n}\n\nfunction finishICO() public nonPayable { \n    require(msg.sender == address(_owner));\n    assert(0xff & _owner >> 168 <= 7);\n    require(0xff & _owner >> 168 == 4);\n    0x1c1e(6);\n    v0 = stor_b_0_19.call().value((address(this)).balance).gas(0x2dc6c0);\n    require(v0);\n}\n\nfunction startPreIco(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 > 0);\n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 0;\n    if (0xff & _owner >> 168 != 0) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = 0xff & _owner >> 168 == 2;\n    }\n    require(v0);\n    _priceUSD = varg1;\n    _startPreICO = block.timestamp;\n    _period = varg0 * stor_8;\n    0x1c1e(1);\n}\n\nfunction mintTokens() public payable { \n    0x5dc();\n}\n\nfunction period() public nonPayable { \n    return _period;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == address(_owner));\n    require(varg0 != 0);\n    _owner = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owner;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x5dc() private { \n    assert(0xff & _owner >> 168 <= 7);\n    v0 = v1 = 0xff & _owner >> 168 == 1;\n    if (0xff & _owner >> 168 != 1) {\n        assert(0xff & _owner >> 168 <= 7);\n        v0 = v2 = 0xff & _owner >> 168 == 4;\n    }\n    if (v0) {\n        v0 = v3 = block.timestamp < _startICO + _period;\n        if (block.timestamp >= _startICO + _period) {\n            v0 = v4 = block.timestamp < _startPreICO + _period;\n        }\n    }\n    require(v0);\n    v5 = 0x1b30();\n    require(_soldTokens < v5);\n    require(!(0xff & _owner >> 160));\n    _owner = 0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    assert(_priceUSD);\n    v6 = v7 = msg.value / _priceUSD;\n    v8 = v9 = _SafeMul(v7, 0x71afd498d0000);\n    v10 = 0x1b30();\n    if (_soldTokens + v9 > v10) {\n        assert(_soldTokens <= v10);\n        v8 = v11 = v10 - _soldTokens;\n        assert(0x71afd498d0000);\n        v6 = v11 / 0x71afd498d0000;\n        v12 = _SafeMul(_priceUSD, v6);\n        v13 = msg.sender.call().value(msg.value - v12).gas(0x2dc6c0);\n        require(v13);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v14, v15 = _token.mint(msg.sender, v8).gas(msg.gas - 710);\n    require(v14);\n    _collectedCent = _collectedCent + v6;\n    _soldTokens = _soldTokens + v8;\n    assert(0xff & _owner >> 168 <= 7);\n    if (0xff & _owner >> 168 != 1) {\n        owner_2[msg.sender] = owner_2[msg.sender] + v8;\n    } else {\n        owner_1[msg.sender] = owner_1[msg.sender] + v8;\n    }\n    _owner = 0x0 | ~0xff0000000000000000000000000000000000000000 & _owner;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x1c6b69b7 == function_selector) {\n            rateCent();\n        } else if (0x1eed0f27 == function_selector) {\n            setPriceUSD(uint256);\n        } else if (0x2d21ca88 == function_selector) {\n            ICOTokenHardCap();\n        } else if (0x2ea3ad74 == function_selector) {\n            finishPreIco();\n        } else if (0x4357da58 == function_selector) {\n            pausePreSale();\n        } else if (0x47c421b5 == function_selector) {\n            changeOracle(address);\n        } else if (0x55367ba9 == function_selector) {\n            pauseSale();\n        } else if (0x5ed9ebfc == function_selector) {\n            soldTokens();\n        } else if (0x70597cb1 == function_selector) {\n            startCompanySell();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x7dc0d1d0 == function_selector) {\n            oracle();\n        } else if (0x7fa8c158 == function_selector) {\n            startICO();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x928b4cd2 == function_selector) {\n            preICOTokenHardCap();\n        } else if (0x93a408d7 == function_selector) {\n            priceUSD();\n        } else if (0x986bb722 == function_selector) {\n            startIco(uint256,uint256);\n        } else if (0xa3f1bd35 == function_selector) {\n            getDouble();\n        } else if (0xada6b1d9 == function_selector) {\n            collectedCent();\n        } else if (0xb2684945 == function_selector) {\n            usdSale(address,uint256);\n        } else if (0xbc40b52a == function_selector) {\n            startPreICO();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xc4561d61 == function_selector) {\n            finishICO();\n        } else if (0xe4c19408 == function_selector) {\n            startPreIco(uint256,uint256);\n        } else if (0xeeb9635c == function_selector) {\n            mintTokens();\n        } else if (0xef78d4fd == function_selector) {\n            period();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 16.988332986831665,
	"usage": {
		"completion_tokens": 400,
		"prompt_tokens": 3906,
		"total_tokens": 4306
	}
}