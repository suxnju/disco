{
	"address": "0x52083b1a21a5abc422b1b0bce5c43ca86ef74cd1",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2022.06.05 08:51 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_1; // STORAGE[0x1]\nuint256 _getTimeLeft; // STORAGE[0x2]\nuint256 _airDropPot_; // STORAGE[0x3]\nuint256 _airDropTracker_; // STORAGE[0x4]\nuint256 _rID_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyr_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xe]\naddress _activate; // STORAGE[0x0] bytes 0 to 19\nuint8 _activated_; // STORAGE[0xf] bytes 0 to 0\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1]\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3]\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonPotSwapDeposit(uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonAffiliatePayout(uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256, uint256);\n\nfunction () public payable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v0, v1 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v2, v3 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] += 1;\n    }\n    v8 = _pIDxAddr_[_pIDxAddr_[msg.sender]][6];\n    v9 = _rID_;\n    v10 = v11 = block.timestamp > _getTimeLeft + _round_[v9][4];\n    if (v11) {\n        v10 = v12 = block.timestamp <= _round_[v9][2];\n        if (block.timestamp > _round_[v9][2]) {\n            v10 = v13 = block.timestamp > _round_[v9][2];\n            if (v13) {\n                v10 = !_round_[v9];\n            }\n        }\n    }\n    if (!v10) {\n        v14 = v15 = block.timestamp > _round_[v9][2];\n        if (v15) {\n            v14 = !(0xff & _round_[v9][0x3]);\n        }\n        if (v14) {\n            _round_[v9][3] = 0x1 | ~0xff & _round_[v9][0x3];\n            v16 = MEM[64];\n            MEM[v16] = 0;\n            MEM[32 + v16] = 0;\n            MEM[64 + v16] = 0;\n            MEM[96 + v16] = 0;\n            MEM[128 + v16] = 0;\n            MEM[160 + v16] = 0;\n            MEM[192 + v16] = 0;\n            MEM[224 + v16] = 0;\n            MEM[256 + v16] = 0;\n            v16 = v17 = _rID_;\n            v16 = v18 = 0;\n            v16 = v19 = _round_[v17];\n            v16 = v20 = _round_[v17][1];\n            v16 = v21 = _round_[v17][7];\n            if (v21) {\n                v22 = 48 * v21;\n                assert(v21);\n                require(v22 / v21 == 48, 'SafeMath mul failed');\n            } else {\n                v22 = v23 = 0;\n            }\n            assert(100);\n            v16 = v24 = v22 / 100;\n            v16 = v25 = v21 / 50;\n            if (v21) {\n                v26 = _potSplit_[v20] * v21;\n                assert(v21);\n                require(v26 / v21 == _potSplit_[v20], 'SafeMath mul failed');\n            } else {\n                v26 = v27 = 0;\n            }\n            assert(100);\n            v16 = v28 = v26 / 100;\n            if (v21) {\n                v29 = _potSplit_[v20][1] * v21;\n                assert(v21);\n                require(v29 / v21 == _potSplit_[v20][1], 'SafeMath mul failed');\n            } else {\n                v29 = v30 = 0;\n            }\n            assert(100);\n            v16 = v31 = v29 / 100;\n            v16 = v32 = 13414;\n            v16 = v33 = 7649;\n            v34 = v35 = _SafeSub(v24, v21);\n            while (1) {\n                v34 = _SafeSub(v16, v34);\n            }\n            if (v16) {\n                v36 = 0xde0b6b3a7640000 * v16;\n                assert(v16);\n                require(v36 / v16 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v36 = v37 = 0;\n            }\n            assert(_round_[v16][5]);\n            if (v36 / _round_[v16][5]) {\n                v38 = _round_[v16][5] * (v36 / _round_[v16][5]);\n                assert(v36 / _round_[v16][5]);\n                require(v38 / (v36 / _round_[v16][5]) == _round_[v16][5], 'SafeMath mul failed');\n            } else {\n                v38 = v39 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v38 / 0xde0b6b3a7640000 <= v16, 'SafeMath sub failed');\n            if (v16 - v38 / 0xde0b6b3a7640000 > 0) {\n                v16 = v40 = _SafeSub(v16 - v38 / 0xde0b6b3a7640000, v16);\n                v34 += v16 - v38 / 0xde0b6b3a7640000;\n                require(v34 >= v34, 'SafeMath add failed');\n            }\n            require(_plyr_[v16][2] + v16 >= v16, 'SafeMath add failed');\n            _plyr_[v16][2] = _plyr_[v16][2] + v16;\n            v41 = _activate.call().value(v16).gas(2300 * !v16);\n            require(v41); // checks call status, propagates error data on error\n            require(v16 + v16 >= v16, 'SafeMath add failed');\n            _round_[v16][7] = v16 + v16;\n            require(_round_[v16][8] + v36 / _round_[v16][5] >= v36 / _round_[v16][5], 'SafeMath add failed');\n            _round_[v16][8] = _round_[v16][8] + v36 / _round_[v16][5];\n            MEM[0 + v16] = MEM[0 + v16] + 0xf4240 * _round_[v16][2];\n            MEM[32 + v16] = MEM[32 + v16] + 0x52b7d2dcc80cd2e4000000 * v16 + 0x16345785d8a0000 * v16;\n            MEM[64 + v16] = address(_round_[v16][0]);\n            MEM[96 + v16] = ~0x0 & (~0x0 & _round_[v16][0x1]);\n            MEM[128 + v16] = v16;\n            MEM[224 + v16] = v16;\n            MEM[192 + v16] = v16;\n            MEM[160 + v16] = v34;\n            _rID_ += 1;\n            _round_[v16][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v16][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v16][7] = v34;\n            MEM[0 + v16] = MEM[0 + v16] + 0xde0b6b3a7640000 * v17;\n            MEM[32 + v16] = MEM[32 + v16] + v9;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v9][0x1]), msg.value, MEM[0 + v16], MEM[32 + v16], address(MEM[64 + v16]), ~0x0 & (~0x0 & MEM[96 + v16]), MEM[128 + v16], MEM[160 + v16], MEM[192 + v16], MEM[224 + v16]);\n        }\n        require(msg.value + _plyr_[v9][3] >= _plyr_[v9][3], 'SafeMath add failed');\n        _plyr_[v9][3] += msg.value;\n    } else {\n        0x2f36(MEM[64], v42, v42, msg.value, v42);\n    }\n}\n\nfunction 0x2f36(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg1 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        MEM[MEM[64]] = 0;\n        MEM[32 + MEM[64]] = 0;\n        MEM[64 + MEM[64]] = 0;\n        MEM[96 + MEM[64]] = 0;\n        MEM[128 + MEM[64]] = 0;\n        MEM[160 + MEM[64]] = 0;\n        MEM[192 + MEM[64]] = 0;\n        MEM[224 + MEM[64]] = 0;\n        MEM[256 + MEM[64]] = 0;\n        if (_plyr_[varg4][5]) {\n            0x4dd9(_plyr_[varg4][5], varg4);\n        }\n        _plyr_[varg4][5] = _rID_;\n        MEM[varg0] += 10;\n    }\n    if (varg3 > 0x3b9aca00) {\n        varg1 = v2 = _round_[v1][6];\n        varg1 = v3 = 12182;\n        varg1 = v4 = 0;\n        varg3 = v5 = 14305;\n        varg1 = v6 = 0x44e6(v2);\n        varg3 = v7 = 7649;\n        varg1 = v8 = varg3 + v2;\n        require(v8 >= v2, 'SafeMath add failed');\n        varg3 = v9 = 0;\n        varg1 = v10 = 0x9502f90;\n        varg3 = v11 = 17742;\n        varg1 = v12 = 0x3b2a1d15167e7c5699bfde00000;\n        if (v8) {\n            v13 = 0xde0b6b3a7640000 * v8;\n            assert(v8);\n            require(v13 / v8 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n        } else {\n            v13 = v14 = 0;\n        }\n        if (v13) {\n            v15 = 0x1027e72f1f1281308800000 * v13;\n            assert(v13);\n            require(v15 / v13 == 0x1027e72f1f1281308800000, 'SafeMath mul failed');\n        } else {\n            v15 = v16 = 0;\n        }\n        require(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000 + v15 >= v15, 'SafeMath add failed');\n        varg1 = v17 = 0x4e70(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000 + v15);\n        while (1) {\n            varg1 = _SafeSub(varg1, varg1);\n            assert(varg1);\n            varg1 = varg1 / varg1;\n            goto 0x1de10x44c5B0x2f75;\n        }\n        require(varg1 <= varg1, 'SafeMath sub failed');\n        varg1 = v18 = varg1 - varg1;\n        if (v18 >= 0xde0b6b3a7640000) {\n            v19 = v20 = block.timestamp > _round_[varg1][2];\n            if (v20) {\n                v19 = !_round_[varg1];\n            }\n            if (!v19) {\n                if (v18 / 0xde0b6b3a7640000) {\n                    v21 = v18 / 0xde0b6b3a7640000;\n                    assert(v18 / 0xde0b6b3a7640000);\n                    require(v21 / (v18 / 0xde0b6b3a7640000) == 1, 'SafeMath mul failed');\n                } else {\n                    v21 = v22 = 0;\n                }\n                v23 = v24 = _SafeSub(v21, _round_[varg1][2]);\n            } else {\n                if (v18 / 0xde0b6b3a7640000) {\n                    v25 = v18 / 0xde0b6b3a7640000;\n                    assert(v18 / 0xde0b6b3a7640000);\n                    require(v25 / (v18 / 0xde0b6b3a7640000) == 1, 'SafeMath mul failed');\n                } else {\n                    v25 = v26 = 0;\n                }\n                v23 = v27 = _SafeSub(v25, block.timestamp);\n            }\n            require(block.timestamp + 0x112a880 >= 0x112a880, 'SafeMath add failed');\n            if (v23 >= block.timestamp + 0x112a880) {\n                require(block.timestamp + 0x112a880 >= 0x112a880, 'SafeMath add failed');\n                _round_[varg1][2] = block.timestamp + 0x112a880;\n                goto 0x2fb1;\n            } else {\n                _round_[varg1][2] = v23;\n            }\n            if (varg1 != _round_[varg1]) {\n                _round_[varg1] = varg1;\n            }\n            if (v3 != _round_[varg1][1]) {\n                _round_[varg1][1] = v3;\n            }\n            MEM[v28] += 100;\n        }\n        if (v0 >= 0x16345785d8a0000) {\n            _airDropTracker_ += 1;\n            varg1 = v29 = 12333;\n            varg1 = v30 = 0;\n            varg1 = v31 = 18578;\n            varg1 = v32 = block.number;\n            varg1 = v33 = 14111;\n            MEM[MEM[64]] = 20;\n            v34 = v35 = v35.data;\n            v36 = v37 = MEM[MEM[64]];\n            v38 = v39 = 32 + MEM[64];\n            while (v36 >= 32) {\n                MEM[v34] = MEM[v38];\n                v36 = v36 + ~31;\n                v34 += 32;\n                v38 += 32;\n            }\n            MEM[v34] = MEM[v34] & ~0 + 256 ** (32 - v36) | MEM[v38] & ~(~0 + 256 ** (32 - v36));\n            assert(block.timestamp);\n            varg1 = v40 = keccak256(msg.sender) / block.timestamp;\n            varg1 = v41 = 14111;\n            varg1 = v42 = block.gaslimit;\n            varg1 = v43 = 14111;\n            MEM[MEM[64]] = 20;\n            v44 = v45 = v45.data;\n            v46 = v47 = MEM[MEM[64]];\n            v48 = v49 = 32 + MEM[64];\n            while (v46 >= 32) {\n                MEM[v44] = MEM[v48];\n                v46 = v46 + ~31;\n                v44 += 32;\n                v48 += 32;\n            }\n            MEM[v44] = MEM[v44] & ~0 + 256 ** (32 - v46) | MEM[v48] & ~(~0 + 256 ** (32 - v46));\n            assert(block.timestamp);\n            varg1 = v50 = keccak256(address(block.coinbase)) / block.timestamp;\n            v51 = block.difficulty + block.timestamp;\n            require(v51 >= block.timestamp, 'SafeMath add failed');\n            while (1) {\n                v51 += varg1;\n                if (v51 >= v51) {\n                    break;\n                }\n                require(v51 >= v51, 'SafeMath add failed');\n                MEM[MEM[64]] = 32;\n                v52 = v53 = v53.data;\n                v54 = v55 = MEM[MEM[64]];\n                v56 = v57 = 32 + MEM[64];\n                while (v54 >= 32) {\n                    MEM[v52] = MEM[v56];\n                    v54 = v54 + ~31;\n                    v52 += 32;\n                    v56 += 32;\n                }\n                MEM[v52] = MEM[v52] & ~0 + 256 ** (32 - v54) | MEM[v56] & ~(~0 + 256 ** (32 - v54));\n                if (keccak256(v51) - 1000 * (keccak256(v51) / 1000) >= _airDropTracker_) {\n                    v58 = v59 = 0;\n                } else {\n                    v58 = v60 = 1;\n                }\n                if (1 == v58) {\n                    if (v29 < 0x8ac7230489e80000) {\n                        v61 = v62 = v29 >= 0xde0b6b3a7640000;\n                        if (v62) {\n                            v61 = v63 = v29 < 0x8ac7230489e80000;\n                        }\n                        if (!v61) {\n                            v64 = v65 = v29 >= 0x16345785d8a0000;\n                            if (v65) {\n                                v64 = v66 = v29 < 0xde0b6b3a7640000;\n                            }\n                            if (v64) {\n                                if (_airDropPot_) {\n                                    v67 = 25 * _airDropPot_;\n                                    assert(_airDropPot_);\n                                    require(v67 / _airDropPot_ == 25, 'SafeMath mul failed');\n                                } else {\n                                    v67 = v68 = 0;\n                                }\n                                assert(100);\n                                varg1 = v69 = v67 / 100;\n                                require(v69 + _plyr_[v70][2] >= _plyr_[v70][2], 'SafeMath add failed');\n                                _plyr_[v70][2] += v69;\n                                v71 = _SafeSub(v69, _airDropPot_);\n                                _airDropPot_ = v71;\n                                MEM[v72] += 0xeca8847c4129106ce8300000000;\n                            }\n                        } else {\n                            if (_airDropPot_) {\n                                v73 = 50 * _airDropPot_;\n                                assert(_airDropPot_);\n                                require(v73 / _airDropPot_ == 50, 'SafeMath mul failed');\n                            } else {\n                                v73 = v74 = 0;\n                            }\n                            assert(100);\n                            varg1 = v75 = v73 / 100;\n                            require(v75 + _plyr_[v70][2] >= _plyr_[v70][2], 'SafeMath add failed');\n                            _plyr_[v70][2] += v75;\n                            v76 = _SafeSub(v75, _airDropPot_);\n                            _airDropPot_ = v76;\n                            MEM[v72] += 0x9dc5ada82b70b59df0200000000;\n                        }\n                    } else {\n                        if (_airDropPot_) {\n                            v77 = 75 * _airDropPot_;\n                            assert(_airDropPot_);\n                            require(v77 / _airDropPot_ == 75, 'SafeMath mul failed');\n                        } else {\n                            v77 = v78 = 0;\n                        }\n                        assert(100);\n                        varg1 = v79 = v77 / 100;\n                        require(v79 + _plyr_[v70][2] >= _plyr_[v70][2], 'SafeMath add failed');\n                        _plyr_[v70][2] += v79;\n                        v80 = _SafeSub(v79, _airDropPot_);\n                        _airDropPot_ = v80;\n                        MEM[v72] += 0xeca8847c4129106ce8300000000;\n                    }\n                    MEM[v72] = 0x7e37be2022c0914b2680000000 + (varg1 * 0x314dc6448d9338c15b0a00000000 + MEM[v72]);\n                    _airDropTracker_ = 0;\n                }\n                goto {'0x4892B0x301d', '0x371f0x4721B0x301d'};\n            }\n        }\n        MEM[varg1] += _airDropTracker_ * 1000;\n        require(_plyrRnds_[varg1][1] + varg1 >= varg1, 'SafeMath add failed');\n        _plyrRnds_[varg1][1] = _plyrRnds_[varg1][1] + varg1;\n        require(_plyrRnds_[varg1] + varg1 >= varg1, 'SafeMath add failed');\n        _plyrRnds_[varg1] = _plyrRnds_[varg1] + varg1;\n        require(_plyrRnds_[varg1][5] + varg1 >= varg1, 'SafeMath add failed');\n        _round_[varg1][5] = _plyrRnds_[varg1][5] + varg1;\n        require(_round_[varg1][6] + varg1 >= varg1, 'SafeMath add failed');\n        _round_[varg1][6] = _round_[varg1][6] + varg1;\n        require(_rndTmEth_[varg1] + varg1 >= varg1, 'SafeMath add failed');\n        _rndTmEth_[varg1] = _rndTmEth_[varg1] + varg1;\n        MEM[MEM[64]] = 0;\n        MEM[32 + MEM[64]] = 0;\n        MEM[64 + MEM[64]] = 0;\n        MEM[96 + MEM[64]] = 0;\n        MEM[128 + MEM[64]] = 0;\n        MEM[160 + MEM[64]] = 0;\n        MEM[192 + MEM[64]] = 0;\n        MEM[224 + MEM[64]] = 0;\n        MEM[256 + MEM[64]] = 0;\n        v81 = v82 = 0;\n        v81 = varg1 / 100 + varg1 / 50;\n        require(v81 >= varg1 / 50, 'SafeMath add failed');\n        v83 = _activate.call().value(v81).gas(msg.gas);\n        if (!v83) {\n        }\n        v81 = v84 = varg1 / 10;\n        v85 = v86 = varg1 != varg1;\n        if (v86) {\n            v85 = _plyr_[varg1][1];\n        }\n        if (v85) {\n            require(_plyr_[varg1][4] + v84 >= v84, 'SafeMath add failed');\n            _plyr_[varg1][4] = _plyr_[varg1][4] + v84;\n            emit onAffiliatePayout(varg1, varg1, varg1, address(_plyr_[varg1]), _plyr_[varg1][1], v84, block.timestamp);\n        }\n        if (varg1) {\n            v87 = _fees_[varg1][1] * varg1;\n            assert(varg1);\n            require(v87 / varg1 == _fees_[varg1][1], 'SafeMath mul failed');\n        } else {\n            v87 = v88 = 0;\n        }\n        assert(100);\n        require(v87 / 100 + v81 >= v81, 'SafeMath add failed');\n        if (v87 / 100 + v81 > 0) {\n            require(v87 / 100 + v81 + _round_[varg1][7] >= _round_[varg1][7], 'SafeMath add failed');\n            _round_[varg1][7] += v87 / 100 + v81;\n            require(MEM[varg1 + 192] + (v87 / 100 + v81) >= v87 / 100 + v81, 'SafeMath add failed');\n            MEM[varg1 + 192] = MEM[varg1 + 192] + (v87 / 100 + v81);\n        }\n        MEM[MEM[64]] = 0;\n        MEM[32 + MEM[64]] = 0;\n        MEM[64 + MEM[64]] = 0;\n        MEM[96 + MEM[64]] = 0;\n        MEM[128 + MEM[64]] = 0;\n        MEM[160 + MEM[64]] = 0;\n        MEM[192 + MEM[64]] = 0;\n        MEM[224 + MEM[64]] = 0;\n        MEM[256 + MEM[64]] = 0;\n        if (varg1) {\n            v89 = _fees_[varg1] * varg1;\n            assert(varg1);\n            require(v89 / varg1 == _fees_[varg1], 'SafeMath mul failed');\n        } else {\n            v89 = v90 = 0;\n        }\n        assert(100);\n        varg1 = v91 = v89 / 100;\n        require(varg1 / 100 + _airDropPot_ >= _airDropPot_, 'SafeMath add failed');\n        _airDropPot_ += varg1 / 100;\n        if (varg1) {\n            v92 = _fees_[varg1][1] * varg1;\n            assert(varg1);\n            require(v92 / varg1 == _fees_[varg1][1], 'SafeMath mul failed');\n        } else {\n            v92 = v93 = 0;\n        }\n        assert(100);\n        if (varg1) {\n            v94 = 14 * varg1;\n            assert(varg1);\n            require(v94 / varg1 == 14, 'SafeMath mul failed');\n        } else {\n            v94 = v95 = 0;\n        }\n        assert(100);\n        require(v92 / 100 + v94 / 100 >= v94 / 100, 'SafeMath add failed');\n        require(v92 / 100 + v94 / 100 <= varg1, 'SafeMath sub failed');\n        v96 = v97 = _SafeSub(v91, varg1 - (v92 / 100 + v94 / 100));\n        varg1 = v98 = 0;\n        if (v91) {\n            v99 = 0xde0b6b3a7640000 * v91;\n            assert(v91);\n            require(v99 / v91 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n        } else {\n            v99 = v100 = 0;\n        }\n        assert(_round_[v101][5]);\n        varg1 = v102 = v99 / _round_[v101][5];\n        require(_round_[v101][8] + v102 >= v102, 'SafeMath add failed');\n        _round_[v101][8] = _round_[v101][8] + v102;\n        if (v102) {\n            v103 = v104 * v102;\n            assert(v102);\n            require(v103 / v102 == v104, 'SafeMath mul failed');\n        } else {\n            v103 = v105 = 0;\n        }\n        assert(0xde0b6b3a7640000);\n        varg1 = v106 = _plyrRnds_[v101][2];\n        varg1 = v107 = v103 / 0xde0b6b3a7640000;\n        varg1 = v108 = 20405;\n        v109 = v110 = 14111;\n        if (_plyrRnds_[v101][8]) {\n            v111 = v104 * _plyrRnds_[v101][8];\n            assert(_plyrRnds_[v101][8]);\n            require(v111 / _plyrRnds_[v101][8] == v104, 'SafeMath mul failed');\n        } else {\n            v111 = v112 = 0;\n        }\n        assert(0xde0b6b3a7640000);\n        varg1 = v113 = v111 / 0xde0b6b3a7640000;\n        while (varg1 > varg1) {\n            goto {'0x4ffdB0x4bd8', '0x371f0x4ecfB0x4bd8'};\n            if (varg1 + (varg1 - varg1) >= varg1 - varg1) {\n                break;\n            }\n            require(varg1 + (varg1 - varg1) >= varg1 - varg1, 'SafeMath add failed');\n            _plyrRnds_[v101][2] = varg1 + (varg1 - varg1);\n            v109 = v114 = 20477;\n            if (varg1) {\n                v115 = _plyrRnds_[v101][5] * varg1;\n                assert(varg1);\n                require(v115 / varg1 == _plyrRnds_[v101][5], 'SafeMath mul failed');\n            } else {\n                v115 = v116 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            varg1 = v117 = v115 / 0xde0b6b3a7640000;\n        }\n        revert('SafeMath sub failed');\n        if (varg1 - varg1 > 0) {\n            v96 = v118 = _SafeSub(varg1 - varg1, v97);\n        }\n        require(varg1 - varg1 + 19430 >= 19430, 'SafeMath add failed');\n        require(_round_[varg1 - (v92 / 100 + v94 / 100)][7] + (varg1 - varg1 + 19430) >= varg1 - varg1 + 19430, 'SafeMath add failed');\n        _round_[varg1 - (v92 / 100 + v94 / 100)][7] = _round_[varg1 - (v92 / 100 + v94 / 100)][7] + (varg1 - varg1 + 19430);\n        require(MEM[v91 + 224] + v96 >= v96, 'SafeMath add failed');\n        MEM[v91 + 224] = MEM[v91 + 224] + v96;\n        MEM[v91 + 256] = 19430;\n        MEM[0 + v91] = MEM[0 + v91] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * varg1;\n        MEM[32 + v91] = MEM[32 + v91] + varg1 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + v91], MEM[32 + v91], ~0x0 & (~0x0 & _plyr_[varg1][0x1]), msg.sender, varg1, 13191, address(MEM[64 + v91]), ~0x0 & (~0x0 & MEM[96 + v91]), MEM[128 + v91], MEM[160 + v91], MEM[192 + v91], MEM[224 + v91], MEM[256 + v91], _airDropPot_);\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x44364c5bb000;\n    } else {\n        require(0xde0b6b3a7640000 + _round_[_rID_][5] >= _round_[_rID_][5], 'SafeMath add failed');\n        v4 = v6 = 0x37bb(0xde0b6b3a7640000, 0xde0b6b3a7640000 + _round_[_rID_][5]);\n    }\n    return v4;\n}\n\nfunction 0x37bb(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeSub(varg0, varg1);\n    v1 = 0x455e(v0);\n    v2 = 0x455e(varg1);\n    v3 = _SafeSub(v1, v2);\n    return v3;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0x3a29(uint256 varg0) private { \n    0x4dd9(_plyr_[varg0][5], varg0);\n    v0 = _plyr_[varg0][2];\n    require(_plyr_[varg0][3] + v0 >= v0, 'SafeMath add failed');\n    require(_plyr_[varg0][4] + (_plyr_[varg0][3] + v0) >= _plyr_[varg0][3] + v0, 'SafeMath add failed');\n    if (_plyr_[varg0][4] + (_plyr_[varg0][3] + v0) > 0) {\n        _plyr_[varg0][2] = 0;\n        _plyr_[varg0][3] = 0;\n        _plyr_[varg0][4] = 0;\n    }\n    return _plyr_[varg0][4] + (_plyr_[varg0][3] + v0);\n}\n\nfunction 0x3ab0(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, 'string must be between 1 and 32 characters');\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (varg0.length - 1)] >> 248 << 248;\n    }\n    require(v5, 'string cannot start or end with space');\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0x');\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0X');\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, 'string contains invalid characters');\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (1 + v8)] >> 248 << 248, 'string cannot contain consecutive spaces');\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (MEM[varg0.data + v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, 'string cannot be only numbers');\n    return MEM[varg0.data];\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg2 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg2 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v0 = v1 = !varg0;\n    if (varg0) {\n        v0 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v0) {\n        v2 = v3 = _pIDxName_[varg0];\n        if (v3 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v3;\n        }\n    } else {\n        v2 = v4 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = v6 = varg1 < 0;\n    if (varg1 >= 0) {\n        v5 = varg1 > 3;\n    }\n    if (v5) {\n        v7 = 2;\n    }\n    v8 = v9 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v9) {\n        v8 = v10 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v8 = v11 = block.timestamp > _round_[_rID_][2];\n            if (v11) {\n                v8 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v8) {\n        v12 = v13 = block.timestamp > _round_[_rID_][2];\n        if (v13) {\n            v12 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v12) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v14 = MEM[64];\n            MEM[v14] = 0;\n            MEM[32 + v14] = 0;\n            MEM[64 + v14] = 0;\n            MEM[96 + v14] = 0;\n            MEM[128 + v14] = 0;\n            MEM[160 + v14] = 0;\n            MEM[192 + v14] = 0;\n            MEM[224 + v14] = 0;\n            MEM[256 + v14] = 0;\n            v14 = v15 = _rID_;\n            v14 = v16 = 0;\n            v14 = v17 = _round_[v15];\n            v14 = v18 = _round_[v15][1];\n            v14 = v19 = _round_[v15][7];\n            if (v19) {\n                v20 = 48 * v19;\n                assert(v19);\n                require(v20 / v19 == 48, 'SafeMath mul failed');\n            } else {\n                v20 = v21 = 0;\n            }\n            assert(100);\n            v14 = v22 = v20 / 100;\n            v14 = v23 = v19 / 50;\n            if (v19) {\n                v24 = _potSplit_[v18] * v19;\n                assert(v19);\n                require(v24 / v19 == _potSplit_[v18], 'SafeMath mul failed');\n            } else {\n                v24 = v25 = 0;\n            }\n            assert(100);\n            v14 = v26 = v24 / 100;\n            if (v19) {\n                v27 = _potSplit_[v18][1] * v19;\n                assert(v19);\n                require(v27 / v19 == _potSplit_[v18][1], 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(100);\n            v14 = v29 = v27 / 100;\n            v14 = v30 = 13414;\n            v14 = v31 = 7649;\n            v32 = v33 = _SafeSub(v22, v19);\n            while (1) {\n                v32 = _SafeSub(v14, v32);\n            }\n            if (v14) {\n                v34 = 0xde0b6b3a7640000 * v14;\n                assert(v14);\n                require(v34 / v14 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v34 = v35 = 0;\n            }\n            assert(_round_[v14][5]);\n            if (v34 / _round_[v14][5]) {\n                v36 = _round_[v14][5] * (v34 / _round_[v14][5]);\n                assert(v34 / _round_[v14][5]);\n                require(v36 / (v34 / _round_[v14][5]) == _round_[v14][5], 'SafeMath mul failed');\n            } else {\n                v36 = v37 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v36 / 0xde0b6b3a7640000 <= v14, 'SafeMath sub failed');\n            if (v14 - v36 / 0xde0b6b3a7640000 > 0) {\n                v14 = v38 = _SafeSub(v14 - v36 / 0xde0b6b3a7640000, v14);\n                v32 += v14 - v36 / 0xde0b6b3a7640000;\n                require(v32 >= v32, 'SafeMath add failed');\n            }\n            require(_plyr_[v14][2] + v14 >= v14, 'SafeMath add failed');\n            _plyr_[v14][2] = _plyr_[v14][2] + v14;\n            v39 = _activate.call().value(v14).gas(2300 * !v14);\n            require(v39); // checks call status, propagates error data on error\n            require(v14 + v14 >= v14, 'SafeMath add failed');\n            _round_[v14][7] = v14 + v14;\n            require(_round_[v14][8] + v34 / _round_[v14][5] >= v34 / _round_[v14][5], 'SafeMath add failed');\n            _round_[v14][8] = _round_[v14][8] + v34 / _round_[v14][5];\n            MEM[0 + v14] = MEM[0 + v14] + 0xf4240 * _round_[v14][2];\n            MEM[32 + v14] = MEM[32 + v14] + 0x52b7d2dcc80cd2e4000000 * v14 + 0x16345785d8a0000 * v14;\n            MEM[64 + v14] = address(_round_[v14][0]);\n            MEM[96 + v14] = ~0x0 & (~0x0 & _round_[v14][0x1]);\n            MEM[128 + v14] = v14;\n            MEM[224 + v14] = v14;\n            MEM[192 + v14] = v14;\n            MEM[160 + v14] = v32;\n            _rID_ += 1;\n            _round_[v14][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v14][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v14][7] = v32;\n            MEM[0 + v14] = MEM[0 + v14] + 0xde0b6b3a7640000 * v15;\n            MEM[32 + v14] = MEM[32 + v14] + MEM[64];\n            emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[MEM[64]][0x1]), MEM[0 + v14], MEM[32 + v14], address(MEM[64 + v14]), ~0x0 & (~0x0 & MEM[96 + v14]), MEM[128 + v14], MEM[160 + v14], MEM[192 + v14], MEM[224 + v14]);\n            goto 0x11b50xfb4B0x41c;\n        }\n    } else {\n        v40 = 0x3a29(_pIDxAddr_[msg.sender]);\n        v41 = _SafeSub(varg2, v40);\n        _plyr_[_pIDxAddr_[msg.sender]][3] = v41;\n        0x2f36(MEM[64], v7, v2, varg2, _pIDxAddr_[msg.sender]);\n        goto 0x19190x380dB0x11a60xfb4B0x41c;\n    }\n}\n\nfunction activate() public nonPayable { \n    require(msg.sender == _activate, 'only admin can activate');\n    require(!_activated_, 'FOMO Short already activated');\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 11;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3 = stor_1 + block.timestamp - _getTimeLeft;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1 = 0x112a880 + (stor_1 + block.timestamp);\n}\n\nfunction 0x433a(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[v0][1];\n    varg0 = v3 = _plyrRnds_[v0][5];\n    v4 = _plyrRnds_[v0][1];\n    v5 = _plyrRnds_[v0];\n    MEM[v1] = varg0;\n    MEM[32] = 11;\n    v6 = _plyrRnds_[v0][7];\n    varg0 = v7 = 0xde0b6b3a7640000;\n    v0 = v8 = 17399;\n    v0 = v9 = 17387;\n    v0 = v10 = 17346;\n    if (v11) {\n        v12 = v5 * v6;\n        assert(v6);\n        require(v12 / v6 == v5, 'SafeMath mul failed');\n    } else {\n        v12 = v13 = 0;\n    }\n    assert(100);\n    v11 = v12 / 100;\n    while (1) {\n        v11 = v14 = 0;\n        while (1) {\n            goto {'0x43c2', '0x43eb0x433a', '0x43f7'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v15 = _round_[varg0][8];\n            v11 = v11 / varg0 + v15;\n            require(v11 >= v15, 'SafeMath add failed');\n        }\n        continue;\n        v11 *= varg0;\n        assert(v11);\n        require(v11 / v11 == varg0, 'SafeMath mul failed');\n    }\n    assert(varg0);\n    return v11 / varg0, v0, varg0, v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, 'SafeMath sub failed');\n    return varg1 - varg0;\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction 0x4468(uint256 varg0, uint256 varg1) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = _plyrRnds_[varg0][1];\n    v2 = _plyrRnds_[varg0][8];\n    if (v2) {\n        v3 = v1 * v2;\n        assert(v2);\n        require(v3 / v2 == v1, 'SafeMath mul failed');\n    } else {\n        v3 = v4 = 0;\n    }\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v3 / 0xde0b6b3a7640000, 'SafeMath sub failed');\n    return v3 / 0xde0b6b3a7640000 - v0;\n}\n\nfunction 0x44e6(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0x9502f90;\n    v0 = v4 = 17742;\n    v5 = v6 = 0x3b2a1d15167e7c5699bfde00000;\n    if (varg0) {\n        v7 = 0xde0b6b3a7640000 * varg0;\n        assert(varg0);\n        require(v7 / varg0 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n    } else {\n        v7 = v8 = 0;\n    }\n    if (v7) {\n        v9 = 0x1027e72f1f1281308800000 * v7;\n        assert(v7);\n        require(v9 / v7 == 0x1027e72f1f1281308800000, 'SafeMath mul failed');\n    } else {\n        v9 = v10 = 0;\n    }\n    require(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000 + v9 >= v9, 'SafeMath add failed');\n    v2 = v11 = 0x4e70(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000 + v9);\n    v5 = v12 = _SafeSub(v6, v11);\n    require(v5 <= v2, 'SafeMath sub failed');\n    while (1) {\n        goto 0x37e10x44e6;\n    }\n    assert(v2);\n    return v5 / v2;\n}\n\nfunction 0x455e(uint256 varg0) private { \n    v0 = 0x4ec3(0xde0b6b3a7640000);\n    if (varg0) {\n        v1 = 0xde0b6b3a7640000 * varg0;\n        assert(varg0);\n        require(v1 / varg0 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n    } else {\n        v1 = v2 = 0;\n    }\n    if (0x886c8f673070) {\n        v3 = v1 * 0x886c8f673070;\n        assert(0x886c8f673070);\n        require(v3 / 0x886c8f673070 == v1, 'SafeMath mul failed');\n    } else {\n        v3 = v4 = 0;\n    }\n    assert(2);\n    v5 = 0x4ec3(varg0);\n    if (0x4a817c8) {\n        v6 = v5 * 0x4a817c8;\n        assert(0x4a817c8);\n        require(v6 / 0x4a817c8 == v5, 'SafeMath mul failed');\n    } else {\n        v6 = v7 = 0;\n    }\n    require((v3 >> 1) + v6 >= v6, 'SafeMath add failed');\n    assert(v0);\n    return ((v3 >> 1) + v6) / v0;\n}\n\nfunction airDropTracker_() public nonPayable { \n    return _airDropTracker_;\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    return _round_[varg0], _round_[varg0][1], _round_[varg0][2], _round_[varg0][0x3] & 0xff, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10], _round_[varg0][11];\n}\n\nfunction 0x4dd9(uint256 varg0, uint256 varg1) private { \n    v0 = 0x4468(varg0, varg1);\n    if (v0 > 0) {\n        require(_plyr_[varg1][3] + v0 >= v0, 'SafeMath add failed');\n        _plyr_[varg1][3] = _plyr_[varg1][3] + v0;\n        require(_plyrRnds_[varg1][2] + v0 >= v0, 'SafeMath add failed');\n        _plyrRnds_[varg1][2] = _plyrRnds_[varg1][2] + v0;\n    }\n    return ;\n}\n\nfunction 0x4e70(uint256 varg0) private { \n    require(v0 >= varg0, 'SafeMath add failed');\n    assert(2);\n    varg0 = v0 >> 1;\n    while (1) {\n        v0 = varg0 + varg0;\n        if (v0 >= varg0) {\n            break;\n        }\n        if (v0 >= varg0) {\n            break;\n        }\n        if (varg0 >= varg0) {\n            break;\n        }\n        if (varg0) {\n            break;\n        }\n        assert(varg0);\n        require(v0 >= varg0, 'SafeMath add failed');\n        assert(2);\n        varg0 = v1 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x4ec3(uint256 varg0) private { \n    if (varg0) {\n        v0 = varg0 * varg0;\n        assert(varg0);\n        require(v0 / varg0 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction reLoadXid(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg2 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg2 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v0 = v1 = !varg0;\n    if (varg0) {\n        v0 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v0) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v2 = v3 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v4 = v5 = varg1 < 0;\n    if (varg1 >= 0) {\n        v4 = varg1 > 3;\n    }\n    if (v4) {\n        v6 = 2;\n    }\n    v7 = v8 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v8) {\n        v7 = v9 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v7 = v10 = block.timestamp > _round_[_rID_][2];\n            if (v10) {\n                v7 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v7) {\n        v11 = v12 = block.timestamp > _round_[_rID_][2];\n        if (v12) {\n            v11 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v11) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v13 = MEM[64];\n            MEM[v13] = 0;\n            MEM[32 + v13] = 0;\n            MEM[64 + v13] = 0;\n            MEM[96 + v13] = 0;\n            MEM[128 + v13] = 0;\n            MEM[160 + v13] = 0;\n            MEM[192 + v13] = 0;\n            MEM[224 + v13] = 0;\n            MEM[256 + v13] = 0;\n            v13 = v14 = _rID_;\n            v13 = v15 = 0;\n            v13 = v16 = _round_[v14];\n            v13 = v17 = _round_[v14][1];\n            v13 = v18 = _round_[v14][7];\n            if (v18) {\n                v19 = 48 * v18;\n                assert(v18);\n                require(v19 / v18 == 48, 'SafeMath mul failed');\n            } else {\n                v19 = v20 = 0;\n            }\n            assert(100);\n            v13 = v21 = v19 / 100;\n            v13 = v22 = v18 / 50;\n            if (v18) {\n                v23 = _potSplit_[v17] * v18;\n                assert(v18);\n                require(v23 / v18 == _potSplit_[v17], 'SafeMath mul failed');\n            } else {\n                v23 = v24 = 0;\n            }\n            assert(100);\n            v13 = v25 = v23 / 100;\n            if (v18) {\n                v26 = _potSplit_[v17][1] * v18;\n                assert(v18);\n                require(v26 / v18 == _potSplit_[v17][1], 'SafeMath mul failed');\n            } else {\n                v26 = v27 = 0;\n            }\n            assert(100);\n            v13 = v28 = v26 / 100;\n            v13 = v29 = 13414;\n            v13 = v30 = 7649;\n            v31 = v32 = _SafeSub(v21, v18);\n            while (1) {\n                v31 = _SafeSub(v13, v31);\n            }\n            if (v13) {\n                v33 = 0xde0b6b3a7640000 * v13;\n                assert(v13);\n                require(v33 / v13 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v33 = v34 = 0;\n            }\n            assert(_round_[v13][5]);\n            if (v33 / _round_[v13][5]) {\n                v35 = _round_[v13][5] * (v33 / _round_[v13][5]);\n                assert(v33 / _round_[v13][5]);\n                require(v35 / (v33 / _round_[v13][5]) == _round_[v13][5], 'SafeMath mul failed');\n            } else {\n                v35 = v36 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v35 / 0xde0b6b3a7640000 <= v13, 'SafeMath sub failed');\n            if (v13 - v35 / 0xde0b6b3a7640000 > 0) {\n                v13 = v37 = _SafeSub(v13 - v35 / 0xde0b6b3a7640000, v13);\n                v31 += v13 - v35 / 0xde0b6b3a7640000;\n                require(v31 >= v31, 'SafeMath add failed');\n            }\n            require(_plyr_[v13][2] + v13 >= v13, 'SafeMath add failed');\n            _plyr_[v13][2] = _plyr_[v13][2] + v13;\n            v38 = _activate.call().value(v13).gas(2300 * !v13);\n            require(v38); // checks call status, propagates error data on error\n            require(v13 + v13 >= v13, 'SafeMath add failed');\n            _round_[v13][7] = v13 + v13;\n            require(_round_[v13][8] + v33 / _round_[v13][5] >= v33 / _round_[v13][5], 'SafeMath add failed');\n            _round_[v13][8] = _round_[v13][8] + v33 / _round_[v13][5];\n            MEM[0 + v13] = MEM[0 + v13] + 0xf4240 * _round_[v13][2];\n            MEM[32 + v13] = MEM[32 + v13] + 0x52b7d2dcc80cd2e4000000 * v13 + 0x16345785d8a0000 * v13;\n            MEM[64 + v13] = address(_round_[v13][0]);\n            MEM[96 + v13] = ~0x0 & (~0x0 & _round_[v13][0x1]);\n            MEM[128 + v13] = v13;\n            MEM[224 + v13] = v13;\n            MEM[192 + v13] = v13;\n            MEM[160 + v13] = v31;\n            _rID_ += 1;\n            _round_[v13][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v13][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v13][7] = v31;\n            MEM[0 + v13] = MEM[0 + v13] + 0xde0b6b3a7640000 * v14;\n            MEM[32 + v13] = MEM[32 + v13] + MEM[64];\n            emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[MEM[64]][0x1]), MEM[0 + v13], MEM[32 + v13], address(MEM[64 + v13]), ~0x0 & (~0x0 & MEM[96 + v13]), MEM[128 + v13], MEM[160 + v13], MEM[192 + v13], MEM[224 + v13]);\n            goto 0x15970x13bbB0x576;\n        }\n    } else {\n        v39 = 0x3a29(_pIDxAddr_[msg.sender]);\n        v40 = _SafeSub(varg2, v39);\n        _plyr_[_pIDxAddr_[msg.sender]][3] = v40;\n        0x2f36(MEM[64], v6, v2, varg2, _pIDxAddr_[msg.sender]);\n        goto 0x19190x380dB0x1588B0x576;\n    }\n}\n\nfunction withdraw() public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v0 = v1 = block.timestamp > _round_[msg.sender][2];\n    if (v1) {\n        v0 = v2 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v0) {\n        v0 = _round_[_rID_];\n    }\n    if (!v0) {\n        v3 = 0x3a29(_pIDxAddr_[msg.sender]);\n        if (v3 > 0) {\n            v4 = address(_plyr_[_pIDxAddr_[msg.sender]]).call().value(v3).gas(2300 * !v3);\n            require(v4); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(_pIDxAddr_[msg.sender], msg.sender, _plyr_[_pIDxAddr_[msg.sender]][1], v3, block.timestamp);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v5 = MEM[64];\n        MEM[v5] = 0;\n        MEM[32 + v5] = 0;\n        MEM[64 + v5] = 0;\n        MEM[96 + v5] = 0;\n        MEM[128 + v5] = 0;\n        MEM[160 + v5] = 0;\n        MEM[192 + v5] = 0;\n        MEM[224 + v5] = 0;\n        MEM[256 + v5] = 0;\n        v5 = v6 = _rID_;\n        v5 = v7 = 0;\n        v5 = v8 = _round_[v6];\n        v5 = v9 = _round_[v6][1];\n        v5 = v10 = _round_[v6][7];\n        if (v10) {\n            v11 = 48 * v10;\n            assert(v10);\n            require(v11 / v10 == 48, 'SafeMath mul failed');\n        } else {\n            v11 = v12 = 0;\n        }\n        assert(100);\n        v5 = v13 = v11 / 100;\n        v5 = v14 = v10 / 50;\n        if (v10) {\n            v15 = _potSplit_[v9] * v10;\n            assert(v10);\n            require(v15 / v10 == _potSplit_[v9], 'SafeMath mul failed');\n        } else {\n            v15 = v16 = 0;\n        }\n        assert(100);\n        v5 = v17 = v15 / 100;\n        if (v10) {\n            v18 = _potSplit_[v9][1] * v10;\n            assert(v10);\n            require(v18 / v10 == _potSplit_[v9][1], 'SafeMath mul failed');\n        } else {\n            v18 = v19 = 0;\n        }\n        assert(100);\n        v5 = v20 = v18 / 100;\n        v5 = v21 = 13414;\n        v5 = v22 = 7649;\n        v23 = v24 = _SafeSub(v13, v10);\n        while (1) {\n            v23 = _SafeSub(v5, v23);\n        }\n        if (v5) {\n            v25 = 0xde0b6b3a7640000 * v5;\n            assert(v5);\n            require(v25 / v5 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n        } else {\n            v25 = v26 = 0;\n        }\n        assert(_round_[v5][5]);\n        if (v25 / _round_[v5][5]) {\n            v27 = _round_[v5][5] * (v25 / _round_[v5][5]);\n            assert(v25 / _round_[v5][5]);\n            require(v27 / (v25 / _round_[v5][5]) == _round_[v5][5], 'SafeMath mul failed');\n        } else {\n            v27 = v28 = 0;\n        }\n        assert(0xde0b6b3a7640000);\n        require(v27 / 0xde0b6b3a7640000 <= v5, 'SafeMath sub failed');\n        if (v5 - v27 / 0xde0b6b3a7640000 > 0) {\n            v5 = v29 = _SafeSub(v5 - v27 / 0xde0b6b3a7640000, v5);\n            v23 += v5 - v27 / 0xde0b6b3a7640000;\n            require(v23 >= v23, 'SafeMath add failed');\n        }\n        require(_plyr_[v5][2] + v5 >= v5, 'SafeMath add failed');\n        _plyr_[v5][2] = _plyr_[v5][2] + v5;\n        v30 = _activate.call().value(v5).gas(2300 * !v5);\n        require(v30); // checks call status, propagates error data on error\n        require(v5 + v5 >= v5, 'SafeMath add failed');\n        _round_[v5][7] = v5 + v5;\n        require(_round_[v5][8] + v25 / _round_[v5][5] >= v25 / _round_[v5][5], 'SafeMath add failed');\n        _round_[v5][8] = _round_[v5][8] + v25 / _round_[v5][5];\n        MEM[0 + v5] = MEM[0 + v5] + 0xf4240 * _round_[v5][2];\n        MEM[32 + v5] = MEM[32 + v5] + 0x52b7d2dcc80cd2e4000000 * v5 + 0x16345785d8a0000 * v5;\n        MEM[64 + v5] = address(_round_[v5][0]);\n        MEM[96 + v5] = ~0x0 & (~0x0 & _round_[v5][0x1]);\n        MEM[128 + v5] = v5;\n        MEM[224 + v5] = v5;\n        MEM[192 + v5] = v5;\n        MEM[160 + v5] = v23;\n        _rID_ += 1;\n        _round_[v5][4] = block.timestamp;\n        require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n        require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n        _round_[1 + v5][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n        _round_[1 + v5][7] = v23;\n        v31 = 0x3a29(msg.sender.code.size);\n        if (v31 > 0) {\n            v32 = address(_plyr_[msg.sender.code.size]).call().value(v31).gas(2300 * !v31);\n            require(v32); // checks call status, propagates error data on error\n        }\n        MEM[0 + v5] = MEM[0 + v5] + 0xde0b6b3a7640000 * msg.sender;\n        MEM[32 + v5] = MEM[32 + v5] + msg.sender.code.size;\n        emit 0xbd0dba8ab932212fa78150cdb7b0275da72e255875967b5cad11464cf71bedc(msg.sender, ~0x0 & (~0x0 & _plyr_[msg.sender.code.size][0x1]), v31, MEM[0 + v5], MEM[32 + v5], address(MEM[64 + v5]), ~0x0 & (~0x0 & MEM[96 + v5]), MEM[128 + v5], MEM[160 + v5], MEM[192 + v5], MEM[224 + v5]);\n    }\n}\n\nfunction registerNameXaddr(string varg0, address varg1, bool varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(!msg.sender.code.size, 'sorry humans only');\n    v2 = 0x3ab0(v0);\n    require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n    v3, v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.registerNameXaddrFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction receivePlayerInfo(uint256 varg0, address varg1, bytes32 varg2, uint256 varg3) public nonPayable { \n    require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf == msg.sender, 'your not playerNames contract... hmmm..');\n    if (varg0 != _pIDxAddr_[varg1]) {\n        _pIDxAddr_[varg1] = varg0;\n    }\n    if (varg0 != _pIDxName_[varg2]) {\n        _pIDxName_[varg2] = varg0;\n    }\n    if (address(_plyr_[varg0]) != varg1) {\n        _plyr_[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _plyr_[varg0];\n    }\n    if (varg2 != _plyr_[varg0][1]) {\n        _plyr_[varg0][1] = varg2;\n    }\n    if (varg3 != _plyr_[varg0][6]) {\n        _plyr_[varg0][6] = varg3;\n    }\n    if (!(0xff & _plyrNames_[varg2])) {\n        _plyrNames_[varg2] = 0x1 | ~0xff & _plyrNames_[varg2];\n    }\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 varg0) public nonPayable { \n    v0 = v1 = _rID_;\n    v2 = v3 = block.timestamp > _round_[v1][2];\n    if (v3) {\n        v2 = v4 = !(0xff & _round_[v1][0x3]);\n    }\n    if (v2) {\n        v2 = _round_[v1];\n    }\n    if (!v2) {\n        v5 = v6 = _plyr_[varg0][2];\n        v7 = v8 = 7691;\n        v9 = v10 = 0x4468(_plyr_[varg0][5], varg0);\n    } else {\n        if (varg0 != _round_[v1]) {\n            v11 = _plyr_[varg0][2];\n            v12 = _plyrRnds_[v1][2];\n            v5 = v13 = 7649;\n            v14 = v15, v16 = v17, v18 = v19, v7 = v20 = 0x433a(v1);\n        } else {\n            if (_round_[v1][7]) {\n                v21 = 48 * _round_[v1][7];\n                assert(_round_[v1][7]);\n                require(v21 / _round_[v1][7] == 48, 'SafeMath mul failed');\n            } else {\n                v21 = v22 = 0;\n            }\n            assert(100);\n            require(v21 / 100 + _plyr_[varg0][2] >= _plyr_[varg0][2], 'SafeMath add failed');\n            v23 = _plyrRnds_[v1][2];\n            v5 = v24 = 7649;\n            v14 = v25, v16 = v26, v18 = v27, v7 = v28 = 0x433a(v1);\n        }\n        v9 = _SafeSub(v16, v14);\n    }\n    require(v9 + _plyr_[v0][3] >= _plyr_[v0][3], 'SafeMath add failed');\n    return v5, v9 + _plyr_[v0][3], _plyr_[v0][4];\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1, bool varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(!msg.sender.code.size, 'sorry humans only');\n    v2 = 0x3ab0(v0);\n    require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n    v3, v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.registerNameXnameFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    v0 = _rID_;\n    return _round_[v0][9], v0, _round_[v0][5], _round_[v0][2], _round_[v0][4], _round_[v0][7], _round_[v0][1] + 10 * _round_[v0][0], address(_round_[_round_[v0][0]][0]), _round_[_round_[_round_[v0][0]][0]][1], _rndTmEth_[0], _rndTmEth_[1], _rndTmEth_[2], _rndTmEth_[3], _airDropTracker_ + 1000 * _airDropPot_;\n}\n\nfunction reLoadXaddr(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg2 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg2 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v0 = v1 = !varg0;\n    if (varg0) {\n        v0 = msg.sender == varg0;\n    }\n    if (!v0) {\n        v2 = v3 = _pIDxAddr_[varg0];\n        if (v3 != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v3;\n            v4 = v5 = varg1 < 0;\n            if (varg1 >= 0) {\n                v4 = varg1 > 3;\n            }\n            if (v4) {\n                v6 = v7 = 2;\n            }\n            goto 0x11a60x2173B0x773;\n        }\n    } else {\n        v2 = v8 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v9 = v10 = varg1 < 0;\n    if (varg1 >= 0) {\n        v9 = varg1 > 3;\n    }\n    if (v9) {\n        v6 = 2;\n    }\n    v11 = v12 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v12) {\n        v11 = v13 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v11 = v14 = block.timestamp > _round_[_rID_][2];\n            if (v14) {\n                v11 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v11) {\n        v15 = v16 = block.timestamp > _round_[_rID_][2];\n        if (v16) {\n            v15 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v15) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v17 = MEM[64];\n            MEM[v17] = 0;\n            MEM[32 + v17] = 0;\n            MEM[64 + v17] = 0;\n            MEM[96 + v17] = 0;\n            MEM[128 + v17] = 0;\n            MEM[160 + v17] = 0;\n            MEM[192 + v17] = 0;\n            MEM[224 + v17] = 0;\n            MEM[256 + v17] = 0;\n            v17 = v18 = _rID_;\n            v17 = v19 = 0;\n            v17 = v20 = _round_[v18];\n            v17 = v21 = _round_[v18][1];\n            v17 = v22 = _round_[v18][7];\n            if (v22) {\n                v23 = 48 * v22;\n                assert(v22);\n                require(v23 / v22 == 48, 'SafeMath mul failed');\n            } else {\n                v23 = v24 = 0;\n            }\n            assert(100);\n            v17 = v25 = v23 / 100;\n            v17 = v26 = v22 / 50;\n            if (v22) {\n                v27 = _potSplit_[v21] * v22;\n                assert(v22);\n                require(v27 / v22 == _potSplit_[v21], 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(100);\n            v17 = v29 = v27 / 100;\n            if (v22) {\n                v30 = _potSplit_[v21][1] * v22;\n                assert(v22);\n                require(v30 / v22 == _potSplit_[v21][1], 'SafeMath mul failed');\n            } else {\n                v30 = v31 = 0;\n            }\n            assert(100);\n            v17 = v32 = v30 / 100;\n            v17 = v33 = 13414;\n            v17 = v34 = 7649;\n            v35 = v36 = _SafeSub(v25, v22);\n            while (1) {\n                v35 = _SafeSub(v17, v35);\n            }\n            if (v17) {\n                v37 = 0xde0b6b3a7640000 * v17;\n                assert(v17);\n                require(v37 / v17 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v37 = v38 = 0;\n            }\n            assert(_round_[v17][5]);\n            if (v37 / _round_[v17][5]) {\n                v39 = _round_[v17][5] * (v37 / _round_[v17][5]);\n                assert(v37 / _round_[v17][5]);\n                require(v39 / (v37 / _round_[v17][5]) == _round_[v17][5], 'SafeMath mul failed');\n            } else {\n                v39 = v40 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v39 / 0xde0b6b3a7640000 <= v17, 'SafeMath sub failed');\n            if (v17 - v39 / 0xde0b6b3a7640000 > 0) {\n                v17 = v41 = _SafeSub(v17 - v39 / 0xde0b6b3a7640000, v17);\n                v35 += v17 - v39 / 0xde0b6b3a7640000;\n                require(v35 >= v35, 'SafeMath add failed');\n            }\n            require(_plyr_[v17][2] + v17 >= v17, 'SafeMath add failed');\n            _plyr_[v17][2] = _plyr_[v17][2] + v17;\n            v42 = _activate.call().value(v17).gas(2300 * !v17);\n            require(v42); // checks call status, propagates error data on error\n            require(v17 + v17 >= v17, 'SafeMath add failed');\n            _round_[v17][7] = v17 + v17;\n            require(_round_[v17][8] + v37 / _round_[v17][5] >= v37 / _round_[v17][5], 'SafeMath add failed');\n            _round_[v17][8] = _round_[v17][8] + v37 / _round_[v17][5];\n            MEM[0 + v17] = MEM[0 + v17] + 0xf4240 * _round_[v17][2];\n            MEM[32 + v17] = MEM[32 + v17] + 0x52b7d2dcc80cd2e4000000 * v17 + 0x16345785d8a0000 * v17;\n            MEM[64 + v17] = address(_round_[v17][0]);\n            MEM[96 + v17] = ~0x0 & (~0x0 & _round_[v17][0x1]);\n            MEM[128 + v17] = v17;\n            MEM[224 + v17] = v17;\n            MEM[192 + v17] = v17;\n            MEM[160 + v17] = v35;\n            _rID_ += 1;\n            _round_[v17][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v17][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v17][7] = v35;\n            MEM[0 + v17] = MEM[0 + v17] + 0xde0b6b3a7640000 * v18;\n            MEM[32 + v17] = MEM[32 + v17] + MEM[64];\n            emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[MEM[64]][0x1]), MEM[0 + v17], MEM[32 + v17], address(MEM[64 + v17]), ~0x0 & (~0x0 & MEM[96 + v17]), MEM[128 + v17], MEM[160 + v17], MEM[192 + v17], MEM[224 + v17]);\n            goto 0x11b50x2173B0x773;\n        }\n    } else {\n        v43 = 0x3a29(_pIDxAddr_[msg.sender]);\n        v44 = _SafeSub(varg2, v43);\n        _plyr_[_pIDxAddr_[msg.sender]][3] = v44;\n        0x2f36(MEM[64], v6, v2, varg2, _pIDxAddr_[msg.sender]);\n        goto 0x19190x380dB0x11a60x2173B0x773;\n    }\n}\n\nfunction buyXid(uint256 varg0, uint256 varg1) public payable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v0, v1 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v2, v3 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] += 1;\n    }\n    v8 = v9 = !varg0;\n    if (varg0) {\n        v8 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v8) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v10 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v11 = v12 = varg1 < 0;\n    if (varg1 >= 0) {\n        v11 = varg1 > 3;\n    }\n    if (v11) {\n    }\n    v13 = _rID_;\n    v14 = v15 = block.timestamp > _getTimeLeft + _round_[v13][4];\n    if (v15) {\n        v14 = v16 = block.timestamp <= _round_[v13][2];\n        if (block.timestamp > _round_[v13][2]) {\n            v14 = v17 = block.timestamp > _round_[v13][2];\n            if (v17) {\n                v14 = !_round_[v13];\n            }\n        }\n    }\n    if (!v14) {\n        v18 = v19 = block.timestamp > _round_[v13][2];\n        if (v19) {\n            v18 = !(0xff & _round_[v13][0x3]);\n        }\n        if (v18) {\n            _round_[v13][3] = 0x1 | ~0xff & _round_[v13][0x3];\n            v20 = MEM[64];\n            MEM[v20] = 0;\n            MEM[32 + v20] = 0;\n            MEM[64 + v20] = 0;\n            MEM[96 + v20] = 0;\n            MEM[128 + v20] = 0;\n            MEM[160 + v20] = 0;\n            MEM[192 + v20] = 0;\n            MEM[224 + v20] = 0;\n            MEM[256 + v20] = 0;\n            v20 = v21 = _rID_;\n            v20 = v22 = 0;\n            v20 = v23 = _round_[v21];\n            v20 = v24 = _round_[v21][1];\n            v20 = v25 = _round_[v21][7];\n            if (v25) {\n                v26 = 48 * v25;\n                assert(v25);\n                require(v26 / v25 == 48, 'SafeMath mul failed');\n            } else {\n                v26 = v27 = 0;\n            }\n            assert(100);\n            v20 = v28 = v26 / 100;\n            v20 = v29 = v25 / 50;\n            if (v25) {\n                v30 = _potSplit_[v24] * v25;\n                assert(v25);\n                require(v30 / v25 == _potSplit_[v24], 'SafeMath mul failed');\n            } else {\n                v30 = v31 = 0;\n            }\n            assert(100);\n            v20 = v32 = v30 / 100;\n            if (v25) {\n                v33 = _potSplit_[v24][1] * v25;\n                assert(v25);\n                require(v33 / v25 == _potSplit_[v24][1], 'SafeMath mul failed');\n            } else {\n                v33 = v34 = 0;\n            }\n            assert(100);\n            v20 = v35 = v33 / 100;\n            v20 = v36 = 13414;\n            v20 = v37 = 7649;\n            v38 = v39 = _SafeSub(v28, v25);\n            while (1) {\n                v38 = _SafeSub(v20, v38);\n            }\n            if (v20) {\n                v40 = 0xde0b6b3a7640000 * v20;\n                assert(v20);\n                require(v40 / v20 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v40 = v41 = 0;\n            }\n            assert(_round_[v20][5]);\n            if (v40 / _round_[v20][5]) {\n                v42 = _round_[v20][5] * (v40 / _round_[v20][5]);\n                assert(v40 / _round_[v20][5]);\n                require(v42 / (v40 / _round_[v20][5]) == _round_[v20][5], 'SafeMath mul failed');\n            } else {\n                v42 = v43 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v42 / 0xde0b6b3a7640000 <= v20, 'SafeMath sub failed');\n            if (v20 - v42 / 0xde0b6b3a7640000 > 0) {\n                v20 = v44 = _SafeSub(v20 - v42 / 0xde0b6b3a7640000, v20);\n                v38 += v20 - v42 / 0xde0b6b3a7640000;\n                require(v38 >= v38, 'SafeMath add failed');\n            }\n            require(_plyr_[v20][2] + v20 >= v20, 'SafeMath add failed');\n            _plyr_[v20][2] = _plyr_[v20][2] + v20;\n            v45 = _activate.call().value(v20).gas(2300 * !v20);\n            require(v45); // checks call status, propagates error data on error\n            require(v20 + v20 >= v20, 'SafeMath add failed');\n            _round_[v20][7] = v20 + v20;\n            require(_round_[v20][8] + v40 / _round_[v20][5] >= v40 / _round_[v20][5], 'SafeMath add failed');\n            _round_[v20][8] = _round_[v20][8] + v40 / _round_[v20][5];\n            MEM[0 + v20] = MEM[0 + v20] + 0xf4240 * _round_[v20][2];\n            MEM[32 + v20] = MEM[32 + v20] + 0x52b7d2dcc80cd2e4000000 * v20 + 0x16345785d8a0000 * v20;\n            MEM[64 + v20] = address(_round_[v20][0]);\n            MEM[96 + v20] = ~0x0 & (~0x0 & _round_[v20][0x1]);\n            MEM[128 + v20] = v20;\n            MEM[224 + v20] = v20;\n            MEM[192 + v20] = v20;\n            MEM[160 + v20] = v38;\n            _rID_ += 1;\n            _round_[v20][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v20][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v20][7] = v38;\n            MEM[0 + v20] = MEM[0 + v20] + 0xde0b6b3a7640000 * v21;\n            MEM[32 + v20] = MEM[32 + v20] + v13;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v13][0x1]), msg.value, MEM[0 + v20], MEM[32 + v20], address(MEM[64 + v20]), ~0x0 & (~0x0 & MEM[96 + v20]), MEM[128 + v20], MEM[160 + v20], MEM[192 + v20], MEM[224 + v20]);\n        }\n        require(msg.value + _plyr_[v13][3] >= _plyr_[v13][3], 'SafeMath add failed');\n        _plyr_[v13][3] += msg.value;\n    } else {\n        0x2f36(MEM[64], v46, v46, msg.value, v46);\n    }\n}\n\nfunction receivePlayerNameList(uint256 varg0, bytes32 varg1) public nonPayable { \n    require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf == msg.sender, 'your not playerNames contract... hmmm..');\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n}\n\nfunction registerNameXID(string varg0, uint256 varg1, bool varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(!msg.sender.code.size, 'sorry humans only');\n    v2 = 0x3ab0(v0);\n    require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n    v3, v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.registerNameXIDFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buyXaddr(address varg0, uint256 varg1) public payable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v0, v1 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v2, v3 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] += 1;\n    }\n    v8 = v9 = !varg0;\n    if (varg0) {\n        v8 = msg.sender == varg0;\n    }\n    if (!v8) {\n        if (_pIDxAddr_[varg0] != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxAddr_[varg0];\n        }\n    } else {\n        v10 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v11 = v12 = varg1 < 0;\n    if (varg1 >= 0) {\n        v11 = varg1 > 3;\n    }\n    if (v11) {\n    }\n    v13 = _rID_;\n    v14 = v15 = block.timestamp > _getTimeLeft + _round_[v13][4];\n    if (v15) {\n        v14 = v16 = block.timestamp <= _round_[v13][2];\n        if (block.timestamp > _round_[v13][2]) {\n            v14 = v17 = block.timestamp > _round_[v13][2];\n            if (v17) {\n                v14 = !_round_[v13];\n            }\n        }\n    }\n    if (!v14) {\n        v18 = v19 = block.timestamp > _round_[v13][2];\n        if (v19) {\n            v18 = !(0xff & _round_[v13][0x3]);\n        }\n        if (v18) {\n            _round_[v13][3] = 0x1 | ~0xff & _round_[v13][0x3];\n            v20 = MEM[64];\n            MEM[v20] = 0;\n            MEM[32 + v20] = 0;\n            MEM[64 + v20] = 0;\n            MEM[96 + v20] = 0;\n            MEM[128 + v20] = 0;\n            MEM[160 + v20] = 0;\n            MEM[192 + v20] = 0;\n            MEM[224 + v20] = 0;\n            MEM[256 + v20] = 0;\n            v20 = v21 = _rID_;\n            v20 = v22 = 0;\n            v20 = v23 = _round_[v21];\n            v20 = v24 = _round_[v21][1];\n            v20 = v25 = _round_[v21][7];\n            if (v25) {\n                v26 = 48 * v25;\n                assert(v25);\n                require(v26 / v25 == 48, 'SafeMath mul failed');\n            } else {\n                v26 = v27 = 0;\n            }\n            assert(100);\n            v20 = v28 = v26 / 100;\n            v20 = v29 = v25 / 50;\n            if (v25) {\n                v30 = _potSplit_[v24] * v25;\n                assert(v25);\n                require(v30 / v25 == _potSplit_[v24], 'SafeMath mul failed');\n            } else {\n                v30 = v31 = 0;\n            }\n            assert(100);\n            v20 = v32 = v30 / 100;\n            if (v25) {\n                v33 = _potSplit_[v24][1] * v25;\n                assert(v25);\n                require(v33 / v25 == _potSplit_[v24][1], 'SafeMath mul failed');\n            } else {\n                v33 = v34 = 0;\n            }\n            assert(100);\n            v20 = v35 = v33 / 100;\n            v20 = v36 = 13414;\n            v20 = v37 = 7649;\n            v38 = v39 = _SafeSub(v28, v25);\n            while (1) {\n                v38 = _SafeSub(v20, v38);\n            }\n            if (v20) {\n                v40 = 0xde0b6b3a7640000 * v20;\n                assert(v20);\n                require(v40 / v20 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v40 = v41 = 0;\n            }\n            assert(_round_[v20][5]);\n            if (v40 / _round_[v20][5]) {\n                v42 = _round_[v20][5] * (v40 / _round_[v20][5]);\n                assert(v40 / _round_[v20][5]);\n                require(v42 / (v40 / _round_[v20][5]) == _round_[v20][5], 'SafeMath mul failed');\n            } else {\n                v42 = v43 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v42 / 0xde0b6b3a7640000 <= v20, 'SafeMath sub failed');\n            if (v20 - v42 / 0xde0b6b3a7640000 > 0) {\n                v20 = v44 = _SafeSub(v20 - v42 / 0xde0b6b3a7640000, v20);\n                v38 += v20 - v42 / 0xde0b6b3a7640000;\n                require(v38 >= v38, 'SafeMath add failed');\n            }\n            require(_plyr_[v20][2] + v20 >= v20, 'SafeMath add failed');\n            _plyr_[v20][2] = _plyr_[v20][2] + v20;\n            v45 = _activate.call().value(v20).gas(2300 * !v20);\n            require(v45); // checks call status, propagates error data on error\n            require(v20 + v20 >= v20, 'SafeMath add failed');\n            _round_[v20][7] = v20 + v20;\n            require(_round_[v20][8] + v40 / _round_[v20][5] >= v40 / _round_[v20][5], 'SafeMath add failed');\n            _round_[v20][8] = _round_[v20][8] + v40 / _round_[v20][5];\n            MEM[0 + v20] = MEM[0 + v20] + 0xf4240 * _round_[v20][2];\n            MEM[32 + v20] = MEM[32 + v20] + 0x52b7d2dcc80cd2e4000000 * v20 + 0x16345785d8a0000 * v20;\n            MEM[64 + v20] = address(_round_[v20][0]);\n            MEM[96 + v20] = ~0x0 & (~0x0 & _round_[v20][0x1]);\n            MEM[128 + v20] = v20;\n            MEM[224 + v20] = v20;\n            MEM[192 + v20] = v20;\n            MEM[160 + v20] = v38;\n            _rID_ += 1;\n            _round_[v20][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v20][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v20][7] = v38;\n            MEM[0 + v20] = MEM[0 + v20] + 0xde0b6b3a7640000 * v21;\n            MEM[32 + v20] = MEM[32 + v20] + v13;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v13][0x1]), msg.value, MEM[0 + v20], MEM[32 + v20], address(MEM[64 + v20]), ~0x0 & (~0x0 & MEM[96 + v20]), MEM[128 + v20], MEM[160 + v20], MEM[192 + v20], MEM[224 + v20]);\n        }\n        require(msg.value + _plyr_[v13][3] >= _plyr_[v13][3], 'SafeMath add failed');\n        _plyr_[v13][3] += msg.value;\n    } else {\n        0x2f36(MEM[64], v46, v46, msg.value, v46);\n    }\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1], _plyrRnds_[varg1][2], _plyrRnds_[varg1][3];\n}\n\nfunction buyXname(bytes32 varg0, uint256 varg1) public payable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v0, v1 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v2, v3 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xee83e20c6aeab2284685efe0b5ffb250be5480bf.code.size);\n        v4, v5 = 0xee83e20c6aeab2284685efe0b5ffb250be5480bf.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] += 1;\n    }\n    v8 = v9 = !varg0;\n    if (varg0) {\n        v8 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v8) {\n        if (_pIDxName_[varg0] != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxName_[varg0];\n            v10 = v11 = varg1 < 0;\n            if (varg1 >= 0) {\n                v10 = varg1 > 3;\n            }\n            if (v10) {\n            }\n            goto 0x294f0x298fB0x877;\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = v14 = varg1 < 0;\n    if (varg1 >= 0) {\n        v13 = varg1 > 3;\n    }\n    if (v13) {\n    }\n    v15 = _rID_;\n    v16 = v17 = block.timestamp > _getTimeLeft + _round_[v15][4];\n    if (v17) {\n        v16 = v18 = block.timestamp <= _round_[v15][2];\n        if (block.timestamp > _round_[v15][2]) {\n            v16 = v19 = block.timestamp > _round_[v15][2];\n            if (v19) {\n                v16 = !_round_[v15];\n            }\n        }\n    }\n    if (!v16) {\n        v20 = v21 = block.timestamp > _round_[v15][2];\n        if (v21) {\n            v20 = !(0xff & _round_[v15][0x3]);\n        }\n        if (v20) {\n            _round_[v15][3] = 0x1 | ~0xff & _round_[v15][0x3];\n            v22 = MEM[64];\n            MEM[v22] = 0;\n            MEM[32 + v22] = 0;\n            MEM[64 + v22] = 0;\n            MEM[96 + v22] = 0;\n            MEM[128 + v22] = 0;\n            MEM[160 + v22] = 0;\n            MEM[192 + v22] = 0;\n            MEM[224 + v22] = 0;\n            MEM[256 + v22] = 0;\n            v22 = v23 = _rID_;\n            v22 = v24 = 0;\n            v22 = v25 = _round_[v23];\n            v22 = v26 = _round_[v23][1];\n            v22 = v27 = _round_[v23][7];\n            if (v27) {\n                v28 = 48 * v27;\n                assert(v27);\n                require(v28 / v27 == 48, 'SafeMath mul failed');\n            } else {\n                v28 = v29 = 0;\n            }\n            assert(100);\n            v22 = v30 = v28 / 100;\n            v22 = v31 = v27 / 50;\n            if (v27) {\n                v32 = _potSplit_[v26] * v27;\n                assert(v27);\n                require(v32 / v27 == _potSplit_[v26], 'SafeMath mul failed');\n            } else {\n                v32 = v33 = 0;\n            }\n            assert(100);\n            v22 = v34 = v32 / 100;\n            if (v27) {\n                v35 = _potSplit_[v26][1] * v27;\n                assert(v27);\n                require(v35 / v27 == _potSplit_[v26][1], 'SafeMath mul failed');\n            } else {\n                v35 = v36 = 0;\n            }\n            assert(100);\n            v22 = v37 = v35 / 100;\n            v22 = v38 = 13414;\n            v22 = v39 = 7649;\n            v40 = v41 = _SafeSub(v30, v27);\n            while (1) {\n                v40 = _SafeSub(v22, v40);\n            }\n            if (v22) {\n                v42 = 0xde0b6b3a7640000 * v22;\n                assert(v22);\n                require(v42 / v22 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v42 = v43 = 0;\n            }\n            assert(_round_[v22][5]);\n            if (v42 / _round_[v22][5]) {\n                v44 = _round_[v22][5] * (v42 / _round_[v22][5]);\n                assert(v42 / _round_[v22][5]);\n                require(v44 / (v42 / _round_[v22][5]) == _round_[v22][5], 'SafeMath mul failed');\n            } else {\n                v44 = v45 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v44 / 0xde0b6b3a7640000 <= v22, 'SafeMath sub failed');\n            if (v22 - v44 / 0xde0b6b3a7640000 > 0) {\n                v22 = v46 = _SafeSub(v22 - v44 / 0xde0b6b3a7640000, v22);\n                v40 += v22 - v44 / 0xde0b6b3a7640000;\n                require(v40 >= v40, 'SafeMath add failed');\n            }\n            require(_plyr_[v22][2] + v22 >= v22, 'SafeMath add failed');\n            _plyr_[v22][2] = _plyr_[v22][2] + v22;\n            v47 = _activate.call().value(v22).gas(2300 * !v22);\n            require(v47); // checks call status, propagates error data on error\n            require(v22 + v22 >= v22, 'SafeMath add failed');\n            _round_[v22][7] = v22 + v22;\n            require(_round_[v22][8] + v42 / _round_[v22][5] >= v42 / _round_[v22][5], 'SafeMath add failed');\n            _round_[v22][8] = _round_[v22][8] + v42 / _round_[v22][5];\n            MEM[0 + v22] = MEM[0 + v22] + 0xf4240 * _round_[v22][2];\n            MEM[32 + v22] = MEM[32 + v22] + 0x52b7d2dcc80cd2e4000000 * v22 + 0x16345785d8a0000 * v22;\n            MEM[64 + v22] = address(_round_[v22][0]);\n            MEM[96 + v22] = ~0x0 & (~0x0 & _round_[v22][0x1]);\n            MEM[128 + v22] = v22;\n            MEM[224 + v22] = v22;\n            MEM[192 + v22] = v22;\n            MEM[160 + v22] = v40;\n            _rID_ += 1;\n            _round_[v22][4] = block.timestamp;\n            require(0x112a880 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x112a880 + block.timestamp) >= 0x112a880 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v22][2] = _getTimeLeft + (0x112a880 + block.timestamp);\n            _round_[1 + v22][7] = v40;\n            MEM[0 + v22] = MEM[0 + v22] + 0xde0b6b3a7640000 * v23;\n            MEM[32 + v22] = MEM[32 + v22] + v15;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v15][0x1]), msg.value, MEM[0 + v22], MEM[32 + v22], address(MEM[64 + v22]), ~0x0 & (~0x0 & MEM[96 + v22]), MEM[128 + v22], MEM[160 + v22], MEM[192 + v22], MEM[224 + v22]);\n        }\n        require(msg.value + _plyr_[v15][3] >= _plyr_[v15][3], 'SafeMath add failed');\n        _plyr_[v15][3] += msg.value;\n    } else {\n        0x2f36(MEM[64], v48, v48, msg.value, v48);\n    }\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + _getTimeLeft) {\n            v0 = v2 = _SafeSub(block.timestamp, _getTimeLeft + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0xf780x2ba5B0x8a9;\n    }\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[varg0][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[varg0][2];\n        if (block.timestamp > _round_[varg0][2]) {\n            v0 = v3 = block.timestamp > _round_[varg0][2];\n            if (v3) {\n                v0 = !_round_[varg0];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x44e6(varg1);\n    } else {\n        v6 = v7 = _round_[varg0][6];\n        v6 = v8 = 0;\n        v9 = v10 = 14305;\n        v6 = v11 = 0x44e6(v7);\n        v9 = v12 = 7649;\n        v6 = v13 = varg1 + v7;\n        require(v13 >= v7, 'SafeMath add failed');\n        v9 = v14 = 0;\n        v6 = v15 = 0x9502f90;\n        v9 = v16 = 17742;\n        v6 = v17 = 0x3b2a1d15167e7c5699bfde00000;\n        if (v13) {\n            v18 = 0xde0b6b3a7640000 * v13;\n            assert(v13);\n            require(v18 / v13 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n        } else {\n            v18 = v19 = 0;\n        }\n        if (v18) {\n            v20 = 0x1027e72f1f1281308800000 * v18;\n            assert(v18);\n            require(v20 / v18 == 0x1027e72f1f1281308800000, 'SafeMath mul failed');\n        } else {\n            v20 = v21 = 0;\n        }\n        require(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000 + v20 >= v20, 'SafeMath add failed');\n        v6 = v22 = 0x4e70(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000 + v20);\n        while (1) {\n            v6 = _SafeSub(v6, v6);\n            assert(v6);\n            v6 = v6 / v6;\n            goto 0x1de10x44c5B0x2ca4B0x8be;\n        }\n        require(v6 <= v6, 'SafeMath sub failed');\n        v4 = v6 - v6;\n        goto 0x2cc5B0x8be;\n    }\n    return v4;\n}\n\nfunction iWantXKeys(uint256 varg0) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x455e(varg0);\n    } else {\n        require(varg0 + _round_[_rID_][5] >= _round_[_rID_][5], 'SafeMath add failed');\n        v4 = v6 = 0x37bb(varg0, varg0 + _round_[_rID_][5]);\n    }\n    return v4;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction airDropPot_() public nonPayable { \n    return _airDropPot_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    return address(_plyr_[varg0]), _plyr_[varg0][1], _plyr_[varg0][2], _plyr_[varg0][3], _plyr_[varg0][4], _plyr_[varg0][5], _plyr_[varg0][6];\n}\n\nfunction potSwap() public payable { \n    require(msg.value + _round_[1 + _rID_][7] >= _round_[1 + _rID_][7], 'SafeMath add failed');\n    _round_[1 + _rID_][7] += msg.value;\n    emit onPotSwapDeposit(1 + _rID_, msg.value);\n}\n\nfunction getPlayerInfoByAddress(address varg0) public nonPayable { \n    v0 = _pIDxAddr_[varg0];\n    MEM[0] = v0;\n    MEM[32] = 8;\n    v1 = 0x4468(_pIDxAddr_[v0][5], v0);\n    require(v1 + _plyr_[v0][3] >= _plyr_[v0][3], 'SafeMath add failed');\n    return v0, _pIDxAddr_[v0][1], _plyrRnds_[v0][1], _pIDxAddr_[v0][2], v1 + _plyr_[v0][3], _plyr_[v0][4], _plyrRnds_[v0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x11a09ae7 == v0) {\n            airDropTracker_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3ddd4698 == v0) {\n            registerNameXaddr(string,address,bool);\n        } else if (0x49cc635d == v0) {\n            receivePlayerInfo(uint256,address,bytes32,uint256);\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x685ffd83 == v0) {\n            registerNameXname(string,bytes32,bool);\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x8f7140ea == v0) {\n            receivePlayerNameList(uint256,bytes32);\n        } else if (0x921dec21 == v0) {\n            registerNameXID(string,uint256,bool);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xd87574e0 == v0) {\n            airDropPot_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xed78cf4a == v0) {\n            potSwap();\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 34515 tokens. Please reduce the length of the messages."
}