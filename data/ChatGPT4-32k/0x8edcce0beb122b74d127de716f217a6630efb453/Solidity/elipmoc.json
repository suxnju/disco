{
	"address": "0x8edcce0beb122b74d127de716f217a6630efb453",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Here is the Solidity code for the decompiled EVM bytecode provided:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    // State variables\n    uint256 private _priceOfEthOnEUR;\n    uint256 private _state;\n    uint256 private _startTime;\n    uint256 private _price;\n    uint256 private _totalRaised;\n    uint256 private _totalDistributed;\n    uint256 private _stageDistributed;\n    uint256 private _completedAt;\n    string private _campaignUrl;\n    string private _version;\n    address private _admin;\n    address private _tokenReward;\n    address private _creator;\n\n    // Event definitions\n    event LogFundingReceived(address indexed _address, uint256 _amount, uint256 _totalRaised);\n    event LogContributorsPayout(address indexed _address, uint256 _amount);\n    event PriceUpdate(uint256 _newPrice);\n    event TransferAdminship(address indexed _newAdmin);\n    event LogFundingSuccessful(uint256 _totalRaised);\n    event LogBeneficiaryPaid(address indexed _beneficiary);\n    event StageDistributed(uint8 _state, uint256 _stageDistributed);\n\n    // Function definitions\n    function priceOfEthOnEUR() public view returns(uint256) {\n        return _priceOfEthOnEUR;\n    }\n\n    function updatePriceOfEth(uint256 _newPrice) public {\n        require(_admin == msg.sender);\n        _priceOfEthOnEUR = _newPrice;\n        _price = _newPrice * 0x5c84c203069aaaab / 0xde0b6b3a7640000;\n        emit PriceUpdate(_price);\n    }\n\n    function completedAt() public view returns(uint256) {\n        return _completedAt;\n    }\n\n    // ... the rest of the functions go here...\n}\n```\n\nPlease note that the decompiled code provided was not entirely clear, so this Solidity code might not be 100% correct. Also, the `version` and `campaignUrl` functions were not included as the decompiled code for those parts was not clear.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711532882,
	"id": "chatcmpl-97KB0ddcYL48g4rHJvGEfvzoY4b0J",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.18 00:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _priceOfEthOnEUR; // STORAGE[0x1]\nuint256 _state; // STORAGE[0x2]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nuint256 _totalRaised; // STORAGE[0x5]\nuint256 _totalDistributed; // STORAGE[0x6]\nuint256 _stageDistributed; // STORAGE[0x7]\nuint256 _completedAt; // STORAGE[0x8]\nuint256[] _campaignUrl; // STORAGE[0xb]\nuint256[] _version; // STORAGE[0xc]\nuint256 _admin; // STORAGE[0x0] bytes 0 to 19\nuint256 _tokenReward; // STORAGE[0x9] bytes 0 to 19\nuint256 _creator; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nLogFundingReceived(address, uint256, uint256);\nLogContributorsPayout(address, uint256);\nPriceUpdate(uint256);\nTransferAdminship(address);\nLogFundingSuccessful(uint256);\nLogBeneficiaryPaid(address);\nStageDistributed(uint8, uint256);\n\nfunction priceOfEthOnEUR() public nonPayable { \n    return _priceOfEthOnEUR;\n}\n\nfunction updatePriceOfEth(uint256 varg0) public nonPayable { \n    require(_admin == msg.sender);\n    _priceOfEthOnEUR = varg0;\n    v0 = _SafeMul(0x5c84c203069aaaab, varg0);\n    assert(0xde0b6b3a7640000);\n    _price = v0 / 0xde0b6b3a7640000;\n    emit PriceUpdate(v0 / 0xde0b6b3a7640000);\n}\n\nfunction completedAt() public nonPayable { \n    return _completedAt;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transferAdminship(address varg0) public nonPayable { \n    require(_admin == msg.sender);\n    _admin = varg0;\n    emit TransferAdminship(_admin);\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction checkIfFundingCompleteOrExpired() public nonPayable { \n    0x7fa();\n}\n\nfunction stageDistributed() public nonPayable { \n    return _stageDistributed;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction finished() public nonPayable { \n    0xaa8();\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _state <= 4);\n    return 0xff & (0xff & _state);\n}\n\nfunction payOut() public nonPayable { \n    require(_creator == msg.sender);\n    v0 = _creator.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n    emit LogBeneficiaryPaid(_creator);\n}\n\nfunction totalRaised() public nonPayable { \n    return _totalRaised;\n}\n\nfunction totalDistributed() public nonPayable { \n    return _totalDistributed;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction campaignUrl() public nonPayable { \n    v0 = new bytes[](_campaignUrl.length);\n    v1 = v2 = v0.data;\n    if (_campaignUrl.length) {\n        if (31 < _campaignUrl.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _campaignUrl.length <= v1);\n        } else {\n            MEM[v2] = _campaignUrl.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x7fa() private { \n    assert(0xff & _state <= 4);\n    if (0xff & _state != 4) {\n        assert(0xff & _state <= 4);\n        v0 = v1 = 0xff & _state == 0;\n        if (v1) {\n            assert(0x321900 + _startTime >= _startTime);\n            v0 = v2 = block.timestamp > 0x321900 + _startTime;\n        }\n        if (!v0) {\n            assert(0xff & _state <= 4);\n            v3 = v4 = 0xff & _state == 1;\n            if (v4) {\n                assert(0xa76e80 + _startTime >= _startTime);\n                v3 = v5 = block.timestamp > 0xa76e80 + _startTime;\n            }\n            if (!v3) {\n                assert(0xff & _state <= 4);\n                v6 = v7 = 0xff & _state == 2;\n                if (v7) {\n                    assert(0x120b880 + _startTime >= _startTime);\n                    v6 = v8 = block.timestamp > 0x120b880 + _startTime;\n                }\n                if (!v6) {\n                    assert(0xff & _state <= 4);\n                    v9 = v10 = 0xff & _state == 3;\n                    if (v10) {\n                        assert(0x1ea6e00 + _startTime >= _startTime);\n                        v9 = v11 = block.timestamp > 0x1ea6e00 + _startTime;\n                    }\n                    if (v9) {\n                        assert(0xff & _state <= 4);\n                        emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                        _state = 0x4 | ~0xff & _state;\n                        _completedAt = block.timestamp;\n                        emit LogFundingSuccessful(_totalRaised);\n                        0xaa8();\n                    }\n                } else {\n                    assert(0xff & _state <= 4);\n                    emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                    v12 = v13 = 2;\n                    v12 = v14 = 3;\n                    v15 = v16 = ~0xff & _state;\n                    v12 = v17 = 1;\n                }\n            } else {\n                assert(0xff & _state <= 4);\n                emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                v12 = v18 = 2;\n                v15 = v19 = ~0xff & _state;\n                v12 = v20 = 1;\n            }\n        } else {\n            assert(0xff & _state <= 4);\n            emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n            v12 = v21 = 2;\n            v12 = v22 = 1;\n            v15 = v23 = ~0xff & _state;\n        }\n        STORAGE[v12] = v12 * v12 | v15;\n        _stageDistributed = 0;\n    }\n    return ;\n}\n\nfunction 0xaa8() private { \n    assert(0xff & _state <= 4);\n    require(0xff & _state == 4);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    v2 = _creator.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v2);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.transfer(_creator, v1).gas(msg.gas - 710);\n    require(v3);\n    emit LogBeneficiaryPaid(_creator);\n    emit LogContributorsPayout(_creator, v1);\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction () public payable { \n    v0 = v1 = 0;\n    assert(0xff & _state <= 4);\n    require(0xff & _state != 4);\n    assert(msg.value + _totalRaised >= _totalRaised);\n    _totalRaised += msg.value;\n    assert(0xff & _state <= 4);\n    if (0xff & _state != 0) {\n        assert(0xff & _state <= 4);\n        if (0xff & _state != 1) {\n            assert(0xff & _state <= 4);\n            if (0xff & _state != 2) {\n                assert(0xff & _state <= 4);\n                if (0xff & _state == 3) {\n                    v0 = v2 = _SafeMul(_price, msg.value);\n                    assert(v2 + _stageDistributed >= _stageDistributed);\n                    require(v2 + _stageDistributed <= 0x295be96e640669720000000);\n                }\n            } else {\n                v0 = v3 = _SafeMul(_price, msg.value);\n            }\n        } else {\n            v4 = _SafeMul(_price, msg.value);\n            v5 = _SafeMul(15, v4);\n            assert(10);\n            v0 = v5 / 10;\n            goto 0x421B0xed;\n        }\n        v6 = 0x19d971e4fe8401e74000000;\n        v7 = v0 + _stageDistributed;\n        assert(v7 >= _stageDistributed);\n        goto 0x3beB0xed;\n    } else {\n        v8 = _SafeMul(_price, msg.value);\n        v0 = v9 = _SafeMul(4, v8);\n        v6 = v10 = 0xa56fa5b99019a5c8000000;\n        v7 = v11 = v9 + _stageDistributed;\n        assert(v11 >= _stageDistributed);\n    }\n    require(v7 <= v6);\n    assert(v0 + _totalDistributed >= _totalDistributed);\n    _totalDistributed += v0;\n    assert(v0 + _stageDistributed >= _stageDistributed);\n    _stageDistributed += v0;\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v12, v13 = _tokenReward.transfer(msg.sender, v0).gas(msg.gas - 710);\n    require(v12);\n    emit LogFundingReceived(msg.sender, msg.value, _totalRaised);\n    emit LogContributorsPayout(msg.sender, v0);\n    0x7fa();\n}\n\nfunction creator() public nonPayable { \n    return _creator;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x2d05d3f) {\n            creator();\n        } else if (0x2af5cfdd == v0) {\n            priceOfEthOnEUR();\n        } else if (0x33b8c29d == v0) {\n            updatePriceOfEth(uint256);\n        } else if (0x38771242 == v0) {\n            completedAt();\n        } else if (0x54fd4d50 == v0) {\n            version();\n        } else if (0x5be7cc16 == v0) {\n            transferAdminship(address);\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x86f32586 == v0) {\n            checkIfFundingCompleteOrExpired();\n        } else if (0x9beef73f == v0) {\n            stageDistributed();\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xbef4876b == v0) {\n            finished();\n        } else if (0xc19d93fb == v0) {\n            state();\n        } else if (0xc2052403 == v0) {\n            payOut();\n        } else if (0xc5c4744c == v0) {\n            totalRaised();\n        } else if (0xd7bb99ba != v0) {\n            if (0xefca2eed == v0) {\n                totalDistributed();\n            } else if (0xf851a440 == v0) {\n                admin();\n            } else if (0xfa4f5511 == v0) {\n                campaignUrl();\n            }\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.18 00:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _priceOfEthOnEUR; // STORAGE[0x1]\nuint256 _state; // STORAGE[0x2]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nuint256 _totalRaised; // STORAGE[0x5]\nuint256 _totalDistributed; // STORAGE[0x6]\nuint256 _stageDistributed; // STORAGE[0x7]\nuint256 _completedAt; // STORAGE[0x8]\nuint256[] _campaignUrl; // STORAGE[0xb]\nuint256[] _version; // STORAGE[0xc]\nuint256 _admin; // STORAGE[0x0] bytes 0 to 19\nuint256 _tokenReward; // STORAGE[0x9] bytes 0 to 19\nuint256 _creator; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nLogFundingReceived(address, uint256, uint256);\nLogContributorsPayout(address, uint256);\nPriceUpdate(uint256);\nTransferAdminship(address);\nLogFundingSuccessful(uint256);\nLogBeneficiaryPaid(address);\nStageDistributed(uint8, uint256);\n\nfunction priceOfEthOnEUR() public nonPayable { \n    return _priceOfEthOnEUR;\n}\n\nfunction updatePriceOfEth(uint256 varg0) public nonPayable { \n    require(_admin == msg.sender);\n    _priceOfEthOnEUR = varg0;\n    v0 = _SafeMul(0x5c84c203069aaaab, varg0);\n    assert(0xde0b6b3a7640000);\n    _price = v0 / 0xde0b6b3a7640000;\n    emit PriceUpdate(v0 / 0xde0b6b3a7640000);\n}\n\nfunction completedAt() public nonPayable { \n    return _completedAt;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transferAdminship(address varg0) public nonPayable { \n    require(_admin == msg.sender);\n    _admin = varg0;\n    emit TransferAdminship(_admin);\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction checkIfFundingCompleteOrExpired() public nonPayable { \n    0x7fa();\n}\n\nfunction stageDistributed() public nonPayable { \n    return _stageDistributed;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction finished() public nonPayable { \n    0xaa8();\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _state <= 4);\n    return 0xff & (0xff & _state);\n}\n\nfunction payOut() public nonPayable { \n    require(_creator == msg.sender);\n    v0 = _creator.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n    emit LogBeneficiaryPaid(_creator);\n}\n\nfunction totalRaised() public nonPayable { \n    return _totalRaised;\n}\n\nfunction totalDistributed() public nonPayable { \n    return _totalDistributed;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction campaignUrl() public nonPayable { \n    v0 = new bytes[](_campaignUrl.length);\n    v1 = v2 = v0.data;\n    if (_campaignUrl.length) {\n        if (31 < _campaignUrl.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _campaignUrl.length <= v1);\n        } else {\n            MEM[v2] = _campaignUrl.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x7fa() private { \n    assert(0xff & _state <= 4);\n    if (0xff & _state != 4) {\n        assert(0xff & _state <= 4);\n        v0 = v1 = 0xff & _state == 0;\n        if (v1) {\n            assert(0x321900 + _startTime >= _startTime);\n            v0 = v2 = block.timestamp > 0x321900 + _startTime;\n        }\n        if (!v0) {\n            assert(0xff & _state <= 4);\n            v3 = v4 = 0xff & _state == 1;\n            if (v4) {\n                assert(0xa76e80 + _startTime >= _startTime);\n                v3 = v5 = block.timestamp > 0xa76e80 + _startTime;\n            }\n            if (!v3) {\n                assert(0xff & _state <= 4);\n                v6 = v7 = 0xff & _state == 2;\n                if (v7) {\n                    assert(0x120b880 + _startTime >= _startTime);\n                    v6 = v8 = block.timestamp > 0x120b880 + _startTime;\n                }\n                if (!v6) {\n                    assert(0xff & _state <= 4);\n                    v9 = v10 = 0xff & _state == 3;\n                    if (v10) {\n                        assert(0x1ea6e00 + _startTime >= _startTime);\n                        v9 = v11 = block.timestamp > 0x1ea6e00 + _startTime;\n                    }\n                    if (v9) {\n                        assert(0xff & _state <= 4);\n                        emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                        _state = 0x4 | ~0xff & _state;\n                        _completedAt = block.timestamp;\n                        emit LogFundingSuccessful(_totalRaised);\n                        0xaa8();\n                    }\n                } else {\n                    assert(0xff & _state <= 4);\n                    emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                    v12 = v13 = 2;\n                    v12 = v14 = 3;\n                    v15 = v16 = ~0xff & _state;\n                    v12 = v17 = 1;\n                }\n            } else {\n                assert(0xff & _state <= 4);\n                emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                v12 = v18 = 2;\n                v15 = v19 = ~0xff & _state;\n                v12 = v20 = 1;\n            }\n        } else {\n            assert(0xff & _state <= 4);\n            emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n            v12 = v21 = 2;\n            v12 = v22 = 1;\n            v15 = v23 = ~0xff & _state;\n        }\n        STORAGE[v12] = v12 * v12 | v15;\n        _stageDistributed = 0;\n    }\n    return ;\n}\n\nfunction 0xaa8() private { \n    assert(0xff & _state <= 4);\n    require(0xff & _state == 4);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    v2 = _creator.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v2);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.transfer(_creator, v1).gas(msg.gas - 710);\n    require(v3);\n    emit LogBeneficiaryPaid(_creator);\n    emit LogContributorsPayout(_creator, v1);\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction () public payable { \n    v0 = v1 = 0;\n    assert(0xff & _state <= 4);\n    require(0xff & _state != 4);\n    assert(msg.value + _totalRaised >= _totalRaised);\n    _totalRaised += msg.value;\n    assert(0xff & _state <= 4);\n    if (0xff & _state != 0) {\n        assert(0xff & _state <= 4);\n        if (0xff & _state != 1) {\n            assert(0xff & _state <= 4);\n            if (0xff & _state != 2) {\n                assert(0xff & _state <= 4);\n                if (0xff & _state == 3) {\n                    v0 = v2 = _SafeMul(_price, msg.value);\n                    assert(v2 + _stageDistributed >= _stageDistributed);\n                    require(v2 + _stageDistributed <= 0x295be96e640669720000000);\n                }\n            } else {\n                v0 = v3 = _SafeMul(_price, msg.value);\n            }\n        } else {\n            v4 = _SafeMul(_price, msg.value);\n            v5 = _SafeMul(15, v4);\n            assert(10);\n            v0 = v5 / 10;\n            goto 0x421B0xed;\n        }\n        v6 = 0x19d971e4fe8401e74000000;\n        v7 = v0 + _stageDistributed;\n        assert(v7 >= _stageDistributed);\n        goto 0x3beB0xed;\n    } else {\n        v8 = _SafeMul(_price, msg.value);\n        v0 = v9 = _SafeMul(4, v8);\n        v6 = v10 = 0xa56fa5b99019a5c8000000;\n        v7 = v11 = v9 + _stageDistributed;\n        assert(v11 >= _stageDistributed);\n    }\n    require(v7 <= v6);\n    assert(v0 + _totalDistributed >= _totalDistributed);\n    _totalDistributed += v0;\n    assert(v0 + _stageDistributed >= _stageDistributed);\n    _stageDistributed += v0;\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v12, v13 = _tokenReward.transfer(msg.sender, v0).gas(msg.gas - 710);\n    require(v12);\n    emit LogFundingReceived(msg.sender, msg.value, _totalRaised);\n    emit LogContributorsPayout(msg.sender, v0);\n    0x7fa();\n}\n\nfunction creator() public nonPayable { \n    return _creator;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x2d05d3f) {\n            creator();\n        } else if (0x2af5cfdd == v0) {\n            priceOfEthOnEUR();\n        } else if (0x33b8c29d == v0) {\n            updatePriceOfEth(uint256);\n        } else if (0x38771242 == v0) {\n            completedAt();\n        } else if (0x54fd4d50 == v0) {\n            version();\n        } else if (0x5be7cc16 == v0) {\n            transferAdminship(address);\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x86f32586 == v0) {\n            checkIfFundingCompleteOrExpired();\n        } else if (0x9beef73f == v0) {\n            stageDistributed();\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xbef4876b == v0) {\n            finished();\n        } else if (0xc19d93fb == v0) {\n            state();\n        } else if (0xc2052403 == v0) {\n            payOut();\n        } else if (0xc5c4744c == v0) {\n            totalRaised();\n        } else if (0xd7bb99ba != v0) {\n            if (0xefca2eed == v0) {\n                totalDistributed();\n            } else if (0xf851a440 == v0) {\n                admin();\n            } else if (0xfa4f5511 == v0) {\n                campaignUrl();\n            }\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.18 00:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _priceOfEthOnEUR; // STORAGE[0x1]\nuint256 _state; // STORAGE[0x2]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nuint256 _totalRaised; // STORAGE[0x5]\nuint256 _totalDistributed; // STORAGE[0x6]\nuint256 _stageDistributed; // STORAGE[0x7]\nuint256 _completedAt; // STORAGE[0x8]\nuint256[] _campaignUrl; // STORAGE[0xb]\nuint256[] _version; // STORAGE[0xc]\nuint256 _admin; // STORAGE[0x0] bytes 0 to 19\nuint256 _tokenReward; // STORAGE[0x9] bytes 0 to 19\nuint256 _creator; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nLogFundingReceived(address, uint256, uint256);\nLogContributorsPayout(address, uint256);\nPriceUpdate(uint256);\nTransferAdminship(address);\nLogFundingSuccessful(uint256);\nLogBeneficiaryPaid(address);\nStageDistributed(uint8, uint256);\n\nfunction priceOfEthOnEUR() public nonPayable { \n    return _priceOfEthOnEUR;\n}\n\nfunction updatePriceOfEth(uint256 varg0) public nonPayable { \n    require(_admin == msg.sender);\n    _priceOfEthOnEUR = varg0;\n    v0 = _SafeMul(0x5c84c203069aaaab, varg0);\n    assert(0xde0b6b3a7640000);\n    _price = v0 / 0xde0b6b3a7640000;\n    emit PriceUpdate(v0 / 0xde0b6b3a7640000);\n}\n\nfunction completedAt() public nonPayable { \n    return _completedAt;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transferAdminship(address varg0) public nonPayable { \n    require(_admin == msg.sender);\n    _admin = varg0;\n    emit TransferAdminship(_admin);\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction checkIfFundingCompleteOrExpired() public nonPayable { \n    0x7fa();\n}\n\nfunction stageDistributed() public nonPayable { \n    return _stageDistributed;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction finished() public nonPayable { \n    0xaa8();\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _state <= 4);\n    return 0xff & (0xff & _state);\n}\n\nfunction payOut() public nonPayable { \n    require(_creator == msg.sender);\n    v0 = _creator.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n    emit LogBeneficiaryPaid(_creator);\n}\n\nfunction totalRaised() public nonPayable { \n    return _totalRaised;\n}\n\nfunction totalDistributed() public nonPayable { \n    return _totalDistributed;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction campaignUrl() public nonPayable { \n    v0 = new bytes[](_campaignUrl.length);\n    v1 = v2 = v0.data;\n    if (_campaignUrl.length) {\n        if (31 < _campaignUrl.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _campaignUrl.length <= v1);\n        } else {\n            MEM[v2] = _campaignUrl.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x7fa() private { \n    assert(0xff & _state <= 4);\n    if (0xff & _state != 4) {\n        assert(0xff & _state <= 4);\n        v0 = v1 = 0xff & _state == 0;\n        if (v1) {\n            assert(0x321900 + _startTime >= _startTime);\n            v0 = v2 = block.timestamp > 0x321900 + _startTime;\n        }\n        if (!v0) {\n            assert(0xff & _state <= 4);\n            v3 = v4 = 0xff & _state == 1;\n            if (v4) {\n                assert(0xa76e80 + _startTime >= _startTime);\n                v3 = v5 = block.timestamp > 0xa76e80 + _startTime;\n            }\n            if (!v3) {\n                assert(0xff & _state <= 4);\n                v6 = v7 = 0xff & _state == 2;\n                if (v7) {\n                    assert(0x120b880 + _startTime >= _startTime);\n                    v6 = v8 = block.timestamp > 0x120b880 + _startTime;\n                }\n                if (!v6) {\n                    assert(0xff & _state <= 4);\n                    v9 = v10 = 0xff & _state == 3;\n                    if (v10) {\n                        assert(0x1ea6e00 + _startTime >= _startTime);\n                        v9 = v11 = block.timestamp > 0x1ea6e00 + _startTime;\n                    }\n                    if (v9) {\n                        assert(0xff & _state <= 4);\n                        emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                        _state = 0x4 | ~0xff & _state;\n                        _completedAt = block.timestamp;\n                        emit LogFundingSuccessful(_totalRaised);\n                        0xaa8();\n                    }\n                } else {\n                    assert(0xff & _state <= 4);\n                    emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                    v12 = v13 = 2;\n                    v12 = v14 = 3;\n                    v15 = v16 = ~0xff & _state;\n                    v12 = v17 = 1;\n                }\n            } else {\n                assert(0xff & _state <= 4);\n                emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n                v12 = v18 = 2;\n                v15 = v19 = ~0xff & _state;\n                v12 = v20 = 1;\n            }\n        } else {\n            assert(0xff & _state <= 4);\n            emit StageDistributed(0xff & (0xff & _state), _stageDistributed);\n            v12 = v21 = 2;\n            v12 = v22 = 1;\n            v15 = v23 = ~0xff & _state;\n        }\n        STORAGE[v12] = v12 * v12 | v15;\n        _stageDistributed = 0;\n    }\n    return ;\n}\n\nfunction 0xaa8() private { \n    assert(0xff & _state <= 4);\n    require(0xff & _state == 4);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    v2 = _creator.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v2);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.transfer(_creator, v1).gas(msg.gas - 710);\n    require(v3);\n    emit LogBeneficiaryPaid(_creator);\n    emit LogContributorsPayout(_creator, v1);\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction () public payable { \n    v0 = v1 = 0;\n    assert(0xff & _state <= 4);\n    require(0xff & _state != 4);\n    assert(msg.value + _totalRaised >= _totalRaised);\n    _totalRaised += msg.value;\n    assert(0xff & _state <= 4);\n    if (0xff & _state != 0) {\n        assert(0xff & _state <= 4);\n        if (0xff & _state != 1) {\n            assert(0xff & _state <= 4);\n            if (0xff & _state != 2) {\n                assert(0xff & _state <= 4);\n                if (0xff & _state == 3) {\n                    v0 = v2 = _SafeMul(_price, msg.value);\n                    assert(v2 + _stageDistributed >= _stageDistributed);\n                    require(v2 + _stageDistributed <= 0x295be96e640669720000000);\n                }\n            } else {\n                v0 = v3 = _SafeMul(_price, msg.value);\n            }\n        } else {\n            v4 = _SafeMul(_price, msg.value);\n            v5 = _SafeMul(15, v4);\n            assert(10);\n            v0 = v5 / 10;\n            goto 0x421B0xed;\n        }\n        v6 = 0x19d971e4fe8401e74000000;\n        v7 = v0 + _stageDistributed;\n        assert(v7 >= _stageDistributed);\n        goto 0x3beB0xed;\n    } else {\n        v8 = _SafeMul(_price, msg.value);\n        v0 = v9 = _SafeMul(4, v8);\n        v6 = v10 = 0xa56fa5b99019a5c8000000;\n        v7 = v11 = v9 + _stageDistributed;\n        assert(v11 >= _stageDistributed);\n    }\n    require(v7 <= v6);\n    assert(v0 + _totalDistributed >= _totalDistributed);\n    _totalDistributed += v0;\n    assert(v0 + _stageDistributed >= _stageDistributed);\n    _stageDistributed += v0;\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v12, v13 = _tokenReward.transfer(msg.sender, v0).gas(msg.gas - 710);\n    require(v12);\n    emit LogFundingReceived(msg.sender, msg.value, _totalRaised);\n    emit LogContributorsPayout(msg.sender, v0);\n    0x7fa();\n}\n\nfunction creator() public nonPayable { \n    return _creator;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x2d05d3f) {\n            creator();\n        } else if (0x2af5cfdd == v0) {\n            priceOfEthOnEUR();\n        } else if (0x33b8c29d == v0) {\n            updatePriceOfEth(uint256);\n        } else if (0x38771242 == v0) {\n            completedAt();\n        } else if (0x54fd4d50 == v0) {\n            version();\n        } else if (0x5be7cc16 == v0) {\n            transferAdminship(address);\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x86f32586 == v0) {\n            checkIfFundingCompleteOrExpired();\n        } else if (0x9beef73f == v0) {\n            stageDistributed();\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xbef4876b == v0) {\n            finished();\n        } else if (0xc19d93fb == v0) {\n            state();\n        } else if (0xc2052403 == v0) {\n            payOut();\n        } else if (0xc5c4744c == v0) {\n            totalRaised();\n        } else if (0xd7bb99ba != v0) {\n            if (0xefca2eed == v0) {\n                totalDistributed();\n            } else if (0xf851a440 == v0) {\n                admin();\n            } else if (0xfa4f5511 == v0) {\n                campaignUrl();\n            }\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 117.79750800132751,
	"usage": {
		"completion_tokens": 435,
		"prompt_tokens": 3319,
		"total_tokens": 3754
	}
}