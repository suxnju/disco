{
	"address": "0xe64aa1e4301d85ecaccfc15e4af887a1fe6f5f56",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity contract code that represents the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256[] private _warning;\n    uint256 private _closeBlock;\n    uint256 private _totalNTD;\n    uint256 private _totalWithdrew;\n    mapping (address => uint256) private _myTotalNTD;\n    mapping (address => uint256) private _myTotalWithdrew;\n    address private _owner;\n\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function totalNTD() public view returns(uint256) {\n        return _totalNTD;\n    }\n\n    function ContractBalance() public view returns(uint256) {\n        return address(this).balance;\n    }\n\n    function Unregister(address user, uint256 value) public {\n        require(_owner == msg.sender);\n        require(block.number <= _closeBlock);\n        require(_myTotalNTD[user] >= value);\n\n        _myTotalNTD[user] -= value;\n        _totalNTD -= value;\n    }\n\n    function usersWithdrew(address user) public view returns(uint256) {\n        return _myTotalWithdrew[user];\n    }\n\n    function Withdraw() public {\n        require(_myTotalNTD[msg.sender] > 0);\n        require(block.number > _closeBlock);\n        uint256 v0 = (address(this).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender];\n        require(v0 > 0);\n\n        _totalWithdrew += v0;\n        _myTotalWithdrew[msg.sender] += v0;\n        \n        (bool success, ) = msg.sender.call{value: v0, gas: 2300 * (v0 == 0 ? 0 : 1)}(\"\");\n        require(success);\n    }\n\n    function MyTotalWithdrew() public view returns(uint256) {\n        return _myTotalWithdrew[msg.sender];\n    }\n\n    function usersNTD(address user) public view returns(uint256) {\n        return _myTotalNTD[user];\n    }\n\n    function Cashing(address user, uint256 value) public {\n        require(_myTotalNTD[msg.sender] > 0);\n        require(block.number > _closeBlock);\n        require(value <= 1000 && value > 0);\n\n        _myTotalNTD[msg.sender] -= value * _myTotalNTD[msg.sender] / 1000;\n        _myTotalWithdrew[msg.sender] -= value * _myTotalWithdrew[msg.sender] / 1000;\n        _myTotalWithdrew[user] += value * _myTotalNTD[msg.sender] / 1000;\n        _myTotalWithdrew[user] += value * _myTotalWithdrew[msg.sender] / 1000;\n    }\n\n    function closeBlock() public view returns(uint256) {\n        return _closeBlock;\n    }\n\n    function owner() public view returns(address) {\n        return _owner;\n    }\n\n    function totalWithdrew() public view returns(uint256) {\n        return _totalWithdrew;\n    }\n\n    function warning() public view returns(uint256[] memory) {\n        return _warning;\n    }\n\n    function MyTotalNTD() public view returns(uint256) {\n        return _myTotalNTD[msg.sender];\n    }\n\n    function ContractTotalMined() public view returns(uint256) {\n        return address(this).balance + _totalWithdrew;\n    }\n\n    function Register(address user, uint256 value) public {\n        require(_owner == msg.sender);\n        require(block.number <= _closeBlock);\n\n        _myTotalNTD[user] += value;\n        _totalNTD += value;\n    }\n}\n```\n\nNote: This contract doesn't include the `__function_selector__` function because Solidity automatically generates function selectors for all public and external functions in the contract. Also, `assert` statements have been replaced with `require` for better use of gas.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457819,
	"id": "chatcmpl-8R3BzFEjKQj0P6NlqGVgrtfCMCWg7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 07:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _warning; // STORAGE[0x0]\nuint256 _closeBlock; // STORAGE[0x2]\nuint256 _totalNTD; // STORAGE[0x3]\nuint256 _totalWithdrew; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _myTotalNTD; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _myTotalWithdrew; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction totalNTD() public payable { \n    assert(!msg.value);\n    return _totalNTD;\n}\n\nfunction ContractBalance() public payable { \n    assert(!msg.value);\n    return (address(this)).balance;\n}\n\nfunction Unregister(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_owner == msg.sender);\n    assert(block.number <= _closeBlock);\n    assert(_myTotalNTD[varg0] >= varg1);\n    _myTotalNTD[varg0] = _myTotalNTD[varg0] - varg1;\n    _totalNTD = _totalNTD - varg1;\n}\n\nfunction usersWithdrew(address varg0) public payable { \n    assert(!msg.value);\n    return _myTotalWithdrew[varg0];\n}\n\nfunction Withdraw() public payable { \n    assert(!msg.value);\n    assert(_myTotalNTD[msg.sender]);\n    assert(block.number > _closeBlock);\n    assert(_totalNTD);\n    v0 = ((address(this)).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender];\n    _totalWithdrew += v0;\n    _myTotalWithdrew[msg.sender] += v0;\n    assert(v0 > 0);\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    assert(v1);\n}\n\nfunction MyTotalWithdrew() public payable { \n    assert(!msg.value);\n    return _myTotalWithdrew[msg.sender];\n}\n\nfunction usersNTD(address varg0) public payable { \n    assert(!msg.value);\n    return _myTotalNTD[varg0];\n}\n\nfunction Cashing(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_myTotalNTD[msg.sender]);\n    assert(block.number > _closeBlock);\n    assert(varg1 <= 1000);\n    assert(varg1 > 0);\n    assert(_totalNTD);\n    assert(_totalNTD);\n    assert(!(((address(this)).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender]));\n    assert(!(((address(this)).balance + _totalWithdrew) * _myTotalWithdrew[varg0] / _totalNTD - _myTotalWithdrew[varg0]));\n    _myTotalNTD[msg.sender] = _myTotalNTD[msg.sender] - varg1 * _myTotalNTD[msg.sender] / 1000;\n    _myTotalWithdrew[msg.sender] = _myTotalWithdrew[msg.sender] - varg1 * _myTotalWithdrew[msg.sender] / 1000;\n    _myTotalWithdrew[varg0] += varg1 * _myTotalNTD[msg.sender] / 1000;\n    _myTotalWithdrew[varg0] += varg1 * _myTotalWithdrew[msg.sender] / 1000;\n}\n\nfunction closeBlock() public payable { \n    assert(!msg.value);\n    return _closeBlock;\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction totalWithdrew() public payable { \n    assert(!msg.value);\n    return _totalWithdrew;\n}\n\nfunction warning() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) {\n        if (31 < (_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _warning.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v10 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v11 = v12 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v12 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v12 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction MyTotalNTD() public payable { \n    assert(!msg.value);\n    return _myTotalNTD[msg.sender];\n}\n\nfunction ContractTotalMined() public payable { \n    assert(!msg.value);\n    return (address(this)).balance + _totalWithdrew;\n}\n\nfunction Register(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_owner == msg.sender);\n    assert(block.number <= _closeBlock);\n    _myTotalNTD[varg0] += varg1;\n    _totalNTD += varg1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x7dc6ab) {\n            Register(address,uint256);\n        } else if (0x1870a73a == function_selector) {\n            totalNTD();\n        } else if (0x3b668059 == function_selector) {\n            ContractBalance();\n        } else if (0x46d17c3a == function_selector) {\n            Unregister(address,uint256);\n        } else if (0x56ff2318 == function_selector) {\n            usersWithdrew(address);\n        } else if (0x57ea89b6 == function_selector) {\n            Withdraw();\n        } else if (0x624a8bc3 == function_selector) {\n            MyTotalWithdrew();\n        } else if (0x7748b07e == function_selector) {\n            usersNTD(address);\n        } else if (0x7f279a73 == function_selector) {\n            Cashing(address,uint256);\n        } else if (0x8cdcbdef == function_selector) {\n            closeBlock();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc768ac01 == function_selector) {\n            totalWithdrew();\n        } else if (0xcf0682bc == function_selector) {\n            warning();\n        } else if (0xf20431c8 == function_selector) {\n            MyTotalNTD();\n        } else if (0xf6b39b3c == function_selector) {\n            ContractTotalMined();\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 07:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _warning; // STORAGE[0x0]\nuint256 _closeBlock; // STORAGE[0x2]\nuint256 _totalNTD; // STORAGE[0x3]\nuint256 _totalWithdrew; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _myTotalNTD; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _myTotalWithdrew; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction totalNTD() public payable { \n    assert(!msg.value);\n    return _totalNTD;\n}\n\nfunction ContractBalance() public payable { \n    assert(!msg.value);\n    return (address(this)).balance;\n}\n\nfunction Unregister(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_owner == msg.sender);\n    assert(block.number <= _closeBlock);\n    assert(_myTotalNTD[varg0] >= varg1);\n    _myTotalNTD[varg0] = _myTotalNTD[varg0] - varg1;\n    _totalNTD = _totalNTD - varg1;\n}\n\nfunction usersWithdrew(address varg0) public payable { \n    assert(!msg.value);\n    return _myTotalWithdrew[varg0];\n}\n\nfunction Withdraw() public payable { \n    assert(!msg.value);\n    assert(_myTotalNTD[msg.sender]);\n    assert(block.number > _closeBlock);\n    assert(_totalNTD);\n    v0 = ((address(this)).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender];\n    _totalWithdrew += v0;\n    _myTotalWithdrew[msg.sender] += v0;\n    assert(v0 > 0);\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    assert(v1);\n}\n\nfunction MyTotalWithdrew() public payable { \n    assert(!msg.value);\n    return _myTotalWithdrew[msg.sender];\n}\n\nfunction usersNTD(address varg0) public payable { \n    assert(!msg.value);\n    return _myTotalNTD[varg0];\n}\n\nfunction Cashing(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_myTotalNTD[msg.sender]);\n    assert(block.number > _closeBlock);\n    assert(varg1 <= 1000);\n    assert(varg1 > 0);\n    assert(_totalNTD);\n    assert(_totalNTD);\n    assert(!(((address(this)).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender]));\n    assert(!(((address(this)).balance + _totalWithdrew) * _myTotalWithdrew[varg0] / _totalNTD - _myTotalWithdrew[varg0]));\n    _myTotalNTD[msg.sender] = _myTotalNTD[msg.sender] - varg1 * _myTotalNTD[msg.sender] / 1000;\n    _myTotalWithdrew[msg.sender] = _myTotalWithdrew[msg.sender] - varg1 * _myTotalWithdrew[msg.sender] / 1000;\n    _myTotalWithdrew[varg0] += varg1 * _myTotalNTD[msg.sender] / 1000;\n    _myTotalWithdrew[varg0] += varg1 * _myTotalWithdrew[msg.sender] / 1000;\n}\n\nfunction closeBlock() public payable { \n    assert(!msg.value);\n    return _closeBlock;\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction totalWithdrew() public payable { \n    assert(!msg.value);\n    return _totalWithdrew;\n}\n\nfunction warning() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) {\n        if (31 < (_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _warning.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v10 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v11 = v12 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v12 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v12 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction MyTotalNTD() public payable { \n    assert(!msg.value);\n    return _myTotalNTD[msg.sender];\n}\n\nfunction ContractTotalMined() public payable { \n    assert(!msg.value);\n    return (address(this)).balance + _totalWithdrew;\n}\n\nfunction Register(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_owner == msg.sender);\n    assert(block.number <= _closeBlock);\n    _myTotalNTD[varg0] += varg1;\n    _totalNTD += varg1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x7dc6ab) {\n            Register(address,uint256);\n        } else if (0x1870a73a == function_selector) {\n            totalNTD();\n        } else if (0x3b668059 == function_selector) {\n            ContractBalance();\n        } else if (0x46d17c3a == function_selector) {\n            Unregister(address,uint256);\n        } else if (0x56ff2318 == function_selector) {\n            usersWithdrew(address);\n        } else if (0x57ea89b6 == function_selector) {\n            Withdraw();\n        } else if (0x624a8bc3 == function_selector) {\n            MyTotalWithdrew();\n        } else if (0x7748b07e == function_selector) {\n            usersNTD(address);\n        } else if (0x7f279a73 == function_selector) {\n            Cashing(address,uint256);\n        } else if (0x8cdcbdef == function_selector) {\n            closeBlock();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc768ac01 == function_selector) {\n            totalWithdrew();\n        } else if (0xcf0682bc == function_selector) {\n            warning();\n        } else if (0xf20431c8 == function_selector) {\n            MyTotalNTD();\n        } else if (0xf6b39b3c == function_selector) {\n            ContractTotalMined();\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 07:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _warning; // STORAGE[0x0]\nuint256 _closeBlock; // STORAGE[0x2]\nuint256 _totalNTD; // STORAGE[0x3]\nuint256 _totalWithdrew; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _myTotalNTD; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _myTotalWithdrew; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction totalNTD() public payable { \n    assert(!msg.value);\n    return _totalNTD;\n}\n\nfunction ContractBalance() public payable { \n    assert(!msg.value);\n    return (address(this)).balance;\n}\n\nfunction Unregister(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_owner == msg.sender);\n    assert(block.number <= _closeBlock);\n    assert(_myTotalNTD[varg0] >= varg1);\n    _myTotalNTD[varg0] = _myTotalNTD[varg0] - varg1;\n    _totalNTD = _totalNTD - varg1;\n}\n\nfunction usersWithdrew(address varg0) public payable { \n    assert(!msg.value);\n    return _myTotalWithdrew[varg0];\n}\n\nfunction Withdraw() public payable { \n    assert(!msg.value);\n    assert(_myTotalNTD[msg.sender]);\n    assert(block.number > _closeBlock);\n    assert(_totalNTD);\n    v0 = ((address(this)).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender];\n    _totalWithdrew += v0;\n    _myTotalWithdrew[msg.sender] += v0;\n    assert(v0 > 0);\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    assert(v1);\n}\n\nfunction MyTotalWithdrew() public payable { \n    assert(!msg.value);\n    return _myTotalWithdrew[msg.sender];\n}\n\nfunction usersNTD(address varg0) public payable { \n    assert(!msg.value);\n    return _myTotalNTD[varg0];\n}\n\nfunction Cashing(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_myTotalNTD[msg.sender]);\n    assert(block.number > _closeBlock);\n    assert(varg1 <= 1000);\n    assert(varg1 > 0);\n    assert(_totalNTD);\n    assert(_totalNTD);\n    assert(!(((address(this)).balance + _totalWithdrew) * _myTotalNTD[msg.sender] / _totalNTD - _myTotalWithdrew[msg.sender]));\n    assert(!(((address(this)).balance + _totalWithdrew) * _myTotalWithdrew[varg0] / _totalNTD - _myTotalWithdrew[varg0]));\n    _myTotalNTD[msg.sender] = _myTotalNTD[msg.sender] - varg1 * _myTotalNTD[msg.sender] / 1000;\n    _myTotalWithdrew[msg.sender] = _myTotalWithdrew[msg.sender] - varg1 * _myTotalWithdrew[msg.sender] / 1000;\n    _myTotalWithdrew[varg0] += varg1 * _myTotalNTD[msg.sender] / 1000;\n    _myTotalWithdrew[varg0] += varg1 * _myTotalWithdrew[msg.sender] / 1000;\n}\n\nfunction closeBlock() public payable { \n    assert(!msg.value);\n    return _closeBlock;\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction totalWithdrew() public payable { \n    assert(!msg.value);\n    return _totalWithdrew;\n}\n\nfunction warning() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) {\n        if (31 < (_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_warning.length & ~0 + (!(_warning.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _warning.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v10 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v11 = v12 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v12 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v12 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction MyTotalNTD() public payable { \n    assert(!msg.value);\n    return _myTotalNTD[msg.sender];\n}\n\nfunction ContractTotalMined() public payable { \n    assert(!msg.value);\n    return (address(this)).balance + _totalWithdrew;\n}\n\nfunction Register(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    assert(_owner == msg.sender);\n    assert(block.number <= _closeBlock);\n    _myTotalNTD[varg0] += varg1;\n    _totalNTD += varg1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x7dc6ab) {\n            Register(address,uint256);\n        } else if (0x1870a73a == function_selector) {\n            totalNTD();\n        } else if (0x3b668059 == function_selector) {\n            ContractBalance();\n        } else if (0x46d17c3a == function_selector) {\n            Unregister(address,uint256);\n        } else if (0x56ff2318 == function_selector) {\n            usersWithdrew(address);\n        } else if (0x57ea89b6 == function_selector) {\n            Withdraw();\n        } else if (0x624a8bc3 == function_selector) {\n            MyTotalWithdrew();\n        } else if (0x7748b07e == function_selector) {\n            usersNTD(address);\n        } else if (0x7f279a73 == function_selector) {\n            Cashing(address,uint256);\n        } else if (0x8cdcbdef == function_selector) {\n            closeBlock();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc768ac01 == function_selector) {\n            totalWithdrew();\n        } else if (0xcf0682bc == function_selector) {\n            warning();\n        } else if (0xf20431c8 == function_selector) {\n            MyTotalNTD();\n        } else if (0xf6b39b3c == function_selector) {\n            ContractTotalMined();\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 34.455671072006226,
	"usage": {
		"completion_tokens": 846,
		"prompt_tokens": 1847,
		"total_tokens": 2693
	}
}