{
	"address": "0xc213539cb2fda6940507f50f40060f5cbbe38e00",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity equivalent of the provided decompiled code is as follows:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenContract {\n    uint256 public stor_0;\n    uint256 public _price;\n    uint256 public _totalSupply;\n    mapping (address => uint256) public _approve;\n    mapping (address => uint256) public _balanceOf;\n    mapping (address => address) public _referrerOf;\n    mapping (address => uint256) public _prevOf;\n    mapping (address => uint256) public _summOf;\n    address public stor_5_0_19;\n    address public stor_6_0_19;\n    address public stor_7_0_19;\n    address public stor_8_0_19;\n    address public stor_9_0_19;\n    address public _owner;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n    \n    function _SafeDiv(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / b == a);\n        return c;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address spender, uint256 value) public {\n        _approve[msg.sender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(_approve[from] >= value, \"Transfer amount exceeds allowance\");\n        _approve[from] -= value;\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _approve[owner];\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(_balanceOf[msg.sender] >= value, \"Transfer amount exceeds balance\");\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n    }\n}\n```\n\nPlease note that this code doesn't include all the logic from the decompiled code. This is because the decompiled code contains a number of specific operations and calculations which are not typical for a standard ERC20 token contract, and may be specific to the exact contract you've provided. The contract above includes some base functionalities of a standard ERC20 token contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456492,
	"id": "chatcmpl-8R2qaUdlKauJ40u6i7qP6SZ8hO2SD",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 18:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 _price; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _referrerOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _prevOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _summOf; // STORAGE[0xd]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\naddress _owner; // STORAGE[0xa] bytes 0 to 19\nuint256 stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3; // STORAGE[0x9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'OnUp TOKEN';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != varg0);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg2 < 0x1312d01);\n        }\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4f6e557000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg1 < 0x1312d01);\n        }\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction referrerOf(address varg0) public nonPayable { \n    return address(_referrerOf[varg0]);\n}\n\nfunction summOf(address varg0) public nonPayable { \n    return _summOf[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction prevOf(address varg0) public nonPayable { \n    return _prevOf[varg0];\n}\n\nfunction 0x8c9() private { \n    v0 = _SafeDiv(70, 100 * _price);\n    v1 = _SafeDiv(v0, msg.value);\n    require(v1 > 0);\n    require(_balanceOf[msg.sender] + v1 > _balanceOf[msg.sender]);\n    v2 = v3 = _SafeDiv(100, msg.value);\n    v4 = v5 = _SafeMul(10, v3);\n    v2 = v6 = 0;\n    v7 = v8 = 10;\n    v9 = v10 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n    if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n        v9 = v11 = msg.sender != _owner;\n    }\n    if (v9) {\n        v9 = v12 = 0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender;\n    }\n    if (v9) {\n        if (stor_5_0_19) {\n            _summOf[stor_5_0_19] += msg.value;\n            v13 = v14 = 0xd8d726b7177a80000 <= _summOf[stor_5_0_19];\n            if (0xd8d726b7177a80000 <= _summOf[stor_5_0_19]) {\n                v13 = v15 = 6 > _prevOf[stor_5_0_19];\n            }\n            if (v13) {\n                _prevOf[stor_5_0_19] = 6;\n            }\n            v16 = v17 = 0xad78ebc5ac6200000 <= _summOf[stor_5_0_19];\n            if (0xad78ebc5ac6200000 <= _summOf[stor_5_0_19]) {\n                v16 = v18 = _prevOf[stor_5_0_19] < 5;\n            }\n            if (v16) {\n                _prevOf[stor_5_0_19] = 5;\n            }\n            v19 = v20 = 0x821ab0d4414980000 <= _summOf[stor_5_0_19];\n            if (0x821ab0d4414980000 <= _summOf[stor_5_0_19]) {\n                v19 = v21 = 4 > _prevOf[stor_5_0_19];\n            }\n            if (v19) {\n                _prevOf[stor_5_0_19] = 4;\n            }\n            v22 = v23 = 0x56bc75e2d63100000 <= _summOf[stor_5_0_19];\n            if (0x56bc75e2d63100000 <= _summOf[stor_5_0_19]) {\n                v22 = v24 = 3 > _prevOf[stor_5_0_19];\n            }\n            if (v22) {\n                _prevOf[stor_5_0_19] = 3;\n            }\n            v25 = v26 = 0x2b5e3af16b1880000 <= _summOf[stor_5_0_19];\n            if (0x2b5e3af16b1880000 <= _summOf[stor_5_0_19]) {\n                v25 = v27 = 2 > _prevOf[stor_5_0_19];\n            }\n            if (v25) {\n                _prevOf[stor_5_0_19] = 2;\n            }\n            if (address(_referrerOf[stor_5_0_19])) {\n                stor_6_0_19 = _referrerOf[stor_5_0_19];\n            }\n            if (address(_referrerOf[stor_6_0_19])) {\n                stor_7_0_19 = _referrerOf[stor_6_0_19];\n            }\n            if (address(_referrerOf[stor_7_0_19])) {\n                stor_8_0_19 = _referrerOf[stor_7_0_19];\n            }\n            if (address(_referrerOf[stor_8_0_19])) {\n                stor_9_0_19 = _referrerOf[stor_8_0_19];\n            }\n            if (1 >= _prevOf[stor_5_0_19]) {\n                if (_prevOf[stor_5_0_19] > 0) {\n                    v7 = v28 = 9;\n                }\n            } else {\n                v4 = v29 = v5 - v3;\n                v2 = v30 = _SafeMul(2, v3);\n                v7 = v31 = 8;\n            }\n        }\n        if (stor_6_0_19) {\n            if (2 >= _prevOf[stor_6_0_19]) {\n                if (_prevOf[stor_6_0_19] > 0) {\n                    v4 = v32 = v4 - v3;\n                    v7 = v33 = v7 - 1;\n                }\n            } else {\n                v34 = _SafeMul(2, v3);\n                v4 = v35 = v4 - v34;\n                v2 = v36 = _SafeMul(2, v3);\n                v7 = v37 = v7 - 2;\n            }\n        }\n        if (stor_7_0_19) {\n            if (3 >= _prevOf[stor_7_0_19]) {\n                if (_prevOf[stor_7_0_19] > 0) {\n                    v4 = v38 = v4 - v3;\n                    v7 = v39 = v7 - 1;\n                }\n            } else {\n                v40 = _SafeMul(2, v3);\n                v4 = v41 = v4 - v40;\n                v2 = v42 = _SafeMul(2, v3);\n                v7 = v43 = v7 - 2;\n            }\n        }\n        if (stor_8_0_19) {\n            if (4 >= _prevOf[stor_8_0_19]) {\n                if (_prevOf[stor_8_0_19] > 0) {\n                    v4 = v44 = v4 - v3;\n                    v7 = v45 = v7 - 1;\n                }\n            } else {\n                v46 = _SafeMul(2, v3);\n                v4 = v47 = v4 - v46;\n                v2 = v48 = _SafeMul(2, v3);\n                v7 = v49 = v7 - 2;\n            }\n        }\n        if (stor_9_0_19) {\n            if (5 >= _prevOf[stor_9_0_19]) {\n                if (_prevOf[stor_9_0_19] > 0) {\n                    v4 = v50 = v4 - v3;\n                    v7 = v51 = v7 - 1;\n                }\n            } else {\n                v52 = _SafeMul(2, v3);\n                v4 = v53 = v4 - v52;\n                v2 = v54 = _SafeMul(2, v3);\n                v7 = v55 = v7 - 2;\n            }\n        }\n    }\n    if (v4 > 0) {\n        v56 = _SafeDiv(70, 100 * _price);\n        v2 = v57 = _SafeDiv(v56, v4);\n        require(v57 > 0);\n        v2 = v58 = _SafeDiv(100, v4);\n        MEM[32] = 4;\n        stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3 += v57;\n        emit Transfer(this, 0x516e0debb3db8c2c087786ccf7653fa0991784b3, v57);\n    }\n    v59 = _SafeMul(85 - v7, v2 + v3);\n    stor_0 += v59;\n    _totalSupply += v2 + v1;\n    v60 = _SafeDiv(v2 + v1 + _totalSupply, v59 + stor_0);\n    _price = v60;\n    _balanceOf[msg.sender] += v1;\n    emit Transfer(this, msg.sender, v1);\n    v61 = _SafeMul(5, v3);\n    v62 = _owner.call().value(v61).gas(2300 * !v61);\n    require(v62); // checks call status, propagates error data on error\n    v63 = _SafeMul(5, v3);\n    v64 = 0x28ff20d2d413a346f123198385ccf16e15295351.call().value(v63).gas(2300 * !v63);\n    require(v64); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v65 = stor_5_0_19.call().value(v2).gas(2300 * !v2);\n        require(v65); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v66 = stor_6_0_19.call().value(v2).gas(2300 * !v2);\n        require(v66); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v67 = stor_7_0_19.call().value(v2).gas(2300 * !v2);\n        require(v67); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v68 = stor_8_0_19.call().value(v2).gas(2300 * !v2);\n        require(v68); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v69 = stor_9_0_19.call().value(v2).gas(2300 * !v2);\n        require(v69); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(msg.sender.code.size <= 0);\n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x1a055690d9db80000);\n    if (0xab85cb1087ce716e11dc37c69eaabc09d674575d == msg.sender) {\n        v0 = _SafeDiv(100, msg.value);\n        v1 = _SafeMul(90, v0);\n        stor_0 += v1;\n        v2 = _SafeDiv(_totalSupply, v1 + stor_0);\n        _price = v2;\n    } else {\n        stor_5_0_19 = 0;\n        stor_6_0_19 = 0;\n        stor_7_0_19 = 0;\n        stor_8_0_19 = 0;\n        stor_9_0_19 = 0;\n        v3 = v4 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n        if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n            v3 = v5 = msg.sender != _owner;\n        }\n        if (!v3) {\n            0x8c9();\n        } else {\n            v6 = v7 = msg.value >= 0x15af1d78b58c40000;\n            if (v7) {\n                v6 = 6 > _prevOf[msg.sender];\n            }\n            if (v6) {\n                _prevOf[msg.sender] = 6;\n            }\n            v8 = v9 = msg.value >= 0x1158e460913d00000;\n            if (v9) {\n                v8 = 5 > _prevOf[msg.sender];\n            }\n            if (v8) {\n                _prevOf[msg.sender] = 5;\n            }\n            v10 = v11 = msg.value >= 0xd02ab486cedc0000;\n            if (v11) {\n                v10 = 4 > _prevOf[msg.sender];\n            }\n            if (v10) {\n                _prevOf[msg.sender] = 4;\n            }\n            v12 = v13 = msg.value >= 0x8ac7230489e80000;\n            if (v13) {\n                v12 = 3 > _prevOf[msg.sender];\n            }\n            if (v12) {\n                _prevOf[msg.sender] = 3;\n            }\n            v14 = v15 = msg.value >= 0x4563918244f40000;\n            if (v15) {\n                v14 = 2 > _prevOf[msg.sender];\n            }\n            if (v14) {\n                _prevOf[msg.sender] = 2;\n            }\n            v16 = v17 = msg.value >= 0x16345785d8a0000;\n            if (v17) {\n                v16 = 1 > _prevOf[msg.sender];\n            }\n            if (v16) {\n                _prevOf[msg.sender] = 1;\n            }\n            v18 = v19 = 0xd8d726b7177a80000 <= _summOf[msg.sender];\n            if (0xd8d726b7177a80000 <= _summOf[msg.sender]) {\n                v18 = 6 > _prevOf[msg.sender];\n            }\n            if (v18) {\n                _prevOf[msg.sender] = 6;\n            }\n            v20 = v21 = 0xad78ebc5ac6200000 <= _summOf[msg.sender];\n            if (0xad78ebc5ac6200000 <= _summOf[msg.sender]) {\n                v20 = 5 > _prevOf[msg.sender];\n            }\n            if (v20) {\n                _prevOf[msg.sender] = 5;\n            }\n            v22 = v23 = 0x821ab0d4414980000 <= _summOf[msg.sender];\n            if (0x821ab0d4414980000 <= _summOf[msg.sender]) {\n                v22 = 4 > _prevOf[msg.sender];\n            }\n            if (v22) {\n                _prevOf[msg.sender] = 4;\n            }\n            v24 = v25 = 0x56bc75e2d63100000 <= _summOf[msg.sender];\n            if (0x56bc75e2d63100000 <= _summOf[msg.sender]) {\n                v24 = 3 > _prevOf[msg.sender];\n            }\n            if (v24) {\n                _prevOf[msg.sender] = 3;\n            }\n            v26 = v27 = 0x2b5e3af16b1880000 <= _summOf[msg.sender];\n            if (0x2b5e3af16b1880000 <= _summOf[msg.sender]) {\n                v26 = 2 > _prevOf[msg.sender];\n            }\n            if (v26) {\n                _prevOf[msg.sender] = 2;\n            }\n            stor_5_0_19 = _referrerOf[msg.sender];\n            if (!stor_5_0_0) {\n                v28 = new bytes[](msg.data.length);\n                CALLDATACOPY(v28.data, 0, msg.data.length);\n                stor_5_0_19 = MEM[20 + v28];\n                require(stor_5_0_19.code.size <= 0);\n                require(_balanceOf[stor_5_0_19] > 0);\n                require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != stor_5_0_19);\n                require(0xab85cb1087ce716e11dc37c69eaabc09d674575d != stor_5_0_19);\n                _referrerOf[msg.sender] = stor_5_0_19 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrerOf[msg.sender];\n            }\n            0x8c9();\n            goto 0x1a4;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd21cacdf == function_selector) {\n            referrerOf(address);\n        } else if (0xd929bf26 == function_selector) {\n            summOf(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf32ca660 == function_selector) {\n            prevOf(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 18:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 _price; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _referrerOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _prevOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _summOf; // STORAGE[0xd]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\naddress _owner; // STORAGE[0xa] bytes 0 to 19\nuint256 stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3; // STORAGE[0x9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'OnUp TOKEN';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != varg0);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg2 < 0x1312d01);\n        }\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4f6e557000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg1 < 0x1312d01);\n        }\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction referrerOf(address varg0) public nonPayable { \n    return address(_referrerOf[varg0]);\n}\n\nfunction summOf(address varg0) public nonPayable { \n    return _summOf[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction prevOf(address varg0) public nonPayable { \n    return _prevOf[varg0];\n}\n\nfunction 0x8c9() private { \n    v0 = _SafeDiv(70, 100 * _price);\n    v1 = _SafeDiv(v0, msg.value);\n    require(v1 > 0);\n    require(_balanceOf[msg.sender] + v1 > _balanceOf[msg.sender]);\n    v2 = v3 = _SafeDiv(100, msg.value);\n    v4 = v5 = _SafeMul(10, v3);\n    v2 = v6 = 0;\n    v7 = v8 = 10;\n    v9 = v10 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n    if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n        v9 = v11 = msg.sender != _owner;\n    }\n    if (v9) {\n        v9 = v12 = 0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender;\n    }\n    if (v9) {\n        if (stor_5_0_19) {\n            _summOf[stor_5_0_19] += msg.value;\n            v13 = v14 = 0xd8d726b7177a80000 <= _summOf[stor_5_0_19];\n            if (0xd8d726b7177a80000 <= _summOf[stor_5_0_19]) {\n                v13 = v15 = 6 > _prevOf[stor_5_0_19];\n            }\n            if (v13) {\n                _prevOf[stor_5_0_19] = 6;\n            }\n            v16 = v17 = 0xad78ebc5ac6200000 <= _summOf[stor_5_0_19];\n            if (0xad78ebc5ac6200000 <= _summOf[stor_5_0_19]) {\n                v16 = v18 = _prevOf[stor_5_0_19] < 5;\n            }\n            if (v16) {\n                _prevOf[stor_5_0_19] = 5;\n            }\n            v19 = v20 = 0x821ab0d4414980000 <= _summOf[stor_5_0_19];\n            if (0x821ab0d4414980000 <= _summOf[stor_5_0_19]) {\n                v19 = v21 = 4 > _prevOf[stor_5_0_19];\n            }\n            if (v19) {\n                _prevOf[stor_5_0_19] = 4;\n            }\n            v22 = v23 = 0x56bc75e2d63100000 <= _summOf[stor_5_0_19];\n            if (0x56bc75e2d63100000 <= _summOf[stor_5_0_19]) {\n                v22 = v24 = 3 > _prevOf[stor_5_0_19];\n            }\n            if (v22) {\n                _prevOf[stor_5_0_19] = 3;\n            }\n            v25 = v26 = 0x2b5e3af16b1880000 <= _summOf[stor_5_0_19];\n            if (0x2b5e3af16b1880000 <= _summOf[stor_5_0_19]) {\n                v25 = v27 = 2 > _prevOf[stor_5_0_19];\n            }\n            if (v25) {\n                _prevOf[stor_5_0_19] = 2;\n            }\n            if (address(_referrerOf[stor_5_0_19])) {\n                stor_6_0_19 = _referrerOf[stor_5_0_19];\n            }\n            if (address(_referrerOf[stor_6_0_19])) {\n                stor_7_0_19 = _referrerOf[stor_6_0_19];\n            }\n            if (address(_referrerOf[stor_7_0_19])) {\n                stor_8_0_19 = _referrerOf[stor_7_0_19];\n            }\n            if (address(_referrerOf[stor_8_0_19])) {\n                stor_9_0_19 = _referrerOf[stor_8_0_19];\n            }\n            if (1 >= _prevOf[stor_5_0_19]) {\n                if (_prevOf[stor_5_0_19] > 0) {\n                    v7 = v28 = 9;\n                }\n            } else {\n                v4 = v29 = v5 - v3;\n                v2 = v30 = _SafeMul(2, v3);\n                v7 = v31 = 8;\n            }\n        }\n        if (stor_6_0_19) {\n            if (2 >= _prevOf[stor_6_0_19]) {\n                if (_prevOf[stor_6_0_19] > 0) {\n                    v4 = v32 = v4 - v3;\n                    v7 = v33 = v7 - 1;\n                }\n            } else {\n                v34 = _SafeMul(2, v3);\n                v4 = v35 = v4 - v34;\n                v2 = v36 = _SafeMul(2, v3);\n                v7 = v37 = v7 - 2;\n            }\n        }\n        if (stor_7_0_19) {\n            if (3 >= _prevOf[stor_7_0_19]) {\n                if (_prevOf[stor_7_0_19] > 0) {\n                    v4 = v38 = v4 - v3;\n                    v7 = v39 = v7 - 1;\n                }\n            } else {\n                v40 = _SafeMul(2, v3);\n                v4 = v41 = v4 - v40;\n                v2 = v42 = _SafeMul(2, v3);\n                v7 = v43 = v7 - 2;\n            }\n        }\n        if (stor_8_0_19) {\n            if (4 >= _prevOf[stor_8_0_19]) {\n                if (_prevOf[stor_8_0_19] > 0) {\n                    v4 = v44 = v4 - v3;\n                    v7 = v45 = v7 - 1;\n                }\n            } else {\n                v46 = _SafeMul(2, v3);\n                v4 = v47 = v4 - v46;\n                v2 = v48 = _SafeMul(2, v3);\n                v7 = v49 = v7 - 2;\n            }\n        }\n        if (stor_9_0_19) {\n            if (5 >= _prevOf[stor_9_0_19]) {\n                if (_prevOf[stor_9_0_19] > 0) {\n                    v4 = v50 = v4 - v3;\n                    v7 = v51 = v7 - 1;\n                }\n            } else {\n                v52 = _SafeMul(2, v3);\n                v4 = v53 = v4 - v52;\n                v2 = v54 = _SafeMul(2, v3);\n                v7 = v55 = v7 - 2;\n            }\n        }\n    }\n    if (v4 > 0) {\n        v56 = _SafeDiv(70, 100 * _price);\n        v2 = v57 = _SafeDiv(v56, v4);\n        require(v57 > 0);\n        v2 = v58 = _SafeDiv(100, v4);\n        MEM[32] = 4;\n        stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3 += v57;\n        emit Transfer(this, 0x516e0debb3db8c2c087786ccf7653fa0991784b3, v57);\n    }\n    v59 = _SafeMul(85 - v7, v2 + v3);\n    stor_0 += v59;\n    _totalSupply += v2 + v1;\n    v60 = _SafeDiv(v2 + v1 + _totalSupply, v59 + stor_0);\n    _price = v60;\n    _balanceOf[msg.sender] += v1;\n    emit Transfer(this, msg.sender, v1);\n    v61 = _SafeMul(5, v3);\n    v62 = _owner.call().value(v61).gas(2300 * !v61);\n    require(v62); // checks call status, propagates error data on error\n    v63 = _SafeMul(5, v3);\n    v64 = 0x28ff20d2d413a346f123198385ccf16e15295351.call().value(v63).gas(2300 * !v63);\n    require(v64); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v65 = stor_5_0_19.call().value(v2).gas(2300 * !v2);\n        require(v65); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v66 = stor_6_0_19.call().value(v2).gas(2300 * !v2);\n        require(v66); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v67 = stor_7_0_19.call().value(v2).gas(2300 * !v2);\n        require(v67); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v68 = stor_8_0_19.call().value(v2).gas(2300 * !v2);\n        require(v68); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v69 = stor_9_0_19.call().value(v2).gas(2300 * !v2);\n        require(v69); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(msg.sender.code.size <= 0);\n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x1a055690d9db80000);\n    if (0xab85cb1087ce716e11dc37c69eaabc09d674575d == msg.sender) {\n        v0 = _SafeDiv(100, msg.value);\n        v1 = _SafeMul(90, v0);\n        stor_0 += v1;\n        v2 = _SafeDiv(_totalSupply, v1 + stor_0);\n        _price = v2;\n    } else {\n        stor_5_0_19 = 0;\n        stor_6_0_19 = 0;\n        stor_7_0_19 = 0;\n        stor_8_0_19 = 0;\n        stor_9_0_19 = 0;\n        v3 = v4 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n        if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n            v3 = v5 = msg.sender != _owner;\n        }\n        if (!v3) {\n            0x8c9();\n        } else {\n            v6 = v7 = msg.value >= 0x15af1d78b58c40000;\n            if (v7) {\n                v6 = 6 > _prevOf[msg.sender];\n            }\n            if (v6) {\n                _prevOf[msg.sender] = 6;\n            }\n            v8 = v9 = msg.value >= 0x1158e460913d00000;\n            if (v9) {\n                v8 = 5 > _prevOf[msg.sender];\n            }\n            if (v8) {\n                _prevOf[msg.sender] = 5;\n            }\n            v10 = v11 = msg.value >= 0xd02ab486cedc0000;\n            if (v11) {\n                v10 = 4 > _prevOf[msg.sender];\n            }\n            if (v10) {\n                _prevOf[msg.sender] = 4;\n            }\n            v12 = v13 = msg.value >= 0x8ac7230489e80000;\n            if (v13) {\n                v12 = 3 > _prevOf[msg.sender];\n            }\n            if (v12) {\n                _prevOf[msg.sender] = 3;\n            }\n            v14 = v15 = msg.value >= 0x4563918244f40000;\n            if (v15) {\n                v14 = 2 > _prevOf[msg.sender];\n            }\n            if (v14) {\n                _prevOf[msg.sender] = 2;\n            }\n            v16 = v17 = msg.value >= 0x16345785d8a0000;\n            if (v17) {\n                v16 = 1 > _prevOf[msg.sender];\n            }\n            if (v16) {\n                _prevOf[msg.sender] = 1;\n            }\n            v18 = v19 = 0xd8d726b7177a80000 <= _summOf[msg.sender];\n            if (0xd8d726b7177a80000 <= _summOf[msg.sender]) {\n                v18 = 6 > _prevOf[msg.sender];\n            }\n            if (v18) {\n                _prevOf[msg.sender] = 6;\n            }\n            v20 = v21 = 0xad78ebc5ac6200000 <= _summOf[msg.sender];\n            if (0xad78ebc5ac6200000 <= _summOf[msg.sender]) {\n                v20 = 5 > _prevOf[msg.sender];\n            }\n            if (v20) {\n                _prevOf[msg.sender] = 5;\n            }\n            v22 = v23 = 0x821ab0d4414980000 <= _summOf[msg.sender];\n            if (0x821ab0d4414980000 <= _summOf[msg.sender]) {\n                v22 = 4 > _prevOf[msg.sender];\n            }\n            if (v22) {\n                _prevOf[msg.sender] = 4;\n            }\n            v24 = v25 = 0x56bc75e2d63100000 <= _summOf[msg.sender];\n            if (0x56bc75e2d63100000 <= _summOf[msg.sender]) {\n                v24 = 3 > _prevOf[msg.sender];\n            }\n            if (v24) {\n                _prevOf[msg.sender] = 3;\n            }\n            v26 = v27 = 0x2b5e3af16b1880000 <= _summOf[msg.sender];\n            if (0x2b5e3af16b1880000 <= _summOf[msg.sender]) {\n                v26 = 2 > _prevOf[msg.sender];\n            }\n            if (v26) {\n                _prevOf[msg.sender] = 2;\n            }\n            stor_5_0_19 = _referrerOf[msg.sender];\n            if (!stor_5_0_0) {\n                v28 = new bytes[](msg.data.length);\n                CALLDATACOPY(v28.data, 0, msg.data.length);\n                stor_5_0_19 = MEM[20 + v28];\n                require(stor_5_0_19.code.size <= 0);\n                require(_balanceOf[stor_5_0_19] > 0);\n                require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != stor_5_0_19);\n                require(0xab85cb1087ce716e11dc37c69eaabc09d674575d != stor_5_0_19);\n                _referrerOf[msg.sender] = stor_5_0_19 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrerOf[msg.sender];\n            }\n            0x8c9();\n            goto 0x1a4;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd21cacdf == function_selector) {\n            referrerOf(address);\n        } else if (0xd929bf26 == function_selector) {\n            summOf(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf32ca660 == function_selector) {\n            prevOf(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 18:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 _price; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _referrerOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _prevOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _summOf; // STORAGE[0xd]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\naddress _owner; // STORAGE[0xa] bytes 0 to 19\nuint256 stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3; // STORAGE[0x9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'OnUp TOKEN';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != varg0);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg2 < 0x1312d01);\n        }\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4f6e557000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg1 < 0x1312d01);\n        }\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction referrerOf(address varg0) public nonPayable { \n    return address(_referrerOf[varg0]);\n}\n\nfunction summOf(address varg0) public nonPayable { \n    return _summOf[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction prevOf(address varg0) public nonPayable { \n    return _prevOf[varg0];\n}\n\nfunction 0x8c9() private { \n    v0 = _SafeDiv(70, 100 * _price);\n    v1 = _SafeDiv(v0, msg.value);\n    require(v1 > 0);\n    require(_balanceOf[msg.sender] + v1 > _balanceOf[msg.sender]);\n    v2 = v3 = _SafeDiv(100, msg.value);\n    v4 = v5 = _SafeMul(10, v3);\n    v2 = v6 = 0;\n    v7 = v8 = 10;\n    v9 = v10 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n    if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n        v9 = v11 = msg.sender != _owner;\n    }\n    if (v9) {\n        v9 = v12 = 0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender;\n    }\n    if (v9) {\n        if (stor_5_0_19) {\n            _summOf[stor_5_0_19] += msg.value;\n            v13 = v14 = 0xd8d726b7177a80000 <= _summOf[stor_5_0_19];\n            if (0xd8d726b7177a80000 <= _summOf[stor_5_0_19]) {\n                v13 = v15 = 6 > _prevOf[stor_5_0_19];\n            }\n            if (v13) {\n                _prevOf[stor_5_0_19] = 6;\n            }\n            v16 = v17 = 0xad78ebc5ac6200000 <= _summOf[stor_5_0_19];\n            if (0xad78ebc5ac6200000 <= _summOf[stor_5_0_19]) {\n                v16 = v18 = _prevOf[stor_5_0_19] < 5;\n            }\n            if (v16) {\n                _prevOf[stor_5_0_19] = 5;\n            }\n            v19 = v20 = 0x821ab0d4414980000 <= _summOf[stor_5_0_19];\n            if (0x821ab0d4414980000 <= _summOf[stor_5_0_19]) {\n                v19 = v21 = 4 > _prevOf[stor_5_0_19];\n            }\n            if (v19) {\n                _prevOf[stor_5_0_19] = 4;\n            }\n            v22 = v23 = 0x56bc75e2d63100000 <= _summOf[stor_5_0_19];\n            if (0x56bc75e2d63100000 <= _summOf[stor_5_0_19]) {\n                v22 = v24 = 3 > _prevOf[stor_5_0_19];\n            }\n            if (v22) {\n                _prevOf[stor_5_0_19] = 3;\n            }\n            v25 = v26 = 0x2b5e3af16b1880000 <= _summOf[stor_5_0_19];\n            if (0x2b5e3af16b1880000 <= _summOf[stor_5_0_19]) {\n                v25 = v27 = 2 > _prevOf[stor_5_0_19];\n            }\n            if (v25) {\n                _prevOf[stor_5_0_19] = 2;\n            }\n            if (address(_referrerOf[stor_5_0_19])) {\n                stor_6_0_19 = _referrerOf[stor_5_0_19];\n            }\n            if (address(_referrerOf[stor_6_0_19])) {\n                stor_7_0_19 = _referrerOf[stor_6_0_19];\n            }\n            if (address(_referrerOf[stor_7_0_19])) {\n                stor_8_0_19 = _referrerOf[stor_7_0_19];\n            }\n            if (address(_referrerOf[stor_8_0_19])) {\n                stor_9_0_19 = _referrerOf[stor_8_0_19];\n            }\n            if (1 >= _prevOf[stor_5_0_19]) {\n                if (_prevOf[stor_5_0_19] > 0) {\n                    v7 = v28 = 9;\n                }\n            } else {\n                v4 = v29 = v5 - v3;\n                v2 = v30 = _SafeMul(2, v3);\n                v7 = v31 = 8;\n            }\n        }\n        if (stor_6_0_19) {\n            if (2 >= _prevOf[stor_6_0_19]) {\n                if (_prevOf[stor_6_0_19] > 0) {\n                    v4 = v32 = v4 - v3;\n                    v7 = v33 = v7 - 1;\n                }\n            } else {\n                v34 = _SafeMul(2, v3);\n                v4 = v35 = v4 - v34;\n                v2 = v36 = _SafeMul(2, v3);\n                v7 = v37 = v7 - 2;\n            }\n        }\n        if (stor_7_0_19) {\n            if (3 >= _prevOf[stor_7_0_19]) {\n                if (_prevOf[stor_7_0_19] > 0) {\n                    v4 = v38 = v4 - v3;\n                    v7 = v39 = v7 - 1;\n                }\n            } else {\n                v40 = _SafeMul(2, v3);\n                v4 = v41 = v4 - v40;\n                v2 = v42 = _SafeMul(2, v3);\n                v7 = v43 = v7 - 2;\n            }\n        }\n        if (stor_8_0_19) {\n            if (4 >= _prevOf[stor_8_0_19]) {\n                if (_prevOf[stor_8_0_19] > 0) {\n                    v4 = v44 = v4 - v3;\n                    v7 = v45 = v7 - 1;\n                }\n            } else {\n                v46 = _SafeMul(2, v3);\n                v4 = v47 = v4 - v46;\n                v2 = v48 = _SafeMul(2, v3);\n                v7 = v49 = v7 - 2;\n            }\n        }\n        if (stor_9_0_19) {\n            if (5 >= _prevOf[stor_9_0_19]) {\n                if (_prevOf[stor_9_0_19] > 0) {\n                    v4 = v50 = v4 - v3;\n                    v7 = v51 = v7 - 1;\n                }\n            } else {\n                v52 = _SafeMul(2, v3);\n                v4 = v53 = v4 - v52;\n                v2 = v54 = _SafeMul(2, v3);\n                v7 = v55 = v7 - 2;\n            }\n        }\n    }\n    if (v4 > 0) {\n        v56 = _SafeDiv(70, 100 * _price);\n        v2 = v57 = _SafeDiv(v56, v4);\n        require(v57 > 0);\n        v2 = v58 = _SafeDiv(100, v4);\n        MEM[32] = 4;\n        stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3 += v57;\n        emit Transfer(this, 0x516e0debb3db8c2c087786ccf7653fa0991784b3, v57);\n    }\n    v59 = _SafeMul(85 - v7, v2 + v3);\n    stor_0 += v59;\n    _totalSupply += v2 + v1;\n    v60 = _SafeDiv(v2 + v1 + _totalSupply, v59 + stor_0);\n    _price = v60;\n    _balanceOf[msg.sender] += v1;\n    emit Transfer(this, msg.sender, v1);\n    v61 = _SafeMul(5, v3);\n    v62 = _owner.call().value(v61).gas(2300 * !v61);\n    require(v62); // checks call status, propagates error data on error\n    v63 = _SafeMul(5, v3);\n    v64 = 0x28ff20d2d413a346f123198385ccf16e15295351.call().value(v63).gas(2300 * !v63);\n    require(v64); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v65 = stor_5_0_19.call().value(v2).gas(2300 * !v2);\n        require(v65); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v66 = stor_6_0_19.call().value(v2).gas(2300 * !v2);\n        require(v66); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v67 = stor_7_0_19.call().value(v2).gas(2300 * !v2);\n        require(v67); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v68 = stor_8_0_19.call().value(v2).gas(2300 * !v2);\n        require(v68); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v69 = stor_9_0_19.call().value(v2).gas(2300 * !v2);\n        require(v69); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(msg.sender.code.size <= 0);\n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x1a055690d9db80000);\n    if (0xab85cb1087ce716e11dc37c69eaabc09d674575d == msg.sender) {\n        v0 = _SafeDiv(100, msg.value);\n        v1 = _SafeMul(90, v0);\n        stor_0 += v1;\n        v2 = _SafeDiv(_totalSupply, v1 + stor_0);\n        _price = v2;\n    } else {\n        stor_5_0_19 = 0;\n        stor_6_0_19 = 0;\n        stor_7_0_19 = 0;\n        stor_8_0_19 = 0;\n        stor_9_0_19 = 0;\n        v3 = v4 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n        if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n            v3 = v5 = msg.sender != _owner;\n        }\n        if (!v3) {\n            0x8c9();\n        } else {\n            v6 = v7 = msg.value >= 0x15af1d78b58c40000;\n            if (v7) {\n                v6 = 6 > _prevOf[msg.sender];\n            }\n            if (v6) {\n                _prevOf[msg.sender] = 6;\n            }\n            v8 = v9 = msg.value >= 0x1158e460913d00000;\n            if (v9) {\n                v8 = 5 > _prevOf[msg.sender];\n            }\n            if (v8) {\n                _prevOf[msg.sender] = 5;\n            }\n            v10 = v11 = msg.value >= 0xd02ab486cedc0000;\n            if (v11) {\n                v10 = 4 > _prevOf[msg.sender];\n            }\n            if (v10) {\n                _prevOf[msg.sender] = 4;\n            }\n            v12 = v13 = msg.value >= 0x8ac7230489e80000;\n            if (v13) {\n                v12 = 3 > _prevOf[msg.sender];\n            }\n            if (v12) {\n                _prevOf[msg.sender] = 3;\n            }\n            v14 = v15 = msg.value >= 0x4563918244f40000;\n            if (v15) {\n                v14 = 2 > _prevOf[msg.sender];\n            }\n            if (v14) {\n                _prevOf[msg.sender] = 2;\n            }\n            v16 = v17 = msg.value >= 0x16345785d8a0000;\n            if (v17) {\n                v16 = 1 > _prevOf[msg.sender];\n            }\n            if (v16) {\n                _prevOf[msg.sender] = 1;\n            }\n            v18 = v19 = 0xd8d726b7177a80000 <= _summOf[msg.sender];\n            if (0xd8d726b7177a80000 <= _summOf[msg.sender]) {\n                v18 = 6 > _prevOf[msg.sender];\n            }\n            if (v18) {\n                _prevOf[msg.sender] = 6;\n            }\n            v20 = v21 = 0xad78ebc5ac6200000 <= _summOf[msg.sender];\n            if (0xad78ebc5ac6200000 <= _summOf[msg.sender]) {\n                v20 = 5 > _prevOf[msg.sender];\n            }\n            if (v20) {\n                _prevOf[msg.sender] = 5;\n            }\n            v22 = v23 = 0x821ab0d4414980000 <= _summOf[msg.sender];\n            if (0x821ab0d4414980000 <= _summOf[msg.sender]) {\n                v22 = 4 > _prevOf[msg.sender];\n            }\n            if (v22) {\n                _prevOf[msg.sender] = 4;\n            }\n            v24 = v25 = 0x56bc75e2d63100000 <= _summOf[msg.sender];\n            if (0x56bc75e2d63100000 <= _summOf[msg.sender]) {\n                v24 = 3 > _prevOf[msg.sender];\n            }\n            if (v24) {\n                _prevOf[msg.sender] = 3;\n            }\n            v26 = v27 = 0x2b5e3af16b1880000 <= _summOf[msg.sender];\n            if (0x2b5e3af16b1880000 <= _summOf[msg.sender]) {\n                v26 = 2 > _prevOf[msg.sender];\n            }\n            if (v26) {\n                _prevOf[msg.sender] = 2;\n            }\n            stor_5_0_19 = _referrerOf[msg.sender];\n            if (!stor_5_0_0) {\n                v28 = new bytes[](msg.data.length);\n                CALLDATACOPY(v28.data, 0, msg.data.length);\n                stor_5_0_19 = MEM[20 + v28];\n                require(stor_5_0_19.code.size <= 0);\n                require(_balanceOf[stor_5_0_19] > 0);\n                require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != stor_5_0_19);\n                require(0xab85cb1087ce716e11dc37c69eaabc09d674575d != stor_5_0_19);\n                _referrerOf[msg.sender] = stor_5_0_19 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrerOf[msg.sender];\n            }\n            0x8c9();\n            goto 0x1a4;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd21cacdf == function_selector) {\n            referrerOf(address);\n        } else if (0xd929bf26 == function_selector) {\n            summOf(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf32ca660 == function_selector) {\n            prevOf(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 32.82839393615723,
	"usage": {
		"completion_tokens": 633,
		"prompt_tokens": 6200,
		"total_tokens": 6833
	}
}