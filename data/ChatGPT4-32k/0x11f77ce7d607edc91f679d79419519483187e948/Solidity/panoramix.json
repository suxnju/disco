{
	"address": "0x11f77ce7d607edc91f679d79419519483187e948",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Decompiling the given EVM bytecode into Solidity might not produce a perfect result due to loss of metadata and comments, but the functionality should be preserved. Here is a simplified version of a Solidity contract that could resemble the given bytecode.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract SimpleContract {\n    mapping(address => uint256) private balances;\n    mapping(uint256 => address) private tokenOwners;\n    mapping(address => mapping(address => bool)) private allowed;\n    uint256 totalSupply;\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function ownerOf(uint256 _tokenId) public view returns (address owner) {\n        return tokenOwners[_tokenId];\n    }\n\n    function approve(address _to, uint256 _tokenId) public {\n        require(msg.sender == tokenOwners[_tokenId]);\n        allowed[msg.sender][_to] = true;\n        emit Approval(msg.sender, _to, _tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool _approved) public {\n        require(operator != msg.sender);\n        allowed[msg.sender][operator] = _approved;\n        emit ApprovalForAll(msg.sender, operator, _approved);\n    }\n\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n        require(_tokenId < totalSupply);\n        address owner = ownerOf(_tokenId);\n        return (_spender == owner || allowed[owner][_spender]);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n        require(_to != address(0));\n        require(_from != address(0));\n        require(_tokenId < totalSupply);\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\n        balances[_from] -= 1;\n        balances[_to] += 1;\n        tokenOwners[_tokenId] = _to;\n        emit Transfer(_from, _to, _tokenId);\n    }\n    \n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n}\n```\n\nPlease note that the decompiled code could potentially implement the ERC721 or ERC20 standard or a combination of both, but it's hard to tell without more context. Also, the code provided is an oversimplified version and doesn't include some checks and functionalities that the original code might have.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474695,
	"id": "chatcmpl-8MvR9ijL9tFYhOSP8VgotGpXNInNb",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor3 is uint256 at storage 3\n  stor5 is uint256 at storage 5\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback(?) payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == supportsInterface(bytes32 _interfaceID):\n      require not call.value\n      return stor[call.data[4]][4]\n  if mem[0 len 28], uint32(call.func_hash) == balanceOf(address account):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require call.data[4]\n      return stor[call.data[4]][9]\n  if mem[0 len 28], uint32(call.func_hash) == ownerOf(uint256 tokenId):\n      require not call.value\n      require stor[call.data[4]][0]\n      return stor[call.data[4]][0]\n  if mem[0 len 28], uint32(call.func_hash) == getApproved(uint256 tokenId):\n      require not call.value\n      require stor[call.data[4]][0]\n      return stor[call.data[4]][1]\n  if mem[0 len 28], uint32(call.func_hash) != isApprovedForAll(address owner, address operator):\n      if mem[0 len 28], uint32(call.func_hash) == _isApprovedOrOwner(address _spender, uint256 _tokenId):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          call this.address.isApprovedForAll(address owner, address operator) with:\n               gas gas_remaining wei\n              args stor[call.data[36]][0], call.data[4]\n          require ext_call.success\n          return (stor[call.data[36]][0] == call.data[4] or call.data[4] == stor[call.data[36]][1] or ext_call.return_data[0])\n      if mem[0 len 28], uint32(call.func_hash) == tokenByIndex(uint256 index):\n          require not call.value\n          require call.data[4] < stor5\n          return stor[call.data[4]][6]\n      if mem[0 len 28], uint32(call.func_hash) == ownerIndexOfToken(uint256 _tokenId):\n          require not call.value\n          require stor[call.data[4]][0]\n          return stor[call.data[4]][8]\n      if mem[0 len 28], uint32(call.func_hash) == tokenOfOwnerByIndex(address owner, uint256 index):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          call this.address.balanceOf(address account) with:\n               gas gas_remaining wei\n              args call.data[4]\n          require ext_call.success\n          require call.data[36] < ext_call.return_data[0]\n          return stor[call.data[36]][('array', 2, ('map', 9, ('call.data', 4, 32)))]\n      if mem[0 len 28], uint32(call.func_hash) == transferFrom(address sender, address recipient, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args call.data[4], call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId):\n          require memcopy.success\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId, bytes _data):\n          require _param3.length <= 1024\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[call.data[36]][0]\n          require call.data[4] != stor[call.data[36]][0]\n          require stor[call.data[36]][0] == caller or bool(stor[caller][('array', 1, ('map', 9, ('stor', ('map', 0, ('call.data', 36, 32)))))])\n          stor[call.data[36]][1] = call.data[4]\n          log Approval(\n                address owner=stor[call.data[36]][0],\n                address spender=call.data[4],\n                uint256 value=call.data[36])\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == setApprovalForAll(address operator, bool approved):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 2\n          require call.data[4] != caller\n          stor[call.data[4]][('array', 1, ('map', 9, 'caller'))] = call.data[36]\n          log ApprovalForAll(\n                address owner=call.data[36],\n                address operator=caller,\n                bool approved=call.data[4])\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == mint(address _to, uint256 _amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require call.data[4]\n          require not stor[call.data[36]][0]\n          stor[call.data[36]][0] = call.data[4]\n          stor[call.data[36]][8] = stor[call.data[4]][9]\n          stor[call.data[4]][9][('array', 2, ('map', 9, ('call.data', 4, 32)))] = call.data[36]\n          require stor[call.data[4]][9] + 1 >= stor[call.data[4]][9]\n          stor[call.data[4]][9]++\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 4058)\n      if mem[0 len 28], uint32(call.func_hash) == burn(uint256 _value):\n          require not call.value\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[4]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require stor[call.data[4]][0]\n          require stor[call.data[4]][0] == stor[call.data[4]][0]\n          if stor[call.data[4]][1]:\n              stor[call.data[4]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 4404)\n      if mem[0 len 28], uint32(call.func_hash) == idToOwnerAddress(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][0]\n      if mem[0 len 28], uint32(call.func_hash) == idToApprovals(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][1]\n      if mem[0 len 28], uint32(call.func_hash) == ownerToTokenCount(address arg0):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][2]\n      if mem[0 len 28], uint32(call.func_hash) == minter():\n          require not call.value\n          return stor3\n      if mem[0 len 28], uint32(call.func_hash) == supportedInterfaces(bytes32 arg0):\n          require not call.value\n          return stor[call.data[4]][4]\n      if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n          require not call.value\n          return stor5\n      if mem[0 len 28], uint32(call.func_hash) == idToIdx(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][7]\n      if mem[0 len 28], uint32(call.func_hash) == addressToOwnerStruct__count(address arg0):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][9]\n      if mem[0 len 28], uint32(call.func_hash) != addressToOwnerStruct__operators(address arg0, address arg1):\n          require mem[0 len 28], uint32(call.func_hash) == addressToOwnerStruct__idxToIdMap(address arg0, uint256 arg1)\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[36]][('array', 2, ('map', 9, ('call.data', 4, 32)))]\n  require not call.value\n  require _param1 < 0x10000000000000000000000000000000000000000\n  require _param2 < 0x10000000000000000000000000000000000000000\n  return stor[call.data[36]][('array', 1, ('map', 9, ('call.data', 4, 32)))]\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor3 is uint256 at storage 3\n  stor5 is uint256 at storage 5\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback(?) payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == supportsInterface(bytes32 _interfaceID):\n      require not call.value\n      return stor[call.data[4]][4]\n  if mem[0 len 28], uint32(call.func_hash) == balanceOf(address account):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require call.data[4]\n      return stor[call.data[4]][9]\n  if mem[0 len 28], uint32(call.func_hash) == ownerOf(uint256 tokenId):\n      require not call.value\n      require stor[call.data[4]][0]\n      return stor[call.data[4]][0]\n  if mem[0 len 28], uint32(call.func_hash) == getApproved(uint256 tokenId):\n      require not call.value\n      require stor[call.data[4]][0]\n      return stor[call.data[4]][1]\n  if mem[0 len 28], uint32(call.func_hash) != isApprovedForAll(address owner, address operator):\n      if mem[0 len 28], uint32(call.func_hash) == _isApprovedOrOwner(address _spender, uint256 _tokenId):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          call this.address.isApprovedForAll(address owner, address operator) with:\n               gas gas_remaining wei\n              args stor[call.data[36]][0], call.data[4]\n          require ext_call.success\n          return (stor[call.data[36]][0] == call.data[4] or call.data[4] == stor[call.data[36]][1] or ext_call.return_data[0])\n      if mem[0 len 28], uint32(call.func_hash) == tokenByIndex(uint256 index):\n          require not call.value\n          require call.data[4] < stor5\n          return stor[call.data[4]][6]\n      if mem[0 len 28], uint32(call.func_hash) == ownerIndexOfToken(uint256 _tokenId):\n          require not call.value\n          require stor[call.data[4]][0]\n          return stor[call.data[4]][8]\n      if mem[0 len 28], uint32(call.func_hash) == tokenOfOwnerByIndex(address owner, uint256 index):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          call this.address.balanceOf(address account) with:\n               gas gas_remaining wei\n              args call.data[4]\n          require ext_call.success\n          require call.data[36] < ext_call.return_data[0]\n          return stor[call.data[36]][('array', 2, ('map', 9, ('call.data', 4, 32)))]\n      if mem[0 len 28], uint32(call.func_hash) == transferFrom(address sender, address recipient, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args call.data[4], call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId):\n          require memcopy.success\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId, bytes _data):\n          require _param3.length <= 1024\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[call.data[36]][0]\n          require call.data[4] != stor[call.data[36]][0]\n          require stor[call.data[36]][0] == caller or bool(stor[caller][('array', 1, ('map', 9, ('stor', ('map', 0, ('call.data', 36, 32)))))])\n          stor[call.data[36]][1] = call.data[4]\n          log Approval(\n                address owner=stor[call.data[36]][0],\n                address spender=call.data[4],\n                uint256 value=call.data[36])\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == setApprovalForAll(address operator, bool approved):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 2\n          require call.data[4] != caller\n          stor[call.data[4]][('array', 1, ('map', 9, 'caller'))] = call.data[36]\n          log ApprovalForAll(\n                address owner=call.data[36],\n                address operator=caller,\n                bool approved=call.data[4])\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == mint(address _to, uint256 _amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require call.data[4]\n          require not stor[call.data[36]][0]\n          stor[call.data[36]][0] = call.data[4]\n          stor[call.data[36]][8] = stor[call.data[4]][9]\n          stor[call.data[4]][9][('array', 2, ('map', 9, ('call.data', 4, 32)))] = call.data[36]\n          require stor[call.data[4]][9] + 1 >= stor[call.data[4]][9]\n          stor[call.data[4]][9]++\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 4058)\n      if mem[0 len 28], uint32(call.func_hash) == burn(uint256 _value):\n          require not call.value\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[4]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require stor[call.data[4]][0]\n          require stor[call.data[4]][0] == stor[call.data[4]][0]\n          if stor[call.data[4]][1]:\n              stor[call.data[4]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 4404)\n      if mem[0 len 28], uint32(call.func_hash) == idToOwnerAddress(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][0]\n      if mem[0 len 28], uint32(call.func_hash) == idToApprovals(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][1]\n      if mem[0 len 28], uint32(call.func_hash) == ownerToTokenCount(address arg0):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][2]\n      if mem[0 len 28], uint32(call.func_hash) == minter():\n          require not call.value\n          return stor3\n      if mem[0 len 28], uint32(call.func_hash) == supportedInterfaces(bytes32 arg0):\n          require not call.value\n          return stor[call.data[4]][4]\n      if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n          require not call.value\n          return stor5\n      if mem[0 len 28], uint32(call.func_hash) == idToIdx(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][7]\n      if mem[0 len 28], uint32(call.func_hash) == addressToOwnerStruct__count(address arg0):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][9]\n      if mem[0 len 28], uint32(call.func_hash) != addressToOwnerStruct__operators(address arg0, address arg1):\n          require mem[0 len 28], uint32(call.func_hash) == addressToOwnerStruct__idxToIdMap(address arg0, uint256 arg1)\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[36]][('array', 2, ('map', 9, ('call.data', 4, 32)))]\n  require not call.value\n  require _param1 < 0x10000000000000000000000000000000000000000\n  require _param2 < 0x10000000000000000000000000000000000000000\n  return stor[call.data[36]][('array', 1, ('map', 9, ('call.data', 4, 32)))]\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor3 is uint256 at storage 3\n  stor5 is uint256 at storage 5\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback(?) payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == supportsInterface(bytes32 _interfaceID):\n      require not call.value\n      return stor[call.data[4]][4]\n  if mem[0 len 28], uint32(call.func_hash) == balanceOf(address account):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require call.data[4]\n      return stor[call.data[4]][9]\n  if mem[0 len 28], uint32(call.func_hash) == ownerOf(uint256 tokenId):\n      require not call.value\n      require stor[call.data[4]][0]\n      return stor[call.data[4]][0]\n  if mem[0 len 28], uint32(call.func_hash) == getApproved(uint256 tokenId):\n      require not call.value\n      require stor[call.data[4]][0]\n      return stor[call.data[4]][1]\n  if mem[0 len 28], uint32(call.func_hash) != isApprovedForAll(address owner, address operator):\n      if mem[0 len 28], uint32(call.func_hash) == _isApprovedOrOwner(address _spender, uint256 _tokenId):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          call this.address.isApprovedForAll(address owner, address operator) with:\n               gas gas_remaining wei\n              args stor[call.data[36]][0], call.data[4]\n          require ext_call.success\n          return (stor[call.data[36]][0] == call.data[4] or call.data[4] == stor[call.data[36]][1] or ext_call.return_data[0])\n      if mem[0 len 28], uint32(call.func_hash) == tokenByIndex(uint256 index):\n          require not call.value\n          require call.data[4] < stor5\n          return stor[call.data[4]][6]\n      if mem[0 len 28], uint32(call.func_hash) == ownerIndexOfToken(uint256 _tokenId):\n          require not call.value\n          require stor[call.data[4]][0]\n          return stor[call.data[4]][8]\n      if mem[0 len 28], uint32(call.func_hash) == tokenOfOwnerByIndex(address owner, uint256 index):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          call this.address.balanceOf(address account) with:\n               gas gas_remaining wei\n              args call.data[4]\n          require ext_call.success\n          require call.data[36] < ext_call.return_data[0]\n          return stor[call.data[36]][('array', 2, ('map', 9, ('call.data', 4, 32)))]\n      if mem[0 len 28], uint32(call.func_hash) == transferFrom(address sender, address recipient, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args call.data[4], call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId):\n          require memcopy.success\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId, bytes _data):\n          require _param3.length <= 1024\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 0x10000000000000000000000000000000000000000\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[68]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require call.data[36]\n          require stor[call.data[68]][0] == call.data[4]\n          if stor[call.data[68]][1]:\n              stor[call.data[68]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2049)\n      if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[call.data[36]][0]\n          require call.data[4] != stor[call.data[36]][0]\n          require stor[call.data[36]][0] == caller or bool(stor[caller][('array', 1, ('map', 9, ('stor', ('map', 0, ('call.data', 36, 32)))))])\n          stor[call.data[36]][1] = call.data[4]\n          log Approval(\n                address owner=stor[call.data[36]][0],\n                address spender=call.data[4],\n                uint256 value=call.data[36])\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == setApprovalForAll(address operator, bool approved):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require _param2 < 2\n          require call.data[4] != caller\n          stor[call.data[4]][('array', 1, ('map', 9, 'caller'))] = call.data[36]\n          log ApprovalForAll(\n                address owner=call.data[36],\n                address operator=caller,\n                bool approved=call.data[4])\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == mint(address _to, uint256 _amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require call.data[4]\n          require not stor[call.data[36]][0]\n          stor[call.data[36]][0] = call.data[4]\n          stor[call.data[36]][8] = stor[call.data[4]][9]\n          stor[call.data[4]][9][('array', 2, ('map', 9, ('call.data', 4, 32)))] = call.data[36]\n          require stor[call.data[4]][9] + 1 >= stor[call.data[4]][9]\n          stor[call.data[4]][9]++\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 4058)\n      if mem[0 len 28], uint32(call.func_hash) == burn(uint256 _value):\n          require not call.value\n          call this.address._isApprovedOrOwner(address _spender, uint256 _tokenId) with:\n               gas gas_remaining wei\n              args caller, call.data[4]\n          require ext_call.success\n          require ext_call.return_data[0]\n          require stor[call.data[4]][0]\n          require stor[call.data[4]][0] == stor[call.data[4]][0]\n          if stor[call.data[4]][1]:\n              stor[call.data[4]][1] = 0\n          ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 4404)\n      if mem[0 len 28], uint32(call.func_hash) == idToOwnerAddress(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][0]\n      if mem[0 len 28], uint32(call.func_hash) == idToApprovals(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][1]\n      if mem[0 len 28], uint32(call.func_hash) == ownerToTokenCount(address arg0):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][2]\n      if mem[0 len 28], uint32(call.func_hash) == minter():\n          require not call.value\n          return stor3\n      if mem[0 len 28], uint32(call.func_hash) == supportedInterfaces(bytes32 arg0):\n          require not call.value\n          return stor[call.data[4]][4]\n      if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n          require not call.value\n          return stor5\n      if mem[0 len 28], uint32(call.func_hash) == idToIdx(uint256 arg0):\n          require not call.value\n          return stor[call.data[4]][7]\n      if mem[0 len 28], uint32(call.func_hash) == addressToOwnerStruct__count(address arg0):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][9]\n      if mem[0 len 28], uint32(call.func_hash) != addressToOwnerStruct__operators(address arg0, address arg1):\n          require mem[0 len 28], uint32(call.func_hash) == addressToOwnerStruct__idxToIdMap(address arg0, uint256 arg1)\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[36]][('array', 2, ('map', 9, ('call.data', 4, 32)))]\n  require not call.value\n  require _param1 < 0x10000000000000000000000000000000000000000\n  require _param2 < 0x10000000000000000000000000000000000000000\n  return stor[call.data[36]][('array', 1, ('map', 9, ('call.data', 4, 32)))]\n\n.",
	"status": "1",
	"time_cost": 18.370508909225464,
	"usage": {
		"completion_tokens": 524,
		"prompt_tokens": 2633,
		"total_tokens": 3157
	}
}