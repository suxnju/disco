{
	"address": "0xb9ab8eed48852de901c13543042204c6c569b811",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst icoHashedPass = 0xbc01e2c48062bbd576f26d72d8ceffdacd379582fb42d3d0eff647b3f52d370\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stakingRequirement is uint256 at storage 4\n  name is array of uint256 at storage 5\n  stor7 is address at storage 7\n  balanceOf is mapping of uint256 at storage 9\n  dividendTokenBalanceOf is mapping of uint256 at storage 10\n  allowed is mapping of uint256 at storage 11\n  stor12 is mapping of uint8 at storage 12\n  stor13 is mapping of uint8 at storage 13\n  stor14 is mapping of uint8 at storage 14\n  stor15 is mapping of uint256 at storage 15\n  stor16 is mapping of address at storage 16\n  stor17 is mapping of uint256 at storage 17\n  stor19 is uint256 at storage 19\n  ethInvestedDuringICO is uint256 at storage 20\n  currentEthInvested is uint256 at storage 21\n  totalSupply is uint256 at storage 22\n  stor23 is uint256 at storage 23\n  stor24 is uint256 at storage 24\n  stor25 is mapping of uint8 at storage 25\n  stor26 is address at storage 26\n  stor27 is uint8 at storage 27 offset 160\n  stor27 is uint8 at storage 27 offset 168\n  stor27 is address at storage 27\n  stor28 is uint256 at storage 28\n\ndef totalEthereumICOReceived(): # not payable\n  return ethInvestedDuringICO\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef currentEthInvested(): # not payable\n  return currentEthInvested\n\ndef regularPhase(): # not payable\n  return bool(uint8(stor27.field_168))\n\ndef getFrontEndTokenBalanceOf(address _customerAddress): # not payable\n  return balanceOf[address(_customerAddress)]\n\ndef getDividendTokenBalanceOf(address _customerAddress): # not payable\n  return uint256(dividendTokenBalanceOf[address(_customerAddress)])\n\ndef stakingRequirement(): # not payable\n  return stakingRequirement\n\ndef allowed(address _param1, address _param2): # not payable\n  return allowed[_param1][_param2]\n\ndef ethInvestedDuringICO(): # not payable\n  return ethInvestedDuringICO\n\ndef myDividendTokens(): # not payable\n  return uint256(dividendTokenBalanceOf[caller])\n\ndef icoPhase(): # not payable\n  return bool(uint8(stor27.field_160))\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef administrators(address _param1): # not payable\n  return bool(stor25[_param1])\n\n#\n#  Regular functions\n#\n\ndef injectEther() payable: \n  require stor25[caller]\n\ndef startRegularPhase(): # not payable\n  require stor25[caller]\n  uint8(stor27.field_160) = 0\n  uint8(stor27.field_168) = 1\n\ndef getMyAverageDividendRate(): # not payable\n  require balanceOf[caller]\n  return (Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller])\n\ndef setStakingRequirement(uint256 _amountOfTokens): # not payable\n  require stor25[caller]\n  require _amountOfTokens >= 100 * 10^18\n  stakingRequirement = _amountOfTokens\n\ndef setAdministrator(address _identifier, bool _status): # not payable\n  require stor25[caller]\n  stor25[address(_identifier)] = uint8(_status)\n\ndef publicStartRegularPhase(): # not payable\n  require block.timestamp > stor28 + (336 * 24 * 3600)\n  require stor28\n  uint8(stor27.field_160) = 0\n  uint8(stor27.field_168) = 1\n\ndef sqrt(uint256 y): # not payable\n  s = y + 1 / 2\n  t = y\n  while s < t:\n      require s\n      s = (y / s) + s / 2\n      t = s\n      continue \n  return t\n\ndef dividendsOf(address _customerAddress): # not payable\n  return (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_customerAddress)]) * stor24) - stor17[address(_customerAddress)]) >> 64)\n\ndef approve(address spender, uint256 amount): # not payable\n  allowed[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef changeCreator(address _creator): # not payable\n  require stor25[caller]\n  stor26 = _creator\n  stor13[address(_creator)] = 1\n  stor14[stor26] = 33\n  stor16[address(stor27.field_0)] = stor26\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return ((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller])\n  return (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64)\n\ndef setPercentage(uint256 referrerPercentage1, uint256 referrerPercentage2, uint256 referrerPercentage3, uint256 bankrollPercentage): # not payable\n  require stor25[caller]\n  require referrerPercentage1 >= 0\n  require referrerPercentage2 >= 0\n  require referrerPercentage3 >= 0\n  require bankrollPercentage >= 0\n  stor0 = referrerPercentage1\n  stor1 = referrerPercentage2\n  stor2 = referrerPercentage3\n  stor3 = bankrollPercentage\n\ndef withdraw(address _asset): # not payable\n  require (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller] > 0\n  require uint8(stor27.field_168)\n  stor17[caller] += Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller])\n  stor15[caller] = 0\n  if _asset:\n      call _asset with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller]),\n            uint256 ethereumWithdrawn=_asset)\n  else:\n      call caller with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller]),\n            uint256 ethereumWithdrawn=caller)\n\ndef transferTo(address _from, address _to, uint256 _amountOfTokens, bytes _data): # not payable\n  require _amountOfTokens >= 10^10\n  require _amountOfTokens <= balanceOf[address(_from)]\n  if caller == _from:\n  else:\n      require _amountOfTokens <= allowed[address(_from)][caller]\n  require uint8(stor27.field_168)\n  require _to\n  if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor24) - stor17[address(_from)]) >> 64) + stor15[address(_from)] > 0:\n      stor17[address(_from)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor24) - stor17[address(_from)])\n      stor15[address(_from)] = 0\n      call _from with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor24) - stor17[address(_from)]) >> 64) + stor15[address(_from)] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor24) - stor17[address(_from)]) >> 64) + stor15[address(_from)]),\n            uint256 ethereumWithdrawn=_from)\n  require balanceOf[address(_from)]\n  if not _amountOfTokens:\n      if _from != caller:\n          allowed[address(_from)][caller] -= _amountOfTokens\n      require _amountOfTokens <= balanceOf[address(_from)]\n      balanceOf[address(_from)] -= _amountOfTokens\n      require _amountOfTokens + balanceOf[_to] >= balanceOf[_to]\n      balanceOf[address(_to)] = _amountOfTokens + balanceOf[_to]\n      require 0 <= uint256(dividendTokenBalanceOf[address(_from)])\n      require uint256(dividendTokenBalanceOf[_to]) >= uint256(dividendTokenBalanceOf[_to])\n      uint256(dividendTokenBalanceOf[address(_to)]) = uint256(dividendTokenBalanceOf[_to])\n      if not stor13[address(_to)]:\n          stor13[address(_to)] = 1\n          stor14[_to] = stor14[address(_from)]\n  else:\n      require Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens / _amountOfTokens == Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)]\n      if _from != caller:\n          allowed[address(_from)][caller] -= _amountOfTokens\n      require _amountOfTokens <= balanceOf[address(_from)]\n      balanceOf[address(_from)] -= _amountOfTokens\n      require _amountOfTokens + balanceOf[_to] >= balanceOf[_to]\n      balanceOf[address(_to)] = _amountOfTokens + balanceOf[_to]\n      require Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64 <= uint256(dividendTokenBalanceOf[address(_from)])\n      uint256(dividendTokenBalanceOf[address(_from)]) -= Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64\n      require (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64) + uint256(dividendTokenBalanceOf[_to]) >= uint256(dividendTokenBalanceOf[_to])\n      uint256(dividendTokenBalanceOf[address(_to)]) = (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64) + uint256(dividendTokenBalanceOf[_to])\n      if not stor13[address(_to)]:\n          stor13[address(_to)] = 1\n          stor14[_to] = stor14[address(_from)]\n      stor17[address(_from)] += -1 * Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64 * stor24\n      stor17[_to] += Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64 * stor24\n  if ext_code.size(_to) > 0:\n      require ext_code.size(_to)\n      call _to.tokenFallback(address _from, uint256 _value, bytes _data) with:\n           gas gas_remaining wei\n          args address(_from), _amountOfTokens, Array(len=_data.length, data=_data[all])\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n  log Transfer(\n        address from=_amountOfTokens,\n        address to=_from,\n        uint256 value=_to)\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require amount >= 10^10\n  require amount <= balanceOf[address(sender)]\n  require amount <= allowed[address(sender)][caller]\n  require uint8(stor27.field_168)\n  require recipient\n  if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor24) - stor17[address(sender)]) >> 64) + stor15[address(sender)] > 0:\n      stor17[address(sender)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor24) - stor17[address(sender)])\n      stor15[address(sender)] = 0\n      call sender with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor24) - stor17[address(sender)]) >> 64) + stor15[address(sender)] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor24) - stor17[address(sender)]) >> 64) + stor15[address(sender)]),\n            uint256 ethereumWithdrawn=sender)\n  require balanceOf[address(sender)]\n  if not amount:\n      if sender != caller:\n          allowed[address(sender)][caller] -= amount\n      require amount <= balanceOf[address(sender)]\n      balanceOf[address(sender)] -= amount\n      require amount + balanceOf[recipient] >= balanceOf[recipient]\n      balanceOf[address(recipient)] = amount + balanceOf[recipient]\n      require 0 <= uint256(dividendTokenBalanceOf[address(sender)])\n      require uint256(dividendTokenBalanceOf[recipient]) >= uint256(dividendTokenBalanceOf[recipient])\n      uint256(dividendTokenBalanceOf[address(recipient)]) = uint256(dividendTokenBalanceOf[recipient])\n      if not stor13[address(recipient)]:\n          stor13[address(recipient)] = 1\n          stor14[recipient] = stor14[address(sender)]\n  else:\n      require Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount / amount == Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)]\n      if sender != caller:\n          allowed[address(sender)][caller] -= amount\n      require amount <= balanceOf[address(sender)]\n      balanceOf[address(sender)] -= amount\n      require amount + balanceOf[recipient] >= balanceOf[recipient]\n      balanceOf[address(recipient)] = amount + balanceOf[recipient]\n      require Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64 <= uint256(dividendTokenBalanceOf[address(sender)])\n      uint256(dividendTokenBalanceOf[address(sender)]) -= Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64\n      require (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64) + uint256(dividendTokenBalanceOf[recipient]) >= uint256(dividendTokenBalanceOf[recipient])\n      uint256(dividendTokenBalanceOf[address(recipient)]) = (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64) + uint256(dividendTokenBalanceOf[recipient])\n      if not stor13[address(recipient)]:\n          stor13[address(recipient)] = 1\n          stor14[recipient] = stor14[address(sender)]\n      stor17[address(sender)] += -1 * Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64 * stor24\n      stor17[recipient] += Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64 * stor24\n  if ext_code.size(recipient) > 0:\n      mem[228 len 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000] = 0, amount, 96, 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000, mem[228 len 0xc0ee0b89ffffffffffffffffffffffffffffffffffffffffffffffffffffff9c]\n      require ext_code.size(recipient)\n      call recipient.tokenFallback(address _from, uint256 _value, bytes _data) with:\n           gas gas_remaining wei\n          args 0, 0, amount, 96, 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000, mem[228 len 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  if not _ethereumToSpend:\n      if 0 <= _ethereumToSpend:\n          if _ethereumToSpend <= 10^14:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Tried to buy tokens with too little eth.'\n          if uint8(stor27.field_160):\n              return (10^18 * _ethereumToSpend / 653 * 10^12)\n          if currentEthInvested >= ethInvestedDuringICO:\n              if _ethereumToSpend == _ethereumToSpend:\n                  if _ethereumToSpend:\n                      s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                      t = (totalSupply / 9615 * 10^6)^3\n                      while s < t:\n                          require s\n                          s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                          t = s\n                          continue \n                      if not t:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if 2 * t / t == 2:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if currentEthInvested + _ethereumToSpend <= ethInvestedDuringICO:\n                  if _ethereumToSpend == _ethereumToSpend:\n                      if _ethereumToSpend:\n                          if _ethereumToSpend:\n                              if 10^18 * _ethereumToSpend / _ethereumToSpend == 10^18:\n                                  if 10^18 * _ethereumToSpend / 653 * 10^12 > 0:\n                                      return (10^18 * _ethereumToSpend / 653 * 10^12)\n              else:\n                  require currentEthInvested < ethInvestedDuringICO\n                  require currentEthInvested + _ethereumToSpend > ethInvestedDuringICO\n                  if currentEthInvested <= ethInvestedDuringICO:\n                      if ethInvestedDuringICO - currentEthInvested <= _ethereumToSpend:\n                          if _ethereumToSpend == _ethereumToSpend:\n                              if not ethInvestedDuringICO - currentEthInvested:\n                                  if _ethereumToSpend - ethInvestedDuringICO + currentEthInvested:\n                                      s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (totalSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 2 * t / t == 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                                      if _ethereumToSpend - ethInvestedDuringICO + currentEthInvested:\n                                          s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                          t = (totalSupply / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 2 * t / t == 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                          if not _ethereumToSpend - ethInvestedDuringICO + currentEthInvested:\n                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                  return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                          else:\n                                              s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                              t = (totalSupply / 9615 * 10^6)^3\n                                              while s < t:\n                                                  require s\n                                                  s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 2 * t / t == 2:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if stor14[caller] * _ethereumToSpend / _ethereumToSpend == stor14[caller]:\n          if stor14[caller] * _ethereumToSpend / 100 <= _ethereumToSpend:\n              if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) <= 10^14:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Tried to buy tokens with too little eth.'\n              if uint8(stor27.field_160):\n                  return (10^18 * _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) / 653 * 10^12)\n              if currentEthInvested >= ethInvestedDuringICO:\n                  if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) == _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                      if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                          s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                          t = (totalSupply / 9615 * 10^6)^3\n                          while s < t:\n                              require s\n                              s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                              t = s\n                              continue \n                          if not t:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 2 * t / t == 2:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested + _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) <= ethInvestedDuringICO:\n                      if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) == _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                          if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                              if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                                  if (10^18 * _ethereumToSpend) - (10^18 * stor14[caller] * _ethereumToSpend / 100) / _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) == 10^18:\n                                      if (10^18 * _ethereumToSpend) - (10^18 * stor14[caller] * _ethereumToSpend / 100) / 653 * 10^12 > 0:\n                                          return ((10^18 * _ethereumToSpend) - (10^18 * stor14[caller] * _ethereumToSpend / 100) / 653 * 10^12)\n                  else:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                              if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) == _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100):\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                                      if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) - ethInvestedDuringICO + currentEthInvested:\n                                          s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                          t = (totalSupply / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 2 * t / t == 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not ethInvestedDuringICO - currentEthInvested:\n                                          if _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) - ethInvestedDuringICO + currentEthInvested:\n                                              s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                              t = (totalSupply / 9615 * 10^6)^3\n                                              while s < t:\n                                                  require s\n                                                  s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 2 * t / t == 2:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                              if not _ethereumToSpend - (stor14[caller] * _ethereumToSpend / 100) - ethInvestedDuringICO + currentEthInvested:\n                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                      return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                              else:\n                                                  s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                                  t = (totalSupply / 9615 * 10^6)^3\n                                                  while s < t:\n                                                      require s\n                                                      s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                      t = s\n                                                      continue \n                                                  if not t:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if 2 * t / t == 2:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef sellPrice(): # not payable\n  if uint8(stor27.field_160):\n      if balanceOf[caller]:\n          if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n              if Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 653 * 10^12:\n                  return (-(Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 653 * 10^12)\n  else:\n      if currentEthInvested < ethInvestedDuringICO:\n          if balanceOf[caller]:\n              if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                  if Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 653 * 10^12:\n                      return (-(Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 653 * 10^12)\n      else:\n          if uint8(stor27.field_160):\n              if balanceOf[caller]:\n                  if 10^15 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 10^15 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                      if Mask(192, 64, 10^15 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 10^15:\n                          return (-(Mask(192, 64, 10^15 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 10^15)\n          else:\n              if currentEthInvested >= ethInvestedDuringICO:\n                  s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                  t = (totalSupply / 9615 * 10^6)^3\n                  while s < t:\n                      require s\n                      s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                      t = s\n                      continue \n                  if not t:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if 2 * t / t == 2:\n                      if 2 * t / 3:\n                          if 3 * 2 * t / 3 / 2 * t / 3 == 3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if (2 * t / 3) + 10^15:\n                              if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested + 10^15 <= ethInvestedDuringICO:\n                      if balanceOf[caller]:\n                          if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                              if Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 653 * 10^12:\n                                  return (-(Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 653 * 10^12)\n                  else:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + 10^15 > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= 10^15:\n                              if not ethInvestedDuringICO - currentEthInvested:\n                                  if -ethInvestedDuringICO + currentEthInvested + 10^15:\n                                      s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (totalSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          if not ethInvestedDuringICO - currentEthInvested:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if 2 * t / t == 2:\n                                              if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                  if (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              else:\n                                                  if (2 * t / 3) + 10^15:\n                                                      if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                                      if -ethInvestedDuringICO + currentEthInvested + 10^15:\n                                          s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                          t = (totalSupply / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              if not ethInvestedDuringICO - currentEthInvested:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          else:\n                                              if 2 * t / t == 2:\n                                                  if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                      if (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  else:\n                                                      if (2 * t / 3) + 10^15:\n                                                          if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                          if not -ethInvestedDuringICO + currentEthInvested + 10^15:\n                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                      if balanceOf[caller]:\n                                                          if not 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                              if 0 <= 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                  return (1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                                          else:\n                                                              if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 100) >> 64 <= 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                      return ((1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 100) >> 64))\n                                          else:\n                                              s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                              t = (totalSupply / 9615 * 10^6)^3\n                                              while s < t:\n                                                  require s\n                                                  s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  if not ethInvestedDuringICO - currentEthInvested:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              else:\n                                                  if 2 * t / t == 2:\n                                                      if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                          if (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3:\n                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                      else:\n                                                          if (2 * t / 3) + 10^15:\n                                                              if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                          else:\n                                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                      if balanceOf[caller]:\n                                                                          if not 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                                          if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef ethereumToTokens_(uint256 _ethereum): # not payable\n  if _ethereum <= 10^14:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Tried to buy tokens with too little eth.'\n  if uint8(stor27.field_160):\n      return (10^18 * _ethereum / 653 * 10^12)\n  if currentEthInvested >= ethInvestedDuringICO:\n      if _ethereum == _ethereum:\n          if _ethereum:\n              s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n              t = (totalSupply / 9615 * 10^6)^3\n              while s < t:\n                  require s\n                  s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                  t = s\n                  continue \n              if not t:\n                  if _ethereum:\n                      if 3 * _ethereum / _ethereum == 3:\n                          s = (3 * _ethereum / 2)^2 + 1 / 3\n                          t = (3 * _ethereum / 2)^2\n                          while s < t:\n                              require s * s\n                              s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                              t = s\n                              continue \n                          if not t:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 9615 * t / t == 9615:\n                              if 0 <= 9615 * t:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if 2 * t / t == 2:\n                      if 2 * t / 3:\n                          require 3 * 2 * t / 3 / 2 * t / 3 == 3\n                          s = (3 * 2 * t / 3 / 2)^2 + 1 / 3\n                          u = (3 * 2 * t / 3 / 2)^2\n                          while s < u:\n                              require s * s\n                              s = ((3 * 2 * t / 3 / 2)^2 / s * s) + (2 * s) / 3\n                              u = s\n                              continue \n                          if not u:\n                              if not (2 * t / 3) + _ethereum:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 9615 * u / u == 9615\n                          if (2 * t / 3) + _ethereum:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if (2 * t / 3) + _ethereum:\n                          if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                              s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                              u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                              while s < u:\n                                  require s * s\n                                  s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                  u = s\n                                  continue \n                              if not u:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 9615 * u / u == 9615:\n                                  if 0 <= 9615 * u:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if currentEthInvested + _ethereum <= ethInvestedDuringICO:\n          if _ethereum == _ethereum:\n              if _ethereum:\n                  if _ethereum:\n                      if 10^18 * _ethereum / _ethereum == 10^18:\n                          if 10^18 * _ethereum / 653 * 10^12 > 0:\n                              return (10^18 * _ethereum / 653 * 10^12)\n      else:\n          require currentEthInvested < ethInvestedDuringICO\n          require currentEthInvested + _ethereum > ethInvestedDuringICO\n          if currentEthInvested <= ethInvestedDuringICO:\n              if ethInvestedDuringICO - currentEthInvested <= _ethereum:\n                  if _ethereum == _ethereum:\n                      if not ethInvestedDuringICO - currentEthInvested:\n                          if _ethereum - ethInvestedDuringICO + currentEthInvested:\n                              s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                              t = (totalSupply / 9615 * 10^6)^3\n                              while s < t:\n                                  require s\n                                  s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                  t = s\n                                  continue \n                              if not t:\n                                  if ethInvestedDuringICO - currentEthInvested:\n                                      require (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3\n                                      s = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                      t = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                      while s < t:\n                                          require s * s\n                                          s = (((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                          t = s\n                                          continue \n                                      if not t:\n                                          if not _ethereum:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 3 * _ethereum / _ethereum == 3\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 9615 * t / t == 9615\n                                      if _ethereum:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if _ethereum:\n                                      if 3 * _ethereum / _ethereum == 3:\n                                          s = (3 * _ethereum / 2)^2 + 1 / 3\n                                          t = (3 * _ethereum / 2)^2\n                                          while s < t:\n                                              require s * s\n                                              s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                                              t = s\n                                              continue \n                                          if not t:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 9615 * t / t == 9615:\n                                              if 0 <= 9615 * t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if 2 * t / t == 2:\n                                      if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                          require (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3\n                                          s = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                          u = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                          while s < u:\n                                              require s * s\n                                              s = (((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                              u = s\n                                              continue \n                                          if not u:\n                                              if not (2 * t / 3) + _ethereum:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 9615 * u / u == 9615\n                                          if (2 * t / 3) + _ethereum:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (2 * t / 3) + _ethereum:\n                                          if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                                              s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                                              u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                                              while s < u:\n                                                  require s * s\n                                                  s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                                  u = s\n                                                  continue \n                                              if not u:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 9615 * u / u == 9615:\n                                                  if 0 <= 9615 * u:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if not ethInvestedDuringICO - currentEthInvested:\n                              if _ethereum - ethInvestedDuringICO + currentEthInvested:\n                                  s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                  t = (totalSupply / 9615 * 10^6)^3\n                                  while s < t:\n                                      require s\n                                      s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                      t = s\n                                      continue \n                                  if not t:\n                                      if ethInvestedDuringICO - currentEthInvested:\n                                          require (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3\n                                          s = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                          t = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                          while s < t:\n                                              require s * s\n                                              s = (((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                              t = s\n                                              continue \n                                          if not t:\n                                              if not _ethereum:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require 3 * _ethereum / _ethereum == 3\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 9615 * t / t == 9615\n                                          if _ethereum:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if _ethereum:\n                                          if 3 * _ethereum / _ethereum == 3:\n                                              s = (3 * _ethereum / 2)^2 + 1 / 3\n                                              t = (3 * _ethereum / 2)^2\n                                              while s < t:\n                                                  require s * s\n                                                  s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 9615 * t / t == 9615:\n                                                  if 0 <= 9615 * t:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if 2 * t / t == 2:\n                                          if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                              require (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3\n                                              s = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                              u = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                              while s < u:\n                                                  require s * s\n                                                  s = (((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                                  u = s\n                                                  continue \n                                              if not u:\n                                                  if not (2 * t / 3) + _ethereum:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require 9615 * u / u == 9615\n                                              if (2 * t / 3) + _ethereum:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (2 * t / 3) + _ethereum:\n                                              if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                                                  s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                                                  u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                                                  while s < u:\n                                                      require s * s\n                                                      s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                                      u = s\n                                                      continue \n                                                  if not u:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if 9615 * u / u == 9615:\n                                                      if 0 <= 9615 * u:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                  if not _ethereum - ethInvestedDuringICO + currentEthInvested:\n                                      if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                          return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                  else:\n                                      s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (totalSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          if ethInvestedDuringICO - currentEthInvested:\n                                              require (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3\n                                              s = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                              t = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                              while s < t:\n                                                  require s * s\n                                                  s = (((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  if not _ethereum:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  require 3 * _ethereum / _ethereum == 3\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require 9615 * t / t == 9615\n                                              if _ethereum:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if not _ethereum:\n                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                  return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                          else:\n                                              if 3 * _ethereum / _ethereum == 3:\n                                                  s = (3 * _ethereum / 2)^2 + 1 / 3\n                                                  t = (3 * _ethereum / 2)^2\n                                                  while s < t:\n                                                      require s * s\n                                                      s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                                                      t = s\n                                                      continue \n                                                  if not t:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if 9615 * t / t == 9615:\n                                                      if 0 <= 9615 * t:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if 2 * t / t == 2:\n                                              if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                  require (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3\n                                                  s = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                                  u = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                                  while s < u:\n                                                      require s * s\n                                                      s = (((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                                      u = s\n                                                      continue \n                                                  if not u:\n                                                      if not (2 * t / 3) + _ethereum:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                      require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  require 9615 * u / u == 9615\n                                                  if (2 * t / 3) + _ethereum:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if not (2 * t / 3) + _ethereum:\n                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                      return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                              else:\n                                                  if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                                                      s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                                                      u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                                                      while s < u:\n                                                          require s * s\n                                                          s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                                          u = s\n                                                          continue \n                                                      if not u:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                      if 9615 * u / u == 9615:\n                                                          if 0 <= 9615 * u:\n                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= totalSupply\n  if _tokensToSell < 10^14:\n      revert with 0, 'Tried to sell too few tokens.'\n  if totalSupply <= stor19:\n      if _tokensToSell == _tokensToSell:\n          if _tokensToSell:\n              if _tokensToSell:\n                  if 653 * 10^12 * _tokensToSell / _tokensToSell == 653 * 10^12:\n                      if 653 * 10^12 * _tokensToSell / 10^18 > 0:\n                          if balanceOf[caller]:\n                              if not 653 * 10^12 * _tokensToSell / 10^18:\n                                  if 0 <= 653 * 10^12 * _tokensToSell / 10^18:\n                                      return (653 * 10^12 * _tokensToSell / 10^18)\n                              else:\n                                  if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 653 * 10^12 * _tokensToSell / 10^18 / 653 * 10^12 * _tokensToSell / 10^18 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                      if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 653 * 10^12 * _tokensToSell / 10^18 / 100) >> 64 <= 653 * 10^12 * _tokensToSell / 10^18:\n                                          return ((653 * 10^12 * _tokensToSell / 10^18) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 653 * 10^12 * _tokensToSell / 10^18 / 100) >> 64))\n  else:\n      if totalSupply - _tokensToSell >= stor19:\n          if _tokensToSell == _tokensToSell:\n              if _tokensToSell:\n                  s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                  t = (totalSupply / 9615 * 10^6)^3\n                  while s < t:\n                      require s\n                      s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                      t = s\n                      continue \n                  if not t:\n                      s = (totalSupply - _tokensToSell / 9615 * 10^6)^3 + 1 / 2\n                      t = (totalSupply - _tokensToSell / 9615 * 10^6)^3\n                      while s < t:\n                          require s\n                          s = ((totalSupply - _tokensToSell / 9615 * 10^6)^3 / s) + s / 2\n                          t = s\n                          continue \n                      if t:\n                          if 2 * t / t == 2:\n                              if 2 * t / 3 <= 0:\n                                  if -2 * t / 3 > 0:\n                                      if balanceOf[caller]:\n                                          if not -2 * t / 3:\n                                              if 0 <= -2 * t / 3:\n                                                  return -(2 * t / 3)\n                                          else:\n                                              if -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / -2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                  if Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= -2 * t / 3:\n                                                      return (-(2 * t / 3) - (Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                  else:\n                      if 2 * t / t == 2:\n                          s = (totalSupply - _tokensToSell / 9615 * 10^6)^3 + 1 / 2\n                          u = (totalSupply - _tokensToSell / 9615 * 10^6)^3\n                          while s < u:\n                              require s\n                              s = ((totalSupply - _tokensToSell / 9615 * 10^6)^3 / s) + s / 2\n                              u = s\n                              continue \n                          if not u:\n                              if 0 <= 2 * t / 3:\n                                  if 2 * t / 3 > 0:\n                                      if balanceOf[caller]:\n                                          if not 2 * t / 3:\n                                              if 0 <= 2 * t / 3:\n                                                  return (2 * t / 3)\n                                          else:\n                                              if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                  if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= 2 * t / 3:\n                                                      return ((2 * t / 3) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                          else:\n                              if 2 * u / u == 2:\n                                  if 2 * u / 3 <= 2 * t / 3:\n                                      if (2 * t / 3) - (2 * u / 3) > 0:\n                                          if balanceOf[caller]:\n                                              if not (2 * t / 3) - (2 * u / 3):\n                                                  if 0 <= (2 * t / 3) - (2 * u / 3):\n                                                      return ((2 * t / 3) - (2 * u / 3))\n                                              else:\n                                                  if (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                      if Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= (2 * t / 3) - (2 * u / 3):\n                                                          return ((2 * t / 3) - (2 * u / 3) - (Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n      else:\n          require totalSupply > stor19\n          require totalSupply - _tokensToSell < stor19\n          if stor19 <= totalSupply:\n              if totalSupply - stor19 <= _tokensToSell:\n                  if _tokensToSell == _tokensToSell:\n                      if not _tokensToSell - totalSupply + stor19:\n                          if totalSupply - stor19:\n                              s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                              t = (totalSupply / 9615 * 10^6)^3\n                              while s < t:\n                                  require s\n                                  s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                  t = s\n                                  continue \n                              if not t:\n                                  s = (stor19 / 9615 * 10^6)^3 + 1 / 2\n                                  t = (stor19 / 9615 * 10^6)^3\n                                  while s < t:\n                                      require s\n                                      s = ((stor19 / 9615 * 10^6)^3 / s) + s / 2\n                                      t = s\n                                      continue \n                                  if t:\n                                      if 2 * t / t == 2:\n                                          if 2 * t / 3 <= 0:\n                                              if -2 * t / 3 > 0:\n                                                  if balanceOf[caller]:\n                                                      if not -2 * t / 3:\n                                                          if 0 <= -2 * t / 3:\n                                                              return -(2 * t / 3)\n                                                      else:\n                                                          if -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / -2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                              if Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= -2 * t / 3:\n                                                                  return (-(2 * t / 3) - (Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                              else:\n                                  if 2 * t / t == 2:\n                                      s = (stor19 / 9615 * 10^6)^3 + 1 / 2\n                                      u = (stor19 / 9615 * 10^6)^3\n                                      while s < u:\n                                          require s\n                                          s = ((stor19 / 9615 * 10^6)^3 / s) + s / 2\n                                          u = s\n                                          continue \n                                      if not u:\n                                          if 0 <= 2 * t / 3:\n                                              if 2 * t / 3 > 0:\n                                                  if balanceOf[caller]:\n                                                      if not 2 * t / 3:\n                                                          if 0 <= 2 * t / 3:\n                                                              return (2 * t / 3)\n                                                      else:\n                                                          if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                              if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= 2 * t / 3:\n                                                                  return ((2 * t / 3) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                                      else:\n                                          if 2 * u / u == 2:\n                                              if 2 * u / 3 <= 2 * t / 3:\n                                                  if (2 * t / 3) - (2 * u / 3) > 0:\n                                                      if balanceOf[caller]:\n                                                          if not (2 * t / 3) - (2 * u / 3):\n                                                              if 0 <= (2 * t / 3) - (2 * u / 3):\n                                                                  return ((2 * t / 3) - (2 * u / 3))\n                                                          else:\n                                                              if (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= (2 * t / 3) - (2 * u / 3):\n                                                                      return ((2 * t / 3) - (2 * u / 3) - (Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                      else:\n                          if not _tokensToSell - totalSupply + stor19:\n                              if totalSupply - stor19:\n                                  s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                  t = (totalSupply / 9615 * 10^6)^3\n                                  while s < t:\n                                      require s\n                                      s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                      t = s\n                                      continue \n                                  if not t:\n                                      s = (stor19 / 9615 * 10^6)^3 + 1 / 2\n                                      t = (stor19 / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((stor19 / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if t:\n                                          if 2 * t / t == 2:\n                                              if 2 * t / 3 <= 0:\n                                                  if -2 * t / 3 > 0:\n                                                      if balanceOf[caller]:\n                                                          if not -2 * t / 3:\n                                                              if 0 <= -2 * t / 3:\n                                                                  return -(2 * t / 3)\n                                                          else:\n                                                              if -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / -2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= -2 * t / 3:\n                                                                      return (-(2 * t / 3) - (Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                                  else:\n                                      if 2 * t / t == 2:\n                                          s = (stor19 / 9615 * 10^6)^3 + 1 / 2\n                                          u = (stor19 / 9615 * 10^6)^3\n                                          while s < u:\n                                              require s\n                                              s = ((stor19 / 9615 * 10^6)^3 / s) + s / 2\n                                              u = s\n                                              continue \n                                          if not u:\n                                              if 0 <= 2 * t / 3:\n                                                  if 2 * t / 3 > 0:\n                                                      if balanceOf[caller]:\n                                                          if not 2 * t / 3:\n                                                              if 0 <= 2 * t / 3:\n                                                                  return (2 * t / 3)\n                                                          else:\n                                                              if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= 2 * t / 3:\n                                                                      return ((2 * t / 3) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                                          else:\n                                              if 2 * u / u == 2:\n                                                  if 2 * u / 3 <= 2 * t / 3:\n                                                      if (2 * t / 3) - (2 * u / 3) > 0:\n                                                          if balanceOf[caller]:\n                                                              if not (2 * t / 3) - (2 * u / 3):\n                                                                  if 0 <= (2 * t / 3) - (2 * u / 3):\n                                                                      return ((2 * t / 3) - (2 * u / 3))\n                                                              else:\n                                                                  if (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                      if Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= (2 * t / 3) - (2 * u / 3):\n                                                                          return ((2 * t / 3) - (2 * u / 3) - (Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                          else:\n                              if (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / _tokensToSell - totalSupply + stor19 == 653 * 10^12:\n                                  if not totalSupply - stor19:\n                                      if (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 > 0:\n                                          if balanceOf[caller]:\n                                              if not (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18:\n                                                  if 0 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18:\n                                                      return ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18)\n                                              else:\n                                                  if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 / (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                      if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 / 100) >> 64 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18:\n                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 / 100) >> 64))\n                                  else:\n                                      s = (totalSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (totalSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((totalSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          s = (stor19 / 9615 * 10^6)^3 + 1 / 2\n                                          t = (stor19 / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((stor19 / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              if (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 > 0:\n                                                  if balanceOf[caller]:\n                                                      if not (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18:\n                                                          if 0 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18:\n                                                              return ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18)\n                                                      else:\n                                                          if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 / (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                              if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 / 100) >> 64 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18:\n                                                                  return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 / 100) >> 64))\n                                          else:\n                                              if 2 * t / t == 2:\n                                                  if 2 * t / 3 <= 0:\n                                                      if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3) > 0:\n                                                          if balanceOf[caller]:\n                                                              if not ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3):\n                                                                  if 0 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3):\n                                                                      return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3))\n                                                              else:\n                                                                  if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                      if Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3):\n                                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) - (2 * t / 3) - (Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                                      else:\n                                          if 2 * t / t == 2:\n                                              s = (stor19 / 9615 * 10^6)^3 + 1 / 2\n                                              u = (stor19 / 9615 * 10^6)^3\n                                              while s < u:\n                                                  require s\n                                                  s = ((stor19 / 9615 * 10^6)^3 / s) + s / 2\n                                                  u = s\n                                                  continue \n                                              if not u:\n                                                  if 0 <= 2 * t / 3:\n                                                      if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) > 0:\n                                                          if balanceOf[caller]:\n                                                              if not ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3):\n                                                                  if 0 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3):\n                                                                      return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3))\n                                                              else:\n                                                                  if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                      if Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3):\n                                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                                              else:\n                                                  if 2 * u / u == 2:\n                                                      if 2 * u / 3 <= 2 * t / 3:\n                                                          if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3) > 0:\n                                                              if balanceOf[caller]:\n                                                                  if not ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3):\n                                                                      if 0 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3):\n                                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3))\n                                                                  else:\n                                                                      if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                          if Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3):\n                                                                              return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18) + (2 * t / 3) - (2 * u / 3) - (Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * totalSupply) + (653 * 10^12 * stor19) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n  revert\n\ndef buyAndTransfer(address _referredBy, address target) payable: \n  require uint8(stor27.field_168)\n  if stor13[caller]:\n      if not uint8(stor27.field_160):\n          require uint8(stor27.field_168)\n          if not uint8(stor27.field_160):\n              require stor12[20]\n              stor13[caller] = 1\n              stor14[caller] = 20\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=20)\n              if call.value >= 10^14:\n                  if uint8(stor27.field_168):\n                      if call.value / 100:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                      else:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100):\n                              require 0 <= call.value - (call.value / 100)\n                          else:\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value == call.value\n                                      require call.value\n                                      if call.value:\n                          else:\n                              if stor7 != caller:\n                                  if uint8(stor27.field_160):\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                      else:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              require call.value - (stor14[caller] * call.value / 100)\n                          else:\n                              if caller == stor7:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                              if call.value - (stor14[caller] * call.value / 100):\n              else:\n                  if stor7 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if uint8(stor27.field_168):\n                      if not call.value / 100:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 0 <= call.value - (call.value / 100)\n                      else:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                  else:\n                      if call.value:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          if call.value - (stor14[caller] * call.value / 100):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if caller == stor7:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n  else:\n      if not uint8(stor27.field_160):\n          require uint8(stor27.field_168)\n          if not uint8(stor27.field_160):\n              require stor12[20]\n              stor13[caller] = 1\n              stor14[caller] = 20\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=20)\n              if call.value >= 10^14:\n                  if uint8(stor27.field_168):\n                      if not call.value / 100:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                          else:\n                              require 0 <= call.value - (call.value / 100)\n                              if uint8(stor27.field_160):\n                      else:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          else:\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                  else:\n                      if call.value:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                      if call.value - (stor14[caller] * call.value / 100):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if uint8(stor27.field_160):\n                                      if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * call.value / call.value == 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if caller == stor7:\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value == call.value\n                                      require call.value\n                                      if call.value:\n              else:\n                  if stor7 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if uint8(stor27.field_168):\n                      if call.value / 100:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                      else:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100):\n                              require 0 <= call.value - (call.value / 100)\n                          else:\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value == call.value\n                                      require call.value\n                                      if call.value:\n                          else:\n                              if stor7 != caller:\n                                  if uint8(stor27.field_160):\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                      else:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              require call.value - (stor14[caller] * call.value / 100)\n                          else:\n                              if caller == stor7:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                              if call.value - (stor14[caller] * call.value / 100):\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass) payable: \n  if not uint8(stor27.field_160):\n      require uint8(stor27.field_168)\n      if not uint8(stor27.field_160):\n          require stor12[_divChoice << 248]\n          stor13[caller] = 1\n          stor14[caller] = _divChoice\n          log UserDividendRate(\n                address user=caller,\n                uint256 divRate=_divChoice)\n          if call.value >= 10^14:\n              if uint8(stor27.field_168):\n                  if call.value / 100:\n                      require stor3 * call.value / 100 / call.value / 100 == stor3\n                      require call.value / 100 <= call.value\n                      require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (call.value / 100) - (stor3 * call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if not uint8(stor27.field_160):\n                          else:\n                              if caller == stor7:\n                              else:\n                                  if not uint8(stor27.field_160):\n                  else:\n                      require call.value / 100 <= call.value\n                      require 0 <= call.value - (call.value / 100)\n                      if not call.value - (call.value / 100):\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if not uint8(stor27.field_160):\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                          else:\n                              if not uint8(stor27.field_160):\n                      else:\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if caller == stor7:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n              else:\n                  if call.value:\n                      require stor14[caller] * call.value / call.value == stor14[caller]\n                      require stor14[caller] * call.value / 100 <= call.value\n                      if not uint8(stor27.field_160):\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                  require (10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + stor23 >= stor23\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                              require stor23 >= stor23\n                              currentEthInvested = call.value - (stor14[caller] * call.value / 100) + currentEthInvested\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                      if not call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                      else:\n                          if caller == stor7:\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  else:\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value / 653 * 10^12\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value == call.value:\n                                          if call.value:\n                                              if not call.value:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 10^18 * call.value / call.value == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              revert\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                  require stor23 >= stor23\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                      if not call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100)\n                  else:\n                      require 0 <= call.value\n                      if call.value <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not uint8(stor27.field_160):\n                          if uint8(stor27.field_160):\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value / 653 * 10^12\n                                  require stor23 >= stor23\n                                  currentEthInvested += call.value\n                                  if uint8(stor27.field_160):\n                              else:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value / 653 * 10^12\n                                  require (10^18 * stor14[caller] * call.value / 653 * 10^12) + stor23 >= stor23\n                                  stor23 += 10^18 * stor14[caller] * call.value / 653 * 10^12\n                                  currentEthInvested += call.value\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * call.value / call.value == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value\n                                  require call.value == call.value\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                      else:\n                          if caller == stor7:\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                      totalSupply += 10^18 * call.value / 653 * 10^12\n                                      require stor23 >= stor23\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value / 653 * 10^12\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 10^18 * call.value / call.value == 10^18\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      require ethInvestedDuringICO - currentEthInvested <= call.value\n                          else:\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                      totalSupply += 10^18 * call.value / 653 * 10^12\n                                      require (10^18 * stor14[caller] * call.value / 653 * 10^12) + stor23 >= stor23\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value / 653 * 10^12\n                                  require stor23 >= stor23\n                                  currentEthInvested += call.value\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 10^18 * call.value / call.value == 10^18\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      require ethInvestedDuringICO - currentEthInvested <= call.value\n                                      require call.value == call.value\n          else:\n              if stor7 != caller:\n                  revert with 0, 'Tried to buy below the min eth buyin threshold.'\n              if uint8(stor27.field_168):\n                  if call.value / 100:\n                      require stor3 * call.value / 100 / call.value / 100 == stor3\n                      require call.value / 100 <= call.value\n                      require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                          else:\n                              if stor7 != caller:\n                      else:\n                          require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  else:\n                      require call.value / 100 <= call.value\n                      require 0 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if not uint8(stor27.field_160):\n                          else:\n                              if caller == stor7:\n                              else:\n                                  if not uint8(stor27.field_160):\n              else:\n                  if call.value:\n                      require stor14[caller] * call.value / call.value == stor14[caller]\n                      require stor14[caller] * call.value / 100 <= call.value\n                      if not uint8(stor27.field_160):\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                  require stor23 >= stor23\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                      if not call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor7 != caller:\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                              else:\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                  if call.value - (stor14[caller] * call.value / 100):\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                      if call.value - (stor14[caller] * call.value / 100):\n                                          if not call.value - (stor14[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      revert\n                  require 0 <= call.value\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not uint8(stor27.field_160):\n                      if uint8(stor27.field_160):\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              require (10^18 * stor14[caller] * call.value / 653 * 10^12) + stor23 >= stor23\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                          require stor23 >= stor23\n                          currentEthInvested += call.value\n                      else:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * call.value / call.value == 10^18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              require ethInvestedDuringICO - currentEthInvested <= call.value\n                              require call.value == call.value\n                  else:\n                      if caller == stor7:\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              else:\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      if uint8(stor27.field_160):\n                          if not 10^18 * call.value / 653 * 10^12:\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              require stor23 >= stor23\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                      else:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * call.value / call.value == 10^18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              require ethInvestedDuringICO - currentEthInvested <= call.value\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice) payable: \n  require uint8(stor27.field_168)\n  if not stor13[caller]:\n      if not uint8(stor27.field_160):\n          require uint8(stor27.field_168)\n          if not uint8(stor27.field_160):\n              require stor12[divChoice << 248]\n              stor13[caller] = 1\n              stor14[caller] = divChoice\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=divChoice)\n              if call.value >= 10^14:\n                  if uint8(stor27.field_168):\n                      if not call.value / 100:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 0 <= call.value - (call.value / 100)\n                      else:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                  else:\n                      if call.value:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          if call.value - (stor14[caller] * call.value / 100):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if caller == stor7:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n              else:\n                  if stor7 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if uint8(stor27.field_168):\n                      if call.value / 100:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100):\n                              require 0 <= call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                      else:\n                                          require call.value == call.value\n                                          if call.value:\n                          else:\n                              if stor7 != caller:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                          else:\n                              if caller == stor7:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      else:\n                                          require call.value == call.value\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n  else:\n      if not divChoice:\n          if call.value >= 10^14:\n              if uint8(stor27.field_168):\n                  if call.value / 100:\n                      require stor3 * call.value / 100 / call.value / 100 == stor3\n                      require call.value / 100 <= call.value\n                      require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if uint8(stor27.field_160):\n                      else:\n                          require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                          else:\n                              if stor7 != caller:\n                  else:\n                      require call.value / 100 <= call.value\n                      require 0 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                          else:\n                              if stor7 != caller:\n                      else:\n                          require 0 <= call.value - (call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if not call.value:\n                  if 0 <= call.value:\n                      if call.value <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not uint8(stor27.field_160):\n                          if uint8(stor27.field_160):\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value / 653 * 10^12\n                                  require stor23 >= stor23\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * call.value / call.value == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor7 != caller:\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              else:\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor14[caller] * call.value / call.value == stor14[caller]:\n                      if stor14[caller] * call.value / 100 <= call.value:\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                  else:\n                                  require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                      if call.value - (stor14[caller] * call.value / 100):\n                                          if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                          if call.value - (stor14[caller] * call.value / 100):\n                                              if not call.value - (stor14[caller] * call.value / 100):\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                          require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                          require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                      totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                          if call.value - (stor14[caller] * call.value / 100):\n                                              if not call.value - (stor14[caller] * call.value / 100):\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if uint8(stor27.field_160):\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              revert\n          if stor7 != caller:\n              revert with 0, 'Tried to buy below the min eth buyin threshold.'\n          if uint8(stor27.field_168):\n              if not call.value / 100:\n                  require call.value / 100 <= call.value\n                  require 0 <= call.value - (call.value / 100)\n                  if call.value - (call.value / 100):\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                      if uint8(stor27.field_160):\n                  else:\n                      require 0 <= call.value - (call.value / 100)\n                      if not uint8(stor27.field_160):\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          if stor7 != caller:\n              else:\n                  require stor3 * call.value / 100 / call.value / 100 == stor3\n                  require call.value / 100 <= call.value\n                  require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                  if not call.value - (call.value / 100) - (stor3 * call.value / 100):\n                      require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                  else:\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                  if uint8(stor27.field_160):\n          else:\n              if not call.value:\n                  require 0 <= call.value\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not uint8(stor27.field_160):\n                      if uint8(stor27.field_160):\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                          else:\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          if call.value == call.value:\n                              if call.value:\n                                  if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if stor7 != caller:\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if uint8(stor27.field_160):\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if call.value == call.value:\n                              if call.value:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 10^18 * call.value / call.value == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require stor14[caller] * call.value / call.value == stor14[caller]\n              require stor14[caller] * call.value / 100 <= call.value\n              if not uint8(stor27.field_160):\n                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if uint8(stor27.field_160):\n                      if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                          require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                          require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                      totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                      require call.value - (stor14[caller] * call.value / 100)\n                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                          if call.value - (stor14[caller] * call.value / 100):\n                              if not call.value - (stor14[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if stor7 != caller:\n                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if uint8(stor27.field_160):\n                      if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                          require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                      require call.value - (stor14[caller] * call.value / 100)\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                      require currentEthInvested <= ethInvestedDuringICO\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                  require call.value - (stor14[caller] * call.value / 100)\n                  if not call.value - (stor14[caller] * call.value / 100):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if call.value <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if uint8(stor27.field_160):\n                  if 10^18 * call.value / 653 * 10^12:\n                      require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                  else:\n                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value > ethInvestedDuringICO\n                          require currentEthInvested <= ethInvestedDuringICO\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.value == call.value\n                      require call.value\n                      if call.value:\n      else:\n          if not uint8(stor27.field_160):\n              require uint8(stor27.field_168)\n              if not uint8(stor27.field_160):\n                  require stor12[divChoice << 248]\n                  stor13[caller] = 1\n                  stor14[caller] = divChoice\n                  log UserDividendRate(\n                        address user=caller,\n                        uint256 divRate=divChoice)\n                  if call.value >= 10^14:\n                      if uint8(stor27.field_168):\n                          if call.value / 100:\n                              require stor3 * call.value / 100 / call.value / 100 == stor3\n                              require call.value / 100 <= call.value\n                              require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                                  require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require call.value / 100 <= call.value\n                              require 0 <= call.value - (call.value / 100)\n                              if not call.value - (call.value / 100):\n                                  require 0 <= call.value - (call.value / 100)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                      else:\n                          if not call.value:\n                              require 0 <= call.value\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                              else:\n                                  if stor7 != caller:\n                                      if not uint8(stor27.field_160):\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n                                  else:\n                                      if not uint8(stor27.field_160):\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n                          else:\n                              require stor14[caller] * call.value / call.value == stor14[caller]\n                              require stor14[caller] * call.value / 100 <= call.value\n                              if not uint8(stor27.field_160):\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if caller == stor7:\n                                      if call.value <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not uint8(stor27.field_160):\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                                  else:\n                                      if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not uint8(stor27.field_160):\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                              require call.value - (stor14[caller] * call.value / 100)\n                                          else:\n                                              if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                  else:\n                      if stor7 != caller:\n                          revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                      if uint8(stor27.field_168):\n                          if not call.value / 100:\n                              require call.value / 100 <= call.value\n                              require 0 <= call.value - (call.value / 100)\n                              if call.value - (call.value / 100):\n                                  require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if call.value:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      else:\n                                          require call.value == call.value\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if not uint8(stor27.field_160):\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                      else:\n                                          require call.value == call.value\n                          else:\n                              if caller == stor7:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      else:\n                                          require call.value == call.value\n                              else:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef _fallback(?) payable: # default function\n  if calldata.size < 4:\n      require uint8(stor27.field_168)\n      if stor13[caller]:\n          if call.value >= 10^14:\n              if uint8(stor27.field_168):\n                  if call.value / 100:\n                      require stor3 * call.value / 100 / call.value / 100 == stor3\n                      require call.value / 100 <= call.value\n                      require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                          else:\n                              if stor7 != caller:\n                      else:\n                          require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  else:\n                      require call.value / 100 <= call.value\n                      require 0 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100):\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                          if not uint8(stor27.field_160):\n                              if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if not uint8(stor27.field_160):\n                          else:\n                              if caller == stor7:\n                              else:\n                                  if not uint8(stor27.field_160):\n              else:\n                  if call.value:\n                      require stor14[caller] * call.value / call.value == stor14[caller]\n                      require stor14[caller] * call.value / 100 <= call.value\n                      if not uint8(stor27.field_160):\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if not 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                  require stor23 >= stor23\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if currentEthInvested + call.value - (stor14[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                      if not call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor7 != caller:\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                              else:\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                  if call.value - (stor14[caller] * call.value / 100):\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                      if call.value - (stor14[caller] * call.value / 100):\n                                          if not call.value - (stor14[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      revert\n                  require 0 <= call.value\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not uint8(stor27.field_160):\n                      if uint8(stor27.field_160):\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              require (10^18 * stor14[caller] * call.value / 653 * 10^12) + stor23 >= stor23\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                          require stor23 >= stor23\n                          currentEthInvested += call.value\n                      else:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * call.value / call.value == 10^18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              require ethInvestedDuringICO - currentEthInvested <= call.value\n                              require call.value == call.value\n                  else:\n                      if caller == stor7:\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              else:\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      if uint8(stor27.field_160):\n                          if not 10^18 * call.value / 653 * 10^12:\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              require stor23 >= stor23\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                      else:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * call.value / call.value == 10^18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              require ethInvestedDuringICO - currentEthInvested <= call.value\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if stor7 != caller:\n              revert with 0, 'Tried to buy below the min eth buyin threshold.'\n          if uint8(stor27.field_168):\n              if call.value / 100:\n                  require stor3 * call.value / 100 / call.value / 100 == stor3\n                  require call.value / 100 <= call.value\n                  require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                  if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                      if uint8(stor27.field_160):\n                  else:\n                      require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                      if not uint8(stor27.field_160):\n                          if call.value - (call.value / 100) - (stor3 * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          if stor7 != caller:\n              else:\n                  require call.value / 100 <= call.value\n                  require 0 <= call.value - (call.value / 100)\n                  if call.value - (call.value / 100):\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                      require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                      if not uint8(stor27.field_160):\n                          if call.value - (call.value / 100) - ((call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          if stor7 != caller:\n                  else:\n                      require 0 <= call.value - (call.value / 100)\n                      if not uint8(stor27.field_160):\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                      else:\n                          if stor7 != caller:\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.value:\n              if 0 <= call.value:\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not uint8(stor27.field_160):\n                      if uint8(stor27.field_160):\n                          if not 10^18 * call.value / 653 * 10^12:\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value / 653 * 10^12\n                              require stor23 >= stor23\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                      else:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * call.value / call.value == 10^18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              require ethInvestedDuringICO - currentEthInvested <= call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if stor7 != caller:\n                      if uint8(stor27.field_160):\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                          else:\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          if call.value == call.value:\n                              if call.value:\n                                  if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if uint8(stor27.field_160):\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                              require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                          totalSupply += 10^18 * call.value / 653 * 10^12\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value == call.value\n                          require call.value\n                          if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value == call.value:\n                              if call.value:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 10^18 * call.value / call.value == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if stor14[caller] * call.value / call.value == stor14[caller]:\n                  if stor14[caller] * call.value / 100 <= call.value:\n                      if not uint8(stor27.field_160):\n                          if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if uint8(stor27.field_160):\n                              if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                  require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                              else:\n                              require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                              totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                  if call.value - (stor14[caller] * call.value / 100):\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                      if call.value - (stor14[caller] * call.value / 100):\n                                          if not call.value - (stor14[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if stor7 != caller:\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                                      require 10^18 * stor14[caller] * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12 == stor14[caller]\n                                      require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require (10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12) + totalSupply >= totalSupply\n                                  totalSupply += 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                  require call.value - (stor14[caller] * call.value / 100)\n                                  if (totalSupply / 9615 * 10^6)^3 + 1 / 2 < (totalSupply / 9615 * 10^6)^3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value - (stor14[caller] * call.value / 100):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100):\n                                      if call.value - (stor14[caller] * call.value / 100):\n                                          if not call.value - (stor14[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (10^18 * call.value) - (10^18 * stor14[caller] * call.value / 100) / call.value - (stor14[caller] * call.value / 100) == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      require (10^18 * call.value / 653 * 10^12) + totalSupply >= totalSupply\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          revert\n      if not uint8(stor27.field_160):\n          require uint8(stor27.field_168)\n          if not uint8(stor27.field_160):\n              require stor12[20]\n              stor13[caller] = 1\n              stor14[caller] = 20\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=20)\n              if call.value >= 10^14:\n                  if uint8(stor27.field_168):\n                      if not call.value / 100:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / 100 <= call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 0 <= call.value - (call.value / 100)\n                      else:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require 0 <= call.value - (call.value / 100) - (stor3 * call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                  else:\n                      if call.value:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value - (stor14[caller] * call.value / 100) / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          if call.value - (stor14[caller] * call.value / 100):\n                          else:\n                              if stor7 != caller:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor14[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor14[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if caller == stor7:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if uint8(stor27.field_160):\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n              else:\n                  if stor7 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if uint8(stor27.field_168):\n                      if call.value / 100:\n                          require stor3 * call.value / 100 / call.value / 100 == stor3\n                          require call.value / 100 <= call.value\n                          require stor3 * call.value / 100 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) - (stor3 * call.value / 100):\n                              require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) - (stor3 * call.value / 100 * stor14[caller]) / call.value - (call.value / 100) - (stor3 * call.value / 100) == stor14[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          require call.value / 100 <= call.value\n                          require 0 <= call.value - (call.value / 100)\n                          if not call.value - (call.value / 100):\n                              require 0 <= call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (call.value * stor14[caller]) - (call.value / 100 * stor14[caller]) / call.value - (call.value / 100) == stor14[caller]\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not uint8(stor27.field_160):\n                              if uint8(stor27.field_160):\n                                  if 10^18 * call.value / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                      else:\n                                          require call.value == call.value\n                                          if call.value:\n                          else:\n                              if stor7 != caller:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require stor14[caller] * call.value / call.value == stor14[caller]\n                          require stor14[caller] * call.value / 100 <= call.value\n                          if not uint8(stor27.field_160):\n                              if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not uint8(stor27.field_160):\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                      require call.value - (stor14[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                          else:\n                              if caller == stor7:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      else:\n                                          require call.value == call.value\n                              else:\n                                  if call.value - (stor14[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not uint8(stor27.field_160):\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n                                          require call.value - (stor14[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor14[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor14[caller] * call.value / 100) == call.value - (stor14[caller] * call.value / 100)\n  else:\n      if uint32(call.func_hash) == dividendsOf(address _customerAddress):\n          require not call.value\n          return (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64)\n      if totalEthereumICOReceived() == uint32(call.func_hash):\n          require not call.value\n          return ethInvestedDuringICO\n      if name() == uint32(call.func_hash):\n          require not call.value\n      else:\n          if approve(address spender, uint256 amount) == uint32(call.func_hash):\n              require not call.value\n              allowed[caller][address(_param1)] = _param2\n              log Approval(\n                    address owner=_param2,\n                    address spender=caller,\n                    uint256 value=_param1)\n              return 1\n          if icoHashedPass() == uint32(call.func_hash):\n              require not call.value\n              return 0xbc01e2c48062bbd576f26d72d8ceffdacd379582fb42d3d0eff647b3f52d370\n          if setPercentage(uint256 referrerPercentage1, uint256 referrerPercentage2, uint256 referrerPercentage3, uint256 bankrollPercentage) == uint32(call.func_hash):\n              require not call.value\n              require stor25[caller]\n              require _param1 >= 0\n              require _param2 >= 0\n              require _param3 >= 0\n              require _param4 >= 0\n              stor0 = _param1\n              stor1 = _param2\n              stor2 = _param3\n              stor3 = _param4\n              stop\n          if calculateTokensReceived(uint256 _ethereumToSpend) == uint32(call.func_hash):\n              require not call.value\n              if _param1:\n                  require stor14[caller] * _param1 / _param1 == stor14[caller]\n                  require stor14[caller] * _param1 / 100 <= _param1\n                  if _param1 - (stor14[caller] * _param1 / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if uint8(stor27.field_160):\n                      return (10^18 * _param1 - (stor14[caller] * _param1 / 100) / 653 * 10^12)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      if _param1 - (stor14[caller] * _param1 / 100) == _param1 - (stor14[caller] * _param1 / 100):\n                          if _param1 - (stor14[caller] * _param1 / 100):\n                              if (totalSupply / 9615 * 10^6)^3 + 1 / 2 >= (totalSupply / 9615 * 10^6)^3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (totalSupply / 9615 * 10^6)^3 + 1 / 2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if currentEthInvested + _param1 - (stor14[caller] * _param1 / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + _param1 - (stor14[caller] * _param1 / 100) > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= _param1 - (stor14[caller] * _param1 / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if _param1 - (stor14[caller] * _param1 / 100) == _param1 - (stor14[caller] * _param1 / 100):\n                              if _param1 - (stor14[caller] * _param1 / 100):\n                                  if not _param1 - (stor14[caller] * _param1 / 100):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (10^18 * _param1) - (10^18 * stor14[caller] * _param1 / 100) / _param1 - (stor14[caller] * _param1 / 100) == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require 0 <= _param1\n              if _param1 <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if uint8(stor27.field_160):\n                  return (10^18 * _param1 / 653 * 10^12)\n              if currentEthInvested >= ethInvestedDuringICO:\n                  require _param1 == _param1\n                  require _param1\n              else:\n                  if currentEthInvested + _param1 <= ethInvestedDuringICO:\n                      require _param1 == _param1\n                      require _param1\n                      if not _param1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 10^18 * _param1 / _param1 == 10^18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require currentEthInvested < ethInvestedDuringICO\n                  require currentEthInvested + _param1 > ethInvestedDuringICO\n                  require currentEthInvested <= ethInvestedDuringICO\n                  require ethInvestedDuringICO - currentEthInvested <= _param1\n          else:\n              if totalSupply() == uint32(call.func_hash):\n                  require not call.value\n                  return totalSupply\n              if transferTo(address _from, address _to, uint256 _amountOfTokens, bytes _data) == uint32(call.func_hash):\n                  require not call.value\n                  require _param3 >= 10^10\n                  require _param3 <= balanceOf[address(_param1)]\n                  if caller == _param1:\n                      require uint8(stor27.field_168)\n                      require address(_param2)\n                      if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)] <= 0:\n                          require balanceOf[address(_param1)]\n                          if not _param3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require Mask(192, 0, dividendTokenBalanceOf[address(_param1)]) / balanceOf[address(_param1)] * _param3 / _param3 == Mask(192, 0, dividendTokenBalanceOf[address(_param1)]) / balanceOf[address(_param1)]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor17[address(_param1)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)])\n                      stor15[address(_param1)] = 0\n                      call _param1 with:\n                         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)] wei\n                           gas 2300 * is_zero(value) wei\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      log onWithdraw(\n                            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)]),\n                            uint256 ethereumWithdrawn=_param1)\n                  else:\n                      require _param3 <= allowed[address(_param1)][caller]\n                      require uint8(stor27.field_168)\n                      require address(_param2)\n                      if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)] <= 0:\n                          require balanceOf[address(_param1)]\n                          if _param3:\n                      else:\n                          stor17[address(_param1)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)])\n                          stor15[address(_param1)] = 0\n                          call _param1 with:\n                             value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)] wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          log onWithdraw(\n                                address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)]),\n                                uint256 ethereumWithdrawn=_param1)\n              else:\n                  if currentEthInvested() == uint32(call.func_hash):\n                      require not call.value\n                      return currentEthInvested\n                  if regularPhase() == uint32(call.func_hash):\n                      require not call.value\n                      return bool(uint8(stor27.field_168))\n                  if calculateEthereumReceived(uint256 _tokensToSell) == uint32(call.func_hash):\n                      require not call.value\n                      require _param1 <= totalSupply\n                      if _param1 < 10^14:\n                          revert with 0, 'Tried to sell too few tokens.'\n                      if totalSupply <= stor19:\n                          require _param1 == _param1\n                          require _param1\n                          require _param1\n                          require 653 * 10^12 * _param1 / _param1 == 653 * 10^12\n                          require 653 * 10^12 * _param1 / 10^18 > 0\n                          require balanceOf[caller]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if totalSupply - _param1 >= stor19:\n                          require _param1 == _param1\n                          require _param1\n                      else:\n                          require totalSupply > stor19\n                          require totalSupply - _param1 < stor19\n                          require stor19 <= totalSupply\n                          require totalSupply - stor19 <= _param1\n                          require _param1 == _param1\n                          if not _param1 - totalSupply + stor19:\n                              require totalSupply - stor19\n                          else:\n                              if _param1 - totalSupply + stor19:\n                  else:\n                      if transferFrom(address sender, address recipient, uint256 amount) == uint32(call.func_hash):\n                          require not call.value\n                          require _param3 >= 10^10\n                          require _param3 <= balanceOf[address(_param1)]\n                          require _param3 <= allowed[address(_param1)][caller]\n                          require uint8(stor27.field_168)\n                          require address(_param2)\n                          if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor24) - stor17[address(_param1)]) >> 64) + stor15[address(_param1)] <= 0:\n                              require balanceOf[address(_param1)]\n                      else:\n                          if buyAndTransfer(address _referredBy, address target) == uint32(call.func_hash):\n                              require uint8(stor27.field_168)\n                              if not stor13[caller]:\n                                  if not uint8(stor27.field_160):\n                                      require uint8(stor27.field_168)\n                                      if not uint8(stor27.field_160):\n                                          require stor12[20]\n                                          stor13[caller] = 1\n                                          stor14[caller] = 20\n                                          log UserDividendRate(\n                                                address user=caller,\n                                                uint256 divRate=20)\n                                          if call.value >= 10^14:\n                                              if not uint8(stor27.field_168):\n                                                  if not call.value:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if stor14[caller] * call.value / call.value == stor14[caller]:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              else:\n                                                  if not call.value / 100:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if stor3 * call.value / 100 / call.value / 100 == stor3:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              revert\n                                          if stor7 != caller:\n                                              revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                                          if not uint8(stor27.field_168):\n                                              if not call.value:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require stor14[caller] * call.value / call.value == stor14[caller]\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if call.value / 100:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(stor27.field_160):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(stor27.field_168)\n                              if uint8(stor27.field_160):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require stor12[20]\n                              stor13[caller] = 1\n                              stor14[caller] = 20\n                              log UserDividendRate(\n                                    address user=caller,\n                                    uint256 divRate=20)\n                              if call.value >= 10^14:\n                                  if not uint8(stor27.field_168):\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require stor14[caller] * call.value / call.value == stor14[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if call.value / 100:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor7 != caller:\n                                  revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                              if uint8(stor27.field_168):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require stor14[caller] * call.value / call.value == stor14[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if startRegularPhase() == uint32(call.func_hash):\n                              require not call.value\n                              require stor25[caller]\n                              uint8(stor27.field_160) = 0\n                              uint8(stor27.field_168) = 1\n                              stop\n                          if ethereumToTokens_(uint256 _ethereum) == uint32(call.func_hash):\n                              require not call.value\n                              if _param1 <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if uint8(stor27.field_160):\n                                  return (10^18 * _param1 / 653 * 10^12)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require _param1 == _param1\n                                  require _param1\n                              else:\n                                  if currentEthInvested + _param1 <= ethInvestedDuringICO:\n                                      require _param1 == _param1\n                                      require _param1\n                                      if not _param1:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * _param1 / _param1 == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + _param1 > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= _param1\n                                  require _param1 == _param1\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                          else:\n                              if decimals() == uint32(call.func_hash):\n                                  require not call.value\n                                  return 18\n                              if publicStartRegularPhase() == uint32(call.func_hash):\n                                  require not call.value\n                                  require block.timestamp > stor28 + (336 * 24 * 3600)\n                                  require stor28\n                                  uint8(stor27.field_160) = 0\n                                  uint8(stor27.field_168) = 1\n                                  stop\n                              if sellPrice() == uint32(call.func_hash):\n                                  require not call.value\n                                  if uint8(stor27.field_160):\n                                      if balanceOf[caller]:\n                                          if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if balanceOf[caller]:\n                                              if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if uint8(stor27.field_160):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if currentEthInvested + 10^15 <= ethInvestedDuringICO:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + 10^15 > ethInvestedDuringICO\n                                          if currentEthInvested <= ethInvestedDuringICO:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                              if getFrontEndTokenBalanceOf(address _customerAddress) == uint32(call.func_hash):\n                                  require not call.value\n                                  return balanceOf[address(_param1)]\n                              if getDividendTokenBalanceOf(address _customerAddress) == uint32(call.func_hash):\n                                  require not call.value\n                                  return uint256(dividendTokenBalanceOf[address(_param1)])\n                              if withdraw(address _asset) == uint32(call.func_hash):\n                                  require not call.value\n                                  require (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller] > 0\n                                  require uint8(stor27.field_168)\n                              else:\n                                  if stakingRequirement() == uint32(call.func_hash):\n                                      require not call.value\n                                      return stakingRequirement\n                                  if allowed(address _param1, address _param2) == uint32(call.func_hash):\n                                      require not call.value\n                                      return allowed[_param1][address(_param2)]\n                                  if ethInvestedDuringICO() == uint32(call.func_hash):\n                                      require not call.value\n                                      return ethInvestedDuringICO\n                                  if myDividendTokens() == uint32(call.func_hash):\n                                      require not call.value\n                                      return uint256(dividendTokenBalanceOf[caller])\n                                  if buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice) == uint32(call.func_hash):\n                                      require uint8(stor27.field_168)\n                                      if not stor13[caller]:\n                                          if not uint8(stor27.field_160):\n                                              require uint8(stor27.field_168)\n                                              if not uint8(stor27.field_160):\n                                      else:\n                                          if uint8(_param4):\n                                              if not uint8(stor27.field_160):\n                                                  require uint8(stor27.field_168)\n                                          else:\n                                              if call.value < 10^14:\n                                                  if stor7 != caller:\n                                                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                                  else:\n                                      if sqrt(uint256 y) == uint32(call.func_hash):\n                                          require not call.value\n                                      else:\n                                          if myDividends(bool _includeReferralBonus) == uint32(call.func_hash):\n                                              require not call.value\n                                              if _param1:\n                                                  return ((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64) + stor15[caller])\n                                              return (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor24) - stor17[caller]) >> 64)\n                                          if icoPhase() == uint32(call.func_hash):\n                                              require not call.value\n                                              return bool(uint8(stor27.field_160))\n                                          if injectEther() == uint32(call.func_hash):\n                                              require stor25[caller]\n                                              stop\n                                          if totalEthereumBalance() == uint32(call.func_hash):\n                                              require not call.value\n                                              return eth.balance(this.address)\n                                          if balanceOf(address account) == uint32(call.func_hash):\n                                              require not call.value\n                                          else:\n                                              if uint32(call.func_hash) != buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass):\n                                                  if changeCreator(address _creator) == uint32(call.func_hash):\n                                                      require not call.value\n                                                  else:\n                                                      if uint32(call.func_hash) != administrators(address _param1):\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 68368 tokens. Please reduce the length of the messages."
}