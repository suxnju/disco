{
	"address": "0xe5a04d98538231b0fab9aba60cd73ce4ff3039df",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code that might fit your decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract BettingContract {\n    address private owner;\n    uint256 public maxBet;\n    uint256 public minBet;\n    address public jackpotTokenAddress;\n    address public bonusTokenAddress;\n    uint256 public bonusAmount;\n    uint256 public bonusMin;\n    uint256 public bonusMax;\n    address public flipTokenRewardAddress;\n    uint256 public flipRewardAmount;\n    address public millionDollarTokenRewardAddress;\n    uint256 public mdtRewardAmount;\n    mapping(bytes32 => address) private userAddress;\n    mapping(bytes32 => uint256) private userBetValue;\n\n    constructor() {\n        owner = msg.sender;\n        // set default values for public variables\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function setMaxBet(uint256 _maxBet) public onlyOwner {\n        maxBet = _maxBet;\n    }\n\n    function setMinBet(uint256 _minBet) public onlyOwner {\n        minBet = _minBet;\n    }\n\n    function setJackpotToken(address _jackpotTokenAddress) public onlyOwner {\n        jackpotTokenAddress = _jackpotTokenAddress;\n    }\n\n    function setBonusToken(address _bonusTokenAddress) public onlyOwner {\n        bonusTokenAddress = _bonusTokenAddress;\n    }\n\n    function setBonusAmount(uint256 _bonusAmount) public onlyOwner {\n        bonusAmount = _bonusAmount;\n    }\n\n    function setBonusMin(uint256 _bonusMin) public onlyOwner {\n        bonusMin = _bonusMin;\n    }\n\n    function setBonusMax(uint256 _bonusMax) public onlyOwner {\n        bonusMax = _bonusMax;\n    }\n\n    function setFlipTokenReward(address _flipTokenRewardAddress) public onlyOwner {\n        flipTokenRewardAddress = _flipTokenRewardAddress;\n    }\n\n    function setFlipRewardAmount(uint256 _flipRewardAmount) public onlyOwner {\n        flipRewardAmount = _flipRewardAmount;\n    }\n\n    function setMDTReward(address _mdtRewardAddress) public onlyOwner {\n        millionDollarTokenRewardAddress = _mdtRewardAddress;\n    }\n\n    function setMDTRewardAmount(uint256 _mdtRewardAmount) public onlyOwner {\n        mdtRewardAmount = _mdtRewardAmount;\n    }\n\n    function placeBet(bytes32 _betId) public payable {\n        require(msg.value >= minBet && msg.value <= maxBet, \"Bet amount is out of range.\");\n        userAddress[_betId] = msg.sender;\n        userBetValue[_betId] = msg.value;\n        // Add additional logic for the bet\n    }\n\n    function payout(bytes32 _betId) public onlyOwner {\n        // Add logic for payout\n        delete userAddress[_betId];\n        delete userBetValue[_betId];\n    }\n}\n```\n\nPlease note that this is a simplified representation and the actual contract might include more complex logic. Please adjust the code according to your requirements. The main point is to illustrate how the mappings, public variables, and functions might be represented in Solidity based on the decompiled EVM Bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471173,
	"id": "chatcmpl-8MuWLsltJJkoLqbaKZxRY1HIGktKL",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is address at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is array of uint256 at storage 2\n  flipTokenRewardAddress is address at storage 5\n  millionDollarTokenRewardAddress is address at storage 6\n  jackpotTokenAddress is address at storage 7\n  sponsoredJackpotTokenAddress is address at storage 8\n  bonusTokenAddress is address at storage 9\n  sponsoredBonusTokenAddress is address at storage 10\n  owner is address at storage 11\n  generatedBytes is uint256 at storage 12\n  maxBet is uint256 at storage 13\n  minBet is uint256 at storage 14\n  oraclizeFee is uint256 at storage 15\n  flipRewardAmount is uint256 at storage 16\n  mdtRewardAmount is uint256 at storage 17\n  jackpotAmount is uint256 at storage 18\n  sponsoredJackpotAmount is uint256 at storage 19\n  bonusAmount is uint256 at storage 20\n  sponsoredBonusAmount is uint256 at storage 21\n  callbackGas is uint256 at storage 22\n  incrementFee is uint256 at storage 23\n  incrementDivisor is uint256 at storage 24\n  baseComparable is uint256 at storage 25\n  jackpotHit is uint256 at storage 26\n  sponsoredJackpotMin is uint256 at storage 27\n  sponsoredJackpotMax is uint256 at storage 28\n  bonusMin is uint256 at storage 29\n  bonusMax is uint256 at storage 30\n  sponsoredBonusMin is uint256 at storage 31\n  sponsoredBonusMax is uint256 at storage 32\n  mdtComparable is uint256 at storage 33\n  stor34 is mapping of address at storage 34\n  stor35 is mapping of uint256 at storage 35\n\ndef bonusMin(): # not payable\n  return bonusMin\n\ndef generatedBytes(): # not payable\n  return generatedBytes\n\ndef maxBet(): # not payable\n  return maxBet\n\ndef sponsoredBonusMin(): # not payable\n  return sponsoredBonusMin\n\ndef baseComparable(): # not payable\n  return baseComparable\n\ndef bonusToken(): # not payable\n  return bonusTokenAddress\n\ndef sponsoredJackpotToken(): # not payable\n  return sponsoredJackpotTokenAddress\n\ndef oraclizeFee(): # not payable\n  return oraclizeFee\n\ndef sponsoredJackpotMin(): # not payable\n  return sponsoredJackpotMin\n\ndef sponsoredJackpotAmount(): # not payable\n  return sponsoredJackpotAmount\n\ndef flipTokenReward(): # not payable\n  return flipTokenRewardAddress\n\ndef flipRewardAmount(): # not payable\n  return flipRewardAmount\n\ndef bonusMax(): # not payable\n  return bonusMax\n\ndef jackpotHit(): # not payable\n  return jackpotHit\n\ndef owner(): # not payable\n  return owner\n\ndef jackpotToken(): # not payable\n  return jackpotTokenAddress\n\ndef minBet(): # not payable\n  return minBet\n\ndef incrementFee(): # not payable\n  return incrementFee\n\ndef callbackGas(): # not payable\n  return callbackGas\n\ndef incrementDivisor(): # not payable\n  return incrementDivisor\n\ndef bonusAmount(): # not payable\n  return bonusAmount\n\ndef sponsoredJackpotMax(): # not payable\n  return sponsoredJackpotMax\n\ndef jackpotAmount(): # not payable\n  return jackpotAmount\n\ndef sponsoredBonusMax(): # not payable\n  return sponsoredBonusMax\n\ndef millionDollarTokenReward(): # not payable\n  return millionDollarTokenRewardAddress\n\ndef sponsoredBonusAmount(): # not payable\n  return sponsoredBonusAmount\n\ndef mdtRewardAmount(): # not payable\n  return mdtRewardAmount\n\ndef sponsoredBonusToken(): # not payable\n  return sponsoredBonusTokenAddress\n\ndef mdtComparable(): # not payable\n  return mdtComparable\n\n#\n#  Regular functions\n#\n\ndef updateOwner(address newOwner): # not payable\n  require owner == caller\n  owner = newOwner\n\ndef refundTransfer(address outboundAddress, uint256 amount): # not payable\n  require owner == caller\n  call outboundAddress with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef updateGameSpecifics(uint256 newGas, uint256 newOraclizeFee, uint256 newFee, uint256 newDivisor): # not payable\n  require owner == caller\n  callbackGas = newGas\n  oraclizeFee = newOraclizeFee\n  incrementFee = newFee\n  incrementDivisor = newDivisor\n\ndef updateMaxMinComparables(uint256 updatedMaxBet, uint256 updatedMinBet, uint256 updatedBaseComparable, uint256 updatedMDTComparable): # not payable\n  require owner == caller\n  maxBet = updatedMaxBet\n  minBet = updatedMinBet\n  baseComparable = updatedBaseComparable\n  mdtComparable = updatedMDTComparable\n\ndef walletSend(address tokenAddress, uint256 amount, address outboundAddress): # not payable\n  require owner == caller\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args address(outboundAddress), amount\n  require ext_call.success\n\ndef updateFlipAndMDT(address updatedFlipToken, uint256 updatedFlipRewardAmount, address updatedMDTToken, uint256 updatedMDTRewardAmount): # not payable\n  require owner == caller\n  millionDollarTokenRewardAddress = updatedMDTToken\n  mdtRewardAmount = updatedMDTRewardAmount\n  flipTokenRewardAddress = updatedFlipToken\n  flipRewardAmount = updatedFlipRewardAmount\n\ndef setJackpotToken(address newJackpotToken, uint256 newJackpotAmount, uint256 newJackpotHit, address newSponsoredJackpotToken, uint256 newSponsoredJackpotAmount, uint256 newSJackpotMin, uint256 newSJackpotMax): # not payable\n  require owner == caller\n  jackpotTokenAddress = newJackpotToken\n  jackpotAmount = newJackpotAmount\n  jackpotHit = newJackpotHit\n  sponsoredJackpotTokenAddress = newSponsoredJackpotToken\n  sponsoredJackpotAmount = newSponsoredJackpotAmount\n  sponsoredJackpotMin = newSJackpotMin\n  sponsoredJackpotMax = newSJackpotMax\n\ndef setBonusToken(address newBonusToken, uint256 newBonusAmount, uint256 newBonusMin, uint256 newBonusMax, address newSponsoredBonusToken, uint256 newSponsoredBonusAmount, uint256 newSBonusMin, uint256 newSBonusMax): # not payable\n  require owner == caller\n  bonusTokenAddress = newBonusToken\n  bonusAmount = newBonusAmount\n  bonusMin = newBonusMin\n  bonusMax = newBonusMax\n  sponsoredBonusTokenAddress = newSponsoredBonusToken\n  sponsoredBonusAmount = newSponsoredBonusAmount\n  sponsoredBonusMin = newSBonusMin\n  sponsoredBonusMax = newSBonusMax\n\ndef __callback(bytes32 myid, string result): # not payable\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 12\n          stor2.length.field_8 = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 9\n          stor2.length.field_8 = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).cbAddress() with:\n                       gas gas_remaining - 710 wei\n                  if ext_call.success:\n                      require caller == ext_call.return_data[12 len 20]\n  else:\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).cbAddress() with:\n                       gas gas_remaining - 710 wei\n                  if ext_call.success:\n                      require caller == ext_call.return_data[12 len 20]\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n              stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 9\n              stor2.length.field_8 = 'eth_kovan' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n              stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_rinkeby' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n          else:\n              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n              else:\n                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n          if ext_code.size(stor0):\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              if ext_call.success:\n                  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n                  if ext_code.size(address(ext_call.return_data[0])):\n                      call address(ext_call.return_data[0]).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      if ext_call.success:\n                          require caller == ext_call.return_data[12 len 20]\n  revert\n\ndef __callback(bytes32 myid, string result, bytes proof): # not payable\n  mem[ceil32(result.length) + 160 len proof.length] = proof[all]\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 12\n          stor2.length.field_8 = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 9\n          stor2.length.field_8 = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      require ext_code.size(stor0)\n  else:\n      if not ext_code.size(stor0):\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n              stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 9\n              stor2.length.field_8 = 'eth_kovan' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n              stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_rinkeby' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n          else:\n              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n              else:\n                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n          require ext_code.size(stor0)\n  call stor0.getAddress() with:\n       gas gas_remaining - 710 wei\n  require ext_call.success\n  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n  require ext_code.size(address(ext_call.return_data[0]))\n  call address(ext_call.return_data[0]).cbAddress() with:\n       gas gas_remaining - 710 wei\n  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n  require ext_call.success\n  require caller == ext_call.return_data[12 len 20]\n  require 0 < proof.length\n  if 'L' == Mask(8, 248, mem[ceil32(result.length) + 160]):\n      require 1 < proof.length\n      if 'P' == Mask(8, 248, mem[ceil32(result.length) + 161]):\n          require 2 < proof.length\n          if Mask(8, 248, mem[ceil32(result.length) + 162]) == 0x100000000000000000000000000000000000000000000000000000000000000:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  log proofFailed(\n        address =stor34[myid],\n        uint256 =stor35[myid])\n  call stor34[myid] with:\n     value stor35[myid] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  stor34[myid] = 0\n  stor35[myid] = 0\n\ndef _fallback(?) payable: # default function\n  if owner == caller:\n      stop\n  require call.value <= maxBet\n  require call.value >= minBet\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          idx = 0\n          while stor2.length + 31 / 32 > idx:\n              stor2[idx].field_0 = 0\n              idx = idx + 1\n              continue \n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              idx = 0\n              while stor2.length + 31 / 32 > idx:\n                  stor2[idx].field_0 = 0\n                  idx = idx + 1\n                  continue \n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.length) = 0\n                  stor2.length.field_1 = 9\n                  stor2.length.field_8 = 'eth_kovan' / 256\n                  idx = 0\n                  while stor2.length + 31 / 32 > idx:\n                      stor2[idx].field_0 = 0\n                      idx = idx + 1\n                      continue \n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) <= 0:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                      else:\n                          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          else:\n                              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                  else:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.length) = 0\n                      stor2.length.field_1 = 11\n                      stor2.length.field_8 = 'eth_rinkeby' / 256\n                      idx = 0\n                      while stor2.length + 31 / 32 > idx:\n                          stor2[idx].field_0 = 0\n                          idx = idx + 1\n                          continue \n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                       gas gas_remaining - 710 wei\n                      args 0\n                  if ext_call.success:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                       gas gas_remaining - 710 wei\n                      args 0\n                  if ext_call.success:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              idx = 0\n              while stor2.length + 31 / 32 > idx:\n                  stor2[idx].field_0 = 0\n                  idx = idx + 1\n                  continue \n          else:\n              if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n                  stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n                  bool(stor2.length) = 0\n                  stor2.length.field_1 = 12\n                  stor2.length.field_8 = 'eth_ropsten3' / 256\n                  idx = 0\n                  while stor2.length + 31 / 32 > idx:\n                      stor2[idx].field_0 = 0\n                      idx = idx + 1\n                      continue \n              else:\n                  if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                      stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                      bool(stor2.length) = 0\n                      stor2.length.field_1 = 9\n                      stor2.length.field_8 = 'eth_kovan' / 256\n                      idx = 0\n                      while stor2.length + 31 / 32 > idx:\n                          stor2[idx].field_0 = 0\n                          idx = idx + 1\n                          continue \n                  else:\n                      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) <= 0:\n                          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          else:\n                              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              else:\n                                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      else:\n                          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                          bool(stor2.length) = 0\n                          stor2.length.field_1 = 11\n                          stor2.length.field_8 = 'eth_rinkeby' / 256\n                          idx = 0\n                          while stor2.length + 31 / 32 > idx:\n                              stor2[idx].field_0 = 0\n                              idx = idx + 1\n                              continue \n          if ext_code.size(stor0):\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              if ext_call.success:\n                  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n                  if ext_code.size(address(ext_call.return_data[0])):\n                      call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                           gas gas_remaining - 710 wei\n                          args 0\n                      if ext_call.success:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is address at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is array of uint256 at storage 2\n  flipTokenRewardAddress is address at storage 5\n  millionDollarTokenRewardAddress is address at storage 6\n  jackpotTokenAddress is address at storage 7\n  sponsoredJackpotTokenAddress is address at storage 8\n  bonusTokenAddress is address at storage 9\n  sponsoredBonusTokenAddress is address at storage 10\n  owner is address at storage 11\n  generatedBytes is uint256 at storage 12\n  maxBet is uint256 at storage 13\n  minBet is uint256 at storage 14\n  oraclizeFee is uint256 at storage 15\n  flipRewardAmount is uint256 at storage 16\n  mdtRewardAmount is uint256 at storage 17\n  jackpotAmount is uint256 at storage 18\n  sponsoredJackpotAmount is uint256 at storage 19\n  bonusAmount is uint256 at storage 20\n  sponsoredBonusAmount is uint256 at storage 21\n  callbackGas is uint256 at storage 22\n  incrementFee is uint256 at storage 23\n  incrementDivisor is uint256 at storage 24\n  baseComparable is uint256 at storage 25\n  jackpotHit is uint256 at storage 26\n  sponsoredJackpotMin is uint256 at storage 27\n  sponsoredJackpotMax is uint256 at storage 28\n  bonusMin is uint256 at storage 29\n  bonusMax is uint256 at storage 30\n  sponsoredBonusMin is uint256 at storage 31\n  sponsoredBonusMax is uint256 at storage 32\n  mdtComparable is uint256 at storage 33\n  stor34 is mapping of address at storage 34\n  stor35 is mapping of uint256 at storage 35\n\ndef bonusMin(): # not payable\n  return bonusMin\n\ndef generatedBytes(): # not payable\n  return generatedBytes\n\ndef maxBet(): # not payable\n  return maxBet\n\ndef sponsoredBonusMin(): # not payable\n  return sponsoredBonusMin\n\ndef baseComparable(): # not payable\n  return baseComparable\n\ndef bonusToken(): # not payable\n  return bonusTokenAddress\n\ndef sponsoredJackpotToken(): # not payable\n  return sponsoredJackpotTokenAddress\n\ndef oraclizeFee(): # not payable\n  return oraclizeFee\n\ndef sponsoredJackpotMin(): # not payable\n  return sponsoredJackpotMin\n\ndef sponsoredJackpotAmount(): # not payable\n  return sponsoredJackpotAmount\n\ndef flipTokenReward(): # not payable\n  return flipTokenRewardAddress\n\ndef flipRewardAmount(): # not payable\n  return flipRewardAmount\n\ndef bonusMax(): # not payable\n  return bonusMax\n\ndef jackpotHit(): # not payable\n  return jackpotHit\n\ndef owner(): # not payable\n  return owner\n\ndef jackpotToken(): # not payable\n  return jackpotTokenAddress\n\ndef minBet(): # not payable\n  return minBet\n\ndef incrementFee(): # not payable\n  return incrementFee\n\ndef callbackGas(): # not payable\n  return callbackGas\n\ndef incrementDivisor(): # not payable\n  return incrementDivisor\n\ndef bonusAmount(): # not payable\n  return bonusAmount\n\ndef sponsoredJackpotMax(): # not payable\n  return sponsoredJackpotMax\n\ndef jackpotAmount(): # not payable\n  return jackpotAmount\n\ndef sponsoredBonusMax(): # not payable\n  return sponsoredBonusMax\n\ndef millionDollarTokenReward(): # not payable\n  return millionDollarTokenRewardAddress\n\ndef sponsoredBonusAmount(): # not payable\n  return sponsoredBonusAmount\n\ndef mdtRewardAmount(): # not payable\n  return mdtRewardAmount\n\ndef sponsoredBonusToken(): # not payable\n  return sponsoredBonusTokenAddress\n\ndef mdtComparable(): # not payable\n  return mdtComparable\n\n#\n#  Regular functions\n#\n\ndef updateOwner(address newOwner): # not payable\n  require owner == caller\n  owner = newOwner\n\ndef refundTransfer(address outboundAddress, uint256 amount): # not payable\n  require owner == caller\n  call outboundAddress with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef updateGameSpecifics(uint256 newGas, uint256 newOraclizeFee, uint256 newFee, uint256 newDivisor): # not payable\n  require owner == caller\n  callbackGas = newGas\n  oraclizeFee = newOraclizeFee\n  incrementFee = newFee\n  incrementDivisor = newDivisor\n\ndef updateMaxMinComparables(uint256 updatedMaxBet, uint256 updatedMinBet, uint256 updatedBaseComparable, uint256 updatedMDTComparable): # not payable\n  require owner == caller\n  maxBet = updatedMaxBet\n  minBet = updatedMinBet\n  baseComparable = updatedBaseComparable\n  mdtComparable = updatedMDTComparable\n\ndef walletSend(address tokenAddress, uint256 amount, address outboundAddress): # not payable\n  require owner == caller\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args address(outboundAddress), amount\n  require ext_call.success\n\ndef updateFlipAndMDT(address updatedFlipToken, uint256 updatedFlipRewardAmount, address updatedMDTToken, uint256 updatedMDTRewardAmount): # not payable\n  require owner == caller\n  millionDollarTokenRewardAddress = updatedMDTToken\n  mdtRewardAmount = updatedMDTRewardAmount\n  flipTokenRewardAddress = updatedFlipToken\n  flipRewardAmount = updatedFlipRewardAmount\n\ndef setJackpotToken(address newJackpotToken, uint256 newJackpotAmount, uint256 newJackpotHit, address newSponsoredJackpotToken, uint256 newSponsoredJackpotAmount, uint256 newSJackpotMin, uint256 newSJackpotMax): # not payable\n  require owner == caller\n  jackpotTokenAddress = newJackpotToken\n  jackpotAmount = newJackpotAmount\n  jackpotHit = newJackpotHit\n  sponsoredJackpotTokenAddress = newSponsoredJackpotToken\n  sponsoredJackpotAmount = newSponsoredJackpotAmount\n  sponsoredJackpotMin = newSJackpotMin\n  sponsoredJackpotMax = newSJackpotMax\n\ndef setBonusToken(address newBonusToken, uint256 newBonusAmount, uint256 newBonusMin, uint256 newBonusMax, address newSponsoredBonusToken, uint256 newSponsoredBonusAmount, uint256 newSBonusMin, uint256 newSBonusMax): # not payable\n  require owner == caller\n  bonusTokenAddress = newBonusToken\n  bonusAmount = newBonusAmount\n  bonusMin = newBonusMin\n  bonusMax = newBonusMax\n  sponsoredBonusTokenAddress = newSponsoredBonusToken\n  sponsoredBonusAmount = newSponsoredBonusAmount\n  sponsoredBonusMin = newSBonusMin\n  sponsoredBonusMax = newSBonusMax\n\ndef __callback(bytes32 myid, string result): # not payable\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 12\n          stor2.length.field_8 = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 9\n          stor2.length.field_8 = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).cbAddress() with:\n                       gas gas_remaining - 710 wei\n                  if ext_call.success:\n                      require caller == ext_call.return_data[12 len 20]\n  else:\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).cbAddress() with:\n                       gas gas_remaining - 710 wei\n                  if ext_call.success:\n                      require caller == ext_call.return_data[12 len 20]\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n              stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 9\n              stor2.length.field_8 = 'eth_kovan' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n              stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_rinkeby' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n          else:\n              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n              else:\n                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n          if ext_code.size(stor0):\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              if ext_call.success:\n                  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n                  if ext_code.size(address(ext_call.return_data[0])):\n                      call address(ext_call.return_data[0]).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      if ext_call.success:\n                          require caller == ext_call.return_data[12 len 20]\n  revert\n\ndef __callback(bytes32 myid, string result, bytes proof): # not payable\n  mem[ceil32(result.length) + 160 len proof.length] = proof[all]\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 12\n          stor2.length.field_8 = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 9\n          stor2.length.field_8 = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      require ext_code.size(stor0)\n  else:\n      if not ext_code.size(stor0):\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n              stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 9\n              stor2.length.field_8 = 'eth_kovan' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n              stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_rinkeby' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n          else:\n              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n              else:\n                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n          require ext_code.size(stor0)\n  call stor0.getAddress() with:\n       gas gas_remaining - 710 wei\n  require ext_call.success\n  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n  require ext_code.size(address(ext_call.return_data[0]))\n  call address(ext_call.return_data[0]).cbAddress() with:\n       gas gas_remaining - 710 wei\n  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n  require ext_call.success\n  require caller == ext_call.return_data[12 len 20]\n  require 0 < proof.length\n  if 'L' == Mask(8, 248, mem[ceil32(result.length) + 160]):\n      require 1 < proof.length\n      if 'P' == Mask(8, 248, mem[ceil32(result.length) + 161]):\n          require 2 < proof.length\n          if Mask(8, 248, mem[ceil32(result.length) + 162]) == 0x100000000000000000000000000000000000000000000000000000000000000:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  log proofFailed(\n        address =stor34[myid],\n        uint256 =stor35[myid])\n  call stor34[myid] with:\n     value stor35[myid] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  stor34[myid] = 0\n  stor35[myid] = 0\n\ndef _fallback(?) payable: # default function\n  if owner == caller:\n      stop\n  require call.value <= maxBet\n  require call.value >= minBet\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          idx = 0\n          while stor2.length + 31 / 32 > idx:\n              stor2[idx].field_0 = 0\n              idx = idx + 1\n              continue \n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              idx = 0\n              while stor2.length + 31 / 32 > idx:\n                  stor2[idx].field_0 = 0\n                  idx = idx + 1\n                  continue \n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.length) = 0\n                  stor2.length.field_1 = 9\n                  stor2.length.field_8 = 'eth_kovan' / 256\n                  idx = 0\n                  while stor2.length + 31 / 32 > idx:\n                      stor2[idx].field_0 = 0\n                      idx = idx + 1\n                      continue \n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) <= 0:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                      else:\n                          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          else:\n                              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                  else:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.length) = 0\n                      stor2.length.field_1 = 11\n                      stor2.length.field_8 = 'eth_rinkeby' / 256\n                      idx = 0\n                      while stor2.length + 31 / 32 > idx:\n                          stor2[idx].field_0 = 0\n                          idx = idx + 1\n                          continue \n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                       gas gas_remaining - 710 wei\n                      args 0\n                  if ext_call.success:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                       gas gas_remaining - 710 wei\n                      args 0\n                  if ext_call.success:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              idx = 0\n              while stor2.length + 31 / 32 > idx:\n                  stor2[idx].field_0 = 0\n                  idx = idx + 1\n                  continue \n          else:\n              if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n                  stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n                  bool(stor2.length) = 0\n                  stor2.length.field_1 = 12\n                  stor2.length.field_8 = 'eth_ropsten3' / 256\n                  idx = 0\n                  while stor2.length + 31 / 32 > idx:\n                      stor2[idx].field_0 = 0\n                      idx = idx + 1\n                      continue \n              else:\n                  if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                      stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                      bool(stor2.length) = 0\n                      stor2.length.field_1 = 9\n                      stor2.length.field_8 = 'eth_kovan' / 256\n                      idx = 0\n                      while stor2.length + 31 / 32 > idx:\n                          stor2[idx].field_0 = 0\n                          idx = idx + 1\n                          continue \n                  else:\n                      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) <= 0:\n                          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          else:\n                              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              else:\n                                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      else:\n                          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                          bool(stor2.length) = 0\n                          stor2.length.field_1 = 11\n                          stor2.length.field_8 = 'eth_rinkeby' / 256\n                          idx = 0\n                          while stor2.length + 31 / 32 > idx:\n                              stor2[idx].field_0 = 0\n                              idx = idx + 1\n                              continue \n          if ext_code.size(stor0):\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              if ext_call.success:\n                  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n                  if ext_code.size(address(ext_call.return_data[0])):\n                      call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                           gas gas_remaining - 710 wei\n                          args 0\n                      if ext_call.success:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is address at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is array of uint256 at storage 2\n  flipTokenRewardAddress is address at storage 5\n  millionDollarTokenRewardAddress is address at storage 6\n  jackpotTokenAddress is address at storage 7\n  sponsoredJackpotTokenAddress is address at storage 8\n  bonusTokenAddress is address at storage 9\n  sponsoredBonusTokenAddress is address at storage 10\n  owner is address at storage 11\n  generatedBytes is uint256 at storage 12\n  maxBet is uint256 at storage 13\n  minBet is uint256 at storage 14\n  oraclizeFee is uint256 at storage 15\n  flipRewardAmount is uint256 at storage 16\n  mdtRewardAmount is uint256 at storage 17\n  jackpotAmount is uint256 at storage 18\n  sponsoredJackpotAmount is uint256 at storage 19\n  bonusAmount is uint256 at storage 20\n  sponsoredBonusAmount is uint256 at storage 21\n  callbackGas is uint256 at storage 22\n  incrementFee is uint256 at storage 23\n  incrementDivisor is uint256 at storage 24\n  baseComparable is uint256 at storage 25\n  jackpotHit is uint256 at storage 26\n  sponsoredJackpotMin is uint256 at storage 27\n  sponsoredJackpotMax is uint256 at storage 28\n  bonusMin is uint256 at storage 29\n  bonusMax is uint256 at storage 30\n  sponsoredBonusMin is uint256 at storage 31\n  sponsoredBonusMax is uint256 at storage 32\n  mdtComparable is uint256 at storage 33\n  stor34 is mapping of address at storage 34\n  stor35 is mapping of uint256 at storage 35\n\ndef bonusMin(): # not payable\n  return bonusMin\n\ndef generatedBytes(): # not payable\n  return generatedBytes\n\ndef maxBet(): # not payable\n  return maxBet\n\ndef sponsoredBonusMin(): # not payable\n  return sponsoredBonusMin\n\ndef baseComparable(): # not payable\n  return baseComparable\n\ndef bonusToken(): # not payable\n  return bonusTokenAddress\n\ndef sponsoredJackpotToken(): # not payable\n  return sponsoredJackpotTokenAddress\n\ndef oraclizeFee(): # not payable\n  return oraclizeFee\n\ndef sponsoredJackpotMin(): # not payable\n  return sponsoredJackpotMin\n\ndef sponsoredJackpotAmount(): # not payable\n  return sponsoredJackpotAmount\n\ndef flipTokenReward(): # not payable\n  return flipTokenRewardAddress\n\ndef flipRewardAmount(): # not payable\n  return flipRewardAmount\n\ndef bonusMax(): # not payable\n  return bonusMax\n\ndef jackpotHit(): # not payable\n  return jackpotHit\n\ndef owner(): # not payable\n  return owner\n\ndef jackpotToken(): # not payable\n  return jackpotTokenAddress\n\ndef minBet(): # not payable\n  return minBet\n\ndef incrementFee(): # not payable\n  return incrementFee\n\ndef callbackGas(): # not payable\n  return callbackGas\n\ndef incrementDivisor(): # not payable\n  return incrementDivisor\n\ndef bonusAmount(): # not payable\n  return bonusAmount\n\ndef sponsoredJackpotMax(): # not payable\n  return sponsoredJackpotMax\n\ndef jackpotAmount(): # not payable\n  return jackpotAmount\n\ndef sponsoredBonusMax(): # not payable\n  return sponsoredBonusMax\n\ndef millionDollarTokenReward(): # not payable\n  return millionDollarTokenRewardAddress\n\ndef sponsoredBonusAmount(): # not payable\n  return sponsoredBonusAmount\n\ndef mdtRewardAmount(): # not payable\n  return mdtRewardAmount\n\ndef sponsoredBonusToken(): # not payable\n  return sponsoredBonusTokenAddress\n\ndef mdtComparable(): # not payable\n  return mdtComparable\n\n#\n#  Regular functions\n#\n\ndef updateOwner(address newOwner): # not payable\n  require owner == caller\n  owner = newOwner\n\ndef refundTransfer(address outboundAddress, uint256 amount): # not payable\n  require owner == caller\n  call outboundAddress with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef updateGameSpecifics(uint256 newGas, uint256 newOraclizeFee, uint256 newFee, uint256 newDivisor): # not payable\n  require owner == caller\n  callbackGas = newGas\n  oraclizeFee = newOraclizeFee\n  incrementFee = newFee\n  incrementDivisor = newDivisor\n\ndef updateMaxMinComparables(uint256 updatedMaxBet, uint256 updatedMinBet, uint256 updatedBaseComparable, uint256 updatedMDTComparable): # not payable\n  require owner == caller\n  maxBet = updatedMaxBet\n  minBet = updatedMinBet\n  baseComparable = updatedBaseComparable\n  mdtComparable = updatedMDTComparable\n\ndef walletSend(address tokenAddress, uint256 amount, address outboundAddress): # not payable\n  require owner == caller\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args address(outboundAddress), amount\n  require ext_call.success\n\ndef updateFlipAndMDT(address updatedFlipToken, uint256 updatedFlipRewardAmount, address updatedMDTToken, uint256 updatedMDTRewardAmount): # not payable\n  require owner == caller\n  millionDollarTokenRewardAddress = updatedMDTToken\n  mdtRewardAmount = updatedMDTRewardAmount\n  flipTokenRewardAddress = updatedFlipToken\n  flipRewardAmount = updatedFlipRewardAmount\n\ndef setJackpotToken(address newJackpotToken, uint256 newJackpotAmount, uint256 newJackpotHit, address newSponsoredJackpotToken, uint256 newSponsoredJackpotAmount, uint256 newSJackpotMin, uint256 newSJackpotMax): # not payable\n  require owner == caller\n  jackpotTokenAddress = newJackpotToken\n  jackpotAmount = newJackpotAmount\n  jackpotHit = newJackpotHit\n  sponsoredJackpotTokenAddress = newSponsoredJackpotToken\n  sponsoredJackpotAmount = newSponsoredJackpotAmount\n  sponsoredJackpotMin = newSJackpotMin\n  sponsoredJackpotMax = newSJackpotMax\n\ndef setBonusToken(address newBonusToken, uint256 newBonusAmount, uint256 newBonusMin, uint256 newBonusMax, address newSponsoredBonusToken, uint256 newSponsoredBonusAmount, uint256 newSBonusMin, uint256 newSBonusMax): # not payable\n  require owner == caller\n  bonusTokenAddress = newBonusToken\n  bonusAmount = newBonusAmount\n  bonusMin = newBonusMin\n  bonusMax = newBonusMax\n  sponsoredBonusTokenAddress = newSponsoredBonusToken\n  sponsoredBonusAmount = newSponsoredBonusAmount\n  sponsoredBonusMin = newSBonusMin\n  sponsoredBonusMax = newSBonusMax\n\ndef __callback(bytes32 myid, string result): # not payable\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 12\n          stor2.length.field_8 = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 9\n          stor2.length.field_8 = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).cbAddress() with:\n                       gas gas_remaining - 710 wei\n                  if ext_call.success:\n                      require caller == ext_call.return_data[12 len 20]\n  else:\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).cbAddress() with:\n                       gas gas_remaining - 710 wei\n                  if ext_call.success:\n                      require caller == ext_call.return_data[12 len 20]\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n              stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 9\n              stor2.length.field_8 = 'eth_kovan' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n              stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_rinkeby' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n          else:\n              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n              else:\n                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n          if ext_code.size(stor0):\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              if ext_call.success:\n                  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n                  if ext_code.size(address(ext_call.return_data[0])):\n                      call address(ext_call.return_data[0]).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      if ext_call.success:\n                          require caller == ext_call.return_data[12 len 20]\n  revert\n\ndef __callback(bytes32 myid, string result, bytes proof): # not payable\n  mem[ceil32(result.length) + 160 len proof.length] = proof[all]\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 12\n          stor2.length.field_8 = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 9\n          stor2.length.field_8 = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      require ext_code.size(stor0)\n  else:\n      if not ext_code.size(stor0):\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n              stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 9\n              stor2.length.field_8 = 'eth_kovan' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n              stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_rinkeby' / 256\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n          else:\n              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n              else:\n                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n          require ext_code.size(stor0)\n  call stor0.getAddress() with:\n       gas gas_remaining - 710 wei\n  require ext_call.success\n  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n  require ext_code.size(address(ext_call.return_data[0]))\n  call address(ext_call.return_data[0]).cbAddress() with:\n       gas gas_remaining - 710 wei\n  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n  require ext_call.success\n  require caller == ext_call.return_data[12 len 20]\n  require 0 < proof.length\n  if 'L' == Mask(8, 248, mem[ceil32(result.length) + 160]):\n      require 1 < proof.length\n      if 'P' == Mask(8, 248, mem[ceil32(result.length) + 161]):\n          require 2 < proof.length\n          if Mask(8, 248, mem[ceil32(result.length) + 162]) == 0x100000000000000000000000000000000000000000000000000000000000000:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  log proofFailed(\n        address =stor34[myid],\n        uint256 =stor35[myid])\n  call stor34[myid] with:\n     value stor35[myid] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  stor34[myid] = 0\n  stor35[myid] = 0\n\ndef _fallback(?) payable: # default function\n  if owner == caller:\n      stop\n  require call.value <= maxBet\n  require call.value >= minBet\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.length) = 0\n          stor2.length.field_1 = 11\n          stor2.length.field_8 = 'eth_mainnet' / 256\n          idx = 0\n          while stor2.length + 31 / 32 > idx:\n              stor2[idx].field_0 = 0\n              idx = idx + 1\n              continue \n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 12\n              stor2.length.field_8 = 'eth_ropsten3' / 256\n              idx = 0\n              while stor2.length + 31 / 32 > idx:\n                  stor2[idx].field_0 = 0\n                  idx = idx + 1\n                  continue \n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.length) = 0\n                  stor2.length.field_1 = 9\n                  stor2.length.field_8 = 'eth_kovan' / 256\n                  idx = 0\n                  while stor2.length + 31 / 32 > idx:\n                      stor2[idx].field_0 = 0\n                      idx = idx + 1\n                      continue \n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) <= 0:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                      else:\n                          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          else:\n                              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                  else:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.length) = 0\n                      stor2.length.field_1 = 11\n                      stor2.length.field_8 = 'eth_rinkeby' / 256\n                      idx = 0\n                      while stor2.length + 31 / 32 > idx:\n                          stor2[idx].field_0 = 0\n                          idx = idx + 1\n                          continue \n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                       gas gas_remaining - 710 wei\n                      args 0\n                  if ext_call.success:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if ext_code.size(stor0):\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          if ext_call.success:\n              stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n              if ext_code.size(address(ext_call.return_data[0])):\n                  call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                       gas gas_remaining - 710 wei\n                      args 0\n                  if ext_call.success:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.length) = 0\n              stor2.length.field_1 = 11\n              stor2.length.field_8 = 'eth_mainnet' / 256\n              idx = 0\n              while stor2.length + 31 / 32 > idx:\n                  stor2[idx].field_0 = 0\n                  idx = idx + 1\n                  continue \n          else:\n              if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n                  stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n                  bool(stor2.length) = 0\n                  stor2.length.field_1 = 12\n                  stor2.length.field_8 = 'eth_ropsten3' / 256\n                  idx = 0\n                  while stor2.length + 31 / 32 > idx:\n                      stor2[idx].field_0 = 0\n                      idx = idx + 1\n                      continue \n              else:\n                  if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                      stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                      bool(stor2.length) = 0\n                      stor2.length.field_1 = 9\n                      stor2.length.field_8 = 'eth_kovan' / 256\n                      idx = 0\n                      while stor2.length + 31 / 32 > idx:\n                          stor2[idx].field_0 = 0\n                          idx = idx + 1\n                          continue \n                  else:\n                      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) <= 0:\n                          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          else:\n                              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                                  stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              else:\n                                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      else:\n                          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                          bool(stor2.length) = 0\n                          stor2.length.field_1 = 11\n                          stor2.length.field_8 = 'eth_rinkeby' / 256\n                          idx = 0\n                          while stor2.length + 31 / 32 > idx:\n                              stor2[idx].field_0 = 0\n                              idx = idx + 1\n                              continue \n          if ext_code.size(stor0):\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              if ext_call.success:\n                  stor1 = ext_call.return_data[12 len 20] or Mask(96, 160, stor1)\n                  if ext_code.size(address(ext_call.return_data[0])):\n                      call address(ext_call.return_data[0]).setProofType(bytes1 _proofType) with:\n                           gas gas_remaining - 710 wei\n                          args 0\n                      if ext_call.success:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\n.",
	"status": "1",
	"time_cost": 60.026347160339355,
	"usage": {
		"completion_tokens": 672,
		"prompt_tokens": 7478,
		"total_tokens": 8150
	}
}