{
	"address": "0xe5a04d98538231b0fab9aba60cd73ce4ff3039df",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the contract code based on the provided decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping (uint256 => uint256[]) public array_2; \n    mapping (uint256 => uint256[]) public map_3; \n    mapping (uint256 => uint256[]) public map_4; \n    uint256 public _generatedBytes;\n    uint256 public _maxBet;\n    uint256 public _minBet;\n    uint256 public _oraclizeFee;\n    uint256 public _flipRewardAmount; \n    uint256 public _mdtRewardAmount;\n    uint256 public _jackpotAmount;\n    uint256 public _sponsoredJackpotAmount;\n    uint256 public _bonusAmount;\n    uint256 public _sponsoredBonusAmount;\n    uint256 public _callbackGas;\n    uint256 public _incrementFee;\n    uint256 public _incrementDivisor;\n    uint256 public _baseComparable;\n    address public stor_0_0_19;\n    uint256 public _jackpotHit;\n    uint256 public _sponsoredJackpotMin;\n    uint256 public _sponsoredJackpotMax;\n    uint256 public _bonusMin;\n    uint256 public _bonusMax;\n    uint256 public _sponsoredBonusMin;\n    uint256 public _sponsoredBonusMax;\n    uint256 public _mdtComparable;\n    mapping (uint256 => uint256[]) public map_22;\n    mapping (uint256 => uint256[]) public map_23;\n    address public owner_1_0_19;\n    address public _flipTokenReward;\n    address public _millionDollarTokenReward;\n    address public _jackpotToken;\n    address public _sponsoredJackpotToken;\n    address public _bonusToken;\n    address public _sponsoredBonusToken;\n    address public _owner;\n\n    event proofFailed(address indexed from, uint256 value);\n    event newRandomValue(bytes data, address indexed from, uint256 value);\n\n    function bonusMin() public view returns (uint256) {\n        return _bonusMin;\n    }\n\n    function updateFlipAndMDT(address varg0, uint256 varg1, address varg2, uint256 varg3) public {\n        require(_owner == msg.sender);\n        _millionDollarTokenReward = varg2;\n        _mdtRewardAmount = varg3;\n        _flipTokenReward = varg0;\n        _flipRewardAmount = varg1;\n    }\n\n    function generatedBytes() public view returns (uint256) {\n        return _generatedBytes;\n    }\n\n    function updateGameSpecifics(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public {\n        require(_owner == msg.sender);\n        _callbackGas = varg0;\n        _oraclizeFee = varg1;\n        _incrementFee = varg2;\n        _incrementDivisor = varg3;\n    }\n\n    function setJackpotToken(address varg0, uint256 varg1, uint256 varg2, address varg3, uint256 varg4, uint256 varg5, uint256 varg6) public {\n        require(_owner == msg.sender);\n        _jackpotToken = varg0;\n        _jackpotAmount = varg1;\n        _jackpotHit = varg2;\n        _sponsoredJackpotToken = varg3;\n        _sponsoredJackpotAmount = varg4;\n        _sponsoredJackpotMin = varg5;\n        _sponsoredJackpotMax = varg6;\n    }\n\n    function maxBet() public view returns (uint256) {\n        return _maxBet;\n    }\n\n    function baseComparable() public view returns (uint256) {\n        return _baseComparable;\n    }\n\n    function bonusToken() public view returns (address) {\n        return _bonusToken;\n    }\n\n    function sponsoredJackpotToken() public view returns (address) {\n        return _sponsoredJackpotToken;\n    }\n\n    function oraclizeFee() public view returns (uint256) {\n        return _oraclizeFee;\n    }\n\n    function sponsoredJackpotMin() public view returns (uint256) {\n        return _sponsoredJackpotMin;\n    }\n\n    function sponsoredJackpotAmount() public view returns (uint256) {\n        return _sponsoredJackpotAmount;\n    }\n\n    function flipTokenReward() public view returns (address) {\n        return _flipTokenReward;\n    }\n\n    function flipRewardAmount() public view returns (uint256) {\n        return _flipRewardAmount;\n    }\n\n    function bonusMax() public view returns (uint256) {\n        return _bonusMax;\n    }\n\n    function jackpotHit() public view returns (uint256) {\n        return _jackpotHit;\n    }\n\n    function updateOwner(address varg0) public {\n        require(_owner == msg.sender);\n        _owner = varg0;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function jackpotToken() public view returns (address) {\n        return _jackpotToken;\n    }\n\n    function minBet() public view returns (uint256) {\n        return _minBet;\n    }\n\n    function incrementFee() public view returns (uint256) {\n        return _incrementFee;\n    }\n\n    function callbackGas() public view returns (uint256) {\n        return _callbackGas;\n    }\n\n    function incrementDivisor() public view returns (uint256) {\n        return _incrementDivisor;\n    }\n\n    function walletSend(address varg0, uint256 varg1, address varg2) public {\n        require(_owner == msg.sender);\n        require(varg0.code.size);\n        bool v0 = varg0.transfer(varg2, varg1);\n        require(v0);\n    }\n\n    function bonusAmount() public view returns (uint256) {\n        return _bonusAmount;\n    }\n\n    function sponsoredJackpotMax() public view returns (uint256) {\n        return _sponsoredJackpotMax;\n    }\n\n    function jackpotAmount() public view returns (uint256) {\n        return _jackpotAmount;\n    }\n\n    function sponsoredBonusMax() public view returns (uint256) {\n        return _sponsoredBonusMax;\n    }\n\n    function millionDollarTokenReward() public view returns (address) {\n        return _millionDollarTokenReward;\n    }\n\n    function refundTransfer(address varg0, uint256 varg1) public {\n        require(_owner == msg.sender);\n        bool v0 = varg0.call.value(varg1)();\n        require(v0);\n    }\n\n    function sponsoredBonusAmount() public view returns (uint256) {\n        return _sponsoredBonusAmount;\n    }\n\n    function mdtRewardAmount() public view returns (uint256) {\n        return _mdtRewardAmount;\n    }\n\n    function sponsoredBonusToken() public view returns (address) {\n        return _sponsoredBonusToken;\n    }\n\n    function updateMaxMinComparables(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public {\n        require(_owner == msg.sender);\n        _maxBet = varg0;\n        _minBet = varg1;\n        _baseComparable = varg2;\n        _mdtComparable = varg3;\n    }\n\n    function mdtComparable() public view returns (uint256) {\n        return _mdtComparable;\n    }\n}\n```\n\nPlease note that the derived code is incomplete and may not work as expected without additional modification. The original bytecode contains complex functionality, such as inline assembly, dynamic length array manipulations, and cryptographic operations that cannot be directly translated to high-level Solidity code. Therefore, the derived code should be carefully reviewed and tested before any use.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038802,
	"id": "chatcmpl-8ChkYV1nk7uaIqraZJ768j9YFSntM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 07:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) map_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) map_4; // STORAGE[0x4]\nuint256 _generatedBytes; // STORAGE[0xc]\nuint256 _maxBet; // STORAGE[0xd]\nuint256 _minBet; // STORAGE[0xe]\nuint256 _oraclizeFee; // STORAGE[0xf]\nuint256 _flipRewardAmount; // STORAGE[0x10]\nuint256 _mdtRewardAmount; // STORAGE[0x11]\nuint256 _jackpotAmount; // STORAGE[0x12]\nuint256 _sponsoredJackpotAmount; // STORAGE[0x13]\nuint256 _bonusAmount; // STORAGE[0x14]\nuint256 _sponsoredBonusAmount; // STORAGE[0x15]\nuint256 _callbackGas; // STORAGE[0x16]\nuint256 _incrementFee; // STORAGE[0x17]\nuint256 _incrementDivisor; // STORAGE[0x18]\nuint256 _baseComparable; // STORAGE[0x19]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\nuint256 _jackpotHit; // STORAGE[0x1a]\nuint256 _sponsoredJackpotMin; // STORAGE[0x1b]\nuint256 _sponsoredJackpotMax; // STORAGE[0x1c]\nuint256 _bonusMin; // STORAGE[0x1d]\nuint256 _bonusMax; // STORAGE[0x1e]\nuint256 _sponsoredBonusMin; // STORAGE[0x1f]\nuint256 _sponsoredBonusMax; // STORAGE[0x20]\nuint256 _mdtComparable; // STORAGE[0x21]\nmapping (uint256 => [uint256]) map_22; // STORAGE[0x22]\nmapping (uint256 => [uint256]) map_23; // STORAGE[0x23]\naddress owner_1_0_19; // STORAGE[0x1] bytes 0 to 19\naddress _flipTokenReward; // STORAGE[0x5] bytes 0 to 19\naddress _millionDollarTokenReward; // STORAGE[0x6] bytes 0 to 19\naddress _jackpotToken; // STORAGE[0x7] bytes 0 to 19\naddress _sponsoredJackpotToken; // STORAGE[0x8] bytes 0 to 19\naddress _bonusToken; // STORAGE[0x9] bytes 0 to 19\naddress _sponsoredBonusToken; // STORAGE[0xa] bytes 0 to 19\naddress _owner; // STORAGE[0xb] bytes 0 to 19\n\n// Events\nproofFailed(address, uint256);\nnewRandomValue(bytes, address, uint256);\n\nfunction 0x1777() private { \n    if (0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed.code.size <= 0) {\n        if (0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1.code.size <= 0) {\n            if (0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e.code.size <= 0) {\n                if (0x146500cfd35b22e4a392fe0adc06de1a1368ed48.code.size <= 0) {\n                    if (0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475.code.size <= 0) {\n                        if (0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf.code.size <= 0) {\n                            if (0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa.code.size <= 0) {\n                                v0 = v1 = 0;\n                            } else {\n                                stor_0_0_19 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa;\n                                v0 = v2 = 1;\n                            }\n                        } else {\n                            stor_0_0_19 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf;\n                            v0 = v3 = 1;\n                        }\n                    } else {\n                        stor_0_0_19 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475;\n                        v0 = v4 = 1;\n                        goto 0x1ab60x1777;\n                    }\n                } else {\n                    stor_0_0_19 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48;\n                    0x2012('eth_rinkeby');\n                }\n            } else {\n                stor_0_0_19 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e;\n                0x2012('eth_kovan');\n            }\n        } else {\n            stor_0_0_19 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1;\n            0x2012('eth_ropsten3');\n        }\n    } else {\n        stor_0_0_19 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed;\n        0x2012('eth_mainnet');\n    }\n    v0 = v5 = 1;\n    return v0;\n}\n\nfunction 0x1da3() private { \n    v0 = v1 = !stor_0_0_19;\n    if (stor_0_0_19) {\n        v0 = v2 = !stor_0_0_19.code.size;\n    }\n    if (v0) {\n        v3 = 0x1777();\n    }\n    MEM[32 + MEM[64]] = 0;\n    assert(stor_0_0_19.code.size);\n    v4, v5 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n    assert(v4);\n    owner_1_0_19 = v5;\n    MEM[32 + MEM[64]] = 0;\n    assert(owner_1_0_19.code.size);\n    v6, v7 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    assert(v6);\n    return MEM[MEM[64]];\n}\n\nfunction 0x1edf(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    assert(0 < varg0.length);\n    v0 = v1 = 0x4c00000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (0x4c00000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        v0 = v2 = 0x5000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248;\n    }\n    if (!v0) {\n        assert(2 < varg0.length);\n        v0 = v3 = MEM[34 + varg0] >> 248 << 248 & 0xff00000000000000000000000000000000000000000000000000000000000000 != 0x100000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        MEM[MEM[64]] = 0;\n        v4 = new bytes[]((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1);\n        v5 = v6 = v4.data;\n        if ((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) {\n            if (31 < (array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v5] = STORAGE[v7];\n                    v7 += 1;\n                    v5 += 32;\n                } while (v6 + ((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) <= v5);\n            } else {\n                MEM[v6] = array_2.length >> 8 << 8;\n            }\n        }\n        v8 = 0x241c(v4, varg1, varg2, varg0);\n        if (v8) {\n            v9 = v10 = 0;\n        } else {\n            v9 = v11 = 2;\n        }\n    } else {\n        v9 = v12 = 1;\n    }\n    return v9;\n}\n\nfunction 0x2012(uint256 varg0) private { \n    v0 = v1 = varg0.data;\n    if (31 < varg0.length) {\n        array_2.length = 1 + (varg0.length + varg0.length);\n        if (varg0.length) {\n            while (v1 + varg0.length > v0) {\n                STORAGE[v2] = MEM[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        array_2.length = varg0.length + varg0.length | ~0xff & MEM[v1];\n    }\n    while (v3 + (31 + array_2.length >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x241c(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    assert(69 < varg3.length);\n    v0 = 102 + (MEM[varg3.data + 69] >> 248 << 248 >> 248);\n    v1 = v2 = MEM[64];\n    if (MSIZE() >= v2) {\n        v1 = v3 = new uint256[](32);\n    }\n    v1 = new uint256[](32);\n    MEM[MEM[64]] = 0;\n    require(v1.length >= 32);\n    v4 = v0 + 32;\n    v5 = 32;\n    while (v4 < 32 + v0 + 32) {\n        MEM[v5 + v1] = MEM[v4 + varg3];\n        v4 += 32;\n        v5 += 32;\n    }\n    MEM[32 + v6.data] = 0;\n    v7 = v8 = v6.data;\n    v9 = v10 = varg0.length;\n    v11 = v12 = varg0.data;\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v11 += 32;\n    }\n    MEM[v7] = ~0 + 256 ** (32 - v9) & MEM[v7] | MEM[v11] & ~(~0 + 256 ** (32 - v9));\n    MEM[v8 + v10] = varg2;\n    assert(v13);\n    v14 = v15 = v15.data;\n    v16 = v17 = v1.length;\n    v18 = v19 = v1.data;\n    while (v16 >= 32) {\n        MEM[v14] = MEM[v18];\n        v16 = v16 + ~31;\n        v14 += 32;\n        v18 += 32;\n    }\n    MEM[v14] = MEM[v14] & ~0 + 256 ** (32 - v16) | MEM[v18] & ~(~0 + 256 ** (32 - v16));\n    if (keccak256(v20.data) == keccak256(MEM[v15 len 32])) {\n        assert(v0 + 74 < varg3.length);\n        v21 = v22 = MEM[64];\n        if (MSIZE() >= v22) {\n            v21 = v23 = new uint256[](2 + (MEM[varg3.data + (v0 + 74)] >> 248 << 248 >> 248));\n        }\n        v21 = new uint256[](2 + (MEM[varg3.data + (v0 + 74)] >> 248 << 248 >> 248));\n        MEM[MEM[64]] = 0;\n        require(v21.length >= v21.length + 0);\n        v24 = 73 + v0 + 32;\n        v25 = 32;\n        while (v24 < 105 + v0 + v21.length) {\n            MEM[v25 + v21] = MEM[v24 + varg3];\n            v24 += 32;\n            v25 += 32;\n        }\n        MEM[32 + v26.data] = 0;\n        v27 = v28 = v26.data;\n        v29 = v30 = v21.length;\n        v31 = v32 = v21.data;\n        while (v29 >= 32) {\n            MEM[v27] = MEM[v31];\n            v29 = v29 + ~31;\n            v27 += 32;\n            v31 += 32;\n        }\n        MEM[v27] = ~0 + 256 ** (32 - v29) & MEM[v27] | MEM[v31] & ~(~0 + 256 ** (32 - v29));\n        v33, v34 = sha256hash(v26.data, 0);\n        assert(v33);\n        v35 = v36 = 0;\n        v37 = v38 = 1;\n        while (0xff & v35 < varg1.length) {\n            assert(0xff & v35 < varg1.length);\n            assert(0xff & v35 < 32);\n            if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(v34, 0xff & v35)) << 248 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg1.data + (0xff & v35)] >> 248 << 248) {\n                v37 = v39 = 0;\n            }\n            v35 += 1;\n        }\n        if (v37) {\n            v40 = v41 = MEM[64];\n            if (MSIZE() >= v41) {\n                v40 = v42 = new uint256[](41);\n            }\n            v40 = new uint256[](41);\n            MEM[MEM[64]] = 0;\n            require(v40.length >= 41);\n            v43 = 32 + v0 + 32;\n            v44 = 32;\n            while (v43 < 64 + v0 + 41) {\n                MEM[v44 + v40] = MEM[v43 + varg3];\n                v43 += 32;\n                v44 += 32;\n            }\n            v45 = v46 = MEM[64];\n            if (MSIZE() >= v46) {\n                v45 = v47 = new uint256[](64);\n            }\n            v45 = new uint256[](64);\n            v45 = v48 = 65 + (73 + v0 + v21.length);\n            MEM[MEM[64]] = 0;\n            require(v45.length >= 64);\n            v49 = v48 - 64 + 32;\n            v50 = 32;\n            while (v49 < 32 + (v48 - 64) + 64) {\n                MEM[v50 + v45] = MEM[v49 + varg3];\n                v49 += 32;\n                v50 += 32;\n            }\n            MEM[32 + v51.data] = 0;\n            v52 = v53 = v51.data;\n            v54 = v55 = v45.length;\n            v56 = v57 = v45.data;\n            while (v54 >= 32) {\n                MEM[v52] = MEM[v56];\n                v54 = v54 + ~31;\n                v52 += 32;\n                v56 += 32;\n            }\n            MEM[v52] = ~0 + 256 ** (32 - v54) & MEM[v52] | MEM[v56] & ~(~0 + 256 ** (32 - v54));\n            v58, v40 = sha256hash(v51.data, 0);\n            assert(v58);\n            v59 = v60 = v60.data;\n            v61 = v62 = v40.length;\n            v63 = v64 = v40.data;\n            while (v61 >= 32) {\n                MEM[v59] = MEM[v63];\n                v61 = v61 + ~31;\n                v59 += 32;\n                v63 += 32;\n            }\n            MEM[v59] = MEM[v63] & ~(256 ** (32 - v61) - 1) | MEM[v59] & 256 ** (32 - v61) - 1;\n            MEM[v62 + v60] = ~0x0 & (~0x0 & v40);\n            v65 = ~0x0 & (~0x0 & varg2);\n            if (~0x0 & map_3[v65] != ~0x0 & keccak256(v60)) {\n                v66 = v67 = 0;\n            } else {\n                map_3[varg2] = 0;\n                v21 = v68 = MEM[64];\n                if (MSIZE() >= v68) {\n                    v21 = v69 = new uint256[](73);\n                }\n                v21 = new uint256[](73);\n                MEM[MEM[64]] = 0;\n                require(v21.length >= 73);\n                v70 = v0 + 32;\n                v71 = 32;\n                while (v70 < 32 + v0 + 73) {\n                    MEM[v71 + v21] = MEM[v70 + varg3];\n                    v70 += 32;\n                    v71 += 32;\n                }\n                v72 = v73 = 10516;\n                MEM[32 + v74.data] = 0;\n                v75 = v76 = v74.data;\n                v77 = v78 = v21.length;\n                v79 = v80 = v21.data;\n                while (v77 >= 32) {\n                    MEM[v75] = MEM[v79];\n                    v77 = v77 + ~31;\n                    v75 += 32;\n                    v79 += 32;\n                }\n                MEM[v75] = ~0 + 256 ** (32 - v77) & MEM[v75] | MEM[v79] & ~(~0 + 256 ** (32 - v77));\n                v81, v82 = sha256hash(v74.data, 0);\n                assert(v81);\n                while (1) {\n                    MEM[MEM[64]] = 0;\n                    MEM[MEM[64]] = 0;\n                    v83 = v84 = MEM[64];\n                    if (MSIZE() >= v84) {\n                        v83 = new uint256[](32);\n                    }\n                    v83 = new uint256[](32);\n                    if (3 < MEM[v21]) {\n                        break;\n                    }\n                    assert(3 < MEM[v21]);\n                    MEM[MEM[64]] = 0;\n                    require(v83.length >= 32);\n                    v85 = 4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 32;\n                    v86 = 32;\n                    while (v85 < 36 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 32) {\n                        MEM[v86 + v83] = MEM[v85 + v21];\n                        v85 += 32;\n                        v86 += 32;\n                    }\n                    v87 = v88 = MEM[64];\n                    if (MSIZE() >= v88) {\n                        v87 = new uint256[](32);\n                    }\n                    v87 = new uint256[](32);\n                    assert(4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1 < MEM[v21]);\n                    v89 = 4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 + ((MEM[32 + v21 + (4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1)] >> 248 << 248 >> 248) - 32);\n                    MEM[MEM[64]] = 0;\n                    require(v87.length >= 32);\n                    v90 = v89 + 32;\n                    v91 = 32;\n                    while (v90 < 32 + v89 + 32) {\n                        MEM[v91 + v87] = MEM[v90 + v21];\n                        v90 += 32;\n                        v91 += 32;\n                    }\n                    v92, v93 = ecrecover(v82, 27, MEM[v83.data], MEM[v87.data]);\n                    v94 = v95 = MEM[64];\n                    v96 = v97 = MEM[v45];\n                    v98 = 32 + v45;\n                    while (v96 >= 32) {\n                        MEM[v94] = MEM[v98];\n                        v96 = v96 + ~31;\n                        v94 += 32;\n                        v98 += 32;\n                    }\n                    MEM[v94] = MEM[v98] & ~(256 ** (32 - v96) - 1) | MEM[v94] & 256 ** (32 - v96) - 1;\n                    if (address(keccak256(v99.data)) != address(v93)) {\n                        v100, v101 = ecrecover(v82, 28, MEM[v83.data], MEM[v87.data]);\n                        v102 = v103 = MEM[64];\n                        v104 = v105 = MEM[v45];\n                        v106 = 32 + v45;\n                        while (v104 >= 32) {\n                            MEM[v102] = MEM[v106];\n                            v104 = v104 + ~31;\n                            v102 += 32;\n                            v106 += 32;\n                        }\n                        MEM[v102] = MEM[v106] & ~(256 ** (32 - v104) - 1) | MEM[v102] & 256 ** (32 - v104) - 1;\n                        v107 = address(keccak256(v108.data)) == address(v101);\n                    } else {\n                        v107 = v109 = 1;\n                    }\n                    goto {'0x33fc0x241c', '0x29140x241c', '0x32430x241c'};\n                    if (v107) {\n                        if (!(0xff & map_4[v40])) {\n                            v110 = 0x303e(v45, varg3, 10568, v21, v40);\n                            map_4[v40] = v110 | ~0xff & map_4[v40];\n                        }\n                        v66 = 0xff & map_4[v40];\n                    } else {\n                        v66 = v111 = 0;\n                    }\n                    if (v107) {\n                        v45 = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4;\n                        v40 = v112 = MEM[64];\n                        if (MSIZE() >= v112) {\n                            v40 = new uint256[](66);\n                        }\n                        v40 = new uint256[](66);\n                        assert(0 < v40.length);\n                        v113 = v40.data;\n                        MEM8[v40.data] = (byte(0xfe00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                        MEM[MEM[64]] = 0;\n                        require(v40.length >= 66);\n                        v114 = 35;\n                        v115 = 33;\n                        while (v114 < 100) {\n                            MEM[v115 + v40] = MEM[v114 + varg0];\n                            v114 += 32;\n                            v115 += 32;\n                        }\n                        assert(69 < varg0.length);\n                        v21 = v116 = MEM[64];\n                        if (MSIZE() >= v116) {\n                            v21 = new uint256[](2 + (MEM[varg0.data + 69] >> 248 << 248 >> 248));\n                        }\n                        v21 = new uint256[](2 + (MEM[varg0.data + 69] >> 248 << 248 >> 248));\n                        MEM[MEM[64]] = 0;\n                        require(v21.length >= v21.length + 0);\n                        v117 = 100;\n                        v118 = 32;\n                        while (v117 < 100 + v21.length) {\n                            MEM[v118 + v21] = MEM[v117 + varg0];\n                            v117 += 32;\n                            v118 += 32;\n                        }\n                        v72 = v119 = 13308;\n                        MEM[32 + MEM[64]] = 0;\n                        v120 = v121 = MEM[64];\n                        v122 = v123 = v40.length;\n                        v124 = v40.data;\n                        while (v122 >= 32) {\n                            MEM[v120] = MEM[v124];\n                            v122 = v122 + ~31;\n                            v120 += 32;\n                            v124 += 32;\n                        }\n                        MEM[v120] = ~0 + 256 ** (32 - v122) & MEM[v120] | MEM[v124] & ~(~0 + 256 ** (32 - v122));\n                        v125 = sha256hash(MEM[(MEM[64]) len (v121 + v123 - MEM[64])], MEM[(MEM[64]) len 32]);\n                        assert(v125);\n                        v82 = MEM[MEM[64]];\n                    }\n                }\n            }\n        } else {\n            v66 = v126 = 0;\n        }\n    } else {\n        v66 = v127 = 0;\n    }\n    return v66;\n}\n\nfunction bonusMin() public payable { \n    assert(!msg.value);\n    return _bonusMin;\n}\n\nfunction updateFlipAndMDT(address varg0, uint256 varg1, address varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _millionDollarTokenReward = varg2;\n    _mdtRewardAmount = varg3;\n    _flipTokenReward = varg0;\n    _flipRewardAmount = varg1;\n}\n\nfunction generatedBytes() public payable { \n    assert(!msg.value);\n    return _generatedBytes;\n}\n\nfunction updateGameSpecifics(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _callbackGas = varg0;\n    _oraclizeFee = varg1;\n    _incrementFee = varg2;\n    _incrementDivisor = varg3;\n}\n\nfunction 0x303e(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    v0 = MEM[64];\n    MEM[64] = v0 + 32;\n    MEM[v0] = 0;\n    v1 = MEM[64];\n    MEM[64] = v1 + 32;\n    MEM[v1] = 0;\n    v2 = MEM[64];\n    MEM[v2] = 0;\n    v3 = 1 + varg0;\n    assert(v3 < varg1.length);\n    v2 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v2 = v5 = new uint256[](2 + (MEM[varg1.data + v3] >> 248 << 248 >> 248));\n    }\n    v2 = new uint256[](2 + (MEM[varg1.data + v3] >> 248 << 248 >> 248));\n    MEM[MEM[64]] = 0;\n    require(v2.length >= v2.length + 0);\n    v6 = varg0 + 32;\n    v7 = 32;\n    while (v6 < 32 + varg0 + v2.length) {\n        MEM[v7 + v2] = MEM[v6 + varg1];\n        v6 += 32;\n        v7 += 32;\n    }\n    v0 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v0 = v9 = new uint256[](64);\n    }\n    v0 = new uint256[](64);\n    MEM[MEM[64]] = 0;\n    require(v0.length >= 64);\n    v10 = 36;\n    v11 = 32;\n    while (v10 < 100) {\n        MEM[v11 + v0] = MEM[v10 + varg1];\n        v10 += 32;\n        v11 += 32;\n    }\n    v1 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v1 = v13 = new uint256[](98);\n    }\n    v1 = new uint256[](98);\n    assert(0 < v1.length);\n    v14 = v1.data;\n    MEM8[v1.data] = (byte(0x100000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n    v15 = varg0 - 65;\n    MEM[MEM[64]] = 0;\n    require(v1.length >= 66);\n    v16 = v15 + 32;\n    v17 = 33;\n    while (v16 < 32 + v15 + 65) {\n        MEM[v17 + v1] = MEM[v16 + varg1];\n        v16 += 32;\n        v17 += 32;\n    }\n    require(v1.length >= 98);\n    v18 = 32;\n    v19 = 98;\n    while (v18 < 64) {\n        MEM[v19 + v1] = MEM[v18 + 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c0];\n        v18 += 32;\n        v19 += 32;\n    }\n    v20 = v21 = 12867;\n    MEM[32 + v22.data] = 0;\n    v23 = v24 = v22.data;\n    v25 = v26 = v1.length;\n    v27 = v28 = v1.data;\n    while (v25 >= 32) {\n        MEM[v23] = MEM[v27];\n        v25 = v25 + ~31;\n        v23 += 32;\n        v27 += 32;\n    }\n    MEM[v23] = ~0 + 256 ** (32 - v25) & MEM[v23] | MEM[v27] & ~(~0 + 256 ** (32 - v25));\n    v29, v30 = sha256hash(v22.data, 0);\n    assert(v29);\n    while (1) {\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64]] = 0;\n        v31 = v32 = MEM[64];\n        if (MSIZE() >= v32) {\n            v31 = new uint256[](32);\n        }\n        v31 = new uint256[](32);\n        if (3 < MEM[v2]) {\n            break;\n        }\n        assert(3 < MEM[v2]);\n        MEM[MEM[64]] = 0;\n        require(v31.length >= 32);\n        v33 = 4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 32;\n        v34 = 32;\n        while (v33 < 36 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 32) {\n            MEM[v34 + v31] = MEM[v33 + v2];\n            v33 += 32;\n            v34 += 32;\n        }\n        v35 = v36 = MEM[64];\n        if (MSIZE() >= v36) {\n            v35 = new uint256[](32);\n        }\n        v35 = new uint256[](32);\n        assert(4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1 < MEM[v2]);\n        v37 = 4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 + ((MEM[32 + v2 + (4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1)] >> 248 << 248 >> 248) - 32);\n        MEM[MEM[64]] = 0;\n        require(v35.length >= 32);\n        v38 = v37 + 32;\n        v39 = 32;\n        while (v38 < 32 + v37 + 32) {\n            MEM[v39 + v35] = MEM[v38 + v2];\n            v38 += 32;\n            v39 += 32;\n        }\n        v40, v41 = ecrecover(v30, 27, MEM[v31.data], MEM[v35.data]);\n        v42 = v43 = MEM[64];\n        v44 = v45 = MEM[v0];\n        v46 = 32 + v0;\n        while (v44 >= 32) {\n            MEM[v42] = MEM[v46];\n            v44 = v44 + ~31;\n            v42 += 32;\n            v46 += 32;\n        }\n        MEM[v42] = MEM[v46] & ~(256 ** (32 - v44) - 1) | MEM[v42] & 256 ** (32 - v44) - 1;\n        if (address(keccak256(v47.data)) != address(v41)) {\n            v48, v49 = ecrecover(v30, 28, MEM[v31.data], MEM[v35.data]);\n            v50 = v51 = MEM[64];\n            v52 = v53 = MEM[v0];\n            v54 = 32 + v0;\n            while (v52 >= 32) {\n                MEM[v50] = MEM[v54];\n                v52 = v52 + ~31;\n                v50 += 32;\n                v54 += 32;\n            }\n            MEM[v50] = MEM[v54] & ~(256 ** (32 - v52) - 1) | MEM[v50] & 256 ** (32 - v52) - 1;\n            v55 = address(keccak256(v56.data)) == address(v49);\n        } else {\n            v55 = v57 = 1;\n        }\n        goto {'0x32430x303e', '0x29140x303e', '0x33fc0x303e'};\n        if (v55) {\n            if (!(0xff & map_4[v1])) {\n                v58 = 0x303e(v0, varg4, 10568, v2, v1);\n                map_4[v1] = v58 | ~0xff & map_4[v1];\n            }\n        }\n        if (v55) {\n            v0 = v59 = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4;\n            v1 = v60 = MEM[64];\n            if (MSIZE() >= v60) {\n                v1 = v61 = new uint256[](66);\n            }\n            v1 = new uint256[](66);\n            assert(0 < v1.length);\n            v62 = v61.data;\n            MEM8[v61.data] = (byte(0xfe00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n            MEM[MEM[64]] = 0;\n            require(v1.length >= 66);\n            v63 = 35;\n            v64 = 33;\n            while (v63 < 100) {\n                MEM[v64 + v1] = MEM[v63 + varg1];\n                v63 += 32;\n                v64 += 32;\n            }\n            assert(69 < varg1.length);\n            v2 = v65 = MEM[64];\n            if (MSIZE() >= v65) {\n                v2 = v66 = new uint256[](2 + (MEM[varg1.data + 69] >> 248 << 248 >> 248));\n            }\n            v2 = new uint256[](2 + (MEM[varg1.data + 69] >> 248 << 248 >> 248));\n            MEM[MEM[64]] = 0;\n            require(v2.length >= v2.length + 0);\n            v67 = 100;\n            v68 = 32;\n            while (v67 < 100 + v2.length) {\n                MEM[v68 + v2] = MEM[v67 + varg1];\n                v67 += 32;\n                v68 += 32;\n            }\n            v20 = v69 = 13308;\n            MEM[32 + MEM[64]] = 0;\n            v70 = v71 = MEM[64];\n            v72 = v73 = v1.length;\n            v74 = v61.data;\n            while (v72 >= 32) {\n                MEM[v70] = MEM[v74];\n                v72 = v72 + ~31;\n                v70 += 32;\n                v74 += 32;\n            }\n            MEM[v70] = ~0 + 256 ** (32 - v72) & MEM[v70] | MEM[v74] & ~(~0 + 256 ** (32 - v72));\n            v75 = sha256hash(MEM[(MEM[64]) len (v71 + v73 - MEM[64])], MEM[(MEM[64]) len 32]);\n            assert(v75);\n            v30 = MEM[MEM[64]];\n        } else {\n            v55 = v76 = 0;\n        }\n        return v55;\n    }\n}\n\nfunction __callback(bytes32 varg0, string varg1) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = v2 = MEM[64];\n    if (MSIZE() >= v2) {\n        v1 = v3 = new uint256[](0);\n    }\n    v1 = new uint256[](0);\n    v4 = 0x1da3();\n    require(msg.sender == address(v4));\n    v5 = 0x1edf(v1, v0, varg0);\n    v6 = v7 = 0xff & v5;\n    if (!(0xff & v5)) {\n        v6 = v8 = !v1.length;\n    }\n    if (!v6) {\n        v9 = new array[](v0.length);\n        v10 = v11 = v0.length;\n        v12 = v13 = v9.data;\n        v14 = v15 = v0.data;\n        if (v11) {\n            while (1) {\n                MEM[v12] = MEM[v14];\n                if (v10 <= 32) {\n                    break;\n                }\n                v10 = v10 + ~31;\n                v12 += 32;\n                v14 += 32;\n            }\n        }\n        v16 = v17 = v11 + v13;\n        if (0x1f & v11) {\n            MEM[v17 - (0x1f & v11)] = ~(256 ** (32 - (0x1f & v11)) - 1) & MEM[v17 - (0x1f & v11)];\n        }\n        emit newRandomValue(v9, address(map_22[varg0]), map_23[varg0]);\n        v18 = v19 = v19.data;\n        v20 = v21 = v0.length;\n        v22 = v23 = v0.data;\n        while (v20 >= 32) {\n            MEM[v18] = MEM[v22];\n            v20 = v20 + ~31;\n            v18 += 32;\n            v22 += 32;\n        }\n        MEM[v18] = MEM[v18] & ~0 + 256 ** (32 - v20) | MEM[v22] & ~(~0 + 256 ** (32 - v20));\n        assert(0x10000);\n        _generatedBytes = keccak256(v19) % 0x10000;\n        assert(_incrementDivisor);\n        if (_generatedBytes < _baseComparable) {\n            v24 = address(map_22[varg0]).call().value(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1).gas(!(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1) * 2300);\n            assert(v24);\n        }\n        v25 = v26 = _generatedBytes >= _baseComparable;\n        if (v26) {\n            v25 = v27 = _flipRewardAmount > 0;\n        }\n        if (v25) {\n            assert(_flipTokenReward.code.size);\n            v28 = _flipTokenReward.transfer(address(map_22[varg0]), map_23[varg0] / _incrementDivisor * _flipRewardAmount).gas(msg.gas - 710);\n            assert(v28);\n        }\n        v29 = v30 = _generatedBytes >= _mdtComparable;\n        if (v30) {\n            v29 = v31 = _mdtRewardAmount > 0;\n        }\n        if (v29) {\n            assert(_millionDollarTokenReward.code.size);\n            v32 = _millionDollarTokenReward.transfer(address(map_22[varg0]), _mdtRewardAmount).gas(msg.gas - 710);\n            assert(v32);\n        }\n        v33 = v34 = _generatedBytes == _jackpotHit;\n        if (v34) {\n            v33 = v35 = map_23[varg0] == _maxBet;\n        }\n        if (v33) {\n            assert(_jackpotToken.code.size);\n            v36 = _jackpotToken.transfer(address(map_22[varg0]), _jackpotAmount).gas(msg.gas - 710);\n            assert(v36);\n        }\n        v37 = v38 = _generatedBytes >= _sponsoredJackpotMin;\n        if (v38) {\n            v37 = v39 = _generatedBytes <= _sponsoredJackpotMax;\n        }\n        if (v37) {\n            assert(_sponsoredJackpotToken.code.size);\n            v40 = _sponsoredJackpotToken.transfer(address(map_22[varg0]), _sponsoredJackpotAmount).gas(msg.gas - 710);\n            assert(v40);\n        }\n        v41 = v42 = _generatedBytes >= _bonusMin;\n        if (v42) {\n            v41 = v43 = _generatedBytes <= _bonusMax;\n        }\n        if (v41) {\n            assert(_bonusToken.code.size);\n            v44 = _bonusToken.transfer(address(map_22[varg0]), _bonusAmount).gas(msg.gas - 710);\n            assert(v44);\n        }\n        v45 = v46 = _generatedBytes >= _sponsoredBonusMin;\n        if (v46) {\n            v45 = v47 = _generatedBytes <= _sponsoredBonusMax;\n        }\n        if (v45) {\n            assert(_sponsoredBonusToken.code.size);\n            v48 = _sponsoredBonusToken.transfer(address(map_22[varg0]), _sponsoredBonusAmount).gas(msg.gas - 710);\n            assert(v48);\n        }\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    } else {\n        emit proofFailed(address(map_22[varg0]), map_23[varg0]);\n        v49 = address(map_22[varg0]).call().value(map_23[varg0]).gas(2300 * !map_23[varg0]);\n        assert(v49);\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    }\n}\n\nfunction setJackpotToken(address varg0, uint256 varg1, uint256 varg2, address varg3, uint256 varg4, uint256 varg5, uint256 varg6) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _jackpotToken = varg0;\n    _jackpotAmount = varg1;\n    _jackpotHit = varg2;\n    _sponsoredJackpotToken = varg3;\n    _sponsoredJackpotAmount = varg4;\n    _sponsoredJackpotMin = varg5;\n    _sponsoredJackpotMax = varg6;\n}\n\nfunction maxBet() public payable { \n    assert(!msg.value);\n    return _maxBet;\n}\n\nfunction sponsoredBonusMin() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusMin;\n}\n\nfunction __callback(bytes32 varg0, string varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length);\n    v2 = 0x1da3();\n    require(msg.sender == address(v2));\n    v3 = 0x1edf(v1, v0, varg0);\n    v4 = v5 = 0xff & v3;\n    if (!(0xff & v3)) {\n        v4 = v6 = !v1.length;\n    }\n    if (!v4) {\n        v7 = new array[](v0.length);\n        v8 = v9 = v0.length;\n        v10 = v11 = v7.data;\n        v12 = v13 = v0.data;\n        if (v9) {\n            while (1) {\n                MEM[v10] = MEM[v12];\n                if (v8 <= 32) {\n                    break;\n                }\n                v8 = v8 + ~31;\n                v10 += 32;\n                v12 += 32;\n            }\n        }\n        v14 = v15 = v9 + v11;\n        if (0x1f & v9) {\n            MEM[v15 - (0x1f & v9)] = ~(256 ** (32 - (0x1f & v9)) - 1) & MEM[v15 - (0x1f & v9)];\n        }\n        emit newRandomValue(v7, address(map_22[varg0]), map_23[varg0]);\n        v16 = v17 = v17.data;\n        v18 = v19 = v0.length;\n        v20 = v21 = v0.data;\n        while (v18 >= 32) {\n            MEM[v16] = MEM[v20];\n            v18 = v18 + ~31;\n            v16 += 32;\n            v20 += 32;\n        }\n        MEM[v16] = MEM[v16] & ~0 + 256 ** (32 - v18) | MEM[v20] & ~(~0 + 256 ** (32 - v18));\n        assert(0x10000);\n        _generatedBytes = keccak256(v17) % 0x10000;\n        assert(_incrementDivisor);\n        if (_generatedBytes < _baseComparable) {\n            v22 = address(map_22[varg0]).call().value(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1).gas(!(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1) * 2300);\n            assert(v22);\n        }\n        v23 = v24 = _generatedBytes >= _baseComparable;\n        if (v24) {\n            v23 = v25 = _flipRewardAmount > 0;\n        }\n        if (v23) {\n            assert(_flipTokenReward.code.size);\n            v26 = _flipTokenReward.transfer(address(map_22[varg0]), map_23[varg0] / _incrementDivisor * _flipRewardAmount).gas(msg.gas - 710);\n            assert(v26);\n        }\n        v27 = v28 = _generatedBytes >= _mdtComparable;\n        if (v28) {\n            v27 = v29 = _mdtRewardAmount > 0;\n        }\n        if (v27) {\n            assert(_millionDollarTokenReward.code.size);\n            v30 = _millionDollarTokenReward.transfer(address(map_22[varg0]), _mdtRewardAmount).gas(msg.gas - 710);\n            assert(v30);\n        }\n        v31 = v32 = _generatedBytes == _jackpotHit;\n        if (v32) {\n            v31 = v33 = map_23[varg0] == _maxBet;\n        }\n        if (v31) {\n            assert(_jackpotToken.code.size);\n            v34 = _jackpotToken.transfer(address(map_22[varg0]), _jackpotAmount).gas(msg.gas - 710);\n            assert(v34);\n        }\n        v35 = v36 = _generatedBytes >= _sponsoredJackpotMin;\n        if (v36) {\n            v35 = v37 = _generatedBytes <= _sponsoredJackpotMax;\n        }\n        if (v35) {\n            assert(_sponsoredJackpotToken.code.size);\n            v38 = _sponsoredJackpotToken.transfer(address(map_22[varg0]), _sponsoredJackpotAmount).gas(msg.gas - 710);\n            assert(v38);\n        }\n        v39 = v40 = _generatedBytes >= _bonusMin;\n        if (v40) {\n            v39 = v41 = _generatedBytes <= _bonusMax;\n        }\n        if (v39) {\n            assert(_bonusToken.code.size);\n            v42 = _bonusToken.transfer(address(map_22[varg0]), _bonusAmount).gas(msg.gas - 710);\n            assert(v42);\n        }\n        v43 = v44 = _generatedBytes >= _sponsoredBonusMin;\n        if (v44) {\n            v43 = v45 = _generatedBytes <= _sponsoredBonusMax;\n        }\n        if (v43) {\n            assert(_sponsoredBonusToken.code.size);\n            v46 = _sponsoredBonusToken.transfer(address(map_22[varg0]), _sponsoredBonusAmount).gas(msg.gas - 710);\n            assert(v46);\n        }\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    } else {\n        emit proofFailed(address(map_22[varg0]), map_23[varg0]);\n        v47 = address(map_22[varg0]).call().value(map_23[varg0]).gas(2300 * !map_23[varg0]);\n        assert(v47);\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    }\n}\n\nfunction baseComparable() public payable { \n    assert(!msg.value);\n    return _baseComparable;\n}\n\nfunction bonusToken() public payable { \n    assert(!msg.value);\n    return _bonusToken;\n}\n\nfunction sponsoredJackpotToken() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotToken;\n}\n\nfunction oraclizeFee() public payable { \n    assert(!msg.value);\n    return _oraclizeFee;\n}\n\nfunction sponsoredJackpotMin() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotMin;\n}\n\nfunction sponsoredJackpotAmount() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotAmount;\n}\n\nfunction flipTokenReward() public payable { \n    assert(!msg.value);\n    return _flipTokenReward;\n}\n\nfunction flipRewardAmount() public payable { \n    assert(!msg.value);\n    return _flipRewardAmount;\n}\n\nfunction bonusMax() public payable { \n    assert(!msg.value);\n    return _bonusMax;\n}\n\nfunction jackpotHit() public payable { \n    assert(!msg.value);\n    return _jackpotHit;\n}\n\nfunction updateOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction jackpotToken() public payable { \n    assert(!msg.value);\n    return _jackpotToken;\n}\n\nfunction minBet() public payable { \n    assert(!msg.value);\n    return _minBet;\n}\n\nfunction incrementFee() public payable { \n    assert(!msg.value);\n    return _incrementFee;\n}\n\nfunction callbackGas() public payable { \n    assert(!msg.value);\n    return _callbackGas;\n}\n\nfunction incrementDivisor() public payable { \n    assert(!msg.value);\n    return _incrementDivisor;\n}\n\nfunction walletSend(address varg0, uint256 varg1, address varg2) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    assert(varg0.code.size);\n    v0 = varg0.transfer(varg2, varg1).gas(msg.gas - 710);\n    assert(v0);\n}\n\nfunction bonusAmount() public payable { \n    assert(!msg.value);\n    return _bonusAmount;\n}\n\nfunction sponsoredJackpotMax() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotMax;\n}\n\nfunction jackpotAmount() public payable { \n    assert(!msg.value);\n    return _jackpotAmount;\n}\n\nfunction sponsoredBonusMax() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusMax;\n}\n\nfunction millionDollarTokenReward() public payable { \n    assert(!msg.value);\n    return _millionDollarTokenReward;\n}\n\nfunction refundTransfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    assert(v0);\n}\n\nfunction sponsoredBonusAmount() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusAmount;\n}\n\nfunction mdtRewardAmount() public payable { \n    assert(!msg.value);\n    return _mdtRewardAmount;\n}\n\nfunction sponsoredBonusToken() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusToken;\n}\n\nfunction updateMaxMinComparables(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _maxBet = varg0;\n    _minBet = varg1;\n    _baseComparable = varg2;\n    _mdtComparable = varg3;\n}\n\nfunction setBonusToken(address varg0, uint256 varg1, uint256 varg2, uint256 varg3, address varg4, uint256 varg5, uint256 varg6, uint256 varg7) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _bonusToken = varg0;\n    _bonusAmount = varg1;\n    _bonusMin = varg2;\n    _bonusMax = varg3;\n    _sponsoredBonusToken = varg4;\n    _sponsoredBonusAmount = varg5;\n    _sponsoredBonusMin = varg6;\n    _sponsoredBonusMax = varg7;\n}\n\nfunction mdtComparable() public payable { \n    assert(!msg.value);\n    return _mdtComparable;\n}\n\nfunction 0xa1d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    MEM[64] = v1 + 96;\n    v2 = v3 = 3;\n    while (1) {\n        MEM[64] = MEM[64] + 32;\n        MEM[MEM[64]] = 0;\n        MEM[v0] = MEM[64];\n        v0 += 32;\n        v2 = v2 - 1;\n        if (v2) {\n            break;\n        }\n        if (!v2) {\n            v4 = v5 = !varg1;\n            if (varg1) {\n                v4 = v6 = varg1 > 32;\n            }\n            require(!v4);\n            v7 = v8 = MEM[64];\n            if (MSIZE() >= v8) {\n                v7 = v9 = new uint256[](1);\n            }\n            v7 = new uint256[](1);\n            assert(0 < v7.length);\n            v10 = v7.data;\n            MEM8[v7.data] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1 << 248, 0x0)) & 0xFF;\n            v11 = v12 = MEM[64];\n            if (MSIZE() >= v12) {\n                v11 = v13 = new uint256[](32);\n            }\n            v11 = new uint256[](32);\n            v14 = v15 = MEM[64];\n            if (MSIZE() >= v15) {\n                v14 = v16 = new uint256[](32);\n            }\n            v14 = new uint256[](32);\n            v17 = v18 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v17 = !stor_0_0_19.code.size;\n            }\n            if (v17) {\n                v19 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v20, v21 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v20);\n            owner_1_0_19 = v21;\n            MEM[32 + MEM[64]] = 0;\n            assert(owner_1_0_19.code.size);\n            v22, v23 = owner_1_0_19.randomDS_getSessionPubKeyHash().gas(msg.gas - 710);\n            assert(v22);\n            MEM[v11.data] = block.blockhash(block.number - 1) ^ (block.coinbase ^ block.timestamp);\n            MEM[v14.data] = MEM[MEM[64]];\n            v24 = v25 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v24 = !stor_0_0_19.code.size;\n            }\n            if (v24) {\n                v26 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v27, v28 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v27);\n            v29 = v30 = MEM[64];\n            owner_1_0_19 = v28;\n            v31 = v32 = 3;\n            if (MSIZE() >= v30) {\n                v29 = v33 = new uint256[](v32);\n            }\n            v29 = new uint256[](v32);\n            if (v32) {\n                v34 = v33.data;\n                do {\n                    MEM[MEM[64]] = 0;\n                    MEM[v34] = MEM[64];\n                    v34 += 32;\n                    v31 = v31 - 1;\n                } while (!v31);\n            }\n            assert(0 < v29.length);\n            v35 = v33.data;\n            v33[0] = v11;\n            assert(1 < v29.length);\n            v33[1] = v7;\n            assert(2 < v29.length);\n            v33[2] = v14;\n            MEM[MEM[64]] = 0;\n            v36 = v37 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v36 = !stor_0_0_19.code.size;\n            }\n            if (v36) {\n                v38 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v39, v40 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v39);\n            owner_1_0_19 = v40;\n            MEM[32 + MEM[64]] = 0;\n            v41 = new array[](v42.length);\n            v43 = v44 = v42.length;\n            v45 = v46 = v41.data;\n            v47 = v48 = v42.data;\n            if (v44) {\n                while (1) {\n                    MEM[v45] = MEM[v47];\n                    if (v43 <= 32) {\n                        break;\n                    }\n                    v43 = v43 + ~31;\n                    v45 += 32;\n                    v47 += 32;\n                }\n            }\n            if (0x1f & v44) {\n                MEM[v41.data] = ~(256 ** (32 - (0x1f & v44)) - 1) & MEM[v41.data];\n            }\n            assert(owner_1_0_19.code.size);\n            v49, v50 = owner_1_0_19.getPrice(v41, varg0).gas(msg.gas - 710);\n            assert(v49);\n            if (v50 <= varg0 * msg.gas + 0xde0b6b3a7640000) {\n                MEM[64] = MEM[64] + 32;\n                MEM[MEM[64]] = 0;\n                MEM[64] = MEM[64] + 32;\n                MEM[MEM[64]] = 0;\n                MEM[MEM[64]] = 0;\n                v51 = v52 = v29.length;\n                v53 = v54 = 0;\n                v55 = v56 = MEM[64];\n                if (MSIZE() >= v56) {\n                    v55 = v57 = new uint256[](v52);\n                }\n                v55 = new uint256[](v52);\n                if (v52) {\n                    v58 = v57.data;\n                    do {\n                        MEM[MEM[64]] = 0;\n                        MEM[v58] = MEM[64];\n                        v58 += 32;\n                        v51 = v51 - 1;\n                    } while (!v51);\n                }\n                v59 = v60 = 0;\n                while (v59 < v52) {\n                    assert(v59 < v29.length);\n                    assert(v59 < v55.length);\n                    v57[v59] = v33[v59];\n                    assert(v59 < v55.length);\n                    assert(23);\n                    assert(v59 < v55.length);\n                    v53 = v53 + (3 + (MEM[v57[v59]] + (MEM[v57[v59]] - 1) / 23));\n                    v59 = v59 + 1;\n                }\n                v61 = v62 = 0;\n                v63 = v64 = MEM[64];\n                if (MSIZE() >= v64) {\n                    v63 = v65 = new uint256[](v53 + 1);\n                }\n                v63 = new uint256[](v53 + 1);\n                while (1 > v61) {\n                    assert(v61 < 1);\n                    assert(v61 < v63.length);\n                    MEM8[v65.data + v61] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(128 + v52 << 248, v61)) << 248, 0x0)) & 0xFF;\n                    v61 = v61 + 1;\n                }\n                v66 = v67 = 0;\n                while (v66 < v52) {\n                    assert(v61 < v63.length);\n                    MEM8[v65.data + v61] = (byte(0x5f00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                    v68 = v61 + 1;\n                    v69 = v70 = 0;\n                    while (v66 >= v55.length) {\n                        if (v69 >= MEM[v57[v66]]) {\n                            break;\n                        }\n                        if (v69 >= MEM[v57[v66]]) {\n                            assert(v68 < v63.length);\n                            MEM8[v65.data + v68] = (byte(0xff00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                            v61 = v68 + 1;\n                            v66 = v66 + 1;\n                        }\n                        if (!(v69 % 23)) {\n                            assert(v66 < v55.length);\n                            if (MEM[v57[v66]] - v69 >= 24) {\n                                v71 = v72 = 23;\n                            } else {\n                                assert(v66 < v55.length);\n                                v71 = v73 = MEM[v57[v66]] - v69;\n                            }\n                            while (1 > v68 - v68) {\n                                assert(v68 - v68 < 1);\n                                assert(v68 < v63.length);\n                                MEM8[v65.data + v68] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(64 + v71 << 248, v68 - v68)) << 248, 0x0)) & 0xFF;\n                                v68 = v68 + 1;\n                            }\n                        }\n                        assert(v66 < v55.length);\n                        assert(v69 < MEM[v57[v66]]);\n                        assert(v68 < v63.length);\n                        MEM8[v65.data + v68] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[32 + v57[v66] + v69] >> 248 << 248, 0x0)) & 0xFF;\n                        v68 = v68 + 1;\n                        v69 = v69 + 1;\n                    }\n                    throw();\n                }\n                MEM[32 + MEM[64]] = 0;\n                v74 = new array[](v42.length);\n                v75 = v76 = v74.data;\n                v77 = v78 = v42.length;\n                v79 = v80 = v42.data;\n                if (v78 != 0) {\n                    while (1) {\n                        MEM[v75] = MEM[v79];\n                        if (v77 <= 32) {\n                            break;\n                        }\n                        v77 = v77 + ~31;\n                        v75 += 32;\n                        v79 += 32;\n                    }\n                }\n                if (0x1f & v78) {\n                    MEM[v74.data] = ~(256 ** (32 - (0x1f & v78)) - 1) & MEM[v74.data];\n                }\n                v81 = new array[](v63.length);\n                v82 = v83 = v63.length;\n                v84 = v85 = v81.data;\n                v86 = v87 = v65.data;\n                if (v83) {\n                    while (1) {\n                        MEM[v84] = MEM[v86];\n                        if (v82 <= 32) {\n                            break;\n                        }\n                        v82 = v82 + ~31;\n                        v84 += 32;\n                        v86 += 32;\n                    }\n                }\n                v88 = v89 = v83 + v85;\n                if (0x1f & v83) {\n                    MEM[v89 - (0x1f & v83)] = ~(256 ** (32 - (0x1f & v83)) - 1) & MEM[v89 - (0x1f & v83)];\n                }\n                assert(owner_1_0_19.code.size);\n                assert(v90);\n            } else {\n                v91 = v92 = 0;\n            }\n            v93 = v94 = MEM[64];\n            v95 = v96 = MEM[v11];\n            v97 = v98 = 32 + v11;\n            while (v95 >= 32) {\n                MEM[v93] = MEM[v97];\n                v95 = v95 + ~31;\n                v93 += 32;\n                v97 += 32;\n            }\n            MEM[v93] = ~0 + 256 ** (32 - v95) & MEM[v93] | MEM[v97] & ~(~0 + 256 ** (32 - v95));\n            v99, v100 = sha256hash(v101, 0, 128, v81 - (4 + MEM[64]));\n            assert(v99);\n            MEM[v102.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffff & varg2 << 192);\n            v103 = v104 = 8 + v102.data;\n            v105 = v106 = MEM[v7];\n            v107 = v108 = 32 + v7;\n            while (v105 >= 32) {\n                MEM[v103] = MEM[v107];\n                v105 = v105 + ~31;\n                v103 += 32;\n                v107 += 32;\n            }\n            MEM[v103] = ~0 + 256 ** (32 - v105) & MEM[v103] | MEM[v107] & ~(~0 + 256 ** (32 - v105));\n            MEM[v104 + v106] = v100;\n            v109 = v110 = MEM[v14];\n            v111 = v112 = 32 + (v104 + v106);\n            v113 = v114 = v14 + 32;\n            while (v109 >= 32) {\n                MEM[v111] = MEM[v113];\n                v109 = v109 + ~31;\n                v111 += 32;\n                v113 += 32;\n            }\n            MEM[v111] = MEM[v113] & ~(256 ** (32 - v109) - 1) | MEM[v111] & 256 ** (32 - v109) - 1;\n            map_3[v91] = keccak256(v102.data);\n            return v91;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1b87d58a) {\n            bonusMin();\n        } else if (0x2399f870 == v0) {\n            updateFlipAndMDT(address,uint256,address,uint256);\n        } else if (0x23d32d6a == v0) {\n            generatedBytes();\n        } else if (0x24ce2562 == v0) {\n            updateGameSpecifics(uint256,uint256,uint256,uint256);\n        } else if (0x27dc297e == v0) {\n            __callback(bytes32,string);\n        } else if (0x2d19413c == v0) {\n            setJackpotToken(address,uint256,uint256,address,uint256,uint256,uint256);\n        } else if (0x2e5b2168 == v0) {\n            maxBet();\n        } else if (0x2e6b2662 == v0) {\n            sponsoredBonusMin();\n        } else if (0x38bbfa50 == v0) {\n            __callback(bytes32,string,bytes);\n        } else if (0x3b5e5376 == v0) {\n            baseComparable();\n        } else if (0x41d4a1ab == v0) {\n            bonusToken();\n        } else if (0x4af69189 == v0) {\n            sponsoredJackpotToken();\n        } else if (0x4c6226fc == v0) {\n            oraclizeFee();\n        } else if (0x5ed65228 == v0) {\n            sponsoredJackpotMin();\n        } else if (0x600720c2 == v0) {\n            sponsoredJackpotAmount();\n        } else if (0x66476fcc == v0) {\n            flipTokenReward();\n        } else if (0x7a8bd93e == v0) {\n            flipRewardAmount();\n        } else if (0x7aba86d2 == v0) {\n            bonusMax();\n        } else if (0x80d1bd47 == v0) {\n            jackpotHit();\n        } else if (0x880cdc31 == v0) {\n            updateOwner(address);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x8ec9925e == v0) {\n            jackpotToken();\n        } else if (0x9619367d == v0) {\n            minBet();\n        } else if (0xa0109c9f == v0) {\n            incrementFee();\n        } else if (0xa10132ad == v0) {\n            callbackGas();\n        } else if (0xa7ace55d == v0) {\n            incrementDivisor();\n        } else if (0xa824e636 == v0) {\n            walletSend(address,uint256,address);\n        } else if (0xabadaf9a == v0) {\n            bonusAmount();\n        } else if (0xb1e045f7 == v0) {\n            sponsoredJackpotMax();\n        } else if (0xb1eac37e == v0) {\n            jackpotAmount();\n        } else if (0xb65b4c9a == v0) {\n            sponsoredBonusMax();\n        } else if (0xbd22b1cb == v0) {\n            millionDollarTokenReward();\n        } else if (0xc8d52ee3 == v0) {\n            refundTransfer(address,uint256);\n        } else if (0xcbd5131b == v0) {\n            sponsoredBonusAmount();\n        } else if (0xd08d6753 == v0) {\n            mdtRewardAmount();\n        } else if (0xe0f8da97 == v0) {\n            sponsoredBonusToken();\n        } else if (0xfe2b6246 == v0) {\n            updateMaxMinComparables(uint256,uint256,uint256,uint256);\n        } else if (0xff3af97f == v0) {\n            setBonusToken(address,uint256,uint256,uint256,address,uint256,uint256,uint256);\n        } else if (0xff78d5ed == v0) {\n            mdtComparable();\n        }\n    }\n    if (_owner != msg.sender) {\n        v1 = v2 = msg.value > _maxBet;\n        if (msg.value <= _maxBet) {\n            v1 = v3 = msg.value < _minBet;\n        }\n        require(!v1);\n        v4 = v5 = !stor_0_0_19;\n        if (stor_0_0_19) {\n            v4 = !stor_0_0_19.code.size;\n        }\n        if (v4) {\n            v6 = 0x1777();\n        }\n        MEM[32 + MEM[64]] = 0;\n        assert(stor_0_0_19.code.size);\n        v7, v8 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n        assert(v7);\n        owner_1_0_19 = v8;\n        assert(owner_1_0_19.code.size);\n        v9 = owner_1_0_19.setProofType(0x3000000000000000000000000000000000000000000000000000000000000000).gas(msg.gas - 710);\n        assert(v9);\n        v10 = 0xa1d(_callbackGas, 2, 0);\n        map_22[v10] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & map_22[v10];\n        map_23[v10] = msg.value;\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 07:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) map_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) map_4; // STORAGE[0x4]\nuint256 _generatedBytes; // STORAGE[0xc]\nuint256 _maxBet; // STORAGE[0xd]\nuint256 _minBet; // STORAGE[0xe]\nuint256 _oraclizeFee; // STORAGE[0xf]\nuint256 _flipRewardAmount; // STORAGE[0x10]\nuint256 _mdtRewardAmount; // STORAGE[0x11]\nuint256 _jackpotAmount; // STORAGE[0x12]\nuint256 _sponsoredJackpotAmount; // STORAGE[0x13]\nuint256 _bonusAmount; // STORAGE[0x14]\nuint256 _sponsoredBonusAmount; // STORAGE[0x15]\nuint256 _callbackGas; // STORAGE[0x16]\nuint256 _incrementFee; // STORAGE[0x17]\nuint256 _incrementDivisor; // STORAGE[0x18]\nuint256 _baseComparable; // STORAGE[0x19]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\nuint256 _jackpotHit; // STORAGE[0x1a]\nuint256 _sponsoredJackpotMin; // STORAGE[0x1b]\nuint256 _sponsoredJackpotMax; // STORAGE[0x1c]\nuint256 _bonusMin; // STORAGE[0x1d]\nuint256 _bonusMax; // STORAGE[0x1e]\nuint256 _sponsoredBonusMin; // STORAGE[0x1f]\nuint256 _sponsoredBonusMax; // STORAGE[0x20]\nuint256 _mdtComparable; // STORAGE[0x21]\nmapping (uint256 => [uint256]) map_22; // STORAGE[0x22]\nmapping (uint256 => [uint256]) map_23; // STORAGE[0x23]\naddress owner_1_0_19; // STORAGE[0x1] bytes 0 to 19\naddress _flipTokenReward; // STORAGE[0x5] bytes 0 to 19\naddress _millionDollarTokenReward; // STORAGE[0x6] bytes 0 to 19\naddress _jackpotToken; // STORAGE[0x7] bytes 0 to 19\naddress _sponsoredJackpotToken; // STORAGE[0x8] bytes 0 to 19\naddress _bonusToken; // STORAGE[0x9] bytes 0 to 19\naddress _sponsoredBonusToken; // STORAGE[0xa] bytes 0 to 19\naddress _owner; // STORAGE[0xb] bytes 0 to 19\n\n// Events\nproofFailed(address, uint256);\nnewRandomValue(bytes, address, uint256);\n\nfunction 0x1777() private { \n    if (0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed.code.size <= 0) {\n        if (0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1.code.size <= 0) {\n            if (0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e.code.size <= 0) {\n                if (0x146500cfd35b22e4a392fe0adc06de1a1368ed48.code.size <= 0) {\n                    if (0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475.code.size <= 0) {\n                        if (0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf.code.size <= 0) {\n                            if (0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa.code.size <= 0) {\n                                v0 = v1 = 0;\n                            } else {\n                                stor_0_0_19 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa;\n                                v0 = v2 = 1;\n                            }\n                        } else {\n                            stor_0_0_19 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf;\n                            v0 = v3 = 1;\n                        }\n                    } else {\n                        stor_0_0_19 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475;\n                        v0 = v4 = 1;\n                        goto 0x1ab60x1777;\n                    }\n                } else {\n                    stor_0_0_19 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48;\n                    0x2012('eth_rinkeby');\n                }\n            } else {\n                stor_0_0_19 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e;\n                0x2012('eth_kovan');\n            }\n        } else {\n            stor_0_0_19 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1;\n            0x2012('eth_ropsten3');\n        }\n    } else {\n        stor_0_0_19 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed;\n        0x2012('eth_mainnet');\n    }\n    v0 = v5 = 1;\n    return v0;\n}\n\nfunction 0x1da3() private { \n    v0 = v1 = !stor_0_0_19;\n    if (stor_0_0_19) {\n        v0 = v2 = !stor_0_0_19.code.size;\n    }\n    if (v0) {\n        v3 = 0x1777();\n    }\n    MEM[32 + MEM[64]] = 0;\n    assert(stor_0_0_19.code.size);\n    v4, v5 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n    assert(v4);\n    owner_1_0_19 = v5;\n    MEM[32 + MEM[64]] = 0;\n    assert(owner_1_0_19.code.size);\n    v6, v7 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    assert(v6);\n    return MEM[MEM[64]];\n}\n\nfunction 0x1edf(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    assert(0 < varg0.length);\n    v0 = v1 = 0x4c00000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (0x4c00000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        v0 = v2 = 0x5000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248;\n    }\n    if (!v0) {\n        assert(2 < varg0.length);\n        v0 = v3 = MEM[34 + varg0] >> 248 << 248 & 0xff00000000000000000000000000000000000000000000000000000000000000 != 0x100000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        MEM[MEM[64]] = 0;\n        v4 = new bytes[]((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1);\n        v5 = v6 = v4.data;\n        if ((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) {\n            if (31 < (array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v5] = STORAGE[v7];\n                    v7 += 1;\n                    v5 += 32;\n                } while (v6 + ((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) <= v5);\n            } else {\n                MEM[v6] = array_2.length >> 8 << 8;\n            }\n        }\n        v8 = 0x241c(v4, varg1, varg2, varg0);\n        if (v8) {\n            v9 = v10 = 0;\n        } else {\n            v9 = v11 = 2;\n        }\n    } else {\n        v9 = v12 = 1;\n    }\n    return v9;\n}\n\nfunction 0x2012(uint256 varg0) private { \n    v0 = v1 = varg0.data;\n    if (31 < varg0.length) {\n        array_2.length = 1 + (varg0.length + varg0.length);\n        if (varg0.length) {\n            while (v1 + varg0.length > v0) {\n                STORAGE[v2] = MEM[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        array_2.length = varg0.length + varg0.length | ~0xff & MEM[v1];\n    }\n    while (v3 + (31 + array_2.length >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x241c(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    assert(69 < varg3.length);\n    v0 = 102 + (MEM[varg3.data + 69] >> 248 << 248 >> 248);\n    v1 = v2 = MEM[64];\n    if (MSIZE() >= v2) {\n        v1 = v3 = new uint256[](32);\n    }\n    v1 = new uint256[](32);\n    MEM[MEM[64]] = 0;\n    require(v1.length >= 32);\n    v4 = v0 + 32;\n    v5 = 32;\n    while (v4 < 32 + v0 + 32) {\n        MEM[v5 + v1] = MEM[v4 + varg3];\n        v4 += 32;\n        v5 += 32;\n    }\n    MEM[32 + v6.data] = 0;\n    v7 = v8 = v6.data;\n    v9 = v10 = varg0.length;\n    v11 = v12 = varg0.data;\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v11 += 32;\n    }\n    MEM[v7] = ~0 + 256 ** (32 - v9) & MEM[v7] | MEM[v11] & ~(~0 + 256 ** (32 - v9));\n    MEM[v8 + v10] = varg2;\n    assert(v13);\n    v14 = v15 = v15.data;\n    v16 = v17 = v1.length;\n    v18 = v19 = v1.data;\n    while (v16 >= 32) {\n        MEM[v14] = MEM[v18];\n        v16 = v16 + ~31;\n        v14 += 32;\n        v18 += 32;\n    }\n    MEM[v14] = MEM[v14] & ~0 + 256 ** (32 - v16) | MEM[v18] & ~(~0 + 256 ** (32 - v16));\n    if (keccak256(v20.data) == keccak256(MEM[v15 len 32])) {\n        assert(v0 + 74 < varg3.length);\n        v21 = v22 = MEM[64];\n        if (MSIZE() >= v22) {\n            v21 = v23 = new uint256[](2 + (MEM[varg3.data + (v0 + 74)] >> 248 << 248 >> 248));\n        }\n        v21 = new uint256[](2 + (MEM[varg3.data + (v0 + 74)] >> 248 << 248 >> 248));\n        MEM[MEM[64]] = 0;\n        require(v21.length >= v21.length + 0);\n        v24 = 73 + v0 + 32;\n        v25 = 32;\n        while (v24 < 105 + v0 + v21.length) {\n            MEM[v25 + v21] = MEM[v24 + varg3];\n            v24 += 32;\n            v25 += 32;\n        }\n        MEM[32 + v26.data] = 0;\n        v27 = v28 = v26.data;\n        v29 = v30 = v21.length;\n        v31 = v32 = v21.data;\n        while (v29 >= 32) {\n            MEM[v27] = MEM[v31];\n            v29 = v29 + ~31;\n            v27 += 32;\n            v31 += 32;\n        }\n        MEM[v27] = ~0 + 256 ** (32 - v29) & MEM[v27] | MEM[v31] & ~(~0 + 256 ** (32 - v29));\n        v33, v34 = sha256hash(v26.data, 0);\n        assert(v33);\n        v35 = v36 = 0;\n        v37 = v38 = 1;\n        while (0xff & v35 < varg1.length) {\n            assert(0xff & v35 < varg1.length);\n            assert(0xff & v35 < 32);\n            if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(v34, 0xff & v35)) << 248 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg1.data + (0xff & v35)] >> 248 << 248) {\n                v37 = v39 = 0;\n            }\n            v35 += 1;\n        }\n        if (v37) {\n            v40 = v41 = MEM[64];\n            if (MSIZE() >= v41) {\n                v40 = v42 = new uint256[](41);\n            }\n            v40 = new uint256[](41);\n            MEM[MEM[64]] = 0;\n            require(v40.length >= 41);\n            v43 = 32 + v0 + 32;\n            v44 = 32;\n            while (v43 < 64 + v0 + 41) {\n                MEM[v44 + v40] = MEM[v43 + varg3];\n                v43 += 32;\n                v44 += 32;\n            }\n            v45 = v46 = MEM[64];\n            if (MSIZE() >= v46) {\n                v45 = v47 = new uint256[](64);\n            }\n            v45 = new uint256[](64);\n            v45 = v48 = 65 + (73 + v0 + v21.length);\n            MEM[MEM[64]] = 0;\n            require(v45.length >= 64);\n            v49 = v48 - 64 + 32;\n            v50 = 32;\n            while (v49 < 32 + (v48 - 64) + 64) {\n                MEM[v50 + v45] = MEM[v49 + varg3];\n                v49 += 32;\n                v50 += 32;\n            }\n            MEM[32 + v51.data] = 0;\n            v52 = v53 = v51.data;\n            v54 = v55 = v45.length;\n            v56 = v57 = v45.data;\n            while (v54 >= 32) {\n                MEM[v52] = MEM[v56];\n                v54 = v54 + ~31;\n                v52 += 32;\n                v56 += 32;\n            }\n            MEM[v52] = ~0 + 256 ** (32 - v54) & MEM[v52] | MEM[v56] & ~(~0 + 256 ** (32 - v54));\n            v58, v40 = sha256hash(v51.data, 0);\n            assert(v58);\n            v59 = v60 = v60.data;\n            v61 = v62 = v40.length;\n            v63 = v64 = v40.data;\n            while (v61 >= 32) {\n                MEM[v59] = MEM[v63];\n                v61 = v61 + ~31;\n                v59 += 32;\n                v63 += 32;\n            }\n            MEM[v59] = MEM[v63] & ~(256 ** (32 - v61) - 1) | MEM[v59] & 256 ** (32 - v61) - 1;\n            MEM[v62 + v60] = ~0x0 & (~0x0 & v40);\n            v65 = ~0x0 & (~0x0 & varg2);\n            if (~0x0 & map_3[v65] != ~0x0 & keccak256(v60)) {\n                v66 = v67 = 0;\n            } else {\n                map_3[varg2] = 0;\n                v21 = v68 = MEM[64];\n                if (MSIZE() >= v68) {\n                    v21 = v69 = new uint256[](73);\n                }\n                v21 = new uint256[](73);\n                MEM[MEM[64]] = 0;\n                require(v21.length >= 73);\n                v70 = v0 + 32;\n                v71 = 32;\n                while (v70 < 32 + v0 + 73) {\n                    MEM[v71 + v21] = MEM[v70 + varg3];\n                    v70 += 32;\n                    v71 += 32;\n                }\n                v72 = v73 = 10516;\n                MEM[32 + v74.data] = 0;\n                v75 = v76 = v74.data;\n                v77 = v78 = v21.length;\n                v79 = v80 = v21.data;\n                while (v77 >= 32) {\n                    MEM[v75] = MEM[v79];\n                    v77 = v77 + ~31;\n                    v75 += 32;\n                    v79 += 32;\n                }\n                MEM[v75] = ~0 + 256 ** (32 - v77) & MEM[v75] | MEM[v79] & ~(~0 + 256 ** (32 - v77));\n                v81, v82 = sha256hash(v74.data, 0);\n                assert(v81);\n                while (1) {\n                    MEM[MEM[64]] = 0;\n                    MEM[MEM[64]] = 0;\n                    v83 = v84 = MEM[64];\n                    if (MSIZE() >= v84) {\n                        v83 = new uint256[](32);\n                    }\n                    v83 = new uint256[](32);\n                    if (3 < MEM[v21]) {\n                        break;\n                    }\n                    assert(3 < MEM[v21]);\n                    MEM[MEM[64]] = 0;\n                    require(v83.length >= 32);\n                    v85 = 4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 32;\n                    v86 = 32;\n                    while (v85 < 36 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 32) {\n                        MEM[v86 + v83] = MEM[v85 + v21];\n                        v85 += 32;\n                        v86 += 32;\n                    }\n                    v87 = v88 = MEM[64];\n                    if (MSIZE() >= v88) {\n                        v87 = new uint256[](32);\n                    }\n                    v87 = new uint256[](32);\n                    assert(4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1 < MEM[v21]);\n                    v89 = 4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 + ((MEM[32 + v21 + (4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1)] >> 248 << 248 >> 248) - 32);\n                    MEM[MEM[64]] = 0;\n                    require(v87.length >= 32);\n                    v90 = v89 + 32;\n                    v91 = 32;\n                    while (v90 < 32 + v89 + 32) {\n                        MEM[v91 + v87] = MEM[v90 + v21];\n                        v90 += 32;\n                        v91 += 32;\n                    }\n                    v92, v93 = ecrecover(v82, 27, MEM[v83.data], MEM[v87.data]);\n                    v94 = v95 = MEM[64];\n                    v96 = v97 = MEM[v45];\n                    v98 = 32 + v45;\n                    while (v96 >= 32) {\n                        MEM[v94] = MEM[v98];\n                        v96 = v96 + ~31;\n                        v94 += 32;\n                        v98 += 32;\n                    }\n                    MEM[v94] = MEM[v98] & ~(256 ** (32 - v96) - 1) | MEM[v94] & 256 ** (32 - v96) - 1;\n                    if (address(keccak256(v99.data)) != address(v93)) {\n                        v100, v101 = ecrecover(v82, 28, MEM[v83.data], MEM[v87.data]);\n                        v102 = v103 = MEM[64];\n                        v104 = v105 = MEM[v45];\n                        v106 = 32 + v45;\n                        while (v104 >= 32) {\n                            MEM[v102] = MEM[v106];\n                            v104 = v104 + ~31;\n                            v102 += 32;\n                            v106 += 32;\n                        }\n                        MEM[v102] = MEM[v106] & ~(256 ** (32 - v104) - 1) | MEM[v102] & 256 ** (32 - v104) - 1;\n                        v107 = address(keccak256(v108.data)) == address(v101);\n                    } else {\n                        v107 = v109 = 1;\n                    }\n                    goto {'0x33fc0x241c', '0x29140x241c', '0x32430x241c'};\n                    if (v107) {\n                        if (!(0xff & map_4[v40])) {\n                            v110 = 0x303e(v45, varg3, 10568, v21, v40);\n                            map_4[v40] = v110 | ~0xff & map_4[v40];\n                        }\n                        v66 = 0xff & map_4[v40];\n                    } else {\n                        v66 = v111 = 0;\n                    }\n                    if (v107) {\n                        v45 = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4;\n                        v40 = v112 = MEM[64];\n                        if (MSIZE() >= v112) {\n                            v40 = new uint256[](66);\n                        }\n                        v40 = new uint256[](66);\n                        assert(0 < v40.length);\n                        v113 = v40.data;\n                        MEM8[v40.data] = (byte(0xfe00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                        MEM[MEM[64]] = 0;\n                        require(v40.length >= 66);\n                        v114 = 35;\n                        v115 = 33;\n                        while (v114 < 100) {\n                            MEM[v115 + v40] = MEM[v114 + varg0];\n                            v114 += 32;\n                            v115 += 32;\n                        }\n                        assert(69 < varg0.length);\n                        v21 = v116 = MEM[64];\n                        if (MSIZE() >= v116) {\n                            v21 = new uint256[](2 + (MEM[varg0.data + 69] >> 248 << 248 >> 248));\n                        }\n                        v21 = new uint256[](2 + (MEM[varg0.data + 69] >> 248 << 248 >> 248));\n                        MEM[MEM[64]] = 0;\n                        require(v21.length >= v21.length + 0);\n                        v117 = 100;\n                        v118 = 32;\n                        while (v117 < 100 + v21.length) {\n                            MEM[v118 + v21] = MEM[v117 + varg0];\n                            v117 += 32;\n                            v118 += 32;\n                        }\n                        v72 = v119 = 13308;\n                        MEM[32 + MEM[64]] = 0;\n                        v120 = v121 = MEM[64];\n                        v122 = v123 = v40.length;\n                        v124 = v40.data;\n                        while (v122 >= 32) {\n                            MEM[v120] = MEM[v124];\n                            v122 = v122 + ~31;\n                            v120 += 32;\n                            v124 += 32;\n                        }\n                        MEM[v120] = ~0 + 256 ** (32 - v122) & MEM[v120] | MEM[v124] & ~(~0 + 256 ** (32 - v122));\n                        v125 = sha256hash(MEM[(MEM[64]) len (v121 + v123 - MEM[64])], MEM[(MEM[64]) len 32]);\n                        assert(v125);\n                        v82 = MEM[MEM[64]];\n                    }\n                }\n            }\n        } else {\n            v66 = v126 = 0;\n        }\n    } else {\n        v66 = v127 = 0;\n    }\n    return v66;\n}\n\nfunction bonusMin() public payable { \n    assert(!msg.value);\n    return _bonusMin;\n}\n\nfunction updateFlipAndMDT(address varg0, uint256 varg1, address varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _millionDollarTokenReward = varg2;\n    _mdtRewardAmount = varg3;\n    _flipTokenReward = varg0;\n    _flipRewardAmount = varg1;\n}\n\nfunction generatedBytes() public payable { \n    assert(!msg.value);\n    return _generatedBytes;\n}\n\nfunction updateGameSpecifics(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _callbackGas = varg0;\n    _oraclizeFee = varg1;\n    _incrementFee = varg2;\n    _incrementDivisor = varg3;\n}\n\nfunction 0x303e(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    v0 = MEM[64];\n    MEM[64] = v0 + 32;\n    MEM[v0] = 0;\n    v1 = MEM[64];\n    MEM[64] = v1 + 32;\n    MEM[v1] = 0;\n    v2 = MEM[64];\n    MEM[v2] = 0;\n    v3 = 1 + varg0;\n    assert(v3 < varg1.length);\n    v2 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v2 = v5 = new uint256[](2 + (MEM[varg1.data + v3] >> 248 << 248 >> 248));\n    }\n    v2 = new uint256[](2 + (MEM[varg1.data + v3] >> 248 << 248 >> 248));\n    MEM[MEM[64]] = 0;\n    require(v2.length >= v2.length + 0);\n    v6 = varg0 + 32;\n    v7 = 32;\n    while (v6 < 32 + varg0 + v2.length) {\n        MEM[v7 + v2] = MEM[v6 + varg1];\n        v6 += 32;\n        v7 += 32;\n    }\n    v0 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v0 = v9 = new uint256[](64);\n    }\n    v0 = new uint256[](64);\n    MEM[MEM[64]] = 0;\n    require(v0.length >= 64);\n    v10 = 36;\n    v11 = 32;\n    while (v10 < 100) {\n        MEM[v11 + v0] = MEM[v10 + varg1];\n        v10 += 32;\n        v11 += 32;\n    }\n    v1 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v1 = v13 = new uint256[](98);\n    }\n    v1 = new uint256[](98);\n    assert(0 < v1.length);\n    v14 = v1.data;\n    MEM8[v1.data] = (byte(0x100000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n    v15 = varg0 - 65;\n    MEM[MEM[64]] = 0;\n    require(v1.length >= 66);\n    v16 = v15 + 32;\n    v17 = 33;\n    while (v16 < 32 + v15 + 65) {\n        MEM[v17 + v1] = MEM[v16 + varg1];\n        v16 += 32;\n        v17 += 32;\n    }\n    require(v1.length >= 98);\n    v18 = 32;\n    v19 = 98;\n    while (v18 < 64) {\n        MEM[v19 + v1] = MEM[v18 + 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c0];\n        v18 += 32;\n        v19 += 32;\n    }\n    v20 = v21 = 12867;\n    MEM[32 + v22.data] = 0;\n    v23 = v24 = v22.data;\n    v25 = v26 = v1.length;\n    v27 = v28 = v1.data;\n    while (v25 >= 32) {\n        MEM[v23] = MEM[v27];\n        v25 = v25 + ~31;\n        v23 += 32;\n        v27 += 32;\n    }\n    MEM[v23] = ~0 + 256 ** (32 - v25) & MEM[v23] | MEM[v27] & ~(~0 + 256 ** (32 - v25));\n    v29, v30 = sha256hash(v22.data, 0);\n    assert(v29);\n    while (1) {\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64]] = 0;\n        v31 = v32 = MEM[64];\n        if (MSIZE() >= v32) {\n            v31 = new uint256[](32);\n        }\n        v31 = new uint256[](32);\n        if (3 < MEM[v2]) {\n            break;\n        }\n        assert(3 < MEM[v2]);\n        MEM[MEM[64]] = 0;\n        require(v31.length >= 32);\n        v33 = 4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 32;\n        v34 = 32;\n        while (v33 < 36 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 32) {\n            MEM[v34 + v31] = MEM[v33 + v2];\n            v33 += 32;\n            v34 += 32;\n        }\n        v35 = v36 = MEM[64];\n        if (MSIZE() >= v36) {\n            v35 = new uint256[](32);\n        }\n        v35 = new uint256[](32);\n        assert(4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1 < MEM[v2]);\n        v37 = 4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 + ((MEM[32 + v2 + (4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1)] >> 248 << 248 >> 248) - 32);\n        MEM[MEM[64]] = 0;\n        require(v35.length >= 32);\n        v38 = v37 + 32;\n        v39 = 32;\n        while (v38 < 32 + v37 + 32) {\n            MEM[v39 + v35] = MEM[v38 + v2];\n            v38 += 32;\n            v39 += 32;\n        }\n        v40, v41 = ecrecover(v30, 27, MEM[v31.data], MEM[v35.data]);\n        v42 = v43 = MEM[64];\n        v44 = v45 = MEM[v0];\n        v46 = 32 + v0;\n        while (v44 >= 32) {\n            MEM[v42] = MEM[v46];\n            v44 = v44 + ~31;\n            v42 += 32;\n            v46 += 32;\n        }\n        MEM[v42] = MEM[v46] & ~(256 ** (32 - v44) - 1) | MEM[v42] & 256 ** (32 - v44) - 1;\n        if (address(keccak256(v47.data)) != address(v41)) {\n            v48, v49 = ecrecover(v30, 28, MEM[v31.data], MEM[v35.data]);\n            v50 = v51 = MEM[64];\n            v52 = v53 = MEM[v0];\n            v54 = 32 + v0;\n            while (v52 >= 32) {\n                MEM[v50] = MEM[v54];\n                v52 = v52 + ~31;\n                v50 += 32;\n                v54 += 32;\n            }\n            MEM[v50] = MEM[v54] & ~(256 ** (32 - v52) - 1) | MEM[v50] & 256 ** (32 - v52) - 1;\n            v55 = address(keccak256(v56.data)) == address(v49);\n        } else {\n            v55 = v57 = 1;\n        }\n        goto {'0x32430x303e', '0x29140x303e', '0x33fc0x303e'};\n        if (v55) {\n            if (!(0xff & map_4[v1])) {\n                v58 = 0x303e(v0, varg4, 10568, v2, v1);\n                map_4[v1] = v58 | ~0xff & map_4[v1];\n            }\n        }\n        if (v55) {\n            v0 = v59 = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4;\n            v1 = v60 = MEM[64];\n            if (MSIZE() >= v60) {\n                v1 = v61 = new uint256[](66);\n            }\n            v1 = new uint256[](66);\n            assert(0 < v1.length);\n            v62 = v61.data;\n            MEM8[v61.data] = (byte(0xfe00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n            MEM[MEM[64]] = 0;\n            require(v1.length >= 66);\n            v63 = 35;\n            v64 = 33;\n            while (v63 < 100) {\n                MEM[v64 + v1] = MEM[v63 + varg1];\n                v63 += 32;\n                v64 += 32;\n            }\n            assert(69 < varg1.length);\n            v2 = v65 = MEM[64];\n            if (MSIZE() >= v65) {\n                v2 = v66 = new uint256[](2 + (MEM[varg1.data + 69] >> 248 << 248 >> 248));\n            }\n            v2 = new uint256[](2 + (MEM[varg1.data + 69] >> 248 << 248 >> 248));\n            MEM[MEM[64]] = 0;\n            require(v2.length >= v2.length + 0);\n            v67 = 100;\n            v68 = 32;\n            while (v67 < 100 + v2.length) {\n                MEM[v68 + v2] = MEM[v67 + varg1];\n                v67 += 32;\n                v68 += 32;\n            }\n            v20 = v69 = 13308;\n            MEM[32 + MEM[64]] = 0;\n            v70 = v71 = MEM[64];\n            v72 = v73 = v1.length;\n            v74 = v61.data;\n            while (v72 >= 32) {\n                MEM[v70] = MEM[v74];\n                v72 = v72 + ~31;\n                v70 += 32;\n                v74 += 32;\n            }\n            MEM[v70] = ~0 + 256 ** (32 - v72) & MEM[v70] | MEM[v74] & ~(~0 + 256 ** (32 - v72));\n            v75 = sha256hash(MEM[(MEM[64]) len (v71 + v73 - MEM[64])], MEM[(MEM[64]) len 32]);\n            assert(v75);\n            v30 = MEM[MEM[64]];\n        } else {\n            v55 = v76 = 0;\n        }\n        return v55;\n    }\n}\n\nfunction __callback(bytes32 varg0, string varg1) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = v2 = MEM[64];\n    if (MSIZE() >= v2) {\n        v1 = v3 = new uint256[](0);\n    }\n    v1 = new uint256[](0);\n    v4 = 0x1da3();\n    require(msg.sender == address(v4));\n    v5 = 0x1edf(v1, v0, varg0);\n    v6 = v7 = 0xff & v5;\n    if (!(0xff & v5)) {\n        v6 = v8 = !v1.length;\n    }\n    if (!v6) {\n        v9 = new array[](v0.length);\n        v10 = v11 = v0.length;\n        v12 = v13 = v9.data;\n        v14 = v15 = v0.data;\n        if (v11) {\n            while (1) {\n                MEM[v12] = MEM[v14];\n                if (v10 <= 32) {\n                    break;\n                }\n                v10 = v10 + ~31;\n                v12 += 32;\n                v14 += 32;\n            }\n        }\n        v16 = v17 = v11 + v13;\n        if (0x1f & v11) {\n            MEM[v17 - (0x1f & v11)] = ~(256 ** (32 - (0x1f & v11)) - 1) & MEM[v17 - (0x1f & v11)];\n        }\n        emit newRandomValue(v9, address(map_22[varg0]), map_23[varg0]);\n        v18 = v19 = v19.data;\n        v20 = v21 = v0.length;\n        v22 = v23 = v0.data;\n        while (v20 >= 32) {\n            MEM[v18] = MEM[v22];\n            v20 = v20 + ~31;\n            v18 += 32;\n            v22 += 32;\n        }\n        MEM[v18] = MEM[v18] & ~0 + 256 ** (32 - v20) | MEM[v22] & ~(~0 + 256 ** (32 - v20));\n        assert(0x10000);\n        _generatedBytes = keccak256(v19) % 0x10000;\n        assert(_incrementDivisor);\n        if (_generatedBytes < _baseComparable) {\n            v24 = address(map_22[varg0]).call().value(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1).gas(!(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1) * 2300);\n            assert(v24);\n        }\n        v25 = v26 = _generatedBytes >= _baseComparable;\n        if (v26) {\n            v25 = v27 = _flipRewardAmount > 0;\n        }\n        if (v25) {\n            assert(_flipTokenReward.code.size);\n            v28 = _flipTokenReward.transfer(address(map_22[varg0]), map_23[varg0] / _incrementDivisor * _flipRewardAmount).gas(msg.gas - 710);\n            assert(v28);\n        }\n        v29 = v30 = _generatedBytes >= _mdtComparable;\n        if (v30) {\n            v29 = v31 = _mdtRewardAmount > 0;\n        }\n        if (v29) {\n            assert(_millionDollarTokenReward.code.size);\n            v32 = _millionDollarTokenReward.transfer(address(map_22[varg0]), _mdtRewardAmount).gas(msg.gas - 710);\n            assert(v32);\n        }\n        v33 = v34 = _generatedBytes == _jackpotHit;\n        if (v34) {\n            v33 = v35 = map_23[varg0] == _maxBet;\n        }\n        if (v33) {\n            assert(_jackpotToken.code.size);\n            v36 = _jackpotToken.transfer(address(map_22[varg0]), _jackpotAmount).gas(msg.gas - 710);\n            assert(v36);\n        }\n        v37 = v38 = _generatedBytes >= _sponsoredJackpotMin;\n        if (v38) {\n            v37 = v39 = _generatedBytes <= _sponsoredJackpotMax;\n        }\n        if (v37) {\n            assert(_sponsoredJackpotToken.code.size);\n            v40 = _sponsoredJackpotToken.transfer(address(map_22[varg0]), _sponsoredJackpotAmount).gas(msg.gas - 710);\n            assert(v40);\n        }\n        v41 = v42 = _generatedBytes >= _bonusMin;\n        if (v42) {\n            v41 = v43 = _generatedBytes <= _bonusMax;\n        }\n        if (v41) {\n            assert(_bonusToken.code.size);\n            v44 = _bonusToken.transfer(address(map_22[varg0]), _bonusAmount).gas(msg.gas - 710);\n            assert(v44);\n        }\n        v45 = v46 = _generatedBytes >= _sponsoredBonusMin;\n        if (v46) {\n            v45 = v47 = _generatedBytes <= _sponsoredBonusMax;\n        }\n        if (v45) {\n            assert(_sponsoredBonusToken.code.size);\n            v48 = _sponsoredBonusToken.transfer(address(map_22[varg0]), _sponsoredBonusAmount).gas(msg.gas - 710);\n            assert(v48);\n        }\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    } else {\n        emit proofFailed(address(map_22[varg0]), map_23[varg0]);\n        v49 = address(map_22[varg0]).call().value(map_23[varg0]).gas(2300 * !map_23[varg0]);\n        assert(v49);\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    }\n}\n\nfunction setJackpotToken(address varg0, uint256 varg1, uint256 varg2, address varg3, uint256 varg4, uint256 varg5, uint256 varg6) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _jackpotToken = varg0;\n    _jackpotAmount = varg1;\n    _jackpotHit = varg2;\n    _sponsoredJackpotToken = varg3;\n    _sponsoredJackpotAmount = varg4;\n    _sponsoredJackpotMin = varg5;\n    _sponsoredJackpotMax = varg6;\n}\n\nfunction maxBet() public payable { \n    assert(!msg.value);\n    return _maxBet;\n}\n\nfunction sponsoredBonusMin() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusMin;\n}\n\nfunction __callback(bytes32 varg0, string varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length);\n    v2 = 0x1da3();\n    require(msg.sender == address(v2));\n    v3 = 0x1edf(v1, v0, varg0);\n    v4 = v5 = 0xff & v3;\n    if (!(0xff & v3)) {\n        v4 = v6 = !v1.length;\n    }\n    if (!v4) {\n        v7 = new array[](v0.length);\n        v8 = v9 = v0.length;\n        v10 = v11 = v7.data;\n        v12 = v13 = v0.data;\n        if (v9) {\n            while (1) {\n                MEM[v10] = MEM[v12];\n                if (v8 <= 32) {\n                    break;\n                }\n                v8 = v8 + ~31;\n                v10 += 32;\n                v12 += 32;\n            }\n        }\n        v14 = v15 = v9 + v11;\n        if (0x1f & v9) {\n            MEM[v15 - (0x1f & v9)] = ~(256 ** (32 - (0x1f & v9)) - 1) & MEM[v15 - (0x1f & v9)];\n        }\n        emit newRandomValue(v7, address(map_22[varg0]), map_23[varg0]);\n        v16 = v17 = v17.data;\n        v18 = v19 = v0.length;\n        v20 = v21 = v0.data;\n        while (v18 >= 32) {\n            MEM[v16] = MEM[v20];\n            v18 = v18 + ~31;\n            v16 += 32;\n            v20 += 32;\n        }\n        MEM[v16] = MEM[v16] & ~0 + 256 ** (32 - v18) | MEM[v20] & ~(~0 + 256 ** (32 - v18));\n        assert(0x10000);\n        _generatedBytes = keccak256(v17) % 0x10000;\n        assert(_incrementDivisor);\n        if (_generatedBytes < _baseComparable) {\n            v22 = address(map_22[varg0]).call().value(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1).gas(!(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1) * 2300);\n            assert(v22);\n        }\n        v23 = v24 = _generatedBytes >= _baseComparable;\n        if (v24) {\n            v23 = v25 = _flipRewardAmount > 0;\n        }\n        if (v23) {\n            assert(_flipTokenReward.code.size);\n            v26 = _flipTokenReward.transfer(address(map_22[varg0]), map_23[varg0] / _incrementDivisor * _flipRewardAmount).gas(msg.gas - 710);\n            assert(v26);\n        }\n        v27 = v28 = _generatedBytes >= _mdtComparable;\n        if (v28) {\n            v27 = v29 = _mdtRewardAmount > 0;\n        }\n        if (v27) {\n            assert(_millionDollarTokenReward.code.size);\n            v30 = _millionDollarTokenReward.transfer(address(map_22[varg0]), _mdtRewardAmount).gas(msg.gas - 710);\n            assert(v30);\n        }\n        v31 = v32 = _generatedBytes == _jackpotHit;\n        if (v32) {\n            v31 = v33 = map_23[varg0] == _maxBet;\n        }\n        if (v31) {\n            assert(_jackpotToken.code.size);\n            v34 = _jackpotToken.transfer(address(map_22[varg0]), _jackpotAmount).gas(msg.gas - 710);\n            assert(v34);\n        }\n        v35 = v36 = _generatedBytes >= _sponsoredJackpotMin;\n        if (v36) {\n            v35 = v37 = _generatedBytes <= _sponsoredJackpotMax;\n        }\n        if (v35) {\n            assert(_sponsoredJackpotToken.code.size);\n            v38 = _sponsoredJackpotToken.transfer(address(map_22[varg0]), _sponsoredJackpotAmount).gas(msg.gas - 710);\n            assert(v38);\n        }\n        v39 = v40 = _generatedBytes >= _bonusMin;\n        if (v40) {\n            v39 = v41 = _generatedBytes <= _bonusMax;\n        }\n        if (v39) {\n            assert(_bonusToken.code.size);\n            v42 = _bonusToken.transfer(address(map_22[varg0]), _bonusAmount).gas(msg.gas - 710);\n            assert(v42);\n        }\n        v43 = v44 = _generatedBytes >= _sponsoredBonusMin;\n        if (v44) {\n            v43 = v45 = _generatedBytes <= _sponsoredBonusMax;\n        }\n        if (v43) {\n            assert(_sponsoredBonusToken.code.size);\n            v46 = _sponsoredBonusToken.transfer(address(map_22[varg0]), _sponsoredBonusAmount).gas(msg.gas - 710);\n            assert(v46);\n        }\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    } else {\n        emit proofFailed(address(map_22[varg0]), map_23[varg0]);\n        v47 = address(map_22[varg0]).call().value(map_23[varg0]).gas(2300 * !map_23[varg0]);\n        assert(v47);\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    }\n}\n\nfunction baseComparable() public payable { \n    assert(!msg.value);\n    return _baseComparable;\n}\n\nfunction bonusToken() public payable { \n    assert(!msg.value);\n    return _bonusToken;\n}\n\nfunction sponsoredJackpotToken() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotToken;\n}\n\nfunction oraclizeFee() public payable { \n    assert(!msg.value);\n    return _oraclizeFee;\n}\n\nfunction sponsoredJackpotMin() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotMin;\n}\n\nfunction sponsoredJackpotAmount() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotAmount;\n}\n\nfunction flipTokenReward() public payable { \n    assert(!msg.value);\n    return _flipTokenReward;\n}\n\nfunction flipRewardAmount() public payable { \n    assert(!msg.value);\n    return _flipRewardAmount;\n}\n\nfunction bonusMax() public payable { \n    assert(!msg.value);\n    return _bonusMax;\n}\n\nfunction jackpotHit() public payable { \n    assert(!msg.value);\n    return _jackpotHit;\n}\n\nfunction updateOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction jackpotToken() public payable { \n    assert(!msg.value);\n    return _jackpotToken;\n}\n\nfunction minBet() public payable { \n    assert(!msg.value);\n    return _minBet;\n}\n\nfunction incrementFee() public payable { \n    assert(!msg.value);\n    return _incrementFee;\n}\n\nfunction callbackGas() public payable { \n    assert(!msg.value);\n    return _callbackGas;\n}\n\nfunction incrementDivisor() public payable { \n    assert(!msg.value);\n    return _incrementDivisor;\n}\n\nfunction walletSend(address varg0, uint256 varg1, address varg2) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    assert(varg0.code.size);\n    v0 = varg0.transfer(varg2, varg1).gas(msg.gas - 710);\n    assert(v0);\n}\n\nfunction bonusAmount() public payable { \n    assert(!msg.value);\n    return _bonusAmount;\n}\n\nfunction sponsoredJackpotMax() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotMax;\n}\n\nfunction jackpotAmount() public payable { \n    assert(!msg.value);\n    return _jackpotAmount;\n}\n\nfunction sponsoredBonusMax() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusMax;\n}\n\nfunction millionDollarTokenReward() public payable { \n    assert(!msg.value);\n    return _millionDollarTokenReward;\n}\n\nfunction refundTransfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    assert(v0);\n}\n\nfunction sponsoredBonusAmount() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusAmount;\n}\n\nfunction mdtRewardAmount() public payable { \n    assert(!msg.value);\n    return _mdtRewardAmount;\n}\n\nfunction sponsoredBonusToken() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusToken;\n}\n\nfunction updateMaxMinComparables(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _maxBet = varg0;\n    _minBet = varg1;\n    _baseComparable = varg2;\n    _mdtComparable = varg3;\n}\n\nfunction setBonusToken(address varg0, uint256 varg1, uint256 varg2, uint256 varg3, address varg4, uint256 varg5, uint256 varg6, uint256 varg7) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _bonusToken = varg0;\n    _bonusAmount = varg1;\n    _bonusMin = varg2;\n    _bonusMax = varg3;\n    _sponsoredBonusToken = varg4;\n    _sponsoredBonusAmount = varg5;\n    _sponsoredBonusMin = varg6;\n    _sponsoredBonusMax = varg7;\n}\n\nfunction mdtComparable() public payable { \n    assert(!msg.value);\n    return _mdtComparable;\n}\n\nfunction 0xa1d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    MEM[64] = v1 + 96;\n    v2 = v3 = 3;\n    while (1) {\n        MEM[64] = MEM[64] + 32;\n        MEM[MEM[64]] = 0;\n        MEM[v0] = MEM[64];\n        v0 += 32;\n        v2 = v2 - 1;\n        if (v2) {\n            break;\n        }\n        if (!v2) {\n            v4 = v5 = !varg1;\n            if (varg1) {\n                v4 = v6 = varg1 > 32;\n            }\n            require(!v4);\n            v7 = v8 = MEM[64];\n            if (MSIZE() >= v8) {\n                v7 = v9 = new uint256[](1);\n            }\n            v7 = new uint256[](1);\n            assert(0 < v7.length);\n            v10 = v7.data;\n            MEM8[v7.data] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1 << 248, 0x0)) & 0xFF;\n            v11 = v12 = MEM[64];\n            if (MSIZE() >= v12) {\n                v11 = v13 = new uint256[](32);\n            }\n            v11 = new uint256[](32);\n            v14 = v15 = MEM[64];\n            if (MSIZE() >= v15) {\n                v14 = v16 = new uint256[](32);\n            }\n            v14 = new uint256[](32);\n            v17 = v18 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v17 = !stor_0_0_19.code.size;\n            }\n            if (v17) {\n                v19 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v20, v21 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v20);\n            owner_1_0_19 = v21;\n            MEM[32 + MEM[64]] = 0;\n            assert(owner_1_0_19.code.size);\n            v22, v23 = owner_1_0_19.randomDS_getSessionPubKeyHash().gas(msg.gas - 710);\n            assert(v22);\n            MEM[v11.data] = block.blockhash(block.number - 1) ^ (block.coinbase ^ block.timestamp);\n            MEM[v14.data] = MEM[MEM[64]];\n            v24 = v25 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v24 = !stor_0_0_19.code.size;\n            }\n            if (v24) {\n                v26 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v27, v28 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v27);\n            v29 = v30 = MEM[64];\n            owner_1_0_19 = v28;\n            v31 = v32 = 3;\n            if (MSIZE() >= v30) {\n                v29 = v33 = new uint256[](v32);\n            }\n            v29 = new uint256[](v32);\n            if (v32) {\n                v34 = v33.data;\n                do {\n                    MEM[MEM[64]] = 0;\n                    MEM[v34] = MEM[64];\n                    v34 += 32;\n                    v31 = v31 - 1;\n                } while (!v31);\n            }\n            assert(0 < v29.length);\n            v35 = v33.data;\n            v33[0] = v11;\n            assert(1 < v29.length);\n            v33[1] = v7;\n            assert(2 < v29.length);\n            v33[2] = v14;\n            MEM[MEM[64]] = 0;\n            v36 = v37 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v36 = !stor_0_0_19.code.size;\n            }\n            if (v36) {\n                v38 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v39, v40 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v39);\n            owner_1_0_19 = v40;\n            MEM[32 + MEM[64]] = 0;\n            v41 = new array[](v42.length);\n            v43 = v44 = v42.length;\n            v45 = v46 = v41.data;\n            v47 = v48 = v42.data;\n            if (v44) {\n                while (1) {\n                    MEM[v45] = MEM[v47];\n                    if (v43 <= 32) {\n                        break;\n                    }\n                    v43 = v43 + ~31;\n                    v45 += 32;\n                    v47 += 32;\n                }\n            }\n            if (0x1f & v44) {\n                MEM[v41.data] = ~(256 ** (32 - (0x1f & v44)) - 1) & MEM[v41.data];\n            }\n            assert(owner_1_0_19.code.size);\n            v49, v50 = owner_1_0_19.getPrice(v41, varg0).gas(msg.gas - 710);\n            assert(v49);\n            if (v50 <= varg0 * msg.gas + 0xde0b6b3a7640000) {\n                MEM[64] = MEM[64] + 32;\n                MEM[MEM[64]] = 0;\n                MEM[64] = MEM[64] + 32;\n                MEM[MEM[64]] = 0;\n                MEM[MEM[64]] = 0;\n                v51 = v52 = v29.length;\n                v53 = v54 = 0;\n                v55 = v56 = MEM[64];\n                if (MSIZE() >= v56) {\n                    v55 = v57 = new uint256[](v52);\n                }\n                v55 = new uint256[](v52);\n                if (v52) {\n                    v58 = v57.data;\n                    do {\n                        MEM[MEM[64]] = 0;\n                        MEM[v58] = MEM[64];\n                        v58 += 32;\n                        v51 = v51 - 1;\n                    } while (!v51);\n                }\n                v59 = v60 = 0;\n                while (v59 < v52) {\n                    assert(v59 < v29.length);\n                    assert(v59 < v55.length);\n                    v57[v59] = v33[v59];\n                    assert(v59 < v55.length);\n                    assert(23);\n                    assert(v59 < v55.length);\n                    v53 = v53 + (3 + (MEM[v57[v59]] + (MEM[v57[v59]] - 1) / 23));\n                    v59 = v59 + 1;\n                }\n                v61 = v62 = 0;\n                v63 = v64 = MEM[64];\n                if (MSIZE() >= v64) {\n                    v63 = v65 = new uint256[](v53 + 1);\n                }\n                v63 = new uint256[](v53 + 1);\n                while (1 > v61) {\n                    assert(v61 < 1);\n                    assert(v61 < v63.length);\n                    MEM8[v65.data + v61] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(128 + v52 << 248, v61)) << 248, 0x0)) & 0xFF;\n                    v61 = v61 + 1;\n                }\n                v66 = v67 = 0;\n                while (v66 < v52) {\n                    assert(v61 < v63.length);\n                    MEM8[v65.data + v61] = (byte(0x5f00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                    v68 = v61 + 1;\n                    v69 = v70 = 0;\n                    while (v66 >= v55.length) {\n                        if (v69 >= MEM[v57[v66]]) {\n                            break;\n                        }\n                        if (v69 >= MEM[v57[v66]]) {\n                            assert(v68 < v63.length);\n                            MEM8[v65.data + v68] = (byte(0xff00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                            v61 = v68 + 1;\n                            v66 = v66 + 1;\n                        }\n                        if (!(v69 % 23)) {\n                            assert(v66 < v55.length);\n                            if (MEM[v57[v66]] - v69 >= 24) {\n                                v71 = v72 = 23;\n                            } else {\n                                assert(v66 < v55.length);\n                                v71 = v73 = MEM[v57[v66]] - v69;\n                            }\n                            while (1 > v68 - v68) {\n                                assert(v68 - v68 < 1);\n                                assert(v68 < v63.length);\n                                MEM8[v65.data + v68] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(64 + v71 << 248, v68 - v68)) << 248, 0x0)) & 0xFF;\n                                v68 = v68 + 1;\n                            }\n                        }\n                        assert(v66 < v55.length);\n                        assert(v69 < MEM[v57[v66]]);\n                        assert(v68 < v63.length);\n                        MEM8[v65.data + v68] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[32 + v57[v66] + v69] >> 248 << 248, 0x0)) & 0xFF;\n                        v68 = v68 + 1;\n                        v69 = v69 + 1;\n                    }\n                    throw();\n                }\n                MEM[32 + MEM[64]] = 0;\n                v74 = new array[](v42.length);\n                v75 = v76 = v74.data;\n                v77 = v78 = v42.length;\n                v79 = v80 = v42.data;\n                if (v78 != 0) {\n                    while (1) {\n                        MEM[v75] = MEM[v79];\n                        if (v77 <= 32) {\n                            break;\n                        }\n                        v77 = v77 + ~31;\n                        v75 += 32;\n                        v79 += 32;\n                    }\n                }\n                if (0x1f & v78) {\n                    MEM[v74.data] = ~(256 ** (32 - (0x1f & v78)) - 1) & MEM[v74.data];\n                }\n                v81 = new array[](v63.length);\n                v82 = v83 = v63.length;\n                v84 = v85 = v81.data;\n                v86 = v87 = v65.data;\n                if (v83) {\n                    while (1) {\n                        MEM[v84] = MEM[v86];\n                        if (v82 <= 32) {\n                            break;\n                        }\n                        v82 = v82 + ~31;\n                        v84 += 32;\n                        v86 += 32;\n                    }\n                }\n                v88 = v89 = v83 + v85;\n                if (0x1f & v83) {\n                    MEM[v89 - (0x1f & v83)] = ~(256 ** (32 - (0x1f & v83)) - 1) & MEM[v89 - (0x1f & v83)];\n                }\n                assert(owner_1_0_19.code.size);\n                assert(v90);\n            } else {\n                v91 = v92 = 0;\n            }\n            v93 = v94 = MEM[64];\n            v95 = v96 = MEM[v11];\n            v97 = v98 = 32 + v11;\n            while (v95 >= 32) {\n                MEM[v93] = MEM[v97];\n                v95 = v95 + ~31;\n                v93 += 32;\n                v97 += 32;\n            }\n            MEM[v93] = ~0 + 256 ** (32 - v95) & MEM[v93] | MEM[v97] & ~(~0 + 256 ** (32 - v95));\n            v99, v100 = sha256hash(v101, 0, 128, v81 - (4 + MEM[64]));\n            assert(v99);\n            MEM[v102.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffff & varg2 << 192);\n            v103 = v104 = 8 + v102.data;\n            v105 = v106 = MEM[v7];\n            v107 = v108 = 32 + v7;\n            while (v105 >= 32) {\n                MEM[v103] = MEM[v107];\n                v105 = v105 + ~31;\n                v103 += 32;\n                v107 += 32;\n            }\n            MEM[v103] = ~0 + 256 ** (32 - v105) & MEM[v103] | MEM[v107] & ~(~0 + 256 ** (32 - v105));\n            MEM[v104 + v106] = v100;\n            v109 = v110 = MEM[v14];\n            v111 = v112 = 32 + (v104 + v106);\n            v113 = v114 = v14 + 32;\n            while (v109 >= 32) {\n                MEM[v111] = MEM[v113];\n                v109 = v109 + ~31;\n                v111 += 32;\n                v113 += 32;\n            }\n            MEM[v111] = MEM[v113] & ~(256 ** (32 - v109) - 1) | MEM[v111] & 256 ** (32 - v109) - 1;\n            map_3[v91] = keccak256(v102.data);\n            return v91;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1b87d58a) {\n            bonusMin();\n        } else if (0x2399f870 == v0) {\n            updateFlipAndMDT(address,uint256,address,uint256);\n        } else if (0x23d32d6a == v0) {\n            generatedBytes();\n        } else if (0x24ce2562 == v0) {\n            updateGameSpecifics(uint256,uint256,uint256,uint256);\n        } else if (0x27dc297e == v0) {\n            __callback(bytes32,string);\n        } else if (0x2d19413c == v0) {\n            setJackpotToken(address,uint256,uint256,address,uint256,uint256,uint256);\n        } else if (0x2e5b2168 == v0) {\n            maxBet();\n        } else if (0x2e6b2662 == v0) {\n            sponsoredBonusMin();\n        } else if (0x38bbfa50 == v0) {\n            __callback(bytes32,string,bytes);\n        } else if (0x3b5e5376 == v0) {\n            baseComparable();\n        } else if (0x41d4a1ab == v0) {\n            bonusToken();\n        } else if (0x4af69189 == v0) {\n            sponsoredJackpotToken();\n        } else if (0x4c6226fc == v0) {\n            oraclizeFee();\n        } else if (0x5ed65228 == v0) {\n            sponsoredJackpotMin();\n        } else if (0x600720c2 == v0) {\n            sponsoredJackpotAmount();\n        } else if (0x66476fcc == v0) {\n            flipTokenReward();\n        } else if (0x7a8bd93e == v0) {\n            flipRewardAmount();\n        } else if (0x7aba86d2 == v0) {\n            bonusMax();\n        } else if (0x80d1bd47 == v0) {\n            jackpotHit();\n        } else if (0x880cdc31 == v0) {\n            updateOwner(address);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x8ec9925e == v0) {\n            jackpotToken();\n        } else if (0x9619367d == v0) {\n            minBet();\n        } else if (0xa0109c9f == v0) {\n            incrementFee();\n        } else if (0xa10132ad == v0) {\n            callbackGas();\n        } else if (0xa7ace55d == v0) {\n            incrementDivisor();\n        } else if (0xa824e636 == v0) {\n            walletSend(address,uint256,address);\n        } else if (0xabadaf9a == v0) {\n            bonusAmount();\n        } else if (0xb1e045f7 == v0) {\n            sponsoredJackpotMax();\n        } else if (0xb1eac37e == v0) {\n            jackpotAmount();\n        } else if (0xb65b4c9a == v0) {\n            sponsoredBonusMax();\n        } else if (0xbd22b1cb == v0) {\n            millionDollarTokenReward();\n        } else if (0xc8d52ee3 == v0) {\n            refundTransfer(address,uint256);\n        } else if (0xcbd5131b == v0) {\n            sponsoredBonusAmount();\n        } else if (0xd08d6753 == v0) {\n            mdtRewardAmount();\n        } else if (0xe0f8da97 == v0) {\n            sponsoredBonusToken();\n        } else if (0xfe2b6246 == v0) {\n            updateMaxMinComparables(uint256,uint256,uint256,uint256);\n        } else if (0xff3af97f == v0) {\n            setBonusToken(address,uint256,uint256,uint256,address,uint256,uint256,uint256);\n        } else if (0xff78d5ed == v0) {\n            mdtComparable();\n        }\n    }\n    if (_owner != msg.sender) {\n        v1 = v2 = msg.value > _maxBet;\n        if (msg.value <= _maxBet) {\n            v1 = v3 = msg.value < _minBet;\n        }\n        require(!v1);\n        v4 = v5 = !stor_0_0_19;\n        if (stor_0_0_19) {\n            v4 = !stor_0_0_19.code.size;\n        }\n        if (v4) {\n            v6 = 0x1777();\n        }\n        MEM[32 + MEM[64]] = 0;\n        assert(stor_0_0_19.code.size);\n        v7, v8 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n        assert(v7);\n        owner_1_0_19 = v8;\n        assert(owner_1_0_19.code.size);\n        v9 = owner_1_0_19.setProofType(0x3000000000000000000000000000000000000000000000000000000000000000).gas(msg.gas - 710);\n        assert(v9);\n        v10 = 0xa1d(_callbackGas, 2, 0);\n        map_22[v10] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & map_22[v10];\n        map_23[v10] = msg.value;\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 07:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) map_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) map_4; // STORAGE[0x4]\nuint256 _generatedBytes; // STORAGE[0xc]\nuint256 _maxBet; // STORAGE[0xd]\nuint256 _minBet; // STORAGE[0xe]\nuint256 _oraclizeFee; // STORAGE[0xf]\nuint256 _flipRewardAmount; // STORAGE[0x10]\nuint256 _mdtRewardAmount; // STORAGE[0x11]\nuint256 _jackpotAmount; // STORAGE[0x12]\nuint256 _sponsoredJackpotAmount; // STORAGE[0x13]\nuint256 _bonusAmount; // STORAGE[0x14]\nuint256 _sponsoredBonusAmount; // STORAGE[0x15]\nuint256 _callbackGas; // STORAGE[0x16]\nuint256 _incrementFee; // STORAGE[0x17]\nuint256 _incrementDivisor; // STORAGE[0x18]\nuint256 _baseComparable; // STORAGE[0x19]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\nuint256 _jackpotHit; // STORAGE[0x1a]\nuint256 _sponsoredJackpotMin; // STORAGE[0x1b]\nuint256 _sponsoredJackpotMax; // STORAGE[0x1c]\nuint256 _bonusMin; // STORAGE[0x1d]\nuint256 _bonusMax; // STORAGE[0x1e]\nuint256 _sponsoredBonusMin; // STORAGE[0x1f]\nuint256 _sponsoredBonusMax; // STORAGE[0x20]\nuint256 _mdtComparable; // STORAGE[0x21]\nmapping (uint256 => [uint256]) map_22; // STORAGE[0x22]\nmapping (uint256 => [uint256]) map_23; // STORAGE[0x23]\naddress owner_1_0_19; // STORAGE[0x1] bytes 0 to 19\naddress _flipTokenReward; // STORAGE[0x5] bytes 0 to 19\naddress _millionDollarTokenReward; // STORAGE[0x6] bytes 0 to 19\naddress _jackpotToken; // STORAGE[0x7] bytes 0 to 19\naddress _sponsoredJackpotToken; // STORAGE[0x8] bytes 0 to 19\naddress _bonusToken; // STORAGE[0x9] bytes 0 to 19\naddress _sponsoredBonusToken; // STORAGE[0xa] bytes 0 to 19\naddress _owner; // STORAGE[0xb] bytes 0 to 19\n\n// Events\nproofFailed(address, uint256);\nnewRandomValue(bytes, address, uint256);\n\nfunction 0x1777() private { \n    if (0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed.code.size <= 0) {\n        if (0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1.code.size <= 0) {\n            if (0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e.code.size <= 0) {\n                if (0x146500cfd35b22e4a392fe0adc06de1a1368ed48.code.size <= 0) {\n                    if (0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475.code.size <= 0) {\n                        if (0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf.code.size <= 0) {\n                            if (0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa.code.size <= 0) {\n                                v0 = v1 = 0;\n                            } else {\n                                stor_0_0_19 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa;\n                                v0 = v2 = 1;\n                            }\n                        } else {\n                            stor_0_0_19 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf;\n                            v0 = v3 = 1;\n                        }\n                    } else {\n                        stor_0_0_19 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475;\n                        v0 = v4 = 1;\n                        goto 0x1ab60x1777;\n                    }\n                } else {\n                    stor_0_0_19 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48;\n                    0x2012('eth_rinkeby');\n                }\n            } else {\n                stor_0_0_19 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e;\n                0x2012('eth_kovan');\n            }\n        } else {\n            stor_0_0_19 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1;\n            0x2012('eth_ropsten3');\n        }\n    } else {\n        stor_0_0_19 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed;\n        0x2012('eth_mainnet');\n    }\n    v0 = v5 = 1;\n    return v0;\n}\n\nfunction 0x1da3() private { \n    v0 = v1 = !stor_0_0_19;\n    if (stor_0_0_19) {\n        v0 = v2 = !stor_0_0_19.code.size;\n    }\n    if (v0) {\n        v3 = 0x1777();\n    }\n    MEM[32 + MEM[64]] = 0;\n    assert(stor_0_0_19.code.size);\n    v4, v5 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n    assert(v4);\n    owner_1_0_19 = v5;\n    MEM[32 + MEM[64]] = 0;\n    assert(owner_1_0_19.code.size);\n    v6, v7 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    assert(v6);\n    return MEM[MEM[64]];\n}\n\nfunction 0x1edf(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    assert(0 < varg0.length);\n    v0 = v1 = 0x4c00000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (0x4c00000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        v0 = v2 = 0x5000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248;\n    }\n    if (!v0) {\n        assert(2 < varg0.length);\n        v0 = v3 = MEM[34 + varg0] >> 248 << 248 & 0xff00000000000000000000000000000000000000000000000000000000000000 != 0x100000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        MEM[MEM[64]] = 0;\n        v4 = new bytes[]((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1);\n        v5 = v6 = v4.data;\n        if ((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) {\n            if (31 < (array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v5] = STORAGE[v7];\n                    v7 += 1;\n                    v5 += 32;\n                } while (v6 + ((array_2.length & ~0 + (!(array_2.length & 0x1) << 8)) >> 1) <= v5);\n            } else {\n                MEM[v6] = array_2.length >> 8 << 8;\n            }\n        }\n        v8 = 0x241c(v4, varg1, varg2, varg0);\n        if (v8) {\n            v9 = v10 = 0;\n        } else {\n            v9 = v11 = 2;\n        }\n    } else {\n        v9 = v12 = 1;\n    }\n    return v9;\n}\n\nfunction 0x2012(uint256 varg0) private { \n    v0 = v1 = varg0.data;\n    if (31 < varg0.length) {\n        array_2.length = 1 + (varg0.length + varg0.length);\n        if (varg0.length) {\n            while (v1 + varg0.length > v0) {\n                STORAGE[v2] = MEM[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        array_2.length = varg0.length + varg0.length | ~0xff & MEM[v1];\n    }\n    while (v3 + (31 + array_2.length >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x241c(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    assert(69 < varg3.length);\n    v0 = 102 + (MEM[varg3.data + 69] >> 248 << 248 >> 248);\n    v1 = v2 = MEM[64];\n    if (MSIZE() >= v2) {\n        v1 = v3 = new uint256[](32);\n    }\n    v1 = new uint256[](32);\n    MEM[MEM[64]] = 0;\n    require(v1.length >= 32);\n    v4 = v0 + 32;\n    v5 = 32;\n    while (v4 < 32 + v0 + 32) {\n        MEM[v5 + v1] = MEM[v4 + varg3];\n        v4 += 32;\n        v5 += 32;\n    }\n    MEM[32 + v6.data] = 0;\n    v7 = v8 = v6.data;\n    v9 = v10 = varg0.length;\n    v11 = v12 = varg0.data;\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v11 += 32;\n    }\n    MEM[v7] = ~0 + 256 ** (32 - v9) & MEM[v7] | MEM[v11] & ~(~0 + 256 ** (32 - v9));\n    MEM[v8 + v10] = varg2;\n    assert(v13);\n    v14 = v15 = v15.data;\n    v16 = v17 = v1.length;\n    v18 = v19 = v1.data;\n    while (v16 >= 32) {\n        MEM[v14] = MEM[v18];\n        v16 = v16 + ~31;\n        v14 += 32;\n        v18 += 32;\n    }\n    MEM[v14] = MEM[v14] & ~0 + 256 ** (32 - v16) | MEM[v18] & ~(~0 + 256 ** (32 - v16));\n    if (keccak256(v20.data) == keccak256(MEM[v15 len 32])) {\n        assert(v0 + 74 < varg3.length);\n        v21 = v22 = MEM[64];\n        if (MSIZE() >= v22) {\n            v21 = v23 = new uint256[](2 + (MEM[varg3.data + (v0 + 74)] >> 248 << 248 >> 248));\n        }\n        v21 = new uint256[](2 + (MEM[varg3.data + (v0 + 74)] >> 248 << 248 >> 248));\n        MEM[MEM[64]] = 0;\n        require(v21.length >= v21.length + 0);\n        v24 = 73 + v0 + 32;\n        v25 = 32;\n        while (v24 < 105 + v0 + v21.length) {\n            MEM[v25 + v21] = MEM[v24 + varg3];\n            v24 += 32;\n            v25 += 32;\n        }\n        MEM[32 + v26.data] = 0;\n        v27 = v28 = v26.data;\n        v29 = v30 = v21.length;\n        v31 = v32 = v21.data;\n        while (v29 >= 32) {\n            MEM[v27] = MEM[v31];\n            v29 = v29 + ~31;\n            v27 += 32;\n            v31 += 32;\n        }\n        MEM[v27] = ~0 + 256 ** (32 - v29) & MEM[v27] | MEM[v31] & ~(~0 + 256 ** (32 - v29));\n        v33, v34 = sha256hash(v26.data, 0);\n        assert(v33);\n        v35 = v36 = 0;\n        v37 = v38 = 1;\n        while (0xff & v35 < varg1.length) {\n            assert(0xff & v35 < varg1.length);\n            assert(0xff & v35 < 32);\n            if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(v34, 0xff & v35)) << 248 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg1.data + (0xff & v35)] >> 248 << 248) {\n                v37 = v39 = 0;\n            }\n            v35 += 1;\n        }\n        if (v37) {\n            v40 = v41 = MEM[64];\n            if (MSIZE() >= v41) {\n                v40 = v42 = new uint256[](41);\n            }\n            v40 = new uint256[](41);\n            MEM[MEM[64]] = 0;\n            require(v40.length >= 41);\n            v43 = 32 + v0 + 32;\n            v44 = 32;\n            while (v43 < 64 + v0 + 41) {\n                MEM[v44 + v40] = MEM[v43 + varg3];\n                v43 += 32;\n                v44 += 32;\n            }\n            v45 = v46 = MEM[64];\n            if (MSIZE() >= v46) {\n                v45 = v47 = new uint256[](64);\n            }\n            v45 = new uint256[](64);\n            v45 = v48 = 65 + (73 + v0 + v21.length);\n            MEM[MEM[64]] = 0;\n            require(v45.length >= 64);\n            v49 = v48 - 64 + 32;\n            v50 = 32;\n            while (v49 < 32 + (v48 - 64) + 64) {\n                MEM[v50 + v45] = MEM[v49 + varg3];\n                v49 += 32;\n                v50 += 32;\n            }\n            MEM[32 + v51.data] = 0;\n            v52 = v53 = v51.data;\n            v54 = v55 = v45.length;\n            v56 = v57 = v45.data;\n            while (v54 >= 32) {\n                MEM[v52] = MEM[v56];\n                v54 = v54 + ~31;\n                v52 += 32;\n                v56 += 32;\n            }\n            MEM[v52] = ~0 + 256 ** (32 - v54) & MEM[v52] | MEM[v56] & ~(~0 + 256 ** (32 - v54));\n            v58, v40 = sha256hash(v51.data, 0);\n            assert(v58);\n            v59 = v60 = v60.data;\n            v61 = v62 = v40.length;\n            v63 = v64 = v40.data;\n            while (v61 >= 32) {\n                MEM[v59] = MEM[v63];\n                v61 = v61 + ~31;\n                v59 += 32;\n                v63 += 32;\n            }\n            MEM[v59] = MEM[v63] & ~(256 ** (32 - v61) - 1) | MEM[v59] & 256 ** (32 - v61) - 1;\n            MEM[v62 + v60] = ~0x0 & (~0x0 & v40);\n            v65 = ~0x0 & (~0x0 & varg2);\n            if (~0x0 & map_3[v65] != ~0x0 & keccak256(v60)) {\n                v66 = v67 = 0;\n            } else {\n                map_3[varg2] = 0;\n                v21 = v68 = MEM[64];\n                if (MSIZE() >= v68) {\n                    v21 = v69 = new uint256[](73);\n                }\n                v21 = new uint256[](73);\n                MEM[MEM[64]] = 0;\n                require(v21.length >= 73);\n                v70 = v0 + 32;\n                v71 = 32;\n                while (v70 < 32 + v0 + 73) {\n                    MEM[v71 + v21] = MEM[v70 + varg3];\n                    v70 += 32;\n                    v71 += 32;\n                }\n                v72 = v73 = 10516;\n                MEM[32 + v74.data] = 0;\n                v75 = v76 = v74.data;\n                v77 = v78 = v21.length;\n                v79 = v80 = v21.data;\n                while (v77 >= 32) {\n                    MEM[v75] = MEM[v79];\n                    v77 = v77 + ~31;\n                    v75 += 32;\n                    v79 += 32;\n                }\n                MEM[v75] = ~0 + 256 ** (32 - v77) & MEM[v75] | MEM[v79] & ~(~0 + 256 ** (32 - v77));\n                v81, v82 = sha256hash(v74.data, 0);\n                assert(v81);\n                while (1) {\n                    MEM[MEM[64]] = 0;\n                    MEM[MEM[64]] = 0;\n                    v83 = v84 = MEM[64];\n                    if (MSIZE() >= v84) {\n                        v83 = new uint256[](32);\n                    }\n                    v83 = new uint256[](32);\n                    if (3 < MEM[v21]) {\n                        break;\n                    }\n                    assert(3 < MEM[v21]);\n                    MEM[MEM[64]] = 0;\n                    require(v83.length >= 32);\n                    v85 = 4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 32;\n                    v86 = 32;\n                    while (v85 < 36 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 32) {\n                        MEM[v86 + v83] = MEM[v85 + v21];\n                        v85 += 32;\n                        v86 += 32;\n                    }\n                    v87 = v88 = MEM[64];\n                    if (MSIZE() >= v88) {\n                        v87 = new uint256[](32);\n                    }\n                    v87 = new uint256[](32);\n                    assert(4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1 < MEM[v21]);\n                    v89 = 4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 + ((MEM[32 + v21 + (4 + ((MEM[32 + v21 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1)] >> 248 << 248 >> 248) - 32);\n                    MEM[MEM[64]] = 0;\n                    require(v87.length >= 32);\n                    v90 = v89 + 32;\n                    v91 = 32;\n                    while (v90 < 32 + v89 + 32) {\n                        MEM[v91 + v87] = MEM[v90 + v21];\n                        v90 += 32;\n                        v91 += 32;\n                    }\n                    v92, v93 = ecrecover(v82, 27, MEM[v83.data], MEM[v87.data]);\n                    v94 = v95 = MEM[64];\n                    v96 = v97 = MEM[v45];\n                    v98 = 32 + v45;\n                    while (v96 >= 32) {\n                        MEM[v94] = MEM[v98];\n                        v96 = v96 + ~31;\n                        v94 += 32;\n                        v98 += 32;\n                    }\n                    MEM[v94] = MEM[v98] & ~(256 ** (32 - v96) - 1) | MEM[v94] & 256 ** (32 - v96) - 1;\n                    if (address(keccak256(v99.data)) != address(v93)) {\n                        v100, v101 = ecrecover(v82, 28, MEM[v83.data], MEM[v87.data]);\n                        v102 = v103 = MEM[64];\n                        v104 = v105 = MEM[v45];\n                        v106 = 32 + v45;\n                        while (v104 >= 32) {\n                            MEM[v102] = MEM[v106];\n                            v104 = v104 + ~31;\n                            v102 += 32;\n                            v106 += 32;\n                        }\n                        MEM[v102] = MEM[v106] & ~(256 ** (32 - v104) - 1) | MEM[v102] & 256 ** (32 - v104) - 1;\n                        v107 = address(keccak256(v108.data)) == address(v101);\n                    } else {\n                        v107 = v109 = 1;\n                    }\n                    goto {'0x33fc0x241c', '0x29140x241c', '0x32430x241c'};\n                    if (v107) {\n                        if (!(0xff & map_4[v40])) {\n                            v110 = 0x303e(v45, varg3, 10568, v21, v40);\n                            map_4[v40] = v110 | ~0xff & map_4[v40];\n                        }\n                        v66 = 0xff & map_4[v40];\n                    } else {\n                        v66 = v111 = 0;\n                    }\n                    if (v107) {\n                        v45 = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4;\n                        v40 = v112 = MEM[64];\n                        if (MSIZE() >= v112) {\n                            v40 = new uint256[](66);\n                        }\n                        v40 = new uint256[](66);\n                        assert(0 < v40.length);\n                        v113 = v40.data;\n                        MEM8[v40.data] = (byte(0xfe00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                        MEM[MEM[64]] = 0;\n                        require(v40.length >= 66);\n                        v114 = 35;\n                        v115 = 33;\n                        while (v114 < 100) {\n                            MEM[v115 + v40] = MEM[v114 + varg0];\n                            v114 += 32;\n                            v115 += 32;\n                        }\n                        assert(69 < varg0.length);\n                        v21 = v116 = MEM[64];\n                        if (MSIZE() >= v116) {\n                            v21 = new uint256[](2 + (MEM[varg0.data + 69] >> 248 << 248 >> 248));\n                        }\n                        v21 = new uint256[](2 + (MEM[varg0.data + 69] >> 248 << 248 >> 248));\n                        MEM[MEM[64]] = 0;\n                        require(v21.length >= v21.length + 0);\n                        v117 = 100;\n                        v118 = 32;\n                        while (v117 < 100 + v21.length) {\n                            MEM[v118 + v21] = MEM[v117 + varg0];\n                            v117 += 32;\n                            v118 += 32;\n                        }\n                        v72 = v119 = 13308;\n                        MEM[32 + MEM[64]] = 0;\n                        v120 = v121 = MEM[64];\n                        v122 = v123 = v40.length;\n                        v124 = v40.data;\n                        while (v122 >= 32) {\n                            MEM[v120] = MEM[v124];\n                            v122 = v122 + ~31;\n                            v120 += 32;\n                            v124 += 32;\n                        }\n                        MEM[v120] = ~0 + 256 ** (32 - v122) & MEM[v120] | MEM[v124] & ~(~0 + 256 ** (32 - v122));\n                        v125 = sha256hash(MEM[(MEM[64]) len (v121 + v123 - MEM[64])], MEM[(MEM[64]) len 32]);\n                        assert(v125);\n                        v82 = MEM[MEM[64]];\n                    }\n                }\n            }\n        } else {\n            v66 = v126 = 0;\n        }\n    } else {\n        v66 = v127 = 0;\n    }\n    return v66;\n}\n\nfunction bonusMin() public payable { \n    assert(!msg.value);\n    return _bonusMin;\n}\n\nfunction updateFlipAndMDT(address varg0, uint256 varg1, address varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _millionDollarTokenReward = varg2;\n    _mdtRewardAmount = varg3;\n    _flipTokenReward = varg0;\n    _flipRewardAmount = varg1;\n}\n\nfunction generatedBytes() public payable { \n    assert(!msg.value);\n    return _generatedBytes;\n}\n\nfunction updateGameSpecifics(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _callbackGas = varg0;\n    _oraclizeFee = varg1;\n    _incrementFee = varg2;\n    _incrementDivisor = varg3;\n}\n\nfunction 0x303e(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    v0 = MEM[64];\n    MEM[64] = v0 + 32;\n    MEM[v0] = 0;\n    v1 = MEM[64];\n    MEM[64] = v1 + 32;\n    MEM[v1] = 0;\n    v2 = MEM[64];\n    MEM[v2] = 0;\n    v3 = 1 + varg0;\n    assert(v3 < varg1.length);\n    v2 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v2 = v5 = new uint256[](2 + (MEM[varg1.data + v3] >> 248 << 248 >> 248));\n    }\n    v2 = new uint256[](2 + (MEM[varg1.data + v3] >> 248 << 248 >> 248));\n    MEM[MEM[64]] = 0;\n    require(v2.length >= v2.length + 0);\n    v6 = varg0 + 32;\n    v7 = 32;\n    while (v6 < 32 + varg0 + v2.length) {\n        MEM[v7 + v2] = MEM[v6 + varg1];\n        v6 += 32;\n        v7 += 32;\n    }\n    v0 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v0 = v9 = new uint256[](64);\n    }\n    v0 = new uint256[](64);\n    MEM[MEM[64]] = 0;\n    require(v0.length >= 64);\n    v10 = 36;\n    v11 = 32;\n    while (v10 < 100) {\n        MEM[v11 + v0] = MEM[v10 + varg1];\n        v10 += 32;\n        v11 += 32;\n    }\n    v1 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v1 = v13 = new uint256[](98);\n    }\n    v1 = new uint256[](98);\n    assert(0 < v1.length);\n    v14 = v1.data;\n    MEM8[v1.data] = (byte(0x100000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n    v15 = varg0 - 65;\n    MEM[MEM[64]] = 0;\n    require(v1.length >= 66);\n    v16 = v15 + 32;\n    v17 = 33;\n    while (v16 < 32 + v15 + 65) {\n        MEM[v17 + v1] = MEM[v16 + varg1];\n        v16 += 32;\n        v17 += 32;\n    }\n    require(v1.length >= 98);\n    v18 = 32;\n    v19 = 98;\n    while (v18 < 64) {\n        MEM[v19 + v1] = MEM[v18 + 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c0];\n        v18 += 32;\n        v19 += 32;\n    }\n    v20 = v21 = 12867;\n    MEM[32 + v22.data] = 0;\n    v23 = v24 = v22.data;\n    v25 = v26 = v1.length;\n    v27 = v28 = v1.data;\n    while (v25 >= 32) {\n        MEM[v23] = MEM[v27];\n        v25 = v25 + ~31;\n        v23 += 32;\n        v27 += 32;\n    }\n    MEM[v23] = ~0 + 256 ** (32 - v25) & MEM[v23] | MEM[v27] & ~(~0 + 256 ** (32 - v25));\n    v29, v30 = sha256hash(v22.data, 0);\n    assert(v29);\n    while (1) {\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64]] = 0;\n        v31 = v32 = MEM[64];\n        if (MSIZE() >= v32) {\n            v31 = new uint256[](32);\n        }\n        v31 = new uint256[](32);\n        if (3 < MEM[v2]) {\n            break;\n        }\n        assert(3 < MEM[v2]);\n        MEM[MEM[64]] = 0;\n        require(v31.length >= 32);\n        v33 = 4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 32;\n        v34 = 32;\n        while (v33 < 36 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 32) {\n            MEM[v34 + v31] = MEM[v33 + v2];\n            v33 += 32;\n            v34 += 32;\n        }\n        v35 = v36 = MEM[64];\n        if (MSIZE() >= v36) {\n            v35 = new uint256[](32);\n        }\n        v35 = new uint256[](32);\n        assert(4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1 < MEM[v2]);\n        v37 = 4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 + ((MEM[32 + v2 + (4 + ((MEM[32 + v2 + 3] >> 248 << 248 >> 248) - 32) + 34 - 1)] >> 248 << 248 >> 248) - 32);\n        MEM[MEM[64]] = 0;\n        require(v35.length >= 32);\n        v38 = v37 + 32;\n        v39 = 32;\n        while (v38 < 32 + v37 + 32) {\n            MEM[v39 + v35] = MEM[v38 + v2];\n            v38 += 32;\n            v39 += 32;\n        }\n        v40, v41 = ecrecover(v30, 27, MEM[v31.data], MEM[v35.data]);\n        v42 = v43 = MEM[64];\n        v44 = v45 = MEM[v0];\n        v46 = 32 + v0;\n        while (v44 >= 32) {\n            MEM[v42] = MEM[v46];\n            v44 = v44 + ~31;\n            v42 += 32;\n            v46 += 32;\n        }\n        MEM[v42] = MEM[v46] & ~(256 ** (32 - v44) - 1) | MEM[v42] & 256 ** (32 - v44) - 1;\n        if (address(keccak256(v47.data)) != address(v41)) {\n            v48, v49 = ecrecover(v30, 28, MEM[v31.data], MEM[v35.data]);\n            v50 = v51 = MEM[64];\n            v52 = v53 = MEM[v0];\n            v54 = 32 + v0;\n            while (v52 >= 32) {\n                MEM[v50] = MEM[v54];\n                v52 = v52 + ~31;\n                v50 += 32;\n                v54 += 32;\n            }\n            MEM[v50] = MEM[v54] & ~(256 ** (32 - v52) - 1) | MEM[v50] & 256 ** (32 - v52) - 1;\n            v55 = address(keccak256(v56.data)) == address(v49);\n        } else {\n            v55 = v57 = 1;\n        }\n        goto {'0x32430x303e', '0x29140x303e', '0x33fc0x303e'};\n        if (v55) {\n            if (!(0xff & map_4[v1])) {\n                v58 = 0x303e(v0, varg4, 10568, v2, v1);\n                map_4[v1] = v58 | ~0xff & map_4[v1];\n            }\n        }\n        if (v55) {\n            v0 = v59 = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4;\n            v1 = v60 = MEM[64];\n            if (MSIZE() >= v60) {\n                v1 = v61 = new uint256[](66);\n            }\n            v1 = new uint256[](66);\n            assert(0 < v1.length);\n            v62 = v61.data;\n            MEM8[v61.data] = (byte(0xfe00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n            MEM[MEM[64]] = 0;\n            require(v1.length >= 66);\n            v63 = 35;\n            v64 = 33;\n            while (v63 < 100) {\n                MEM[v64 + v1] = MEM[v63 + varg1];\n                v63 += 32;\n                v64 += 32;\n            }\n            assert(69 < varg1.length);\n            v2 = v65 = MEM[64];\n            if (MSIZE() >= v65) {\n                v2 = v66 = new uint256[](2 + (MEM[varg1.data + 69] >> 248 << 248 >> 248));\n            }\n            v2 = new uint256[](2 + (MEM[varg1.data + 69] >> 248 << 248 >> 248));\n            MEM[MEM[64]] = 0;\n            require(v2.length >= v2.length + 0);\n            v67 = 100;\n            v68 = 32;\n            while (v67 < 100 + v2.length) {\n                MEM[v68 + v2] = MEM[v67 + varg1];\n                v67 += 32;\n                v68 += 32;\n            }\n            v20 = v69 = 13308;\n            MEM[32 + MEM[64]] = 0;\n            v70 = v71 = MEM[64];\n            v72 = v73 = v1.length;\n            v74 = v61.data;\n            while (v72 >= 32) {\n                MEM[v70] = MEM[v74];\n                v72 = v72 + ~31;\n                v70 += 32;\n                v74 += 32;\n            }\n            MEM[v70] = ~0 + 256 ** (32 - v72) & MEM[v70] | MEM[v74] & ~(~0 + 256 ** (32 - v72));\n            v75 = sha256hash(MEM[(MEM[64]) len (v71 + v73 - MEM[64])], MEM[(MEM[64]) len 32]);\n            assert(v75);\n            v30 = MEM[MEM[64]];\n        } else {\n            v55 = v76 = 0;\n        }\n        return v55;\n    }\n}\n\nfunction __callback(bytes32 varg0, string varg1) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = v2 = MEM[64];\n    if (MSIZE() >= v2) {\n        v1 = v3 = new uint256[](0);\n    }\n    v1 = new uint256[](0);\n    v4 = 0x1da3();\n    require(msg.sender == address(v4));\n    v5 = 0x1edf(v1, v0, varg0);\n    v6 = v7 = 0xff & v5;\n    if (!(0xff & v5)) {\n        v6 = v8 = !v1.length;\n    }\n    if (!v6) {\n        v9 = new array[](v0.length);\n        v10 = v11 = v0.length;\n        v12 = v13 = v9.data;\n        v14 = v15 = v0.data;\n        if (v11) {\n            while (1) {\n                MEM[v12] = MEM[v14];\n                if (v10 <= 32) {\n                    break;\n                }\n                v10 = v10 + ~31;\n                v12 += 32;\n                v14 += 32;\n            }\n        }\n        v16 = v17 = v11 + v13;\n        if (0x1f & v11) {\n            MEM[v17 - (0x1f & v11)] = ~(256 ** (32 - (0x1f & v11)) - 1) & MEM[v17 - (0x1f & v11)];\n        }\n        emit newRandomValue(v9, address(map_22[varg0]), map_23[varg0]);\n        v18 = v19 = v19.data;\n        v20 = v21 = v0.length;\n        v22 = v23 = v0.data;\n        while (v20 >= 32) {\n            MEM[v18] = MEM[v22];\n            v20 = v20 + ~31;\n            v18 += 32;\n            v22 += 32;\n        }\n        MEM[v18] = MEM[v18] & ~0 + 256 ** (32 - v20) | MEM[v22] & ~(~0 + 256 ** (32 - v20));\n        assert(0x10000);\n        _generatedBytes = keccak256(v19) % 0x10000;\n        assert(_incrementDivisor);\n        if (_generatedBytes < _baseComparable) {\n            v24 = address(map_22[varg0]).call().value(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1).gas(!(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1) * 2300);\n            assert(v24);\n        }\n        v25 = v26 = _generatedBytes >= _baseComparable;\n        if (v26) {\n            v25 = v27 = _flipRewardAmount > 0;\n        }\n        if (v25) {\n            assert(_flipTokenReward.code.size);\n            v28 = _flipTokenReward.transfer(address(map_22[varg0]), map_23[varg0] / _incrementDivisor * _flipRewardAmount).gas(msg.gas - 710);\n            assert(v28);\n        }\n        v29 = v30 = _generatedBytes >= _mdtComparable;\n        if (v30) {\n            v29 = v31 = _mdtRewardAmount > 0;\n        }\n        if (v29) {\n            assert(_millionDollarTokenReward.code.size);\n            v32 = _millionDollarTokenReward.transfer(address(map_22[varg0]), _mdtRewardAmount).gas(msg.gas - 710);\n            assert(v32);\n        }\n        v33 = v34 = _generatedBytes == _jackpotHit;\n        if (v34) {\n            v33 = v35 = map_23[varg0] == _maxBet;\n        }\n        if (v33) {\n            assert(_jackpotToken.code.size);\n            v36 = _jackpotToken.transfer(address(map_22[varg0]), _jackpotAmount).gas(msg.gas - 710);\n            assert(v36);\n        }\n        v37 = v38 = _generatedBytes >= _sponsoredJackpotMin;\n        if (v38) {\n            v37 = v39 = _generatedBytes <= _sponsoredJackpotMax;\n        }\n        if (v37) {\n            assert(_sponsoredJackpotToken.code.size);\n            v40 = _sponsoredJackpotToken.transfer(address(map_22[varg0]), _sponsoredJackpotAmount).gas(msg.gas - 710);\n            assert(v40);\n        }\n        v41 = v42 = _generatedBytes >= _bonusMin;\n        if (v42) {\n            v41 = v43 = _generatedBytes <= _bonusMax;\n        }\n        if (v41) {\n            assert(_bonusToken.code.size);\n            v44 = _bonusToken.transfer(address(map_22[varg0]), _bonusAmount).gas(msg.gas - 710);\n            assert(v44);\n        }\n        v45 = v46 = _generatedBytes >= _sponsoredBonusMin;\n        if (v46) {\n            v45 = v47 = _generatedBytes <= _sponsoredBonusMax;\n        }\n        if (v45) {\n            assert(_sponsoredBonusToken.code.size);\n            v48 = _sponsoredBonusToken.transfer(address(map_22[varg0]), _sponsoredBonusAmount).gas(msg.gas - 710);\n            assert(v48);\n        }\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    } else {\n        emit proofFailed(address(map_22[varg0]), map_23[varg0]);\n        v49 = address(map_22[varg0]).call().value(map_23[varg0]).gas(2300 * !map_23[varg0]);\n        assert(v49);\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    }\n}\n\nfunction setJackpotToken(address varg0, uint256 varg1, uint256 varg2, address varg3, uint256 varg4, uint256 varg5, uint256 varg6) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _jackpotToken = varg0;\n    _jackpotAmount = varg1;\n    _jackpotHit = varg2;\n    _sponsoredJackpotToken = varg3;\n    _sponsoredJackpotAmount = varg4;\n    _sponsoredJackpotMin = varg5;\n    _sponsoredJackpotMax = varg6;\n}\n\nfunction maxBet() public payable { \n    assert(!msg.value);\n    return _maxBet;\n}\n\nfunction sponsoredBonusMin() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusMin;\n}\n\nfunction __callback(bytes32 varg0, string varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length);\n    v2 = 0x1da3();\n    require(msg.sender == address(v2));\n    v3 = 0x1edf(v1, v0, varg0);\n    v4 = v5 = 0xff & v3;\n    if (!(0xff & v3)) {\n        v4 = v6 = !v1.length;\n    }\n    if (!v4) {\n        v7 = new array[](v0.length);\n        v8 = v9 = v0.length;\n        v10 = v11 = v7.data;\n        v12 = v13 = v0.data;\n        if (v9) {\n            while (1) {\n                MEM[v10] = MEM[v12];\n                if (v8 <= 32) {\n                    break;\n                }\n                v8 = v8 + ~31;\n                v10 += 32;\n                v12 += 32;\n            }\n        }\n        v14 = v15 = v9 + v11;\n        if (0x1f & v9) {\n            MEM[v15 - (0x1f & v9)] = ~(256 ** (32 - (0x1f & v9)) - 1) & MEM[v15 - (0x1f & v9)];\n        }\n        emit newRandomValue(v7, address(map_22[varg0]), map_23[varg0]);\n        v16 = v17 = v17.data;\n        v18 = v19 = v0.length;\n        v20 = v21 = v0.data;\n        while (v18 >= 32) {\n            MEM[v16] = MEM[v20];\n            v18 = v18 + ~31;\n            v16 += 32;\n            v20 += 32;\n        }\n        MEM[v16] = MEM[v16] & ~0 + 256 ** (32 - v18) | MEM[v20] & ~(~0 + 256 ** (32 - v18));\n        assert(0x10000);\n        _generatedBytes = keccak256(v17) % 0x10000;\n        assert(_incrementDivisor);\n        if (_generatedBytes < _baseComparable) {\n            v22 = address(map_22[varg0]).call().value(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1).gas(!(map_23[varg0] - _oraclizeFee - (map_23[varg0] / _incrementDivisor - 3) * _incrementFee << 1) * 2300);\n            assert(v22);\n        }\n        v23 = v24 = _generatedBytes >= _baseComparable;\n        if (v24) {\n            v23 = v25 = _flipRewardAmount > 0;\n        }\n        if (v23) {\n            assert(_flipTokenReward.code.size);\n            v26 = _flipTokenReward.transfer(address(map_22[varg0]), map_23[varg0] / _incrementDivisor * _flipRewardAmount).gas(msg.gas - 710);\n            assert(v26);\n        }\n        v27 = v28 = _generatedBytes >= _mdtComparable;\n        if (v28) {\n            v27 = v29 = _mdtRewardAmount > 0;\n        }\n        if (v27) {\n            assert(_millionDollarTokenReward.code.size);\n            v30 = _millionDollarTokenReward.transfer(address(map_22[varg0]), _mdtRewardAmount).gas(msg.gas - 710);\n            assert(v30);\n        }\n        v31 = v32 = _generatedBytes == _jackpotHit;\n        if (v32) {\n            v31 = v33 = map_23[varg0] == _maxBet;\n        }\n        if (v31) {\n            assert(_jackpotToken.code.size);\n            v34 = _jackpotToken.transfer(address(map_22[varg0]), _jackpotAmount).gas(msg.gas - 710);\n            assert(v34);\n        }\n        v35 = v36 = _generatedBytes >= _sponsoredJackpotMin;\n        if (v36) {\n            v35 = v37 = _generatedBytes <= _sponsoredJackpotMax;\n        }\n        if (v35) {\n            assert(_sponsoredJackpotToken.code.size);\n            v38 = _sponsoredJackpotToken.transfer(address(map_22[varg0]), _sponsoredJackpotAmount).gas(msg.gas - 710);\n            assert(v38);\n        }\n        v39 = v40 = _generatedBytes >= _bonusMin;\n        if (v40) {\n            v39 = v41 = _generatedBytes <= _bonusMax;\n        }\n        if (v39) {\n            assert(_bonusToken.code.size);\n            v42 = _bonusToken.transfer(address(map_22[varg0]), _bonusAmount).gas(msg.gas - 710);\n            assert(v42);\n        }\n        v43 = v44 = _generatedBytes >= _sponsoredBonusMin;\n        if (v44) {\n            v43 = v45 = _generatedBytes <= _sponsoredBonusMax;\n        }\n        if (v43) {\n            assert(_sponsoredBonusToken.code.size);\n            v46 = _sponsoredBonusToken.transfer(address(map_22[varg0]), _sponsoredBonusAmount).gas(msg.gas - 710);\n            assert(v46);\n        }\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    } else {\n        emit proofFailed(address(map_22[varg0]), map_23[varg0]);\n        v47 = address(map_22[varg0]).call().value(map_23[varg0]).gas(2300 * !map_23[varg0]);\n        assert(v47);\n        map_22[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & map_22[varg0];\n        map_23[varg0] = 0;\n    }\n}\n\nfunction baseComparable() public payable { \n    assert(!msg.value);\n    return _baseComparable;\n}\n\nfunction bonusToken() public payable { \n    assert(!msg.value);\n    return _bonusToken;\n}\n\nfunction sponsoredJackpotToken() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotToken;\n}\n\nfunction oraclizeFee() public payable { \n    assert(!msg.value);\n    return _oraclizeFee;\n}\n\nfunction sponsoredJackpotMin() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotMin;\n}\n\nfunction sponsoredJackpotAmount() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotAmount;\n}\n\nfunction flipTokenReward() public payable { \n    assert(!msg.value);\n    return _flipTokenReward;\n}\n\nfunction flipRewardAmount() public payable { \n    assert(!msg.value);\n    return _flipRewardAmount;\n}\n\nfunction bonusMax() public payable { \n    assert(!msg.value);\n    return _bonusMax;\n}\n\nfunction jackpotHit() public payable { \n    assert(!msg.value);\n    return _jackpotHit;\n}\n\nfunction updateOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction jackpotToken() public payable { \n    assert(!msg.value);\n    return _jackpotToken;\n}\n\nfunction minBet() public payable { \n    assert(!msg.value);\n    return _minBet;\n}\n\nfunction incrementFee() public payable { \n    assert(!msg.value);\n    return _incrementFee;\n}\n\nfunction callbackGas() public payable { \n    assert(!msg.value);\n    return _callbackGas;\n}\n\nfunction incrementDivisor() public payable { \n    assert(!msg.value);\n    return _incrementDivisor;\n}\n\nfunction walletSend(address varg0, uint256 varg1, address varg2) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    assert(varg0.code.size);\n    v0 = varg0.transfer(varg2, varg1).gas(msg.gas - 710);\n    assert(v0);\n}\n\nfunction bonusAmount() public payable { \n    assert(!msg.value);\n    return _bonusAmount;\n}\n\nfunction sponsoredJackpotMax() public payable { \n    assert(!msg.value);\n    return _sponsoredJackpotMax;\n}\n\nfunction jackpotAmount() public payable { \n    assert(!msg.value);\n    return _jackpotAmount;\n}\n\nfunction sponsoredBonusMax() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusMax;\n}\n\nfunction millionDollarTokenReward() public payable { \n    assert(!msg.value);\n    return _millionDollarTokenReward;\n}\n\nfunction refundTransfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    assert(v0);\n}\n\nfunction sponsoredBonusAmount() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusAmount;\n}\n\nfunction mdtRewardAmount() public payable { \n    assert(!msg.value);\n    return _mdtRewardAmount;\n}\n\nfunction sponsoredBonusToken() public payable { \n    assert(!msg.value);\n    return _sponsoredBonusToken;\n}\n\nfunction updateMaxMinComparables(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _maxBet = varg0;\n    _minBet = varg1;\n    _baseComparable = varg2;\n    _mdtComparable = varg3;\n}\n\nfunction setBonusToken(address varg0, uint256 varg1, uint256 varg2, uint256 varg3, address varg4, uint256 varg5, uint256 varg6, uint256 varg7) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _bonusToken = varg0;\n    _bonusAmount = varg1;\n    _bonusMin = varg2;\n    _bonusMax = varg3;\n    _sponsoredBonusToken = varg4;\n    _sponsoredBonusAmount = varg5;\n    _sponsoredBonusMin = varg6;\n    _sponsoredBonusMax = varg7;\n}\n\nfunction mdtComparable() public payable { \n    assert(!msg.value);\n    return _mdtComparable;\n}\n\nfunction 0xa1d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    MEM[64] = v1 + 96;\n    v2 = v3 = 3;\n    while (1) {\n        MEM[64] = MEM[64] + 32;\n        MEM[MEM[64]] = 0;\n        MEM[v0] = MEM[64];\n        v0 += 32;\n        v2 = v2 - 1;\n        if (v2) {\n            break;\n        }\n        if (!v2) {\n            v4 = v5 = !varg1;\n            if (varg1) {\n                v4 = v6 = varg1 > 32;\n            }\n            require(!v4);\n            v7 = v8 = MEM[64];\n            if (MSIZE() >= v8) {\n                v7 = v9 = new uint256[](1);\n            }\n            v7 = new uint256[](1);\n            assert(0 < v7.length);\n            v10 = v7.data;\n            MEM8[v7.data] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1 << 248, 0x0)) & 0xFF;\n            v11 = v12 = MEM[64];\n            if (MSIZE() >= v12) {\n                v11 = v13 = new uint256[](32);\n            }\n            v11 = new uint256[](32);\n            v14 = v15 = MEM[64];\n            if (MSIZE() >= v15) {\n                v14 = v16 = new uint256[](32);\n            }\n            v14 = new uint256[](32);\n            v17 = v18 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v17 = !stor_0_0_19.code.size;\n            }\n            if (v17) {\n                v19 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v20, v21 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v20);\n            owner_1_0_19 = v21;\n            MEM[32 + MEM[64]] = 0;\n            assert(owner_1_0_19.code.size);\n            v22, v23 = owner_1_0_19.randomDS_getSessionPubKeyHash().gas(msg.gas - 710);\n            assert(v22);\n            MEM[v11.data] = block.blockhash(block.number - 1) ^ (block.coinbase ^ block.timestamp);\n            MEM[v14.data] = MEM[MEM[64]];\n            v24 = v25 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v24 = !stor_0_0_19.code.size;\n            }\n            if (v24) {\n                v26 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v27, v28 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v27);\n            v29 = v30 = MEM[64];\n            owner_1_0_19 = v28;\n            v31 = v32 = 3;\n            if (MSIZE() >= v30) {\n                v29 = v33 = new uint256[](v32);\n            }\n            v29 = new uint256[](v32);\n            if (v32) {\n                v34 = v33.data;\n                do {\n                    MEM[MEM[64]] = 0;\n                    MEM[v34] = MEM[64];\n                    v34 += 32;\n                    v31 = v31 - 1;\n                } while (!v31);\n            }\n            assert(0 < v29.length);\n            v35 = v33.data;\n            v33[0] = v11;\n            assert(1 < v29.length);\n            v33[1] = v7;\n            assert(2 < v29.length);\n            v33[2] = v14;\n            MEM[MEM[64]] = 0;\n            v36 = v37 = !stor_0_0_19;\n            if (stor_0_0_19) {\n                v36 = !stor_0_0_19.code.size;\n            }\n            if (v36) {\n                v38 = 0x1777();\n            }\n            MEM[32 + MEM[64]] = 0;\n            assert(stor_0_0_19.code.size);\n            v39, v40 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n            assert(v39);\n            owner_1_0_19 = v40;\n            MEM[32 + MEM[64]] = 0;\n            v41 = new array[](v42.length);\n            v43 = v44 = v42.length;\n            v45 = v46 = v41.data;\n            v47 = v48 = v42.data;\n            if (v44) {\n                while (1) {\n                    MEM[v45] = MEM[v47];\n                    if (v43 <= 32) {\n                        break;\n                    }\n                    v43 = v43 + ~31;\n                    v45 += 32;\n                    v47 += 32;\n                }\n            }\n            if (0x1f & v44) {\n                MEM[v41.data] = ~(256 ** (32 - (0x1f & v44)) - 1) & MEM[v41.data];\n            }\n            assert(owner_1_0_19.code.size);\n            v49, v50 = owner_1_0_19.getPrice(v41, varg0).gas(msg.gas - 710);\n            assert(v49);\n            if (v50 <= varg0 * msg.gas + 0xde0b6b3a7640000) {\n                MEM[64] = MEM[64] + 32;\n                MEM[MEM[64]] = 0;\n                MEM[64] = MEM[64] + 32;\n                MEM[MEM[64]] = 0;\n                MEM[MEM[64]] = 0;\n                v51 = v52 = v29.length;\n                v53 = v54 = 0;\n                v55 = v56 = MEM[64];\n                if (MSIZE() >= v56) {\n                    v55 = v57 = new uint256[](v52);\n                }\n                v55 = new uint256[](v52);\n                if (v52) {\n                    v58 = v57.data;\n                    do {\n                        MEM[MEM[64]] = 0;\n                        MEM[v58] = MEM[64];\n                        v58 += 32;\n                        v51 = v51 - 1;\n                    } while (!v51);\n                }\n                v59 = v60 = 0;\n                while (v59 < v52) {\n                    assert(v59 < v29.length);\n                    assert(v59 < v55.length);\n                    v57[v59] = v33[v59];\n                    assert(v59 < v55.length);\n                    assert(23);\n                    assert(v59 < v55.length);\n                    v53 = v53 + (3 + (MEM[v57[v59]] + (MEM[v57[v59]] - 1) / 23));\n                    v59 = v59 + 1;\n                }\n                v61 = v62 = 0;\n                v63 = v64 = MEM[64];\n                if (MSIZE() >= v64) {\n                    v63 = v65 = new uint256[](v53 + 1);\n                }\n                v63 = new uint256[](v53 + 1);\n                while (1 > v61) {\n                    assert(v61 < 1);\n                    assert(v61 < v63.length);\n                    MEM8[v65.data + v61] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(128 + v52 << 248, v61)) << 248, 0x0)) & 0xFF;\n                    v61 = v61 + 1;\n                }\n                v66 = v67 = 0;\n                while (v66 < v52) {\n                    assert(v61 < v63.length);\n                    MEM8[v65.data + v61] = (byte(0x5f00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                    v68 = v61 + 1;\n                    v69 = v70 = 0;\n                    while (v66 >= v55.length) {\n                        if (v69 >= MEM[v57[v66]]) {\n                            break;\n                        }\n                        if (v69 >= MEM[v57[v66]]) {\n                            assert(v68 < v63.length);\n                            MEM8[v65.data + v68] = (byte(0xff00000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n                            v61 = v68 + 1;\n                            v66 = v66 + 1;\n                        }\n                        if (!(v69 % 23)) {\n                            assert(v66 < v55.length);\n                            if (MEM[v57[v66]] - v69 >= 24) {\n                                v71 = v72 = 23;\n                            } else {\n                                assert(v66 < v55.length);\n                                v71 = v73 = MEM[v57[v66]] - v69;\n                            }\n                            while (1 > v68 - v68) {\n                                assert(v68 - v68 < 1);\n                                assert(v68 < v63.length);\n                                MEM8[v65.data + v68] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(64 + v71 << 248, v68 - v68)) << 248, 0x0)) & 0xFF;\n                                v68 = v68 + 1;\n                            }\n                        }\n                        assert(v66 < v55.length);\n                        assert(v69 < MEM[v57[v66]]);\n                        assert(v68 < v63.length);\n                        MEM8[v65.data + v68] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[32 + v57[v66] + v69] >> 248 << 248, 0x0)) & 0xFF;\n                        v68 = v68 + 1;\n                        v69 = v69 + 1;\n                    }\n                    throw();\n                }\n                MEM[32 + MEM[64]] = 0;\n                v74 = new array[](v42.length);\n                v75 = v76 = v74.data;\n                v77 = v78 = v42.length;\n                v79 = v80 = v42.data;\n                if (v78 != 0) {\n                    while (1) {\n                        MEM[v75] = MEM[v79];\n                        if (v77 <= 32) {\n                            break;\n                        }\n                        v77 = v77 + ~31;\n                        v75 += 32;\n                        v79 += 32;\n                    }\n                }\n                if (0x1f & v78) {\n                    MEM[v74.data] = ~(256 ** (32 - (0x1f & v78)) - 1) & MEM[v74.data];\n                }\n                v81 = new array[](v63.length);\n                v82 = v83 = v63.length;\n                v84 = v85 = v81.data;\n                v86 = v87 = v65.data;\n                if (v83) {\n                    while (1) {\n                        MEM[v84] = MEM[v86];\n                        if (v82 <= 32) {\n                            break;\n                        }\n                        v82 = v82 + ~31;\n                        v84 += 32;\n                        v86 += 32;\n                    }\n                }\n                v88 = v89 = v83 + v85;\n                if (0x1f & v83) {\n                    MEM[v89 - (0x1f & v83)] = ~(256 ** (32 - (0x1f & v83)) - 1) & MEM[v89 - (0x1f & v83)];\n                }\n                assert(owner_1_0_19.code.size);\n                assert(v90);\n            } else {\n                v91 = v92 = 0;\n            }\n            v93 = v94 = MEM[64];\n            v95 = v96 = MEM[v11];\n            v97 = v98 = 32 + v11;\n            while (v95 >= 32) {\n                MEM[v93] = MEM[v97];\n                v95 = v95 + ~31;\n                v93 += 32;\n                v97 += 32;\n            }\n            MEM[v93] = ~0 + 256 ** (32 - v95) & MEM[v93] | MEM[v97] & ~(~0 + 256 ** (32 - v95));\n            v99, v100 = sha256hash(v101, 0, 128, v81 - (4 + MEM[64]));\n            assert(v99);\n            MEM[v102.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffff & varg2 << 192);\n            v103 = v104 = 8 + v102.data;\n            v105 = v106 = MEM[v7];\n            v107 = v108 = 32 + v7;\n            while (v105 >= 32) {\n                MEM[v103] = MEM[v107];\n                v105 = v105 + ~31;\n                v103 += 32;\n                v107 += 32;\n            }\n            MEM[v103] = ~0 + 256 ** (32 - v105) & MEM[v103] | MEM[v107] & ~(~0 + 256 ** (32 - v105));\n            MEM[v104 + v106] = v100;\n            v109 = v110 = MEM[v14];\n            v111 = v112 = 32 + (v104 + v106);\n            v113 = v114 = v14 + 32;\n            while (v109 >= 32) {\n                MEM[v111] = MEM[v113];\n                v109 = v109 + ~31;\n                v111 += 32;\n                v113 += 32;\n            }\n            MEM[v111] = MEM[v113] & ~(256 ** (32 - v109) - 1) | MEM[v111] & 256 ** (32 - v109) - 1;\n            map_3[v91] = keccak256(v102.data);\n            return v91;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1b87d58a) {\n            bonusMin();\n        } else if (0x2399f870 == v0) {\n            updateFlipAndMDT(address,uint256,address,uint256);\n        } else if (0x23d32d6a == v0) {\n            generatedBytes();\n        } else if (0x24ce2562 == v0) {\n            updateGameSpecifics(uint256,uint256,uint256,uint256);\n        } else if (0x27dc297e == v0) {\n            __callback(bytes32,string);\n        } else if (0x2d19413c == v0) {\n            setJackpotToken(address,uint256,uint256,address,uint256,uint256,uint256);\n        } else if (0x2e5b2168 == v0) {\n            maxBet();\n        } else if (0x2e6b2662 == v0) {\n            sponsoredBonusMin();\n        } else if (0x38bbfa50 == v0) {\n            __callback(bytes32,string,bytes);\n        } else if (0x3b5e5376 == v0) {\n            baseComparable();\n        } else if (0x41d4a1ab == v0) {\n            bonusToken();\n        } else if (0x4af69189 == v0) {\n            sponsoredJackpotToken();\n        } else if (0x4c6226fc == v0) {\n            oraclizeFee();\n        } else if (0x5ed65228 == v0) {\n            sponsoredJackpotMin();\n        } else if (0x600720c2 == v0) {\n            sponsoredJackpotAmount();\n        } else if (0x66476fcc == v0) {\n            flipTokenReward();\n        } else if (0x7a8bd93e == v0) {\n            flipRewardAmount();\n        } else if (0x7aba86d2 == v0) {\n            bonusMax();\n        } else if (0x80d1bd47 == v0) {\n            jackpotHit();\n        } else if (0x880cdc31 == v0) {\n            updateOwner(address);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x8ec9925e == v0) {\n            jackpotToken();\n        } else if (0x9619367d == v0) {\n            minBet();\n        } else if (0xa0109c9f == v0) {\n            incrementFee();\n        } else if (0xa10132ad == v0) {\n            callbackGas();\n        } else if (0xa7ace55d == v0) {\n            incrementDivisor();\n        } else if (0xa824e636 == v0) {\n            walletSend(address,uint256,address);\n        } else if (0xabadaf9a == v0) {\n            bonusAmount();\n        } else if (0xb1e045f7 == v0) {\n            sponsoredJackpotMax();\n        } else if (0xb1eac37e == v0) {\n            jackpotAmount();\n        } else if (0xb65b4c9a == v0) {\n            sponsoredBonusMax();\n        } else if (0xbd22b1cb == v0) {\n            millionDollarTokenReward();\n        } else if (0xc8d52ee3 == v0) {\n            refundTransfer(address,uint256);\n        } else if (0xcbd5131b == v0) {\n            sponsoredBonusAmount();\n        } else if (0xd08d6753 == v0) {\n            mdtRewardAmount();\n        } else if (0xe0f8da97 == v0) {\n            sponsoredBonusToken();\n        } else if (0xfe2b6246 == v0) {\n            updateMaxMinComparables(uint256,uint256,uint256,uint256);\n        } else if (0xff3af97f == v0) {\n            setBonusToken(address,uint256,uint256,uint256,address,uint256,uint256,uint256);\n        } else if (0xff78d5ed == v0) {\n            mdtComparable();\n        }\n    }\n    if (_owner != msg.sender) {\n        v1 = v2 = msg.value > _maxBet;\n        if (msg.value <= _maxBet) {\n            v1 = v3 = msg.value < _minBet;\n        }\n        require(!v1);\n        v4 = v5 = !stor_0_0_19;\n        if (stor_0_0_19) {\n            v4 = !stor_0_0_19.code.size;\n        }\n        if (v4) {\n            v6 = 0x1777();\n        }\n        MEM[32 + MEM[64]] = 0;\n        assert(stor_0_0_19.code.size);\n        v7, v8 = stor_0_0_19.getAddress().gas(msg.gas - 710);\n        assert(v7);\n        owner_1_0_19 = v8;\n        assert(owner_1_0_19.code.size);\n        v9 = owner_1_0_19.setProofType(0x3000000000000000000000000000000000000000000000000000000000000000).gas(msg.gas - 710);\n        assert(v9);\n        v10 = 0xa1d(_callbackGas, 2, 0);\n        map_22[v10] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & map_22[v10];\n        map_23[v10] = msg.value;\n    }\n}\n.",
	"status": "1",
	"time_cost": 117.99603962898254,
	"usage": {
		"completion_tokens": 1632,
		"prompt_tokens": 17480,
		"total_tokens": 19112
	}
}