{
	"address": "0x7463c891a2b5b832f4a60dde07c8a3511a72d1b9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract that corresponds to the given decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _totalSupply = 0;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0));\n        require(_balances[msg.sender] >= amount);\n\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0));\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0));\n        require(recipient != address(0));\n        require(_balances[sender] >= amount);\n        require(_allowances[sender][msg.sender] >= amount);\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowances[msg.sender][spender] += addedValue;\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowances[msg.sender][spender] -= subtractedValue;\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n        return true;\n    }\n\n    function mint(address account, uint256 amount) public {\n        require(account != address(0));\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        require(account != address(0));\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n}\n```\n\nPlease note that the above contract is a basic implementation of the ERC20 token standard. Some parts of the decompiled code are not represented in the Solidity contract as they are not part of the standard ERC20 implementation.",
				"role": "assistant"
			}
		}
	],
	"created": 1701486177,
	"id": "chatcmpl-8RAZNRZfUQ5OgiNWTNgTZC2JisrQl",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 22:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _dOMAIN_SEPARATOR; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _nonces; // STORAGE[0x4]\nuint256 _getReserves; // STORAGE[0x8]\nuint256 _price0CumulativeLast; // STORAGE[0x9]\nuint256 _price1CumulativeLast; // STORAGE[0xa]\nuint256 _kLast; // STORAGE[0xb]\nuint256 _sync; // STORAGE[0xc]\nuint256 _factory; // STORAGE[0x5] bytes 0 to 19\nuint256 _token0; // STORAGE[0x6] bytes 0 to 19\nuint256 _token1; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nSwap(address, uint256, uint256, uint256, uint256, address);\nMint(address, uint256, uint256);\nBurn(address, uint256, uint256, address);\nSync(uint112, uint112);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction swap(uint256 varg0, uint256 varg1, address varg2, bytes varg3) public payable { \n    v0 = v1 = 11612;\n    require(msg.data.length - 4 >= 128);\n    v0 = v2 = varg2;\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    v0 = v3 = varg3.length;\n    v0 = v4 = 36 + varg3;\n    require(!((v3 > 0x100000000) | (v4 + v3 > 4 + (msg.data.length - 4))));\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    v5 = v6 = varg0;\n    if (!varg0) {\n        v5 = v7 = varg1 > 0;\n    }\n    require(v5, Error('UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT'));\n    v0 = v8 = _getReserves & 0xffffffffffffffffffffffffffff;\n    v0 = v9 = 0xffffffffffffffffffffffffffff & _getReserves >> 112;\n    v10 = v11 = varg0 < 0xffffffffffffffffffffffffffff & v8;\n    if (v11) {\n        v10 = v12 = varg1 < 0xffffffffffffffffffffffffffff & v9;\n    }\n    require(v10, Error('UniswapV2: INSUFFICIENT_LIQUIDITY'));\n    v13 = v14 = _token0 != address(v2);\n    if (_token0 != address(v2)) {\n        v13 = v15 = address(v2) != _token1;\n    }\n    require(v13, Error('UniswapV2: INVALID_TO'));\n    if (varg0) {\n        0x1fdb(varg0, v2, _token0);\n    }\n    if (varg1) {\n        0x1fdb(varg1, v2, _token1);\n    }\n    if (v3) {\n        v16[v3] = 0;\n        require((address(v2)).code.size);\n        v17 = address(v2).uniswapV2Call(msg.sender, varg0, varg1, 132 + MEM[64]).gas(msg.gas);\n        require(v17); // checks call status, propagates error data on error\n    }\n    require(_token0.code.size);\n    v18, v0 = _token0.balanceOf(this).gas(msg.gas);\n    require(v18); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v19, v0 = _token1.balanceOf(this).gas(msg.gas);\n    require(v19); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v0 > (v8 & 0xffffffffffffffffffffffffffff) - varg0) {\n        v0 = v20 = v0 - ((0xffffffffffffffffffffffffffff & v8) - varg0);\n    } else {\n        v0 = v21 = 0;\n    }\n    if (v0 > (0xffffffffffffffffffffffffffff & v9) - varg1) {\n        v0 = v22 = v0 - ((0xffffffffffffffffffffffffffff & v9) - varg1);\n    } else {\n        v0 = v23 = 0;\n    }\n    v24 = v25 = v0 > 0;\n    if (v0 <= 0) {\n        v24 = v26 = v0 > 0;\n    }\n    require(v24, Error('UniswapV2: INSUFFICIENT_INPUT_AMOUNT', v27, v27, 128));\n    v28 = v29 = 3081;\n    v30 = v31 = 0x21e8(3, v0);\n    while (1) {\n        v32 = 0x21e8(1000, v0);\n        v0 = _SafeSub(v30, v32);\n        v28 = v33 = 3105;\n        v30 = 0x21e8(3, v0);\n    }\n    v34 = 0x21e8(v0 & 0xffffffffffffffffffffffffffff, 0xffffffffffffffffffffffffffff & v0);\n    v35 = 0x21e8(0xf4240, v34);\n    v36 = 0x21e8(v0, v0);\n    require(v36 >= v35, Error('UniswapV2: K'));\n    0x22e0(v0, v0, v0, v0);\n    emit Swap(msg.sender, address(v0), v0, v0, v0, v0);\n    _sync = 1;\n}\n\nfunction 0x1fdb(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg1);\n    MEM[64] = MEM[64] + 100;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v6, v7, v8 = address(varg2).transfer(0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v0, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    if (v6) {\n        v6 = v11 = !MEM[v9];\n        if (MEM[v9]) {\n            require(MEM[v9] >= 32);\n            v6 = v12 = MEM[32 + v9];\n        }\n    }\n    require(v6, Error('UniswapV2: TRANSFER_FAILED'));\n    return ;\n}\n\nfunction 0x21e8(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = !varg0;\n    if (varg0) {\n        v0 = v4 = varg1 * varg0;\n        assert(varg0);\n        v2 = v5 = v4 / varg0 == varg1;\n    }\n    require(v2, Error('ds-math-mul-overflow'));\n    return v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 - varg0;\n    require(v0 <= varg1, Error('ds-math-sub-underflow'));\n    return v0;\n}\n\nfunction 0x22e0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = varg3 > 0xffffffffffffffffffffffffffff;\n    v1 = v2 = varg3 <= 0xffffffffffffffffffffffffffff;\n    if (varg3 <= 0xffffffffffffffffffffffffffff) {\n        v1 = varg2 <= 0xffffffffffffffffffffffffffff;\n    }\n    require(v1, Error('UniswapV2: OVERFLOW'));\n    v3 = uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    if (uint32(uint32(block.timestamp) - uint32(_getReserves >> 224))) {\n        v3 = v4 = varg1 & 0xffffffffffffffffffffffffffff;\n    }\n    if (v3) {\n        v3 = v5 = varg0 & 0xffffffffffffffffffffffffffff;\n    }\n    if (v3) {\n        v6 = varg1 & 0xffffffffffffffffffffffffffff;\n        assert(v6);\n        _price0CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg0) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / v6) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n        v7 = varg0 & 0xffffffffffffffffffffffffffff;\n        assert(v7);\n        _price1CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg1) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / v7) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    }\n    v8 = uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & varg2) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg3 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves));\n    _getReserves = v8;\n    emit Sync(0xffffffffffffffffffffffffffff & v8, 0xffffffffffffffffffffffffffff & v8 >> 112);\n    return ;\n}\n\nfunction name() public payable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'Uniswap V2';\n    }\n    return v0;\n}\n\nfunction 0x260b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = _SafeSub(varg0, _balanceOf[v0]);\n    v2 = address(varg2);\n    _balanceOf[v2] = v1;\n    v3 = address(varg1);\n    v4 = _balanceOf[v3] + varg0;\n    require(v4 >= _balanceOf[v3], Error('ds-math-add-overflow'));\n    v5 = address(varg1);\n    _balanceOf[v5] = v4;\n    emit Transfer(address(varg2), v5, varg0);\n    return ;\n}\n\nfunction 0x26ec(uint256 varg0, uint256 varg1) private { \n    require(_factory.code.size);\n    v0, v1 = _factory.feeTo().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!address(v1)) {\n        if (!_kLast) {\n            return address(v1);\n        } else {\n            _kLast = 0;\n            return address(v1);\n        }\n    } else {\n        if (_kLast) {\n            v2 = 0x21e8(varg0 & 0xffffffffffffffffffffffffffff, 0xffffffffffffffffffffffffffff & varg1);\n            v3 = 0x2878(v2);\n            v4 = 0x2878(_kLast);\n            if (v3 > v4) {\n                v5 = _SafeSub(v4, v3);\n                v6 = 0x21e8(v5, _totalSupply);\n                v7 = 0x21e8(5, v3);\n                require(v7 + v4 >= v7, Error('ds-math-add-overflow'));\n                assert(v7 + v4);\n                if (v6 / (v7 + v4)) {\n                    0x28ca(v6 / (v7 + v4), v1);\n                }\n            }\n        }\n        return address(v1);\n    }\n}\n\nfunction 0x2878(uint256 varg0) private { \n    if (varg0 <= 3) {\n        if (!varg0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else {\n        varg0 = v0 = (varg0 >> 1) + 1;\n        while (varg0 < varg0) {\n            assert(varg0);\n            assert(2);\n            varg0 = varg0 / varg0 + varg0 >> 1;\n        }\n        return varg0;\n    }\n}\n\nfunction 0x28ca(uint256 varg0, uint256 varg1) private { \n    v0 = _totalSupply + varg0;\n    require(v0 >= _totalSupply, Error('ds-math-add-overflow'));\n    _totalSupply = v0;\n    v1 = address(varg1);\n    v2 = _balanceOf[v1] + varg0;\n    require(v2 >= _balanceOf[v1], Error('ds-math-add-overflow'));\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(0, v3, varg0);\n    return ;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction getReserves() public payable { \n    return 0xffffffffffffffffffffffffffff & (_getReserves & 0xffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & _getReserves >> 112), uint32(_getReserves >> 224);\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction token0() public payable { \n    return _token0;\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    if (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != _allowance[msg.sender]) {\n        v0 = _SafeSub(varg2, _allowance[msg.sender]);\n        _allowance[msg.sender] = v0;\n    }\n    0x260b(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction PERMIT_TYPEHASH() public payable { \n    return 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n}\n\nfunction decimals() public payable { \n    return 18;\n}\n\nfunction DOMAIN_SEPARATOR() public payable { \n    return _dOMAIN_SEPARATOR;\n}\n\nfunction initialize(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _factory, Error('UniswapV2: FORBIDDEN'));\n    _token0 = varg0;\n    _token1 = varg1;\n}\n\nfunction price0CumulativeLast() public payable { \n    return _price0CumulativeLast;\n}\n\nfunction price1CumulativeLast() public payable { \n    return _price1CumulativeLast;\n}\n\nfunction mint(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = _SafeSub(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff, v1);\n    v5 = _SafeSub(0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff, v3);\n    v6 = 0x26ec(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff);\n    if (_totalSupply) {\n        v7 = 0x21e8(_totalSupply, v4);\n        assert(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        v8 = v9 = v7 / (_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        v10 = 0x21e8(_totalSupply, v5);\n        assert(0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff);\n        v8 = v11 = v10 / (0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff);\n        if (v9 >= v11) {\n        }\n    } else {\n        v12 = 0x21e8(v5, v4);\n        v13 = 0x2878(v12);\n        v8 = v14 = _SafeSub(1000, v13);\n        0x28ca(1000, 0);\n    }\n    require(v8 > 0, Error('UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED'));\n    0x28ca(v8, varg0);\n    0x22e0(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff, v3, v1);\n    if (v6) {\n        v15 = 0x21e8(_getReserves >> 112 & 0xffffffffffffffffffffffffffff, _getReserves & 0xffffffffffffffffffffffffffff);\n        _kLast = v15;\n    }\n    emit Mint(msg.sender, v4, v5);\n    _sync = 1;\n    return v8;\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction kLast() public payable { \n    return _kLast;\n}\n\nfunction nonces(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _nonces[varg0];\n}\n\nfunction burn(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = 0x26ec(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff);\n    v5 = 0x21e8(v1, _balanceOf[this]);\n    assert(_totalSupply);\n    v6 = 0x21e8(v3, _balanceOf[this]);\n    assert(_totalSupply);\n    v7 = v8 = v5 / _totalSupply > 0;\n    if (v8) {\n        v7 = v9 = v6 / _totalSupply > 0;\n    }\n    require(v7, Error('UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED'));\n    v10 = _SafeSub(_balanceOf[this], _balanceOf[address(this)]);\n    _balanceOf[address(this)] = v10;\n    v11 = _SafeSub(_balanceOf[this], _totalSupply);\n    _totalSupply = v11;\n    emit Transfer(address(this), 0, _balanceOf[this]);\n    0x1fdb(v5 / _totalSupply, varg0, _token0);\n    0x1fdb(v6 / _totalSupply, varg0, _token1);\n    require(_token0.code.size);\n    v12, v13 = _token0.balanceOf(this).gas(msg.gas);\n    require(v12); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v14, v15 = _token1.balanceOf(this).gas(msg.gas);\n    require(v14); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    0x22e0(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff, v15, v13);\n    if (v4) {\n        v16 = 0x21e8(_getReserves >> 112 & 0xffffffffffffffffffffffffffff, _getReserves & 0xffffffffffffffffffffffffffff);\n        _kLast = v16;\n    }\n    emit Burn(msg.sender, varg0, v5 / _totalSupply, v6 / _totalSupply);\n    _sync = 1;\n    return v5 / _totalSupply, v6 / _totalSupply;\n}\n\nfunction symbol() public payable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'UNI-V2';\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x260b(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction MINIMUM_LIQUIDITY() public payable { \n    return 1000;\n}\n\nfunction skim(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[MEM[64] + 4] = this;\n    v0 = v1 = MEM[64];\n    v2 = v3 = _token0;\n    v2 = v4 = _token1;\n    v5 = v6 = 6699;\n    v7 = v8 = 12807;\n    v9 = v10 = 0xffffffffffffffffffffffffffff & _getReserves;\n    v11 = v12 = 32;\n    v13 = v14 = 36;\n    require(v3.code.size);\n    while (1) {\n        v15 = v2.staticcall(MEM[v0 len v13], MEM[v0 len v11]).gas(msg.gas);\n        if (v15) {\n            break;\n        }\n        v16 = 'transfer(address,uint256)';\n        if (RETURNDATASIZE() >= 32) {\n            break;\n        }\n        require(RETURNDATASIZE() >= 32);\n        if (v16.length - v9 <= v16.length) {\n            break;\n        }\n        require(v16.length - v9 <= v16.length, Error('ds-math-sub-underflow'));\n        goto {'0x3207', '0x322b'};\n        MEM[64] = MEM[64] + 100;\n        v17 = MEM[64] + 32;\n        v18 = MEM[64];\n        while (v19 >= 32) {\n            MEM[v18] = MEM[v17];\n            v19 = v19 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0;\n            v18 += 32;\n            v17 += 32;\n        }\n        MEM[v18] = MEM[v17] & ~(256 ** (32 - v19) - 1) | MEM[v18] & 256 ** (32 - v19) - 1;\n        v20, v21, v22 = address(v2).transfer(varg0, v16.length - v9).gas(msg.gas);\n        if (RETURNDATASIZE() == 0) {\n            v23 = v24 = 96;\n        } else {\n            v23 = new bytes[](RETURNDATASIZE());\n            RETURNDATACOPY(v23.data, 0, RETURNDATASIZE());\n        }\n        if (v20) {\n            v20 = v25 = !MEM[v23];\n            if (MEM[v23]) {\n                require(MEM[v23] >= 32);\n                v20 = v26 = MEM[32 + v23];\n            }\n        }\n        require(v20, Error('UniswapV2: TRANSFER_FAILED'));\n        goto {'0x1a2b', '0x1aca'};\n        v27 = new bytes[](RETURNDATASIZE());\n        MEM[v27 + 4] = this;\n        v0 = v28 = MEM[64];\n        v5 = v29 = 6858;\n        v7 = v30 = 12843;\n        v9 = v31 = 0xffffffffffffffffffffffffffff & _getReserves >> 112;\n        v2 = v32 = _token1;\n        v11 = v33 = 32;\n        v13 = v34 = 36;\n        require(v32.code.size);\n        _sync = 1;\n        exit;\n        goto 0x1fdb0x59f;\n    }\n    revert(0, RETURNDATASIZE());\n}\n\nfunction factory() public payable { \n    return _factory;\n}\n\nfunction token1() public payable { \n    return _token1;\n}\n\nfunction permit(address varg0, address varg1, uint256 varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6) public payable { \n    require(msg.data.length - 4 >= 224);\n    require(varg3 >= block.timestamp, Error('UniswapV2: EXPIRED'));\n    _nonces[varg0] = _nonces[varg0] + 1;\n    MEM[MEM[64] + 256] = 0x1901000000000000000000000000000000000000000000000000000000000000;\n    MEM[MEM[64] + 258] = _dOMAIN_SEPARATOR;\n    MEM[MEM[64] + 290] = keccak256(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, varg0, varg1, varg2, _nonces[varg0], varg3);\n    v0 = new array[](290 + (MEM[64] - v0));\n    v1 = v0.length;\n    v2 = v0.data;\n    MEM[MEM[64] + 322] = 0;\n    MEM[MEM[64] + 354] = keccak256(v0);\n    MEM[MEM[64] + 386] = varg4 & 0xff & 0xff;\n    MEM[MEM[64] + 418] = varg5;\n    MEM[MEM[64] + 450] = varg6;\n    v3, v4 = ecrecover(MEM[(MEM[64]) len (482 + (MEM[64] - MEM[64]))], MEM[(MEM[64] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) len 32]);\n    require(v3); // checks call status, propagates error data on error\n    v5 = v6 = address(v4);\n    if (address(v4)) {\n        v5 = v7 = address(v4) == varg0;\n    }\n    require(v5, Error('UniswapV2: INVALID_SIGNATURE'));\n    _allowance[varg1] = varg2;\n    emit Approval(varg0, varg1, varg2);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sync() public payable { \n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = v1 <= 0xffffffffffffffffffffffffffff;\n    if (v1 <= 0xffffffffffffffffffffffffffff) {\n        v4 = v5 = v3 <= 0xffffffffffffffffffffffffffff;\n    }\n    require(v4, Error('UniswapV2: OVERFLOW'));\n    v6 = uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    if (uint32(uint32(block.timestamp) - uint32(_getReserves >> 224))) {\n        v6 = v7 = _getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff;\n    }\n    if (v6) {\n        v6 = v8 = _getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff;\n    }\n    if (v6) {\n        assert(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        _price0CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & (_getReserves >> 112 & 0xffffffffffffffffffffffffffff)) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / (_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff)) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n        assert(_getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        _price1CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & (_getReserves & 0xffffffffffffffffffffffffffff)) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / (_getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff)) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    }\n    _getReserves = uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves));\n    emit Sync(0xffffffffffffffffffffffffffff & (uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves))), 0xffffffffffffffffffffffffffff & (uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves))) >> 112);\n    _sync = 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x6a627842 > v0) {\n            if (0x23b872dd > v0) {\n                if (0x95ea7b3 > v0) {\n                    if (0x22c0d9f == v0) {\n                        swap(uint256,uint256,address,bytes);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else {\n                        require(0x902f1ac == v0);\n                        getReserves();\n                    }\n                } else if (0x95ea7b3 == v0) {\n                    approve(address,uint256);\n                } else if (0xdfe1681 == v0) {\n                    token0();\n                } else {\n                    require(0x18160ddd == v0);\n                    totalSupply();\n                }\n            } else if (0x3644e515 > v0) {\n                if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x30adf81f == v0) {\n                    PERMIT_TYPEHASH();\n                } else {\n                    require(0x313ce567 == v0);\n                    decimals();\n                }\n            } else if (0x3644e515 == v0) {\n                DOMAIN_SEPARATOR();\n            } else if (0x485cc955 == v0) {\n                initialize(address,address);\n            } else if (0x5909c0d5 == v0) {\n                price0CumulativeLast();\n            } else {\n                require(0x5a3d5493 == v0);\n                price1CumulativeLast();\n            }\n        } else if (0xba9a7a56 > v0) {\n            if (0x7ecebe00 > v0) {\n                if (0x6a627842 == v0) {\n                    mint(address);\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else {\n                    require(0x7464fc3d == v0);\n                    kLast();\n                }\n            } else if (0x7ecebe00 == v0) {\n                nonces(address);\n            } else if (0x89afcb44 == v0) {\n                burn(address);\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else {\n                require(0xa9059cbb == v0);\n                transfer(address,uint256);\n            }\n        } else if (0xd21220a7 > v0) {\n            if (0xba9a7a56 == v0) {\n                MINIMUM_LIQUIDITY();\n            } else if (0xbc25cf77 == v0) {\n                skim(address);\n            } else {\n                require(0xc45a0155 == v0);\n                factory();\n            }\n        } else if (0xd21220a7 == v0) {\n            token1();\n        } else if (0xd505accf == v0) {\n            permit(address,address,uint256,uint256,uint8,bytes32,bytes32);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else {\n            require(0xfff6cae9 == v0);\n            sync();\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 22:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _dOMAIN_SEPARATOR; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _nonces; // STORAGE[0x4]\nuint256 _getReserves; // STORAGE[0x8]\nuint256 _price0CumulativeLast; // STORAGE[0x9]\nuint256 _price1CumulativeLast; // STORAGE[0xa]\nuint256 _kLast; // STORAGE[0xb]\nuint256 _sync; // STORAGE[0xc]\nuint256 _factory; // STORAGE[0x5] bytes 0 to 19\nuint256 _token0; // STORAGE[0x6] bytes 0 to 19\nuint256 _token1; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nSwap(address, uint256, uint256, uint256, uint256, address);\nMint(address, uint256, uint256);\nBurn(address, uint256, uint256, address);\nSync(uint112, uint112);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction swap(uint256 varg0, uint256 varg1, address varg2, bytes varg3) public payable { \n    v0 = v1 = 11612;\n    require(msg.data.length - 4 >= 128);\n    v0 = v2 = varg2;\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    v0 = v3 = varg3.length;\n    v0 = v4 = 36 + varg3;\n    require(!((v3 > 0x100000000) | (v4 + v3 > 4 + (msg.data.length - 4))));\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    v5 = v6 = varg0;\n    if (!varg0) {\n        v5 = v7 = varg1 > 0;\n    }\n    require(v5, Error('UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT'));\n    v0 = v8 = _getReserves & 0xffffffffffffffffffffffffffff;\n    v0 = v9 = 0xffffffffffffffffffffffffffff & _getReserves >> 112;\n    v10 = v11 = varg0 < 0xffffffffffffffffffffffffffff & v8;\n    if (v11) {\n        v10 = v12 = varg1 < 0xffffffffffffffffffffffffffff & v9;\n    }\n    require(v10, Error('UniswapV2: INSUFFICIENT_LIQUIDITY'));\n    v13 = v14 = _token0 != address(v2);\n    if (_token0 != address(v2)) {\n        v13 = v15 = address(v2) != _token1;\n    }\n    require(v13, Error('UniswapV2: INVALID_TO'));\n    if (varg0) {\n        0x1fdb(varg0, v2, _token0);\n    }\n    if (varg1) {\n        0x1fdb(varg1, v2, _token1);\n    }\n    if (v3) {\n        v16[v3] = 0;\n        require((address(v2)).code.size);\n        v17 = address(v2).uniswapV2Call(msg.sender, varg0, varg1, 132 + MEM[64]).gas(msg.gas);\n        require(v17); // checks call status, propagates error data on error\n    }\n    require(_token0.code.size);\n    v18, v0 = _token0.balanceOf(this).gas(msg.gas);\n    require(v18); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v19, v0 = _token1.balanceOf(this).gas(msg.gas);\n    require(v19); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v0 > (v8 & 0xffffffffffffffffffffffffffff) - varg0) {\n        v0 = v20 = v0 - ((0xffffffffffffffffffffffffffff & v8) - varg0);\n    } else {\n        v0 = v21 = 0;\n    }\n    if (v0 > (0xffffffffffffffffffffffffffff & v9) - varg1) {\n        v0 = v22 = v0 - ((0xffffffffffffffffffffffffffff & v9) - varg1);\n    } else {\n        v0 = v23 = 0;\n    }\n    v24 = v25 = v0 > 0;\n    if (v0 <= 0) {\n        v24 = v26 = v0 > 0;\n    }\n    require(v24, Error('UniswapV2: INSUFFICIENT_INPUT_AMOUNT', v27, v27, 128));\n    v28 = v29 = 3081;\n    v30 = v31 = 0x21e8(3, v0);\n    while (1) {\n        v32 = 0x21e8(1000, v0);\n        v0 = _SafeSub(v30, v32);\n        v28 = v33 = 3105;\n        v30 = 0x21e8(3, v0);\n    }\n    v34 = 0x21e8(v0 & 0xffffffffffffffffffffffffffff, 0xffffffffffffffffffffffffffff & v0);\n    v35 = 0x21e8(0xf4240, v34);\n    v36 = 0x21e8(v0, v0);\n    require(v36 >= v35, Error('UniswapV2: K'));\n    0x22e0(v0, v0, v0, v0);\n    emit Swap(msg.sender, address(v0), v0, v0, v0, v0);\n    _sync = 1;\n}\n\nfunction 0x1fdb(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg1);\n    MEM[64] = MEM[64] + 100;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v6, v7, v8 = address(varg2).transfer(0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v0, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    if (v6) {\n        v6 = v11 = !MEM[v9];\n        if (MEM[v9]) {\n            require(MEM[v9] >= 32);\n            v6 = v12 = MEM[32 + v9];\n        }\n    }\n    require(v6, Error('UniswapV2: TRANSFER_FAILED'));\n    return ;\n}\n\nfunction 0x21e8(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = !varg0;\n    if (varg0) {\n        v0 = v4 = varg1 * varg0;\n        assert(varg0);\n        v2 = v5 = v4 / varg0 == varg1;\n    }\n    require(v2, Error('ds-math-mul-overflow'));\n    return v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 - varg0;\n    require(v0 <= varg1, Error('ds-math-sub-underflow'));\n    return v0;\n}\n\nfunction 0x22e0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = varg3 > 0xffffffffffffffffffffffffffff;\n    v1 = v2 = varg3 <= 0xffffffffffffffffffffffffffff;\n    if (varg3 <= 0xffffffffffffffffffffffffffff) {\n        v1 = varg2 <= 0xffffffffffffffffffffffffffff;\n    }\n    require(v1, Error('UniswapV2: OVERFLOW'));\n    v3 = uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    if (uint32(uint32(block.timestamp) - uint32(_getReserves >> 224))) {\n        v3 = v4 = varg1 & 0xffffffffffffffffffffffffffff;\n    }\n    if (v3) {\n        v3 = v5 = varg0 & 0xffffffffffffffffffffffffffff;\n    }\n    if (v3) {\n        v6 = varg1 & 0xffffffffffffffffffffffffffff;\n        assert(v6);\n        _price0CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg0) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / v6) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n        v7 = varg0 & 0xffffffffffffffffffffffffffff;\n        assert(v7);\n        _price1CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg1) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / v7) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    }\n    v8 = uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & varg2) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg3 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves));\n    _getReserves = v8;\n    emit Sync(0xffffffffffffffffffffffffffff & v8, 0xffffffffffffffffffffffffffff & v8 >> 112);\n    return ;\n}\n\nfunction name() public payable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'Uniswap V2';\n    }\n    return v0;\n}\n\nfunction 0x260b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = _SafeSub(varg0, _balanceOf[v0]);\n    v2 = address(varg2);\n    _balanceOf[v2] = v1;\n    v3 = address(varg1);\n    v4 = _balanceOf[v3] + varg0;\n    require(v4 >= _balanceOf[v3], Error('ds-math-add-overflow'));\n    v5 = address(varg1);\n    _balanceOf[v5] = v4;\n    emit Transfer(address(varg2), v5, varg0);\n    return ;\n}\n\nfunction 0x26ec(uint256 varg0, uint256 varg1) private { \n    require(_factory.code.size);\n    v0, v1 = _factory.feeTo().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!address(v1)) {\n        if (!_kLast) {\n            return address(v1);\n        } else {\n            _kLast = 0;\n            return address(v1);\n        }\n    } else {\n        if (_kLast) {\n            v2 = 0x21e8(varg0 & 0xffffffffffffffffffffffffffff, 0xffffffffffffffffffffffffffff & varg1);\n            v3 = 0x2878(v2);\n            v4 = 0x2878(_kLast);\n            if (v3 > v4) {\n                v5 = _SafeSub(v4, v3);\n                v6 = 0x21e8(v5, _totalSupply);\n                v7 = 0x21e8(5, v3);\n                require(v7 + v4 >= v7, Error('ds-math-add-overflow'));\n                assert(v7 + v4);\n                if (v6 / (v7 + v4)) {\n                    0x28ca(v6 / (v7 + v4), v1);\n                }\n            }\n        }\n        return address(v1);\n    }\n}\n\nfunction 0x2878(uint256 varg0) private { \n    if (varg0 <= 3) {\n        if (!varg0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else {\n        varg0 = v0 = (varg0 >> 1) + 1;\n        while (varg0 < varg0) {\n            assert(varg0);\n            assert(2);\n            varg0 = varg0 / varg0 + varg0 >> 1;\n        }\n        return varg0;\n    }\n}\n\nfunction 0x28ca(uint256 varg0, uint256 varg1) private { \n    v0 = _totalSupply + varg0;\n    require(v0 >= _totalSupply, Error('ds-math-add-overflow'));\n    _totalSupply = v0;\n    v1 = address(varg1);\n    v2 = _balanceOf[v1] + varg0;\n    require(v2 >= _balanceOf[v1], Error('ds-math-add-overflow'));\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(0, v3, varg0);\n    return ;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction getReserves() public payable { \n    return 0xffffffffffffffffffffffffffff & (_getReserves & 0xffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & _getReserves >> 112), uint32(_getReserves >> 224);\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction token0() public payable { \n    return _token0;\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    if (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != _allowance[msg.sender]) {\n        v0 = _SafeSub(varg2, _allowance[msg.sender]);\n        _allowance[msg.sender] = v0;\n    }\n    0x260b(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction PERMIT_TYPEHASH() public payable { \n    return 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n}\n\nfunction decimals() public payable { \n    return 18;\n}\n\nfunction DOMAIN_SEPARATOR() public payable { \n    return _dOMAIN_SEPARATOR;\n}\n\nfunction initialize(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _factory, Error('UniswapV2: FORBIDDEN'));\n    _token0 = varg0;\n    _token1 = varg1;\n}\n\nfunction price0CumulativeLast() public payable { \n    return _price0CumulativeLast;\n}\n\nfunction price1CumulativeLast() public payable { \n    return _price1CumulativeLast;\n}\n\nfunction mint(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = _SafeSub(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff, v1);\n    v5 = _SafeSub(0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff, v3);\n    v6 = 0x26ec(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff);\n    if (_totalSupply) {\n        v7 = 0x21e8(_totalSupply, v4);\n        assert(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        v8 = v9 = v7 / (_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        v10 = 0x21e8(_totalSupply, v5);\n        assert(0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff);\n        v8 = v11 = v10 / (0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff);\n        if (v9 >= v11) {\n        }\n    } else {\n        v12 = 0x21e8(v5, v4);\n        v13 = 0x2878(v12);\n        v8 = v14 = _SafeSub(1000, v13);\n        0x28ca(1000, 0);\n    }\n    require(v8 > 0, Error('UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED'));\n    0x28ca(v8, varg0);\n    0x22e0(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff, v3, v1);\n    if (v6) {\n        v15 = 0x21e8(_getReserves >> 112 & 0xffffffffffffffffffffffffffff, _getReserves & 0xffffffffffffffffffffffffffff);\n        _kLast = v15;\n    }\n    emit Mint(msg.sender, v4, v5);\n    _sync = 1;\n    return v8;\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction kLast() public payable { \n    return _kLast;\n}\n\nfunction nonces(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _nonces[varg0];\n}\n\nfunction burn(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = 0x26ec(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff);\n    v5 = 0x21e8(v1, _balanceOf[this]);\n    assert(_totalSupply);\n    v6 = 0x21e8(v3, _balanceOf[this]);\n    assert(_totalSupply);\n    v7 = v8 = v5 / _totalSupply > 0;\n    if (v8) {\n        v7 = v9 = v6 / _totalSupply > 0;\n    }\n    require(v7, Error('UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED'));\n    v10 = _SafeSub(_balanceOf[this], _balanceOf[address(this)]);\n    _balanceOf[address(this)] = v10;\n    v11 = _SafeSub(_balanceOf[this], _totalSupply);\n    _totalSupply = v11;\n    emit Transfer(address(this), 0, _balanceOf[this]);\n    0x1fdb(v5 / _totalSupply, varg0, _token0);\n    0x1fdb(v6 / _totalSupply, varg0, _token1);\n    require(_token0.code.size);\n    v12, v13 = _token0.balanceOf(this).gas(msg.gas);\n    require(v12); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v14, v15 = _token1.balanceOf(this).gas(msg.gas);\n    require(v14); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    0x22e0(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff, v15, v13);\n    if (v4) {\n        v16 = 0x21e8(_getReserves >> 112 & 0xffffffffffffffffffffffffffff, _getReserves & 0xffffffffffffffffffffffffffff);\n        _kLast = v16;\n    }\n    emit Burn(msg.sender, varg0, v5 / _totalSupply, v6 / _totalSupply);\n    _sync = 1;\n    return v5 / _totalSupply, v6 / _totalSupply;\n}\n\nfunction symbol() public payable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'UNI-V2';\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x260b(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction MINIMUM_LIQUIDITY() public payable { \n    return 1000;\n}\n\nfunction skim(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[MEM[64] + 4] = this;\n    v0 = v1 = MEM[64];\n    v2 = v3 = _token0;\n    v2 = v4 = _token1;\n    v5 = v6 = 6699;\n    v7 = v8 = 12807;\n    v9 = v10 = 0xffffffffffffffffffffffffffff & _getReserves;\n    v11 = v12 = 32;\n    v13 = v14 = 36;\n    require(v3.code.size);\n    while (1) {\n        v15 = v2.staticcall(MEM[v0 len v13], MEM[v0 len v11]).gas(msg.gas);\n        if (v15) {\n            break;\n        }\n        v16 = 'transfer(address,uint256)';\n        if (RETURNDATASIZE() >= 32) {\n            break;\n        }\n        require(RETURNDATASIZE() >= 32);\n        if (v16.length - v9 <= v16.length) {\n            break;\n        }\n        require(v16.length - v9 <= v16.length, Error('ds-math-sub-underflow'));\n        goto {'0x3207', '0x322b'};\n        MEM[64] = MEM[64] + 100;\n        v17 = MEM[64] + 32;\n        v18 = MEM[64];\n        while (v19 >= 32) {\n            MEM[v18] = MEM[v17];\n            v19 = v19 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0;\n            v18 += 32;\n            v17 += 32;\n        }\n        MEM[v18] = MEM[v17] & ~(256 ** (32 - v19) - 1) | MEM[v18] & 256 ** (32 - v19) - 1;\n        v20, v21, v22 = address(v2).transfer(varg0, v16.length - v9).gas(msg.gas);\n        if (RETURNDATASIZE() == 0) {\n            v23 = v24 = 96;\n        } else {\n            v23 = new bytes[](RETURNDATASIZE());\n            RETURNDATACOPY(v23.data, 0, RETURNDATASIZE());\n        }\n        if (v20) {\n            v20 = v25 = !MEM[v23];\n            if (MEM[v23]) {\n                require(MEM[v23] >= 32);\n                v20 = v26 = MEM[32 + v23];\n            }\n        }\n        require(v20, Error('UniswapV2: TRANSFER_FAILED'));\n        goto {'0x1a2b', '0x1aca'};\n        v27 = new bytes[](RETURNDATASIZE());\n        MEM[v27 + 4] = this;\n        v0 = v28 = MEM[64];\n        v5 = v29 = 6858;\n        v7 = v30 = 12843;\n        v9 = v31 = 0xffffffffffffffffffffffffffff & _getReserves >> 112;\n        v2 = v32 = _token1;\n        v11 = v33 = 32;\n        v13 = v34 = 36;\n        require(v32.code.size);\n        _sync = 1;\n        exit;\n        goto 0x1fdb0x59f;\n    }\n    revert(0, RETURNDATASIZE());\n}\n\nfunction factory() public payable { \n    return _factory;\n}\n\nfunction token1() public payable { \n    return _token1;\n}\n\nfunction permit(address varg0, address varg1, uint256 varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6) public payable { \n    require(msg.data.length - 4 >= 224);\n    require(varg3 >= block.timestamp, Error('UniswapV2: EXPIRED'));\n    _nonces[varg0] = _nonces[varg0] + 1;\n    MEM[MEM[64] + 256] = 0x1901000000000000000000000000000000000000000000000000000000000000;\n    MEM[MEM[64] + 258] = _dOMAIN_SEPARATOR;\n    MEM[MEM[64] + 290] = keccak256(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, varg0, varg1, varg2, _nonces[varg0], varg3);\n    v0 = new array[](290 + (MEM[64] - v0));\n    v1 = v0.length;\n    v2 = v0.data;\n    MEM[MEM[64] + 322] = 0;\n    MEM[MEM[64] + 354] = keccak256(v0);\n    MEM[MEM[64] + 386] = varg4 & 0xff & 0xff;\n    MEM[MEM[64] + 418] = varg5;\n    MEM[MEM[64] + 450] = varg6;\n    v3, v4 = ecrecover(MEM[(MEM[64]) len (482 + (MEM[64] - MEM[64]))], MEM[(MEM[64] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) len 32]);\n    require(v3); // checks call status, propagates error data on error\n    v5 = v6 = address(v4);\n    if (address(v4)) {\n        v5 = v7 = address(v4) == varg0;\n    }\n    require(v5, Error('UniswapV2: INVALID_SIGNATURE'));\n    _allowance[varg1] = varg2;\n    emit Approval(varg0, varg1, varg2);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sync() public payable { \n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = v1 <= 0xffffffffffffffffffffffffffff;\n    if (v1 <= 0xffffffffffffffffffffffffffff) {\n        v4 = v5 = v3 <= 0xffffffffffffffffffffffffffff;\n    }\n    require(v4, Error('UniswapV2: OVERFLOW'));\n    v6 = uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    if (uint32(uint32(block.timestamp) - uint32(_getReserves >> 224))) {\n        v6 = v7 = _getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff;\n    }\n    if (v6) {\n        v6 = v8 = _getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff;\n    }\n    if (v6) {\n        assert(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        _price0CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & (_getReserves >> 112 & 0xffffffffffffffffffffffffffff)) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / (_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff)) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n        assert(_getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        _price1CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & (_getReserves & 0xffffffffffffffffffffffffffff)) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / (_getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff)) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    }\n    _getReserves = uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves));\n    emit Sync(0xffffffffffffffffffffffffffff & (uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves))), 0xffffffffffffffffffffffffffff & (uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves))) >> 112);\n    _sync = 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x6a627842 > v0) {\n            if (0x23b872dd > v0) {\n                if (0x95ea7b3 > v0) {\n                    if (0x22c0d9f == v0) {\n                        swap(uint256,uint256,address,bytes);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else {\n                        require(0x902f1ac == v0);\n                        getReserves();\n                    }\n                } else if (0x95ea7b3 == v0) {\n                    approve(address,uint256);\n                } else if (0xdfe1681 == v0) {\n                    token0();\n                } else {\n                    require(0x18160ddd == v0);\n                    totalSupply();\n                }\n            } else if (0x3644e515 > v0) {\n                if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x30adf81f == v0) {\n                    PERMIT_TYPEHASH();\n                } else {\n                    require(0x313ce567 == v0);\n                    decimals();\n                }\n            } else if (0x3644e515 == v0) {\n                DOMAIN_SEPARATOR();\n            } else if (0x485cc955 == v0) {\n                initialize(address,address);\n            } else if (0x5909c0d5 == v0) {\n                price0CumulativeLast();\n            } else {\n                require(0x5a3d5493 == v0);\n                price1CumulativeLast();\n            }\n        } else if (0xba9a7a56 > v0) {\n            if (0x7ecebe00 > v0) {\n                if (0x6a627842 == v0) {\n                    mint(address);\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else {\n                    require(0x7464fc3d == v0);\n                    kLast();\n                }\n            } else if (0x7ecebe00 == v0) {\n                nonces(address);\n            } else if (0x89afcb44 == v0) {\n                burn(address);\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else {\n                require(0xa9059cbb == v0);\n                transfer(address,uint256);\n            }\n        } else if (0xd21220a7 > v0) {\n            if (0xba9a7a56 == v0) {\n                MINIMUM_LIQUIDITY();\n            } else if (0xbc25cf77 == v0) {\n                skim(address);\n            } else {\n                require(0xc45a0155 == v0);\n                factory();\n            }\n        } else if (0xd21220a7 == v0) {\n            token1();\n        } else if (0xd505accf == v0) {\n            permit(address,address,uint256,uint256,uint8,bytes32,bytes32);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else {\n            require(0xfff6cae9 == v0);\n            sync();\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 22:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _dOMAIN_SEPARATOR; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _nonces; // STORAGE[0x4]\nuint256 _getReserves; // STORAGE[0x8]\nuint256 _price0CumulativeLast; // STORAGE[0x9]\nuint256 _price1CumulativeLast; // STORAGE[0xa]\nuint256 _kLast; // STORAGE[0xb]\nuint256 _sync; // STORAGE[0xc]\nuint256 _factory; // STORAGE[0x5] bytes 0 to 19\nuint256 _token0; // STORAGE[0x6] bytes 0 to 19\nuint256 _token1; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nSwap(address, uint256, uint256, uint256, uint256, address);\nMint(address, uint256, uint256);\nBurn(address, uint256, uint256, address);\nSync(uint112, uint112);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction swap(uint256 varg0, uint256 varg1, address varg2, bytes varg3) public payable { \n    v0 = v1 = 11612;\n    require(msg.data.length - 4 >= 128);\n    v0 = v2 = varg2;\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    v0 = v3 = varg3.length;\n    v0 = v4 = 36 + varg3;\n    require(!((v3 > 0x100000000) | (v4 + v3 > 4 + (msg.data.length - 4))));\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    v5 = v6 = varg0;\n    if (!varg0) {\n        v5 = v7 = varg1 > 0;\n    }\n    require(v5, Error('UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT'));\n    v0 = v8 = _getReserves & 0xffffffffffffffffffffffffffff;\n    v0 = v9 = 0xffffffffffffffffffffffffffff & _getReserves >> 112;\n    v10 = v11 = varg0 < 0xffffffffffffffffffffffffffff & v8;\n    if (v11) {\n        v10 = v12 = varg1 < 0xffffffffffffffffffffffffffff & v9;\n    }\n    require(v10, Error('UniswapV2: INSUFFICIENT_LIQUIDITY'));\n    v13 = v14 = _token0 != address(v2);\n    if (_token0 != address(v2)) {\n        v13 = v15 = address(v2) != _token1;\n    }\n    require(v13, Error('UniswapV2: INVALID_TO'));\n    if (varg0) {\n        0x1fdb(varg0, v2, _token0);\n    }\n    if (varg1) {\n        0x1fdb(varg1, v2, _token1);\n    }\n    if (v3) {\n        v16[v3] = 0;\n        require((address(v2)).code.size);\n        v17 = address(v2).uniswapV2Call(msg.sender, varg0, varg1, 132 + MEM[64]).gas(msg.gas);\n        require(v17); // checks call status, propagates error data on error\n    }\n    require(_token0.code.size);\n    v18, v0 = _token0.balanceOf(this).gas(msg.gas);\n    require(v18); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v19, v0 = _token1.balanceOf(this).gas(msg.gas);\n    require(v19); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v0 > (v8 & 0xffffffffffffffffffffffffffff) - varg0) {\n        v0 = v20 = v0 - ((0xffffffffffffffffffffffffffff & v8) - varg0);\n    } else {\n        v0 = v21 = 0;\n    }\n    if (v0 > (0xffffffffffffffffffffffffffff & v9) - varg1) {\n        v0 = v22 = v0 - ((0xffffffffffffffffffffffffffff & v9) - varg1);\n    } else {\n        v0 = v23 = 0;\n    }\n    v24 = v25 = v0 > 0;\n    if (v0 <= 0) {\n        v24 = v26 = v0 > 0;\n    }\n    require(v24, Error('UniswapV2: INSUFFICIENT_INPUT_AMOUNT', v27, v27, 128));\n    v28 = v29 = 3081;\n    v30 = v31 = 0x21e8(3, v0);\n    while (1) {\n        v32 = 0x21e8(1000, v0);\n        v0 = _SafeSub(v30, v32);\n        v28 = v33 = 3105;\n        v30 = 0x21e8(3, v0);\n    }\n    v34 = 0x21e8(v0 & 0xffffffffffffffffffffffffffff, 0xffffffffffffffffffffffffffff & v0);\n    v35 = 0x21e8(0xf4240, v34);\n    v36 = 0x21e8(v0, v0);\n    require(v36 >= v35, Error('UniswapV2: K'));\n    0x22e0(v0, v0, v0, v0);\n    emit Swap(msg.sender, address(v0), v0, v0, v0, v0);\n    _sync = 1;\n}\n\nfunction 0x1fdb(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg1);\n    MEM[64] = MEM[64] + 100;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v6, v7, v8 = address(varg2).transfer(0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v0, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    if (v6) {\n        v6 = v11 = !MEM[v9];\n        if (MEM[v9]) {\n            require(MEM[v9] >= 32);\n            v6 = v12 = MEM[32 + v9];\n        }\n    }\n    require(v6, Error('UniswapV2: TRANSFER_FAILED'));\n    return ;\n}\n\nfunction 0x21e8(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = !varg0;\n    if (varg0) {\n        v0 = v4 = varg1 * varg0;\n        assert(varg0);\n        v2 = v5 = v4 / varg0 == varg1;\n    }\n    require(v2, Error('ds-math-mul-overflow'));\n    return v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 - varg0;\n    require(v0 <= varg1, Error('ds-math-sub-underflow'));\n    return v0;\n}\n\nfunction 0x22e0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = varg3 > 0xffffffffffffffffffffffffffff;\n    v1 = v2 = varg3 <= 0xffffffffffffffffffffffffffff;\n    if (varg3 <= 0xffffffffffffffffffffffffffff) {\n        v1 = varg2 <= 0xffffffffffffffffffffffffffff;\n    }\n    require(v1, Error('UniswapV2: OVERFLOW'));\n    v3 = uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    if (uint32(uint32(block.timestamp) - uint32(_getReserves >> 224))) {\n        v3 = v4 = varg1 & 0xffffffffffffffffffffffffffff;\n    }\n    if (v3) {\n        v3 = v5 = varg0 & 0xffffffffffffffffffffffffffff;\n    }\n    if (v3) {\n        v6 = varg1 & 0xffffffffffffffffffffffffffff;\n        assert(v6);\n        _price0CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg0) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / v6) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n        v7 = varg0 & 0xffffffffffffffffffffffffffff;\n        assert(v7);\n        _price1CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg1) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / v7) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    }\n    v8 = uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & varg2) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & varg3 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves));\n    _getReserves = v8;\n    emit Sync(0xffffffffffffffffffffffffffff & v8, 0xffffffffffffffffffffffffffff & v8 >> 112);\n    return ;\n}\n\nfunction name() public payable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'Uniswap V2';\n    }\n    return v0;\n}\n\nfunction 0x260b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = _SafeSub(varg0, _balanceOf[v0]);\n    v2 = address(varg2);\n    _balanceOf[v2] = v1;\n    v3 = address(varg1);\n    v4 = _balanceOf[v3] + varg0;\n    require(v4 >= _balanceOf[v3], Error('ds-math-add-overflow'));\n    v5 = address(varg1);\n    _balanceOf[v5] = v4;\n    emit Transfer(address(varg2), v5, varg0);\n    return ;\n}\n\nfunction 0x26ec(uint256 varg0, uint256 varg1) private { \n    require(_factory.code.size);\n    v0, v1 = _factory.feeTo().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!address(v1)) {\n        if (!_kLast) {\n            return address(v1);\n        } else {\n            _kLast = 0;\n            return address(v1);\n        }\n    } else {\n        if (_kLast) {\n            v2 = 0x21e8(varg0 & 0xffffffffffffffffffffffffffff, 0xffffffffffffffffffffffffffff & varg1);\n            v3 = 0x2878(v2);\n            v4 = 0x2878(_kLast);\n            if (v3 > v4) {\n                v5 = _SafeSub(v4, v3);\n                v6 = 0x21e8(v5, _totalSupply);\n                v7 = 0x21e8(5, v3);\n                require(v7 + v4 >= v7, Error('ds-math-add-overflow'));\n                assert(v7 + v4);\n                if (v6 / (v7 + v4)) {\n                    0x28ca(v6 / (v7 + v4), v1);\n                }\n            }\n        }\n        return address(v1);\n    }\n}\n\nfunction 0x2878(uint256 varg0) private { \n    if (varg0 <= 3) {\n        if (!varg0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else {\n        varg0 = v0 = (varg0 >> 1) + 1;\n        while (varg0 < varg0) {\n            assert(varg0);\n            assert(2);\n            varg0 = varg0 / varg0 + varg0 >> 1;\n        }\n        return varg0;\n    }\n}\n\nfunction 0x28ca(uint256 varg0, uint256 varg1) private { \n    v0 = _totalSupply + varg0;\n    require(v0 >= _totalSupply, Error('ds-math-add-overflow'));\n    _totalSupply = v0;\n    v1 = address(varg1);\n    v2 = _balanceOf[v1] + varg0;\n    require(v2 >= _balanceOf[v1], Error('ds-math-add-overflow'));\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(0, v3, varg0);\n    return ;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction getReserves() public payable { \n    return 0xffffffffffffffffffffffffffff & (_getReserves & 0xffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & _getReserves >> 112), uint32(_getReserves >> 224);\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction token0() public payable { \n    return _token0;\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    if (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != _allowance[msg.sender]) {\n        v0 = _SafeSub(varg2, _allowance[msg.sender]);\n        _allowance[msg.sender] = v0;\n    }\n    0x260b(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction PERMIT_TYPEHASH() public payable { \n    return 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n}\n\nfunction decimals() public payable { \n    return 18;\n}\n\nfunction DOMAIN_SEPARATOR() public payable { \n    return _dOMAIN_SEPARATOR;\n}\n\nfunction initialize(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _factory, Error('UniswapV2: FORBIDDEN'));\n    _token0 = varg0;\n    _token1 = varg1;\n}\n\nfunction price0CumulativeLast() public payable { \n    return _price0CumulativeLast;\n}\n\nfunction price1CumulativeLast() public payable { \n    return _price1CumulativeLast;\n}\n\nfunction mint(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = _SafeSub(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff, v1);\n    v5 = _SafeSub(0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff, v3);\n    v6 = 0x26ec(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff);\n    if (_totalSupply) {\n        v7 = 0x21e8(_totalSupply, v4);\n        assert(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        v8 = v9 = v7 / (_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        v10 = 0x21e8(_totalSupply, v5);\n        assert(0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff);\n        v8 = v11 = v10 / (0xffffffffffffffffffffffffffff & _getReserves >> 112 & 0xffffffffffffffffffffffffffff);\n        if (v9 >= v11) {\n        }\n    } else {\n        v12 = 0x21e8(v5, v4);\n        v13 = 0x2878(v12);\n        v8 = v14 = _SafeSub(1000, v13);\n        0x28ca(1000, 0);\n    }\n    require(v8 > 0, Error('UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED'));\n    0x28ca(v8, varg0);\n    0x22e0(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff, v3, v1);\n    if (v6) {\n        v15 = 0x21e8(_getReserves >> 112 & 0xffffffffffffffffffffffffffff, _getReserves & 0xffffffffffffffffffffffffffff);\n        _kLast = v15;\n    }\n    emit Mint(msg.sender, v4, v5);\n    _sync = 1;\n    return v8;\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction kLast() public payable { \n    return _kLast;\n}\n\nfunction nonces(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _nonces[varg0];\n}\n\nfunction burn(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = 0x26ec(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff);\n    v5 = 0x21e8(v1, _balanceOf[this]);\n    assert(_totalSupply);\n    v6 = 0x21e8(v3, _balanceOf[this]);\n    assert(_totalSupply);\n    v7 = v8 = v5 / _totalSupply > 0;\n    if (v8) {\n        v7 = v9 = v6 / _totalSupply > 0;\n    }\n    require(v7, Error('UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED'));\n    v10 = _SafeSub(_balanceOf[this], _balanceOf[address(this)]);\n    _balanceOf[address(this)] = v10;\n    v11 = _SafeSub(_balanceOf[this], _totalSupply);\n    _totalSupply = v11;\n    emit Transfer(address(this), 0, _balanceOf[this]);\n    0x1fdb(v5 / _totalSupply, varg0, _token0);\n    0x1fdb(v6 / _totalSupply, varg0, _token1);\n    require(_token0.code.size);\n    v12, v13 = _token0.balanceOf(this).gas(msg.gas);\n    require(v12); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v14, v15 = _token1.balanceOf(this).gas(msg.gas);\n    require(v14); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    0x22e0(0xffffffffffffffffffffffffffff & _getReserves >> 112, _getReserves & 0xffffffffffffffffffffffffffff, v15, v13);\n    if (v4) {\n        v16 = 0x21e8(_getReserves >> 112 & 0xffffffffffffffffffffffffffff, _getReserves & 0xffffffffffffffffffffffffffff);\n        _kLast = v16;\n    }\n    emit Burn(msg.sender, varg0, v5 / _totalSupply, v6 / _totalSupply);\n    _sync = 1;\n    return v5 / _totalSupply, v6 / _totalSupply;\n}\n\nfunction symbol() public payable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'UNI-V2';\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x260b(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction MINIMUM_LIQUIDITY() public payable { \n    return 1000;\n}\n\nfunction skim(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[MEM[64] + 4] = this;\n    v0 = v1 = MEM[64];\n    v2 = v3 = _token0;\n    v2 = v4 = _token1;\n    v5 = v6 = 6699;\n    v7 = v8 = 12807;\n    v9 = v10 = 0xffffffffffffffffffffffffffff & _getReserves;\n    v11 = v12 = 32;\n    v13 = v14 = 36;\n    require(v3.code.size);\n    while (1) {\n        v15 = v2.staticcall(MEM[v0 len v13], MEM[v0 len v11]).gas(msg.gas);\n        if (v15) {\n            break;\n        }\n        v16 = 'transfer(address,uint256)';\n        if (RETURNDATASIZE() >= 32) {\n            break;\n        }\n        require(RETURNDATASIZE() >= 32);\n        if (v16.length - v9 <= v16.length) {\n            break;\n        }\n        require(v16.length - v9 <= v16.length, Error('ds-math-sub-underflow'));\n        goto {'0x3207', '0x322b'};\n        MEM[64] = MEM[64] + 100;\n        v17 = MEM[64] + 32;\n        v18 = MEM[64];\n        while (v19 >= 32) {\n            MEM[v18] = MEM[v17];\n            v19 = v19 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0;\n            v18 += 32;\n            v17 += 32;\n        }\n        MEM[v18] = MEM[v17] & ~(256 ** (32 - v19) - 1) | MEM[v18] & 256 ** (32 - v19) - 1;\n        v20, v21, v22 = address(v2).transfer(varg0, v16.length - v9).gas(msg.gas);\n        if (RETURNDATASIZE() == 0) {\n            v23 = v24 = 96;\n        } else {\n            v23 = new bytes[](RETURNDATASIZE());\n            RETURNDATACOPY(v23.data, 0, RETURNDATASIZE());\n        }\n        if (v20) {\n            v20 = v25 = !MEM[v23];\n            if (MEM[v23]) {\n                require(MEM[v23] >= 32);\n                v20 = v26 = MEM[32 + v23];\n            }\n        }\n        require(v20, Error('UniswapV2: TRANSFER_FAILED'));\n        goto {'0x1a2b', '0x1aca'};\n        v27 = new bytes[](RETURNDATASIZE());\n        MEM[v27 + 4] = this;\n        v0 = v28 = MEM[64];\n        v5 = v29 = 6858;\n        v7 = v30 = 12843;\n        v9 = v31 = 0xffffffffffffffffffffffffffff & _getReserves >> 112;\n        v2 = v32 = _token1;\n        v11 = v33 = 32;\n        v13 = v34 = 36;\n        require(v32.code.size);\n        _sync = 1;\n        exit;\n        goto 0x1fdb0x59f;\n    }\n    revert(0, RETURNDATASIZE());\n}\n\nfunction factory() public payable { \n    return _factory;\n}\n\nfunction token1() public payable { \n    return _token1;\n}\n\nfunction permit(address varg0, address varg1, uint256 varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6) public payable { \n    require(msg.data.length - 4 >= 224);\n    require(varg3 >= block.timestamp, Error('UniswapV2: EXPIRED'));\n    _nonces[varg0] = _nonces[varg0] + 1;\n    MEM[MEM[64] + 256] = 0x1901000000000000000000000000000000000000000000000000000000000000;\n    MEM[MEM[64] + 258] = _dOMAIN_SEPARATOR;\n    MEM[MEM[64] + 290] = keccak256(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, varg0, varg1, varg2, _nonces[varg0], varg3);\n    v0 = new array[](290 + (MEM[64] - v0));\n    v1 = v0.length;\n    v2 = v0.data;\n    MEM[MEM[64] + 322] = 0;\n    MEM[MEM[64] + 354] = keccak256(v0);\n    MEM[MEM[64] + 386] = varg4 & 0xff & 0xff;\n    MEM[MEM[64] + 418] = varg5;\n    MEM[MEM[64] + 450] = varg6;\n    v3, v4 = ecrecover(MEM[(MEM[64]) len (482 + (MEM[64] - MEM[64]))], MEM[(MEM[64] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) len 32]);\n    require(v3); // checks call status, propagates error data on error\n    v5 = v6 = address(v4);\n    if (address(v4)) {\n        v5 = v7 = address(v4) == varg0;\n    }\n    require(v5, Error('UniswapV2: INVALID_SIGNATURE'));\n    _allowance[varg1] = varg2;\n    emit Approval(varg0, varg1, varg2);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sync() public payable { \n    require(1 == _sync, Error('UniswapV2: LOCKED'));\n    _sync = 0;\n    require(_token0.code.size);\n    v0, v1 = _token0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token1.code.size);\n    v2, v3 = _token1.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = v1 <= 0xffffffffffffffffffffffffffff;\n    if (v1 <= 0xffffffffffffffffffffffffffff) {\n        v4 = v5 = v3 <= 0xffffffffffffffffffffffffffff;\n    }\n    require(v4, Error('UniswapV2: OVERFLOW'));\n    v6 = uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    if (uint32(uint32(block.timestamp) - uint32(_getReserves >> 224))) {\n        v6 = v7 = _getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff;\n    }\n    if (v6) {\n        v6 = v8 = _getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff;\n    }\n    if (v6) {\n        assert(_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        _price0CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & (_getReserves >> 112 & 0xffffffffffffffffffffffffffff)) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / (_getReserves & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff)) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n        assert(_getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff);\n        _price1CumulativeLast += (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & (_getReserves & 0xffffffffffffffffffffffffffff)) << 112 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / (_getReserves >> 112 & 0xffffffffffffffffffffffffffff & 0xffffffffffffffffffffffffffff)) * uint32(uint32(block.timestamp) - uint32(_getReserves >> 224));\n    }\n    _getReserves = uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves));\n    emit Sync(0xffffffffffffffffffffffffffff & (uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves))), 0xffffffffffffffffffffffffffff & (uint32(block.timestamp) << 224 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & ((0xffffffffffffffffffffffffffff & v3) << 112 | 0xffffffff0000000000000000000000000000ffffffffffffffffffffffffffff & (0xffffffffffffffffffffffffffff & v1 | 0xffffffffffffffffffffffffffffffffffff0000000000000000000000000000 & _getReserves))) >> 112);\n    _sync = 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x6a627842 > v0) {\n            if (0x23b872dd > v0) {\n                if (0x95ea7b3 > v0) {\n                    if (0x22c0d9f == v0) {\n                        swap(uint256,uint256,address,bytes);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else {\n                        require(0x902f1ac == v0);\n                        getReserves();\n                    }\n                } else if (0x95ea7b3 == v0) {\n                    approve(address,uint256);\n                } else if (0xdfe1681 == v0) {\n                    token0();\n                } else {\n                    require(0x18160ddd == v0);\n                    totalSupply();\n                }\n            } else if (0x3644e515 > v0) {\n                if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x30adf81f == v0) {\n                    PERMIT_TYPEHASH();\n                } else {\n                    require(0x313ce567 == v0);\n                    decimals();\n                }\n            } else if (0x3644e515 == v0) {\n                DOMAIN_SEPARATOR();\n            } else if (0x485cc955 == v0) {\n                initialize(address,address);\n            } else if (0x5909c0d5 == v0) {\n                price0CumulativeLast();\n            } else {\n                require(0x5a3d5493 == v0);\n                price1CumulativeLast();\n            }\n        } else if (0xba9a7a56 > v0) {\n            if (0x7ecebe00 > v0) {\n                if (0x6a627842 == v0) {\n                    mint(address);\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else {\n                    require(0x7464fc3d == v0);\n                    kLast();\n                }\n            } else if (0x7ecebe00 == v0) {\n                nonces(address);\n            } else if (0x89afcb44 == v0) {\n                burn(address);\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else {\n                require(0xa9059cbb == v0);\n                transfer(address,uint256);\n            }\n        } else if (0xd21220a7 > v0) {\n            if (0xba9a7a56 == v0) {\n                MINIMUM_LIQUIDITY();\n            } else if (0xbc25cf77 == v0) {\n                skim(address);\n            } else {\n                require(0xc45a0155 == v0);\n                factory();\n            }\n        } else if (0xd21220a7 == v0) {\n            token1();\n        } else if (0xd505accf == v0) {\n            permit(address,address,uint256,uint256,uint8,bytes32,bytes32);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else {\n            require(0xfff6cae9 == v0);\n            sync();\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 33.47280764579773,
	"usage": {
		"completion_tokens": 795,
		"prompt_tokens": 8489,
		"total_tokens": 9284
	}
}