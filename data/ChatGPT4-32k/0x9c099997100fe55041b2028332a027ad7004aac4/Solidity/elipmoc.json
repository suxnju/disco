{
	"address": "0x9c099997100fe55041b2028332a027ad7004aac4",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code you've provided, it appears to represent a smart contract for a token sale (or ICO). Here's a simplified Solidity version of the code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract TokenSale {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => bool) public whiteList;\n    uint256 public tokenOwnerNumber;\n    address public reopenSale;\n    bool public crowdsaleClosed;\n    address public beneficiary;\n    bool public halted;\n    uint256 public price;\n    uint256 public discountPrice;\n    uint256 public tokensContractBalance;\n    uint256 public startTime;\n    uint256 public duration;\n\n    event FundTransfer(address user, uint256 amount, bool isContribution);\n\n    modifier onlyOwner {\n        require(msg.sender == reopenSale, \"Only owner can call this function\");\n        _;\n    }\n\n    function buyTokens() public payable {\n        require(!halted, \"Sale is halted\");\n        require(block.timestamp >= startTime, \"Sale has not started yet\");\n        require(block.timestamp <= startTime + duration, \"Sale is over\");\n        require(msg.value >= 1 ether, \"Not enough ether sent\"); // 0x15af1d78b58c40000 in wei is approximately 1 ether\n        require(!crowdsaleClosed, \"Crowdsale is closed\");\n        require(tokensContractBalance > 0, \"No tokens left\");\n\n        uint256 amount = msg.value / price;\n\n        if (msg.value >= 10 ether) { // 0x56bc75e2d63100000 in wei is approximately 10 ether\n            amount = msg.value / discountPrice;\n        }\n\n        require(amount <= tokensContractBalance, \"Not enough tokens left\");\n\n        balanceOf[msg.sender] += amount;\n        tokensContractBalance -= amount;\n\n        emit FundTransfer(msg.sender, amount, true);\n    }\n\n    function joinWhiteList(address user) public onlyOwner {\n        whiteList[user] = true;\n    }\n\n    function finalizeSale() public onlyOwner {\n        crowdsaleClosed = true;\n    }\n\n    function halt() public onlyOwner {\n        halted = true;\n    }\n\n    // Other functions such as setPrice, setDiscount, etc. would go here.\n}\n```\nThis code is a simplified version and may not cover all the functionality of the original bytecode. You need to adjust it to fit your requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464160,
	"id": "chatcmpl-8R4qGfUsbQaXoXwlpgabNZD3zDrdP",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 03:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _duration; // STORAGE[0x4]\nuint256 _tokensContractBalance; // STORAGE[0x5]\nuint256 _price; // STORAGE[0x6]\nuint256 _discountPrice; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _whiteList; // STORAGE[0xa]\nuint256 _tokenOwnerNumber; // STORAGE[0xc]\naddress _reopenSale; // STORAGE[0x0] bytes 0 to 19\nuint8 _crowdsaleClosed; // STORAGE[0xb] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x2] bytes 0 to 19\nuint8 _halted; // STORAGE[0x0] bytes 20 to 20\naddress _tokenReward; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\n\nfunction fallback() public payable { \n    require(!_halted);\n    require(block.timestamp >= _startTime);\n    require(block.timestamp <= _startTime + _duration);\n    require(msg.value >= 0x15af1d78b58c40000);\n    require(!_crowdsaleClosed);\n    require(_tokensContractBalance > 0);\n    require(1 == 0xff & _whiteList[msg.sender]);\n    v0 = v1 = _price;\n    if (!_balanceOf[msg.sender]) {\n        require(_tokenOwnerNumber < 120);\n        _tokenOwnerNumber += 1;\n    }\n    if (msg.value >= 0x56bc75e2d63100000) {\n        v0 = v2 = _discountPrice;\n    }\n    assert(v0);\n    v3 = v4 = msg.value / v0;\n    if (v4 <= _tokensContractBalance) {\n        _balanceOf[msg.sender] += msg.value;\n    } else {\n        v3 = v5 = _tokensContractBalance;\n        v6 = msg.sender.call().value(msg.value - v0 * v5).gas(2300 * !(msg.value - v0 * v5));\n        require(v6);\n        emit FundTransfer(msg.sender, msg.value - v0 * v5, 1);\n        _balanceOf[msg.sender] += msg.value - (msg.value - v0 * v5);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v7, v8 = _tokenReward.transfer(msg.sender, v3).gas(msg.gas - 710);\n    require(v7);\n    emit FundTransfer(msg.sender, v3, 1);\n    _tokensContractBalance = _tokensContractBalance - v3;\n}\n\nfunction joinWhiteList(address varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _whiteList[varg0] = 0x1 | ~0xff & _whiteList[varg0];\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction tokensContractBalance() public nonPayable { \n    return _tokensContractBalance;\n}\n\nfunction tokenOwnerNumber() public nonPayable { \n    return _tokenOwnerNumber;\n}\n\nfunction minPurchase() public nonPayable { \n    return 0x15af1d78b58c40000;\n}\n\nfunction whiteList(address varg0) public nonPayable { \n    return 0xff & _whiteList[varg0];\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction finalizeSale() public nonPayable { \n    require(_reopenSale == msg.sender);\n    require(!_crowdsaleClosed);\n    _crowdsaleClosed = 1;\n}\n\nfunction halt() public nonPayable { \n    require(_reopenSale == msg.sender);\n    _halted = 1;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction discountPrice() public nonPayable { \n    return _discountPrice;\n}\n\nfunction owner() public nonPayable { \n    return _reopenSale;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _price = varg0;\n        goto 0x4200x5fd;\n    }\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction tokenWithdrawal(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(_beneficiary, varg0).gas(msg.gas - 710);\n    require(v0);\n    _tokensContractBalance = _tokensContractBalance - varg0;\n}\n\nfunction fundWithdrawal(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    v0 = _beneficiary.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction halted() public nonPayable { \n    return _halted;\n}\n\nfunction unhalt() public nonPayable { \n    require(_reopenSale == msg.sender);\n    require(_halted);\n    _halted = 0;\n}\n\nfunction crowdsaleClosed() public nonPayable { \n    return _crowdsaleClosed;\n}\n\nfunction setDiscount(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _discountPrice = varg0;\n        goto 0x4200x68b;\n    }\n}\n\nfunction changeBeneficiary(address varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _beneficiary = varg0;\n        goto 0x4200x6a1;\n    }\n}\n\nfunction discountValue() public nonPayable { \n    return 0x56bc75e2d63100000;\n}\n\nfunction tokenOwnerNumberMax() public nonPayable { \n    return 120;\n}\n\nfunction reopenSale() public nonPayable { \n    require(_reopenSale == msg.sender);\n    _crowdsaleClosed = 0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x10066ad) {\n            joinWhiteList(address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0xfb5a6b4 == v0) {\n            duration();\n        } else if (0x126af4af == v0) {\n            tokensContractBalance();\n        } else if (0x17f8252e == v0) {\n            tokenOwnerNumber();\n        } else if (0x33b5b62e == v0) {\n            minPurchase();\n        } else if (0x372c12b1 == v0) {\n            whiteList(address);\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x58a687ec == v0) {\n            finalizeSale();\n        } else if (0x5ed7ca5b == v0) {\n            halt();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x84ad8e8f == v0) {\n            discountPrice();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x91b7f5ed == v0) {\n            setPrice(uint256);\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xa92457a1 == v0) {\n            tokenWithdrawal(uint256);\n        } else if (0xb987ae02 == v0) {\n            fundWithdrawal(uint256);\n        } else if (0xb9b8af0b == v0) {\n            halted();\n        } else if (0xcb3e64fd == v0) {\n            unhalt();\n        } else if (0xccb07cef == v0) {\n            crowdsaleClosed();\n        } else if (0xdabd2719 == v0) {\n            setDiscount(uint256);\n        } else if (0xdc070657 == v0) {\n            changeBeneficiary(address);\n        } else if (0xe0ebd259 == v0) {\n            discountValue();\n        } else if (0xeed331f7 == v0) {\n            tokenOwnerNumberMax();\n        } else if (0xf88001d4 == v0) {\n            reopenSale();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 03:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _duration; // STORAGE[0x4]\nuint256 _tokensContractBalance; // STORAGE[0x5]\nuint256 _price; // STORAGE[0x6]\nuint256 _discountPrice; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _whiteList; // STORAGE[0xa]\nuint256 _tokenOwnerNumber; // STORAGE[0xc]\naddress _reopenSale; // STORAGE[0x0] bytes 0 to 19\nuint8 _crowdsaleClosed; // STORAGE[0xb] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x2] bytes 0 to 19\nuint8 _halted; // STORAGE[0x0] bytes 20 to 20\naddress _tokenReward; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\n\nfunction fallback() public payable { \n    require(!_halted);\n    require(block.timestamp >= _startTime);\n    require(block.timestamp <= _startTime + _duration);\n    require(msg.value >= 0x15af1d78b58c40000);\n    require(!_crowdsaleClosed);\n    require(_tokensContractBalance > 0);\n    require(1 == 0xff & _whiteList[msg.sender]);\n    v0 = v1 = _price;\n    if (!_balanceOf[msg.sender]) {\n        require(_tokenOwnerNumber < 120);\n        _tokenOwnerNumber += 1;\n    }\n    if (msg.value >= 0x56bc75e2d63100000) {\n        v0 = v2 = _discountPrice;\n    }\n    assert(v0);\n    v3 = v4 = msg.value / v0;\n    if (v4 <= _tokensContractBalance) {\n        _balanceOf[msg.sender] += msg.value;\n    } else {\n        v3 = v5 = _tokensContractBalance;\n        v6 = msg.sender.call().value(msg.value - v0 * v5).gas(2300 * !(msg.value - v0 * v5));\n        require(v6);\n        emit FundTransfer(msg.sender, msg.value - v0 * v5, 1);\n        _balanceOf[msg.sender] += msg.value - (msg.value - v0 * v5);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v7, v8 = _tokenReward.transfer(msg.sender, v3).gas(msg.gas - 710);\n    require(v7);\n    emit FundTransfer(msg.sender, v3, 1);\n    _tokensContractBalance = _tokensContractBalance - v3;\n}\n\nfunction joinWhiteList(address varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _whiteList[varg0] = 0x1 | ~0xff & _whiteList[varg0];\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction tokensContractBalance() public nonPayable { \n    return _tokensContractBalance;\n}\n\nfunction tokenOwnerNumber() public nonPayable { \n    return _tokenOwnerNumber;\n}\n\nfunction minPurchase() public nonPayable { \n    return 0x15af1d78b58c40000;\n}\n\nfunction whiteList(address varg0) public nonPayable { \n    return 0xff & _whiteList[varg0];\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction finalizeSale() public nonPayable { \n    require(_reopenSale == msg.sender);\n    require(!_crowdsaleClosed);\n    _crowdsaleClosed = 1;\n}\n\nfunction halt() public nonPayable { \n    require(_reopenSale == msg.sender);\n    _halted = 1;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction discountPrice() public nonPayable { \n    return _discountPrice;\n}\n\nfunction owner() public nonPayable { \n    return _reopenSale;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _price = varg0;\n        goto 0x4200x5fd;\n    }\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction tokenWithdrawal(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(_beneficiary, varg0).gas(msg.gas - 710);\n    require(v0);\n    _tokensContractBalance = _tokensContractBalance - varg0;\n}\n\nfunction fundWithdrawal(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    v0 = _beneficiary.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction halted() public nonPayable { \n    return _halted;\n}\n\nfunction unhalt() public nonPayable { \n    require(_reopenSale == msg.sender);\n    require(_halted);\n    _halted = 0;\n}\n\nfunction crowdsaleClosed() public nonPayable { \n    return _crowdsaleClosed;\n}\n\nfunction setDiscount(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _discountPrice = varg0;\n        goto 0x4200x68b;\n    }\n}\n\nfunction changeBeneficiary(address varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _beneficiary = varg0;\n        goto 0x4200x6a1;\n    }\n}\n\nfunction discountValue() public nonPayable { \n    return 0x56bc75e2d63100000;\n}\n\nfunction tokenOwnerNumberMax() public nonPayable { \n    return 120;\n}\n\nfunction reopenSale() public nonPayable { \n    require(_reopenSale == msg.sender);\n    _crowdsaleClosed = 0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x10066ad) {\n            joinWhiteList(address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0xfb5a6b4 == v0) {\n            duration();\n        } else if (0x126af4af == v0) {\n            tokensContractBalance();\n        } else if (0x17f8252e == v0) {\n            tokenOwnerNumber();\n        } else if (0x33b5b62e == v0) {\n            minPurchase();\n        } else if (0x372c12b1 == v0) {\n            whiteList(address);\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x58a687ec == v0) {\n            finalizeSale();\n        } else if (0x5ed7ca5b == v0) {\n            halt();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x84ad8e8f == v0) {\n            discountPrice();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x91b7f5ed == v0) {\n            setPrice(uint256);\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xa92457a1 == v0) {\n            tokenWithdrawal(uint256);\n        } else if (0xb987ae02 == v0) {\n            fundWithdrawal(uint256);\n        } else if (0xb9b8af0b == v0) {\n            halted();\n        } else if (0xcb3e64fd == v0) {\n            unhalt();\n        } else if (0xccb07cef == v0) {\n            crowdsaleClosed();\n        } else if (0xdabd2719 == v0) {\n            setDiscount(uint256);\n        } else if (0xdc070657 == v0) {\n            changeBeneficiary(address);\n        } else if (0xe0ebd259 == v0) {\n            discountValue();\n        } else if (0xeed331f7 == v0) {\n            tokenOwnerNumberMax();\n        } else if (0xf88001d4 == v0) {\n            reopenSale();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 03:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _duration; // STORAGE[0x4]\nuint256 _tokensContractBalance; // STORAGE[0x5]\nuint256 _price; // STORAGE[0x6]\nuint256 _discountPrice; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _whiteList; // STORAGE[0xa]\nuint256 _tokenOwnerNumber; // STORAGE[0xc]\naddress _reopenSale; // STORAGE[0x0] bytes 0 to 19\nuint8 _crowdsaleClosed; // STORAGE[0xb] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x2] bytes 0 to 19\nuint8 _halted; // STORAGE[0x0] bytes 20 to 20\naddress _tokenReward; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\n\nfunction fallback() public payable { \n    require(!_halted);\n    require(block.timestamp >= _startTime);\n    require(block.timestamp <= _startTime + _duration);\n    require(msg.value >= 0x15af1d78b58c40000);\n    require(!_crowdsaleClosed);\n    require(_tokensContractBalance > 0);\n    require(1 == 0xff & _whiteList[msg.sender]);\n    v0 = v1 = _price;\n    if (!_balanceOf[msg.sender]) {\n        require(_tokenOwnerNumber < 120);\n        _tokenOwnerNumber += 1;\n    }\n    if (msg.value >= 0x56bc75e2d63100000) {\n        v0 = v2 = _discountPrice;\n    }\n    assert(v0);\n    v3 = v4 = msg.value / v0;\n    if (v4 <= _tokensContractBalance) {\n        _balanceOf[msg.sender] += msg.value;\n    } else {\n        v3 = v5 = _tokensContractBalance;\n        v6 = msg.sender.call().value(msg.value - v0 * v5).gas(2300 * !(msg.value - v0 * v5));\n        require(v6);\n        emit FundTransfer(msg.sender, msg.value - v0 * v5, 1);\n        _balanceOf[msg.sender] += msg.value - (msg.value - v0 * v5);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v7, v8 = _tokenReward.transfer(msg.sender, v3).gas(msg.gas - 710);\n    require(v7);\n    emit FundTransfer(msg.sender, v3, 1);\n    _tokensContractBalance = _tokensContractBalance - v3;\n}\n\nfunction joinWhiteList(address varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _whiteList[varg0] = 0x1 | ~0xff & _whiteList[varg0];\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction tokensContractBalance() public nonPayable { \n    return _tokensContractBalance;\n}\n\nfunction tokenOwnerNumber() public nonPayable { \n    return _tokenOwnerNumber;\n}\n\nfunction minPurchase() public nonPayable { \n    return 0x15af1d78b58c40000;\n}\n\nfunction whiteList(address varg0) public nonPayable { \n    return 0xff & _whiteList[varg0];\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction finalizeSale() public nonPayable { \n    require(_reopenSale == msg.sender);\n    require(!_crowdsaleClosed);\n    _crowdsaleClosed = 1;\n}\n\nfunction halt() public nonPayable { \n    require(_reopenSale == msg.sender);\n    _halted = 1;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction discountPrice() public nonPayable { \n    return _discountPrice;\n}\n\nfunction owner() public nonPayable { \n    return _reopenSale;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _price = varg0;\n        goto 0x4200x5fd;\n    }\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction tokenWithdrawal(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(_beneficiary, varg0).gas(msg.gas - 710);\n    require(v0);\n    _tokensContractBalance = _tokensContractBalance - varg0;\n}\n\nfunction fundWithdrawal(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    v0 = _beneficiary.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction halted() public nonPayable { \n    return _halted;\n}\n\nfunction unhalt() public nonPayable { \n    require(_reopenSale == msg.sender);\n    require(_halted);\n    _halted = 0;\n}\n\nfunction crowdsaleClosed() public nonPayable { \n    return _crowdsaleClosed;\n}\n\nfunction setDiscount(uint256 varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _discountPrice = varg0;\n        goto 0x4200x68b;\n    }\n}\n\nfunction changeBeneficiary(address varg0) public nonPayable { \n    require(_reopenSale == msg.sender);\n    if (varg0) {\n        _beneficiary = varg0;\n        goto 0x4200x6a1;\n    }\n}\n\nfunction discountValue() public nonPayable { \n    return 0x56bc75e2d63100000;\n}\n\nfunction tokenOwnerNumberMax() public nonPayable { \n    return 120;\n}\n\nfunction reopenSale() public nonPayable { \n    require(_reopenSale == msg.sender);\n    _crowdsaleClosed = 0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x10066ad) {\n            joinWhiteList(address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0xfb5a6b4 == v0) {\n            duration();\n        } else if (0x126af4af == v0) {\n            tokensContractBalance();\n        } else if (0x17f8252e == v0) {\n            tokenOwnerNumber();\n        } else if (0x33b5b62e == v0) {\n            minPurchase();\n        } else if (0x372c12b1 == v0) {\n            whiteList(address);\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x58a687ec == v0) {\n            finalizeSale();\n        } else if (0x5ed7ca5b == v0) {\n            halt();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x84ad8e8f == v0) {\n            discountPrice();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x91b7f5ed == v0) {\n            setPrice(uint256);\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xa92457a1 == v0) {\n            tokenWithdrawal(uint256);\n        } else if (0xb987ae02 == v0) {\n            fundWithdrawal(uint256);\n        } else if (0xb9b8af0b == v0) {\n            halted();\n        } else if (0xcb3e64fd == v0) {\n            unhalt();\n        } else if (0xccb07cef == v0) {\n            crowdsaleClosed();\n        } else if (0xdabd2719 == v0) {\n            setDiscount(uint256);\n        } else if (0xdc070657 == v0) {\n            changeBeneficiary(address);\n        } else if (0xe0ebd259 == v0) {\n            discountValue();\n        } else if (0xeed331f7 == v0) {\n            tokenOwnerNumberMax();\n        } else if (0xf88001d4 == v0) {\n            reopenSale();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 24.166462898254395,
	"usage": {
		"completion_tokens": 495,
		"prompt_tokens": 2415,
		"total_tokens": 2910
	}
}