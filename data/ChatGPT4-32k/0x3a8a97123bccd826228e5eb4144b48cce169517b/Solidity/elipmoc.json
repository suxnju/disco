{
	"address": "0x3a8a97123bccd826228e5eb4144b48cce169517b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code based on the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Contract {\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    mapping (address => uint256) private _ethPossibleRefunds;\n    uint256 private _soldTokens;\n    mapping (address => uint256) private _whitelist;\n    uint256 private _reserves;\n    uint256 private _endBlock;\n    uint256 private _eTH_QCO;\n    uint256 private _pauseOffset;\n    uint256 private _pauseLastStart;\n    bool private _mintingFinished;\n    address private _stateControl;\n    address private _whitelistControl;\n    address private _withdrawControl;\n    address private _tokenAssignmentControl;\n    address private _teamWallet;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Whitelisted(address indexed account);\n    event MintFinished();\n    event StateTransition(uint8 oldState, uint8 newState);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b == 0 || a * b / b == a, \"Multiplication overflow\");\n        return a * b;\n    }\n\n    // Other functions are omitted for brevity\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(_reserves <= 5, \"Reserves overflow\");\n        require(_reserves == 4, \"Invalid reserves state\");\n        require(to != address(0), \"Zero address\");\n\n        uint256 availableBalance = _balanceOf[msg.sender];\n        require(value <= availableBalance, \"Insufficient balance\");\n\n        _balanceOf[msg.sender] = availableBalance - value;\n        _balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // Other functions are omitted for brevity\n}\n```\n\nPlease note that the contract provided is a high level interpretation of the decompiled EVM Bytecode and some details might be missing or might not be entirely accurate.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040264,
	"id": "chatcmpl-8Ci881PC7GGdJfdFHtyuqzVezRzqM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 13:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _ethPossibleRefunds; // STORAGE[0x3]\nuint256 _soldTokens; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x5]\nuint256 _reserves; // STORAGE[0xb]\nuint256 _endBlock; // STORAGE[0xc]\nuint256 _eTH_QCO; // STORAGE[0xd]\nuint256 _pauseOffset; // STORAGE[0x1c]\nuint256 _pauseLastStart; // STORAGE[0x1d]\nuint8 _mintingFinished; // STORAGE[0x1b] bytes 0 to 0\naddress _stateControl; // STORAGE[0x6] bytes 0 to 19\naddress _whitelistControl; // STORAGE[0x7] bytes 0 to 19\naddress _withdrawControl; // STORAGE[0x8] bytes 0 to 19\naddress _tokenAssignmentControl; // STORAGE[0x9] bytes 0 to 19\nuint160 _teamWallet; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nWhitelisted(address);\nMintFinished();\nStateTransition(uint8, uint8);\nTransfer(address, address, uint256);\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x1568(uint256 varg0) private { \n    assert(0xff & _reserves >> 160 <= 5);\n    assert(varg0 <= 5);\n    v0 = 0xff & varg0;\n    emit StateTransition(0xff & (0xff & _reserves >> 160), v0);\n    assert(varg0 <= 5);\n    _reserves = varg0 << 160 | ~0xff0000000000000000000000000000000000000000 & _reserves;\n    return ;\n}\n\nfunction fallback() public payable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 2);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(msg.value > 0);\n    require(msg.data.length < 4);\n    fallback();\n}\n\nfunction fallback() public payable { \n    require(block.number < _endBlock);\n    v0 = 0x7af(msg.value);\n    0x801(v0, msg.sender);\n    assert(msg.value + _ethPossibleRefunds[msg.sender] >= _ethPossibleRefunds[msg.sender]);\n    _ethPossibleRefunds[msg.sender] += msg.value;\n}\n\nfunction stateControl() public nonPayable { \n    return _stateControl;\n}\n\nfunction mintingFinished() public nonPayable { \n    return _mintingFinished;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (18) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffff & 'Qravity Coin Token';\n    }\n    return v0;\n}\n\nfunction endBlock() public nonPayable { \n    return _endBlock;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction calcBonus(uint256 varg0) public nonPayable { \n    v0 = 0x7af(varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction pauseOffset() public nonPayable { \n    return _pauseOffset;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    require(varg1);\n    assert(varg2 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _allowance[msg.sender] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction ETH_QCO() public nonPayable { \n    return _eTH_QCO;\n}\n\nfunction maxTotalSupply() public nonPayable { \n    return 0x33b2e3c9fd0803ce8000000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction anyoneEndICO() public nonPayable { \n    v0 = v1 = 1206;\n    v2 = v3 = 2;\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == v3);\n    require(block.number > _endBlock);\n    v4 = v5 = 2675;\n    v6 = v7 = 0;\n    v8 = v9 = 5153;\n    v10 = v11 = 50;\n    v12 = v13 = _SafeMul(100, _soldTokens);\n    while (!v10) {\n        assert(v10);\n        _balanceOf[_teamWallet] = v14;\n        emit Transfer(address(_reserves), _teamWallet, v14);\n        v15 = v16 = 5301;\n        assert(_soldTokens <= _totalSupply);\n        v17 = v18 = _totalSupply - _soldTokens;\n        while (v0 > v17) {\n            assert(v0 <= v17);\n            emit v6(v0, v4, v2);\n            _balanceOf[address(_reserves)] = v2;\n            _mintingFinished = 1;\n            emit MintFinished();\n            0x1568(4);\n            exit;\n            v2 = v17 - v0;\n            goto {'0x14fa0xa38B0x4ae', '0x14b50xa38B0x4ae'};\n            v0 = v19 = address(_reserves);\n            v4 = v20 = 0;\n            v15 = 5370;\n            v6 = v21 = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n            assert(v2 <= _balanceOf[v19]);\n            v17 = _balanceOf[v19] - v2;\n            goto 0x14a90xa38B0x4ae;\n        }\n        v0 = v14 = v12 / v10;\n        goto {'0x143e0xa38B0x4ae', '0x14210xa38B0x4ae'};\n        _totalSupply = v14;\n        v8 = v22 = 5182;\n        v10 = v23 = 100;\n        v12 = _SafeMul(22, v14);\n    }\n}\n\nfunction updateEthICOVariables(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    v0 = v1 = 0xff & _reserves >> 160 == 0;\n    if (0xff & _reserves >> 160 != 0) {\n        assert(0xff & _reserves >> 160 <= 5);\n        v0 = 0xff & _reserves >> 160 == 1;\n    }\n    require(v0);\n    require(varg0 > 0);\n    require(block.number < varg1);\n    _endBlock = varg1;\n    _eTH_QCO = varg0;\n    0x1568(1);\n}\n\nfunction abort() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 5);\n    0x1568(3);\n}\n\nfunction whitelistControl() public nonPayable { \n    return _whitelistControl;\n}\n\nfunction rescueToken(address varg0, address varg1) public nonPayable { \n    require(_tokenAssignmentControl == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(varg1, v1).gas(msg.gas - 710);\n    require(v2);\n}\n\nfunction getNextCutoffTime() public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < 6) {\n        if (v0 < 6) {\n            break;\n        }\n        assert(v0 < 6);\n        if (block.timestamp - _pauseOffset >= STORAGE[v0 + 21]) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < 6);\n            v0 = v2 = STORAGE[v0 + 21];\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction endICO() public nonPayable { \n    v0 = v1 = 1206;\n    require(_stateControl == msg.sender);\n    v2 = v3 = 2;\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == v3);\n    v4 = v5 = 2675;\n    v6 = v7 = 0;\n    v8 = v9 = 5153;\n    v10 = v11 = 50;\n    v12 = v13 = _SafeMul(100, _soldTokens);\n    while (!v10) {\n        assert(v10);\n        _balanceOf[_teamWallet] = v14;\n        emit Transfer(address(_reserves), _teamWallet, v14);\n        v15 = v16 = 5301;\n        assert(_soldTokens <= _totalSupply);\n        v17 = v18 = _totalSupply - _soldTokens;\n        while (v0 > v17) {\n            assert(v0 <= v17);\n            emit v6(v0, v4, v2);\n            _balanceOf[address(_reserves)] = v2;\n            _mintingFinished = 1;\n            emit MintFinished();\n            0x1568(4);\n            exit;\n            v2 = v17 - v0;\n            goto {'0x14b50xc84B0x53a', '0x14fa0xc84B0x53a'};\n            v0 = v19 = address(_reserves);\n            v4 = v20 = 0;\n            v15 = 5370;\n            v6 = v21 = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n            assert(v2 <= _balanceOf[v19]);\n            v17 = _balanceOf[v19] - v2;\n            goto 0x14a90xc84B0x53a;\n        }\n        v0 = v14 = v12 / v10;\n        goto {'0x143e0xc84B0x53a', '0x14210xc84B0x53a'};\n        _totalSupply = v14;\n        v8 = v22 = 5182;\n        v10 = v23 = 100;\n        v12 = _SafeMul(22, v14);\n    }\n}\n\nfunction teamWallet() public nonPayable { \n    return _teamWallet;\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction withdrawControl() public nonPayable { \n    return _withdrawControl;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction reserves() public nonPayable { \n    return address(_reserves);\n}\n\nfunction getCurrentBonusFactor() public nonPayable { \n    v0 = 0xe10();\n    return v0;\n}\n\nfunction startICO() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 1);\n    require(block.number < _endBlock);\n    0x1568(2);\n}\n\nfunction pause() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 2);\n    0x1568(5);\n    _pauseLastStart = block.timestamp;\n}\n\nfunction requestPayout(uint256 varg0) public nonPayable { \n    require(_withdrawControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    v0 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x51434f0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return 0xff & _whitelist[varg0];\n}\n\nfunction resumeICO() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 5);\n    0x1568(2);\n    _pauseOffset = _pauseOffset + (block.timestamp - _pauseLastStart);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    require(varg0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction percentForSale() public nonPayable { \n    return 50;\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    return 0xff & (0xff & _reserves >> 160);\n}\n\nfunction pauseLastStart() public nonPayable { \n    return _pauseLastStart;\n}\n\nfunction tokenAssignmentControl() public nonPayable { \n    return _tokenAssignmentControl;\n}\n\nfunction addPresaleAmount(address varg0, uint256 varg1) public nonPayable { \n    require(_tokenAssignmentControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    v0 = v1 = 0xff & _reserves >> 160 == 1;\n    if (0xff & _reserves >> 160 != 1) {\n        assert(0xff & _reserves >> 160 <= 5);\n        v0 = 0xff & _reserves >> 160 == 2;\n    }\n    require(v0);\n    0x801(varg1, varg0);\n}\n\nfunction requestRefund() public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 3);\n    require(_ethPossibleRefunds[msg.sender] > 0);\n    _ethPossibleRefunds[msg.sender] = 0;\n    v0 = msg.sender.call().value(_ethPossibleRefunds[msg.sender]).gas(2300 * !_ethPossibleRefunds[msg.sender]);\n    require(v0);\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 + _allowance[varg0] >= _allowance[varg0]);\n    _allowance[varg0] += varg1;\n    emit Approval(msg.sender, varg0, varg1 + _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction addToWhitelist(address varg0) public nonPayable { \n    require(_whitelistControl == msg.sender);\n    _whitelist[varg0] = 0x1 | ~0xff & _whitelist[varg0];\n    emit Whitelisted(varg0);\n}\n\nfunction ethPossibleRefunds(address varg0) public nonPayable { \n    return _ethPossibleRefunds[varg0];\n}\n\nfunction 0x7af(uint256 varg0) private { \n    v0 = _SafeMul(_eTH_QCO, varg0);\n    v1 = 0xe10();\n    v2 = _SafeMul(v1 + 1000, v0);\n    assert(1000);\n    return v2 / 1000;\n}\n\nfunction 0x801(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + _soldTokens;\n    assert(v0 >= _soldTokens);\n    v1 = _SafeMul(50, 0x33b2e3c9fd0803ce8000000);\n    assert(100);\n    require(v0 <= v1 / 100);\n    v2 = address(varg1);\n    v3 = varg0 + _balanceOf[v2];\n    assert(v3 >= _balanceOf[v2]);\n    v4 = address(varg1);\n    _balanceOf[v4] = v3;\n    assert(varg0 <= _balanceOf[address(_reserves)]);\n    _balanceOf[address(_reserves)] = _balanceOf[address(_reserves)] - varg0;\n    _soldTokens = v0;\n    emit Transfer(address(_reserves), address(varg1), varg0);\n    return ;\n}\n\nfunction 0xe10() private { \n    v0 = v1 = 0;\n    v0 = v2 = 6;\n    while (v0 < v2) {\n        assert(v0 < 6);\n        if (block.timestamp - _pauseOffset >= STORAGE[v0 + 21]) {\n            v0 += 1;\n        } else {\n            break;\n        }\n    }\n    assert(v0 < 7);\n    return STORAGE[v0 + 14];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x4b2bf99) {\n            stateControl();\n        } else if (0x5d2035b == v0) {\n            mintingFinished();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x83c6323 == v0) {\n            endBlock();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x9f3ad26 == v0) {\n            calcBonus(uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x2344acdf == v0) {\n            pauseOffset();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x28250d43 == v0) {\n            ETH_QCO();\n        } else if (0x2ab4d052 == v0) {\n            maxTotalSupply();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x32b3c323 == v0) {\n            anyoneEndICO();\n        } else if (0x34bb3ee1 == v0) {\n            updateEthICOVariables(uint256,uint256);\n        } else if (0x35a063b4 == v0) {\n            abort();\n        } else if (0x41f1d4dd == v0) {\n            whitelistControl();\n        } else if (0x4707d000 == v0) {\n            rescueToken(address,address);\n        } else if (0x47f8b863 == v0) {\n            getNextCutoffTime();\n        } else if (0x4f248409 == v0) {\n            endICO();\n        } else if (0x59927044 == v0) {\n            teamWallet();\n        } else if (0x5ed9ebfc == v0) {\n            soldTokens();\n        } else if (0x66188463 == v0) {\n            decreaseApproval(address,uint256);\n        } else if (0x6aa9c82b == v0) {\n            withdrawControl();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x75172a8b == v0) {\n            reserves();\n        } else if (0x7d363720 == v0) {\n            getCurrentBonusFactor();\n        } else if (0x7fa8c158 == v0) {\n            startICO();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8f97e3a0 == v0) {\n            requestPayout(uint256);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x9b19251a == v0) {\n            whitelist(address);\n        } else if (0x9cbd7da5 == v0) {\n            resumeICO();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xb21ed44e == v0) {\n            percentForSale();\n        } else if (0xc19d93fb == v0) {\n            state();\n        } else if (0xc4bebd69 == v0) {\n            pauseLastStart();\n        } else if (0xc8c2ed54 == v0) {\n            tokenAssignmentControl();\n        } else if (0xcc577f38 == v0) {\n            addPresaleAmount(address,uint256);\n        } else if (0xd5cef133 == v0) {\n            requestRefund();\n        } else if (0xd73dd623 == v0) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xe43252d7 == v0) {\n            addToWhitelist(address);\n        } else if (0xf8b1fb12 == v0) {\n            ethPossibleRefunds(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 13:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _ethPossibleRefunds; // STORAGE[0x3]\nuint256 _soldTokens; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x5]\nuint256 _reserves; // STORAGE[0xb]\nuint256 _endBlock; // STORAGE[0xc]\nuint256 _eTH_QCO; // STORAGE[0xd]\nuint256 _pauseOffset; // STORAGE[0x1c]\nuint256 _pauseLastStart; // STORAGE[0x1d]\nuint8 _mintingFinished; // STORAGE[0x1b] bytes 0 to 0\naddress _stateControl; // STORAGE[0x6] bytes 0 to 19\naddress _whitelistControl; // STORAGE[0x7] bytes 0 to 19\naddress _withdrawControl; // STORAGE[0x8] bytes 0 to 19\naddress _tokenAssignmentControl; // STORAGE[0x9] bytes 0 to 19\nuint160 _teamWallet; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nWhitelisted(address);\nMintFinished();\nStateTransition(uint8, uint8);\nTransfer(address, address, uint256);\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x1568(uint256 varg0) private { \n    assert(0xff & _reserves >> 160 <= 5);\n    assert(varg0 <= 5);\n    v0 = 0xff & varg0;\n    emit StateTransition(0xff & (0xff & _reserves >> 160), v0);\n    assert(varg0 <= 5);\n    _reserves = varg0 << 160 | ~0xff0000000000000000000000000000000000000000 & _reserves;\n    return ;\n}\n\nfunction fallback() public payable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 2);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(msg.value > 0);\n    require(msg.data.length < 4);\n    fallback();\n}\n\nfunction fallback() public payable { \n    require(block.number < _endBlock);\n    v0 = 0x7af(msg.value);\n    0x801(v0, msg.sender);\n    assert(msg.value + _ethPossibleRefunds[msg.sender] >= _ethPossibleRefunds[msg.sender]);\n    _ethPossibleRefunds[msg.sender] += msg.value;\n}\n\nfunction stateControl() public nonPayable { \n    return _stateControl;\n}\n\nfunction mintingFinished() public nonPayable { \n    return _mintingFinished;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (18) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffff & 'Qravity Coin Token';\n    }\n    return v0;\n}\n\nfunction endBlock() public nonPayable { \n    return _endBlock;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction calcBonus(uint256 varg0) public nonPayable { \n    v0 = 0x7af(varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction pauseOffset() public nonPayable { \n    return _pauseOffset;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    require(varg1);\n    assert(varg2 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _allowance[msg.sender] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction ETH_QCO() public nonPayable { \n    return _eTH_QCO;\n}\n\nfunction maxTotalSupply() public nonPayable { \n    return 0x33b2e3c9fd0803ce8000000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction anyoneEndICO() public nonPayable { \n    v0 = v1 = 1206;\n    v2 = v3 = 2;\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == v3);\n    require(block.number > _endBlock);\n    v4 = v5 = 2675;\n    v6 = v7 = 0;\n    v8 = v9 = 5153;\n    v10 = v11 = 50;\n    v12 = v13 = _SafeMul(100, _soldTokens);\n    while (!v10) {\n        assert(v10);\n        _balanceOf[_teamWallet] = v14;\n        emit Transfer(address(_reserves), _teamWallet, v14);\n        v15 = v16 = 5301;\n        assert(_soldTokens <= _totalSupply);\n        v17 = v18 = _totalSupply - _soldTokens;\n        while (v0 > v17) {\n            assert(v0 <= v17);\n            emit v6(v0, v4, v2);\n            _balanceOf[address(_reserves)] = v2;\n            _mintingFinished = 1;\n            emit MintFinished();\n            0x1568(4);\n            exit;\n            v2 = v17 - v0;\n            goto {'0x14fa0xa38B0x4ae', '0x14b50xa38B0x4ae'};\n            v0 = v19 = address(_reserves);\n            v4 = v20 = 0;\n            v15 = 5370;\n            v6 = v21 = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n            assert(v2 <= _balanceOf[v19]);\n            v17 = _balanceOf[v19] - v2;\n            goto 0x14a90xa38B0x4ae;\n        }\n        v0 = v14 = v12 / v10;\n        goto {'0x143e0xa38B0x4ae', '0x14210xa38B0x4ae'};\n        _totalSupply = v14;\n        v8 = v22 = 5182;\n        v10 = v23 = 100;\n        v12 = _SafeMul(22, v14);\n    }\n}\n\nfunction updateEthICOVariables(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    v0 = v1 = 0xff & _reserves >> 160 == 0;\n    if (0xff & _reserves >> 160 != 0) {\n        assert(0xff & _reserves >> 160 <= 5);\n        v0 = 0xff & _reserves >> 160 == 1;\n    }\n    require(v0);\n    require(varg0 > 0);\n    require(block.number < varg1);\n    _endBlock = varg1;\n    _eTH_QCO = varg0;\n    0x1568(1);\n}\n\nfunction abort() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 5);\n    0x1568(3);\n}\n\nfunction whitelistControl() public nonPayable { \n    return _whitelistControl;\n}\n\nfunction rescueToken(address varg0, address varg1) public nonPayable { \n    require(_tokenAssignmentControl == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(varg1, v1).gas(msg.gas - 710);\n    require(v2);\n}\n\nfunction getNextCutoffTime() public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < 6) {\n        if (v0 < 6) {\n            break;\n        }\n        assert(v0 < 6);\n        if (block.timestamp - _pauseOffset >= STORAGE[v0 + 21]) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < 6);\n            v0 = v2 = STORAGE[v0 + 21];\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction endICO() public nonPayable { \n    v0 = v1 = 1206;\n    require(_stateControl == msg.sender);\n    v2 = v3 = 2;\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == v3);\n    v4 = v5 = 2675;\n    v6 = v7 = 0;\n    v8 = v9 = 5153;\n    v10 = v11 = 50;\n    v12 = v13 = _SafeMul(100, _soldTokens);\n    while (!v10) {\n        assert(v10);\n        _balanceOf[_teamWallet] = v14;\n        emit Transfer(address(_reserves), _teamWallet, v14);\n        v15 = v16 = 5301;\n        assert(_soldTokens <= _totalSupply);\n        v17 = v18 = _totalSupply - _soldTokens;\n        while (v0 > v17) {\n            assert(v0 <= v17);\n            emit v6(v0, v4, v2);\n            _balanceOf[address(_reserves)] = v2;\n            _mintingFinished = 1;\n            emit MintFinished();\n            0x1568(4);\n            exit;\n            v2 = v17 - v0;\n            goto {'0x14b50xc84B0x53a', '0x14fa0xc84B0x53a'};\n            v0 = v19 = address(_reserves);\n            v4 = v20 = 0;\n            v15 = 5370;\n            v6 = v21 = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n            assert(v2 <= _balanceOf[v19]);\n            v17 = _balanceOf[v19] - v2;\n            goto 0x14a90xc84B0x53a;\n        }\n        v0 = v14 = v12 / v10;\n        goto {'0x143e0xc84B0x53a', '0x14210xc84B0x53a'};\n        _totalSupply = v14;\n        v8 = v22 = 5182;\n        v10 = v23 = 100;\n        v12 = _SafeMul(22, v14);\n    }\n}\n\nfunction teamWallet() public nonPayable { \n    return _teamWallet;\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction withdrawControl() public nonPayable { \n    return _withdrawControl;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction reserves() public nonPayable { \n    return address(_reserves);\n}\n\nfunction getCurrentBonusFactor() public nonPayable { \n    v0 = 0xe10();\n    return v0;\n}\n\nfunction startICO() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 1);\n    require(block.number < _endBlock);\n    0x1568(2);\n}\n\nfunction pause() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 2);\n    0x1568(5);\n    _pauseLastStart = block.timestamp;\n}\n\nfunction requestPayout(uint256 varg0) public nonPayable { \n    require(_withdrawControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    v0 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x51434f0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return 0xff & _whitelist[varg0];\n}\n\nfunction resumeICO() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 5);\n    0x1568(2);\n    _pauseOffset = _pauseOffset + (block.timestamp - _pauseLastStart);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    require(varg0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction percentForSale() public nonPayable { \n    return 50;\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    return 0xff & (0xff & _reserves >> 160);\n}\n\nfunction pauseLastStart() public nonPayable { \n    return _pauseLastStart;\n}\n\nfunction tokenAssignmentControl() public nonPayable { \n    return _tokenAssignmentControl;\n}\n\nfunction addPresaleAmount(address varg0, uint256 varg1) public nonPayable { \n    require(_tokenAssignmentControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    v0 = v1 = 0xff & _reserves >> 160 == 1;\n    if (0xff & _reserves >> 160 != 1) {\n        assert(0xff & _reserves >> 160 <= 5);\n        v0 = 0xff & _reserves >> 160 == 2;\n    }\n    require(v0);\n    0x801(varg1, varg0);\n}\n\nfunction requestRefund() public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 3);\n    require(_ethPossibleRefunds[msg.sender] > 0);\n    _ethPossibleRefunds[msg.sender] = 0;\n    v0 = msg.sender.call().value(_ethPossibleRefunds[msg.sender]).gas(2300 * !_ethPossibleRefunds[msg.sender]);\n    require(v0);\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 + _allowance[varg0] >= _allowance[varg0]);\n    _allowance[varg0] += varg1;\n    emit Approval(msg.sender, varg0, varg1 + _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction addToWhitelist(address varg0) public nonPayable { \n    require(_whitelistControl == msg.sender);\n    _whitelist[varg0] = 0x1 | ~0xff & _whitelist[varg0];\n    emit Whitelisted(varg0);\n}\n\nfunction ethPossibleRefunds(address varg0) public nonPayable { \n    return _ethPossibleRefunds[varg0];\n}\n\nfunction 0x7af(uint256 varg0) private { \n    v0 = _SafeMul(_eTH_QCO, varg0);\n    v1 = 0xe10();\n    v2 = _SafeMul(v1 + 1000, v0);\n    assert(1000);\n    return v2 / 1000;\n}\n\nfunction 0x801(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + _soldTokens;\n    assert(v0 >= _soldTokens);\n    v1 = _SafeMul(50, 0x33b2e3c9fd0803ce8000000);\n    assert(100);\n    require(v0 <= v1 / 100);\n    v2 = address(varg1);\n    v3 = varg0 + _balanceOf[v2];\n    assert(v3 >= _balanceOf[v2]);\n    v4 = address(varg1);\n    _balanceOf[v4] = v3;\n    assert(varg0 <= _balanceOf[address(_reserves)]);\n    _balanceOf[address(_reserves)] = _balanceOf[address(_reserves)] - varg0;\n    _soldTokens = v0;\n    emit Transfer(address(_reserves), address(varg1), varg0);\n    return ;\n}\n\nfunction 0xe10() private { \n    v0 = v1 = 0;\n    v0 = v2 = 6;\n    while (v0 < v2) {\n        assert(v0 < 6);\n        if (block.timestamp - _pauseOffset >= STORAGE[v0 + 21]) {\n            v0 += 1;\n        } else {\n            break;\n        }\n    }\n    assert(v0 < 7);\n    return STORAGE[v0 + 14];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x4b2bf99) {\n            stateControl();\n        } else if (0x5d2035b == v0) {\n            mintingFinished();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x83c6323 == v0) {\n            endBlock();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x9f3ad26 == v0) {\n            calcBonus(uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x2344acdf == v0) {\n            pauseOffset();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x28250d43 == v0) {\n            ETH_QCO();\n        } else if (0x2ab4d052 == v0) {\n            maxTotalSupply();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x32b3c323 == v0) {\n            anyoneEndICO();\n        } else if (0x34bb3ee1 == v0) {\n            updateEthICOVariables(uint256,uint256);\n        } else if (0x35a063b4 == v0) {\n            abort();\n        } else if (0x41f1d4dd == v0) {\n            whitelistControl();\n        } else if (0x4707d000 == v0) {\n            rescueToken(address,address);\n        } else if (0x47f8b863 == v0) {\n            getNextCutoffTime();\n        } else if (0x4f248409 == v0) {\n            endICO();\n        } else if (0x59927044 == v0) {\n            teamWallet();\n        } else if (0x5ed9ebfc == v0) {\n            soldTokens();\n        } else if (0x66188463 == v0) {\n            decreaseApproval(address,uint256);\n        } else if (0x6aa9c82b == v0) {\n            withdrawControl();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x75172a8b == v0) {\n            reserves();\n        } else if (0x7d363720 == v0) {\n            getCurrentBonusFactor();\n        } else if (0x7fa8c158 == v0) {\n            startICO();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8f97e3a0 == v0) {\n            requestPayout(uint256);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x9b19251a == v0) {\n            whitelist(address);\n        } else if (0x9cbd7da5 == v0) {\n            resumeICO();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xb21ed44e == v0) {\n            percentForSale();\n        } else if (0xc19d93fb == v0) {\n            state();\n        } else if (0xc4bebd69 == v0) {\n            pauseLastStart();\n        } else if (0xc8c2ed54 == v0) {\n            tokenAssignmentControl();\n        } else if (0xcc577f38 == v0) {\n            addPresaleAmount(address,uint256);\n        } else if (0xd5cef133 == v0) {\n            requestRefund();\n        } else if (0xd73dd623 == v0) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xe43252d7 == v0) {\n            addToWhitelist(address);\n        } else if (0xf8b1fb12 == v0) {\n            ethPossibleRefunds(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 13:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _ethPossibleRefunds; // STORAGE[0x3]\nuint256 _soldTokens; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x5]\nuint256 _reserves; // STORAGE[0xb]\nuint256 _endBlock; // STORAGE[0xc]\nuint256 _eTH_QCO; // STORAGE[0xd]\nuint256 _pauseOffset; // STORAGE[0x1c]\nuint256 _pauseLastStart; // STORAGE[0x1d]\nuint8 _mintingFinished; // STORAGE[0x1b] bytes 0 to 0\naddress _stateControl; // STORAGE[0x6] bytes 0 to 19\naddress _whitelistControl; // STORAGE[0x7] bytes 0 to 19\naddress _withdrawControl; // STORAGE[0x8] bytes 0 to 19\naddress _tokenAssignmentControl; // STORAGE[0x9] bytes 0 to 19\nuint160 _teamWallet; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nWhitelisted(address);\nMintFinished();\nStateTransition(uint8, uint8);\nTransfer(address, address, uint256);\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x1568(uint256 varg0) private { \n    assert(0xff & _reserves >> 160 <= 5);\n    assert(varg0 <= 5);\n    v0 = 0xff & varg0;\n    emit StateTransition(0xff & (0xff & _reserves >> 160), v0);\n    assert(varg0 <= 5);\n    _reserves = varg0 << 160 | ~0xff0000000000000000000000000000000000000000 & _reserves;\n    return ;\n}\n\nfunction fallback() public payable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 2);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(msg.value > 0);\n    require(msg.data.length < 4);\n    fallback();\n}\n\nfunction fallback() public payable { \n    require(block.number < _endBlock);\n    v0 = 0x7af(msg.value);\n    0x801(v0, msg.sender);\n    assert(msg.value + _ethPossibleRefunds[msg.sender] >= _ethPossibleRefunds[msg.sender]);\n    _ethPossibleRefunds[msg.sender] += msg.value;\n}\n\nfunction stateControl() public nonPayable { \n    return _stateControl;\n}\n\nfunction mintingFinished() public nonPayable { \n    return _mintingFinished;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (18) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffff & 'Qravity Coin Token';\n    }\n    return v0;\n}\n\nfunction endBlock() public nonPayable { \n    return _endBlock;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction calcBonus(uint256 varg0) public nonPayable { \n    v0 = 0x7af(varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction pauseOffset() public nonPayable { \n    return _pauseOffset;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    require(varg1);\n    assert(varg2 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _allowance[msg.sender] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction ETH_QCO() public nonPayable { \n    return _eTH_QCO;\n}\n\nfunction maxTotalSupply() public nonPayable { \n    return 0x33b2e3c9fd0803ce8000000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction anyoneEndICO() public nonPayable { \n    v0 = v1 = 1206;\n    v2 = v3 = 2;\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == v3);\n    require(block.number > _endBlock);\n    v4 = v5 = 2675;\n    v6 = v7 = 0;\n    v8 = v9 = 5153;\n    v10 = v11 = 50;\n    v12 = v13 = _SafeMul(100, _soldTokens);\n    while (!v10) {\n        assert(v10);\n        _balanceOf[_teamWallet] = v14;\n        emit Transfer(address(_reserves), _teamWallet, v14);\n        v15 = v16 = 5301;\n        assert(_soldTokens <= _totalSupply);\n        v17 = v18 = _totalSupply - _soldTokens;\n        while (v0 > v17) {\n            assert(v0 <= v17);\n            emit v6(v0, v4, v2);\n            _balanceOf[address(_reserves)] = v2;\n            _mintingFinished = 1;\n            emit MintFinished();\n            0x1568(4);\n            exit;\n            v2 = v17 - v0;\n            goto {'0x14fa0xa38B0x4ae', '0x14b50xa38B0x4ae'};\n            v0 = v19 = address(_reserves);\n            v4 = v20 = 0;\n            v15 = 5370;\n            v6 = v21 = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n            assert(v2 <= _balanceOf[v19]);\n            v17 = _balanceOf[v19] - v2;\n            goto 0x14a90xa38B0x4ae;\n        }\n        v0 = v14 = v12 / v10;\n        goto {'0x143e0xa38B0x4ae', '0x14210xa38B0x4ae'};\n        _totalSupply = v14;\n        v8 = v22 = 5182;\n        v10 = v23 = 100;\n        v12 = _SafeMul(22, v14);\n    }\n}\n\nfunction updateEthICOVariables(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    v0 = v1 = 0xff & _reserves >> 160 == 0;\n    if (0xff & _reserves >> 160 != 0) {\n        assert(0xff & _reserves >> 160 <= 5);\n        v0 = 0xff & _reserves >> 160 == 1;\n    }\n    require(v0);\n    require(varg0 > 0);\n    require(block.number < varg1);\n    _endBlock = varg1;\n    _eTH_QCO = varg0;\n    0x1568(1);\n}\n\nfunction abort() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 5);\n    0x1568(3);\n}\n\nfunction whitelistControl() public nonPayable { \n    return _whitelistControl;\n}\n\nfunction rescueToken(address varg0, address varg1) public nonPayable { \n    require(_tokenAssignmentControl == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(varg1, v1).gas(msg.gas - 710);\n    require(v2);\n}\n\nfunction getNextCutoffTime() public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < 6) {\n        if (v0 < 6) {\n            break;\n        }\n        assert(v0 < 6);\n        if (block.timestamp - _pauseOffset >= STORAGE[v0 + 21]) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < 6);\n            v0 = v2 = STORAGE[v0 + 21];\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction endICO() public nonPayable { \n    v0 = v1 = 1206;\n    require(_stateControl == msg.sender);\n    v2 = v3 = 2;\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == v3);\n    v4 = v5 = 2675;\n    v6 = v7 = 0;\n    v8 = v9 = 5153;\n    v10 = v11 = 50;\n    v12 = v13 = _SafeMul(100, _soldTokens);\n    while (!v10) {\n        assert(v10);\n        _balanceOf[_teamWallet] = v14;\n        emit Transfer(address(_reserves), _teamWallet, v14);\n        v15 = v16 = 5301;\n        assert(_soldTokens <= _totalSupply);\n        v17 = v18 = _totalSupply - _soldTokens;\n        while (v0 > v17) {\n            assert(v0 <= v17);\n            emit v6(v0, v4, v2);\n            _balanceOf[address(_reserves)] = v2;\n            _mintingFinished = 1;\n            emit MintFinished();\n            0x1568(4);\n            exit;\n            v2 = v17 - v0;\n            goto {'0x14b50xc84B0x53a', '0x14fa0xc84B0x53a'};\n            v0 = v19 = address(_reserves);\n            v4 = v20 = 0;\n            v15 = 5370;\n            v6 = v21 = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n            assert(v2 <= _balanceOf[v19]);\n            v17 = _balanceOf[v19] - v2;\n            goto 0x14a90xc84B0x53a;\n        }\n        v0 = v14 = v12 / v10;\n        goto {'0x143e0xc84B0x53a', '0x14210xc84B0x53a'};\n        _totalSupply = v14;\n        v8 = v22 = 5182;\n        v10 = v23 = 100;\n        v12 = _SafeMul(22, v14);\n    }\n}\n\nfunction teamWallet() public nonPayable { \n    return _teamWallet;\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction withdrawControl() public nonPayable { \n    return _withdrawControl;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction reserves() public nonPayable { \n    return address(_reserves);\n}\n\nfunction getCurrentBonusFactor() public nonPayable { \n    v0 = 0xe10();\n    return v0;\n}\n\nfunction startICO() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 1);\n    require(block.number < _endBlock);\n    0x1568(2);\n}\n\nfunction pause() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 2);\n    0x1568(5);\n    _pauseLastStart = block.timestamp;\n}\n\nfunction requestPayout(uint256 varg0) public nonPayable { \n    require(_withdrawControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    v0 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x51434f0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return 0xff & _whitelist[varg0];\n}\n\nfunction resumeICO() public nonPayable { \n    require(_stateControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 5);\n    0x1568(2);\n    _pauseOffset = _pauseOffset + (block.timestamp - _pauseLastStart);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 4);\n    require(varg0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction percentForSale() public nonPayable { \n    return 50;\n}\n\nfunction state() public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    return 0xff & (0xff & _reserves >> 160);\n}\n\nfunction pauseLastStart() public nonPayable { \n    return _pauseLastStart;\n}\n\nfunction tokenAssignmentControl() public nonPayable { \n    return _tokenAssignmentControl;\n}\n\nfunction addPresaleAmount(address varg0, uint256 varg1) public nonPayable { \n    require(_tokenAssignmentControl == msg.sender);\n    assert(0xff & _reserves >> 160 <= 5);\n    v0 = v1 = 0xff & _reserves >> 160 == 1;\n    if (0xff & _reserves >> 160 != 1) {\n        assert(0xff & _reserves >> 160 <= 5);\n        v0 = 0xff & _reserves >> 160 == 2;\n    }\n    require(v0);\n    0x801(varg1, varg0);\n}\n\nfunction requestRefund() public nonPayable { \n    assert(0xff & _reserves >> 160 <= 5);\n    require(0xff & _reserves >> 160 == 3);\n    require(_ethPossibleRefunds[msg.sender] > 0);\n    _ethPossibleRefunds[msg.sender] = 0;\n    v0 = msg.sender.call().value(_ethPossibleRefunds[msg.sender]).gas(2300 * !_ethPossibleRefunds[msg.sender]);\n    require(v0);\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 + _allowance[varg0] >= _allowance[varg0]);\n    _allowance[varg0] += varg1;\n    emit Approval(msg.sender, varg0, varg1 + _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction addToWhitelist(address varg0) public nonPayable { \n    require(_whitelistControl == msg.sender);\n    _whitelist[varg0] = 0x1 | ~0xff & _whitelist[varg0];\n    emit Whitelisted(varg0);\n}\n\nfunction ethPossibleRefunds(address varg0) public nonPayable { \n    return _ethPossibleRefunds[varg0];\n}\n\nfunction 0x7af(uint256 varg0) private { \n    v0 = _SafeMul(_eTH_QCO, varg0);\n    v1 = 0xe10();\n    v2 = _SafeMul(v1 + 1000, v0);\n    assert(1000);\n    return v2 / 1000;\n}\n\nfunction 0x801(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + _soldTokens;\n    assert(v0 >= _soldTokens);\n    v1 = _SafeMul(50, 0x33b2e3c9fd0803ce8000000);\n    assert(100);\n    require(v0 <= v1 / 100);\n    v2 = address(varg1);\n    v3 = varg0 + _balanceOf[v2];\n    assert(v3 >= _balanceOf[v2]);\n    v4 = address(varg1);\n    _balanceOf[v4] = v3;\n    assert(varg0 <= _balanceOf[address(_reserves)]);\n    _balanceOf[address(_reserves)] = _balanceOf[address(_reserves)] - varg0;\n    _soldTokens = v0;\n    emit Transfer(address(_reserves), address(varg1), varg0);\n    return ;\n}\n\nfunction 0xe10() private { \n    v0 = v1 = 0;\n    v0 = v2 = 6;\n    while (v0 < v2) {\n        assert(v0 < 6);\n        if (block.timestamp - _pauseOffset >= STORAGE[v0 + 21]) {\n            v0 += 1;\n        } else {\n            break;\n        }\n    }\n    assert(v0 < 7);\n    return STORAGE[v0 + 14];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x4b2bf99) {\n            stateControl();\n        } else if (0x5d2035b == v0) {\n            mintingFinished();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x83c6323 == v0) {\n            endBlock();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x9f3ad26 == v0) {\n            calcBonus(uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x2344acdf == v0) {\n            pauseOffset();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x28250d43 == v0) {\n            ETH_QCO();\n        } else if (0x2ab4d052 == v0) {\n            maxTotalSupply();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x32b3c323 == v0) {\n            anyoneEndICO();\n        } else if (0x34bb3ee1 == v0) {\n            updateEthICOVariables(uint256,uint256);\n        } else if (0x35a063b4 == v0) {\n            abort();\n        } else if (0x41f1d4dd == v0) {\n            whitelistControl();\n        } else if (0x4707d000 == v0) {\n            rescueToken(address,address);\n        } else if (0x47f8b863 == v0) {\n            getNextCutoffTime();\n        } else if (0x4f248409 == v0) {\n            endICO();\n        } else if (0x59927044 == v0) {\n            teamWallet();\n        } else if (0x5ed9ebfc == v0) {\n            soldTokens();\n        } else if (0x66188463 == v0) {\n            decreaseApproval(address,uint256);\n        } else if (0x6aa9c82b == v0) {\n            withdrawControl();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x75172a8b == v0) {\n            reserves();\n        } else if (0x7d363720 == v0) {\n            getCurrentBonusFactor();\n        } else if (0x7fa8c158 == v0) {\n            startICO();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8f97e3a0 == v0) {\n            requestPayout(uint256);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x9b19251a == v0) {\n            whitelist(address);\n        } else if (0x9cbd7da5 == v0) {\n            resumeICO();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xb21ed44e == v0) {\n            percentForSale();\n        } else if (0xc19d93fb == v0) {\n            state();\n        } else if (0xc4bebd69 == v0) {\n            pauseLastStart();\n        } else if (0xc8c2ed54 == v0) {\n            tokenAssignmentControl();\n        } else if (0xcc577f38 == v0) {\n            addPresaleAmount(address,uint256);\n        } else if (0xd5cef133 == v0) {\n            requestRefund();\n        } else if (0xd73dd623 == v0) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xe43252d7 == v0) {\n            addToWhitelist(address);\n        } else if (0xf8b1fb12 == v0) {\n            ethPossibleRefunds(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 26.914263248443604,
	"usage": {
		"completion_tokens": 476,
		"prompt_tokens": 5601,
		"total_tokens": 6077
	}
}