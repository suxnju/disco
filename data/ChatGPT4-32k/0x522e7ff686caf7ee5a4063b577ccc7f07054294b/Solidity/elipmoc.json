{
	"address": "0x522e7ff686caf7ee5a4063b577ccc7f07054294b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code reconstructed from the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract RedeemableToken {\n    uint256 private _exchangeRate;\n    uint256 private _expirationTime;\n    address private _admin;\n    bool private _active;\n    address private _token;\n\n    event TokenClaim(address indexed from, address indexed to, uint256 value, uint256 varg1);\n    event Redemption(address indexed from, uint256 value, uint256 varg0);\n\n    function active() public view returns(bool) {\n        return _active;\n    }\n\n    function exchangeRate() public view returns(uint256) {\n        return _exchangeRate;\n    }\n\n    function adminWithdrawMiscTokens(address varg0, uint256 varg1) public {\n        require(!_active);\n        require(msg.sender == _admin);\n        bool v0;\n        bytes memory v1;\n        (v0, v1) = varg0.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, varg1));\n        require(v0);\n        emit TokenClaim(varg0, msg.sender, 0, varg1);\n    }\n\n    function adminWithdraw(uint256 varg0) public {\n        require(!_active);\n        require(msg.sender == _admin);\n        (bool v0, ) = msg.sender.call{value: varg0}(\"\");\n        require(v0);\n        emit Redemption(msg.sender, 0, varg0);\n    }\n\n    function adminWithdrawTokens(uint256 varg0) public {\n        require(!_active);\n        require(msg.sender == _admin);\n        bool v0;\n        bytes memory v1;\n        (v0, v1) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, varg0));\n        require(v0);\n        emit TokenClaim(_token, msg.sender, 0, varg0);\n    }\n\n    function redeemTokens(uint256 varg0) public {\n        require(_active);\n        require(block.timestamp < _expirationTime);\n        bool v0;\n        bytes memory v1;\n        (v0, v1) = _token.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), varg0));\n        require(v0);\n        uint256 v2 = varg0 / _exchangeRate;\n        (bool v3, ) = msg.sender.call{value: v2}(\"\");\n        require(v3);\n        emit Redemption(msg.sender, varg0, v2);\n    }\n\n    function expirationTime() public view returns(uint256) {\n        return _expirationTime;\n    }\n\n    function admin() public view returns(address) {\n        return _admin;\n    }\n\n    function token() public view returns(address) {\n        return _token;\n    }\n\n    function expirationCheck() private {\n        _active = block.timestamp <= _expirationTime;\n        bool v0;\n        bytes memory v1;\n        (v0, v1) = _token.call(abi.encodeWithSignature(\"balanceOf(address)\", address(this)));\n        require(v0);\n        _active = _active && (abi.decode(v1, (uint256)) >= _exchangeRate);\n    }\n\n    receive() external payable {\n        require(_active);\n        require(block.timestamp < _expirationTime);\n        uint256 varg0 = msg.value * _exchangeRate;\n        bool v0;\n        bytes memory v1;\n        (v0, v1) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, varg0));\n        require(v0);\n        expirationCheck();\n        emit TokenClaim(_token, msg.sender, msg.value, varg0);\n    }\n}\n```\n\nNote: This code is a rough reconstruction from the decompiled code and it may not compile or work as expected. It's also worth noting that the original contract might have additional safety checks and other features that aren't apparent in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461181,
	"id": "chatcmpl-8R44DYzKrZlq0MRxPknHPSybNOokg",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 00:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _exchangeRate; // STORAGE[0x2]\nuint256 _expirationTime; // STORAGE[0x3]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_2_0_0; // STORAGE[0x2] bytes 0 to 0\nuint8 _active; // STORAGE[0x4] bytes 0 to 0\naddress _token; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTokenClaim(address, address, uint256, uint256);\nRedemption(address, uint256, uint256);\n\nfunction active() public nonPayable { \n    return _active;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction adminWithdrawMiscTokens(address varg0, uint256 varg1) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    emit TokenClaim(varg0, msg.sender, 0, varg1);\n}\n\nfunction expirationCheck() public nonPayable { \n    0x488();\n}\n\nfunction adminWithdraw(uint256 varg0) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n    emit Redemption(msg.sender, 0, varg0);\n}\n\nfunction adminWithdrawTokens(uint256 varg0) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(msg.sender, varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    emit TokenClaim(_token, msg.sender, 0, varg0);\n}\n\nfunction redeemTokens(uint256 varg0) public nonPayable { \n    require(_active);\n    require(block.timestamp < _expirationTime);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transferFrom(msg.sender, address(this), varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(stor_2_0_0);\n    v2 = msg.sender.call().value(varg0 / _exchangeRate).gas(!(varg0 / _exchangeRate) * 2300);\n    require(v2);\n    emit Redemption(msg.sender, varg0, varg0 / _exchangeRate);\n}\n\nfunction expirationTime() public nonPayable { \n    return _expirationTime;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x488() private { \n    if (block.timestamp > _expirationTime) {\n        _active = 0;\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    if (v1 < _exchangeRate) {\n        _active = 0;\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(_active);\n    require(block.timestamp < _expirationTime);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(msg.sender, msg.value * _exchangeRate).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    0x488();\n    emit TokenClaim(_token, msg.sender, msg.value, msg.value * _exchangeRate);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x2fb0c5e == function_selector) {\n            active();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x4cc87328 == function_selector) {\n            adminWithdrawMiscTokens(address,uint256);\n        } else if (0x6a1b52e1 == function_selector) {\n            expirationCheck();\n        } else if (0x7c5b4a37 == function_selector) {\n            adminWithdraw(uint256);\n        } else if (0x921496a9 == function_selector) {\n            adminWithdrawTokens(uint256);\n        } else if (0xa6e158f8 == function_selector) {\n            redeemTokens(uint256);\n        } else if (0xda284dcc == function_selector) {\n            expirationTime();\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 00:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _exchangeRate; // STORAGE[0x2]\nuint256 _expirationTime; // STORAGE[0x3]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_2_0_0; // STORAGE[0x2] bytes 0 to 0\nuint8 _active; // STORAGE[0x4] bytes 0 to 0\naddress _token; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTokenClaim(address, address, uint256, uint256);\nRedemption(address, uint256, uint256);\n\nfunction active() public nonPayable { \n    return _active;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction adminWithdrawMiscTokens(address varg0, uint256 varg1) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    emit TokenClaim(varg0, msg.sender, 0, varg1);\n}\n\nfunction expirationCheck() public nonPayable { \n    0x488();\n}\n\nfunction adminWithdraw(uint256 varg0) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n    emit Redemption(msg.sender, 0, varg0);\n}\n\nfunction adminWithdrawTokens(uint256 varg0) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(msg.sender, varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    emit TokenClaim(_token, msg.sender, 0, varg0);\n}\n\nfunction redeemTokens(uint256 varg0) public nonPayable { \n    require(_active);\n    require(block.timestamp < _expirationTime);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transferFrom(msg.sender, address(this), varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(stor_2_0_0);\n    v2 = msg.sender.call().value(varg0 / _exchangeRate).gas(!(varg0 / _exchangeRate) * 2300);\n    require(v2);\n    emit Redemption(msg.sender, varg0, varg0 / _exchangeRate);\n}\n\nfunction expirationTime() public nonPayable { \n    return _expirationTime;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x488() private { \n    if (block.timestamp > _expirationTime) {\n        _active = 0;\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    if (v1 < _exchangeRate) {\n        _active = 0;\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(_active);\n    require(block.timestamp < _expirationTime);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(msg.sender, msg.value * _exchangeRate).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    0x488();\n    emit TokenClaim(_token, msg.sender, msg.value, msg.value * _exchangeRate);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x2fb0c5e == function_selector) {\n            active();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x4cc87328 == function_selector) {\n            adminWithdrawMiscTokens(address,uint256);\n        } else if (0x6a1b52e1 == function_selector) {\n            expirationCheck();\n        } else if (0x7c5b4a37 == function_selector) {\n            adminWithdraw(uint256);\n        } else if (0x921496a9 == function_selector) {\n            adminWithdrawTokens(uint256);\n        } else if (0xa6e158f8 == function_selector) {\n            redeemTokens(uint256);\n        } else if (0xda284dcc == function_selector) {\n            expirationTime();\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 00:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _exchangeRate; // STORAGE[0x2]\nuint256 _expirationTime; // STORAGE[0x3]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_2_0_0; // STORAGE[0x2] bytes 0 to 0\nuint8 _active; // STORAGE[0x4] bytes 0 to 0\naddress _token; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTokenClaim(address, address, uint256, uint256);\nRedemption(address, uint256, uint256);\n\nfunction active() public nonPayable { \n    return _active;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction adminWithdrawMiscTokens(address varg0, uint256 varg1) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    emit TokenClaim(varg0, msg.sender, 0, varg1);\n}\n\nfunction expirationCheck() public nonPayable { \n    0x488();\n}\n\nfunction adminWithdraw(uint256 varg0) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n    emit Redemption(msg.sender, 0, varg0);\n}\n\nfunction adminWithdrawTokens(uint256 varg0) public nonPayable { \n    require(!_active);\n    require(msg.sender == _admin);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(msg.sender, varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    emit TokenClaim(_token, msg.sender, 0, varg0);\n}\n\nfunction redeemTokens(uint256 varg0) public nonPayable { \n    require(_active);\n    require(block.timestamp < _expirationTime);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transferFrom(msg.sender, address(this), varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(stor_2_0_0);\n    v2 = msg.sender.call().value(varg0 / _exchangeRate).gas(!(varg0 / _exchangeRate) * 2300);\n    require(v2);\n    emit Redemption(msg.sender, varg0, varg0 / _exchangeRate);\n}\n\nfunction expirationTime() public nonPayable { \n    return _expirationTime;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x488() private { \n    if (block.timestamp > _expirationTime) {\n        _active = 0;\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    if (v1 < _exchangeRate) {\n        _active = 0;\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(_active);\n    require(block.timestamp < _expirationTime);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transfer(msg.sender, msg.value * _exchangeRate).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    0x488();\n    emit TokenClaim(_token, msg.sender, msg.value, msg.value * _exchangeRate);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x2fb0c5e == function_selector) {\n            active();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x4cc87328 == function_selector) {\n            adminWithdrawMiscTokens(address,uint256);\n        } else if (0x6a1b52e1 == function_selector) {\n            expirationCheck();\n        } else if (0x7c5b4a37 == function_selector) {\n            adminWithdraw(uint256);\n        } else if (0x921496a9 == function_selector) {\n            adminWithdrawTokens(uint256);\n        } else if (0xa6e158f8 == function_selector) {\n            redeemTokens(uint256);\n        } else if (0xda284dcc == function_selector) {\n            expirationTime();\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.752234935760498,
	"usage": {
		"completion_tokens": 819,
		"prompt_tokens": 1244,
		"total_tokens": 2063
	}
}