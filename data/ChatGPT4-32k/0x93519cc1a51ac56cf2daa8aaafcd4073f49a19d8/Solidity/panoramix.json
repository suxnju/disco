{
	"address": "0x93519cc1a51ac56cf2daa8aaafcd4073f49a19d8",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity implementation of the given decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract CrowdsaleContract {\n    enum State { Active, Refunding, Closed }\n    State public state = State.Active;\n\n    address payable public owner;\n    address public crowdsaleAddress;\n    mapping(address => uint256) public deposited;\n\n    event RefundsEnabled();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Closed();\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyCrowdsale {\n        require(msg.sender == crowdsaleAddress);\n        _;\n    }\n\n    function kill() public onlyOwner {\n        require(state == State.Closed);\n        selfdestruct(owner);\n    }\n\n    function setCrowdsaleAddress(address _crowdsaleAddress) public onlyOwner {\n        require(_crowdsaleAddress != address(0));\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    function enableRefunds() public onlyCrowdsale {\n        require(state == State.Active);\n        state = State.Refunding;\n        emit RefundsEnabled();\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function deposit(address account) public payable onlyCrowdsale {\n        require(state == State.Active);\n        require(msg.value + deposited[account] >= deposited[account]);\n        deposited[account] += msg.value;\n    }\n\n    function close() public onlyCrowdsale {\n        require(state == State.Active);\n        state = State.Closed;\n        emit Closed();\n        owner.transfer(address(this).balance / 100);\n    }\n\n    function refund(address payable investor) public {\n        require(state == State.Refunding);\n        uint256 amount = deposited[investor];\n        deposited[investor] = 0;\n        investor.transfer(amount);\n    }\n}\n```\nThe contract above creates a simple Crowdsale contract where an owner can set a crowdsale address, deposit funds, enable refunds, and transfer ownership. It also includes a kill function for the contract owner to terminate the contract and a refund function to refund investors.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472127,
	"id": "chatcmpl-8Muljl3oYbL93xw6y0d98dh5kGYuA",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst wallet = 0x2d408bc203921646eca69b555524df3c7f3a8d7\n\ndef storage:\n  state is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  stor2 is address at storage 2\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef kill(): # not payable\n  require owner == caller\n  require state <= 2\n  require state == 2\n  selfdestruct(owner)\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef setCrowdsaleAddress(address _crowdsaleAddress): # not payable\n  require owner == caller\n  require _crowdsaleAddress\n  stor2 = _crowdsaleAddress\n\ndef enableRefunds(): # not payable\n  require stor2 == caller\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef deposit(address account) payable: \n  require stor2 == caller\n  require state <= 2\n  require not state\n  require call.value + deposited[address(account)] >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef close(address owner): # not payable\n  require stor2 == caller\n  require owner\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  call owner with:\n     value eth.balance(this.address) / 100 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  call 0x02d408bc203921646eca69b555524df3c7f3a8d7 with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst wallet = 0x2d408bc203921646eca69b555524df3c7f3a8d7\n\ndef storage:\n  state is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  stor2 is address at storage 2\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef kill(): # not payable\n  require owner == caller\n  require state <= 2\n  require state == 2\n  selfdestruct(owner)\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef setCrowdsaleAddress(address _crowdsaleAddress): # not payable\n  require owner == caller\n  require _crowdsaleAddress\n  stor2 = _crowdsaleAddress\n\ndef enableRefunds(): # not payable\n  require stor2 == caller\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef deposit(address account) payable: \n  require stor2 == caller\n  require state <= 2\n  require not state\n  require call.value + deposited[address(account)] >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef close(address owner): # not payable\n  require stor2 == caller\n  require owner\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  call owner with:\n     value eth.balance(this.address) / 100 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  call 0x02d408bc203921646eca69b555524df3c7f3a8d7 with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst wallet = 0x2d408bc203921646eca69b555524df3c7f3a8d7\n\ndef storage:\n  state is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  stor2 is address at storage 2\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef kill(): # not payable\n  require owner == caller\n  require state <= 2\n  require state == 2\n  selfdestruct(owner)\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef setCrowdsaleAddress(address _crowdsaleAddress): # not payable\n  require owner == caller\n  require _crowdsaleAddress\n  stor2 = _crowdsaleAddress\n\ndef enableRefunds(): # not payable\n  require stor2 == caller\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef deposit(address account) payable: \n  require stor2 == caller\n  require state <= 2\n  require not state\n  require call.value + deposited[address(account)] >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef close(address owner): # not payable\n  require stor2 == caller\n  require owner\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  call owner with:\n     value eth.balance(this.address) / 100 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  call 0x02d408bc203921646eca69b555524df3c7f3a8d7 with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n.",
	"status": "1",
	"time_cost": 20.890262126922607,
	"usage": {
		"completion_tokens": 472,
		"prompt_tokens": 644,
		"total_tokens": 1116
	}
}