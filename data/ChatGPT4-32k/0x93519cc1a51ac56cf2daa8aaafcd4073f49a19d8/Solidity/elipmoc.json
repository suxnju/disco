{
	"address": "0x93519cc1a51ac56cf2daa8aaafcd4073f49a19d8",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, here is the equivalent Solidity smart contract:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n\n    mapping (address => uint256) private _deposited;\n    address private _owner;\n    address private _enableRefunds;\n    uint8 private _state;\n\n    event RefundsEnabled();\n    event Closed();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Refunded(address indexed user, uint256 amount);\n\n    constructor() public {\n        _owner = msg.sender;\n        _state = 0;\n    }\n\n    function enableRefunds() public {\n        require(_enableRefunds == msg.sender, \"Not authorized\");\n        require(_state == 0, \"Invalid state\");\n        _state = 1;\n        emit RefundsEnabled();\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function state() public view returns (uint8) {\n        return _state;\n    }\n\n    function close(address recipient) public {\n        require(_enableRefunds == msg.sender, \"Not authorized\");\n        require(recipient != address(0), \"Invalid address\");\n        require(_state == 0, \"Invalid state\");\n        (bool success, ) = recipient.call{value: address(this).balance / 100}(\"\");\n        require(success, \"Transfer failed\");\n        _state = 2;\n        emit Closed();\n    }\n\n    function deposited(address user) public view returns (uint256) {\n        return _deposited[user];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(_owner == msg.sender, \"Not authorized\");\n        require(newOwner != address(0), \"Invalid address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function deposit() public payable {\n        require(_enableRefunds == msg.sender, \"Not authorized\");\n        require(_state == 0, \"Invalid state\");\n        _deposited[msg.sender] += msg.value;\n    }\n\n    function refund(address recipient) public {\n        require(_state == 1, \"Invalid state\");\n        uint256 amount = _deposited[recipient];\n        _deposited[recipient] = 0;\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Refund failed\");\n        emit Refunded(recipient, amount);\n    }\n\n    function setCrowdsaleAddress(address newAddress) public {\n        require(_owner == msg.sender, \"Not authorized\");\n        require(newAddress != address(0), \"Invalid address\");\n        _enableRefunds = newAddress;\n    }\n\n    function kill() public {\n        require(_owner == msg.sender, \"Not authorized\");\n        require(_state == 2, \"Invalid state\");\n        selfdestruct(msg.sender);\n    }\n}\n```\n\nThis Solidity code consists of a smart contract with various functions for managing refunds and deposits. It includes functions for enabling refunds, transferring ownership, depositing funds, refunding, and destroying the contract. It also includes events to log when refunds are enabled, when the contract is closed, when ownership is transferred, and when a refund is completed.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039474,
	"id": "chatcmpl-8ChvOYnqPTJq9Kl5zgxEYqERHKkyZ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 23:43 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _deposited; // STORAGE[0x1]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _enableRefunds; // STORAGE[0x2] bytes 0 to 19\nuint8 _state; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nRefundsEnabled();\nClosed();\nOwnershipTransferred(address, address);\nRefunded(address, uint256);\n\nfunction enableRefunds() public nonPayable { \n    require(_enableRefunds == msg.sender);\n    assert(_state <= 2);\n    require(_state == 0);\n    _state = 1;\n    emit RefundsEnabled();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction state() public nonPayable { \n    assert(_state <= 2);\n    return _state;\n}\n\nfunction close(address varg0) public nonPayable { \n    require(_enableRefunds == msg.sender);\n    require(varg0);\n    assert(_state <= 2);\n    require(_state == 0);\n    _state = 2;\n    emit Closed();\n    assert(100);\n    v0 = varg0.call().value((address(this)).balance / 100).gas(2300 * !((address(this)).balance / 100));\n    require(v0);\n    v1 = 0x2d408bc203921646eca69b555524df3c7f3a8d7.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v1);\n}\n\nfunction deposited(address varg0) public nonPayable { \n    return _deposited[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction deposit(address varg0) public payable { \n    require(_enableRefunds == msg.sender);\n    assert(_state <= 2);\n    require(_state == 0);\n    require(msg.value + _deposited[varg0] >= _deposited[varg0]);\n    _deposited[varg0] += msg.value;\n}\n\nfunction refund(address varg0) public nonPayable { \n    assert(_state <= 2);\n    require(_state == 1);\n    _deposited[varg0] = 0;\n    v0 = varg0.call().value(_deposited[varg0]).gas(2300 * !_deposited[varg0]);\n    require(v0);\n    emit Refunded(varg0, _deposited[varg0]);\n}\n\nfunction setCrowdsaleAddress(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _enableRefunds = varg0;\n}\n\nfunction kill() public nonPayable { \n    require(_owner == msg.sender);\n    assert(_state <= 2);\n    require(_state == 2);\n    selfdestruct(_owner);\n}\n\nfunction wallet() public nonPayable { \n    return 0x2d408bc203921646eca69b555524df3c7f3a8d7;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x1f35bc40) {\n            setCrowdsaleAddress(address);\n        } else if (0x41c0e1b5 == function_selector) {\n            kill();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x8c52dc41 == function_selector) {\n            enableRefunds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xc74073a1 == function_selector) {\n            close(address);\n        } else if (0xcb13cddb == function_selector) {\n            deposited(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf340fa01 == function_selector) {\n            deposit(address);\n        } else if (0xfa89401a == function_selector) {\n            refund(address);\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 23:43 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _deposited; // STORAGE[0x1]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _enableRefunds; // STORAGE[0x2] bytes 0 to 19\nuint8 _state; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nRefundsEnabled();\nClosed();\nOwnershipTransferred(address, address);\nRefunded(address, uint256);\n\nfunction enableRefunds() public nonPayable { \n    require(_enableRefunds == msg.sender);\n    assert(_state <= 2);\n    require(_state == 0);\n    _state = 1;\n    emit RefundsEnabled();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction state() public nonPayable { \n    assert(_state <= 2);\n    return _state;\n}\n\nfunction close(address varg0) public nonPayable { \n    require(_enableRefunds == msg.sender);\n    require(varg0);\n    assert(_state <= 2);\n    require(_state == 0);\n    _state = 2;\n    emit Closed();\n    assert(100);\n    v0 = varg0.call().value((address(this)).balance / 100).gas(2300 * !((address(this)).balance / 100));\n    require(v0);\n    v1 = 0x2d408bc203921646eca69b555524df3c7f3a8d7.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v1);\n}\n\nfunction deposited(address varg0) public nonPayable { \n    return _deposited[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction deposit(address varg0) public payable { \n    require(_enableRefunds == msg.sender);\n    assert(_state <= 2);\n    require(_state == 0);\n    require(msg.value + _deposited[varg0] >= _deposited[varg0]);\n    _deposited[varg0] += msg.value;\n}\n\nfunction refund(address varg0) public nonPayable { \n    assert(_state <= 2);\n    require(_state == 1);\n    _deposited[varg0] = 0;\n    v0 = varg0.call().value(_deposited[varg0]).gas(2300 * !_deposited[varg0]);\n    require(v0);\n    emit Refunded(varg0, _deposited[varg0]);\n}\n\nfunction setCrowdsaleAddress(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _enableRefunds = varg0;\n}\n\nfunction kill() public nonPayable { \n    require(_owner == msg.sender);\n    assert(_state <= 2);\n    require(_state == 2);\n    selfdestruct(_owner);\n}\n\nfunction wallet() public nonPayable { \n    return 0x2d408bc203921646eca69b555524df3c7f3a8d7;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x1f35bc40) {\n            setCrowdsaleAddress(address);\n        } else if (0x41c0e1b5 == function_selector) {\n            kill();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x8c52dc41 == function_selector) {\n            enableRefunds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xc74073a1 == function_selector) {\n            close(address);\n        } else if (0xcb13cddb == function_selector) {\n            deposited(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf340fa01 == function_selector) {\n            deposit(address);\n        } else if (0xfa89401a == function_selector) {\n            refund(address);\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 23:43 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _deposited; // STORAGE[0x1]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _enableRefunds; // STORAGE[0x2] bytes 0 to 19\nuint8 _state; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nRefundsEnabled();\nClosed();\nOwnershipTransferred(address, address);\nRefunded(address, uint256);\n\nfunction enableRefunds() public nonPayable { \n    require(_enableRefunds == msg.sender);\n    assert(_state <= 2);\n    require(_state == 0);\n    _state = 1;\n    emit RefundsEnabled();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction state() public nonPayable { \n    assert(_state <= 2);\n    return _state;\n}\n\nfunction close(address varg0) public nonPayable { \n    require(_enableRefunds == msg.sender);\n    require(varg0);\n    assert(_state <= 2);\n    require(_state == 0);\n    _state = 2;\n    emit Closed();\n    assert(100);\n    v0 = varg0.call().value((address(this)).balance / 100).gas(2300 * !((address(this)).balance / 100));\n    require(v0);\n    v1 = 0x2d408bc203921646eca69b555524df3c7f3a8d7.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v1);\n}\n\nfunction deposited(address varg0) public nonPayable { \n    return _deposited[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction deposit(address varg0) public payable { \n    require(_enableRefunds == msg.sender);\n    assert(_state <= 2);\n    require(_state == 0);\n    require(msg.value + _deposited[varg0] >= _deposited[varg0]);\n    _deposited[varg0] += msg.value;\n}\n\nfunction refund(address varg0) public nonPayable { \n    assert(_state <= 2);\n    require(_state == 1);\n    _deposited[varg0] = 0;\n    v0 = varg0.call().value(_deposited[varg0]).gas(2300 * !_deposited[varg0]);\n    require(v0);\n    emit Refunded(varg0, _deposited[varg0]);\n}\n\nfunction setCrowdsaleAddress(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _enableRefunds = varg0;\n}\n\nfunction kill() public nonPayable { \n    require(_owner == msg.sender);\n    assert(_state <= 2);\n    require(_state == 2);\n    selfdestruct(_owner);\n}\n\nfunction wallet() public nonPayable { \n    return 0x2d408bc203921646eca69b555524df3c7f3a8d7;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x1f35bc40) {\n            setCrowdsaleAddress(address);\n        } else if (0x41c0e1b5 == function_selector) {\n            kill();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x8c52dc41 == function_selector) {\n            enableRefunds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xc74073a1 == function_selector) {\n            close(address);\n        } else if (0xcb13cddb == function_selector) {\n            deposited(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf340fa01 == function_selector) {\n            deposit(address);\n        } else if (0xfa89401a == function_selector) {\n            refund(address);\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 37.15874791145325,
	"usage": {
		"completion_tokens": 665,
		"prompt_tokens": 1086,
		"total_tokens": 1751
	}
}