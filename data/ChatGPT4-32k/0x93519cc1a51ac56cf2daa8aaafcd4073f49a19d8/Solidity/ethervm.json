{
	"address": "0x93519cc1a51ac56cf2daa8aaafcd4073f49a19d8",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code provided, here is the corresponding Solidity code:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract Contract {\n    mapping (address => uint) public deposited;\n    address public owner;\n    address public crowdsaleAddress;\n    address constant wallet = 0x02d408bc203921646eca69b555524df3c7f3a8d7;\n    uint public state;\n\n    function setCrowdsaleAddress(address _crowdsaleAddress) public {\n        require(msg.sender == owner);\n        require(_crowdsaleAddress != address(0));\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    function enableRefunds() public {\n        require(msg.sender == crowdsaleAddress);\n        require(state == 0);\n        state = 1;\n    }\n\n    function close(address _address) public {\n        require(msg.sender == crowdsaleAddress);\n        require(_address != address(0));\n        require(state == 0);\n        state = 2;\n        uint balance = address(this).balance;\n        _address.transfer(balance);\n        wallet.transfer(address(this).balance);\n    }\n\n    function transferOwnership(address _newOwner) public {\n        require(msg.sender == owner);\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }\n\n    function deposit(address _address) public payable {\n        require(msg.sender == crowdsaleAddress);\n        require(state == 0);\n        deposited[_address] = deposited[_address] + msg.value;\n    }\n\n    function refund(address _address) public {\n        require(state == 1);\n        uint amount = deposited[_address];\n        deposited[_address] = 0;\n        _address.transfer(amount);\n    }\n}\n```\n\nPlease note that the provided pseudocode was quite complex and contained some low-level operations which are not usually done in high-level Solidity language. Also, I've made some assumptions about functionality based on the provided pseudocode, so some parts of the contract might behave differently than intended.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472275,
	"id": "chatcmpl-8Muo74a96Ul5cwjs88DRE4u6zNlRm",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x1f35bc40) {\n            // Dispatch table entry for setCrowdsaleAddress(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00d0;\n            var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            setCrowdsaleAddress(var2);\n            stop();\n        } else if (var0 == 0x41c0e1b5) {\n            // Dispatch table entry for kill()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var temp0 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n        \n            var2 = 0x02;\n            var var3 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n        \n            if (var3 > 0x02) { assert(); }\n        \n            if (var3 == var2) { selfdestruct(storage[0x00] & 0x02 ** 0xa0 - 0x01); }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00fa;\n            var2 = wallet();\n        \n        label_00FA:\n            var temp1 = memory[0x40:0x60];\n            memory[temp1:temp1 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp2 = memory[0x40:0x60];\n            return memory[temp2:temp2 + (temp1 + 0x20) - temp2];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00fa;\n            var2 = owner();\n            goto label_00FA;\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x016d;\n            var2 = state();\n            var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp3 = var4;\n            memory[temp3:temp3 + 0x20] = var5 & 0xff;\n            var temp4 = memory[0x40:0x60];\n            return memory[temp4:temp4 + (temp3 + 0x20) - temp4];\n        } else if (var0 == 0xc74073a1) {\n            // Dispatch table entry for close(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            close(var2);\n            stop();\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x01d1;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            var2 = deposited(var2);\n            var temp5 = memory[0x40:0x60];\n            memory[temp5:temp5 + 0x20] = var2;\n            var temp6 = memory[0x40:0x60];\n            return memory[temp6:temp6 + (temp5 + 0x20) - temp6];\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function setCrowdsaleAddress(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x02] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function wallet() returns (var r0) { return 0x02d408bc203921646eca69b555524df3c7f3a8d7; }\n    \n    function enableRefunds() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function state() returns (var r0) { return storage[0x00] / 0x02 ** 0xa0 & 0xff; }\n    \n    function close(var arg0) {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var var1 = 0x00;\n        var var2 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | 0x02 * 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var1 = 0x0487;\n        var2 = address(this).balance;\n        var var3 = 0x64;\n        var1 = func_06EB(var2, var3);\n        var temp2 = var1;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(arg0 & 0x02 ** 0xa0 - 0x01).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = address(this).balance;\n        var temp6 = memory[0x40:0x60];\n        var temp7;\n        temp7, memory[temp6:temp6 + 0x00] = address(0x02d408bc203921646eca69b555524df3c7f3a8d7).call.gas(!temp5 * 0x08fc).value(temp5)(memory[temp6:temp6 + memory[0x40:0x60] - temp6]);\n    \n        if (temp7) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = arg0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, stack[-1] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = (temp2 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var0 = 0x061b;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0707(var1, var2);\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n        var var2 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        var temp2 = storage[temp1];\n        storage[temp1] = 0x00;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = memory[0x40:0x60];\n        memory[temp5:temp5 + 0x20] = var0;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function func_06EB(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = arg1;\n        var var3 = arg0;\n    \n        if (var2) { return var3 / var2; }\n        else { assert(); }\n    }\n    \n    function func_0707(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { revert(memory[0x00:0x00]); }\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x1f35bc40) {\n            // Dispatch table entry for setCrowdsaleAddress(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00d0;\n            var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            setCrowdsaleAddress(var2);\n            stop();\n        } else if (var0 == 0x41c0e1b5) {\n            // Dispatch table entry for kill()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var temp0 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n        \n            var2 = 0x02;\n            var var3 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n        \n            if (var3 > 0x02) { assert(); }\n        \n            if (var3 == var2) { selfdestruct(storage[0x00] & 0x02 ** 0xa0 - 0x01); }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00fa;\n            var2 = wallet();\n        \n        label_00FA:\n            var temp1 = memory[0x40:0x60];\n            memory[temp1:temp1 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp2 = memory[0x40:0x60];\n            return memory[temp2:temp2 + (temp1 + 0x20) - temp2];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00fa;\n            var2 = owner();\n            goto label_00FA;\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x016d;\n            var2 = state();\n            var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp3 = var4;\n            memory[temp3:temp3 + 0x20] = var5 & 0xff;\n            var temp4 = memory[0x40:0x60];\n            return memory[temp4:temp4 + (temp3 + 0x20) - temp4];\n        } else if (var0 == 0xc74073a1) {\n            // Dispatch table entry for close(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            close(var2);\n            stop();\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x01d1;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            var2 = deposited(var2);\n            var temp5 = memory[0x40:0x60];\n            memory[temp5:temp5 + 0x20] = var2;\n            var temp6 = memory[0x40:0x60];\n            return memory[temp6:temp6 + (temp5 + 0x20) - temp6];\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function setCrowdsaleAddress(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x02] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function wallet() returns (var r0) { return 0x02d408bc203921646eca69b555524df3c7f3a8d7; }\n    \n    function enableRefunds() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function state() returns (var r0) { return storage[0x00] / 0x02 ** 0xa0 & 0xff; }\n    \n    function close(var arg0) {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var var1 = 0x00;\n        var var2 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | 0x02 * 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var1 = 0x0487;\n        var2 = address(this).balance;\n        var var3 = 0x64;\n        var1 = func_06EB(var2, var3);\n        var temp2 = var1;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(arg0 & 0x02 ** 0xa0 - 0x01).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = address(this).balance;\n        var temp6 = memory[0x40:0x60];\n        var temp7;\n        temp7, memory[temp6:temp6 + 0x00] = address(0x02d408bc203921646eca69b555524df3c7f3a8d7).call.gas(!temp5 * 0x08fc).value(temp5)(memory[temp6:temp6 + memory[0x40:0x60] - temp6]);\n    \n        if (temp7) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = arg0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, stack[-1] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = (temp2 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var0 = 0x061b;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0707(var1, var2);\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n        var var2 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        var temp2 = storage[temp1];\n        storage[temp1] = 0x00;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = memory[0x40:0x60];\n        memory[temp5:temp5 + 0x20] = var0;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function func_06EB(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = arg1;\n        var var3 = arg0;\n    \n        if (var2) { return var3 / var2; }\n        else { assert(); }\n    }\n    \n    function func_0707(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { revert(memory[0x00:0x00]); }\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x1f35bc40) {\n            // Dispatch table entry for setCrowdsaleAddress(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00d0;\n            var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            setCrowdsaleAddress(var2);\n            stop();\n        } else if (var0 == 0x41c0e1b5) {\n            // Dispatch table entry for kill()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var temp0 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n        \n            var2 = 0x02;\n            var var3 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n        \n            if (var3 > 0x02) { assert(); }\n        \n            if (var3 == var2) { selfdestruct(storage[0x00] & 0x02 ** 0xa0 - 0x01); }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00fa;\n            var2 = wallet();\n        \n        label_00FA:\n            var temp1 = memory[0x40:0x60];\n            memory[temp1:temp1 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp2 = memory[0x40:0x60];\n            return memory[temp2:temp2 + (temp1 + 0x20) - temp2];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00fa;\n            var2 = owner();\n            goto label_00FA;\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x016d;\n            var2 = state();\n            var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp3 = var4;\n            memory[temp3:temp3 + 0x20] = var5 & 0xff;\n            var temp4 = memory[0x40:0x60];\n            return memory[temp4:temp4 + (temp3 + 0x20) - temp4];\n        } else if (var0 == 0xc74073a1) {\n            // Dispatch table entry for close(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            close(var2);\n            stop();\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x01d1;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            var2 = deposited(var2);\n            var temp5 = memory[0x40:0x60];\n            memory[temp5:temp5 + 0x20] = var2;\n            var temp6 = memory[0x40:0x60];\n            return memory[temp6:temp6 + (temp5 + 0x20) - temp6];\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d0;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function setCrowdsaleAddress(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x02] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function wallet() returns (var r0) { return 0x02d408bc203921646eca69b555524df3c7f3a8d7; }\n    \n    function enableRefunds() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function state() returns (var r0) { return storage[0x00] / 0x02 ** 0xa0 & 0xff; }\n    \n    function close(var arg0) {\n        var var0 = 0x00;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var var1 = 0x00;\n        var var2 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | 0x02 * 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var1 = 0x0487;\n        var2 = address(this).balance;\n        var var3 = 0x64;\n        var1 = func_06EB(var2, var3);\n        var temp2 = var1;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(arg0 & 0x02 ** 0xa0 - 0x01).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = address(this).balance;\n        var temp6 = memory[0x40:0x60];\n        var temp7;\n        temp7, memory[temp6:temp6 + 0x00] = address(0x02d408bc203921646eca69b555524df3c7f3a8d7).call.gas(!temp5 * 0x08fc).value(temp5)(memory[temp6:temp6 + memory[0x40:0x60] - temp6]);\n    \n        if (temp7) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = arg0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, stack[-1] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = (temp2 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var0 = 0x061b;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0707(var1, var2);\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n        var var2 = storage[0x00] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        var temp2 = storage[temp1];\n        storage[temp1] = 0x00;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = memory[0x40:0x60];\n        memory[temp5:temp5 + 0x20] = var0;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function func_06EB(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = arg1;\n        var var3 = arg0;\n    \n        if (var2) { return var3 / var2; }\n        else { assert(); }\n    }\n    \n    function func_0707(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { revert(memory[0x00:0x00]); }\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 33.581541299819946,
	"usage": {
		"completion_tokens": 414,
		"prompt_tokens": 3893,
		"total_tokens": 4307
	}
}