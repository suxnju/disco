{
	"address": "0x22e5f62d0fa19974749faa194e3d3ef6d89c08d7",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity code equivalent to the provided decompiled code is:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyContract {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping(address => uint256)) private _allowance;\n    uint256 private _tokenAssigned;\n    address private _redeemEther;\n\n    event Assigned(address indexed account, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() public pure returns(string memory) {\n        return \"Immortal\";\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function totalSupply() public pure returns (uint256) {\n        return 100;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_balanceOf[sender] >= amount, \"Insufficient balance.\");\n        require(_allowance[sender][msg.sender] >= amount, \"Insufficient allowance.\");\n\n        _balanceOf[sender] -= amount;\n        _balanceOf[recipient] += amount;\n        _allowance[sender][msg.sender] -= amount;\n        \n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 0;\n    }\n\n    function version() public pure returns(string memory) {\n        return \"1.0.1\";\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function redeemEther(uint256 amount) public {\n        require(msg.sender == _redeemEther, \"Not authorized\");\n        (bool success,) = _redeemEther.call.value(amount)(\"\");\n        require(success, \"Failed to redeem Ether\");\n    }\n\n    function symbol() public pure returns(string memory) {\n        return \"IMT\";\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balanceOf[msg.sender] >= amount, \"Insufficient balance.\");\n        \n        _balanceOf[msg.sender] -= amount;\n        _balanceOf[recipient] += amount;\n        \n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function tokenAssigned() public view returns (uint256) {\n        return _tokenAssigned;\n    }\n\n    function approveAndCall(address spender, uint256 value, bytes memory data) public returns (bool) {\n        approve(spender, value);\n        (bool success,) = spender.call(abi.encodeWithSignature(\"receiveApproval(address,uint256,address,bytes)\", msg.sender, value, address(this), data));\n        require(success);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n}\n```\nPlease note that the given decompiled code is not complete and contains some ambiguities. Therefore, the provided Solidity code is an approximate representation. You should verify the code according to your specific requirements before using it.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456112,
	"id": "chatcmpl-8R2kSCWh6vt5altrjg5YcU7bx0qfE",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 14:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _tokenAssigned; // STORAGE[0x3]\naddress _redeemEther; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nAssigned(address, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'Immortal';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return 100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] < varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = _allowance[msg.sender] < varg2;\n    }\n    if (!v0) {\n        assert(varg2 <= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        assert(_balanceOf[varg0] >= 0);\n        assert(varg2 <= _allowance[msg.sender]);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n        _balanceOf[varg1] = _allowance[varg1] + varg2;\n        assert(_balanceOf[varg1] <= 100);\n        emit Transfer(varg0, varg1, varg2);\n        v2 = 1;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction decimals() public nonPayable { \n    return 0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & '1.0.1';\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction redeemEther(uint256 varg0) public nonPayable { \n    require(msg.sender == _redeemEther);\n    v0 = _redeemEther.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x494d540000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    if (_balanceOf[msg.sender] >= varg1) {\n        assert(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        assert(_balanceOf[msg.sender] >= 0);\n        assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        assert(_balanceOf[varg0] <= 100);\n        emit Transfer(msg.sender, varg0, varg1);\n        v0 = 1;\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction tokenAssigned() public nonPayable { \n    return _tokenAssigned;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (1) {\n        v1 = new array[](v0.length);\n        v2 = v3 = 0;\n        while (v2 < v0.length) {\n            MEM[v1.data + v2] = MEM[v0.data + v2];\n            v2 = v2 + 32;\n        }\n        v4 = v5 = v0.length + v1.data;\n        if (0x1f & v0.length) {\n            MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas - 710);\n        require(v6);\n        v7 = 1;\n    } else {\n        v7 = v8 = 0;\n    }\n    return v7;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8535490f == function_selector) {\n            redeemEther(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc0c602d9 == function_selector) {\n            tokenAssigned();\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    v0 = v1 = _tokenAssigned < 100;\n    if (v1) {\n        v0 = v2 = msg.value >= 0x6f05b59d3b20000;\n    }\n    require(v0);\n    v3 = v4 = msg.value / 0x6f05b59d3b20000;\n    assert(_tokenAssigned + v4 >= _tokenAssigned);\n    if (_tokenAssigned + v4 <= 100) {\n        v5 = v6 = msg.value % 0x6f05b59d3b20000;\n    } else {\n        v3 = v7 = 100 - _tokenAssigned;\n        v5 = v8 = msg.value - v7 * 0x6f05b59d3b20000;\n    }\n    assert(_tokenAssigned + v3 >= _tokenAssigned);\n    require(_tokenAssigned + v3 <= 100);\n    assert(_balanceOf[msg.sender] + v3 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v3;\n    assert(_tokenAssigned + v3 >= _tokenAssigned);\n    _tokenAssigned = _tokenAssigned + v3;\n    assert(_balanceOf[msg.sender] <= 100);\n    v9 = msg.sender.call().value(v5).gas(!v5 * 2300);\n    require(v9);\n    emit Assigned(msg.sender, v3);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 14:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _tokenAssigned; // STORAGE[0x3]\naddress _redeemEther; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nAssigned(address, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'Immortal';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return 100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] < varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = _allowance[msg.sender] < varg2;\n    }\n    if (!v0) {\n        assert(varg2 <= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        assert(_balanceOf[varg0] >= 0);\n        assert(varg2 <= _allowance[msg.sender]);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n        _balanceOf[varg1] = _allowance[varg1] + varg2;\n        assert(_balanceOf[varg1] <= 100);\n        emit Transfer(varg0, varg1, varg2);\n        v2 = 1;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction decimals() public nonPayable { \n    return 0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & '1.0.1';\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction redeemEther(uint256 varg0) public nonPayable { \n    require(msg.sender == _redeemEther);\n    v0 = _redeemEther.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x494d540000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    if (_balanceOf[msg.sender] >= varg1) {\n        assert(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        assert(_balanceOf[msg.sender] >= 0);\n        assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        assert(_balanceOf[varg0] <= 100);\n        emit Transfer(msg.sender, varg0, varg1);\n        v0 = 1;\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction tokenAssigned() public nonPayable { \n    return _tokenAssigned;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (1) {\n        v1 = new array[](v0.length);\n        v2 = v3 = 0;\n        while (v2 < v0.length) {\n            MEM[v1.data + v2] = MEM[v0.data + v2];\n            v2 = v2 + 32;\n        }\n        v4 = v5 = v0.length + v1.data;\n        if (0x1f & v0.length) {\n            MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas - 710);\n        require(v6);\n        v7 = 1;\n    } else {\n        v7 = v8 = 0;\n    }\n    return v7;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8535490f == function_selector) {\n            redeemEther(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc0c602d9 == function_selector) {\n            tokenAssigned();\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    v0 = v1 = _tokenAssigned < 100;\n    if (v1) {\n        v0 = v2 = msg.value >= 0x6f05b59d3b20000;\n    }\n    require(v0);\n    v3 = v4 = msg.value / 0x6f05b59d3b20000;\n    assert(_tokenAssigned + v4 >= _tokenAssigned);\n    if (_tokenAssigned + v4 <= 100) {\n        v5 = v6 = msg.value % 0x6f05b59d3b20000;\n    } else {\n        v3 = v7 = 100 - _tokenAssigned;\n        v5 = v8 = msg.value - v7 * 0x6f05b59d3b20000;\n    }\n    assert(_tokenAssigned + v3 >= _tokenAssigned);\n    require(_tokenAssigned + v3 <= 100);\n    assert(_balanceOf[msg.sender] + v3 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v3;\n    assert(_tokenAssigned + v3 >= _tokenAssigned);\n    _tokenAssigned = _tokenAssigned + v3;\n    assert(_balanceOf[msg.sender] <= 100);\n    v9 = msg.sender.call().value(v5).gas(!v5 * 2300);\n    require(v9);\n    emit Assigned(msg.sender, v3);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 14:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _tokenAssigned; // STORAGE[0x3]\naddress _redeemEther; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nAssigned(address, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'Immortal';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return 100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] < varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = _allowance[msg.sender] < varg2;\n    }\n    if (!v0) {\n        assert(varg2 <= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        assert(_balanceOf[varg0] >= 0);\n        assert(varg2 <= _allowance[msg.sender]);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n        _balanceOf[varg1] = _allowance[varg1] + varg2;\n        assert(_balanceOf[varg1] <= 100);\n        emit Transfer(varg0, varg1, varg2);\n        v2 = 1;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction decimals() public nonPayable { \n    return 0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & '1.0.1';\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction redeemEther(uint256 varg0) public nonPayable { \n    require(msg.sender == _redeemEther);\n    v0 = _redeemEther.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x494d540000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    if (_balanceOf[msg.sender] >= varg1) {\n        assert(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        assert(_balanceOf[msg.sender] >= 0);\n        assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        assert(_balanceOf[varg0] <= 100);\n        emit Transfer(msg.sender, varg0, varg1);\n        v0 = 1;\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction tokenAssigned() public nonPayable { \n    return _tokenAssigned;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (1) {\n        v1 = new array[](v0.length);\n        v2 = v3 = 0;\n        while (v2 < v0.length) {\n            MEM[v1.data + v2] = MEM[v0.data + v2];\n            v2 = v2 + 32;\n        }\n        v4 = v5 = v0.length + v1.data;\n        if (0x1f & v0.length) {\n            MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas - 710);\n        require(v6);\n        v7 = 1;\n    } else {\n        v7 = v8 = 0;\n    }\n    return v7;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8535490f == function_selector) {\n            redeemEther(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc0c602d9 == function_selector) {\n            tokenAssigned();\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    v0 = v1 = _tokenAssigned < 100;\n    if (v1) {\n        v0 = v2 = msg.value >= 0x6f05b59d3b20000;\n    }\n    require(v0);\n    v3 = v4 = msg.value / 0x6f05b59d3b20000;\n    assert(_tokenAssigned + v4 >= _tokenAssigned);\n    if (_tokenAssigned + v4 <= 100) {\n        v5 = v6 = msg.value % 0x6f05b59d3b20000;\n    } else {\n        v3 = v7 = 100 - _tokenAssigned;\n        v5 = v8 = msg.value - v7 * 0x6f05b59d3b20000;\n    }\n    assert(_tokenAssigned + v3 >= _tokenAssigned);\n    require(_tokenAssigned + v3 <= 100);\n    assert(_balanceOf[msg.sender] + v3 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v3;\n    assert(_tokenAssigned + v3 >= _tokenAssigned);\n    _tokenAssigned = _tokenAssigned + v3;\n    assert(_balanceOf[msg.sender] <= 100);\n    v9 = msg.sender.call().value(v5).gas(!v5 * 2300);\n    require(v9);\n    emit Assigned(msg.sender, v3);\n}\n.",
	"status": "1",
	"time_cost": 28.247050285339355,
	"usage": {
		"completion_tokens": 677,
		"prompt_tokens": 2109,
		"total_tokens": 2786
	}
}