{
	"address": "0x65e68b87f1380b92692f7af47cbeff917ee27a16",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code you provided, I have created the following Solidity contract:\n\n```Solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint8 private stor_0_0_0;\n    uint256[] private _name;\n    uint256[] private _symbol;\n    mapping (uint256 => uint256[]) private _getInvested;\n    mapping (uint256 => uint256[]) private _myTokens;\n    uint256 private _totalInvestor;\n    uint256 private _totalDonation;\n    uint256 private _totalSupply;\n    uint256 private _totalContractBalance;\n    uint256 private _buyingPrice;\n    mapping (uint256 => uint256[]) private _checkGameListed;\n    address private _owner;\n    uint8 private stor_3_0_0;\n    uint8 private stor_3_1_1;\n    uint8 private _calculateTokensReceived;\n\n    event onSellEvent(address indexed _from, uint256 _value);\n    event onBuyEvent(address indexed _from, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    \n    // Additional functions based on the decompiled code\n\n}\n\n```\n\nPlease note that the decompiled code you have provided is very complex and incomplete. The functions listed in the decompiled code are not complete and some of them are using variables that are not declared. It's really hard to convert the provided code into a working Solidity contract without knowing the full context of how this contract is supposed to work.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456495,
	"id": "chatcmpl-8R2qd3QkUQCwSrBZzNMD4TrOcI1SA",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 16:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _myTokens; // STORAGE[0x5]\nuint256 _totalInvestor; // STORAGE[0x6]\nuint256 _totalDonation; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 _totalContractBalance; // STORAGE[0x9]\nuint256 _buyingPrice; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _checkGameListed; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 1 to 20\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\nuint8 stor_3_1_1; // STORAGE[0x3] bytes 1 to 1\nuint8 _calculateTokensReceived; // STORAGE[0x3] bytes 2 to 2\n\n// Events\nonSellEvent(address, uint256);\nonBuyEvent(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x10b9(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x10fa(uint256 varg0, uint256 varg1) private { \n    v0 = 0x10b9(0xde0b6b3a7640000, varg1);\n    assert(_buyingPrice);\n    v1 = address(varg0);\n    require(v0 / _buyingPrice + _myTokens[v1] >= _myTokens[v1]);\n    v2 = address(varg0);\n    _myTokens[v2] = v0 / _buyingPrice + _myTokens[v1];\n    require(v0 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v0 / _buyingPrice;\n    v3 = address(varg0);\n    emit onBuyEvent(v3, v0 / _buyingPrice);\n    return v0 / _buyingPrice;\n}\n\nfunction fallback() public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    require(msg.value + _totalDonation >= _totalDonation);\n    _totalDonation += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v0 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v0 / _totalSupply;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction sellingPrice(bool varg0) public nonPayable { \n    v0 = 0x629(varg0);\n    return v0;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x10b9(_calculateTokensReceived, varg0);\n    assert(100);\n    v1 = 0x10b9(stor_3_0_0, varg0);\n    assert(100);\n    v2 = 0x10b9(0xde0b6b3a7640000, varg0 - v1 / 100 - v0 / 100);\n    assert(_buyingPrice);\n    return v2 / _buyingPrice;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction sellToken(uint256 varg0) public nonPayable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    require(_myTokens[msg.sender] > 0);\n    require(varg0 <= _myTokens[msg.sender]);\n    v2 = 0x10b9(_buyingPrice, varg0);\n    assert(0xde0b6b3a7640000);\n    v3 = 0x10b9(stor_3_1_1, v2 / 0xde0b6b3a7640000);\n    assert(100);\n    v4 = 0x10b9(_calculateTokensReceived, v2 / 0xde0b6b3a7640000);\n    assert(100);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _myTokens[msg.sender]);\n    _myTokens[msg.sender] = _myTokens[msg.sender] - varg0;\n    v5 = 0x10b9(100 - stor_3_1_1 & 0xff, v4 / 100);\n    assert(100);\n    v6 = 0x10b9(0xde0b6b3a7640000, v5 / 100);\n    assert(_buyingPrice);\n    require(v6 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v6 / _buyingPrice;\n    require(v6 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v6 / _buyingPrice;\n    emit onBuyEvent(_owner, v6 / _buyingPrice);\n    require(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - (v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100);\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v7 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v7 / _totalSupply;\n    }\n    emit onSellEvent(msg.sender, varg0);\n    v8 = msg.sender.call().value(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100).gas(2300 * !(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100));\n    require(v8); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction payWithToken(uint256 varg0, address varg1) public nonPayable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = 0xbb5(varg1);\n        v0 = varg0 <= v2;\n    }\n    require(v0);\n    v3 = 0x10b9(0xde0b6b3a7640000, varg0);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice <= _myTokens[varg1]);\n    v4 = 0x10b9(_buyingPrice, v3 / _buyingPrice);\n    assert(0xde0b6b3a7640000);\n    require(v3 / _buyingPrice <= _myTokens[varg1]);\n    require(v3 / _buyingPrice <= _totalSupply);\n    _totalSupply = _totalSupply - v3 / _buyingPrice;\n    _myTokens[varg1] = _myTokens[varg1] - v3 / _buyingPrice;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    v6 = msg.sender.call().value(v4 / 0xde0b6b3a7640000).gas(2300 * !(v4 / 0xde0b6b3a7640000));\n    require(v6); // checks call status, propagates error data on error\n    return v4 / 0xde0b6b3a7640000;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _myTokens[varg0];\n}\n\nfunction ethBalanceOf(address varg0) public nonPayable { \n    v0 = 0xb55(varg0);\n    return v0;\n}\n\nfunction totalInvestor() public nonPayable { \n    return _totalInvestor;\n}\n\nfunction ethBalanceOfNoFee(address varg0) public nonPayable { \n    v0 = 0xbb5(varg0);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    return _myTokens[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buyToken() public payable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    if (!stor_0_0_0) {\n        stor_0_0_0 = 1;\n    }\n    require(msg.value >= 0x5af3107a4000);\n    if (!_getInvested[msg.sender]) {\n        require(1 + _totalInvestor >= _totalInvestor);\n        _totalInvestor += 1;\n    }\n    require(msg.value + _getInvested[msg.sender] >= _getInvested[msg.sender]);\n    _getInvested[msg.sender] += msg.value;\n    v2 = 0x10b9(_calculateTokensReceived, msg.value);\n    assert(100);\n    v3 = 0x10b9(stor_3_0_0, msg.value);\n    assert(100);\n    v4 = 0x10b9(100 - stor_3_0_0 & 0xff, v2 / 100);\n    assert(100);\n    v5 = 0x10b9(0xde0b6b3a7640000, v4 / 100);\n    assert(_buyingPrice);\n    require(v5 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v5 / _buyingPrice;\n    require(v5 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v5 / _buyingPrice;\n    emit onBuyEvent(_owner, v5 / _buyingPrice);\n    v6 = 0x10fa(msg.sender, msg.value - v3 / 100 - v2 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v7 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v7 / _totalSupply;\n    }\n    return v6;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    require(varg1 <= _myTokens[msg.sender]);\n    if (varg1 > 0) {\n        v2 = 0x10b9(1, varg1);\n        assert(100);\n        require(varg1 <= _myTokens[msg.sender]);\n        _myTokens[msg.sender] = _myTokens[msg.sender] - varg1;\n        require(varg1 - v2 / 100 + _myTokens[varg0] >= _myTokens[varg0]);\n        _myTokens[varg0] += varg1 - v2 / 100;\n        require(v2 / 100 <= _totalSupply);\n        _totalSupply = _totalSupply - v2 / 100;\n        if (0xde0b6b3a7640000 < _totalSupply - v2 / 100) {\n            v3 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v3 / _totalSupply;\n        }\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalContractBalance() public nonPayable { \n    return _totalContractBalance;\n}\n\nfunction removeGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = ~0xff & _checkGameListed[varg0];\n}\n\nfunction buyTokenFromGame(address varg0) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value >= 0x5af3107a4000);\n    if (!_getInvested[msg.sender]) {\n        require(1 + _totalInvestor >= _totalInvestor);\n        _totalInvestor += 1;\n    }\n    require(msg.value + _getInvested[msg.sender] >= _getInvested[msg.sender]);\n    _getInvested[msg.sender] += msg.value;\n    v0 = 0x10b9(_calculateTokensReceived, msg.value);\n    assert(100);\n    v1 = 0x10b9(stor_3_0_0, msg.value);\n    assert(100);\n    v2 = 0x10b9(100 - stor_3_0_0 & 0xff, v0 / 100);\n    assert(100);\n    v3 = 0x10b9(0xde0b6b3a7640000, v2 / 100);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v3 / _buyingPrice;\n    require(v3 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v3 / _buyingPrice;\n    emit onBuyEvent(_owner, v3 / _buyingPrice);\n    v4 = 0x10fa(varg0, msg.value - v1 / 100 - v0 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    return v4;\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction myEthBalanceOf() public nonPayable { \n    v0 = 0xb55(msg.sender);\n    return v0;\n}\n\nfunction buyingPrice(bool varg0) public nonPayable { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x10b9(stor_3_0_0, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x10b9(_calculateTokensReceived, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return v0 + _buyingPrice + v0;\n}\n\nfunction addGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = 0x1 | ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOfNoFee() public nonPayable { \n    v0 = 0xbb5(msg.sender);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction checkGameListed(address varg0) public nonPayable { \n    return 0xff & _checkGameListed[varg0];\n}\n\nfunction totalDonation() public nonPayable { \n    return _totalDonation;\n}\n\nfunction 0x629(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x10b9(stor_3_1_1, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x10b9(_calculateTokensReceived, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return _buyingPrice - v0 - v0;\n}\n\nfunction 0xb55(uint256 varg0) private { \n    v0 = 0x629(1);\n    v1 = address(varg0);\n    v2 = 0x10b9(v0, _myTokens[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xbb5(uint256 varg0) private { \n    v0 = 0x629(0);\n    v1 = address(varg0);\n    v2 = 0x10b9(v0, _myTokens[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x1097b9ee == function_selector) {\n            sellingPrice(bool);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x16ff1c76 != function_selector) {\n            if (0x18160ddd == function_selector) {\n                totalSupply();\n            } else if (0x2397e4d7 == function_selector) {\n                sellToken(uint256);\n            } else if (0x313ce567 == function_selector) {\n                decimals();\n            } else if (0x52dde1c3 == function_selector) {\n                payWithToken(uint256,address);\n            } else if (0x6b2f4632 == function_selector) {\n                totalEthereumBalance();\n            } else if (0x70a08231 == function_selector) {\n                balanceOf(address);\n            } else if (0x7252bbf2 == function_selector) {\n                ethBalanceOf(address);\n            } else if (0x807e0b11 == function_selector) {\n                totalInvestor();\n            } else if (0x87f5c846 == function_selector) {\n                ethBalanceOfNoFee(address);\n            } else if (0x8da5cb5b == function_selector) {\n                owner();\n            } else if (0x949e8acd == function_selector) {\n                myTokens();\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0xa4821719 == function_selector) {\n                buyToken();\n            } else if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xbac03cd7 == function_selector) {\n                totalContractBalance();\n            } else if (0xbce24669 == function_selector) {\n                removeGame(address);\n            } else if (0xbde42d0e == function_selector) {\n                buyTokenFromGame(address);\n            } else if (0xbefc3e2b == function_selector) {\n                getInvested();\n            } else if (0xc53b12f9 == function_selector) {\n                myEthBalanceOf();\n            } else if (0xc9a7623a == function_selector) {\n                buyingPrice(bool);\n            } else if (0xd72d04db == function_selector) {\n                addGame(address);\n            } else if (0xd784601a == function_selector) {\n                myEthBalanceOfNoFee();\n            } else if (0xd86479df == function_selector) {\n                investedETH(address);\n            } else if (0xdc62da61 == function_selector) {\n                checkGameListed(address);\n            } else if (0xee2ac05f == function_selector) {\n                totalDonation();\n            }\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 16:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _myTokens; // STORAGE[0x5]\nuint256 _totalInvestor; // STORAGE[0x6]\nuint256 _totalDonation; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 _totalContractBalance; // STORAGE[0x9]\nuint256 _buyingPrice; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _checkGameListed; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 1 to 20\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\nuint8 stor_3_1_1; // STORAGE[0x3] bytes 1 to 1\nuint8 _calculateTokensReceived; // STORAGE[0x3] bytes 2 to 2\n\n// Events\nonSellEvent(address, uint256);\nonBuyEvent(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x10b9(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x10fa(uint256 varg0, uint256 varg1) private { \n    v0 = 0x10b9(0xde0b6b3a7640000, varg1);\n    assert(_buyingPrice);\n    v1 = address(varg0);\n    require(v0 / _buyingPrice + _myTokens[v1] >= _myTokens[v1]);\n    v2 = address(varg0);\n    _myTokens[v2] = v0 / _buyingPrice + _myTokens[v1];\n    require(v0 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v0 / _buyingPrice;\n    v3 = address(varg0);\n    emit onBuyEvent(v3, v0 / _buyingPrice);\n    return v0 / _buyingPrice;\n}\n\nfunction fallback() public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    require(msg.value + _totalDonation >= _totalDonation);\n    _totalDonation += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v0 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v0 / _totalSupply;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction sellingPrice(bool varg0) public nonPayable { \n    v0 = 0x629(varg0);\n    return v0;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x10b9(_calculateTokensReceived, varg0);\n    assert(100);\n    v1 = 0x10b9(stor_3_0_0, varg0);\n    assert(100);\n    v2 = 0x10b9(0xde0b6b3a7640000, varg0 - v1 / 100 - v0 / 100);\n    assert(_buyingPrice);\n    return v2 / _buyingPrice;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction sellToken(uint256 varg0) public nonPayable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    require(_myTokens[msg.sender] > 0);\n    require(varg0 <= _myTokens[msg.sender]);\n    v2 = 0x10b9(_buyingPrice, varg0);\n    assert(0xde0b6b3a7640000);\n    v3 = 0x10b9(stor_3_1_1, v2 / 0xde0b6b3a7640000);\n    assert(100);\n    v4 = 0x10b9(_calculateTokensReceived, v2 / 0xde0b6b3a7640000);\n    assert(100);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _myTokens[msg.sender]);\n    _myTokens[msg.sender] = _myTokens[msg.sender] - varg0;\n    v5 = 0x10b9(100 - stor_3_1_1 & 0xff, v4 / 100);\n    assert(100);\n    v6 = 0x10b9(0xde0b6b3a7640000, v5 / 100);\n    assert(_buyingPrice);\n    require(v6 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v6 / _buyingPrice;\n    require(v6 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v6 / _buyingPrice;\n    emit onBuyEvent(_owner, v6 / _buyingPrice);\n    require(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - (v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100);\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v7 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v7 / _totalSupply;\n    }\n    emit onSellEvent(msg.sender, varg0);\n    v8 = msg.sender.call().value(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100).gas(2300 * !(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100));\n    require(v8); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction payWithToken(uint256 varg0, address varg1) public nonPayable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = 0xbb5(varg1);\n        v0 = varg0 <= v2;\n    }\n    require(v0);\n    v3 = 0x10b9(0xde0b6b3a7640000, varg0);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice <= _myTokens[varg1]);\n    v4 = 0x10b9(_buyingPrice, v3 / _buyingPrice);\n    assert(0xde0b6b3a7640000);\n    require(v3 / _buyingPrice <= _myTokens[varg1]);\n    require(v3 / _buyingPrice <= _totalSupply);\n    _totalSupply = _totalSupply - v3 / _buyingPrice;\n    _myTokens[varg1] = _myTokens[varg1] - v3 / _buyingPrice;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    v6 = msg.sender.call().value(v4 / 0xde0b6b3a7640000).gas(2300 * !(v4 / 0xde0b6b3a7640000));\n    require(v6); // checks call status, propagates error data on error\n    return v4 / 0xde0b6b3a7640000;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _myTokens[varg0];\n}\n\nfunction ethBalanceOf(address varg0) public nonPayable { \n    v0 = 0xb55(varg0);\n    return v0;\n}\n\nfunction totalInvestor() public nonPayable { \n    return _totalInvestor;\n}\n\nfunction ethBalanceOfNoFee(address varg0) public nonPayable { \n    v0 = 0xbb5(varg0);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    return _myTokens[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buyToken() public payable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    if (!stor_0_0_0) {\n        stor_0_0_0 = 1;\n    }\n    require(msg.value >= 0x5af3107a4000);\n    if (!_getInvested[msg.sender]) {\n        require(1 + _totalInvestor >= _totalInvestor);\n        _totalInvestor += 1;\n    }\n    require(msg.value + _getInvested[msg.sender] >= _getInvested[msg.sender]);\n    _getInvested[msg.sender] += msg.value;\n    v2 = 0x10b9(_calculateTokensReceived, msg.value);\n    assert(100);\n    v3 = 0x10b9(stor_3_0_0, msg.value);\n    assert(100);\n    v4 = 0x10b9(100 - stor_3_0_0 & 0xff, v2 / 100);\n    assert(100);\n    v5 = 0x10b9(0xde0b6b3a7640000, v4 / 100);\n    assert(_buyingPrice);\n    require(v5 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v5 / _buyingPrice;\n    require(v5 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v5 / _buyingPrice;\n    emit onBuyEvent(_owner, v5 / _buyingPrice);\n    v6 = 0x10fa(msg.sender, msg.value - v3 / 100 - v2 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v7 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v7 / _totalSupply;\n    }\n    return v6;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    require(varg1 <= _myTokens[msg.sender]);\n    if (varg1 > 0) {\n        v2 = 0x10b9(1, varg1);\n        assert(100);\n        require(varg1 <= _myTokens[msg.sender]);\n        _myTokens[msg.sender] = _myTokens[msg.sender] - varg1;\n        require(varg1 - v2 / 100 + _myTokens[varg0] >= _myTokens[varg0]);\n        _myTokens[varg0] += varg1 - v2 / 100;\n        require(v2 / 100 <= _totalSupply);\n        _totalSupply = _totalSupply - v2 / 100;\n        if (0xde0b6b3a7640000 < _totalSupply - v2 / 100) {\n            v3 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v3 / _totalSupply;\n        }\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalContractBalance() public nonPayable { \n    return _totalContractBalance;\n}\n\nfunction removeGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = ~0xff & _checkGameListed[varg0];\n}\n\nfunction buyTokenFromGame(address varg0) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value >= 0x5af3107a4000);\n    if (!_getInvested[msg.sender]) {\n        require(1 + _totalInvestor >= _totalInvestor);\n        _totalInvestor += 1;\n    }\n    require(msg.value + _getInvested[msg.sender] >= _getInvested[msg.sender]);\n    _getInvested[msg.sender] += msg.value;\n    v0 = 0x10b9(_calculateTokensReceived, msg.value);\n    assert(100);\n    v1 = 0x10b9(stor_3_0_0, msg.value);\n    assert(100);\n    v2 = 0x10b9(100 - stor_3_0_0 & 0xff, v0 / 100);\n    assert(100);\n    v3 = 0x10b9(0xde0b6b3a7640000, v2 / 100);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v3 / _buyingPrice;\n    require(v3 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v3 / _buyingPrice;\n    emit onBuyEvent(_owner, v3 / _buyingPrice);\n    v4 = 0x10fa(varg0, msg.value - v1 / 100 - v0 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    return v4;\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction myEthBalanceOf() public nonPayable { \n    v0 = 0xb55(msg.sender);\n    return v0;\n}\n\nfunction buyingPrice(bool varg0) public nonPayable { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x10b9(stor_3_0_0, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x10b9(_calculateTokensReceived, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return v0 + _buyingPrice + v0;\n}\n\nfunction addGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = 0x1 | ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOfNoFee() public nonPayable { \n    v0 = 0xbb5(msg.sender);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction checkGameListed(address varg0) public nonPayable { \n    return 0xff & _checkGameListed[varg0];\n}\n\nfunction totalDonation() public nonPayable { \n    return _totalDonation;\n}\n\nfunction 0x629(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x10b9(stor_3_1_1, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x10b9(_calculateTokensReceived, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return _buyingPrice - v0 - v0;\n}\n\nfunction 0xb55(uint256 varg0) private { \n    v0 = 0x629(1);\n    v1 = address(varg0);\n    v2 = 0x10b9(v0, _myTokens[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xbb5(uint256 varg0) private { \n    v0 = 0x629(0);\n    v1 = address(varg0);\n    v2 = 0x10b9(v0, _myTokens[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x1097b9ee == function_selector) {\n            sellingPrice(bool);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x16ff1c76 != function_selector) {\n            if (0x18160ddd == function_selector) {\n                totalSupply();\n            } else if (0x2397e4d7 == function_selector) {\n                sellToken(uint256);\n            } else if (0x313ce567 == function_selector) {\n                decimals();\n            } else if (0x52dde1c3 == function_selector) {\n                payWithToken(uint256,address);\n            } else if (0x6b2f4632 == function_selector) {\n                totalEthereumBalance();\n            } else if (0x70a08231 == function_selector) {\n                balanceOf(address);\n            } else if (0x7252bbf2 == function_selector) {\n                ethBalanceOf(address);\n            } else if (0x807e0b11 == function_selector) {\n                totalInvestor();\n            } else if (0x87f5c846 == function_selector) {\n                ethBalanceOfNoFee(address);\n            } else if (0x8da5cb5b == function_selector) {\n                owner();\n            } else if (0x949e8acd == function_selector) {\n                myTokens();\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0xa4821719 == function_selector) {\n                buyToken();\n            } else if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xbac03cd7 == function_selector) {\n                totalContractBalance();\n            } else if (0xbce24669 == function_selector) {\n                removeGame(address);\n            } else if (0xbde42d0e == function_selector) {\n                buyTokenFromGame(address);\n            } else if (0xbefc3e2b == function_selector) {\n                getInvested();\n            } else if (0xc53b12f9 == function_selector) {\n                myEthBalanceOf();\n            } else if (0xc9a7623a == function_selector) {\n                buyingPrice(bool);\n            } else if (0xd72d04db == function_selector) {\n                addGame(address);\n            } else if (0xd784601a == function_selector) {\n                myEthBalanceOfNoFee();\n            } else if (0xd86479df == function_selector) {\n                investedETH(address);\n            } else if (0xdc62da61 == function_selector) {\n                checkGameListed(address);\n            } else if (0xee2ac05f == function_selector) {\n                totalDonation();\n            }\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 16:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _myTokens; // STORAGE[0x5]\nuint256 _totalInvestor; // STORAGE[0x6]\nuint256 _totalDonation; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 _totalContractBalance; // STORAGE[0x9]\nuint256 _buyingPrice; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _checkGameListed; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 1 to 20\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\nuint8 stor_3_1_1; // STORAGE[0x3] bytes 1 to 1\nuint8 _calculateTokensReceived; // STORAGE[0x3] bytes 2 to 2\n\n// Events\nonSellEvent(address, uint256);\nonBuyEvent(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x10b9(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x10fa(uint256 varg0, uint256 varg1) private { \n    v0 = 0x10b9(0xde0b6b3a7640000, varg1);\n    assert(_buyingPrice);\n    v1 = address(varg0);\n    require(v0 / _buyingPrice + _myTokens[v1] >= _myTokens[v1]);\n    v2 = address(varg0);\n    _myTokens[v2] = v0 / _buyingPrice + _myTokens[v1];\n    require(v0 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v0 / _buyingPrice;\n    v3 = address(varg0);\n    emit onBuyEvent(v3, v0 / _buyingPrice);\n    return v0 / _buyingPrice;\n}\n\nfunction fallback() public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    require(msg.value + _totalDonation >= _totalDonation);\n    _totalDonation += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v0 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v0 / _totalSupply;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction sellingPrice(bool varg0) public nonPayable { \n    v0 = 0x629(varg0);\n    return v0;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x10b9(_calculateTokensReceived, varg0);\n    assert(100);\n    v1 = 0x10b9(stor_3_0_0, varg0);\n    assert(100);\n    v2 = 0x10b9(0xde0b6b3a7640000, varg0 - v1 / 100 - v0 / 100);\n    assert(_buyingPrice);\n    return v2 / _buyingPrice;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction sellToken(uint256 varg0) public nonPayable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    require(_myTokens[msg.sender] > 0);\n    require(varg0 <= _myTokens[msg.sender]);\n    v2 = 0x10b9(_buyingPrice, varg0);\n    assert(0xde0b6b3a7640000);\n    v3 = 0x10b9(stor_3_1_1, v2 / 0xde0b6b3a7640000);\n    assert(100);\n    v4 = 0x10b9(_calculateTokensReceived, v2 / 0xde0b6b3a7640000);\n    assert(100);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _myTokens[msg.sender]);\n    _myTokens[msg.sender] = _myTokens[msg.sender] - varg0;\n    v5 = 0x10b9(100 - stor_3_1_1 & 0xff, v4 / 100);\n    assert(100);\n    v6 = 0x10b9(0xde0b6b3a7640000, v5 / 100);\n    assert(_buyingPrice);\n    require(v6 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v6 / _buyingPrice;\n    require(v6 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v6 / _buyingPrice;\n    emit onBuyEvent(_owner, v6 / _buyingPrice);\n    require(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - (v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100);\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v7 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v7 / _totalSupply;\n    }\n    emit onSellEvent(msg.sender, varg0);\n    v8 = msg.sender.call().value(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100).gas(2300 * !(v2 / 0xde0b6b3a7640000 - v3 / 100 - v4 / 100));\n    require(v8); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction payWithToken(uint256 varg0, address varg1) public nonPayable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = 0xbb5(varg1);\n        v0 = varg0 <= v2;\n    }\n    require(v0);\n    v3 = 0x10b9(0xde0b6b3a7640000, varg0);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice <= _myTokens[varg1]);\n    v4 = 0x10b9(_buyingPrice, v3 / _buyingPrice);\n    assert(0xde0b6b3a7640000);\n    require(v3 / _buyingPrice <= _myTokens[varg1]);\n    require(v3 / _buyingPrice <= _totalSupply);\n    _totalSupply = _totalSupply - v3 / _buyingPrice;\n    _myTokens[varg1] = _myTokens[varg1] - v3 / _buyingPrice;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    v6 = msg.sender.call().value(v4 / 0xde0b6b3a7640000).gas(2300 * !(v4 / 0xde0b6b3a7640000));\n    require(v6); // checks call status, propagates error data on error\n    return v4 / 0xde0b6b3a7640000;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _myTokens[varg0];\n}\n\nfunction ethBalanceOf(address varg0) public nonPayable { \n    v0 = 0xb55(varg0);\n    return v0;\n}\n\nfunction totalInvestor() public nonPayable { \n    return _totalInvestor;\n}\n\nfunction ethBalanceOfNoFee(address varg0) public nonPayable { \n    v0 = 0xbb5(varg0);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    return _myTokens[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buyToken() public payable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    if (!stor_0_0_0) {\n        stor_0_0_0 = 1;\n    }\n    require(msg.value >= 0x5af3107a4000);\n    if (!_getInvested[msg.sender]) {\n        require(1 + _totalInvestor >= _totalInvestor);\n        _totalInvestor += 1;\n    }\n    require(msg.value + _getInvested[msg.sender] >= _getInvested[msg.sender]);\n    _getInvested[msg.sender] += msg.value;\n    v2 = 0x10b9(_calculateTokensReceived, msg.value);\n    assert(100);\n    v3 = 0x10b9(stor_3_0_0, msg.value);\n    assert(100);\n    v4 = 0x10b9(100 - stor_3_0_0 & 0xff, v2 / 100);\n    assert(100);\n    v5 = 0x10b9(0xde0b6b3a7640000, v4 / 100);\n    assert(_buyingPrice);\n    require(v5 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v5 / _buyingPrice;\n    require(v5 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v5 / _buyingPrice;\n    emit onBuyEvent(_owner, v5 / _buyingPrice);\n    v6 = 0x10fa(msg.sender, msg.value - v3 / 100 - v2 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v7 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v7 / _totalSupply;\n    }\n    return v6;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = 1 == stor_0_0_0;\n    if (1 != stor_0_0_0) {\n        v0 = msg.sender == _owner;\n    }\n    require(v0);\n    require(varg1 <= _myTokens[msg.sender]);\n    if (varg1 > 0) {\n        v2 = 0x10b9(1, varg1);\n        assert(100);\n        require(varg1 <= _myTokens[msg.sender]);\n        _myTokens[msg.sender] = _myTokens[msg.sender] - varg1;\n        require(varg1 - v2 / 100 + _myTokens[varg0] >= _myTokens[varg0]);\n        _myTokens[varg0] += varg1 - v2 / 100;\n        require(v2 / 100 <= _totalSupply);\n        _totalSupply = _totalSupply - v2 / 100;\n        if (0xde0b6b3a7640000 < _totalSupply - v2 / 100) {\n            v3 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v3 / _totalSupply;\n        }\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalContractBalance() public nonPayable { \n    return _totalContractBalance;\n}\n\nfunction removeGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = ~0xff & _checkGameListed[varg0];\n}\n\nfunction buyTokenFromGame(address varg0) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value >= 0x5af3107a4000);\n    if (!_getInvested[msg.sender]) {\n        require(1 + _totalInvestor >= _totalInvestor);\n        _totalInvestor += 1;\n    }\n    require(msg.value + _getInvested[msg.sender] >= _getInvested[msg.sender]);\n    _getInvested[msg.sender] += msg.value;\n    v0 = 0x10b9(_calculateTokensReceived, msg.value);\n    assert(100);\n    v1 = 0x10b9(stor_3_0_0, msg.value);\n    assert(100);\n    v2 = 0x10b9(100 - stor_3_0_0 & 0xff, v0 / 100);\n    assert(100);\n    v3 = 0x10b9(0xde0b6b3a7640000, v2 / 100);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice + _myTokens[_owner] >= _myTokens[_owner]);\n    _myTokens[_owner] += v3 / _buyingPrice;\n    require(v3 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v3 / _buyingPrice;\n    emit onBuyEvent(_owner, v3 / _buyingPrice);\n    v4 = 0x10fa(varg0, msg.value - v1 / 100 - v0 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x10b9(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    return v4;\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction myEthBalanceOf() public nonPayable { \n    v0 = 0xb55(msg.sender);\n    return v0;\n}\n\nfunction buyingPrice(bool varg0) public nonPayable { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x10b9(stor_3_0_0, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x10b9(_calculateTokensReceived, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return v0 + _buyingPrice + v0;\n}\n\nfunction addGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = 0x1 | ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOfNoFee() public nonPayable { \n    v0 = 0xbb5(msg.sender);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction checkGameListed(address varg0) public nonPayable { \n    return 0xff & _checkGameListed[varg0];\n}\n\nfunction totalDonation() public nonPayable { \n    return _totalDonation;\n}\n\nfunction 0x629(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x10b9(stor_3_1_1, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x10b9(_calculateTokensReceived, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return _buyingPrice - v0 - v0;\n}\n\nfunction 0xb55(uint256 varg0) private { \n    v0 = 0x629(1);\n    v1 = address(varg0);\n    v2 = 0x10b9(v0, _myTokens[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xbb5(uint256 varg0) private { \n    v0 = 0x629(0);\n    v1 = address(varg0);\n    v2 = 0x10b9(v0, _myTokens[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x1097b9ee == function_selector) {\n            sellingPrice(bool);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x16ff1c76 != function_selector) {\n            if (0x18160ddd == function_selector) {\n                totalSupply();\n            } else if (0x2397e4d7 == function_selector) {\n                sellToken(uint256);\n            } else if (0x313ce567 == function_selector) {\n                decimals();\n            } else if (0x52dde1c3 == function_selector) {\n                payWithToken(uint256,address);\n            } else if (0x6b2f4632 == function_selector) {\n                totalEthereumBalance();\n            } else if (0x70a08231 == function_selector) {\n                balanceOf(address);\n            } else if (0x7252bbf2 == function_selector) {\n                ethBalanceOf(address);\n            } else if (0x807e0b11 == function_selector) {\n                totalInvestor();\n            } else if (0x87f5c846 == function_selector) {\n                ethBalanceOfNoFee(address);\n            } else if (0x8da5cb5b == function_selector) {\n                owner();\n            } else if (0x949e8acd == function_selector) {\n                myTokens();\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0xa4821719 == function_selector) {\n                buyToken();\n            } else if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xbac03cd7 == function_selector) {\n                totalContractBalance();\n            } else if (0xbce24669 == function_selector) {\n                removeGame(address);\n            } else if (0xbde42d0e == function_selector) {\n                buyTokenFromGame(address);\n            } else if (0xbefc3e2b == function_selector) {\n                getInvested();\n            } else if (0xc53b12f9 == function_selector) {\n                myEthBalanceOf();\n            } else if (0xc9a7623a == function_selector) {\n                buyingPrice(bool);\n            } else if (0xd72d04db == function_selector) {\n                addGame(address);\n            } else if (0xd784601a == function_selector) {\n                myEthBalanceOfNoFee();\n            } else if (0xd86479df == function_selector) {\n                investedETH(address);\n            } else if (0xdc62da61 == function_selector) {\n                checkGameListed(address);\n            } else if (0xee2ac05f == function_selector) {\n                totalDonation();\n            }\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.849542379379272,
	"usage": {
		"completion_tokens": 322,
		"prompt_tokens": 5605,
		"total_tokens": 5927
	}
}