{
	"address": "0x65770b5283117639760bea3f867b69b3697a91dd",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code derived from the provided decompiled code. Please note that due to the fact that the decompiled code is incomplete and lacks context, some assumptions had to be made while writing this contract.\n\n```solidity\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract CustomToken is ERC721 {\n    address private _minter;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenOwners;\n    mapping(uint256 => address) private _tokenApprovals;\n\n    constructor(address minter) ERC721(\"CustomToken\", \"CTN\") {\n        _minter = minter;\n    }\n\n    function mint(address beneficiary) external {\n        require(msg.sender == _minter, \"Only minter can mint tokens\");\n        uint256 newTokenId = totalSupply() + 1;\n        _mint(beneficiary, newTokenId);\n    }\n\n    function changeMinter(address newMinter) external {\n        require(msg.sender == _minter, \"Only minter can change minter\");\n        _minter = newMinter;\n    }\n\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"Approval to current owner\");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"Not authorized\");\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n}\n```\nThis contract makes use of the OpenZeppelin ERC721 contract to create a custom token. It has the ability to mint new tokens, change the minter, approve a user to spend a token on behalf of the owner, and safely transfer tokens. It's important to note that the original decompiled code was incomplete and complex, making it difficult to perfectly replicate in Solidity.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474916,
	"id": "chatcmpl-8MvUiDLBeIJjOoXRTyOLSKUpakK66",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor5 is uint256 at storage 5\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback() payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == tokenURI(uint256 tokenId):\n      require not call.value\n      if stor5:\n          require ext_code.size(stor5)\n          require this.address xor stor5\n          static call stor5.tokenURI(uint256 tokenId) with:\n                  gas gas_remaining wei\n                 args call.data[4]\n          require ext_call.success\n      require memcopy.success\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == tokenByIndex(uint256 index):\n      require not call.value\n      require call.data[4] < stor2\n      return call.data[4]\n  if mem[0 len 28], uint32(call.func_hash) == tokenOfOwnerByIndex(address owner, uint256 index):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require call.data[36] < stor[call.data[4]][7]\n      return stor[call.data[36]][('map', 11, ('call.data', 4, 32))]\n  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address from, address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 1713)\n  if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId):\n      require memcopy.success\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2147)\n  if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId, bytes data):\n      require _param3.length <= 1024\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2147)\n  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor[call.data[36]][6] or bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 36, 32))))])\n      stor[call.data[36]][8] = call.data[4]\n      log Approval(\n            address tokenOwner=stor[call.data[36]][6],\n            address spender=call.data[4],\n            uint256 tokens=call.data[36])\n      stop\n  if mem[0 len 28], uint32(call.func_hash) == setApprovalForAll(address to, bool approved):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require call.data[4] xor caller\n      stor[call.data[4]][('map', 9, 'caller')] = call.data[36]\n      log ApprovalForAll(\n            address owner=call.data[36],\n            address operator=caller,\n            bool approved=call.data[4])\n      stop\n  if mem[0 len 28], uint32(call.func_hash) != mint(address beneficiary):\n      if mem[0 len 28], uint32(call.func_hash) == changeMinter(address to):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require caller == stor3\n          stor3 = call.data[4]\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == 3186165836:\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require caller == stor3\n          stor5 = call.data[4]\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == name():\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if mem[0 len 28], uint32(call.func_hash) == symbol():\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n          require not call.value\n          return stor2\n      if mem[0 len 28], uint32(call.func_hash) == minter():\n          require not call.value\n          return stor3\n      if mem[0 len 28], uint32(call.func_hash) == 721465140:\n          require not call.value\n          return stor4\n      if mem[0 len 28], uint32(call.func_hash) == 1316201025:\n          require not call.value\n          return stor5\n      if mem[0 len 28], uint32(call.func_hash) == ownerOf(uint256 deedId):\n          require not call.value\n          return stor[call.data[4]][6]\n      if mem[0 len 28], uint32(call.func_hash) == balanceOf(address tokenOwner):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][7]\n      if mem[0 len 28], uint32(call.func_hash) == getApproved(uint256 tokenId):\n          require not call.value\n          return stor[call.data[4]][8]\n      if mem[0 len 28], uint32(call.func_hash) != isApprovedForAll(address owner, address operator):\n          require mem[0 len 28], uint32(call.func_hash) == supportsInterface(bytes32 param1)\n          require not call.value\n          return stor[call.data[4]][10]\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      return stor[call.data[36]][('map', 9, ('call.data', 4, 32))]\n  require not call.value\n  require _param1 < 0x10000000000000000000000000000000000000000\n  require caller == stor3 and call.data[4]\n  require ext_code.size(stor4)\n  require this.address xor stor4\n  static call stor4.totalSupply() with:\n          gas gas_remaining wei\n  require ext_call.success\n  require 500 * 10^18 >= ext_call.return_data[0]\n  if not stor2:\n      require 0 < -ext_call.return_data[0] + 500 * 10^18\n  else:\n      require 10^18 * stor2 / stor2 == 10^18\n      require 10^18 * stor2 < -ext_call.return_data[0] + 500 * 10^18\n  stor2[6] = call.data[4]\n  require stor[call.data[4]][7] + 1 >= stor[call.data[4]][7]\n  stor[call.data[4]][7]++\n  stor[call.data[4]][7][('map', 11, ('call.data', 4, 32))] = stor2\n  stor2[12] = stor[call.data[4]][7]\n  require stor2 + 1 >= stor2\n  stor2++\n  log Transfer(\n        address from=0,\n        address to=call.data[4],\n        uint256 tokens=stor2)\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor5 is uint256 at storage 5\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback() payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == tokenURI(uint256 tokenId):\n      require not call.value\n      if stor5:\n          require ext_code.size(stor5)\n          require this.address xor stor5\n          static call stor5.tokenURI(uint256 tokenId) with:\n                  gas gas_remaining wei\n                 args call.data[4]\n          require ext_call.success\n      require memcopy.success\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == tokenByIndex(uint256 index):\n      require not call.value\n      require call.data[4] < stor2\n      return call.data[4]\n  if mem[0 len 28], uint32(call.func_hash) == tokenOfOwnerByIndex(address owner, uint256 index):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require call.data[36] < stor[call.data[4]][7]\n      return stor[call.data[36]][('map', 11, ('call.data', 4, 32))]\n  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address from, address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 1713)\n  if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId):\n      require memcopy.success\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2147)\n  if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId, bytes data):\n      require _param3.length <= 1024\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2147)\n  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor[call.data[36]][6] or bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 36, 32))))])\n      stor[call.data[36]][8] = call.data[4]\n      log Approval(\n            address tokenOwner=stor[call.data[36]][6],\n            address spender=call.data[4],\n            uint256 tokens=call.data[36])\n      stop\n  if mem[0 len 28], uint32(call.func_hash) == setApprovalForAll(address to, bool approved):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require call.data[4] xor caller\n      stor[call.data[4]][('map', 9, 'caller')] = call.data[36]\n      log ApprovalForAll(\n            address owner=call.data[36],\n            address operator=caller,\n            bool approved=call.data[4])\n      stop\n  if mem[0 len 28], uint32(call.func_hash) != mint(address beneficiary):\n      if mem[0 len 28], uint32(call.func_hash) == changeMinter(address to):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require caller == stor3\n          stor3 = call.data[4]\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == 3186165836:\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require caller == stor3\n          stor5 = call.data[4]\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == name():\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if mem[0 len 28], uint32(call.func_hash) == symbol():\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n          require not call.value\n          return stor2\n      if mem[0 len 28], uint32(call.func_hash) == minter():\n          require not call.value\n          return stor3\n      if mem[0 len 28], uint32(call.func_hash) == 721465140:\n          require not call.value\n          return stor4\n      if mem[0 len 28], uint32(call.func_hash) == 1316201025:\n          require not call.value\n          return stor5\n      if mem[0 len 28], uint32(call.func_hash) == ownerOf(uint256 deedId):\n          require not call.value\n          return stor[call.data[4]][6]\n      if mem[0 len 28], uint32(call.func_hash) == balanceOf(address tokenOwner):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][7]\n      if mem[0 len 28], uint32(call.func_hash) == getApproved(uint256 tokenId):\n          require not call.value\n          return stor[call.data[4]][8]\n      if mem[0 len 28], uint32(call.func_hash) != isApprovedForAll(address owner, address operator):\n          require mem[0 len 28], uint32(call.func_hash) == supportsInterface(bytes32 param1)\n          require not call.value\n          return stor[call.data[4]][10]\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      return stor[call.data[36]][('map', 9, ('call.data', 4, 32))]\n  require not call.value\n  require _param1 < 0x10000000000000000000000000000000000000000\n  require caller == stor3 and call.data[4]\n  require ext_code.size(stor4)\n  require this.address xor stor4\n  static call stor4.totalSupply() with:\n          gas gas_remaining wei\n  require ext_call.success\n  require 500 * 10^18 >= ext_call.return_data[0]\n  if not stor2:\n      require 0 < -ext_call.return_data[0] + 500 * 10^18\n  else:\n      require 10^18 * stor2 / stor2 == 10^18\n      require 10^18 * stor2 < -ext_call.return_data[0] + 500 * 10^18\n  stor2[6] = call.data[4]\n  require stor[call.data[4]][7] + 1 >= stor[call.data[4]][7]\n  stor[call.data[4]][7]++\n  stor[call.data[4]][7][('map', 11, ('call.data', 4, 32))] = stor2\n  stor2[12] = stor[call.data[4]][7]\n  require stor2 + 1 >= stor2\n  stor2++\n  log Transfer(\n        address from=0,\n        address to=call.data[4],\n        uint256 tokens=stor2)\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor5 is uint256 at storage 5\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback() payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == tokenURI(uint256 tokenId):\n      require not call.value\n      if stor5:\n          require ext_code.size(stor5)\n          require this.address xor stor5\n          static call stor5.tokenURI(uint256 tokenId) with:\n                  gas gas_remaining wei\n                 args call.data[4]\n          require ext_call.success\n      require memcopy.success\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == tokenByIndex(uint256 index):\n      require not call.value\n      require call.data[4] < stor2\n      return call.data[4]\n  if mem[0 len 28], uint32(call.func_hash) == tokenOfOwnerByIndex(address owner, uint256 index):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require call.data[36] < stor[call.data[4]][7]\n      return stor[call.data[36]][('map', 11, ('call.data', 4, 32))]\n  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address from, address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 1713)\n  if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId):\n      require memcopy.success\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2147)\n  if mem[0 len 28], uint32(call.func_hash) == safeTransferFrom(address from, address to, uint256 tokenId, bytes data):\n      require _param3.length <= 1024\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[call.data[68]][6] == call.data[4] and call.data[36]\n      require bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 68, 32))))]) or caller == stor[call.data[68]][6] or caller == stor[call.data[68]][8]\n      require stor[call.data[4]][7] >= 1\n      if stor[call.data[4]][7] - 1 != stor[call.data[68]][12]:\n          stor[call.data[68]][12][('map', 11, ('call.data', 4, 32))] = stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))]\n      stor[stor[call.data[4]][7] - 1][('map', 11, ('call.data', 4, 32))] = 0\n      stor[call.data[36]][7][('map', 11, ('call.data', 36, 32))] = call.data[68]\n      stor[call.data[68]][12] = stor[call.data[36]][7]\n      stor[call.data[68]][6] = call.data[36]\n      require stor[call.data[4]][7] >= 1\n      stor[call.data[4]][7]--\n      require stor[call.data[36]][7] + 1 >= stor[call.data[36]][7]\n      stor[call.data[36]][7]++\n      if stor[call.data[68]][8] xor 0:\n          stor[call.data[68]][8] = 0\n      log Transfer(\n            address from=call.data[4],\n            address to=call.data[36],\n            uint256 tokens=call.data[68])\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2147)\n  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor[call.data[36]][6] or bool(stor[caller][('map', 9, ('stor', ('map', 6, ('call.data', 36, 32))))])\n      stor[call.data[36]][8] = call.data[4]\n      log Approval(\n            address tokenOwner=stor[call.data[36]][6],\n            address spender=call.data[4],\n            uint256 tokens=call.data[36])\n      stop\n  if mem[0 len 28], uint32(call.func_hash) == setApprovalForAll(address to, bool approved):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require call.data[4] xor caller\n      stor[call.data[4]][('map', 9, 'caller')] = call.data[36]\n      log ApprovalForAll(\n            address owner=call.data[36],\n            address operator=caller,\n            bool approved=call.data[4])\n      stop\n  if mem[0 len 28], uint32(call.func_hash) != mint(address beneficiary):\n      if mem[0 len 28], uint32(call.func_hash) == changeMinter(address to):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require caller == stor3\n          stor3 = call.data[4]\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == 3186165836:\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require caller == stor3\n          stor5 = call.data[4]\n          stop\n      if mem[0 len 28], uint32(call.func_hash) == name():\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if mem[0 len 28], uint32(call.func_hash) == symbol():\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n          require not call.value\n          return stor2\n      if mem[0 len 28], uint32(call.func_hash) == minter():\n          require not call.value\n          return stor3\n      if mem[0 len 28], uint32(call.func_hash) == 721465140:\n          require not call.value\n          return stor4\n      if mem[0 len 28], uint32(call.func_hash) == 1316201025:\n          require not call.value\n          return stor5\n      if mem[0 len 28], uint32(call.func_hash) == ownerOf(uint256 deedId):\n          require not call.value\n          return stor[call.data[4]][6]\n      if mem[0 len 28], uint32(call.func_hash) == balanceOf(address tokenOwner):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          return stor[call.data[4]][7]\n      if mem[0 len 28], uint32(call.func_hash) == getApproved(uint256 tokenId):\n          require not call.value\n          return stor[call.data[4]][8]\n      if mem[0 len 28], uint32(call.func_hash) != isApprovedForAll(address owner, address operator):\n          require mem[0 len 28], uint32(call.func_hash) == supportsInterface(bytes32 param1)\n          require not call.value\n          return stor[call.data[4]][10]\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      return stor[call.data[36]][('map', 9, ('call.data', 4, 32))]\n  require not call.value\n  require _param1 < 0x10000000000000000000000000000000000000000\n  require caller == stor3 and call.data[4]\n  require ext_code.size(stor4)\n  require this.address xor stor4\n  static call stor4.totalSupply() with:\n          gas gas_remaining wei\n  require ext_call.success\n  require 500 * 10^18 >= ext_call.return_data[0]\n  if not stor2:\n      require 0 < -ext_call.return_data[0] + 500 * 10^18\n  else:\n      require 10^18 * stor2 / stor2 == 10^18\n      require 10^18 * stor2 < -ext_call.return_data[0] + 500 * 10^18\n  stor2[6] = call.data[4]\n  require stor[call.data[4]][7] + 1 >= stor[call.data[4]][7]\n  stor[call.data[4]][7]++\n  stor[call.data[4]][7][('map', 11, ('call.data', 4, 32))] = stor2\n  stor2[12] = stor[call.data[4]][7]\n  require stor2 + 1 >= stor2\n  stor2++\n  log Transfer(\n        address from=0,\n        address to=call.data[4],\n        uint256 tokens=stor2)\n  return 1\n\n.",
	"status": "1",
	"time_cost": 29.36660099029541,
	"usage": {
		"completion_tokens": 460,
		"prompt_tokens": 3197,
		"total_tokens": 3657
	}
}