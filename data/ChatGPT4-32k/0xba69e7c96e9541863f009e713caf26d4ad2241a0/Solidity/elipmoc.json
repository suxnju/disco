{
	"address": "0xba69e7c96e9541863f009e713caf26d4ad2241a0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The EVM Bytecode provided above is complex and appears to be part of a larger contract. The bytecode uses a number of low-level operations such as CALLDATACOPY, MEM, and STORAGE, which are not directly available in Solidity. It's also worth noting that the exact conversion of EVM Bytecode to Solidity is a complex process and may not be possible to achieve with 100% accuracy due to the lower-level nature of bytecode. However, I'll provide a simplified version of a Solidity smart contract that includes some of the concepts and functions gleaned from the bytecode:\n\n```solidity\npragma solidity ^0.7.4;\n\ncontract MyContract {\n    \n    address private owner;\n    address private _invest;\n    uint256 private _balance;\n    uint256[] private _investors;\n\n    event Invest(address investor, uint256 amount);\n    event Payout(address investor, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function invest() public payable {\n        require(msg.value > 0, \"Investment must be a positive value\");\n        _investors.push(msg.value);\n        _balance += msg.value;\n        emit Invest(msg.sender, msg.value);\n    }\n\n    function payout(address payable _to, uint256 _amount) public onlyOwner {\n        require(_balance >= _amount, \"Insufficient balance\");\n        _balance -= _amount;\n        _to.transfer(_amount);\n        emit Payout(_to, _amount);\n    }\n\n    function balance() public view returns (uint256) {\n        return _balance;\n    }\n}\n```\nThis code is a simplified and somewhat interpretive representation of the bytecode. It includes the concept of investing, paying out, and checking the balance. However, it's important to note that the original bytecode includes more complex logic, data manipulation and interactions that are not represented in this Solidity version. It's also important to note that this contract does not include the same safety checks and constraints to ensure that the contract is used as intended. The actual contract behavior may vary from the original bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040206,
	"id": "chatcmpl-8Ci7CIZamrsDmNP2edLbsZxq9QuUm",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 16:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_1; // STORAGE[0x1]\nuint256[] _investors; // STORAGE[0x2]\nuint256 ___function_selector__; // STORAGE[0x3]\nuint256 _balance; // STORAGE[0x5]\naddress owner; // STORAGE[0x0] bytes 0 to 19\naddress _invest; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nPayout(address, uint256);\n\nfunction setOfficialWebsite(string url) public payable { \n    v0 = new bytes[](url.length);\n    CALLDATACOPY(v0.data, 36 + url, url.length);\n    assert(msg.sender == owner);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        array_1.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        array_1.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + array_1.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction balance() public payable { \n    return _balance;\n}\n\nfunction invest() public payable { \n    _investors.length = _investors.length + 1;\n    if (!_investors.length <= _investors.length + 1) {\n        v0 = keccak256(2) + (_investors.length + 1 << 2);\n        while (keccak256(2) + (_investors.length << 2) > v0) {\n            STORAGE[v0] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v0];\n            v0 = v0 + 1;\n            STORAGE[v0] = 0;\n            STORAGE[v0 + 2] = 0;\n            STORAGE[3 + v0] = ~0xff & STORAGE[3 + v0];\n        }\n    }\n    MEM[64] = MEM[64] + 128;\n    if (msg.value > 0xde0b6b3a7640000) {\n        if (msg.value > 0x8ac7230489e80000) {\n            if (msg.value > 0x56bc75e2d63100000) {\n                v1 = v2 = 0;\n            } else {\n                v1 = v3 = 130;\n            }\n        } else {\n            v1 = v4 = 120;\n        }\n    } else {\n        v1 = v5 = 110;\n    }\n    _investors[_investors.length << 2] = ~0xffffffffffffffffffffffffffffffffffffffff & _investors[_investors.length << 2] | msg.sender;\n    STORAGE[(_investors.length << 2) + keccak256(2) + 1] = msg.value;\n    STORAGE[(_investors.length << 2) + keccak256(2) + 2] = block.timestamp / 0x15180;\n    STORAGE[3 + ((_investors.length << 2) + keccak256(2))] = v1 | ~0xff & STORAGE[3 + ((_investors.length << 2) + keccak256(2))];\n    _balance = _balance + msg.value * 99 / 100;\n    v6 = _invest.call().value(msg.value / 100);\n    emit Invest(msg.sender, msg.value);\n}\n\nfunction currentManager() public payable { \n    return _invest;\n}\n\nfunction found() public payable { \n    assert(msg.sender == owner);\n    _balance += msg.value;\n}\n\nfunction investors(uint256 varg0) public payable { \n    assert(varg0 < _investors.length);\n    MEM[0] = 2;\n    return address(STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace]), STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf], STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0], 0xff & (0xff & STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (varg0 << 2)]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = v1 = function_selector >> 224;\n        if (v1 == 0x104b6704) {\n            0x104b6704();\n        } else if (0x3d750b28 == v1) {\n            0x3d750b28();\n        } else if (0x3feb5f2b == v1) {\n            investors(uint256);\n        } else if (0xb3a2a6c0 == v1) {\n            0xb3a2a6c0();\n        } else if (0xb69ef8a8 == v1) {\n            balance();\n        } else if (0xe8b5e51f == v1) {\n            invest();\n        }\n    }\n    v2 = v3 = 583;\n    assert(msg.value >= 0x16345785d8a0000);\n    v0 = v4 = 593;\n    v2 = _investors.length + 1;\n    _investors.length = v2;\n    if (!_investors.length <= v2) {\n        v5 = keccak256(2) + (v2 << 2);\n        while (keccak256(2) + (_investors.length << 2) > v5) {\n            STORAGE[v5] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v5];\n            v5 = v5 + 1;\n            STORAGE[v5] = 0;\n            STORAGE[v5 + 2] = 0;\n            STORAGE[3 + v5] = ~0xff & STORAGE[3 + v5];\n        }\n    }\n    v6 = (_investors.length << 2) + keccak256(2);\n    v7 = MEM[64];\n    MEM[64] = v7 + 128;\n    MEM[v7] = msg.sender;\n    MEM[32 + v7] = msg.value;\n    MEM[64 + v7] = block.timestamp / 0x15180;\n    v8 = 96 + v7;\n    v9 = v10 = 1074;\n    if (msg.value > 0xde0b6b3a7640000) {\n        if (msg.value > 0x8ac7230489e80000) {\n            if (msg.value > 0x56bc75e2d63100000) {\n                v11 = v12 = 0;\n            } else {\n                v11 = v13 = 130;\n            }\n        } else {\n            v11 = v14 = 120;\n        }\n    } else {\n        v11 = v15 = 110;\n    }\n    while (1) {\n        goto {'0x4320x0', '0x364'};\n        MEM[v8] = v11;\n        STORAGE[v6] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v6] | MEM[v7];\n        STORAGE[v6 + 1] = MEM[v7 + 32];\n        STORAGE[v6 + 2] = MEM[64 + v7];\n        STORAGE[3 + v6] = MEM[96 + v7] | ~0xff & STORAGE[3 + v6];\n        _balance = _balance + msg.value * 99 / 100;\n        v16 = _invest.call().value(msg.value / 100);\n        emit Invest(msg.sender, msg.value);\n        v6 = v17 = 616;\n        v7 = v18 = 0;\n        v8 = v19 = 0;\n        v9 = v20 = 868;\n        v11 = block.timestamp / 0x15180;\n    }\n    v21 = v22 = ___function_selector__;\n    while (v21 < _investors.length) {\n        assert(v21 < _investors.length);\n        MEM[0] = 2;\n        if (_balance >= STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100) {\n            assert(v21 < _investors.length);\n            MEM[0] = 2;\n            if (STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0 + (v21 << 2)] < v11) {\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                if (0xff & STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] <= 0) {\n                    ___function_selector__ = v21;\n                }\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                v23 = address(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + (v21 << 2)]).call().value(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100);\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0 + (v21 << 2)] = v11;\n                assert(v21 < _investors.length);\n                STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] = ~0 + (STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] & 0xff) | STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] & ~0xff;\n                _balance = _balance - STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100;\n                assert(v21 < _investors.length);\n                emit Payout(address(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + (v21 << 2)]), STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100);\n            }\n            v21 += 1;\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 16:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_1; // STORAGE[0x1]\nuint256[] _investors; // STORAGE[0x2]\nuint256 ___function_selector__; // STORAGE[0x3]\nuint256 _balance; // STORAGE[0x5]\naddress owner; // STORAGE[0x0] bytes 0 to 19\naddress _invest; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nPayout(address, uint256);\n\nfunction setOfficialWebsite(string url) public payable { \n    v0 = new bytes[](url.length);\n    CALLDATACOPY(v0.data, 36 + url, url.length);\n    assert(msg.sender == owner);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        array_1.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        array_1.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + array_1.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction balance() public payable { \n    return _balance;\n}\n\nfunction invest() public payable { \n    _investors.length = _investors.length + 1;\n    if (!_investors.length <= _investors.length + 1) {\n        v0 = keccak256(2) + (_investors.length + 1 << 2);\n        while (keccak256(2) + (_investors.length << 2) > v0) {\n            STORAGE[v0] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v0];\n            v0 = v0 + 1;\n            STORAGE[v0] = 0;\n            STORAGE[v0 + 2] = 0;\n            STORAGE[3 + v0] = ~0xff & STORAGE[3 + v0];\n        }\n    }\n    MEM[64] = MEM[64] + 128;\n    if (msg.value > 0xde0b6b3a7640000) {\n        if (msg.value > 0x8ac7230489e80000) {\n            if (msg.value > 0x56bc75e2d63100000) {\n                v1 = v2 = 0;\n            } else {\n                v1 = v3 = 130;\n            }\n        } else {\n            v1 = v4 = 120;\n        }\n    } else {\n        v1 = v5 = 110;\n    }\n    _investors[_investors.length << 2] = ~0xffffffffffffffffffffffffffffffffffffffff & _investors[_investors.length << 2] | msg.sender;\n    STORAGE[(_investors.length << 2) + keccak256(2) + 1] = msg.value;\n    STORAGE[(_investors.length << 2) + keccak256(2) + 2] = block.timestamp / 0x15180;\n    STORAGE[3 + ((_investors.length << 2) + keccak256(2))] = v1 | ~0xff & STORAGE[3 + ((_investors.length << 2) + keccak256(2))];\n    _balance = _balance + msg.value * 99 / 100;\n    v6 = _invest.call().value(msg.value / 100);\n    emit Invest(msg.sender, msg.value);\n}\n\nfunction currentManager() public payable { \n    return _invest;\n}\n\nfunction found() public payable { \n    assert(msg.sender == owner);\n    _balance += msg.value;\n}\n\nfunction investors(uint256 varg0) public payable { \n    assert(varg0 < _investors.length);\n    MEM[0] = 2;\n    return address(STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace]), STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf], STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0], 0xff & (0xff & STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (varg0 << 2)]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = v1 = function_selector >> 224;\n        if (v1 == 0x104b6704) {\n            0x104b6704();\n        } else if (0x3d750b28 == v1) {\n            0x3d750b28();\n        } else if (0x3feb5f2b == v1) {\n            investors(uint256);\n        } else if (0xb3a2a6c0 == v1) {\n            0xb3a2a6c0();\n        } else if (0xb69ef8a8 == v1) {\n            balance();\n        } else if (0xe8b5e51f == v1) {\n            invest();\n        }\n    }\n    v2 = v3 = 583;\n    assert(msg.value >= 0x16345785d8a0000);\n    v0 = v4 = 593;\n    v2 = _investors.length + 1;\n    _investors.length = v2;\n    if (!_investors.length <= v2) {\n        v5 = keccak256(2) + (v2 << 2);\n        while (keccak256(2) + (_investors.length << 2) > v5) {\n            STORAGE[v5] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v5];\n            v5 = v5 + 1;\n            STORAGE[v5] = 0;\n            STORAGE[v5 + 2] = 0;\n            STORAGE[3 + v5] = ~0xff & STORAGE[3 + v5];\n        }\n    }\n    v6 = (_investors.length << 2) + keccak256(2);\n    v7 = MEM[64];\n    MEM[64] = v7 + 128;\n    MEM[v7] = msg.sender;\n    MEM[32 + v7] = msg.value;\n    MEM[64 + v7] = block.timestamp / 0x15180;\n    v8 = 96 + v7;\n    v9 = v10 = 1074;\n    if (msg.value > 0xde0b6b3a7640000) {\n        if (msg.value > 0x8ac7230489e80000) {\n            if (msg.value > 0x56bc75e2d63100000) {\n                v11 = v12 = 0;\n            } else {\n                v11 = v13 = 130;\n            }\n        } else {\n            v11 = v14 = 120;\n        }\n    } else {\n        v11 = v15 = 110;\n    }\n    while (1) {\n        goto {'0x4320x0', '0x364'};\n        MEM[v8] = v11;\n        STORAGE[v6] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v6] | MEM[v7];\n        STORAGE[v6 + 1] = MEM[v7 + 32];\n        STORAGE[v6 + 2] = MEM[64 + v7];\n        STORAGE[3 + v6] = MEM[96 + v7] | ~0xff & STORAGE[3 + v6];\n        _balance = _balance + msg.value * 99 / 100;\n        v16 = _invest.call().value(msg.value / 100);\n        emit Invest(msg.sender, msg.value);\n        v6 = v17 = 616;\n        v7 = v18 = 0;\n        v8 = v19 = 0;\n        v9 = v20 = 868;\n        v11 = block.timestamp / 0x15180;\n    }\n    v21 = v22 = ___function_selector__;\n    while (v21 < _investors.length) {\n        assert(v21 < _investors.length);\n        MEM[0] = 2;\n        if (_balance >= STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100) {\n            assert(v21 < _investors.length);\n            MEM[0] = 2;\n            if (STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0 + (v21 << 2)] < v11) {\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                if (0xff & STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] <= 0) {\n                    ___function_selector__ = v21;\n                }\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                v23 = address(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + (v21 << 2)]).call().value(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100);\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0 + (v21 << 2)] = v11;\n                assert(v21 < _investors.length);\n                STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] = ~0 + (STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] & 0xff) | STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] & ~0xff;\n                _balance = _balance - STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100;\n                assert(v21 < _investors.length);\n                emit Payout(address(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + (v21 << 2)]), STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100);\n            }\n            v21 += 1;\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 16:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_1; // STORAGE[0x1]\nuint256[] _investors; // STORAGE[0x2]\nuint256 ___function_selector__; // STORAGE[0x3]\nuint256 _balance; // STORAGE[0x5]\naddress owner; // STORAGE[0x0] bytes 0 to 19\naddress _invest; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nPayout(address, uint256);\n\nfunction setOfficialWebsite(string url) public payable { \n    v0 = new bytes[](url.length);\n    CALLDATACOPY(v0.data, 36 + url, url.length);\n    assert(msg.sender == owner);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        array_1.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        array_1.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + array_1.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction balance() public payable { \n    return _balance;\n}\n\nfunction invest() public payable { \n    _investors.length = _investors.length + 1;\n    if (!_investors.length <= _investors.length + 1) {\n        v0 = keccak256(2) + (_investors.length + 1 << 2);\n        while (keccak256(2) + (_investors.length << 2) > v0) {\n            STORAGE[v0] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v0];\n            v0 = v0 + 1;\n            STORAGE[v0] = 0;\n            STORAGE[v0 + 2] = 0;\n            STORAGE[3 + v0] = ~0xff & STORAGE[3 + v0];\n        }\n    }\n    MEM[64] = MEM[64] + 128;\n    if (msg.value > 0xde0b6b3a7640000) {\n        if (msg.value > 0x8ac7230489e80000) {\n            if (msg.value > 0x56bc75e2d63100000) {\n                v1 = v2 = 0;\n            } else {\n                v1 = v3 = 130;\n            }\n        } else {\n            v1 = v4 = 120;\n        }\n    } else {\n        v1 = v5 = 110;\n    }\n    _investors[_investors.length << 2] = ~0xffffffffffffffffffffffffffffffffffffffff & _investors[_investors.length << 2] | msg.sender;\n    STORAGE[(_investors.length << 2) + keccak256(2) + 1] = msg.value;\n    STORAGE[(_investors.length << 2) + keccak256(2) + 2] = block.timestamp / 0x15180;\n    STORAGE[3 + ((_investors.length << 2) + keccak256(2))] = v1 | ~0xff & STORAGE[3 + ((_investors.length << 2) + keccak256(2))];\n    _balance = _balance + msg.value * 99 / 100;\n    v6 = _invest.call().value(msg.value / 100);\n    emit Invest(msg.sender, msg.value);\n}\n\nfunction currentManager() public payable { \n    return _invest;\n}\n\nfunction found() public payable { \n    assert(msg.sender == owner);\n    _balance += msg.value;\n}\n\nfunction investors(uint256 varg0) public payable { \n    assert(varg0 < _investors.length);\n    MEM[0] = 2;\n    return address(STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace]), STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf], STORAGE[(varg0 << 2) + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0], 0xff & (0xff & STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (varg0 << 2)]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = v1 = function_selector >> 224;\n        if (v1 == 0x104b6704) {\n            0x104b6704();\n        } else if (0x3d750b28 == v1) {\n            0x3d750b28();\n        } else if (0x3feb5f2b == v1) {\n            investors(uint256);\n        } else if (0xb3a2a6c0 == v1) {\n            0xb3a2a6c0();\n        } else if (0xb69ef8a8 == v1) {\n            balance();\n        } else if (0xe8b5e51f == v1) {\n            invest();\n        }\n    }\n    v2 = v3 = 583;\n    assert(msg.value >= 0x16345785d8a0000);\n    v0 = v4 = 593;\n    v2 = _investors.length + 1;\n    _investors.length = v2;\n    if (!_investors.length <= v2) {\n        v5 = keccak256(2) + (v2 << 2);\n        while (keccak256(2) + (_investors.length << 2) > v5) {\n            STORAGE[v5] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v5];\n            v5 = v5 + 1;\n            STORAGE[v5] = 0;\n            STORAGE[v5 + 2] = 0;\n            STORAGE[3 + v5] = ~0xff & STORAGE[3 + v5];\n        }\n    }\n    v6 = (_investors.length << 2) + keccak256(2);\n    v7 = MEM[64];\n    MEM[64] = v7 + 128;\n    MEM[v7] = msg.sender;\n    MEM[32 + v7] = msg.value;\n    MEM[64 + v7] = block.timestamp / 0x15180;\n    v8 = 96 + v7;\n    v9 = v10 = 1074;\n    if (msg.value > 0xde0b6b3a7640000) {\n        if (msg.value > 0x8ac7230489e80000) {\n            if (msg.value > 0x56bc75e2d63100000) {\n                v11 = v12 = 0;\n            } else {\n                v11 = v13 = 130;\n            }\n        } else {\n            v11 = v14 = 120;\n        }\n    } else {\n        v11 = v15 = 110;\n    }\n    while (1) {\n        goto {'0x4320x0', '0x364'};\n        MEM[v8] = v11;\n        STORAGE[v6] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v6] | MEM[v7];\n        STORAGE[v6 + 1] = MEM[v7 + 32];\n        STORAGE[v6 + 2] = MEM[64 + v7];\n        STORAGE[3 + v6] = MEM[96 + v7] | ~0xff & STORAGE[3 + v6];\n        _balance = _balance + msg.value * 99 / 100;\n        v16 = _invest.call().value(msg.value / 100);\n        emit Invest(msg.sender, msg.value);\n        v6 = v17 = 616;\n        v7 = v18 = 0;\n        v8 = v19 = 0;\n        v9 = v20 = 868;\n        v11 = block.timestamp / 0x15180;\n    }\n    v21 = v22 = ___function_selector__;\n    while (v21 < _investors.length) {\n        assert(v21 < _investors.length);\n        MEM[0] = 2;\n        if (_balance >= STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100) {\n            assert(v21 < _investors.length);\n            MEM[0] = 2;\n            if (STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0 + (v21 << 2)] < v11) {\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                if (0xff & STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] <= 0) {\n                    ___function_selector__ = v21;\n                }\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                v23 = address(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + (v21 << 2)]).call().value(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100);\n                assert(v21 < _investors.length);\n                MEM[0] = 2;\n                STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0 + (v21 << 2)] = v11;\n                assert(v21 < _investors.length);\n                STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] = ~0 + (STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] & 0xff) | STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1 + (v21 << 2)] & ~0xff;\n                _balance = _balance - STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100;\n                assert(v21 < _investors.length);\n                emit Payout(address(STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + (v21 << 2)]), STORAGE[0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf + (v21 << 2)] / 100);\n            }\n            v21 += 1;\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 23.07679557800293,
	"usage": {
		"completion_tokens": 449,
		"prompt_tokens": 2806,
		"total_tokens": 3255
	}
}