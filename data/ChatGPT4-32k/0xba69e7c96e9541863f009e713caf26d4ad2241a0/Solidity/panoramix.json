{
	"address": "0xba69e7c96e9541863f009e713caf26d4ad2241a0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on your decompiled code, here is the equivalent Solidity contract:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract InvestmentContract {\n    struct Investor {\n        address addr;\n        uint256 value;\n        uint256 timestamp;\n        uint256 rate;\n    }\n\n    address public currentManagerAddress;\n    uint256 public balance;\n    address private stor0;\n    uint256[] private stor1;\n    Investor[] private stor2;\n\n    event Invest(address indexed investor, uint256 amount);\n    event Payout(address indexed to, uint256 value);\n\n    function currentManager() public view returns (address) {\n        return currentManagerAddress;\n    }\n\n    function balance() public view returns (uint256) {\n        return balance;\n    }\n\n    function found() public payable {\n        require(msg.sender == stor0);\n        balance += msg.value;\n    }\n\n    function setOfficialWebsite(string _url) public {\n        require(msg.sender == stor0);\n        stor1.length = bytes(_url).length;\n        for(uint i=0; i<stor1.length; i++) {\n            stor1[i] = uint256(bytes(_url)[i]);\n        }\n    }\n\n    function investors(uint256 _param1) public view returns (address, uint256, uint256, uint8) {\n        require(_param1 < stor2.length);\n        return (stor2[_param1].addr, stor2[_param1].value, stor2[_param1].timestamp, uint8(stor2[_param1].rate));\n    }\n\n    function invest() public payable {\n        stor2.push(Investor(msg.sender, msg.value, block.timestamp / 24 * 3600, getRate(msg.value)));\n        balance += 99 * msg.value / 100;\n        currentManagerAddress.transfer(msg.value / 100);\n        emit Invest(msg.sender, msg.value);\n    }\n\n    function getRate(uint256 value) private pure returns (uint256) {\n        if(value <= 10**18) return 110;\n        if(value <= 10 * 10**18) return 120;\n        if(value <= 100 * 10**18) return 130;\n        return 0;\n    }\n\n    function() public payable {\n        require(msg.value >= 10**17);\n        stor2.push(Investor(msg.sender, msg.value, block.timestamp / 24 * 3600, getRate(msg.value)));\n        balance += 99 * msg.value / 100;\n        currentManagerAddress.transfer(msg.value / 100);\n        emit Invest(msg.sender, msg.value);\n\n        uint256 idx = 0;\n        uint256 s = 0;\n        while(idx < stor2.length) {\n            if(balance < stor2[idx].value / 100) return;\n            if(stor2[idx].timestamp < block.timestamp / 24 * 3600) {\n                if(uint8(stor2[idx].rate) <= 0) idx++;\n                stor2[idx].addr.transfer(stor2[idx].value / 100);\n                stor2[idx].timestamp = block.timestamp / 24 * 3600;\n                stor2[idx].rate = uint8(stor2[idx].rate) - 1;\n                balance -= stor2[idx].value / 100;\n                emit Payout(stor2[idx].addr, stor2[idx].value / 100);\n            }\n            idx++;\n            s = stor2[idx].value / 100;\n        }\n    }\n}\n```\nThis Solidity code is not a 100% match for the given decompiled code due to the absence of some information. Some assumptions have been made, and the code may need adjustments based on the specific requirements. Please review and modify accordingly.",
				"role": "assistant"
			}
		}
	],
	"created": 1700473275,
	"id": "chatcmpl-8Mv4FPdXgaCn41ZVL637VBMb7Kr4E",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is addr at storage 0\n  stor1 is array of uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is uint256 at storage 3\n  currentManagerAddress is addr at storage 4\n  balance is uint256 at storage 5\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403023 is array of uint256 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403024 is array of uint256 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403025 is array of uint8 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1\n\ndef currentManager() payable: \n  return currentManagerAddress\n\ndef balance() payable: \n  return balance\n\n#\n#  Regular functions\n#\n\ndef found() payable: \n  require caller == stor0\n  balance += call.value\n\ndef setOfficialWebsite(string _url) payable: \n  require caller == stor0\n  stor1[] = Array(len=_url.length, data=_url[all])\n\ndef investors(uint256 _param1) payable: \n  require _param1 < stor2.length\n  return stor2[_param1].field_0, stor4057[_param1], stor4057[_param1], uint8(stor4057[_param1])\n\ndef invest() payable: \n  stor2.length++\n  if not stor2.length <= stor2.length + 1:\n      idx = 4 * stor2.length + 1\n      while 4 * stor2.length > idx:\n          stor2[idx].field_0 = 0\n          stor2[idx].field_256 = 0\n          stor2[idx].field_512 = 0\n          stor2[idx].field_768 = 0\n          idx = idx + 1\n          continue \n  stor2[stor2.length].field_0 = caller\n  stor2[stor2.length].field_256 = call.value\n  stor2[stor2.length].field_512 = block.timestamp / 24 * 3600\n  if call.value <= 10^18:\n      stor2[stor2.length].field_768 = 110\n  else:\n      if call.value <= 10 * 10^18:\n          stor2[stor2.length].field_768 = 120\n      else:\n          if call.value <= 100 * 10^18:\n              stor2[stor2.length].field_768 = 130\n          else:\n              stor2[stor2.length].field_768 = 0\n              stor2[stor2.length].field_1024 = 0\n  balance += 99 * call.value / 100\n  call currentManagerAddress with:\n     value call.value / 100 wei\n       gas 0 wei\n  log Invest(\n        address investor=caller,\n        uint256 amount=call.value)\n\ndef _fallback() payable: # default function\n  require call.value >= 10^17\n  stor2.length++\n  if not stor2.length <= stor2.length + 1:\n      idx = 4 * stor2.length + 1\n      while 4 * stor2.length > idx:\n          stor2[idx].field_0 = 0\n          stor2[idx].field_256 = 0\n          stor2[idx].field_512 = 0\n          stor2[idx].field_768 = 0\n          idx = idx + 1\n          continue \n  stor2[stor2.length].field_0 = caller\n  stor2[stor2.length].field_256 = call.value\n  stor2[stor2.length].field_512 = block.timestamp / 24 * 3600\n  if call.value <= 10^18:\n      stor2[stor2.length].field_768 = 110\n  else:\n      if call.value <= 10 * 10^18:\n          stor2[stor2.length].field_768 = 120\n      else:\n          if call.value <= 100 * 10^18:\n              stor2[stor2.length].field_768 = 130\n          else:\n              stor2[stor2.length].field_768 = 0\n              stor2[stor2.length].field_1024 = 0\n  balance += 99 * call.value / 100\n  call currentManagerAddress with:\n     value call.value / 100 wei\n       gas 0 wei\n  log Invest(\n        address investor=caller,\n        uint256 amount=call.value)\n  idx = stor3\n  s = 0\n  while idx < stor2.length:\n      if balance < stor4057[idx] / 100:\n          stop\n      require idx < stor2.length\n      mem[0] = 2\n      if stor4057[idx] < block.timestamp / 24 * 3600:\n          require idx < stor2.length\n          if uint8(stor4057[idx]) <= 0:\n              stor3 = idx\n          require idx < stor2.length\n          call stor2[idx].field_0 with:\n             value stor4057[idx] / 100 wei\n               gas 0 wei\n          mem[0] = 2\n          stor4057[idx] = block.timestamp / 24 * 3600\n          uint256(stor4057[idx]) = uint8(stor4057[idx]) - 1 or Mask(248, 8, uint256(stor4057[idx]))\n          balance -= stor4057[idx] / 100\n          mem[224] = stor2[idx].field_0\n          mem[256] = stor4057[idx] / 100\n          log Payout(\n                address to=stor2[idx].field_0,\n                uint256 value=stor4057[idx] / 100)\n      idx = idx + 1\n      s = stor4057[idx] / 100\n      continue \n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is addr at storage 0\n  stor1 is array of uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is uint256 at storage 3\n  currentManagerAddress is addr at storage 4\n  balance is uint256 at storage 5\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403023 is array of uint256 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403024 is array of uint256 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403025 is array of uint8 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1\n\ndef currentManager() payable: \n  return currentManagerAddress\n\ndef balance() payable: \n  return balance\n\n#\n#  Regular functions\n#\n\ndef found() payable: \n  require caller == stor0\n  balance += call.value\n\ndef setOfficialWebsite(string _url) payable: \n  require caller == stor0\n  stor1[] = Array(len=_url.length, data=_url[all])\n\ndef investors(uint256 _param1) payable: \n  require _param1 < stor2.length\n  return stor2[_param1].field_0, stor4057[_param1], stor4057[_param1], uint8(stor4057[_param1])\n\ndef invest() payable: \n  stor2.length++\n  if not stor2.length <= stor2.length + 1:\n      idx = 4 * stor2.length + 1\n      while 4 * stor2.length > idx:\n          stor2[idx].field_0 = 0\n          stor2[idx].field_256 = 0\n          stor2[idx].field_512 = 0\n          stor2[idx].field_768 = 0\n          idx = idx + 1\n          continue \n  stor2[stor2.length].field_0 = caller\n  stor2[stor2.length].field_256 = call.value\n  stor2[stor2.length].field_512 = block.timestamp / 24 * 3600\n  if call.value <= 10^18:\n      stor2[stor2.length].field_768 = 110\n  else:\n      if call.value <= 10 * 10^18:\n          stor2[stor2.length].field_768 = 120\n      else:\n          if call.value <= 100 * 10^18:\n              stor2[stor2.length].field_768 = 130\n          else:\n              stor2[stor2.length].field_768 = 0\n              stor2[stor2.length].field_1024 = 0\n  balance += 99 * call.value / 100\n  call currentManagerAddress with:\n     value call.value / 100 wei\n       gas 0 wei\n  log Invest(\n        address investor=caller,\n        uint256 amount=call.value)\n\ndef _fallback() payable: # default function\n  require call.value >= 10^17\n  stor2.length++\n  if not stor2.length <= stor2.length + 1:\n      idx = 4 * stor2.length + 1\n      while 4 * stor2.length > idx:\n          stor2[idx].field_0 = 0\n          stor2[idx].field_256 = 0\n          stor2[idx].field_512 = 0\n          stor2[idx].field_768 = 0\n          idx = idx + 1\n          continue \n  stor2[stor2.length].field_0 = caller\n  stor2[stor2.length].field_256 = call.value\n  stor2[stor2.length].field_512 = block.timestamp / 24 * 3600\n  if call.value <= 10^18:\n      stor2[stor2.length].field_768 = 110\n  else:\n      if call.value <= 10 * 10^18:\n          stor2[stor2.length].field_768 = 120\n      else:\n          if call.value <= 100 * 10^18:\n              stor2[stor2.length].field_768 = 130\n          else:\n              stor2[stor2.length].field_768 = 0\n              stor2[stor2.length].field_1024 = 0\n  balance += 99 * call.value / 100\n  call currentManagerAddress with:\n     value call.value / 100 wei\n       gas 0 wei\n  log Invest(\n        address investor=caller,\n        uint256 amount=call.value)\n  idx = stor3\n  s = 0\n  while idx < stor2.length:\n      if balance < stor4057[idx] / 100:\n          stop\n      require idx < stor2.length\n      mem[0] = 2\n      if stor4057[idx] < block.timestamp / 24 * 3600:\n          require idx < stor2.length\n          if uint8(stor4057[idx]) <= 0:\n              stor3 = idx\n          require idx < stor2.length\n          call stor2[idx].field_0 with:\n             value stor4057[idx] / 100 wei\n               gas 0 wei\n          mem[0] = 2\n          stor4057[idx] = block.timestamp / 24 * 3600\n          uint256(stor4057[idx]) = uint8(stor4057[idx]) - 1 or Mask(248, 8, uint256(stor4057[idx]))\n          balance -= stor4057[idx] / 100\n          mem[224] = stor2[idx].field_0\n          mem[256] = stor4057[idx] / 100\n          log Payout(\n                address to=stor2[idx].field_0,\n                uint256 value=stor4057[idx] / 100)\n      idx = idx + 1\n      s = stor4057[idx] / 100\n      continue \n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is addr at storage 0\n  stor1 is array of uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is uint256 at storage 3\n  currentManagerAddress is addr at storage 4\n  balance is uint256 at storage 5\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403023 is array of uint256 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403024 is array of uint256 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad0\n  stor29102676481673041902632991033461445430619272659676223336789171408008386403025 is array of uint8 at storage 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ad1\n\ndef currentManager() payable: \n  return currentManagerAddress\n\ndef balance() payable: \n  return balance\n\n#\n#  Regular functions\n#\n\ndef found() payable: \n  require caller == stor0\n  balance += call.value\n\ndef setOfficialWebsite(string _url) payable: \n  require caller == stor0\n  stor1[] = Array(len=_url.length, data=_url[all])\n\ndef investors(uint256 _param1) payable: \n  require _param1 < stor2.length\n  return stor2[_param1].field_0, stor4057[_param1], stor4057[_param1], uint8(stor4057[_param1])\n\ndef invest() payable: \n  stor2.length++\n  if not stor2.length <= stor2.length + 1:\n      idx = 4 * stor2.length + 1\n      while 4 * stor2.length > idx:\n          stor2[idx].field_0 = 0\n          stor2[idx].field_256 = 0\n          stor2[idx].field_512 = 0\n          stor2[idx].field_768 = 0\n          idx = idx + 1\n          continue \n  stor2[stor2.length].field_0 = caller\n  stor2[stor2.length].field_256 = call.value\n  stor2[stor2.length].field_512 = block.timestamp / 24 * 3600\n  if call.value <= 10^18:\n      stor2[stor2.length].field_768 = 110\n  else:\n      if call.value <= 10 * 10^18:\n          stor2[stor2.length].field_768 = 120\n      else:\n          if call.value <= 100 * 10^18:\n              stor2[stor2.length].field_768 = 130\n          else:\n              stor2[stor2.length].field_768 = 0\n              stor2[stor2.length].field_1024 = 0\n  balance += 99 * call.value / 100\n  call currentManagerAddress with:\n     value call.value / 100 wei\n       gas 0 wei\n  log Invest(\n        address investor=caller,\n        uint256 amount=call.value)\n\ndef _fallback() payable: # default function\n  require call.value >= 10^17\n  stor2.length++\n  if not stor2.length <= stor2.length + 1:\n      idx = 4 * stor2.length + 1\n      while 4 * stor2.length > idx:\n          stor2[idx].field_0 = 0\n          stor2[idx].field_256 = 0\n          stor2[idx].field_512 = 0\n          stor2[idx].field_768 = 0\n          idx = idx + 1\n          continue \n  stor2[stor2.length].field_0 = caller\n  stor2[stor2.length].field_256 = call.value\n  stor2[stor2.length].field_512 = block.timestamp / 24 * 3600\n  if call.value <= 10^18:\n      stor2[stor2.length].field_768 = 110\n  else:\n      if call.value <= 10 * 10^18:\n          stor2[stor2.length].field_768 = 120\n      else:\n          if call.value <= 100 * 10^18:\n              stor2[stor2.length].field_768 = 130\n          else:\n              stor2[stor2.length].field_768 = 0\n              stor2[stor2.length].field_1024 = 0\n  balance += 99 * call.value / 100\n  call currentManagerAddress with:\n     value call.value / 100 wei\n       gas 0 wei\n  log Invest(\n        address investor=caller,\n        uint256 amount=call.value)\n  idx = stor3\n  s = 0\n  while idx < stor2.length:\n      if balance < stor4057[idx] / 100:\n          stop\n      require idx < stor2.length\n      mem[0] = 2\n      if stor4057[idx] < block.timestamp / 24 * 3600:\n          require idx < stor2.length\n          if uint8(stor4057[idx]) <= 0:\n              stor3 = idx\n          require idx < stor2.length\n          call stor2[idx].field_0 with:\n             value stor4057[idx] / 100 wei\n               gas 0 wei\n          mem[0] = 2\n          stor4057[idx] = block.timestamp / 24 * 3600\n          uint256(stor4057[idx]) = uint8(stor4057[idx]) - 1 or Mask(248, 8, uint256(stor4057[idx]))\n          balance -= stor4057[idx] / 100\n          mem[224] = stor2[idx].field_0\n          mem[256] = stor4057[idx] / 100\n          log Payout(\n                address to=stor2[idx].field_0,\n                uint256 value=stor4057[idx] / 100)\n      idx = idx + 1\n      s = stor4057[idx] / 100\n      continue \n\n.",
	"status": "1",
	"time_cost": 63.01199507713318,
	"usage": {
		"completion_tokens": 763,
		"prompt_tokens": 1470,
		"total_tokens": 2233
	}
}