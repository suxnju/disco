{
	"address": "0x3c2156807013969f7d564b6f5f7caf214ec9c001",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code corresponding to the given decompiled code:\n\n```solidity\npragma solidity ^0.8.20;\n\ncontract MyContract {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    mapping (address => bool) private _isBot;\n    address private _owner;\n    bool private _transferDelayEnabled;\n    address private _manualSwap;\n    address private _uniswapV2Router;\n    address private _uniswapV2Pair;\n    uint256 private _maxTxAmount;\n    uint256 private _maxWalletSize;\n    uint256 private _taxSwapThreshold;\n    uint256 private _maxTaxSwap;\n    bool private _swapTokensAtAmount;\n    bool private _tradingOpen;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        // constructor logic\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0), \"ERC20: approve from the zero address\");\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(value <= _balanceOf[from], \"ERC20: transfer value exceeds balance\");\n        require(value <= _allowance[from][msg.sender], \"ERC20: transfer value exceeds allowance\");\n\n        _balanceOf[from] = _balanceOf[from] - value;\n        _balanceOf[to] = _balanceOf[to] + value;\n        _allowance[from][msg.sender] = _allowance[from][msg.sender] - value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(value <= _balanceOf[msg.sender], \"ERC20: transfer value exceeds balance\");\n\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - value;\n        _balanceOf[to] = _balanceOf[to] + value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function totalSupply() public pure returns (uint256) {\n        // return total supply\n    }\n\n    function name() public pure returns (string memory) {\n        // return name\n    }\n\n    function symbol() public pure returns (string memory) {\n        // return symbol\n    }\n\n    function decimals() public pure returns (uint8) {\n        // return decimals\n    }\n    \n    // Additional functions based on the original code\n}\n```\nPlease note that the original code seems to be part of a larger contract, and a number of functions are missing from the decompiled code, so it was not possible to fully recreate the original Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701485926,
	"id": "chatcmpl-8RAVK3K4KNciHFZIotcYP7nw5dua2",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.20 14:31 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x5]\nmapping (uint256 => uint256) owner_6; // STORAGE[0x6]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __maxTxAmount; // STORAGE[0x10]\nuint256 __maxWalletSize; // STORAGE[0x11]\nuint256 __taxSwapThreshold; // STORAGE[0x12]\nuint256 __maxTaxSwap; // STORAGE[0x13]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x7] bytes 0 to 0\nuint256 _manualSwap; // STORAGE[0x7] bytes 1 to 20\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 owner_15_0_19; // STORAGE[0x15] bytes 0 to 19\nuint256 _@swapTokensForEth_1158; // STORAGE[0x15] bytes 20 to 20\nuint256 stor_15_21_21; // STORAGE[0x15] bytes 21 to 21\nuint256 stor_15_22_22; // STORAGE[0x15] bytes 22 to 22\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction @_approve_725(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1067(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = varg2 != _owner;\n    if (!bool(address(varg2) == _owner)) {\n        v2 = v4 = address(varg1) != _owner;\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(address(varg2))]);\n        if (!bool(uint8(_isBot[address(address(varg2))]))) {\n            v5 = v7 = !uint8(_isBot[address(address(varg1))]);\n        }\n        require(v5);\n        if (_transferDelayEnabled) {\n            v8 = v9 = address(varg1) != stor_14_0_19;\n            if (!bool(address(varg1) == stor_14_0_19)) {\n                v8 = v10 = address(varg1) != owner_15_0_19;\n            }\n            if (v8) {\n                require(owner_6[address(tx.origin)] < block.number, Error('Only one transfer per block allowed.'));\n                owner_6[address(tx.origin)] = block.number;\n            }\n        }\n        v11 = v12 = varg2 == owner_15_0_19;\n        if (v12) {\n            v11 = v13 = address(varg1) != stor_14_0_19;\n        }\n        if (v11) {\n            v11 = v14 = !uint8(map_3[address(address(varg1))]);\n        }\n        if (v11) {\n            require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n            require(_balanceOf[address(varg1)] <= _balanceOf[address(varg1)] + varg0, Panic(17)); // arithmetic overflow or underflow\n            require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n            if (stor_f < stor_e) {\n                require(varg1.code.size <= 0);\n            }\n            require(stor_f - uint256.max, Panic(17)); // arithmetic overflow or underflow\n            stor_f = stor_f + 1;\n            owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(address(varg1))]);\n        }\n        v15 = v16 = 6224;\n        v17 = v18 = 100;\n        v19 = v20 = 6210;\n        if (stor_f > stor_c) {\n            v21 = v22 = stor_a;\n        } else {\n            v21 = v23 = stor_8;\n        }\n        while (1) {\n            if (varg0 - 0) {\n                // Unknown jump to Block 0x2100. Refer to 3-address code (TAC);\n            }\n            v24 = v25 = 0;\n            // Unknown jump to Block {'0x1842', '0x1952'}. Refer to 3-address code (TAC);\n            if (v17 > 0) {\n                require(v17, Panic(18)); // division by zero\n                v0 = v24 / v17;\n                // Unknown jump to Block {'0x1960', '0x1850'}. Refer to 3-address code (TAC);\n                v26 = v27 = address(varg1) == owner_15_0_19;\n                if (v27) {\n                    v26 = v28 = varg2 != address(this);\n                }\n                if (v26) {\n                    require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                    v15 = v29 = 6496;\n                    v17 = v30 = 100;\n                    v19 = v31 = 6482;\n                    if (stor_f > stor_d) {\n                        v21 = v32 = stor_b;\n                    } else {\n                        v21 = v33 = stor_9;\n                    }\n                }\n                v34 = v35 = !stor_15_21_21;\n                if (!stor_15_21_21) {\n                    v34 = v36 = address(varg1) == owner_15_0_19;\n                }\n                if (v34) {\n                    v34 = v37 = stor_15_22_22;\n                }\n                if (v34) {\n                    v34 = v38 = _balanceOf[address(this)] > __taxSwapThreshold;\n                }\n                if (v34) {\n                    v34 = v39 = stor_f > stor_e;\n                }\n                if (v34) {\n                    v40 = @min_1085(__maxTaxSwap, _balanceOf[address(this)]);\n                    v41 = @min_1085(v40, varg0);\n                    @swapTokensForEth_1158(v41);\n                    if (this.balance > 0) {\n                        v42 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n                        require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    }\n                }\n                v43 = v44 = stor_f > stor_e;\n                if (stor_f <= stor_e) {\n                    v43 = v45 = uint8(owner_4[address(address(varg2))]);\n                }\n                require(v43, Error('Seller is not buyer'));\n            } else {\n                v46 = new bytes[](v47.length);\n                v48 = v49 = 0;\n                while (v48 < v47.length) {\n                    v46[v48] = v47[v48];\n                    v48 = v48 + 32;\n                }\n                v46[v47.length] = 0;\n                revert(Error(v46, v50, 'SafeMath: division by zero'));\n            }\n            // Unknown jump to Block 0x2167. Refer to 3-address code (TAC);\n            v24 = varg0 * v21;\n            require(!varg0 | (v21 == v24 / varg0), Panic(17)); // arithmetic overflow or underflow\n            require(varg0, Panic(18)); // division by zero\n            require(v24 / varg0 == v21, Error('SafeMath: multiplication overflow'));\n        }\n    }\n    if (v0 > 0) {\n        v51 = _SafeAdd(v0, _balanceOf[address(this)]);\n        _balanceOf[address(this)] = v51;\n        emit Transfer(varg2, address(this), v0);\n    }\n    v52 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v52;\n    v53 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v54 = _SafeAdd(v53, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v54;\n    v55 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64] + 0] = v55;\n    emit Transfer(varg2, address(varg1), v55);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_approve_725(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    return 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @swapTokensForEth_1158(uint256 varg0) private { \n    stor_15_21_21 = 1;\n    if (varg0 - 0) {\n        if (_@swapTokensForEth_1158) {\n            require(2 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n            v0 = new address[](2);\n            if (2) {\n                CALLDATACOPY(v0.data, msg.data.length, 64);\n            }\n            require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v1 = v0.data;\n            v0[0] = address(this);\n            v2, /* address */ v3 = stor_14_0_19.WETH().gas(msg.gas);\n            require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            validator_revert_t_address(v3);\n            require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v0[1] = address(v3);\n            @_approve_725(varg0, stor_14_0_19, this);\n            v4 = new address[](v0.length);\n            v5 = v6 = v4.data;\n            v7 = v8 = v0.data;\n            v9 = v10 = 0;\n            while (v9 < v0.length) {\n                MEM[v5] = address(MEM[v7]);\n                v5 = v5 + 32;\n                v7 = v7 + 32;\n                v9 = v9 + 1;\n            }\n            require(bool(stor_14_0_19.code.size));\n            v11 = stor_14_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n            require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        }\n    }\n    stor_15_21_21 = 0;\n    return ;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    validator_revert_t_uint256(varg2);\n    @_transfer_1067(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_725(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction @min_1085(uint256 varg0, uint256 varg1) private { \n    if (varg1 <= varg0) {\n    }\n    return varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return uint8(8);\n}\n\nfunction validator_revert_t_address(address varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction validator_revert_t_uint256(uint256 varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_isBot[address(address(varg0))]));\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                require(2 ** varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n                return 2 ** varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > 1) {\n                    require(varg0 <= varg2 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & 0x1) {\n                        v0 = v0 * varg0;\n                    }\n                    varg0 *= varg0;\n                    varg1 = varg1 >> 1;\n                }\n                require(v0 <= varg2 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return v0 * varg0;\n            } else {\n                require(varg0 ** varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    if (_balanceOf[address(this)] > 0) {\n        @swapTokensForEth_1158(_balanceOf[address(this)]);\n    }\n    if (this.balance > 0) {\n        v0 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, address(0x0));\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0;\n    v1 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v1 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v1 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v1;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v2 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v2 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v2);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction PumpIt() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_@swapTokensForEth_1158, Error('trading is already open'));\n    stor_14_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    @_approve_725(0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0, stor_14_0_19, this);\n    v1, /* address */ v2 = stor_14_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v2);\n    v3, /* address */ v4 = stor_14_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v4);\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v6);\n    owner_15_0_19 = v6;\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_14_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    validator_revert_t_uint256(v8);\n    validator_revert_t_uint256(v9);\n    validator_revert_t_uint256(v10);\n    v11, /* bool */ v12 = owner_15_0_19.approve(stor_14_0_19, uint256.max).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    stor_15_22_22 = 1;\n    _@swapTokensForEth_1158 = 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction () public payable { \n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    v0[v1.length] = 0;\n    return v0, v4, 0x4d454d4500000000000000000000000000000000000000000000000000000000;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_transfer_1067(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    return _allowance[varg0][varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0x95d89b41 > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x88d68e99 == function_selector >> 224) {\n            PumpIt();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x8f9a55c0 == function_selector >> 224);\n            _maxWalletSize();\n        }\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 14:31 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x5]\nmapping (uint256 => uint256) owner_6; // STORAGE[0x6]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __maxTxAmount; // STORAGE[0x10]\nuint256 __maxWalletSize; // STORAGE[0x11]\nuint256 __taxSwapThreshold; // STORAGE[0x12]\nuint256 __maxTaxSwap; // STORAGE[0x13]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x7] bytes 0 to 0\nuint256 _manualSwap; // STORAGE[0x7] bytes 1 to 20\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 owner_15_0_19; // STORAGE[0x15] bytes 0 to 19\nuint256 _@swapTokensForEth_1158; // STORAGE[0x15] bytes 20 to 20\nuint256 stor_15_21_21; // STORAGE[0x15] bytes 21 to 21\nuint256 stor_15_22_22; // STORAGE[0x15] bytes 22 to 22\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction @_approve_725(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1067(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = varg2 != _owner;\n    if (!bool(address(varg2) == _owner)) {\n        v2 = v4 = address(varg1) != _owner;\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(address(varg2))]);\n        if (!bool(uint8(_isBot[address(address(varg2))]))) {\n            v5 = v7 = !uint8(_isBot[address(address(varg1))]);\n        }\n        require(v5);\n        if (_transferDelayEnabled) {\n            v8 = v9 = address(varg1) != stor_14_0_19;\n            if (!bool(address(varg1) == stor_14_0_19)) {\n                v8 = v10 = address(varg1) != owner_15_0_19;\n            }\n            if (v8) {\n                require(owner_6[address(tx.origin)] < block.number, Error('Only one transfer per block allowed.'));\n                owner_6[address(tx.origin)] = block.number;\n            }\n        }\n        v11 = v12 = varg2 == owner_15_0_19;\n        if (v12) {\n            v11 = v13 = address(varg1) != stor_14_0_19;\n        }\n        if (v11) {\n            v11 = v14 = !uint8(map_3[address(address(varg1))]);\n        }\n        if (v11) {\n            require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n            require(_balanceOf[address(varg1)] <= _balanceOf[address(varg1)] + varg0, Panic(17)); // arithmetic overflow or underflow\n            require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n            if (stor_f < stor_e) {\n                require(varg1.code.size <= 0);\n            }\n            require(stor_f - uint256.max, Panic(17)); // arithmetic overflow or underflow\n            stor_f = stor_f + 1;\n            owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(address(varg1))]);\n        }\n        v15 = v16 = 6224;\n        v17 = v18 = 100;\n        v19 = v20 = 6210;\n        if (stor_f > stor_c) {\n            v21 = v22 = stor_a;\n        } else {\n            v21 = v23 = stor_8;\n        }\n        while (1) {\n            if (varg0 - 0) {\n                // Unknown jump to Block 0x2100. Refer to 3-address code (TAC);\n            }\n            v24 = v25 = 0;\n            // Unknown jump to Block {'0x1842', '0x1952'}. Refer to 3-address code (TAC);\n            if (v17 > 0) {\n                require(v17, Panic(18)); // division by zero\n                v0 = v24 / v17;\n                // Unknown jump to Block {'0x1960', '0x1850'}. Refer to 3-address code (TAC);\n                v26 = v27 = address(varg1) == owner_15_0_19;\n                if (v27) {\n                    v26 = v28 = varg2 != address(this);\n                }\n                if (v26) {\n                    require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                    v15 = v29 = 6496;\n                    v17 = v30 = 100;\n                    v19 = v31 = 6482;\n                    if (stor_f > stor_d) {\n                        v21 = v32 = stor_b;\n                    } else {\n                        v21 = v33 = stor_9;\n                    }\n                }\n                v34 = v35 = !stor_15_21_21;\n                if (!stor_15_21_21) {\n                    v34 = v36 = address(varg1) == owner_15_0_19;\n                }\n                if (v34) {\n                    v34 = v37 = stor_15_22_22;\n                }\n                if (v34) {\n                    v34 = v38 = _balanceOf[address(this)] > __taxSwapThreshold;\n                }\n                if (v34) {\n                    v34 = v39 = stor_f > stor_e;\n                }\n                if (v34) {\n                    v40 = @min_1085(__maxTaxSwap, _balanceOf[address(this)]);\n                    v41 = @min_1085(v40, varg0);\n                    @swapTokensForEth_1158(v41);\n                    if (this.balance > 0) {\n                        v42 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n                        require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    }\n                }\n                v43 = v44 = stor_f > stor_e;\n                if (stor_f <= stor_e) {\n                    v43 = v45 = uint8(owner_4[address(address(varg2))]);\n                }\n                require(v43, Error('Seller is not buyer'));\n            } else {\n                v46 = new bytes[](v47.length);\n                v48 = v49 = 0;\n                while (v48 < v47.length) {\n                    v46[v48] = v47[v48];\n                    v48 = v48 + 32;\n                }\n                v46[v47.length] = 0;\n                revert(Error(v46, v50, 'SafeMath: division by zero'));\n            }\n            // Unknown jump to Block 0x2167. Refer to 3-address code (TAC);\n            v24 = varg0 * v21;\n            require(!varg0 | (v21 == v24 / varg0), Panic(17)); // arithmetic overflow or underflow\n            require(varg0, Panic(18)); // division by zero\n            require(v24 / varg0 == v21, Error('SafeMath: multiplication overflow'));\n        }\n    }\n    if (v0 > 0) {\n        v51 = _SafeAdd(v0, _balanceOf[address(this)]);\n        _balanceOf[address(this)] = v51;\n        emit Transfer(varg2, address(this), v0);\n    }\n    v52 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v52;\n    v53 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v54 = _SafeAdd(v53, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v54;\n    v55 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64] + 0] = v55;\n    emit Transfer(varg2, address(varg1), v55);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_approve_725(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    return 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @swapTokensForEth_1158(uint256 varg0) private { \n    stor_15_21_21 = 1;\n    if (varg0 - 0) {\n        if (_@swapTokensForEth_1158) {\n            require(2 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n            v0 = new address[](2);\n            if (2) {\n                CALLDATACOPY(v0.data, msg.data.length, 64);\n            }\n            require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v1 = v0.data;\n            v0[0] = address(this);\n            v2, /* address */ v3 = stor_14_0_19.WETH().gas(msg.gas);\n            require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            validator_revert_t_address(v3);\n            require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v0[1] = address(v3);\n            @_approve_725(varg0, stor_14_0_19, this);\n            v4 = new address[](v0.length);\n            v5 = v6 = v4.data;\n            v7 = v8 = v0.data;\n            v9 = v10 = 0;\n            while (v9 < v0.length) {\n                MEM[v5] = address(MEM[v7]);\n                v5 = v5 + 32;\n                v7 = v7 + 32;\n                v9 = v9 + 1;\n            }\n            require(bool(stor_14_0_19.code.size));\n            v11 = stor_14_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n            require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        }\n    }\n    stor_15_21_21 = 0;\n    return ;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    validator_revert_t_uint256(varg2);\n    @_transfer_1067(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_725(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction @min_1085(uint256 varg0, uint256 varg1) private { \n    if (varg1 <= varg0) {\n    }\n    return varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return uint8(8);\n}\n\nfunction validator_revert_t_address(address varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction validator_revert_t_uint256(uint256 varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_isBot[address(address(varg0))]));\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                require(2 ** varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n                return 2 ** varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > 1) {\n                    require(varg0 <= varg2 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & 0x1) {\n                        v0 = v0 * varg0;\n                    }\n                    varg0 *= varg0;\n                    varg1 = varg1 >> 1;\n                }\n                require(v0 <= varg2 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return v0 * varg0;\n            } else {\n                require(varg0 ** varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    if (_balanceOf[address(this)] > 0) {\n        @swapTokensForEth_1158(_balanceOf[address(this)]);\n    }\n    if (this.balance > 0) {\n        v0 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, address(0x0));\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0;\n    v1 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v1 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v1 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v1;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v2 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v2 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v2);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction PumpIt() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_@swapTokensForEth_1158, Error('trading is already open'));\n    stor_14_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    @_approve_725(0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0, stor_14_0_19, this);\n    v1, /* address */ v2 = stor_14_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v2);\n    v3, /* address */ v4 = stor_14_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v4);\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v6);\n    owner_15_0_19 = v6;\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_14_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    validator_revert_t_uint256(v8);\n    validator_revert_t_uint256(v9);\n    validator_revert_t_uint256(v10);\n    v11, /* bool */ v12 = owner_15_0_19.approve(stor_14_0_19, uint256.max).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    stor_15_22_22 = 1;\n    _@swapTokensForEth_1158 = 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction () public payable { \n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    v0[v1.length] = 0;\n    return v0, v4, 0x4d454d4500000000000000000000000000000000000000000000000000000000;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_transfer_1067(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    return _allowance[varg0][varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0x95d89b41 > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x88d68e99 == function_selector >> 224) {\n            PumpIt();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x8f9a55c0 == function_selector >> 224);\n            _maxWalletSize();\n        }\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 14:31 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x5]\nmapping (uint256 => uint256) owner_6; // STORAGE[0x6]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __maxTxAmount; // STORAGE[0x10]\nuint256 __maxWalletSize; // STORAGE[0x11]\nuint256 __taxSwapThreshold; // STORAGE[0x12]\nuint256 __maxTaxSwap; // STORAGE[0x13]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x7] bytes 0 to 0\nuint256 _manualSwap; // STORAGE[0x7] bytes 1 to 20\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 owner_15_0_19; // STORAGE[0x15] bytes 0 to 19\nuint256 _@swapTokensForEth_1158; // STORAGE[0x15] bytes 20 to 20\nuint256 stor_15_21_21; // STORAGE[0x15] bytes 21 to 21\nuint256 stor_15_22_22; // STORAGE[0x15] bytes 22 to 22\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction @_approve_725(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1067(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = varg2 != _owner;\n    if (!bool(address(varg2) == _owner)) {\n        v2 = v4 = address(varg1) != _owner;\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(address(varg2))]);\n        if (!bool(uint8(_isBot[address(address(varg2))]))) {\n            v5 = v7 = !uint8(_isBot[address(address(varg1))]);\n        }\n        require(v5);\n        if (_transferDelayEnabled) {\n            v8 = v9 = address(varg1) != stor_14_0_19;\n            if (!bool(address(varg1) == stor_14_0_19)) {\n                v8 = v10 = address(varg1) != owner_15_0_19;\n            }\n            if (v8) {\n                require(owner_6[address(tx.origin)] < block.number, Error('Only one transfer per block allowed.'));\n                owner_6[address(tx.origin)] = block.number;\n            }\n        }\n        v11 = v12 = varg2 == owner_15_0_19;\n        if (v12) {\n            v11 = v13 = address(varg1) != stor_14_0_19;\n        }\n        if (v11) {\n            v11 = v14 = !uint8(map_3[address(address(varg1))]);\n        }\n        if (v11) {\n            require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n            require(_balanceOf[address(varg1)] <= _balanceOf[address(varg1)] + varg0, Panic(17)); // arithmetic overflow or underflow\n            require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n            if (stor_f < stor_e) {\n                require(varg1.code.size <= 0);\n            }\n            require(stor_f - uint256.max, Panic(17)); // arithmetic overflow or underflow\n            stor_f = stor_f + 1;\n            owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(address(varg1))]);\n        }\n        v15 = v16 = 6224;\n        v17 = v18 = 100;\n        v19 = v20 = 6210;\n        if (stor_f > stor_c) {\n            v21 = v22 = stor_a;\n        } else {\n            v21 = v23 = stor_8;\n        }\n        while (1) {\n            if (varg0 - 0) {\n                // Unknown jump to Block 0x2100. Refer to 3-address code (TAC);\n            }\n            v24 = v25 = 0;\n            // Unknown jump to Block {'0x1842', '0x1952'}. Refer to 3-address code (TAC);\n            if (v17 > 0) {\n                require(v17, Panic(18)); // division by zero\n                v0 = v24 / v17;\n                // Unknown jump to Block {'0x1960', '0x1850'}. Refer to 3-address code (TAC);\n                v26 = v27 = address(varg1) == owner_15_0_19;\n                if (v27) {\n                    v26 = v28 = varg2 != address(this);\n                }\n                if (v26) {\n                    require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                    v15 = v29 = 6496;\n                    v17 = v30 = 100;\n                    v19 = v31 = 6482;\n                    if (stor_f > stor_d) {\n                        v21 = v32 = stor_b;\n                    } else {\n                        v21 = v33 = stor_9;\n                    }\n                }\n                v34 = v35 = !stor_15_21_21;\n                if (!stor_15_21_21) {\n                    v34 = v36 = address(varg1) == owner_15_0_19;\n                }\n                if (v34) {\n                    v34 = v37 = stor_15_22_22;\n                }\n                if (v34) {\n                    v34 = v38 = _balanceOf[address(this)] > __taxSwapThreshold;\n                }\n                if (v34) {\n                    v34 = v39 = stor_f > stor_e;\n                }\n                if (v34) {\n                    v40 = @min_1085(__maxTaxSwap, _balanceOf[address(this)]);\n                    v41 = @min_1085(v40, varg0);\n                    @swapTokensForEth_1158(v41);\n                    if (this.balance > 0) {\n                        v42 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n                        require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    }\n                }\n                v43 = v44 = stor_f > stor_e;\n                if (stor_f <= stor_e) {\n                    v43 = v45 = uint8(owner_4[address(address(varg2))]);\n                }\n                require(v43, Error('Seller is not buyer'));\n            } else {\n                v46 = new bytes[](v47.length);\n                v48 = v49 = 0;\n                while (v48 < v47.length) {\n                    v46[v48] = v47[v48];\n                    v48 = v48 + 32;\n                }\n                v46[v47.length] = 0;\n                revert(Error(v46, v50, 'SafeMath: division by zero'));\n            }\n            // Unknown jump to Block 0x2167. Refer to 3-address code (TAC);\n            v24 = varg0 * v21;\n            require(!varg0 | (v21 == v24 / varg0), Panic(17)); // arithmetic overflow or underflow\n            require(varg0, Panic(18)); // division by zero\n            require(v24 / varg0 == v21, Error('SafeMath: multiplication overflow'));\n        }\n    }\n    if (v0 > 0) {\n        v51 = _SafeAdd(v0, _balanceOf[address(this)]);\n        _balanceOf[address(this)] = v51;\n        emit Transfer(varg2, address(this), v0);\n    }\n    v52 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v52;\n    v53 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v54 = _SafeAdd(v53, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v54;\n    v55 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64] + 0] = v55;\n    emit Transfer(varg2, address(varg1), v55);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_approve_725(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    return 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @swapTokensForEth_1158(uint256 varg0) private { \n    stor_15_21_21 = 1;\n    if (varg0 - 0) {\n        if (_@swapTokensForEth_1158) {\n            require(2 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n            v0 = new address[](2);\n            if (2) {\n                CALLDATACOPY(v0.data, msg.data.length, 64);\n            }\n            require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v1 = v0.data;\n            v0[0] = address(this);\n            v2, /* address */ v3 = stor_14_0_19.WETH().gas(msg.gas);\n            require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            validator_revert_t_address(v3);\n            require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v0[1] = address(v3);\n            @_approve_725(varg0, stor_14_0_19, this);\n            v4 = new address[](v0.length);\n            v5 = v6 = v4.data;\n            v7 = v8 = v0.data;\n            v9 = v10 = 0;\n            while (v9 < v0.length) {\n                MEM[v5] = address(MEM[v7]);\n                v5 = v5 + 32;\n                v7 = v7 + 32;\n                v9 = v9 + 1;\n            }\n            require(bool(stor_14_0_19.code.size));\n            v11 = stor_14_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n            require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        }\n    }\n    stor_15_21_21 = 0;\n    return ;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    validator_revert_t_uint256(varg2);\n    @_transfer_1067(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_725(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction @min_1085(uint256 varg0, uint256 varg1) private { \n    if (varg1 <= varg0) {\n    }\n    return varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return uint8(8);\n}\n\nfunction validator_revert_t_address(address varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction validator_revert_t_uint256(uint256 varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_isBot[address(address(varg0))]));\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                require(2 ** varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n                return 2 ** varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > 1) {\n                    require(varg0 <= varg2 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & 0x1) {\n                        v0 = v0 * varg0;\n                    }\n                    varg0 *= varg0;\n                    varg1 = varg1 >> 1;\n                }\n                require(v0 <= varg2 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return v0 * varg0;\n            } else {\n                require(varg0 ** varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    if (_balanceOf[address(this)] > 0) {\n        @swapTokensForEth_1158(_balanceOf[address(this)]);\n    }\n    if (this.balance > 0) {\n        v0 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, address(0x0));\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0;\n    v1 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v1 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v1 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v1;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v2 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v2 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v2);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction PumpIt() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_@swapTokensForEth_1158, Error('trading is already open'));\n    stor_14_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(8), uint256.max);\n    require(!0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 | (v0 == 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0 / 0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000), Panic(17)); // arithmetic overflow or underflow\n    @_approve_725(0x97edd871cfda3a5697758bf0e3cbb5ac5741c640000000000000000 * v0, stor_14_0_19, this);\n    v1, /* address */ v2 = stor_14_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v2);\n    v3, /* address */ v4 = stor_14_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v4);\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    validator_revert_t_address(v6);\n    owner_15_0_19 = v6;\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_14_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    validator_revert_t_uint256(v8);\n    validator_revert_t_uint256(v9);\n    validator_revert_t_uint256(v10);\n    v11, /* bool */ v12 = owner_15_0_19.approve(stor_14_0_19, uint256.max).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    stor_15_22_22 = 1;\n    _@swapTokensForEth_1158 = 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction () public payable { \n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    v0[v1.length] = 0;\n    return v0, v4, 0x4d454d4500000000000000000000000000000000000000000000000000000000;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_transfer_1067(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    return _allowance[varg0][varg1];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0x95d89b41 > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x88d68e99 == function_selector >> 224) {\n            PumpIt();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x8f9a55c0 == function_selector >> 224);\n            _maxWalletSize();\n        }\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 32.61365294456482,
	"usage": {
		"completion_tokens": 734,
		"prompt_tokens": 6804,
		"total_tokens": 7538
	}
}