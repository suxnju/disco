{
	"address": "0x84eeca28082982abd1d68eadf2c5f509dd181bad",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code you provided is quite abstract and lacks some important details. However, I will attempt to provide a Solidity code that resembles the functionality depicted in the decompiled code. \n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MarketContract {\n    mapping(address => uint256) private _getMyShrimp;\n    mapping(address => uint256) private _claimedEggs;\n    mapping(address => uint256) private _lastHatch;\n    mapping(address => address) private _referrals;\n    uint256 private _marketEggs;\n    bool private _initialized;\n    address private _ceoAddress;\n    uint256 private _eGGS_TO_HATCH_1SHRIMP;\n\n    constructor() public {\n        _ceoAddress = msg.sender;\n    }\n\n    function() external payable {\n        revert();\n    }\n\n    function ceoAddress() public view returns(address) {\n        return _ceoAddress;\n    }\n\n    function getBalance() public view returns(uint256) {\n        return address(this).balance;\n    }\n\n    function initialized() public view returns(bool) {\n        return _initialized;\n    }\n\n    function marketEggs() public view returns(uint256) {\n        return _marketEggs;\n    }\n\n    function seedMarket(uint256 eggs) public payable {\n        require(!_marketEggs);\n        _initialized = true;\n        _marketEggs = eggs;\n    }\n\n    function hatchEggs(address referrer) public {\n        require(_initialized);\n        // ...implementation of hatching eggs\n    }\n\n    function getMyEggs() public view returns(uint256) {\n        return _claimedEggs[msg.sender];\n    }\n\n    function lastHatch(address user) public view returns(uint256) {\n        return _lastHatch[user];\n    }\n\n    function buyEggs() public payable {\n        require(_initialized);\n        // ...implementation of buying eggs\n    }\n\n    function claimedEggs(address user) public view returns(uint256) {\n        return _claimedEggs[user];\n    }\n\n    function EGGS_TO_HATCH_1SHRIMP() public view returns(uint256) {\n        return _eGGS_TO_HATCH_1SHRIMP;\n    }\n\n    function hatcheryShrimp(address user) public view returns(uint256) {\n        return _getMyShrimp[user];\n    }\n\n    function referrals(address user) public view returns(address) {\n        return _referrals[user];\n    }\n\n    function getMyShrimp() public view returns(uint256) {\n        return _getMyShrimp[msg.sender];\n    }\n}\n```\n\nThis is a simple interpretation of the decompiled code. It might not cover all the functionality and the private functions are not implemented. You should adjust it according to your needs and implement the necessary security measures.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465738,
	"id": "chatcmpl-8R5FiEOTbcTUS4sWOetIGin5fLlmf",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 17:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eGGS_TO_HATCH_1SHRIMP; // STORAGE[0x0]\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getMyShrimp; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _claimedEggs; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _lastHatch; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _referrals; // STORAGE[0x7]\nuint256 _marketEggs; // STORAGE[0x8]\nuint8 _initialized; // STORAGE[0x3] bytes 0 to 0\naddress _ceoAddress; // STORAGE[0x3] bytes 1 to 20\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction ceoAddress() public nonPayable { \n    return _ceoAddress;\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction initialized() public nonPayable { \n    return _initialized;\n}\n\nfunction calculateTrade(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0, v1, v2 = 0x36c(varg2, varg1);\n    return v0;\n}\n\nfunction calculateEggBuy(uint256 varg0, uint256 varg1) public nonPayable { \n    v0, v1, v2 = 0x36c(_marketEggs, varg1);\n    return v0;\n}\n\nfunction marketEggs() public nonPayable { \n    return _marketEggs;\n}\n\nfunction sellEggs() public nonPayable { \n    require(_initialized);\n    v0 = 0x811(msg.sender);\n    v1 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    v2, v3, v4 = 0x36c((address(this)).balance, _marketEggs);\n    v5 = 0x4de(v2);\n    _claimedEggs[msg.sender] = 0;\n    _lastHatch[msg.sender] = block.timestamp;\n    v6 = _SafeAdd(1024, _marketEggs);\n    _marketEggs = v6;\n    v7 = _ceoAddress.call().value(v5).gas(!v5 * 2300);\n    require(v7);\n    assert(v5 <= v2);\n    v8 = msg.sender.call().value(v2 - v5).gas(!(v2 - v5) * 2300);\n    require(v8);\n}\n\nfunction seedMarket(uint256 varg0) public payable { \n    require(!_marketEggs);\n    _initialized = 1;\n    _marketEggs = varg0;\n}\n\nfunction devFee(uint256 varg0) public nonPayable { \n    v0 = 0x4de(varg0);\n    return v0;\n}\n\nfunction hatchEggs(address varg0) public nonPayable { \n    require(_initialized);\n    v0 = v1 = !address(_referrals[address(msg.sender)]);\n    if (v1) {\n        v0 = v2 = address(_referrals[address(msg.sender)]) != msg.sender;\n    }\n    if (v0) {\n        _referrals[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrals[msg.sender];\n    }\n    v3 = 0x811(msg.sender);\n    v4 = _SafeAdd(v3, _claimedEggs[msg.sender]);\n    assert(stor_0_0_0);\n    v5 = _SafeAdd(v4 / _eGGS_TO_HATCH_1SHRIMP, _getMyShrimp[msg.sender]);\n    _getMyShrimp[msg.sender] = v5;\n    _getMyShrimp[msg.sender] = 0;\n    _lastHatch[msg.sender] = block.timestamp;\n    v6 = v7 = _lastHatch[address(_lastHatch[address(msg.sender)])];\n    v8 = v9 = 1579;\n    assert(5);\n    v10 = v11 = v4 / 5;\n    while (1) {\n        v12 = _SafeAdd(v10, v6);\n        _referrals[address(_referrals[address(msg.sender)])] = v12;\n        v6 = v13 = _marketEggs;\n        v8 = v14 = 1637;\n        assert(10);\n        v10 = v4 / 10;\n        goto 0x3a10x21a;\n    }\n    _marketEggs = v12;\n}\n\nfunction getMyEggs() public nonPayable { \n    v0 = 0x811(msg.sender);\n    v1 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    return v1;\n}\n\nfunction lastHatch(address varg0) public nonPayable { \n    return _lastHatch[varg0];\n}\n\nfunction buyEggs() public payable { \n    require(_initialized);\n    assert(msg.value <= (address(this)).balance);\n    v0, v1, v2 = 0x36c(_marketEggs, (address(this)).balance - msg.value);\n    v3 = 0x4de(v0);\n    assert(v3 <= v0);\n    v4 = 0x4de(msg.value);\n    v5 = _ceoAddress.call().value(v4).gas(!v4 * 2300);\n    require(v5);\n    v6 = _SafeAdd(v0 - v3, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v6;\n}\n\nfunction claimedEggs(address varg0) public nonPayable { \n    return _claimedEggs[varg0];\n}\n\nfunction EGGS_TO_HATCH_1SHRIMP() public nonPayable { \n    return _eGGS_TO_HATCH_1SHRIMP;\n}\n\nfunction hatcheryShrimp(address varg0) public nonPayable { \n    return _getMyShrimp[varg0];\n}\n\nfunction calculateEggBuySimple(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x36c(_marketEggs, (address(this)).balance);\n    return v0;\n}\n\nfunction calculateEggSell(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x36c((address(this)).balance, _marketEggs);\n    return v0;\n}\n\nfunction referrals(address varg0) public nonPayable { \n    return address(_referrals[varg0]);\n}\n\nfunction getMyShrimp() public nonPayable { \n    return _getMyShrimp[msg.sender];\n}\n\nfunction getEggsSinceLastHatch(address varg0) public nonPayable { \n    v0 = 0x811(varg0);\n    return v0;\n}\n\nfunction 0x36c(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    varg1 = v2 = 945;\n    varg0 = v3 = 0x864(varg0, stor_1);\n    v0 = v4 = 940;\n    varg1 = v5 = stor_2;\n    varg0 = v6 = 929;\n    v0 = v7 = 934;\n    varg1 = v8 = 0x864(varg1, stor_1);\n    v9 = v10 = 0x864(v0, stor_2);\n    while (1) {\n        v11 = _SafeAdd(v9, varg1);\n        assert(v0);\n        v9 = v11 / v0;\n        goto 0x3a10x36c;\n    }\n    assert(v11);\n    return varg0 / v11, varg1, v0;\n}\n\nfunction 0x4de(uint256 varg0) private { \n    v0 = 0x864(4, varg0);\n    assert(100);\n    return v0 / 100;\n}\n\nfunction 0x811(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastHatch[v0] <= block.timestamp);\n    v1 = 0x8d2(block.timestamp - _lastHatch[v0], _eGGS_TO_HATCH_1SHRIMP);\n    v2 = address(varg0);\n    if (v1) {\n        v3 = _getMyShrimp[v2] * v1;\n        assert(v1);\n        assert(v3 / v1 == _getMyShrimp[v2]);\n    } else {\n        v3 = v4 = 0;\n    }\n    return v3;\n}\n\nfunction 0x864(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x8d2(uint256 varg0, uint256 varg1) private { \n    if (varg1 < varg0) {\n        return varg1;\n    } else {\n        return varg0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xa0f8168) {\n            ceoAddress();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x158ef93e == function_selector) {\n            initialized();\n        } else if (0x229824c4 == function_selector) {\n            calculateTrade(uint256,uint256,uint256);\n        } else if (0x26fd8422 == function_selector) {\n            calculateEggBuy(uint256,uint256);\n        } else if (0x2e9392bb == function_selector) {\n            marketEggs();\n        } else if (0x3955f0fe == function_selector) {\n            sellEggs();\n        } else if (0x3b653755 == function_selector) {\n            seedMarket(uint256);\n        } else if (0x3bc0461a == function_selector) {\n            devFee(uint256);\n        } else if (0x3ec862a8 == function_selector) {\n            hatchEggs(address);\n        } else if (0x43ce7422 == function_selector) {\n            getMyEggs();\n        } else if (0x467ece79 == function_selector) {\n            lastHatch(address);\n        } else if (0x4f74acfe == function_selector) {\n            buyEggs();\n        } else if (0x72670361 == function_selector) {\n            claimedEggs(address);\n        } else if (0x732e77d0 == function_selector) {\n            EGGS_TO_HATCH_1SHRIMP();\n        } else if (0x7e2cb974 == function_selector) {\n            hatcheryShrimp(address);\n        } else if (0x7e56fde5 == function_selector) {\n            calculateEggBuySimple(uint256);\n        } else if (0x8e316327 == function_selector) {\n            calculateEggSell(uint256);\n        } else if (0x9ca423b3 == function_selector) {\n            referrals(address);\n        } else if (0xc2127e03 == function_selector) {\n            getMyShrimp();\n        } else if (0xd7c8843b == function_selector) {\n            getEggsSinceLastHatch(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 17:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eGGS_TO_HATCH_1SHRIMP; // STORAGE[0x0]\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getMyShrimp; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _claimedEggs; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _lastHatch; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _referrals; // STORAGE[0x7]\nuint256 _marketEggs; // STORAGE[0x8]\nuint8 _initialized; // STORAGE[0x3] bytes 0 to 0\naddress _ceoAddress; // STORAGE[0x3] bytes 1 to 20\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction ceoAddress() public nonPayable { \n    return _ceoAddress;\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction initialized() public nonPayable { \n    return _initialized;\n}\n\nfunction calculateTrade(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0, v1, v2 = 0x36c(varg2, varg1);\n    return v0;\n}\n\nfunction calculateEggBuy(uint256 varg0, uint256 varg1) public nonPayable { \n    v0, v1, v2 = 0x36c(_marketEggs, varg1);\n    return v0;\n}\n\nfunction marketEggs() public nonPayable { \n    return _marketEggs;\n}\n\nfunction sellEggs() public nonPayable { \n    require(_initialized);\n    v0 = 0x811(msg.sender);\n    v1 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    v2, v3, v4 = 0x36c((address(this)).balance, _marketEggs);\n    v5 = 0x4de(v2);\n    _claimedEggs[msg.sender] = 0;\n    _lastHatch[msg.sender] = block.timestamp;\n    v6 = _SafeAdd(1024, _marketEggs);\n    _marketEggs = v6;\n    v7 = _ceoAddress.call().value(v5).gas(!v5 * 2300);\n    require(v7);\n    assert(v5 <= v2);\n    v8 = msg.sender.call().value(v2 - v5).gas(!(v2 - v5) * 2300);\n    require(v8);\n}\n\nfunction seedMarket(uint256 varg0) public payable { \n    require(!_marketEggs);\n    _initialized = 1;\n    _marketEggs = varg0;\n}\n\nfunction devFee(uint256 varg0) public nonPayable { \n    v0 = 0x4de(varg0);\n    return v0;\n}\n\nfunction hatchEggs(address varg0) public nonPayable { \n    require(_initialized);\n    v0 = v1 = !address(_referrals[address(msg.sender)]);\n    if (v1) {\n        v0 = v2 = address(_referrals[address(msg.sender)]) != msg.sender;\n    }\n    if (v0) {\n        _referrals[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrals[msg.sender];\n    }\n    v3 = 0x811(msg.sender);\n    v4 = _SafeAdd(v3, _claimedEggs[msg.sender]);\n    assert(stor_0_0_0);\n    v5 = _SafeAdd(v4 / _eGGS_TO_HATCH_1SHRIMP, _getMyShrimp[msg.sender]);\n    _getMyShrimp[msg.sender] = v5;\n    _getMyShrimp[msg.sender] = 0;\n    _lastHatch[msg.sender] = block.timestamp;\n    v6 = v7 = _lastHatch[address(_lastHatch[address(msg.sender)])];\n    v8 = v9 = 1579;\n    assert(5);\n    v10 = v11 = v4 / 5;\n    while (1) {\n        v12 = _SafeAdd(v10, v6);\n        _referrals[address(_referrals[address(msg.sender)])] = v12;\n        v6 = v13 = _marketEggs;\n        v8 = v14 = 1637;\n        assert(10);\n        v10 = v4 / 10;\n        goto 0x3a10x21a;\n    }\n    _marketEggs = v12;\n}\n\nfunction getMyEggs() public nonPayable { \n    v0 = 0x811(msg.sender);\n    v1 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    return v1;\n}\n\nfunction lastHatch(address varg0) public nonPayable { \n    return _lastHatch[varg0];\n}\n\nfunction buyEggs() public payable { \n    require(_initialized);\n    assert(msg.value <= (address(this)).balance);\n    v0, v1, v2 = 0x36c(_marketEggs, (address(this)).balance - msg.value);\n    v3 = 0x4de(v0);\n    assert(v3 <= v0);\n    v4 = 0x4de(msg.value);\n    v5 = _ceoAddress.call().value(v4).gas(!v4 * 2300);\n    require(v5);\n    v6 = _SafeAdd(v0 - v3, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v6;\n}\n\nfunction claimedEggs(address varg0) public nonPayable { \n    return _claimedEggs[varg0];\n}\n\nfunction EGGS_TO_HATCH_1SHRIMP() public nonPayable { \n    return _eGGS_TO_HATCH_1SHRIMP;\n}\n\nfunction hatcheryShrimp(address varg0) public nonPayable { \n    return _getMyShrimp[varg0];\n}\n\nfunction calculateEggBuySimple(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x36c(_marketEggs, (address(this)).balance);\n    return v0;\n}\n\nfunction calculateEggSell(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x36c((address(this)).balance, _marketEggs);\n    return v0;\n}\n\nfunction referrals(address varg0) public nonPayable { \n    return address(_referrals[varg0]);\n}\n\nfunction getMyShrimp() public nonPayable { \n    return _getMyShrimp[msg.sender];\n}\n\nfunction getEggsSinceLastHatch(address varg0) public nonPayable { \n    v0 = 0x811(varg0);\n    return v0;\n}\n\nfunction 0x36c(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    varg1 = v2 = 945;\n    varg0 = v3 = 0x864(varg0, stor_1);\n    v0 = v4 = 940;\n    varg1 = v5 = stor_2;\n    varg0 = v6 = 929;\n    v0 = v7 = 934;\n    varg1 = v8 = 0x864(varg1, stor_1);\n    v9 = v10 = 0x864(v0, stor_2);\n    while (1) {\n        v11 = _SafeAdd(v9, varg1);\n        assert(v0);\n        v9 = v11 / v0;\n        goto 0x3a10x36c;\n    }\n    assert(v11);\n    return varg0 / v11, varg1, v0;\n}\n\nfunction 0x4de(uint256 varg0) private { \n    v0 = 0x864(4, varg0);\n    assert(100);\n    return v0 / 100;\n}\n\nfunction 0x811(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastHatch[v0] <= block.timestamp);\n    v1 = 0x8d2(block.timestamp - _lastHatch[v0], _eGGS_TO_HATCH_1SHRIMP);\n    v2 = address(varg0);\n    if (v1) {\n        v3 = _getMyShrimp[v2] * v1;\n        assert(v1);\n        assert(v3 / v1 == _getMyShrimp[v2]);\n    } else {\n        v3 = v4 = 0;\n    }\n    return v3;\n}\n\nfunction 0x864(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x8d2(uint256 varg0, uint256 varg1) private { \n    if (varg1 < varg0) {\n        return varg1;\n    } else {\n        return varg0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xa0f8168) {\n            ceoAddress();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x158ef93e == function_selector) {\n            initialized();\n        } else if (0x229824c4 == function_selector) {\n            calculateTrade(uint256,uint256,uint256);\n        } else if (0x26fd8422 == function_selector) {\n            calculateEggBuy(uint256,uint256);\n        } else if (0x2e9392bb == function_selector) {\n            marketEggs();\n        } else if (0x3955f0fe == function_selector) {\n            sellEggs();\n        } else if (0x3b653755 == function_selector) {\n            seedMarket(uint256);\n        } else if (0x3bc0461a == function_selector) {\n            devFee(uint256);\n        } else if (0x3ec862a8 == function_selector) {\n            hatchEggs(address);\n        } else if (0x43ce7422 == function_selector) {\n            getMyEggs();\n        } else if (0x467ece79 == function_selector) {\n            lastHatch(address);\n        } else if (0x4f74acfe == function_selector) {\n            buyEggs();\n        } else if (0x72670361 == function_selector) {\n            claimedEggs(address);\n        } else if (0x732e77d0 == function_selector) {\n            EGGS_TO_HATCH_1SHRIMP();\n        } else if (0x7e2cb974 == function_selector) {\n            hatcheryShrimp(address);\n        } else if (0x7e56fde5 == function_selector) {\n            calculateEggBuySimple(uint256);\n        } else if (0x8e316327 == function_selector) {\n            calculateEggSell(uint256);\n        } else if (0x9ca423b3 == function_selector) {\n            referrals(address);\n        } else if (0xc2127e03 == function_selector) {\n            getMyShrimp();\n        } else if (0xd7c8843b == function_selector) {\n            getEggsSinceLastHatch(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 17:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eGGS_TO_HATCH_1SHRIMP; // STORAGE[0x0]\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getMyShrimp; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _claimedEggs; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _lastHatch; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _referrals; // STORAGE[0x7]\nuint256 _marketEggs; // STORAGE[0x8]\nuint8 _initialized; // STORAGE[0x3] bytes 0 to 0\naddress _ceoAddress; // STORAGE[0x3] bytes 1 to 20\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction ceoAddress() public nonPayable { \n    return _ceoAddress;\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction initialized() public nonPayable { \n    return _initialized;\n}\n\nfunction calculateTrade(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0, v1, v2 = 0x36c(varg2, varg1);\n    return v0;\n}\n\nfunction calculateEggBuy(uint256 varg0, uint256 varg1) public nonPayable { \n    v0, v1, v2 = 0x36c(_marketEggs, varg1);\n    return v0;\n}\n\nfunction marketEggs() public nonPayable { \n    return _marketEggs;\n}\n\nfunction sellEggs() public nonPayable { \n    require(_initialized);\n    v0 = 0x811(msg.sender);\n    v1 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    v2, v3, v4 = 0x36c((address(this)).balance, _marketEggs);\n    v5 = 0x4de(v2);\n    _claimedEggs[msg.sender] = 0;\n    _lastHatch[msg.sender] = block.timestamp;\n    v6 = _SafeAdd(1024, _marketEggs);\n    _marketEggs = v6;\n    v7 = _ceoAddress.call().value(v5).gas(!v5 * 2300);\n    require(v7);\n    assert(v5 <= v2);\n    v8 = msg.sender.call().value(v2 - v5).gas(!(v2 - v5) * 2300);\n    require(v8);\n}\n\nfunction seedMarket(uint256 varg0) public payable { \n    require(!_marketEggs);\n    _initialized = 1;\n    _marketEggs = varg0;\n}\n\nfunction devFee(uint256 varg0) public nonPayable { \n    v0 = 0x4de(varg0);\n    return v0;\n}\n\nfunction hatchEggs(address varg0) public nonPayable { \n    require(_initialized);\n    v0 = v1 = !address(_referrals[address(msg.sender)]);\n    if (v1) {\n        v0 = v2 = address(_referrals[address(msg.sender)]) != msg.sender;\n    }\n    if (v0) {\n        _referrals[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrals[msg.sender];\n    }\n    v3 = 0x811(msg.sender);\n    v4 = _SafeAdd(v3, _claimedEggs[msg.sender]);\n    assert(stor_0_0_0);\n    v5 = _SafeAdd(v4 / _eGGS_TO_HATCH_1SHRIMP, _getMyShrimp[msg.sender]);\n    _getMyShrimp[msg.sender] = v5;\n    _getMyShrimp[msg.sender] = 0;\n    _lastHatch[msg.sender] = block.timestamp;\n    v6 = v7 = _lastHatch[address(_lastHatch[address(msg.sender)])];\n    v8 = v9 = 1579;\n    assert(5);\n    v10 = v11 = v4 / 5;\n    while (1) {\n        v12 = _SafeAdd(v10, v6);\n        _referrals[address(_referrals[address(msg.sender)])] = v12;\n        v6 = v13 = _marketEggs;\n        v8 = v14 = 1637;\n        assert(10);\n        v10 = v4 / 10;\n        goto 0x3a10x21a;\n    }\n    _marketEggs = v12;\n}\n\nfunction getMyEggs() public nonPayable { \n    v0 = 0x811(msg.sender);\n    v1 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    return v1;\n}\n\nfunction lastHatch(address varg0) public nonPayable { \n    return _lastHatch[varg0];\n}\n\nfunction buyEggs() public payable { \n    require(_initialized);\n    assert(msg.value <= (address(this)).balance);\n    v0, v1, v2 = 0x36c(_marketEggs, (address(this)).balance - msg.value);\n    v3 = 0x4de(v0);\n    assert(v3 <= v0);\n    v4 = 0x4de(msg.value);\n    v5 = _ceoAddress.call().value(v4).gas(!v4 * 2300);\n    require(v5);\n    v6 = _SafeAdd(v0 - v3, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v6;\n}\n\nfunction claimedEggs(address varg0) public nonPayable { \n    return _claimedEggs[varg0];\n}\n\nfunction EGGS_TO_HATCH_1SHRIMP() public nonPayable { \n    return _eGGS_TO_HATCH_1SHRIMP;\n}\n\nfunction hatcheryShrimp(address varg0) public nonPayable { \n    return _getMyShrimp[varg0];\n}\n\nfunction calculateEggBuySimple(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x36c(_marketEggs, (address(this)).balance);\n    return v0;\n}\n\nfunction calculateEggSell(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x36c((address(this)).balance, _marketEggs);\n    return v0;\n}\n\nfunction referrals(address varg0) public nonPayable { \n    return address(_referrals[varg0]);\n}\n\nfunction getMyShrimp() public nonPayable { \n    return _getMyShrimp[msg.sender];\n}\n\nfunction getEggsSinceLastHatch(address varg0) public nonPayable { \n    v0 = 0x811(varg0);\n    return v0;\n}\n\nfunction 0x36c(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    varg1 = v2 = 945;\n    varg0 = v3 = 0x864(varg0, stor_1);\n    v0 = v4 = 940;\n    varg1 = v5 = stor_2;\n    varg0 = v6 = 929;\n    v0 = v7 = 934;\n    varg1 = v8 = 0x864(varg1, stor_1);\n    v9 = v10 = 0x864(v0, stor_2);\n    while (1) {\n        v11 = _SafeAdd(v9, varg1);\n        assert(v0);\n        v9 = v11 / v0;\n        goto 0x3a10x36c;\n    }\n    assert(v11);\n    return varg0 / v11, varg1, v0;\n}\n\nfunction 0x4de(uint256 varg0) private { \n    v0 = 0x864(4, varg0);\n    assert(100);\n    return v0 / 100;\n}\n\nfunction 0x811(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastHatch[v0] <= block.timestamp);\n    v1 = 0x8d2(block.timestamp - _lastHatch[v0], _eGGS_TO_HATCH_1SHRIMP);\n    v2 = address(varg0);\n    if (v1) {\n        v3 = _getMyShrimp[v2] * v1;\n        assert(v1);\n        assert(v3 / v1 == _getMyShrimp[v2]);\n    } else {\n        v3 = v4 = 0;\n    }\n    return v3;\n}\n\nfunction 0x864(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x8d2(uint256 varg0, uint256 varg1) private { \n    if (varg1 < varg0) {\n        return varg1;\n    } else {\n        return varg0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xa0f8168) {\n            ceoAddress();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x158ef93e == function_selector) {\n            initialized();\n        } else if (0x229824c4 == function_selector) {\n            calculateTrade(uint256,uint256,uint256);\n        } else if (0x26fd8422 == function_selector) {\n            calculateEggBuy(uint256,uint256);\n        } else if (0x2e9392bb == function_selector) {\n            marketEggs();\n        } else if (0x3955f0fe == function_selector) {\n            sellEggs();\n        } else if (0x3b653755 == function_selector) {\n            seedMarket(uint256);\n        } else if (0x3bc0461a == function_selector) {\n            devFee(uint256);\n        } else if (0x3ec862a8 == function_selector) {\n            hatchEggs(address);\n        } else if (0x43ce7422 == function_selector) {\n            getMyEggs();\n        } else if (0x467ece79 == function_selector) {\n            lastHatch(address);\n        } else if (0x4f74acfe == function_selector) {\n            buyEggs();\n        } else if (0x72670361 == function_selector) {\n            claimedEggs(address);\n        } else if (0x732e77d0 == function_selector) {\n            EGGS_TO_HATCH_1SHRIMP();\n        } else if (0x7e2cb974 == function_selector) {\n            hatcheryShrimp(address);\n        } else if (0x7e56fde5 == function_selector) {\n            calculateEggBuySimple(uint256);\n        } else if (0x8e316327 == function_selector) {\n            calculateEggSell(uint256);\n        } else if (0x9ca423b3 == function_selector) {\n            referrals(address);\n        } else if (0xc2127e03 == function_selector) {\n            getMyShrimp();\n        } else if (0xd7c8843b == function_selector) {\n            getEggsSinceLastHatch(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 42.1501886844635,
	"usage": {
		"completion_tokens": 581,
		"prompt_tokens": 2783,
		"total_tokens": 3364
	}
}