{
	"address": "0x5030f2fc18658a6de748cb23cbac9b2df2595618",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Crowdfunding {\n    uint256 public _fundingGoal;\n    uint256 public _amountRaised;\n    uint256 public _deadline;\n    uint256 public _price;\n    mapping (address => uint256) public _balanceOf;\n    address public _beneficiary;\n    bool public _safeWithdrawal;\n    bool public _fallback;\n    address public _tokenReward;\n\n    event FundTransfer(address indexed _backer, uint256 _amount, bool _isContribution);\n    event GoalReached(address indexed _beneficiary, uint256 _amountRaised);\n\n    function checkGoalReached() public { \n        if (block.timestamp >= _deadline) {\n            if (_amountRaised >= _fundingGoal) {\n                _safeWithdrawal = true;\n                emit GoalReached(_beneficiary, _amountRaised);\n            }\n            _fallback = true;\n        }\n    }\n\n    function safeWithdrawal() public { \n        if (block.timestamp >= _deadline) {\n            if (!_safeWithdrawal) {\n                _balanceOf[msg.sender] = 0;\n                bool v0 = msg.sender.send(_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], false);\n                }\n            }\n            bool v1 = _safeWithdrawal;\n            if (v1) {\n                v1 = msg.sender == _beneficiary;\n            }\n            if (v1) {\n                bool v3 = msg.sender.send(_amountRaised);\n                if (!v3) {\n                    _safeWithdrawal = false;\n                } else {\n                    emit FundTransfer(_beneficiary, _amountRaised, false);\n                }\n            }\n        }\n    }\n\n    function fallback() public payable { \n        require(!_fallback);\n        _balanceOf[msg.sender] += msg.value;\n        _amountRaised += msg.value;\n        // Assume the _tokenReward is an instance of ERC20 interface.\n        ERC20 token = ERC20(_tokenReward);\n        require(token.totalSupply() > 0);\n        bool v0 = token.transfer(msg.sender, msg.value * 1 ether / _price);\n        require(v0);\n        emit FundTransfer(msg.sender, msg.value, true);\n    }\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n```\n\nThe original decompiled code seems to be a crowdfunding contract where individuals can contribute towards a funding goal. When the deadline is met, if the funding goal is reached, funds can be withdrawn by the beneficiary. If the goal is not reached, contributors can reclaim their contributions. The converted Solidity code above is a simplified version of the original contract and some assumptions were made due to a lack of context. For example, it's assumed that `_tokenReward` is an instance of an ERC20 token.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461331,
	"id": "chatcmpl-8R46dBr4WBDUTimvNJic8W2jPwukb",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 08:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x1]\nuint256 _amountRaised; // STORAGE[0x2]\nuint256 _deadline; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\naddress _beneficiary; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_4_0_0; // STORAGE[0x4] bytes 0 to 0\nuint8 _safeWithdrawal; // STORAGE[0x7] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x7] bytes 1 to 1\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _safeWithdrawal = 1;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n        _fallback = 1;\n    }\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!_safeWithdrawal) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = _safeWithdrawal;\n        if (v2) {\n            v1 = msg.sender == _beneficiary;\n        }\n        if (v1) {\n            v3 = msg.sender.call().value(_amountRaised).gas(2300 * !_amountRaised);\n            if (!v3) {\n                _safeWithdrawal = 0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\nfunction fallback() public payable { \n    require(!_fallback);\n    _balanceOf[msg.sender] += msg.value;\n    _amountRaised += msg.value;\n    assert(stor_4_0_0);\n    require(_tokenReward.code.size);\n    v0 = _tokenReward.transfer(msg.sender, msg.value * 0xde0b6b3a7640000 / _price).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1cb3b20) {\n            checkGoalReached();\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x6e66f6e9 == function_selector) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == function_selector) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 08:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x1]\nuint256 _amountRaised; // STORAGE[0x2]\nuint256 _deadline; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\naddress _beneficiary; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_4_0_0; // STORAGE[0x4] bytes 0 to 0\nuint8 _safeWithdrawal; // STORAGE[0x7] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x7] bytes 1 to 1\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _safeWithdrawal = 1;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n        _fallback = 1;\n    }\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!_safeWithdrawal) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = _safeWithdrawal;\n        if (v2) {\n            v1 = msg.sender == _beneficiary;\n        }\n        if (v1) {\n            v3 = msg.sender.call().value(_amountRaised).gas(2300 * !_amountRaised);\n            if (!v3) {\n                _safeWithdrawal = 0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\nfunction fallback() public payable { \n    require(!_fallback);\n    _balanceOf[msg.sender] += msg.value;\n    _amountRaised += msg.value;\n    assert(stor_4_0_0);\n    require(_tokenReward.code.size);\n    v0 = _tokenReward.transfer(msg.sender, msg.value * 0xde0b6b3a7640000 / _price).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1cb3b20) {\n            checkGoalReached();\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x6e66f6e9 == function_selector) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == function_selector) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 08:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x1]\nuint256 _amountRaised; // STORAGE[0x2]\nuint256 _deadline; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\naddress _beneficiary; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_4_0_0; // STORAGE[0x4] bytes 0 to 0\nuint8 _safeWithdrawal; // STORAGE[0x7] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x7] bytes 1 to 1\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _safeWithdrawal = 1;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n        _fallback = 1;\n    }\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!_safeWithdrawal) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = _safeWithdrawal;\n        if (v2) {\n            v1 = msg.sender == _beneficiary;\n        }\n        if (v1) {\n            v3 = msg.sender.call().value(_amountRaised).gas(2300 * !_amountRaised);\n            if (!v3) {\n                _safeWithdrawal = 0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\nfunction fallback() public payable { \n    require(!_fallback);\n    _balanceOf[msg.sender] += msg.value;\n    _amountRaised += msg.value;\n    assert(stor_4_0_0);\n    require(_tokenReward.code.size);\n    v0 = _tokenReward.transfer(msg.sender, msg.value * 0xde0b6b3a7640000 / _price).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1cb3b20) {\n            checkGoalReached();\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x6e66f6e9 == function_selector) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == function_selector) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 39.59812831878662,
	"usage": {
		"completion_tokens": 634,
		"prompt_tokens": 1075,
		"total_tokens": 1709
	}
}