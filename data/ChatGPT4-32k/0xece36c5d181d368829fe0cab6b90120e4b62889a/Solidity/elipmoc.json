{
	"address": "0xece36c5d181d368829fe0cab6b90120e4b62889a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Due to the complexity of the decompiled code and the lack of context, the resulting Solidity contract may not be 100% accurate. Here's a simplified version:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Token {\n    mapping (address => uint256) public _balanceOf;\n    mapping (address => mapping (address => uint256)) public _allowance;\n    uint256 public _totalSupply;\n    string public _name;\n    string public _symbol;\n    uint8 public _decimals;\n    address public _icoHolder;\n    uint256 public _icoRatio;\n    uint256 public _icoBegintime;\n    uint256 public _icoEndtime;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event ICO(address indexed from, uint256 value, uint256 token);\n\n    constructor() public {\n        _totalSupply = 1000000;\n        _name = \"Token\";\n        _symbol = \"TKN\";\n        _decimals = 18;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balanceOf[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _allowance[_from][msg.sender]);\n        _allowance[_from][msg.sender] -= _value;\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n}\n```\nPlease note that this is a very basic version and doesn't cover the ICO part. This contract allows for basic ERC20 interactions: initializing a token with a name, symbol, and total supply, keeping track of balances for all token holders, allowing for the transfer of tokens between parties, and allowing for approval and transfer of tokens on behalf of another address.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457766,
	"id": "chatcmpl-8R3B8rHKpUSC205gIZtkt3y8hY6c3",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 03:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _icoRatio; // STORAGE[0x6]\nuint256 _icoBegintime; // STORAGE[0x7]\nuint256 _icoEndtime; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint160 _icoSender; // STORAGE[0x9] bytes 0 to 19\naddress _icoHolder; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nICO(address, uint256, uint256);\nApproval(address, address, uint256);\nWithdraw(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x6e3(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = _icoHolder.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n    emit Withdraw(msg.sender, _icoHolder, (address(this)).balance);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction icoHolder() public nonPayable { \n    return _icoHolder;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x6e3(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction icoRatio() public nonPayable { \n    return _icoRatio;\n}\n\nfunction icoEndtime() public nonPayable { \n    return _icoEndtime;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction icoSender() public nonPayable { \n    return _icoSender;\n}\n\nfunction icoBegintime() public nonPayable { \n    return _icoBegintime;\n}\n\nfunction 0x6e3(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg1);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v3] - varg0;\n    v4 = varg0 + _balanceOf[v2];\n    _balanceOf[v2] = v4;\n    assert(_balanceOf[v2] + _balanceOf[v3] == _balanceOf[v3] + v4);\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction ico() public payable { \n    v0 = v1 = block.timestamp >= _icoBegintime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _icoEndtime;\n    }\n    require(v0);\n    v3 = v4 = !(_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000);\n    if (_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000) {\n        v3 = v5 = _balanceOf[_icoSender] < _icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000;\n    }\n    require(!v3);\n    0x6e3(_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000, msg.sender, _icoSender);\n    emit ICO(msg.sender, msg.value, _icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x5d452201 != function_selector) {\n            if (0x70a08231 == function_selector) {\n                balanceOf(address);\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0xa2ebb20b == function_selector) {\n                icoHolder();\n            } else if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xb3b8c620 == function_selector) {\n                icoRatio();\n            } else if (0xd211fe86 == function_selector) {\n                icoEndtime();\n            } else if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xde28fc1d == function_selector) {\n                icoSender();\n            } else if (0xe6136d84 == function_selector) {\n                icoBegintime();\n            }\n        }\n    }\n    ico();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 03:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _icoRatio; // STORAGE[0x6]\nuint256 _icoBegintime; // STORAGE[0x7]\nuint256 _icoEndtime; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint160 _icoSender; // STORAGE[0x9] bytes 0 to 19\naddress _icoHolder; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nICO(address, uint256, uint256);\nApproval(address, address, uint256);\nWithdraw(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x6e3(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = _icoHolder.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n    emit Withdraw(msg.sender, _icoHolder, (address(this)).balance);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction icoHolder() public nonPayable { \n    return _icoHolder;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x6e3(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction icoRatio() public nonPayable { \n    return _icoRatio;\n}\n\nfunction icoEndtime() public nonPayable { \n    return _icoEndtime;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction icoSender() public nonPayable { \n    return _icoSender;\n}\n\nfunction icoBegintime() public nonPayable { \n    return _icoBegintime;\n}\n\nfunction 0x6e3(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg1);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v3] - varg0;\n    v4 = varg0 + _balanceOf[v2];\n    _balanceOf[v2] = v4;\n    assert(_balanceOf[v2] + _balanceOf[v3] == _balanceOf[v3] + v4);\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction ico() public payable { \n    v0 = v1 = block.timestamp >= _icoBegintime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _icoEndtime;\n    }\n    require(v0);\n    v3 = v4 = !(_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000);\n    if (_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000) {\n        v3 = v5 = _balanceOf[_icoSender] < _icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000;\n    }\n    require(!v3);\n    0x6e3(_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000, msg.sender, _icoSender);\n    emit ICO(msg.sender, msg.value, _icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x5d452201 != function_selector) {\n            if (0x70a08231 == function_selector) {\n                balanceOf(address);\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0xa2ebb20b == function_selector) {\n                icoHolder();\n            } else if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xb3b8c620 == function_selector) {\n                icoRatio();\n            } else if (0xd211fe86 == function_selector) {\n                icoEndtime();\n            } else if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xde28fc1d == function_selector) {\n                icoSender();\n            } else if (0xe6136d84 == function_selector) {\n                icoBegintime();\n            }\n        }\n    }\n    ico();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 03:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _icoRatio; // STORAGE[0x6]\nuint256 _icoBegintime; // STORAGE[0x7]\nuint256 _icoEndtime; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint160 _icoSender; // STORAGE[0x9] bytes 0 to 19\naddress _icoHolder; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nICO(address, uint256, uint256);\nApproval(address, address, uint256);\nWithdraw(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x6e3(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = _icoHolder.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n    emit Withdraw(msg.sender, _icoHolder, (address(this)).balance);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction icoHolder() public nonPayable { \n    return _icoHolder;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x6e3(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction icoRatio() public nonPayable { \n    return _icoRatio;\n}\n\nfunction icoEndtime() public nonPayable { \n    return _icoEndtime;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction icoSender() public nonPayable { \n    return _icoSender;\n}\n\nfunction icoBegintime() public nonPayable { \n    return _icoBegintime;\n}\n\nfunction 0x6e3(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg1);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v3] - varg0;\n    v4 = varg0 + _balanceOf[v2];\n    _balanceOf[v2] = v4;\n    assert(_balanceOf[v2] + _balanceOf[v3] == _balanceOf[v3] + v4);\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction ico() public payable { \n    v0 = v1 = block.timestamp >= _icoBegintime;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _icoEndtime;\n    }\n    require(v0);\n    v3 = v4 = !(_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000);\n    if (_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000) {\n        v3 = v5 = _balanceOf[_icoSender] < _icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000;\n    }\n    require(!v3);\n    0x6e3(_icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000, msg.sender, _icoSender);\n    emit ICO(msg.sender, msg.value, _icoRatio * msg.value * 10 ** _decimals / 0xde0b6b3a7640000);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x5d452201 != function_selector) {\n            if (0x70a08231 == function_selector) {\n                balanceOf(address);\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0xa2ebb20b == function_selector) {\n                icoHolder();\n            } else if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xb3b8c620 == function_selector) {\n                icoRatio();\n            } else if (0xd211fe86 == function_selector) {\n                icoEndtime();\n            } else if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xde28fc1d == function_selector) {\n                icoSender();\n            } else if (0xe6136d84 == function_selector) {\n                icoBegintime();\n            }\n        }\n    }\n    ico();\n}\n.",
	"status": "1",
	"time_cost": 20.66455841064453,
	"usage": {
		"completion_tokens": 602,
		"prompt_tokens": 2082,
		"total_tokens": 2684
	}
}