{
	"address": "0x9249133819102b2ed31680468c8c67f6fe9e7505",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code provided is in a high-level assembly language which is not Solidity. However, I can provide you with a similar Solidity contract based on the functionality of the code. \n\nHere is a simplified version of the Ethereum smart contract using Solidity:\n\n```solidity\npragma solidity >=0.6.0 <0.9.0;\n\ncontract EthereumContract {\n    struct Number {\n        address owner;\n        uint256 price;\n        bool isForSale;\n        uint256 bid;\n        address bidder;\n    }\n    \n    mapping (uint256 => Number) public numbers;\n    mapping (address => uint256[]) public ownedNumbers;\n    mapping (address => uint256) public earnings;\n    uint256 public houseEarnings;\n\n    function placeNewBid(uint256 theNum) public payable {\n        require(numbers[theNum].owner != address(0), \"Number does not exist\");\n        require(numbers[theNum].owner != msg.sender, \"Cannot bid on your own number\");\n        require(msg.value >= 1 ether, \"Bid must be at least 1 ether\");\n        require(msg.value > numbers[theNum].bid, \"Must bid more than the current bid\");\n        \n        numbers[theNum].bid = msg.value;\n        numbers[theNum].bidder = msg.sender;\n    }\n\n    function acceptBid(uint256 theNum) public {\n        require(numbers[theNum].owner == msg.sender, \"You do not own this number\");\n        require(numbers[theNum].bid > 0, \"There are no bids on this number\");\n\n        earnings[numbers[theNum].owner] += numbers[theNum].bid;\n        houseEarnings += numbers[theNum].bid / 100;\n        \n        numbers[theNum].owner = numbers[theNum].bidder;\n        numbers[theNum].bid = 0;\n        numbers[theNum].bidder = address(0);\n    }\n\n    // Other functions...\n}\n```\n\nThis is a basic contract where users can place bids on numbers and the owner can accept the highest bid. It should be noted that this contract is a simplified version and doesn't include all the functionality of the given decompiled code. The contract also doesn't cover any security measures and error handling which are very important in a production environment.",
				"role": "assistant"
			}
		}
	],
	"created": 1700473783,
	"id": "chatcmpl-8MvCRrkGA2mheRDK5CdfeltZVX7PZ",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst minPrice = 10^15\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  ownedNumbers is array of uint256 at storage 1\n  houseEarnings is uint256 at storage 2\n  earnings is mapping of uint256 at storage 3\n  deadbids is mapping of uint256 at storage 4\n  stor5 is address at storage 5\n\ndef ownedNumbers(address addr): # not payable\n  idx = 0\n  while idx < ownedNumbers[address(addr)]:\n      mem[32] = 1\n      require idx < ownedNumbers[address(addr)]\n      mem[0] = sha3(address(addr), 1)\n      require idx < ownedNumbers[address(addr)]\n      mem[(32 * idx) + 192] = ownedNumbers[address(addr)][idx]\n      idx = idx + 1\n      continue \n  mem[(32 * ownedNumbers[address(addr)]) + 256 len floor32(ownedNumbers[address(addr)])] = mem[192 len floor32(ownedNumbers[address(addr)])]\n  return Array(len=ownedNumbers[address(addr)], data=mem[192 len floor32(ownedNumbers[address(addr)])], mem[(32 * ownedNumbers[address(addr)]) + floor32(ownedNumbers[address(addr)]) + 256 len (32 * ownedNumbers[address(addr)]) - floor32(ownedNumbers[address(addr)])]), \n\ndef hasBuyNowOffer(uint256 theNum): # not payable\n  return bool(stor0[theNum].field_768)\n\ndef earnings(address ): # not payable\n  return earnings[]\n\ndef ownershipLookup(address , uint256 ): # not payable\n  require  < ownedNumbers[]\n  return ownedNumbers[][]\n\ndef houseEarnings(): # not payable\n  return houseEarnings\n\ndef deadbids(address ): # not payable\n  return deadbids[]\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef hasOwner(uint256 theNum): # not payable\n  return (stor0[theNum].field_0 > 0)\n\ndef isOwner(address owner, uint256 tokenId): # not payable\n  return (stor0[tokenId].field_0 == owner)\n\ndef withdrawEarnings(): # not payable\n  earnings[caller] = 0\n  call caller with:\n     value earnings[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef withdrawDeadBids(): # not payable\n  deadbids[caller] = 0\n  call caller with:\n     value deadbids[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef withdrawHouseEarnings(): # not payable\n  require caller == stor5\n  houseEarnings = 0\n  call caller with:\n     value houseEarnings wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef cancelBuyNowOffer(uint256 theNum): # not payable\n  require stor0[theNum].field_0 == caller\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_768 = 0\n\ndef canAcceptBuyNow(uint256 theNum, address buyer): # not payable\n  if stor0[theNum].field_0 == buyer:\n      return stor0[theNum].field_0 != buyer\n  return bool(stor0[theNum].field_768)\n\ndef updateMessage(uint256 theNum, string aMessage): # not payable\n  require stor0[theNum].field_0 == caller\n  stor0[theNum][2][].field_0 = Array(len=aMessage.length, data=aMessage[all])\n\ndef placeBuyNowOffer(uint256 theNum, uint256 price): # not payable\n  require stor0[theNum].field_0 == caller\n  require price >= 10^15\n  stor0[theNum].field_1024 = price\n  stor0[theNum].field_768 = 1\n  log 0xa0f1665b: price, theNum\n\ndef cancelBid(uint256 _tokenId): # not payable\n  require caller == stor0[_tokenId].field_1280\n  deadbids[stor0[_tokenId].field_1280] += stor0[_tokenId].field_1536\n  stor0[_tokenId].field_1536 = 0\n  stor0[_tokenId].field_1280 = 0\n  log 0x2a0a5f50: stor0[_tokenId].field_1536, _tokenId\n\ndef placeNewBid(uint256 theNum) payable: \n  require stor0[theNum].field_0 > 0\n  require stor0[theNum].field_0 != caller\n  require call.value >= 10^15\n  require call.value > stor0[theNum].field_1536 + 10^15\n  deadbids[stor0[theNum].field_1280] += stor0[theNum].field_1536\n  stor0[theNum].field_1536 = call.value\n  stor0[theNum].field_1280 = caller\n  log 0xfc694070: call.value, theNum\n\ndef ownership(uint256 ): # not payable\n  mem[352] = stor0[][2].field_0\n  idx = 352\n  s = 0\n  while stor0[][2].length + 352 > idx + 32:\n      mem[idx + 32] = stor0[][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return stor0[].field_0, \n         stor0[].field_256,\n         Array(len=stor0[][2].length, data=mem[352 len stor0[][2].length + (floor32(stor0[][2].length - 1) + -stor0[][2].length + 32 % 32)]),\n         bool(stor0[].field_768),\n         stor0[].field_1024,\n         stor0[].field_1280,\n         stor0[].field_1536\n\ndef takeNumber(uint256 theNum): # not payable\n  require stor0[theNum].field_0 <= 0\n  require stor0[theNum].field_0 != caller\n  stor0[theNum].field_0 = caller\n  stor0[theNum].field_256 = 0\n  stor0[theNum].field_512 = 0\n  stor0[theNum].field_513 = 0\n  stor0[theNum].field_520 = mem[352 len 31]\n  idx = 0\n  while stor0[theNum][2].length + 31 / 32 > idx:\n      stor0[theNum][idx + 2].field_0 = 0\n      idx = idx + 1\n      continue \n  stor0[theNum].field_768 = 0\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_1280 = 0\n  stor0[theNum].field_1536 = 0\n  stor0[theNum].field_1536 = 0\n  ownedNumbers[caller]++\n  if not ownedNumbers[caller] <= ownedNumbers[caller] + 1:\n      idx = ownedNumbers[caller] + 1\n      while ownedNumbers[caller] > idx:\n          ownedNumbers[caller][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller][ownedNumbers[caller]] = theNum\n  stor0[theNum].field_256 = ownedNumbers[caller] - 1\n  log 0x9ada7a4c: theNum\n\ndef acceptBuyNowOffer(uint256 theNum) payable: \n  require stor0[theNum].field_0 != caller\n  require stor0[theNum].field_768\n  require call.value == stor0[theNum].field_1024\n  earnings[stor0[theNum].field_0] = earnings[stor0[theNum].field_0] + call.value - (call.value / 100)\n  houseEarnings += call.value / 100\n  deadbids[stor0[theNum].field_1280] += stor0[theNum].field_1536\n  stor0[theNum].field_1536 = 0\n  stor0[theNum].field_1280 = 0\n  require stor0[theNum].field_0 == stor0[theNum].field_0\n  stor0[theNum].field_0 = caller\n  require ownedNumbers[stor0[theNum].field_0] - 1 < ownedNumbers[stor0[theNum].field_0]\n  require stor0[theNum].field_256 < ownedNumbers[stor0[theNum].field_0]\n  ownedNumbers[stor0[theNum].field_0][stor0[theNum].field_256] = ownedNumbers[stor0[theNum].field_0][ownedNumbers[stor0[theNum].field_0]]\n  ownedNumbers[stor0[theNum].field_0]--\n  if not ownedNumbers[stor0[theNum].field_0] <= ownedNumbers[stor0[theNum].field_0] - 1:\n      idx = ownedNumbers[stor0[theNum].field_0] - 1\n      while ownedNumbers[stor0[theNum].field_0] > idx:\n          ownedNumbers[stor0[theNum].field_0][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller]++\n  if not ownedNumbers[caller] <= ownedNumbers[caller] + 1:\n      idx = ownedNumbers[caller] + 1\n      while ownedNumbers[caller] > idx:\n          ownedNumbers[caller][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller][ownedNumbers[caller]] = theNum\n  stor0[theNum].field_256 = ownedNumbers[caller] - 1\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_768 = 0\n  log 0xfbdd8508: call.value, theNum\n\ndef acceptBid(uint256 _editionNumber): # not payable\n  require stor0[_editionNumber].field_0 == caller\n  require stor0[_editionNumber].field_1536 > 0\n  require stor0[_editionNumber].field_1280\n  earnings[stor0[_editionNumber].field_0] = earnings[stor0[_editionNumber].field_0] + stor0[_editionNumber].field_1536 - (stor0[_editionNumber].field_1536 / 100)\n  houseEarnings += stor0[_editionNumber].field_1536 / 100\n  require stor0[_editionNumber].field_0 == stor0[_editionNumber].field_0\n  stor0[_editionNumber].field_0 = stor0[_editionNumber].field_1280\n  require ownedNumbers[stor0[_editionNumber].field_0] - 1 < ownedNumbers[stor0[_editionNumber].field_0]\n  require stor0[_editionNumber].field_256 < ownedNumbers[stor0[_editionNumber].field_0]\n  ownedNumbers[stor0[_editionNumber].field_0][stor0[_editionNumber].field_256] = ownedNumbers[stor0[_editionNumber].field_0][ownedNumbers[stor0[_editionNumber].field_0]]\n  ownedNumbers[stor0[_editionNumber].field_0]--\n  if not ownedNumbers[stor0[_editionNumber].field_0] <= ownedNumbers[stor0[_editionNumber].field_0] - 1:\n      idx = ownedNumbers[stor0[_editionNumber].field_0] - 1\n      while ownedNumbers[stor0[_editionNumber].field_0] > idx:\n          ownedNumbers[stor0[_editionNumber].field_0][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[stor0[_editionNumber].field_1280]++\n  if not ownedNumbers[stor0[_editionNumber].field_1280] <= ownedNumbers[stor0[_editionNumber].field_1280] + 1:\n      idx = ownedNumbers[stor0[_editionNumber].field_1280] + 1\n      while ownedNumbers[stor0[_editionNumber].field_1280] > idx:\n          ownedNumbers[stor0[_editionNumber].field_1280][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[stor0[_editionNumber].field_1280][ownedNumbers[stor0[_editionNumber].field_1280]] = _editionNumber\n  stor0[_editionNumber].field_256 = ownedNumbers[stor0[_editionNumber].field_1280] - 1\n  stor0[_editionNumber].field_1280 = 0\n  stor0[_editionNumber].field_1536 = 0\n  log 0xeeb046b3: stor0[_editionNumber].field_1536, _editionNumber\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst minPrice = 10^15\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  ownedNumbers is array of uint256 at storage 1\n  houseEarnings is uint256 at storage 2\n  earnings is mapping of uint256 at storage 3\n  deadbids is mapping of uint256 at storage 4\n  stor5 is address at storage 5\n\ndef ownedNumbers(address addr): # not payable\n  idx = 0\n  while idx < ownedNumbers[address(addr)]:\n      mem[32] = 1\n      require idx < ownedNumbers[address(addr)]\n      mem[0] = sha3(address(addr), 1)\n      require idx < ownedNumbers[address(addr)]\n      mem[(32 * idx) + 192] = ownedNumbers[address(addr)][idx]\n      idx = idx + 1\n      continue \n  mem[(32 * ownedNumbers[address(addr)]) + 256 len floor32(ownedNumbers[address(addr)])] = mem[192 len floor32(ownedNumbers[address(addr)])]\n  return Array(len=ownedNumbers[address(addr)], data=mem[192 len floor32(ownedNumbers[address(addr)])], mem[(32 * ownedNumbers[address(addr)]) + floor32(ownedNumbers[address(addr)]) + 256 len (32 * ownedNumbers[address(addr)]) - floor32(ownedNumbers[address(addr)])]), \n\ndef hasBuyNowOffer(uint256 theNum): # not payable\n  return bool(stor0[theNum].field_768)\n\ndef earnings(address ): # not payable\n  return earnings[]\n\ndef ownershipLookup(address , uint256 ): # not payable\n  require  < ownedNumbers[]\n  return ownedNumbers[][]\n\ndef houseEarnings(): # not payable\n  return houseEarnings\n\ndef deadbids(address ): # not payable\n  return deadbids[]\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef hasOwner(uint256 theNum): # not payable\n  return (stor0[theNum].field_0 > 0)\n\ndef isOwner(address owner, uint256 tokenId): # not payable\n  return (stor0[tokenId].field_0 == owner)\n\ndef withdrawEarnings(): # not payable\n  earnings[caller] = 0\n  call caller with:\n     value earnings[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef withdrawDeadBids(): # not payable\n  deadbids[caller] = 0\n  call caller with:\n     value deadbids[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef withdrawHouseEarnings(): # not payable\n  require caller == stor5\n  houseEarnings = 0\n  call caller with:\n     value houseEarnings wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef cancelBuyNowOffer(uint256 theNum): # not payable\n  require stor0[theNum].field_0 == caller\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_768 = 0\n\ndef canAcceptBuyNow(uint256 theNum, address buyer): # not payable\n  if stor0[theNum].field_0 == buyer:\n      return stor0[theNum].field_0 != buyer\n  return bool(stor0[theNum].field_768)\n\ndef updateMessage(uint256 theNum, string aMessage): # not payable\n  require stor0[theNum].field_0 == caller\n  stor0[theNum][2][].field_0 = Array(len=aMessage.length, data=aMessage[all])\n\ndef placeBuyNowOffer(uint256 theNum, uint256 price): # not payable\n  require stor0[theNum].field_0 == caller\n  require price >= 10^15\n  stor0[theNum].field_1024 = price\n  stor0[theNum].field_768 = 1\n  log 0xa0f1665b: price, theNum\n\ndef cancelBid(uint256 _tokenId): # not payable\n  require caller == stor0[_tokenId].field_1280\n  deadbids[stor0[_tokenId].field_1280] += stor0[_tokenId].field_1536\n  stor0[_tokenId].field_1536 = 0\n  stor0[_tokenId].field_1280 = 0\n  log 0x2a0a5f50: stor0[_tokenId].field_1536, _tokenId\n\ndef placeNewBid(uint256 theNum) payable: \n  require stor0[theNum].field_0 > 0\n  require stor0[theNum].field_0 != caller\n  require call.value >= 10^15\n  require call.value > stor0[theNum].field_1536 + 10^15\n  deadbids[stor0[theNum].field_1280] += stor0[theNum].field_1536\n  stor0[theNum].field_1536 = call.value\n  stor0[theNum].field_1280 = caller\n  log 0xfc694070: call.value, theNum\n\ndef ownership(uint256 ): # not payable\n  mem[352] = stor0[][2].field_0\n  idx = 352\n  s = 0\n  while stor0[][2].length + 352 > idx + 32:\n      mem[idx + 32] = stor0[][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return stor0[].field_0, \n         stor0[].field_256,\n         Array(len=stor0[][2].length, data=mem[352 len stor0[][2].length + (floor32(stor0[][2].length - 1) + -stor0[][2].length + 32 % 32)]),\n         bool(stor0[].field_768),\n         stor0[].field_1024,\n         stor0[].field_1280,\n         stor0[].field_1536\n\ndef takeNumber(uint256 theNum): # not payable\n  require stor0[theNum].field_0 <= 0\n  require stor0[theNum].field_0 != caller\n  stor0[theNum].field_0 = caller\n  stor0[theNum].field_256 = 0\n  stor0[theNum].field_512 = 0\n  stor0[theNum].field_513 = 0\n  stor0[theNum].field_520 = mem[352 len 31]\n  idx = 0\n  while stor0[theNum][2].length + 31 / 32 > idx:\n      stor0[theNum][idx + 2].field_0 = 0\n      idx = idx + 1\n      continue \n  stor0[theNum].field_768 = 0\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_1280 = 0\n  stor0[theNum].field_1536 = 0\n  stor0[theNum].field_1536 = 0\n  ownedNumbers[caller]++\n  if not ownedNumbers[caller] <= ownedNumbers[caller] + 1:\n      idx = ownedNumbers[caller] + 1\n      while ownedNumbers[caller] > idx:\n          ownedNumbers[caller][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller][ownedNumbers[caller]] = theNum\n  stor0[theNum].field_256 = ownedNumbers[caller] - 1\n  log 0x9ada7a4c: theNum\n\ndef acceptBuyNowOffer(uint256 theNum) payable: \n  require stor0[theNum].field_0 != caller\n  require stor0[theNum].field_768\n  require call.value == stor0[theNum].field_1024\n  earnings[stor0[theNum].field_0] = earnings[stor0[theNum].field_0] + call.value - (call.value / 100)\n  houseEarnings += call.value / 100\n  deadbids[stor0[theNum].field_1280] += stor0[theNum].field_1536\n  stor0[theNum].field_1536 = 0\n  stor0[theNum].field_1280 = 0\n  require stor0[theNum].field_0 == stor0[theNum].field_0\n  stor0[theNum].field_0 = caller\n  require ownedNumbers[stor0[theNum].field_0] - 1 < ownedNumbers[stor0[theNum].field_0]\n  require stor0[theNum].field_256 < ownedNumbers[stor0[theNum].field_0]\n  ownedNumbers[stor0[theNum].field_0][stor0[theNum].field_256] = ownedNumbers[stor0[theNum].field_0][ownedNumbers[stor0[theNum].field_0]]\n  ownedNumbers[stor0[theNum].field_0]--\n  if not ownedNumbers[stor0[theNum].field_0] <= ownedNumbers[stor0[theNum].field_0] - 1:\n      idx = ownedNumbers[stor0[theNum].field_0] - 1\n      while ownedNumbers[stor0[theNum].field_0] > idx:\n          ownedNumbers[stor0[theNum].field_0][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller]++\n  if not ownedNumbers[caller] <= ownedNumbers[caller] + 1:\n      idx = ownedNumbers[caller] + 1\n      while ownedNumbers[caller] > idx:\n          ownedNumbers[caller][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller][ownedNumbers[caller]] = theNum\n  stor0[theNum].field_256 = ownedNumbers[caller] - 1\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_768 = 0\n  log 0xfbdd8508: call.value, theNum\n\ndef acceptBid(uint256 _editionNumber): # not payable\n  require stor0[_editionNumber].field_0 == caller\n  require stor0[_editionNumber].field_1536 > 0\n  require stor0[_editionNumber].field_1280\n  earnings[stor0[_editionNumber].field_0] = earnings[stor0[_editionNumber].field_0] + stor0[_editionNumber].field_1536 - (stor0[_editionNumber].field_1536 / 100)\n  houseEarnings += stor0[_editionNumber].field_1536 / 100\n  require stor0[_editionNumber].field_0 == stor0[_editionNumber].field_0\n  stor0[_editionNumber].field_0 = stor0[_editionNumber].field_1280\n  require ownedNumbers[stor0[_editionNumber].field_0] - 1 < ownedNumbers[stor0[_editionNumber].field_0]\n  require stor0[_editionNumber].field_256 < ownedNumbers[stor0[_editionNumber].field_0]\n  ownedNumbers[stor0[_editionNumber].field_0][stor0[_editionNumber].field_256] = ownedNumbers[stor0[_editionNumber].field_0][ownedNumbers[stor0[_editionNumber].field_0]]\n  ownedNumbers[stor0[_editionNumber].field_0]--\n  if not ownedNumbers[stor0[_editionNumber].field_0] <= ownedNumbers[stor0[_editionNumber].field_0] - 1:\n      idx = ownedNumbers[stor0[_editionNumber].field_0] - 1\n      while ownedNumbers[stor0[_editionNumber].field_0] > idx:\n          ownedNumbers[stor0[_editionNumber].field_0][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[stor0[_editionNumber].field_1280]++\n  if not ownedNumbers[stor0[_editionNumber].field_1280] <= ownedNumbers[stor0[_editionNumber].field_1280] + 1:\n      idx = ownedNumbers[stor0[_editionNumber].field_1280] + 1\n      while ownedNumbers[stor0[_editionNumber].field_1280] > idx:\n          ownedNumbers[stor0[_editionNumber].field_1280][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[stor0[_editionNumber].field_1280][ownedNumbers[stor0[_editionNumber].field_1280]] = _editionNumber\n  stor0[_editionNumber].field_256 = ownedNumbers[stor0[_editionNumber].field_1280] - 1\n  stor0[_editionNumber].field_1280 = 0\n  stor0[_editionNumber].field_1536 = 0\n  log 0xeeb046b3: stor0[_editionNumber].field_1536, _editionNumber\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst minPrice = 10^15\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  ownedNumbers is array of uint256 at storage 1\n  houseEarnings is uint256 at storage 2\n  earnings is mapping of uint256 at storage 3\n  deadbids is mapping of uint256 at storage 4\n  stor5 is address at storage 5\n\ndef ownedNumbers(address addr): # not payable\n  idx = 0\n  while idx < ownedNumbers[address(addr)]:\n      mem[32] = 1\n      require idx < ownedNumbers[address(addr)]\n      mem[0] = sha3(address(addr), 1)\n      require idx < ownedNumbers[address(addr)]\n      mem[(32 * idx) + 192] = ownedNumbers[address(addr)][idx]\n      idx = idx + 1\n      continue \n  mem[(32 * ownedNumbers[address(addr)]) + 256 len floor32(ownedNumbers[address(addr)])] = mem[192 len floor32(ownedNumbers[address(addr)])]\n  return Array(len=ownedNumbers[address(addr)], data=mem[192 len floor32(ownedNumbers[address(addr)])], mem[(32 * ownedNumbers[address(addr)]) + floor32(ownedNumbers[address(addr)]) + 256 len (32 * ownedNumbers[address(addr)]) - floor32(ownedNumbers[address(addr)])]), \n\ndef hasBuyNowOffer(uint256 theNum): # not payable\n  return bool(stor0[theNum].field_768)\n\ndef earnings(address ): # not payable\n  return earnings[]\n\ndef ownershipLookup(address , uint256 ): # not payable\n  require  < ownedNumbers[]\n  return ownedNumbers[][]\n\ndef houseEarnings(): # not payable\n  return houseEarnings\n\ndef deadbids(address ): # not payable\n  return deadbids[]\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef hasOwner(uint256 theNum): # not payable\n  return (stor0[theNum].field_0 > 0)\n\ndef isOwner(address owner, uint256 tokenId): # not payable\n  return (stor0[tokenId].field_0 == owner)\n\ndef withdrawEarnings(): # not payable\n  earnings[caller] = 0\n  call caller with:\n     value earnings[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef withdrawDeadBids(): # not payable\n  deadbids[caller] = 0\n  call caller with:\n     value deadbids[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef withdrawHouseEarnings(): # not payable\n  require caller == stor5\n  houseEarnings = 0\n  call caller with:\n     value houseEarnings wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef cancelBuyNowOffer(uint256 theNum): # not payable\n  require stor0[theNum].field_0 == caller\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_768 = 0\n\ndef canAcceptBuyNow(uint256 theNum, address buyer): # not payable\n  if stor0[theNum].field_0 == buyer:\n      return stor0[theNum].field_0 != buyer\n  return bool(stor0[theNum].field_768)\n\ndef updateMessage(uint256 theNum, string aMessage): # not payable\n  require stor0[theNum].field_0 == caller\n  stor0[theNum][2][].field_0 = Array(len=aMessage.length, data=aMessage[all])\n\ndef placeBuyNowOffer(uint256 theNum, uint256 price): # not payable\n  require stor0[theNum].field_0 == caller\n  require price >= 10^15\n  stor0[theNum].field_1024 = price\n  stor0[theNum].field_768 = 1\n  log 0xa0f1665b: price, theNum\n\ndef cancelBid(uint256 _tokenId): # not payable\n  require caller == stor0[_tokenId].field_1280\n  deadbids[stor0[_tokenId].field_1280] += stor0[_tokenId].field_1536\n  stor0[_tokenId].field_1536 = 0\n  stor0[_tokenId].field_1280 = 0\n  log 0x2a0a5f50: stor0[_tokenId].field_1536, _tokenId\n\ndef placeNewBid(uint256 theNum) payable: \n  require stor0[theNum].field_0 > 0\n  require stor0[theNum].field_0 != caller\n  require call.value >= 10^15\n  require call.value > stor0[theNum].field_1536 + 10^15\n  deadbids[stor0[theNum].field_1280] += stor0[theNum].field_1536\n  stor0[theNum].field_1536 = call.value\n  stor0[theNum].field_1280 = caller\n  log 0xfc694070: call.value, theNum\n\ndef ownership(uint256 ): # not payable\n  mem[352] = stor0[][2].field_0\n  idx = 352\n  s = 0\n  while stor0[][2].length + 352 > idx + 32:\n      mem[idx + 32] = stor0[][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return stor0[].field_0, \n         stor0[].field_256,\n         Array(len=stor0[][2].length, data=mem[352 len stor0[][2].length + (floor32(stor0[][2].length - 1) + -stor0[][2].length + 32 % 32)]),\n         bool(stor0[].field_768),\n         stor0[].field_1024,\n         stor0[].field_1280,\n         stor0[].field_1536\n\ndef takeNumber(uint256 theNum): # not payable\n  require stor0[theNum].field_0 <= 0\n  require stor0[theNum].field_0 != caller\n  stor0[theNum].field_0 = caller\n  stor0[theNum].field_256 = 0\n  stor0[theNum].field_512 = 0\n  stor0[theNum].field_513 = 0\n  stor0[theNum].field_520 = mem[352 len 31]\n  idx = 0\n  while stor0[theNum][2].length + 31 / 32 > idx:\n      stor0[theNum][idx + 2].field_0 = 0\n      idx = idx + 1\n      continue \n  stor0[theNum].field_768 = 0\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_1280 = 0\n  stor0[theNum].field_1536 = 0\n  stor0[theNum].field_1536 = 0\n  ownedNumbers[caller]++\n  if not ownedNumbers[caller] <= ownedNumbers[caller] + 1:\n      idx = ownedNumbers[caller] + 1\n      while ownedNumbers[caller] > idx:\n          ownedNumbers[caller][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller][ownedNumbers[caller]] = theNum\n  stor0[theNum].field_256 = ownedNumbers[caller] - 1\n  log 0x9ada7a4c: theNum\n\ndef acceptBuyNowOffer(uint256 theNum) payable: \n  require stor0[theNum].field_0 != caller\n  require stor0[theNum].field_768\n  require call.value == stor0[theNum].field_1024\n  earnings[stor0[theNum].field_0] = earnings[stor0[theNum].field_0] + call.value - (call.value / 100)\n  houseEarnings += call.value / 100\n  deadbids[stor0[theNum].field_1280] += stor0[theNum].field_1536\n  stor0[theNum].field_1536 = 0\n  stor0[theNum].field_1280 = 0\n  require stor0[theNum].field_0 == stor0[theNum].field_0\n  stor0[theNum].field_0 = caller\n  require ownedNumbers[stor0[theNum].field_0] - 1 < ownedNumbers[stor0[theNum].field_0]\n  require stor0[theNum].field_256 < ownedNumbers[stor0[theNum].field_0]\n  ownedNumbers[stor0[theNum].field_0][stor0[theNum].field_256] = ownedNumbers[stor0[theNum].field_0][ownedNumbers[stor0[theNum].field_0]]\n  ownedNumbers[stor0[theNum].field_0]--\n  if not ownedNumbers[stor0[theNum].field_0] <= ownedNumbers[stor0[theNum].field_0] - 1:\n      idx = ownedNumbers[stor0[theNum].field_0] - 1\n      while ownedNumbers[stor0[theNum].field_0] > idx:\n          ownedNumbers[stor0[theNum].field_0][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller]++\n  if not ownedNumbers[caller] <= ownedNumbers[caller] + 1:\n      idx = ownedNumbers[caller] + 1\n      while ownedNumbers[caller] > idx:\n          ownedNumbers[caller][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[caller][ownedNumbers[caller]] = theNum\n  stor0[theNum].field_256 = ownedNumbers[caller] - 1\n  stor0[theNum].field_1024 = 0\n  stor0[theNum].field_768 = 0\n  log 0xfbdd8508: call.value, theNum\n\ndef acceptBid(uint256 _editionNumber): # not payable\n  require stor0[_editionNumber].field_0 == caller\n  require stor0[_editionNumber].field_1536 > 0\n  require stor0[_editionNumber].field_1280\n  earnings[stor0[_editionNumber].field_0] = earnings[stor0[_editionNumber].field_0] + stor0[_editionNumber].field_1536 - (stor0[_editionNumber].field_1536 / 100)\n  houseEarnings += stor0[_editionNumber].field_1536 / 100\n  require stor0[_editionNumber].field_0 == stor0[_editionNumber].field_0\n  stor0[_editionNumber].field_0 = stor0[_editionNumber].field_1280\n  require ownedNumbers[stor0[_editionNumber].field_0] - 1 < ownedNumbers[stor0[_editionNumber].field_0]\n  require stor0[_editionNumber].field_256 < ownedNumbers[stor0[_editionNumber].field_0]\n  ownedNumbers[stor0[_editionNumber].field_0][stor0[_editionNumber].field_256] = ownedNumbers[stor0[_editionNumber].field_0][ownedNumbers[stor0[_editionNumber].field_0]]\n  ownedNumbers[stor0[_editionNumber].field_0]--\n  if not ownedNumbers[stor0[_editionNumber].field_0] <= ownedNumbers[stor0[_editionNumber].field_0] - 1:\n      idx = ownedNumbers[stor0[_editionNumber].field_0] - 1\n      while ownedNumbers[stor0[_editionNumber].field_0] > idx:\n          ownedNumbers[stor0[_editionNumber].field_0][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[stor0[_editionNumber].field_1280]++\n  if not ownedNumbers[stor0[_editionNumber].field_1280] <= ownedNumbers[stor0[_editionNumber].field_1280] + 1:\n      idx = ownedNumbers[stor0[_editionNumber].field_1280] + 1\n      while ownedNumbers[stor0[_editionNumber].field_1280] > idx:\n          ownedNumbers[stor0[_editionNumber].field_1280][idx] = 0\n          idx = idx + 1\n          continue \n  ownedNumbers[stor0[_editionNumber].field_1280][ownedNumbers[stor0[_editionNumber].field_1280]] = _editionNumber\n  stor0[_editionNumber].field_256 = ownedNumbers[stor0[_editionNumber].field_1280] - 1\n  stor0[_editionNumber].field_1280 = 0\n  stor0[_editionNumber].field_1536 = 0\n  log 0xeeb046b3: stor0[_editionNumber].field_1536, _editionNumber\n\n.",
	"status": "1",
	"time_cost": 32.88835668563843,
	"usage": {
		"completion_tokens": 470,
		"prompt_tokens": 2975,
		"total_tokens": 3445
	}
}