{
	"address": "0xa796d1d9a97bcab5abab9329b8f020746e0a0bdb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n    string public version;\n    uint256 public unitsOneEthCanBuy;\n    uint256 public totalEthInWei;\n    uint8 public decimals;\n    address public fundsWallet;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);\n        require(allowance[_from][msg.sender] >= _value);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        // Call the receiveApproval function on the contract you want to be notified.\n        // This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        // receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        // it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        (bool success,) = _spender.call(abi.encodeWithSignature(\"receiveApproval(address,uint256,address,bytes)\", msg.sender, _value, address(this), _extraData));\n        require(success);\n        return true;\n    }\n\n    receive() external payable {\n        totalEthInWei = totalEthInWei + msg.value;\n        balanceOf[fundsWallet] = balanceOf[fundsWallet] - msg.value * unitsOneEthCanBuy;\n        balanceOf[msg.sender] = balanceOf[msg.sender] + msg.value * unitsOneEthCanBuy;\n        emit Transfer(fundsWallet, msg.sender, msg.value * unitsOneEthCanBuy);\n        // Transfer ether to fundsWallet\n        (bool success,) = fundsWallet.call{value: msg.value}(\"\");\n        require(success);\n    }\n}\n```\n\nThis contract is a basic implementation of an ERC20 token with some additional functionality. The contract has name, symbol, version, unitsOneEthCanBuy, totalEthInWei, and fundsWallet as its properties. It also has approve, transferFrom, transfer, approveAndCall functions. The contract also includes a fallback function that is called when ether is sent to it. This function updates totalEthInWei, balanceOf the sender and the fundsWallet, emits a Transfer event and forwards the ether to the fundsWallet.",
				"role": "assistant"
			}
		}
	],
	"created": 1701467781,
	"id": "chatcmpl-8R5mf8ONvMjzwmxHLoM1c44IIPkhZ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 11:58 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x5]\nuint256[] _version; // STORAGE[0x6]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x7]\nuint256 _totalEthInWei; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _fundsWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_balanceOf[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _balanceOf[_fundsWallet] = _balanceOf[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = _fundsWallet.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 11:58 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x5]\nuint256[] _version; // STORAGE[0x6]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x7]\nuint256 _totalEthInWei; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _fundsWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_balanceOf[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _balanceOf[_fundsWallet] = _balanceOf[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = _fundsWallet.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 11:58 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x5]\nuint256[] _version; // STORAGE[0x6]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x7]\nuint256 _totalEthInWei; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _fundsWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_balanceOf[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _balanceOf[_fundsWallet] = _balanceOf[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = _fundsWallet.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 55.2371666431427,
	"usage": {
		"completion_tokens": 758,
		"prompt_tokens": 2389,
		"total_tokens": 3147
	}
}