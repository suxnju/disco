{
	"address": "0x46403e94529fc04d04c9c393beab1d050ef06409",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code based on your given decompiled EVM bytecode:\n\n```solidity\npragma solidity >=0.4.22 <0.7.0;\n\ncontract Contract {\n    uint256[] array_2;\n    mapping (uint256 => uint256) map_3;\n    uint256 stor_5;\n    mapping (address => uint256) private _totalSupply;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    mapping (uint256 => uint256) map_9;\n    mapping (uint256 => uint256) map_a;\n    uint256 _roll;\n    uint256 stor_c;\n    mapping (address => uint256) _awardToken;\n    mapping (address => uint256) owner_e;\n    uint256 stor_f;\n    address public _owner;\n    address internal ___callback; \n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event EthReceived(address sender, uint256 amount);\n    event LedgerFailed(string reason);\n    event GotRandom(uint256 randomValue);\n    event Winner(address from, address to, uint256 balance, uint256 randomValue, uint256 zeroValue);\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(amount <= _allowance[sender][msg.sender]);\n        _allowance[sender][msg.sender] -= amount;\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0));\n        require(recipient != address(0));\n        require(amount <= _totalSupply[sender]);\n        _totalSupply[sender] -= amount;\n        _totalSupply[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return stor_5 - _totalSupply[address(0)];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _totalSupply[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n    // Add other functions as needed by the decompiled code\n}\n```\n\nPlease note that the original EVM bytecode decompiled code is pseudocode, so the translation into Solidity is not perfect. The above Solidity contract provides a basic structure for the contract and implements standard ERC20 functions. Other custom functions are represented as comments at the end, as their implementation is not clear from the pseudocode.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040632,
	"id": "chatcmpl-8CiE4GcmVeS8JIjwkPoq9uJjQAAXq",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.28 03:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) map_3; // STORAGE[0x3]\nuint256 stor_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) map_a; // STORAGE[0xa]\nuint256 _roll; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _awardToken; // STORAGE[0xd]\nmapping (uint256 => [uint256]) owner_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 ___callback; // STORAGE[0x0] bytes 0 to 19\nuint256 owner_1_0_19; // STORAGE[0x1] bytes 0 to 19\nuint256 _owner; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nEthReceived(address, uint256);\nLedgerFailed(string);\nGotRandom(uint256);\nWinner(address, address, uint256, uint256, uint256);\n\nfunction 0x1114(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0);\n    require(varg0 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg0;\n    v0 = address(varg1);\n    v1 = _totalSupply[v0] + varg0;\n    require(v1 >= _totalSupply[v0]);\n    v2 = address(varg1);\n    _totalSupply[v2] = v1;\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return 1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (11) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffff & 'Bonus Token';\n    }\n    return v0;\n}\n\nfunction 0x17b6() private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = new struct(4);\n    v7 = v8 = 4;\n    while (1) {\n        v9 = new struct(1);\n        v9.word0 = 0;\n        MEM[v5] = v9;\n        v5 += 32;\n        v7 = v7 - 1;\n        if (v7) {\n            break;\n        }\n        if (!v7) {\n            v10 = new struct(1);\n            v10.word0 = 0;\n            v11 = v12 = 7 > 0;\n            if (v12) {\n                v11 = 7 <= 32;\n            }\n            require(v11);\n            v13 = v14 = MEM[64];\n            if (MSIZE() >= v14) {\n                v13 = new uint256[](1);\n            }\n            v13 = new uint256[](1);\n            assert(0 < v13.length);\n            v15 = v13.data;\n            MEM8[v13.data] = (byte(0x700000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n            v16 = v17 = MEM[64];\n            if (MSIZE() >= v17) {\n                v16 = new bytes[](32);\n            }\n            v16 = new bytes[](32);\n            v18 = v19 = MEM[64];\n            if (MSIZE() >= v19) {\n                v18 = new bytes[](32);\n            }\n            v18 = new bytes[](32);\n            v20 = v21 = ___callback == 0;\n            if (___callback != 0) {\n                v20 = ___callback.code.size == 0;\n            }\n            if (v20) {\n                v22 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v23, v24 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v23);\n            if (owner_1_0_19 != address(v24)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v25, v26 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v25);\n                owner_1_0_19 = v26;\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(owner_1_0_19.code.size);\n            v27, v28 = owner_1_0_19.randomDS_getSessionPubKeyHash().gas(msg.gas - 710);\n            require(v27);\n            MEM[v16.data] = block.blockhash(block.number - 1) ^ (block.coinbase ^ block.timestamp);\n            MEM[v18.data] = v28;\n            v29 = v30 = MEM[64];\n            if (MSIZE() >= v30) {\n                v29 = 0;\n            }\n            if (MSIZE() >= MEM[64]) {\n                v31 = new array[](8);\n            }\n            v31 = new array[](8);\n            v32 = new struct(1);\n            v32.word0 = 0;\n            require(v31.length >= 8);\n            v33 = 56;\n            v34 = 32;\n            while (v33 < 64) {\n                MEM[v31 + v34] = MEM[v29 + v33];\n                v33 = v33 + 32;\n                v34 = v34 + 32;\n            }\n            v35 = v36 = ___callback == 0;\n            if (___callback != 0) {\n                v35 = ___callback.code.size == 0;\n            }\n            if (v35) {\n                v37 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v38, v39 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v38);\n            if (owner_1_0_19 != address(v39)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v40, v41 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v40);\n                owner_1_0_19 = v41;\n            }\n            v42 = v43 = 4;\n            v44 = v45 = MEM[64];\n            if (MSIZE() >= v45) {\n                v44 = v46 = new uint256[](v43);\n            }\n            v44 = new uint256[](v43);\n            if (v43) {\n                v47 = v46.data;\n                do {\n                    v48 = new struct(1);\n                    v48.word0 = 0;\n                    MEM[v47] = v48;\n                    v47 += 32;\n                    v42 = v42 - 1;\n                } while (!v42);\n            }\n            assert(0 < v44.length);\n            v49 = v46.data;\n            v50 = v46.data;\n            v46[0] = v16;\n            assert(1 < v44.length);\n            v46[32] = v13;\n            assert(2 < v44.length);\n            v46[64] = v18;\n            assert(3 < v44.length);\n            v46[96] = v29;\n            v51 = new struct(1);\n            v51.word0 = 0;\n            v52 = v53 = ___callback == 0;\n            if (___callback != 0) {\n                v52 = ___callback.code.size == 0;\n            }\n            if (v52) {\n                v54 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v55, v56 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v55);\n            if (owner_1_0_19 != address(v56)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v57, v58 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v57);\n                owner_1_0_19 = v58;\n            }\n            MEM[32 + MEM[64]] = 0;\n            v59 = new array[](v60.length);\n            v61 = v62 = 0;\n            while (v61 < v60.length) {\n                v59[v61] = v60[v61];\n                v61 = v61 + 32;\n            }\n            if (6) {\n                MEM[v59.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'random';\n            }\n            require(owner_1_0_19.code.size);\n            v63, v64 = owner_1_0_19.getPrice(v59, 0x3d090).gas(msg.gas - 710);\n            require(v63);\n            if (v64 <= 0xde0b6b3a7640000 + msg.gas * 0x3d090) {\n                v65, v66, v67, v68 = 0x4850(v44);\n                MEM[32 + MEM[64]] = 0;\n                v69 = new array[](MEM[0]);\n                v70 = v71 = 0;\n                while (v70 < MEM[0]) {\n                    v69[v70] = MEM[32 + v70];\n                    v70 = v70 + 32;\n                }\n                if (0x1f & MEM[0]) {\n                    MEM[MEM[0] + v69.data - (0x1f & MEM[0])] = ~(256 ** (32 - (0x1f & MEM[0])) - 1) & MEM[MEM[0] + v69.data - (0x1f & MEM[0])];\n                }\n                v72 = new array[](MEM[v65]);\n                v73 = v74 = 0;\n                while (v73 < MEM[v65]) {\n                    MEM[v72.data + v73] = MEM[32 + v65 + v73];\n                    v73 = v73 + 32;\n                }\n                v75 = v76 = MEM[v65] + v72.data;\n                if (0x1f & MEM[v65]) {\n                    MEM[v76 - (0x1f & MEM[v65])] = ~(256 ** (32 - (0x1f & MEM[v65])) - 1) & MEM[v76 - (0x1f & MEM[v65])];\n                }\n                require(owner_1_0_19.code.size);\n                v77, v78 = owner_1_0_19.queryN_withGasLimit(0, v69, v72, v51).value(v67).gas(msg.gas - 9710);\n                require(v77);\n            } else {\n                v78 = v79 = 0;\n            }\n            v80 = v81 = MEM[64];\n            if (MSIZE() >= v81) {\n                v80 = new array[](8);\n            }\n            v80 = new array[](8);\n            MEM8[v80 + 39] = v13 >> 248 & 0xFF;\n            MEM8[v80 + 38] = v13 >> 240 & 0xFF;\n            MEM8[v80 + 37] = v13 >> 232 & 0xFF;\n            MEM8[v80 + 36] = v13 >> 224 & 0xFF;\n            MEM8[v80 + 35] = v13 >> 216 & 0xFF;\n            MEM8[v80 + 34] = v13 >> 208 & 0xFF;\n            MEM8[v80 + 33] = v13 >> 200 & 0xFF;\n            MEM8[v80.data] = v13 >> 192 & 0xFF;\n            v82 = v83 = MEM[64];\n            v84 = v85 = MEM[MEM[0]];\n            v86 = v87 = 32 + MEM[0];\n            while (v84 >= 32) {\n                MEM[v82] = MEM[v86];\n                v82 = v82 + 32;\n                v86 = v86 + 32;\n                v84 = v84 - 32;\n            }\n            MEM[v82] = MEM[v86] & ~(256 ** (32 - v84) - 1) | MEM[v82] & 256 ** (32 - v84) - 1;\n            v88, v89 = sha256hash(v90, 0);\n            require(v88);\n            v91 = v92 = v93.data;\n            v94 = v95 = v80.length;\n            v96 = v97 = v80.data;\n            while (v94 >= 32) {\n                MEM[v91] = MEM[v96];\n                v91 = v91 + 32;\n                v96 = v96 + 32;\n                v94 = v94 - 32;\n            }\n            MEM[v91] = MEM[v96] & ~(256 ** (32 - v94) - 1) | MEM[v91] & 256 ** (32 - v94) - 1;\n            v98 = v99 = v95 + v92;\n            v100 = v101 = MEM[MEM[32]];\n            v102 = v103 = 32 + MEM[32];\n            while (v100 >= 32) {\n                MEM[v98] = MEM[v102];\n                v98 = v98 + 32;\n                v102 = v102 + 32;\n                v100 = v100 - 32;\n            }\n            MEM[v98] = MEM[v102] & ~(256 ** (32 - v100) - 1) | MEM[v98] & 256 ** (32 - v100) - 1;\n            MEM[v101 + v99] = ~0x0 & (~0x0 & MEM[v93.data]);\n            v104 = v105 = 32 + (v101 + v99);\n            v106 = v107 = 32 + v93.data;\n            while (v89 >= 32) {\n                MEM[v104] = MEM[v106];\n                v104 = v104 + 32;\n                v106 = v106 + 32;\n                v89 = v89 - 32;\n            }\n            MEM[v104] = MEM[v106] & ~(256 ** (32 - v89) - 1) | MEM[v104] & 256 ** (32 - v89) - 1;\n            map_3[~0x0 & (~0x0 & v78)] = ~0x0 & keccak256(v93.data);\n            return ;\n        }\n    }\n}\n\nfunction 0x1b2b(uint256 varg0, uint256 varg1) private { \n    assert(0 < varg0.length);\n    v0 = v1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248 != 0x4c00000000000000000000000000000000000000000000000000000000000000;\n    if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248 == 0x4c00000000000000000000000000000000000000000000000000000000000000) {\n        assert(1 < varg0.length);\n        v0 = v2 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248 != 0x5000000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        assert(2 < varg0.length);\n        v0 = v3 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[2] >> 248 << 248 != 0x100000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        MEM[MEM[64]] = 0;\n        v4 = new bytes[](array_2.length);\n        v5 = v6 = v4.data;\n        if (array_2.length) {\n            if (31 < array_2.length) {\n                do {\n                    MEM[v5] = STORAGE[v7];\n                    v7 += 1;\n                    v5 += 32;\n                } while (v6 + array_2.length <= v5);\n            } else {\n                MEM[v6] = array_2.length >> 8 << 8;\n            }\n        }\n        v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 = 0x25d4(v4, varg1, v22, varg0);\n        if (v8 != 0) {\n            v23 = v24 = 0;\n        } else {\n            v23 = v25 = 2;\n        }\n    } else {\n        v23 = v26 = 1;\n    }\n    return v23;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return stor_5 - _totalSupply[0];\n}\n\nfunction roll(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 == 10;\n    if (v1) {\n        v0 = v2 = (address(this)).balance >= 0xde0b6b3a764000000;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 100;\n        if (v3) {\n            v0 = v4 = (address(this)).balance >= 0x3782dace9d900000;\n        }\n    }\n    if (!v0) {\n        v0 = varg0 == 1000;\n    }\n    require(v0);\n    require(_totalSupply[msg.sender] >= varg0 * 0xde0b6b3a7640000);\n    map_9[_roll] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & map_9[_roll];\n    map_a[_roll] = varg0;\n    _roll = _roll + 1;\n    v5 = 0x1114(varg0 * 0xde0b6b3a7640000, _owner);\n    0x17b6();\n}\n\nfunction 0x251b(uint256 varg0) private { \n    if (0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed.code.size <= 0) {\n        if (0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1.code.size <= 0) {\n            if (0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e.code.size <= 0) {\n                if (0x146500cfd35b22e4a392fe0adc06de1a1368ed48.code.size <= 0) {\n                    if (0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475.code.size <= 0) {\n                        if (0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf.code.size <= 0) {\n                            if (0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa.code.size <= 0) {\n                                v0 = 0;\n                            } else {\n                                ___callback = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa;\n                                v0 = v1 = 1;\n                            }\n                        } else {\n                            ___callback = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf;\n                            v0 = v2 = 1;\n                        }\n                    } else {\n                        ___callback = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475;\n                        v0 = v3 = 1;\n                    }\n                } else {\n                    ___callback = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48;\n                    v4.word0 = 11;\n                    v5 = v4.data;\n                    v4.word1 = 'eth_rinkeby';\n                    0x47f2('eth_rinkeby');\n                    v0 = v6 = 1;\n                }\n            } else {\n                ___callback = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e;\n                v7.word0 = 9;\n                v8 = v7.data;\n                v7.word1 = 'eth_kovan';\n                0x47f2('eth_kovan');\n                v0 = v9 = 1;\n            }\n        } else {\n            ___callback = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1;\n            v10.word0 = 12;\n            v11 = v10.data;\n            v10.word1 = 'eth_ropsten3';\n            0x47f2('eth_ropsten3');\n            v0 = v12 = 1;\n        }\n    } else {\n        ___callback = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed;\n        v13.word0 = 11;\n        v14 = v13.data;\n        v13.word1 = 'eth_mainnet';\n        0x47f2('eth_mainnet');\n        v0 = v15 = 1;\n    }\n    return v0;\n}\n\nfunction 0x25d4(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    assert(69 < varg3.length);\n    v5 = 68 + ((varg3[69] >> 248 << 248 >> 248) + 2) + 32;\n    v6 = v7 = MEM[64];\n    if (MSIZE() >= v7) {\n        v6 = v8 = new bytes[](32);\n    }\n    v6 = new bytes[](32);\n    v9 = new struct(1);\n    v9.word0 = 0;\n    require(v6.length >= 32);\n    v10 = 32 + v5;\n    v11 = 32;\n    while (v10 < 32 + v5 + 32) {\n        MEM[v6 + v11] = MEM[varg3 + v10];\n        v10 = v10 + 32;\n        v11 = v11 + 32;\n    }\n    MEM[32 + v12.data] = 0;\n    v13 = v14 = v12.data;\n    v15 = v16 = varg0.length;\n    v17 = v18 = varg0.data;\n    while (v15 >= 32) {\n        MEM[v13] = MEM[v17];\n        v13 = v13 + 32;\n        v17 = v17 + 32;\n        v15 = v15 - 32;\n    }\n    MEM[v13] = MEM[v17] & ~(256 ** (32 - v15) - 1) | MEM[v13] & 256 ** (32 - v15) - 1;\n    MEM[v16 + v14] = ~0x0 & (~0x0 & varg2);\n    v19, v20 = sha256hash(v12.data, 0);\n    require(v19);\n    v21 = v22 = v22.data;\n    v23 = v24 = v6.length;\n    v25 = v26 = v6.data;\n    while (v23 >= 32) {\n        MEM[v21] = MEM[v25];\n        v21 = v21 + 32;\n        v25 = v25 + 32;\n        v23 = v23 - 32;\n    }\n    MEM[v21] = MEM[v25] & ~(256 ** (32 - v23) - 1) | MEM[v21] & 256 ** (32 - v23) - 1;\n    if (~0x0 & keccak256(v22) == ~0x0 & keccak256(~0x0 & (~0x0 & v20))) {\n        assert(v5 + 73 + 1 < varg3.length);\n        v27 = v28 = MEM[64];\n        if (MSIZE() >= v28) {\n            v27 = v29 = new bytes[]((varg3[v5 + 73 + 1] >> 248 << 248 >> 248) + 2);\n        }\n        v27 = new bytes[]((varg3[v5 + 73 + 1] >> 248 << 248 >> 248) + 2);\n        v30 = new struct(1);\n        v30.word0 = 0;\n        require(v27.length >= v27.length + 0);\n        v31 = 32 + (v5 + 73);\n        v32 = 32;\n        while (v31 < 32 + (v5 + 73) + v27.length) {\n            MEM[v27 + v32] = MEM[varg3 + v31];\n            v31 = v31 + 32;\n            v32 = v32 + 32;\n        }\n        MEM[32 + v33.data] = 0;\n        v34 = v35 = v33.data;\n        v36 = v37 = v27.length;\n        v38 = v39 = v27.data;\n        while (v36 >= 32) {\n            MEM[v34] = MEM[v38];\n            v34 = v34 + 32;\n            v38 = v38 + 32;\n            v36 = v36 - 32;\n        }\n        MEM[v34] = MEM[v38] & ~(256 ** (32 - v36) - 1) | MEM[v34] & 256 ** (32 - v36) - 1;\n        v40, v41 = sha256hash(v33.data, 0);\n        require(v40);\n        assert(v5 + 32 + 8 < varg3.length);\n        v42 = v43 = 1;\n        require(varg1.length == varg3[v5 + 32 + 8] >> 248 << 248 >> 248);\n        v44 = v45 = 0;\n        while (v44 < varg3[v5 + 32 + 8] >> 248 << 248 >> 248) {\n            assert(v44 < varg1.length);\n            assert(v44 < 32);\n            if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(v41, v44)) << 248 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1[v44] >> 248 << 248) {\n                v42 = v46 = 0;\n            }\n            v44 += 1;\n        }\n        if (v42) {\n            v47 = v48 = MEM[64];\n            if (MSIZE() >= v48) {\n                v47 = v49 = new bytes[](41);\n            }\n            v47 = new bytes[](41);\n            v50 = new struct(1);\n            v50.word0 = 0;\n            require(v47.length >= 41);\n            v51 = 32 + (v5 + 32);\n            v52 = 32;\n            while (v51 < 32 + (v5 + 32) + 41) {\n                MEM[v47 + v52] = MEM[varg3 + v51];\n                v51 = v51 + 32;\n                v52 = v52 + 32;\n            }\n            v53 = v54 = MEM[64];\n            if (MSIZE() >= v54) {\n                v53 = v55 = new bytes[](64);\n            }\n            v53 = new bytes[](64);\n            v56 = new struct(1);\n            v56.word0 = 0;\n            require(v53.length >= 64);\n            v57 = 32 + (v5 + 32 + 41 + v27.length + 65 - 64);\n            v58 = 32;\n            while (v57 < 32 + (v5 + 32 + 41 + v27.length + 65 - 64) + 64) {\n                MEM[v53 + v58] = MEM[varg3 + v57];\n                v57 = v57 + 32;\n                v58 = v58 + 32;\n            }\n            MEM[32 + v59.data] = 0;\n            v60 = v61 = v59.data;\n            v62 = v63 = v53.length;\n            v64 = v65 = v53.data;\n            while (v62 >= 32) {\n                MEM[v60] = MEM[v64];\n                v60 = v60 + 32;\n                v64 = v64 + 32;\n                v62 = v62 - 32;\n            }\n            MEM[v60] = MEM[v64] & ~(256 ** (32 - v62) - 1) | MEM[v60] & 256 ** (32 - v62) - 1;\n            v66, v67 = sha256hash(v59.data, 0);\n            require(v66);\n            v68 = v69 = v70.data;\n            v71 = v72 = v47.length;\n            v73 = v74 = v47.data;\n            while (v71 >= 32) {\n                MEM[v68] = MEM[v73];\n                v68 = v68 + 32;\n                v73 = v73 + 32;\n                v71 = v71 - 32;\n            }\n            MEM[v68] = MEM[v73] & ~(256 ** (32 - v71) - 1) | MEM[v68] & 256 ** (32 - v71) - 1;\n            MEM[v72 + v69] = ~0x0 & (~0x0 & v67);\n            v75 = ~0x0 & (~0x0 & varg2);\n            if (~0x0 & map_3[v75] != ~0x0 & keccak256(v70.data)) {\n                v76 = v77 = 0;\n            } else {\n                v78 = ~0x0 & (~0x0 & varg2);\n                map_3[v78] = 0;\n                v79 = v80 = MEM[64];\n                if (MSIZE() >= v80) {\n                    v79 = v81 = new bytes[](73);\n                }\n                v79 = new bytes[](73);\n                v82 = new struct(1);\n                v82.word0 = 0;\n                require(v79.length >= 73);\n                v83 = 32 + v5;\n                v84 = 32;\n                while (v83 < 32 + v5 + 73) {\n                    MEM[v79 + v84] = MEM[varg3 + v83];\n                    v83 = v83 + 32;\n                    v84 = v84 + 32;\n                }\n                MEM[32 + v85.data] = 0;\n                v86 = v87 = v85.data;\n                v88 = v89 = v79.length;\n                v90 = v91 = v79.data;\n                while (v88 >= 32) {\n                    MEM[v86] = MEM[v90];\n                    v86 = v86 + 32;\n                    v90 = v90 + 32;\n                    v88 = v88 - 32;\n                }\n                MEM[v86] = MEM[v90] & ~(256 ** (32 - v88) - 1) | MEM[v86] & 256 ** (32 - v88) - 1;\n                v92, v93 = sha256hash(v85.data, 0);\n                require(v92);\n                v94 = new struct(1);\n                v94.word0 = 0;\n                v95 = new struct(1);\n                v95.word0 = 0;\n                v96 = MEM[64];\n                if (MSIZE() >= v96) {\n                    v96 = v97 = new bytes[](32);\n                }\n                v96 = new bytes[](32);\n                assert(3 < v27.length);\n                v98 = new struct(1);\n                v98.word0 = 0;\n                require(v96.length >= 32);\n                v99 = 36 + ((v27[3] >> 248 << 248 >> 248) - 32);\n                v100 = 32;\n                while (v99 < 36 + ((v27[3] >> 248 << 248 >> 248) - 32) + 32) {\n                    MEM[v96 + v100] = MEM[v27 + v99];\n                    v99 = v99 + 32;\n                    v100 = v100 + 32;\n                }\n                v101 = MEM[64];\n                if (MSIZE() >= v101) {\n                    v101 = v102 = new bytes[](32);\n                }\n                v101 = new bytes[](32);\n                assert(4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1 < v27.length);\n                v103 = new struct(1);\n                v103.word0 = 0;\n                require(v101.length >= 32);\n                v104 = 32 + (4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 + ((v27[4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1] >> 248 << 248 >> 248) - 32));\n                v105 = 32;\n                while (v104 < 32 + (4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 + ((v27[4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1] >> 248 << 248 >> 248) - 32)) + 32) {\n                    MEM[v101 + v105] = MEM[v27 + v104];\n                    v104 = v104 + 32;\n                    v105 = v105 + 32;\n                }\n                v106, v107 = ecrecover(v93, 27, MEM[v97.data], MEM[v102.data]);\n                v108 = v108.data;\n                v109 = v53.length;\n                v110 = v53.data;\n                while (v109 >= 32) {\n                    MEM[v108] = MEM[v110];\n                    v108 = v108 + 32;\n                    v110 = v110 + 32;\n                    v109 = v109 - 32;\n                }\n                MEM[v108] = MEM[v110] & ~(256 ** (32 - v109) - 1) | MEM[v108] & 256 ** (32 - v109) - 1;\n                if (address(keccak256(v108)) != address(v107)) {\n                    v111, v112 = ecrecover(v93, 28, MEM[v97.data], MEM[v102.data]);\n                    v113 = v113.data;\n                    v114 = v53.length;\n                    v115 = v53.data;\n                    while (v114 >= 32) {\n                        MEM[v113] = MEM[v115];\n                        v113 = v113 + 32;\n                        v115 = v115 + 32;\n                        v114 = v114 - 32;\n                    }\n                    MEM[v113] = MEM[v115] & ~(256 ** (32 - v114) - 1) | MEM[v113] & 256 ** (32 - v114) - 1;\n                    v116 = address(keccak256(v113)) == address(v112);\n                } else {\n                    v116 = v117 = 1;\n                }\n                return v116, v79, v67, v5 + 32 + 41 + v27.length + 65, v53, v47, v27, v6, v5, 0, varg0;\n            }\n        } else {\n            v76 = v118 = 0;\n        }\n    } else {\n        v76 = v119 = 0;\n    }\n    return v76;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x9af(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction __callback(bytes32 varg0, string varg1) public nonPayable { \n    v0 = v1 = ~0x0 & varg0;\n    v0 = v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new bytes[](0);\n    }\n    v3 = new bytes[](0);\n    v6 = v7 = ___callback == 0;\n    if (___callback != 0) {\n        v6 = ___callback.code.size == 0;\n    }\n    if (v6) {\n        v8 = 0x251b(0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(___callback.code.size);\n    v9, v10 = ___callback.getAddress().gas(msg.gas - 710);\n    require(v9);\n    if (owner_1_0_19 != address(MEM[MEM[0x40]])) {\n        MEM[32 + MEM[64]] = 0;\n        require(___callback.code.size);\n        v11, v12 = ___callback.getAddress().gas(msg.gas - 710);\n        require(v11);\n        owner_1_0_19 = MEM[MEM[64]];\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(owner_1_0_19.code.size);\n    v13, v14 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    require(v13);\n    require(msg.sender == address(MEM[MEM[0x40]]));\n    v15 = 0x1b2b(v3, v2);\n    if (0xff & v15 != 3465) {\n        if (stor_f > 2) {\n            emit LedgerFailed('Stopping');\n        } else {\n            emit LedgerFailed('Requesting new');\n            require(stor_f + 1 >= stor_f);\n            stor_f = stor_f + 1;\n            0x17b6();\n        }\n    } else {\n        v16 = v16.data;\n        v17 = v3.length;\n        v18 = v5.data;\n        while (v17 >= 32) {\n            MEM[v16] = MEM[v18];\n            v16 = v16 + 32;\n            v18 = v18 + 32;\n            v17 = v17 - 32;\n        }\n        MEM[v16] = MEM[v18] & ~(256 ** (32 - v17) - 1) | MEM[v16] & 256 ** (32 - v17) - 1;\n        0xe0e(keccak256(v16), 0xf4240, 1);\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction receiveFromGame() public payable { \n    emit EthReceived(msg.sender, msg.value);\n}\n\nfunction __callback(bytes32 varg0, string varg1, bytes varg2) public nonPayable { \n    v0 = v1 = ~0x0 & varg0;\n    v0 = v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    v3 = new bytes[](varg2.length);\n    CALLDATACOPY(v3.data, 36 + varg2, varg2.length);\n    v4 = v5 = ___callback == 0;\n    if (___callback != 0) {\n        v4 = ___callback.code.size == 0;\n    }\n    if (v4) {\n        v6 = 0x251b(0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(___callback.code.size);\n    v7, v8 = ___callback.getAddress().gas(msg.gas - 710);\n    require(v7);\n    if (owner_1_0_19 != address(MEM[MEM[0x40]])) {\n        MEM[32 + MEM[64]] = 0;\n        require(___callback.code.size);\n        v9, v10 = ___callback.getAddress().gas(msg.gas - 710);\n        require(v9);\n        owner_1_0_19 = MEM[MEM[64]];\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(owner_1_0_19.code.size);\n    v11, v12 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    require(v11);\n    require(msg.sender == address(MEM[MEM[0x40]]));\n    v13 = 0x1b2b(v3, v2);\n    if (0xff & v13 != 3465) {\n        if (stor_f > 2) {\n            emit LedgerFailed('Stopping');\n        } else {\n            emit LedgerFailed('Requesting new');\n            require(stor_f + 1 >= stor_f);\n            stor_f = stor_f + 1;\n            0x17b6();\n        }\n    } else {\n        v14 = v14.data;\n        v15 = v3.length;\n        v16 = v3.data;\n        while (v15 >= 32) {\n            MEM[v14] = MEM[v16];\n            v14 = v14 + 32;\n            v16 = v16 + 32;\n            v15 = v15 - 32;\n        }\n        MEM[v14] = MEM[v16] & ~(256 ** (32 - v15) - 1) | MEM[v14] & 256 ** (32 - v15) - 1;\n        0xe0e(keccak256(v14), 0xf4240, 1);\n    }\n}\n\nfunction addGame(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _awardToken[varg0] = 0x1 | ~0xff & _awardToken[varg0];\n    owner_e[varg0] = varg1;\n    _allowance[varg0] = stor_5;\n    emit Approval(msg.sender, varg0, stor_5);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _totalSupply[varg0];\n}\n\nfunction 0x47f2(uint256 varg0) private { \n    v0 = v1 = varg0.data;\n    if (31 < varg0.word0) {\n        array_2.length = 1 + (varg0.word0 + varg0.word0);\n        if (varg0.word0) {\n            while (v1 + varg0.word0 > v0) {\n                STORAGE[v2] = MEM[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        array_2.length = varg0.word0 + varg0.word0 | ~0xff & varg0.word1;\n    }\n    while (v3 + (31 + array_2.length >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x4850(uint256 varg0) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(2);\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v1.word0 = v2;\n    v1.word1 = 0;\n    MEM[(MEM[64]) len (MSIZE() - MEM[64])] = this.code[this.code.size len (MSIZE() - MEM[64])];\n    v3 = v4 = 1024;\n    if (0 != 0) {\n        v3 = 1056;\n    }\n    v1.word1 = v3;\n    v1.word0 = MEM[64];\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + v3;\n    0x4978(4, v1);\n    if (0 >= varg0.length) {\n        0x4978(7, v1);\n        return v1.word0;\n    } else {\n        assert(0 < varg0.length);\n        0x499c(MEM[varg0[0]], 2, v1);\n        v5 = 0x4af5(varg0[0], v1);\n        return 0, v1, v0, varg0;\n    }\n}\n\nfunction 0x4978(uint256 varg0, uint256 varg1) private { \n    0x4ba1((0xff & varg0) << 5 | 0x1f, varg1);\n    return ;\n}\n\nfunction 0x499c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 > 23) {\n        if (varg0 > 255) {\n            if (varg0 > 0xffff) {\n                if (varg0 > 0xffffffff) {\n                    if (varg0 <= 0xffffffffffffffff) {\n                        0x4ba1((0xff & varg1) << 5 | 0x1b, varg2);\n                        v0 = 0x4be1(8, varg0, varg2);\n                    }\n                } else {\n                    0x4ba1((0xff & varg1) << 5 | 0x1a, varg2);\n                    v1 = 0x4be1(4, varg0, varg2);\n                }\n            } else {\n                0x4ba1((0xff & varg1) << 5 | 0x19, varg2);\n                v2 = 0x4be1(2, varg0, varg2);\n            }\n        } else {\n            0x4ba1((0xff & varg1) << 5 | 0x18, varg2);\n            v3 = 0x4be1(1, varg0, varg2);\n        }\n    } else {\n        0x4ba1(0xff & (0xff & varg1) << 5 | varg0, varg2);\n    }\n    return ;\n}\n\nfunction 0x4af5(uint256 varg0, uint256 varg1) private { \n    v0 = new struct(2);\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v0.word0 = v1;\n    v0.word1 = 0;\n    if (MEM[varg0] + MEM[varg1.word0] > varg1.word1) {\n        v2 = 0x4c48(MEM[varg0], varg1.word1);\n        0x4c64(v2 << 1, varg1);\n    }\n    v3 = v4 = MEM[varg0];\n    v5 = v6 = varg1.word0 + MEM[varg1.word0] + 32;\n    MEM[varg1.word0] = MEM[varg1.word0] + MEM[varg0];\n    v7 = v8 = varg0 + 32;\n    while (v3 >= 32) {\n        MEM[v5] = MEM[v7];\n        v5 = v5 + 32;\n        v7 = v7 + 32;\n        v3 = v3 - 32;\n    }\n    MEM[v5] = MEM[v5] & 256 ** (32 - v3) - 1 | MEM[v7] & ~(256 ** (32 - v3) - 1);\n    return varg1;\n}\n\nfunction 0x4ba1(uint256 varg0, uint256 varg1) private { \n    if (MEM[MEM[0 + varg1]] + 1 > MEM[32 + varg1]) {\n        0x4c64(MEM[32 + varg1] << 1, varg1);\n    }\n    v0 = MEM[varg1];\n    MEM8[v0 + MEM[v0] + 32] = varg0 & 0xFF;\n    MEM[v0] = MEM[v0] + 1;\n    return ;\n}\n\nfunction 0x4be1(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = new struct(2);\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v0.word0 = v1;\n    v0.word1 = 0;\n    if (varg0 + MEM[MEM[0 + varg2]] > MEM[32 + varg2]) {\n        v2 = 0x4c48(varg0, MEM[32 + varg2]);\n        0x4c64(v2 << 1, varg2);\n    }\n    v3 = MEM[varg2];\n    v4 = v3 + MEM[v3] + varg0;\n    MEM[v4] = MEM[v4] & ~(256 ** varg0 - 1) | varg1;\n    MEM[v3] = MEM[v3] + varg0;\n    return varg2;\n}\n\nfunction 0x4c48(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n    }\n    return varg0;\n}\n\nfunction 0x4c64(uint256 varg0, uint256 varg1) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    if (varg0 % 32 != 0) {\n        varg0 = v1 = varg0 + (32 - varg0 % 32);\n    }\n    MEM[32 + varg1] = varg0;\n    MEM[varg1] = MEM[64];\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + varg0;\n    v2 = 0x4af5(MEM[0 + varg1], varg1);\n    return ;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x424e530000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1114(varg1, varg0);\n    return v0;\n}\n\nfunction forceRoll() public nonPayable { \n    require(msg.sender == _owner);\n    stor_f = 0;\n    0x17b6();\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction takeAll() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction awardToken(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _awardToken[msg.sender]);\n    v0 = v1 = 1;\n    if ((address(this)).balance >= 0xde0b6b3a7640000) {\n        if ((address(this)).balance >= 0x1bc16d674ec80000) {\n            if ((address(this)).balance >= 0x3782dace9d900000) {\n                if ((address(this)).balance >= 0x6f05b59d3b200000) {\n                    if ((address(this)).balance >= 0xde0b6b3a76400000) {\n                        if ((address(this)).balance >= 0x1bc16d674ec800000) {\n                            if ((address(this)).balance >= 0x3782dace9d9000000) {\n                                if ((address(this)).balance >= 0x6f05b59d3b2000000) {\n                                    if ((address(this)).balance >= 0xde0b6b3a764000000) {\n                                        if ((address(this)).balance < 0x1bc16d674ec8000000) {\n                                            v0 = v2 = 2;\n                                        }\n                                    } else {\n                                        v0 = v3 = 4;\n                                    }\n                                } else {\n                                    v0 = v4 = 6;\n                                }\n                            } else {\n                                v0 = v5 = 8;\n                            }\n                        } else {\n                            v0 = v6 = 10;\n                        }\n                    } else {\n                        v0 = v7 = 15;\n                    }\n                } else {\n                    v0 = v8 = 20;\n                }\n            } else {\n                v0 = v9 = 30;\n            }\n        } else {\n            v0 = v10 = 40;\n        }\n    } else {\n        v0 = v11 = 50;\n    }\n    require(0xff & _awardToken[msg.sender]);\n    v12 = 0x9af(owner_e[msg.sender] * varg1 * 0xe8d4a51000 * v0, varg0, _owner);\n}\n\nfunction 0x9af(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(varg0 <= _totalSupply[v0]);\n    v1 = address(varg2);\n    _totalSupply[v1] = _totalSupply[v0] - varg0;\n    v2 = address(varg2);\n    require(varg0 <= _totalSupply[msg.sender]);\n    v3 = address(varg2);\n    _allowance[msg.sender] = _totalSupply[msg.sender] - varg0;\n    v4 = address(varg1);\n    v5 = _totalSupply[v4] + varg0;\n    require(v5 >= _totalSupply[v4]);\n    v6 = address(varg1);\n    _totalSupply[v6] = v5;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction 0xe0e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 % varg1 + varg2;\n    map_9[stor_c] = ~0xffffffffffffffffffffffffffffffffffffffff & map_9[stor_c];\n    v1 = v2 = map_a[stor_c] == 0;\n    if (map_a[stor_c] != 0) {\n        assert(map_a[stor_c]);\n        v1 = map_a[stor_c] * 10 / map_a[stor_c] == 10;\n    }\n    require(v1);\n    map_a[stor_c] = 0;\n    stor_c = stor_c + 1;\n    emit GotRandom(v0);\n    if (v0 <= map_a[stor_c] * 10) {\n        emit Winner(address(this), address(map_9[stor_c]), (address(this)).balance, v0, 0);\n        require(2 > 0);\n        assert(2);\n        v3 = address(map_9[stor_c]).call().value((address(this)).balance >> 1).gas(!((address(this)).balance >> 1) * 2300);\n        require(v3);\n    }\n    return ;\n}\n\nfunction () public payable { \n    v0 = msg.sender.call().value(msg.value).gas(!msg.value * 2300);\n    require(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x95ea7b3 == uint32(function_selector >> 224)) {\n            approve(address,uint256);\n        } else if (0x18160ddd == uint32(function_selector >> 224)) {\n            totalSupply();\n        } else if (0x1f7b4f30 == uint32(function_selector >> 224)) {\n            roll(uint256);\n        } else if (0x23b872dd == uint32(function_selector >> 224)) {\n            transferFrom(address,address,uint256);\n        } else if (0x27dc297e == uint32(function_selector >> 224)) {\n            __callback(bytes32,string);\n        } else if (0x313ce567 == uint32(function_selector >> 224)) {\n            decimals();\n        } else if (0x386304e4 == uint32(function_selector >> 224)) {\n            receiveFromGame();\n        } else if (0x38bbfa50 == uint32(function_selector >> 224)) {\n            __callback(bytes32,string,bytes);\n        } else if (0x5dce431b == uint32(function_selector >> 224)) {\n            addGame(address,uint256);\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0x95d89b41 == uint32(function_selector >> 224)) {\n            symbol();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xcbc9023c == uint32(function_selector >> 224)) {\n            forceRoll();\n        } else if (0xdd62ed3e == uint32(function_selector >> 224)) {\n            allowance(address,address);\n        } else if (0xde3bcb97 == uint32(function_selector >> 224)) {\n            takeAll();\n        } else if (0xded2d0f4 == uint32(function_selector >> 224)) {\n            awardToken(address,uint256);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.28 03:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) map_3; // STORAGE[0x3]\nuint256 stor_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) map_a; // STORAGE[0xa]\nuint256 _roll; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _awardToken; // STORAGE[0xd]\nmapping (uint256 => [uint256]) owner_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 ___callback; // STORAGE[0x0] bytes 0 to 19\nuint256 owner_1_0_19; // STORAGE[0x1] bytes 0 to 19\nuint256 _owner; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nEthReceived(address, uint256);\nLedgerFailed(string);\nGotRandom(uint256);\nWinner(address, address, uint256, uint256, uint256);\n\nfunction 0x1114(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0);\n    require(varg0 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg0;\n    v0 = address(varg1);\n    v1 = _totalSupply[v0] + varg0;\n    require(v1 >= _totalSupply[v0]);\n    v2 = address(varg1);\n    _totalSupply[v2] = v1;\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return 1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (11) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffff & 'Bonus Token';\n    }\n    return v0;\n}\n\nfunction 0x17b6() private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = new struct(4);\n    v7 = v8 = 4;\n    while (1) {\n        v9 = new struct(1);\n        v9.word0 = 0;\n        MEM[v5] = v9;\n        v5 += 32;\n        v7 = v7 - 1;\n        if (v7) {\n            break;\n        }\n        if (!v7) {\n            v10 = new struct(1);\n            v10.word0 = 0;\n            v11 = v12 = 7 > 0;\n            if (v12) {\n                v11 = 7 <= 32;\n            }\n            require(v11);\n            v13 = v14 = MEM[64];\n            if (MSIZE() >= v14) {\n                v13 = new uint256[](1);\n            }\n            v13 = new uint256[](1);\n            assert(0 < v13.length);\n            v15 = v13.data;\n            MEM8[v13.data] = (byte(0x700000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n            v16 = v17 = MEM[64];\n            if (MSIZE() >= v17) {\n                v16 = new bytes[](32);\n            }\n            v16 = new bytes[](32);\n            v18 = v19 = MEM[64];\n            if (MSIZE() >= v19) {\n                v18 = new bytes[](32);\n            }\n            v18 = new bytes[](32);\n            v20 = v21 = ___callback == 0;\n            if (___callback != 0) {\n                v20 = ___callback.code.size == 0;\n            }\n            if (v20) {\n                v22 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v23, v24 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v23);\n            if (owner_1_0_19 != address(v24)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v25, v26 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v25);\n                owner_1_0_19 = v26;\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(owner_1_0_19.code.size);\n            v27, v28 = owner_1_0_19.randomDS_getSessionPubKeyHash().gas(msg.gas - 710);\n            require(v27);\n            MEM[v16.data] = block.blockhash(block.number - 1) ^ (block.coinbase ^ block.timestamp);\n            MEM[v18.data] = v28;\n            v29 = v30 = MEM[64];\n            if (MSIZE() >= v30) {\n                v29 = 0;\n            }\n            if (MSIZE() >= MEM[64]) {\n                v31 = new array[](8);\n            }\n            v31 = new array[](8);\n            v32 = new struct(1);\n            v32.word0 = 0;\n            require(v31.length >= 8);\n            v33 = 56;\n            v34 = 32;\n            while (v33 < 64) {\n                MEM[v31 + v34] = MEM[v29 + v33];\n                v33 = v33 + 32;\n                v34 = v34 + 32;\n            }\n            v35 = v36 = ___callback == 0;\n            if (___callback != 0) {\n                v35 = ___callback.code.size == 0;\n            }\n            if (v35) {\n                v37 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v38, v39 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v38);\n            if (owner_1_0_19 != address(v39)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v40, v41 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v40);\n                owner_1_0_19 = v41;\n            }\n            v42 = v43 = 4;\n            v44 = v45 = MEM[64];\n            if (MSIZE() >= v45) {\n                v44 = v46 = new uint256[](v43);\n            }\n            v44 = new uint256[](v43);\n            if (v43) {\n                v47 = v46.data;\n                do {\n                    v48 = new struct(1);\n                    v48.word0 = 0;\n                    MEM[v47] = v48;\n                    v47 += 32;\n                    v42 = v42 - 1;\n                } while (!v42);\n            }\n            assert(0 < v44.length);\n            v49 = v46.data;\n            v50 = v46.data;\n            v46[0] = v16;\n            assert(1 < v44.length);\n            v46[32] = v13;\n            assert(2 < v44.length);\n            v46[64] = v18;\n            assert(3 < v44.length);\n            v46[96] = v29;\n            v51 = new struct(1);\n            v51.word0 = 0;\n            v52 = v53 = ___callback == 0;\n            if (___callback != 0) {\n                v52 = ___callback.code.size == 0;\n            }\n            if (v52) {\n                v54 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v55, v56 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v55);\n            if (owner_1_0_19 != address(v56)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v57, v58 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v57);\n                owner_1_0_19 = v58;\n            }\n            MEM[32 + MEM[64]] = 0;\n            v59 = new array[](v60.length);\n            v61 = v62 = 0;\n            while (v61 < v60.length) {\n                v59[v61] = v60[v61];\n                v61 = v61 + 32;\n            }\n            if (6) {\n                MEM[v59.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'random';\n            }\n            require(owner_1_0_19.code.size);\n            v63, v64 = owner_1_0_19.getPrice(v59, 0x3d090).gas(msg.gas - 710);\n            require(v63);\n            if (v64 <= 0xde0b6b3a7640000 + msg.gas * 0x3d090) {\n                v65, v66, v67, v68 = 0x4850(v44);\n                MEM[32 + MEM[64]] = 0;\n                v69 = new array[](MEM[0]);\n                v70 = v71 = 0;\n                while (v70 < MEM[0]) {\n                    v69[v70] = MEM[32 + v70];\n                    v70 = v70 + 32;\n                }\n                if (0x1f & MEM[0]) {\n                    MEM[MEM[0] + v69.data - (0x1f & MEM[0])] = ~(256 ** (32 - (0x1f & MEM[0])) - 1) & MEM[MEM[0] + v69.data - (0x1f & MEM[0])];\n                }\n                v72 = new array[](MEM[v65]);\n                v73 = v74 = 0;\n                while (v73 < MEM[v65]) {\n                    MEM[v72.data + v73] = MEM[32 + v65 + v73];\n                    v73 = v73 + 32;\n                }\n                v75 = v76 = MEM[v65] + v72.data;\n                if (0x1f & MEM[v65]) {\n                    MEM[v76 - (0x1f & MEM[v65])] = ~(256 ** (32 - (0x1f & MEM[v65])) - 1) & MEM[v76 - (0x1f & MEM[v65])];\n                }\n                require(owner_1_0_19.code.size);\n                v77, v78 = owner_1_0_19.queryN_withGasLimit(0, v69, v72, v51).value(v67).gas(msg.gas - 9710);\n                require(v77);\n            } else {\n                v78 = v79 = 0;\n            }\n            v80 = v81 = MEM[64];\n            if (MSIZE() >= v81) {\n                v80 = new array[](8);\n            }\n            v80 = new array[](8);\n            MEM8[v80 + 39] = v13 >> 248 & 0xFF;\n            MEM8[v80 + 38] = v13 >> 240 & 0xFF;\n            MEM8[v80 + 37] = v13 >> 232 & 0xFF;\n            MEM8[v80 + 36] = v13 >> 224 & 0xFF;\n            MEM8[v80 + 35] = v13 >> 216 & 0xFF;\n            MEM8[v80 + 34] = v13 >> 208 & 0xFF;\n            MEM8[v80 + 33] = v13 >> 200 & 0xFF;\n            MEM8[v80.data] = v13 >> 192 & 0xFF;\n            v82 = v83 = MEM[64];\n            v84 = v85 = MEM[MEM[0]];\n            v86 = v87 = 32 + MEM[0];\n            while (v84 >= 32) {\n                MEM[v82] = MEM[v86];\n                v82 = v82 + 32;\n                v86 = v86 + 32;\n                v84 = v84 - 32;\n            }\n            MEM[v82] = MEM[v86] & ~(256 ** (32 - v84) - 1) | MEM[v82] & 256 ** (32 - v84) - 1;\n            v88, v89 = sha256hash(v90, 0);\n            require(v88);\n            v91 = v92 = v93.data;\n            v94 = v95 = v80.length;\n            v96 = v97 = v80.data;\n            while (v94 >= 32) {\n                MEM[v91] = MEM[v96];\n                v91 = v91 + 32;\n                v96 = v96 + 32;\n                v94 = v94 - 32;\n            }\n            MEM[v91] = MEM[v96] & ~(256 ** (32 - v94) - 1) | MEM[v91] & 256 ** (32 - v94) - 1;\n            v98 = v99 = v95 + v92;\n            v100 = v101 = MEM[MEM[32]];\n            v102 = v103 = 32 + MEM[32];\n            while (v100 >= 32) {\n                MEM[v98] = MEM[v102];\n                v98 = v98 + 32;\n                v102 = v102 + 32;\n                v100 = v100 - 32;\n            }\n            MEM[v98] = MEM[v102] & ~(256 ** (32 - v100) - 1) | MEM[v98] & 256 ** (32 - v100) - 1;\n            MEM[v101 + v99] = ~0x0 & (~0x0 & MEM[v93.data]);\n            v104 = v105 = 32 + (v101 + v99);\n            v106 = v107 = 32 + v93.data;\n            while (v89 >= 32) {\n                MEM[v104] = MEM[v106];\n                v104 = v104 + 32;\n                v106 = v106 + 32;\n                v89 = v89 - 32;\n            }\n            MEM[v104] = MEM[v106] & ~(256 ** (32 - v89) - 1) | MEM[v104] & 256 ** (32 - v89) - 1;\n            map_3[~0x0 & (~0x0 & v78)] = ~0x0 & keccak256(v93.data);\n            return ;\n        }\n    }\n}\n\nfunction 0x1b2b(uint256 varg0, uint256 varg1) private { \n    assert(0 < varg0.length);\n    v0 = v1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248 != 0x4c00000000000000000000000000000000000000000000000000000000000000;\n    if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248 == 0x4c00000000000000000000000000000000000000000000000000000000000000) {\n        assert(1 < varg0.length);\n        v0 = v2 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248 != 0x5000000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        assert(2 < varg0.length);\n        v0 = v3 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[2] >> 248 << 248 != 0x100000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        MEM[MEM[64]] = 0;\n        v4 = new bytes[](array_2.length);\n        v5 = v6 = v4.data;\n        if (array_2.length) {\n            if (31 < array_2.length) {\n                do {\n                    MEM[v5] = STORAGE[v7];\n                    v7 += 1;\n                    v5 += 32;\n                } while (v6 + array_2.length <= v5);\n            } else {\n                MEM[v6] = array_2.length >> 8 << 8;\n            }\n        }\n        v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 = 0x25d4(v4, varg1, v22, varg0);\n        if (v8 != 0) {\n            v23 = v24 = 0;\n        } else {\n            v23 = v25 = 2;\n        }\n    } else {\n        v23 = v26 = 1;\n    }\n    return v23;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return stor_5 - _totalSupply[0];\n}\n\nfunction roll(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 == 10;\n    if (v1) {\n        v0 = v2 = (address(this)).balance >= 0xde0b6b3a764000000;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 100;\n        if (v3) {\n            v0 = v4 = (address(this)).balance >= 0x3782dace9d900000;\n        }\n    }\n    if (!v0) {\n        v0 = varg0 == 1000;\n    }\n    require(v0);\n    require(_totalSupply[msg.sender] >= varg0 * 0xde0b6b3a7640000);\n    map_9[_roll] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & map_9[_roll];\n    map_a[_roll] = varg0;\n    _roll = _roll + 1;\n    v5 = 0x1114(varg0 * 0xde0b6b3a7640000, _owner);\n    0x17b6();\n}\n\nfunction 0x251b(uint256 varg0) private { \n    if (0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed.code.size <= 0) {\n        if (0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1.code.size <= 0) {\n            if (0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e.code.size <= 0) {\n                if (0x146500cfd35b22e4a392fe0adc06de1a1368ed48.code.size <= 0) {\n                    if (0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475.code.size <= 0) {\n                        if (0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf.code.size <= 0) {\n                            if (0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa.code.size <= 0) {\n                                v0 = 0;\n                            } else {\n                                ___callback = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa;\n                                v0 = v1 = 1;\n                            }\n                        } else {\n                            ___callback = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf;\n                            v0 = v2 = 1;\n                        }\n                    } else {\n                        ___callback = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475;\n                        v0 = v3 = 1;\n                    }\n                } else {\n                    ___callback = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48;\n                    v4.word0 = 11;\n                    v5 = v4.data;\n                    v4.word1 = 'eth_rinkeby';\n                    0x47f2('eth_rinkeby');\n                    v0 = v6 = 1;\n                }\n            } else {\n                ___callback = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e;\n                v7.word0 = 9;\n                v8 = v7.data;\n                v7.word1 = 'eth_kovan';\n                0x47f2('eth_kovan');\n                v0 = v9 = 1;\n            }\n        } else {\n            ___callback = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1;\n            v10.word0 = 12;\n            v11 = v10.data;\n            v10.word1 = 'eth_ropsten3';\n            0x47f2('eth_ropsten3');\n            v0 = v12 = 1;\n        }\n    } else {\n        ___callback = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed;\n        v13.word0 = 11;\n        v14 = v13.data;\n        v13.word1 = 'eth_mainnet';\n        0x47f2('eth_mainnet');\n        v0 = v15 = 1;\n    }\n    return v0;\n}\n\nfunction 0x25d4(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    assert(69 < varg3.length);\n    v5 = 68 + ((varg3[69] >> 248 << 248 >> 248) + 2) + 32;\n    v6 = v7 = MEM[64];\n    if (MSIZE() >= v7) {\n        v6 = v8 = new bytes[](32);\n    }\n    v6 = new bytes[](32);\n    v9 = new struct(1);\n    v9.word0 = 0;\n    require(v6.length >= 32);\n    v10 = 32 + v5;\n    v11 = 32;\n    while (v10 < 32 + v5 + 32) {\n        MEM[v6 + v11] = MEM[varg3 + v10];\n        v10 = v10 + 32;\n        v11 = v11 + 32;\n    }\n    MEM[32 + v12.data] = 0;\n    v13 = v14 = v12.data;\n    v15 = v16 = varg0.length;\n    v17 = v18 = varg0.data;\n    while (v15 >= 32) {\n        MEM[v13] = MEM[v17];\n        v13 = v13 + 32;\n        v17 = v17 + 32;\n        v15 = v15 - 32;\n    }\n    MEM[v13] = MEM[v17] & ~(256 ** (32 - v15) - 1) | MEM[v13] & 256 ** (32 - v15) - 1;\n    MEM[v16 + v14] = ~0x0 & (~0x0 & varg2);\n    v19, v20 = sha256hash(v12.data, 0);\n    require(v19);\n    v21 = v22 = v22.data;\n    v23 = v24 = v6.length;\n    v25 = v26 = v6.data;\n    while (v23 >= 32) {\n        MEM[v21] = MEM[v25];\n        v21 = v21 + 32;\n        v25 = v25 + 32;\n        v23 = v23 - 32;\n    }\n    MEM[v21] = MEM[v25] & ~(256 ** (32 - v23) - 1) | MEM[v21] & 256 ** (32 - v23) - 1;\n    if (~0x0 & keccak256(v22) == ~0x0 & keccak256(~0x0 & (~0x0 & v20))) {\n        assert(v5 + 73 + 1 < varg3.length);\n        v27 = v28 = MEM[64];\n        if (MSIZE() >= v28) {\n            v27 = v29 = new bytes[]((varg3[v5 + 73 + 1] >> 248 << 248 >> 248) + 2);\n        }\n        v27 = new bytes[]((varg3[v5 + 73 + 1] >> 248 << 248 >> 248) + 2);\n        v30 = new struct(1);\n        v30.word0 = 0;\n        require(v27.length >= v27.length + 0);\n        v31 = 32 + (v5 + 73);\n        v32 = 32;\n        while (v31 < 32 + (v5 + 73) + v27.length) {\n            MEM[v27 + v32] = MEM[varg3 + v31];\n            v31 = v31 + 32;\n            v32 = v32 + 32;\n        }\n        MEM[32 + v33.data] = 0;\n        v34 = v35 = v33.data;\n        v36 = v37 = v27.length;\n        v38 = v39 = v27.data;\n        while (v36 >= 32) {\n            MEM[v34] = MEM[v38];\n            v34 = v34 + 32;\n            v38 = v38 + 32;\n            v36 = v36 - 32;\n        }\n        MEM[v34] = MEM[v38] & ~(256 ** (32 - v36) - 1) | MEM[v34] & 256 ** (32 - v36) - 1;\n        v40, v41 = sha256hash(v33.data, 0);\n        require(v40);\n        assert(v5 + 32 + 8 < varg3.length);\n        v42 = v43 = 1;\n        require(varg1.length == varg3[v5 + 32 + 8] >> 248 << 248 >> 248);\n        v44 = v45 = 0;\n        while (v44 < varg3[v5 + 32 + 8] >> 248 << 248 >> 248) {\n            assert(v44 < varg1.length);\n            assert(v44 < 32);\n            if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(v41, v44)) << 248 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1[v44] >> 248 << 248) {\n                v42 = v46 = 0;\n            }\n            v44 += 1;\n        }\n        if (v42) {\n            v47 = v48 = MEM[64];\n            if (MSIZE() >= v48) {\n                v47 = v49 = new bytes[](41);\n            }\n            v47 = new bytes[](41);\n            v50 = new struct(1);\n            v50.word0 = 0;\n            require(v47.length >= 41);\n            v51 = 32 + (v5 + 32);\n            v52 = 32;\n            while (v51 < 32 + (v5 + 32) + 41) {\n                MEM[v47 + v52] = MEM[varg3 + v51];\n                v51 = v51 + 32;\n                v52 = v52 + 32;\n            }\n            v53 = v54 = MEM[64];\n            if (MSIZE() >= v54) {\n                v53 = v55 = new bytes[](64);\n            }\n            v53 = new bytes[](64);\n            v56 = new struct(1);\n            v56.word0 = 0;\n            require(v53.length >= 64);\n            v57 = 32 + (v5 + 32 + 41 + v27.length + 65 - 64);\n            v58 = 32;\n            while (v57 < 32 + (v5 + 32 + 41 + v27.length + 65 - 64) + 64) {\n                MEM[v53 + v58] = MEM[varg3 + v57];\n                v57 = v57 + 32;\n                v58 = v58 + 32;\n            }\n            MEM[32 + v59.data] = 0;\n            v60 = v61 = v59.data;\n            v62 = v63 = v53.length;\n            v64 = v65 = v53.data;\n            while (v62 >= 32) {\n                MEM[v60] = MEM[v64];\n                v60 = v60 + 32;\n                v64 = v64 + 32;\n                v62 = v62 - 32;\n            }\n            MEM[v60] = MEM[v64] & ~(256 ** (32 - v62) - 1) | MEM[v60] & 256 ** (32 - v62) - 1;\n            v66, v67 = sha256hash(v59.data, 0);\n            require(v66);\n            v68 = v69 = v70.data;\n            v71 = v72 = v47.length;\n            v73 = v74 = v47.data;\n            while (v71 >= 32) {\n                MEM[v68] = MEM[v73];\n                v68 = v68 + 32;\n                v73 = v73 + 32;\n                v71 = v71 - 32;\n            }\n            MEM[v68] = MEM[v73] & ~(256 ** (32 - v71) - 1) | MEM[v68] & 256 ** (32 - v71) - 1;\n            MEM[v72 + v69] = ~0x0 & (~0x0 & v67);\n            v75 = ~0x0 & (~0x0 & varg2);\n            if (~0x0 & map_3[v75] != ~0x0 & keccak256(v70.data)) {\n                v76 = v77 = 0;\n            } else {\n                v78 = ~0x0 & (~0x0 & varg2);\n                map_3[v78] = 0;\n                v79 = v80 = MEM[64];\n                if (MSIZE() >= v80) {\n                    v79 = v81 = new bytes[](73);\n                }\n                v79 = new bytes[](73);\n                v82 = new struct(1);\n                v82.word0 = 0;\n                require(v79.length >= 73);\n                v83 = 32 + v5;\n                v84 = 32;\n                while (v83 < 32 + v5 + 73) {\n                    MEM[v79 + v84] = MEM[varg3 + v83];\n                    v83 = v83 + 32;\n                    v84 = v84 + 32;\n                }\n                MEM[32 + v85.data] = 0;\n                v86 = v87 = v85.data;\n                v88 = v89 = v79.length;\n                v90 = v91 = v79.data;\n                while (v88 >= 32) {\n                    MEM[v86] = MEM[v90];\n                    v86 = v86 + 32;\n                    v90 = v90 + 32;\n                    v88 = v88 - 32;\n                }\n                MEM[v86] = MEM[v90] & ~(256 ** (32 - v88) - 1) | MEM[v86] & 256 ** (32 - v88) - 1;\n                v92, v93 = sha256hash(v85.data, 0);\n                require(v92);\n                v94 = new struct(1);\n                v94.word0 = 0;\n                v95 = new struct(1);\n                v95.word0 = 0;\n                v96 = MEM[64];\n                if (MSIZE() >= v96) {\n                    v96 = v97 = new bytes[](32);\n                }\n                v96 = new bytes[](32);\n                assert(3 < v27.length);\n                v98 = new struct(1);\n                v98.word0 = 0;\n                require(v96.length >= 32);\n                v99 = 36 + ((v27[3] >> 248 << 248 >> 248) - 32);\n                v100 = 32;\n                while (v99 < 36 + ((v27[3] >> 248 << 248 >> 248) - 32) + 32) {\n                    MEM[v96 + v100] = MEM[v27 + v99];\n                    v99 = v99 + 32;\n                    v100 = v100 + 32;\n                }\n                v101 = MEM[64];\n                if (MSIZE() >= v101) {\n                    v101 = v102 = new bytes[](32);\n                }\n                v101 = new bytes[](32);\n                assert(4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1 < v27.length);\n                v103 = new struct(1);\n                v103.word0 = 0;\n                require(v101.length >= 32);\n                v104 = 32 + (4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 + ((v27[4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1] >> 248 << 248 >> 248) - 32));\n                v105 = 32;\n                while (v104 < 32 + (4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 + ((v27[4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1] >> 248 << 248 >> 248) - 32)) + 32) {\n                    MEM[v101 + v105] = MEM[v27 + v104];\n                    v104 = v104 + 32;\n                    v105 = v105 + 32;\n                }\n                v106, v107 = ecrecover(v93, 27, MEM[v97.data], MEM[v102.data]);\n                v108 = v108.data;\n                v109 = v53.length;\n                v110 = v53.data;\n                while (v109 >= 32) {\n                    MEM[v108] = MEM[v110];\n                    v108 = v108 + 32;\n                    v110 = v110 + 32;\n                    v109 = v109 - 32;\n                }\n                MEM[v108] = MEM[v110] & ~(256 ** (32 - v109) - 1) | MEM[v108] & 256 ** (32 - v109) - 1;\n                if (address(keccak256(v108)) != address(v107)) {\n                    v111, v112 = ecrecover(v93, 28, MEM[v97.data], MEM[v102.data]);\n                    v113 = v113.data;\n                    v114 = v53.length;\n                    v115 = v53.data;\n                    while (v114 >= 32) {\n                        MEM[v113] = MEM[v115];\n                        v113 = v113 + 32;\n                        v115 = v115 + 32;\n                        v114 = v114 - 32;\n                    }\n                    MEM[v113] = MEM[v115] & ~(256 ** (32 - v114) - 1) | MEM[v113] & 256 ** (32 - v114) - 1;\n                    v116 = address(keccak256(v113)) == address(v112);\n                } else {\n                    v116 = v117 = 1;\n                }\n                return v116, v79, v67, v5 + 32 + 41 + v27.length + 65, v53, v47, v27, v6, v5, 0, varg0;\n            }\n        } else {\n            v76 = v118 = 0;\n        }\n    } else {\n        v76 = v119 = 0;\n    }\n    return v76;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x9af(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction __callback(bytes32 varg0, string varg1) public nonPayable { \n    v0 = v1 = ~0x0 & varg0;\n    v0 = v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new bytes[](0);\n    }\n    v3 = new bytes[](0);\n    v6 = v7 = ___callback == 0;\n    if (___callback != 0) {\n        v6 = ___callback.code.size == 0;\n    }\n    if (v6) {\n        v8 = 0x251b(0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(___callback.code.size);\n    v9, v10 = ___callback.getAddress().gas(msg.gas - 710);\n    require(v9);\n    if (owner_1_0_19 != address(MEM[MEM[0x40]])) {\n        MEM[32 + MEM[64]] = 0;\n        require(___callback.code.size);\n        v11, v12 = ___callback.getAddress().gas(msg.gas - 710);\n        require(v11);\n        owner_1_0_19 = MEM[MEM[64]];\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(owner_1_0_19.code.size);\n    v13, v14 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    require(v13);\n    require(msg.sender == address(MEM[MEM[0x40]]));\n    v15 = 0x1b2b(v3, v2);\n    if (0xff & v15 != 3465) {\n        if (stor_f > 2) {\n            emit LedgerFailed('Stopping');\n        } else {\n            emit LedgerFailed('Requesting new');\n            require(stor_f + 1 >= stor_f);\n            stor_f = stor_f + 1;\n            0x17b6();\n        }\n    } else {\n        v16 = v16.data;\n        v17 = v3.length;\n        v18 = v5.data;\n        while (v17 >= 32) {\n            MEM[v16] = MEM[v18];\n            v16 = v16 + 32;\n            v18 = v18 + 32;\n            v17 = v17 - 32;\n        }\n        MEM[v16] = MEM[v18] & ~(256 ** (32 - v17) - 1) | MEM[v16] & 256 ** (32 - v17) - 1;\n        0xe0e(keccak256(v16), 0xf4240, 1);\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction receiveFromGame() public payable { \n    emit EthReceived(msg.sender, msg.value);\n}\n\nfunction __callback(bytes32 varg0, string varg1, bytes varg2) public nonPayable { \n    v0 = v1 = ~0x0 & varg0;\n    v0 = v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    v3 = new bytes[](varg2.length);\n    CALLDATACOPY(v3.data, 36 + varg2, varg2.length);\n    v4 = v5 = ___callback == 0;\n    if (___callback != 0) {\n        v4 = ___callback.code.size == 0;\n    }\n    if (v4) {\n        v6 = 0x251b(0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(___callback.code.size);\n    v7, v8 = ___callback.getAddress().gas(msg.gas - 710);\n    require(v7);\n    if (owner_1_0_19 != address(MEM[MEM[0x40]])) {\n        MEM[32 + MEM[64]] = 0;\n        require(___callback.code.size);\n        v9, v10 = ___callback.getAddress().gas(msg.gas - 710);\n        require(v9);\n        owner_1_0_19 = MEM[MEM[64]];\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(owner_1_0_19.code.size);\n    v11, v12 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    require(v11);\n    require(msg.sender == address(MEM[MEM[0x40]]));\n    v13 = 0x1b2b(v3, v2);\n    if (0xff & v13 != 3465) {\n        if (stor_f > 2) {\n            emit LedgerFailed('Stopping');\n        } else {\n            emit LedgerFailed('Requesting new');\n            require(stor_f + 1 >= stor_f);\n            stor_f = stor_f + 1;\n            0x17b6();\n        }\n    } else {\n        v14 = v14.data;\n        v15 = v3.length;\n        v16 = v3.data;\n        while (v15 >= 32) {\n            MEM[v14] = MEM[v16];\n            v14 = v14 + 32;\n            v16 = v16 + 32;\n            v15 = v15 - 32;\n        }\n        MEM[v14] = MEM[v16] & ~(256 ** (32 - v15) - 1) | MEM[v14] & 256 ** (32 - v15) - 1;\n        0xe0e(keccak256(v14), 0xf4240, 1);\n    }\n}\n\nfunction addGame(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _awardToken[varg0] = 0x1 | ~0xff & _awardToken[varg0];\n    owner_e[varg0] = varg1;\n    _allowance[varg0] = stor_5;\n    emit Approval(msg.sender, varg0, stor_5);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _totalSupply[varg0];\n}\n\nfunction 0x47f2(uint256 varg0) private { \n    v0 = v1 = varg0.data;\n    if (31 < varg0.word0) {\n        array_2.length = 1 + (varg0.word0 + varg0.word0);\n        if (varg0.word0) {\n            while (v1 + varg0.word0 > v0) {\n                STORAGE[v2] = MEM[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        array_2.length = varg0.word0 + varg0.word0 | ~0xff & varg0.word1;\n    }\n    while (v3 + (31 + array_2.length >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x4850(uint256 varg0) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(2);\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v1.word0 = v2;\n    v1.word1 = 0;\n    MEM[(MEM[64]) len (MSIZE() - MEM[64])] = this.code[this.code.size len (MSIZE() - MEM[64])];\n    v3 = v4 = 1024;\n    if (0 != 0) {\n        v3 = 1056;\n    }\n    v1.word1 = v3;\n    v1.word0 = MEM[64];\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + v3;\n    0x4978(4, v1);\n    if (0 >= varg0.length) {\n        0x4978(7, v1);\n        return v1.word0;\n    } else {\n        assert(0 < varg0.length);\n        0x499c(MEM[varg0[0]], 2, v1);\n        v5 = 0x4af5(varg0[0], v1);\n        return 0, v1, v0, varg0;\n    }\n}\n\nfunction 0x4978(uint256 varg0, uint256 varg1) private { \n    0x4ba1((0xff & varg0) << 5 | 0x1f, varg1);\n    return ;\n}\n\nfunction 0x499c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 > 23) {\n        if (varg0 > 255) {\n            if (varg0 > 0xffff) {\n                if (varg0 > 0xffffffff) {\n                    if (varg0 <= 0xffffffffffffffff) {\n                        0x4ba1((0xff & varg1) << 5 | 0x1b, varg2);\n                        v0 = 0x4be1(8, varg0, varg2);\n                    }\n                } else {\n                    0x4ba1((0xff & varg1) << 5 | 0x1a, varg2);\n                    v1 = 0x4be1(4, varg0, varg2);\n                }\n            } else {\n                0x4ba1((0xff & varg1) << 5 | 0x19, varg2);\n                v2 = 0x4be1(2, varg0, varg2);\n            }\n        } else {\n            0x4ba1((0xff & varg1) << 5 | 0x18, varg2);\n            v3 = 0x4be1(1, varg0, varg2);\n        }\n    } else {\n        0x4ba1(0xff & (0xff & varg1) << 5 | varg0, varg2);\n    }\n    return ;\n}\n\nfunction 0x4af5(uint256 varg0, uint256 varg1) private { \n    v0 = new struct(2);\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v0.word0 = v1;\n    v0.word1 = 0;\n    if (MEM[varg0] + MEM[varg1.word0] > varg1.word1) {\n        v2 = 0x4c48(MEM[varg0], varg1.word1);\n        0x4c64(v2 << 1, varg1);\n    }\n    v3 = v4 = MEM[varg0];\n    v5 = v6 = varg1.word0 + MEM[varg1.word0] + 32;\n    MEM[varg1.word0] = MEM[varg1.word0] + MEM[varg0];\n    v7 = v8 = varg0 + 32;\n    while (v3 >= 32) {\n        MEM[v5] = MEM[v7];\n        v5 = v5 + 32;\n        v7 = v7 + 32;\n        v3 = v3 - 32;\n    }\n    MEM[v5] = MEM[v5] & 256 ** (32 - v3) - 1 | MEM[v7] & ~(256 ** (32 - v3) - 1);\n    return varg1;\n}\n\nfunction 0x4ba1(uint256 varg0, uint256 varg1) private { \n    if (MEM[MEM[0 + varg1]] + 1 > MEM[32 + varg1]) {\n        0x4c64(MEM[32 + varg1] << 1, varg1);\n    }\n    v0 = MEM[varg1];\n    MEM8[v0 + MEM[v0] + 32] = varg0 & 0xFF;\n    MEM[v0] = MEM[v0] + 1;\n    return ;\n}\n\nfunction 0x4be1(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = new struct(2);\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v0.word0 = v1;\n    v0.word1 = 0;\n    if (varg0 + MEM[MEM[0 + varg2]] > MEM[32 + varg2]) {\n        v2 = 0x4c48(varg0, MEM[32 + varg2]);\n        0x4c64(v2 << 1, varg2);\n    }\n    v3 = MEM[varg2];\n    v4 = v3 + MEM[v3] + varg0;\n    MEM[v4] = MEM[v4] & ~(256 ** varg0 - 1) | varg1;\n    MEM[v3] = MEM[v3] + varg0;\n    return varg2;\n}\n\nfunction 0x4c48(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n    }\n    return varg0;\n}\n\nfunction 0x4c64(uint256 varg0, uint256 varg1) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    if (varg0 % 32 != 0) {\n        varg0 = v1 = varg0 + (32 - varg0 % 32);\n    }\n    MEM[32 + varg1] = varg0;\n    MEM[varg1] = MEM[64];\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + varg0;\n    v2 = 0x4af5(MEM[0 + varg1], varg1);\n    return ;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x424e530000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1114(varg1, varg0);\n    return v0;\n}\n\nfunction forceRoll() public nonPayable { \n    require(msg.sender == _owner);\n    stor_f = 0;\n    0x17b6();\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction takeAll() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction awardToken(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _awardToken[msg.sender]);\n    v0 = v1 = 1;\n    if ((address(this)).balance >= 0xde0b6b3a7640000) {\n        if ((address(this)).balance >= 0x1bc16d674ec80000) {\n            if ((address(this)).balance >= 0x3782dace9d900000) {\n                if ((address(this)).balance >= 0x6f05b59d3b200000) {\n                    if ((address(this)).balance >= 0xde0b6b3a76400000) {\n                        if ((address(this)).balance >= 0x1bc16d674ec800000) {\n                            if ((address(this)).balance >= 0x3782dace9d9000000) {\n                                if ((address(this)).balance >= 0x6f05b59d3b2000000) {\n                                    if ((address(this)).balance >= 0xde0b6b3a764000000) {\n                                        if ((address(this)).balance < 0x1bc16d674ec8000000) {\n                                            v0 = v2 = 2;\n                                        }\n                                    } else {\n                                        v0 = v3 = 4;\n                                    }\n                                } else {\n                                    v0 = v4 = 6;\n                                }\n                            } else {\n                                v0 = v5 = 8;\n                            }\n                        } else {\n                            v0 = v6 = 10;\n                        }\n                    } else {\n                        v0 = v7 = 15;\n                    }\n                } else {\n                    v0 = v8 = 20;\n                }\n            } else {\n                v0 = v9 = 30;\n            }\n        } else {\n            v0 = v10 = 40;\n        }\n    } else {\n        v0 = v11 = 50;\n    }\n    require(0xff & _awardToken[msg.sender]);\n    v12 = 0x9af(owner_e[msg.sender] * varg1 * 0xe8d4a51000 * v0, varg0, _owner);\n}\n\nfunction 0x9af(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(varg0 <= _totalSupply[v0]);\n    v1 = address(varg2);\n    _totalSupply[v1] = _totalSupply[v0] - varg0;\n    v2 = address(varg2);\n    require(varg0 <= _totalSupply[msg.sender]);\n    v3 = address(varg2);\n    _allowance[msg.sender] = _totalSupply[msg.sender] - varg0;\n    v4 = address(varg1);\n    v5 = _totalSupply[v4] + varg0;\n    require(v5 >= _totalSupply[v4]);\n    v6 = address(varg1);\n    _totalSupply[v6] = v5;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction 0xe0e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 % varg1 + varg2;\n    map_9[stor_c] = ~0xffffffffffffffffffffffffffffffffffffffff & map_9[stor_c];\n    v1 = v2 = map_a[stor_c] == 0;\n    if (map_a[stor_c] != 0) {\n        assert(map_a[stor_c]);\n        v1 = map_a[stor_c] * 10 / map_a[stor_c] == 10;\n    }\n    require(v1);\n    map_a[stor_c] = 0;\n    stor_c = stor_c + 1;\n    emit GotRandom(v0);\n    if (v0 <= map_a[stor_c] * 10) {\n        emit Winner(address(this), address(map_9[stor_c]), (address(this)).balance, v0, 0);\n        require(2 > 0);\n        assert(2);\n        v3 = address(map_9[stor_c]).call().value((address(this)).balance >> 1).gas(!((address(this)).balance >> 1) * 2300);\n        require(v3);\n    }\n    return ;\n}\n\nfunction () public payable { \n    v0 = msg.sender.call().value(msg.value).gas(!msg.value * 2300);\n    require(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x95ea7b3 == uint32(function_selector >> 224)) {\n            approve(address,uint256);\n        } else if (0x18160ddd == uint32(function_selector >> 224)) {\n            totalSupply();\n        } else if (0x1f7b4f30 == uint32(function_selector >> 224)) {\n            roll(uint256);\n        } else if (0x23b872dd == uint32(function_selector >> 224)) {\n            transferFrom(address,address,uint256);\n        } else if (0x27dc297e == uint32(function_selector >> 224)) {\n            __callback(bytes32,string);\n        } else if (0x313ce567 == uint32(function_selector >> 224)) {\n            decimals();\n        } else if (0x386304e4 == uint32(function_selector >> 224)) {\n            receiveFromGame();\n        } else if (0x38bbfa50 == uint32(function_selector >> 224)) {\n            __callback(bytes32,string,bytes);\n        } else if (0x5dce431b == uint32(function_selector >> 224)) {\n            addGame(address,uint256);\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0x95d89b41 == uint32(function_selector >> 224)) {\n            symbol();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xcbc9023c == uint32(function_selector >> 224)) {\n            forceRoll();\n        } else if (0xdd62ed3e == uint32(function_selector >> 224)) {\n            allowance(address,address);\n        } else if (0xde3bcb97 == uint32(function_selector >> 224)) {\n            takeAll();\n        } else if (0xded2d0f4 == uint32(function_selector >> 224)) {\n            awardToken(address,uint256);\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.28 03:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) map_3; // STORAGE[0x3]\nuint256 stor_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) map_a; // STORAGE[0xa]\nuint256 _roll; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _awardToken; // STORAGE[0xd]\nmapping (uint256 => [uint256]) owner_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 ___callback; // STORAGE[0x0] bytes 0 to 19\nuint256 owner_1_0_19; // STORAGE[0x1] bytes 0 to 19\nuint256 _owner; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nEthReceived(address, uint256);\nLedgerFailed(string);\nGotRandom(uint256);\nWinner(address, address, uint256, uint256, uint256);\n\nfunction 0x1114(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0);\n    require(varg0 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg0;\n    v0 = address(varg1);\n    v1 = _totalSupply[v0] + varg0;\n    require(v1 >= _totalSupply[v0]);\n    v2 = address(varg1);\n    _totalSupply[v2] = v1;\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return 1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (11) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffff & 'Bonus Token';\n    }\n    return v0;\n}\n\nfunction 0x17b6() private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = new struct(4);\n    v7 = v8 = 4;\n    while (1) {\n        v9 = new struct(1);\n        v9.word0 = 0;\n        MEM[v5] = v9;\n        v5 += 32;\n        v7 = v7 - 1;\n        if (v7) {\n            break;\n        }\n        if (!v7) {\n            v10 = new struct(1);\n            v10.word0 = 0;\n            v11 = v12 = 7 > 0;\n            if (v12) {\n                v11 = 7 <= 32;\n            }\n            require(v11);\n            v13 = v14 = MEM[64];\n            if (MSIZE() >= v14) {\n                v13 = new uint256[](1);\n            }\n            v13 = new uint256[](1);\n            assert(0 < v13.length);\n            v15 = v13.data;\n            MEM8[v13.data] = (byte(0x700000000000000000000000000000000000000000000000000000000000000, 0x0)) & 0xFF;\n            v16 = v17 = MEM[64];\n            if (MSIZE() >= v17) {\n                v16 = new bytes[](32);\n            }\n            v16 = new bytes[](32);\n            v18 = v19 = MEM[64];\n            if (MSIZE() >= v19) {\n                v18 = new bytes[](32);\n            }\n            v18 = new bytes[](32);\n            v20 = v21 = ___callback == 0;\n            if (___callback != 0) {\n                v20 = ___callback.code.size == 0;\n            }\n            if (v20) {\n                v22 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v23, v24 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v23);\n            if (owner_1_0_19 != address(v24)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v25, v26 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v25);\n                owner_1_0_19 = v26;\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(owner_1_0_19.code.size);\n            v27, v28 = owner_1_0_19.randomDS_getSessionPubKeyHash().gas(msg.gas - 710);\n            require(v27);\n            MEM[v16.data] = block.blockhash(block.number - 1) ^ (block.coinbase ^ block.timestamp);\n            MEM[v18.data] = v28;\n            v29 = v30 = MEM[64];\n            if (MSIZE() >= v30) {\n                v29 = 0;\n            }\n            if (MSIZE() >= MEM[64]) {\n                v31 = new array[](8);\n            }\n            v31 = new array[](8);\n            v32 = new struct(1);\n            v32.word0 = 0;\n            require(v31.length >= 8);\n            v33 = 56;\n            v34 = 32;\n            while (v33 < 64) {\n                MEM[v31 + v34] = MEM[v29 + v33];\n                v33 = v33 + 32;\n                v34 = v34 + 32;\n            }\n            v35 = v36 = ___callback == 0;\n            if (___callback != 0) {\n                v35 = ___callback.code.size == 0;\n            }\n            if (v35) {\n                v37 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v38, v39 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v38);\n            if (owner_1_0_19 != address(v39)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v40, v41 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v40);\n                owner_1_0_19 = v41;\n            }\n            v42 = v43 = 4;\n            v44 = v45 = MEM[64];\n            if (MSIZE() >= v45) {\n                v44 = v46 = new uint256[](v43);\n            }\n            v44 = new uint256[](v43);\n            if (v43) {\n                v47 = v46.data;\n                do {\n                    v48 = new struct(1);\n                    v48.word0 = 0;\n                    MEM[v47] = v48;\n                    v47 += 32;\n                    v42 = v42 - 1;\n                } while (!v42);\n            }\n            assert(0 < v44.length);\n            v49 = v46.data;\n            v50 = v46.data;\n            v46[0] = v16;\n            assert(1 < v44.length);\n            v46[32] = v13;\n            assert(2 < v44.length);\n            v46[64] = v18;\n            assert(3 < v44.length);\n            v46[96] = v29;\n            v51 = new struct(1);\n            v51.word0 = 0;\n            v52 = v53 = ___callback == 0;\n            if (___callback != 0) {\n                v52 = ___callback.code.size == 0;\n            }\n            if (v52) {\n                v54 = 0x251b(0);\n            }\n            MEM[32 + MEM[64]] = 0;\n            require(___callback.code.size);\n            v55, v56 = ___callback.getAddress().gas(msg.gas - 710);\n            require(v55);\n            if (owner_1_0_19 != address(v56)) {\n                MEM[32 + MEM[64]] = 0;\n                require(___callback.code.size);\n                v57, v58 = ___callback.getAddress().gas(msg.gas - 710);\n                require(v57);\n                owner_1_0_19 = v58;\n            }\n            MEM[32 + MEM[64]] = 0;\n            v59 = new array[](v60.length);\n            v61 = v62 = 0;\n            while (v61 < v60.length) {\n                v59[v61] = v60[v61];\n                v61 = v61 + 32;\n            }\n            if (6) {\n                MEM[v59.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'random';\n            }\n            require(owner_1_0_19.code.size);\n            v63, v64 = owner_1_0_19.getPrice(v59, 0x3d090).gas(msg.gas - 710);\n            require(v63);\n            if (v64 <= 0xde0b6b3a7640000 + msg.gas * 0x3d090) {\n                v65, v66, v67, v68 = 0x4850(v44);\n                MEM[32 + MEM[64]] = 0;\n                v69 = new array[](MEM[0]);\n                v70 = v71 = 0;\n                while (v70 < MEM[0]) {\n                    v69[v70] = MEM[32 + v70];\n                    v70 = v70 + 32;\n                }\n                if (0x1f & MEM[0]) {\n                    MEM[MEM[0] + v69.data - (0x1f & MEM[0])] = ~(256 ** (32 - (0x1f & MEM[0])) - 1) & MEM[MEM[0] + v69.data - (0x1f & MEM[0])];\n                }\n                v72 = new array[](MEM[v65]);\n                v73 = v74 = 0;\n                while (v73 < MEM[v65]) {\n                    MEM[v72.data + v73] = MEM[32 + v65 + v73];\n                    v73 = v73 + 32;\n                }\n                v75 = v76 = MEM[v65] + v72.data;\n                if (0x1f & MEM[v65]) {\n                    MEM[v76 - (0x1f & MEM[v65])] = ~(256 ** (32 - (0x1f & MEM[v65])) - 1) & MEM[v76 - (0x1f & MEM[v65])];\n                }\n                require(owner_1_0_19.code.size);\n                v77, v78 = owner_1_0_19.queryN_withGasLimit(0, v69, v72, v51).value(v67).gas(msg.gas - 9710);\n                require(v77);\n            } else {\n                v78 = v79 = 0;\n            }\n            v80 = v81 = MEM[64];\n            if (MSIZE() >= v81) {\n                v80 = new array[](8);\n            }\n            v80 = new array[](8);\n            MEM8[v80 + 39] = v13 >> 248 & 0xFF;\n            MEM8[v80 + 38] = v13 >> 240 & 0xFF;\n            MEM8[v80 + 37] = v13 >> 232 & 0xFF;\n            MEM8[v80 + 36] = v13 >> 224 & 0xFF;\n            MEM8[v80 + 35] = v13 >> 216 & 0xFF;\n            MEM8[v80 + 34] = v13 >> 208 & 0xFF;\n            MEM8[v80 + 33] = v13 >> 200 & 0xFF;\n            MEM8[v80.data] = v13 >> 192 & 0xFF;\n            v82 = v83 = MEM[64];\n            v84 = v85 = MEM[MEM[0]];\n            v86 = v87 = 32 + MEM[0];\n            while (v84 >= 32) {\n                MEM[v82] = MEM[v86];\n                v82 = v82 + 32;\n                v86 = v86 + 32;\n                v84 = v84 - 32;\n            }\n            MEM[v82] = MEM[v86] & ~(256 ** (32 - v84) - 1) | MEM[v82] & 256 ** (32 - v84) - 1;\n            v88, v89 = sha256hash(v90, 0);\n            require(v88);\n            v91 = v92 = v93.data;\n            v94 = v95 = v80.length;\n            v96 = v97 = v80.data;\n            while (v94 >= 32) {\n                MEM[v91] = MEM[v96];\n                v91 = v91 + 32;\n                v96 = v96 + 32;\n                v94 = v94 - 32;\n            }\n            MEM[v91] = MEM[v96] & ~(256 ** (32 - v94) - 1) | MEM[v91] & 256 ** (32 - v94) - 1;\n            v98 = v99 = v95 + v92;\n            v100 = v101 = MEM[MEM[32]];\n            v102 = v103 = 32 + MEM[32];\n            while (v100 >= 32) {\n                MEM[v98] = MEM[v102];\n                v98 = v98 + 32;\n                v102 = v102 + 32;\n                v100 = v100 - 32;\n            }\n            MEM[v98] = MEM[v102] & ~(256 ** (32 - v100) - 1) | MEM[v98] & 256 ** (32 - v100) - 1;\n            MEM[v101 + v99] = ~0x0 & (~0x0 & MEM[v93.data]);\n            v104 = v105 = 32 + (v101 + v99);\n            v106 = v107 = 32 + v93.data;\n            while (v89 >= 32) {\n                MEM[v104] = MEM[v106];\n                v104 = v104 + 32;\n                v106 = v106 + 32;\n                v89 = v89 - 32;\n            }\n            MEM[v104] = MEM[v106] & ~(256 ** (32 - v89) - 1) | MEM[v104] & 256 ** (32 - v89) - 1;\n            map_3[~0x0 & (~0x0 & v78)] = ~0x0 & keccak256(v93.data);\n            return ;\n        }\n    }\n}\n\nfunction 0x1b2b(uint256 varg0, uint256 varg1) private { \n    assert(0 < varg0.length);\n    v0 = v1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248 != 0x4c00000000000000000000000000000000000000000000000000000000000000;\n    if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248 == 0x4c00000000000000000000000000000000000000000000000000000000000000) {\n        assert(1 < varg0.length);\n        v0 = v2 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248 != 0x5000000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        assert(2 < varg0.length);\n        v0 = v3 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[2] >> 248 << 248 != 0x100000000000000000000000000000000000000000000000000000000000000;\n    }\n    if (!v0) {\n        MEM[MEM[64]] = 0;\n        v4 = new bytes[](array_2.length);\n        v5 = v6 = v4.data;\n        if (array_2.length) {\n            if (31 < array_2.length) {\n                do {\n                    MEM[v5] = STORAGE[v7];\n                    v7 += 1;\n                    v5 += 32;\n                } while (v6 + array_2.length <= v5);\n            } else {\n                MEM[v6] = array_2.length >> 8 << 8;\n            }\n        }\n        v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 = 0x25d4(v4, varg1, v22, varg0);\n        if (v8 != 0) {\n            v23 = v24 = 0;\n        } else {\n            v23 = v25 = 2;\n        }\n    } else {\n        v23 = v26 = 1;\n    }\n    return v23;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return stor_5 - _totalSupply[0];\n}\n\nfunction roll(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 == 10;\n    if (v1) {\n        v0 = v2 = (address(this)).balance >= 0xde0b6b3a764000000;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 100;\n        if (v3) {\n            v0 = v4 = (address(this)).balance >= 0x3782dace9d900000;\n        }\n    }\n    if (!v0) {\n        v0 = varg0 == 1000;\n    }\n    require(v0);\n    require(_totalSupply[msg.sender] >= varg0 * 0xde0b6b3a7640000);\n    map_9[_roll] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & map_9[_roll];\n    map_a[_roll] = varg0;\n    _roll = _roll + 1;\n    v5 = 0x1114(varg0 * 0xde0b6b3a7640000, _owner);\n    0x17b6();\n}\n\nfunction 0x251b(uint256 varg0) private { \n    if (0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed.code.size <= 0) {\n        if (0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1.code.size <= 0) {\n            if (0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e.code.size <= 0) {\n                if (0x146500cfd35b22e4a392fe0adc06de1a1368ed48.code.size <= 0) {\n                    if (0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475.code.size <= 0) {\n                        if (0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf.code.size <= 0) {\n                            if (0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa.code.size <= 0) {\n                                v0 = 0;\n                            } else {\n                                ___callback = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa;\n                                v0 = v1 = 1;\n                            }\n                        } else {\n                            ___callback = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf;\n                            v0 = v2 = 1;\n                        }\n                    } else {\n                        ___callback = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475;\n                        v0 = v3 = 1;\n                    }\n                } else {\n                    ___callback = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48;\n                    v4.word0 = 11;\n                    v5 = v4.data;\n                    v4.word1 = 'eth_rinkeby';\n                    0x47f2('eth_rinkeby');\n                    v0 = v6 = 1;\n                }\n            } else {\n                ___callback = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e;\n                v7.word0 = 9;\n                v8 = v7.data;\n                v7.word1 = 'eth_kovan';\n                0x47f2('eth_kovan');\n                v0 = v9 = 1;\n            }\n        } else {\n            ___callback = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1;\n            v10.word0 = 12;\n            v11 = v10.data;\n            v10.word1 = 'eth_ropsten3';\n            0x47f2('eth_ropsten3');\n            v0 = v12 = 1;\n        }\n    } else {\n        ___callback = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed;\n        v13.word0 = 11;\n        v14 = v13.data;\n        v13.word1 = 'eth_mainnet';\n        0x47f2('eth_mainnet');\n        v0 = v15 = 1;\n    }\n    return v0;\n}\n\nfunction 0x25d4(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    assert(69 < varg3.length);\n    v5 = 68 + ((varg3[69] >> 248 << 248 >> 248) + 2) + 32;\n    v6 = v7 = MEM[64];\n    if (MSIZE() >= v7) {\n        v6 = v8 = new bytes[](32);\n    }\n    v6 = new bytes[](32);\n    v9 = new struct(1);\n    v9.word0 = 0;\n    require(v6.length >= 32);\n    v10 = 32 + v5;\n    v11 = 32;\n    while (v10 < 32 + v5 + 32) {\n        MEM[v6 + v11] = MEM[varg3 + v10];\n        v10 = v10 + 32;\n        v11 = v11 + 32;\n    }\n    MEM[32 + v12.data] = 0;\n    v13 = v14 = v12.data;\n    v15 = v16 = varg0.length;\n    v17 = v18 = varg0.data;\n    while (v15 >= 32) {\n        MEM[v13] = MEM[v17];\n        v13 = v13 + 32;\n        v17 = v17 + 32;\n        v15 = v15 - 32;\n    }\n    MEM[v13] = MEM[v17] & ~(256 ** (32 - v15) - 1) | MEM[v13] & 256 ** (32 - v15) - 1;\n    MEM[v16 + v14] = ~0x0 & (~0x0 & varg2);\n    v19, v20 = sha256hash(v12.data, 0);\n    require(v19);\n    v21 = v22 = v22.data;\n    v23 = v24 = v6.length;\n    v25 = v26 = v6.data;\n    while (v23 >= 32) {\n        MEM[v21] = MEM[v25];\n        v21 = v21 + 32;\n        v25 = v25 + 32;\n        v23 = v23 - 32;\n    }\n    MEM[v21] = MEM[v25] & ~(256 ** (32 - v23) - 1) | MEM[v21] & 256 ** (32 - v23) - 1;\n    if (~0x0 & keccak256(v22) == ~0x0 & keccak256(~0x0 & (~0x0 & v20))) {\n        assert(v5 + 73 + 1 < varg3.length);\n        v27 = v28 = MEM[64];\n        if (MSIZE() >= v28) {\n            v27 = v29 = new bytes[]((varg3[v5 + 73 + 1] >> 248 << 248 >> 248) + 2);\n        }\n        v27 = new bytes[]((varg3[v5 + 73 + 1] >> 248 << 248 >> 248) + 2);\n        v30 = new struct(1);\n        v30.word0 = 0;\n        require(v27.length >= v27.length + 0);\n        v31 = 32 + (v5 + 73);\n        v32 = 32;\n        while (v31 < 32 + (v5 + 73) + v27.length) {\n            MEM[v27 + v32] = MEM[varg3 + v31];\n            v31 = v31 + 32;\n            v32 = v32 + 32;\n        }\n        MEM[32 + v33.data] = 0;\n        v34 = v35 = v33.data;\n        v36 = v37 = v27.length;\n        v38 = v39 = v27.data;\n        while (v36 >= 32) {\n            MEM[v34] = MEM[v38];\n            v34 = v34 + 32;\n            v38 = v38 + 32;\n            v36 = v36 - 32;\n        }\n        MEM[v34] = MEM[v38] & ~(256 ** (32 - v36) - 1) | MEM[v34] & 256 ** (32 - v36) - 1;\n        v40, v41 = sha256hash(v33.data, 0);\n        require(v40);\n        assert(v5 + 32 + 8 < varg3.length);\n        v42 = v43 = 1;\n        require(varg1.length == varg3[v5 + 32 + 8] >> 248 << 248 >> 248);\n        v44 = v45 = 0;\n        while (v44 < varg3[v5 + 32 + 8] >> 248 << 248 >> 248) {\n            assert(v44 < varg1.length);\n            assert(v44 < 32);\n            if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (byte(v41, v44)) << 248 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1[v44] >> 248 << 248) {\n                v42 = v46 = 0;\n            }\n            v44 += 1;\n        }\n        if (v42) {\n            v47 = v48 = MEM[64];\n            if (MSIZE() >= v48) {\n                v47 = v49 = new bytes[](41);\n            }\n            v47 = new bytes[](41);\n            v50 = new struct(1);\n            v50.word0 = 0;\n            require(v47.length >= 41);\n            v51 = 32 + (v5 + 32);\n            v52 = 32;\n            while (v51 < 32 + (v5 + 32) + 41) {\n                MEM[v47 + v52] = MEM[varg3 + v51];\n                v51 = v51 + 32;\n                v52 = v52 + 32;\n            }\n            v53 = v54 = MEM[64];\n            if (MSIZE() >= v54) {\n                v53 = v55 = new bytes[](64);\n            }\n            v53 = new bytes[](64);\n            v56 = new struct(1);\n            v56.word0 = 0;\n            require(v53.length >= 64);\n            v57 = 32 + (v5 + 32 + 41 + v27.length + 65 - 64);\n            v58 = 32;\n            while (v57 < 32 + (v5 + 32 + 41 + v27.length + 65 - 64) + 64) {\n                MEM[v53 + v58] = MEM[varg3 + v57];\n                v57 = v57 + 32;\n                v58 = v58 + 32;\n            }\n            MEM[32 + v59.data] = 0;\n            v60 = v61 = v59.data;\n            v62 = v63 = v53.length;\n            v64 = v65 = v53.data;\n            while (v62 >= 32) {\n                MEM[v60] = MEM[v64];\n                v60 = v60 + 32;\n                v64 = v64 + 32;\n                v62 = v62 - 32;\n            }\n            MEM[v60] = MEM[v64] & ~(256 ** (32 - v62) - 1) | MEM[v60] & 256 ** (32 - v62) - 1;\n            v66, v67 = sha256hash(v59.data, 0);\n            require(v66);\n            v68 = v69 = v70.data;\n            v71 = v72 = v47.length;\n            v73 = v74 = v47.data;\n            while (v71 >= 32) {\n                MEM[v68] = MEM[v73];\n                v68 = v68 + 32;\n                v73 = v73 + 32;\n                v71 = v71 - 32;\n            }\n            MEM[v68] = MEM[v73] & ~(256 ** (32 - v71) - 1) | MEM[v68] & 256 ** (32 - v71) - 1;\n            MEM[v72 + v69] = ~0x0 & (~0x0 & v67);\n            v75 = ~0x0 & (~0x0 & varg2);\n            if (~0x0 & map_3[v75] != ~0x0 & keccak256(v70.data)) {\n                v76 = v77 = 0;\n            } else {\n                v78 = ~0x0 & (~0x0 & varg2);\n                map_3[v78] = 0;\n                v79 = v80 = MEM[64];\n                if (MSIZE() >= v80) {\n                    v79 = v81 = new bytes[](73);\n                }\n                v79 = new bytes[](73);\n                v82 = new struct(1);\n                v82.word0 = 0;\n                require(v79.length >= 73);\n                v83 = 32 + v5;\n                v84 = 32;\n                while (v83 < 32 + v5 + 73) {\n                    MEM[v79 + v84] = MEM[varg3 + v83];\n                    v83 = v83 + 32;\n                    v84 = v84 + 32;\n                }\n                MEM[32 + v85.data] = 0;\n                v86 = v87 = v85.data;\n                v88 = v89 = v79.length;\n                v90 = v91 = v79.data;\n                while (v88 >= 32) {\n                    MEM[v86] = MEM[v90];\n                    v86 = v86 + 32;\n                    v90 = v90 + 32;\n                    v88 = v88 - 32;\n                }\n                MEM[v86] = MEM[v90] & ~(256 ** (32 - v88) - 1) | MEM[v86] & 256 ** (32 - v88) - 1;\n                v92, v93 = sha256hash(v85.data, 0);\n                require(v92);\n                v94 = new struct(1);\n                v94.word0 = 0;\n                v95 = new struct(1);\n                v95.word0 = 0;\n                v96 = MEM[64];\n                if (MSIZE() >= v96) {\n                    v96 = v97 = new bytes[](32);\n                }\n                v96 = new bytes[](32);\n                assert(3 < v27.length);\n                v98 = new struct(1);\n                v98.word0 = 0;\n                require(v96.length >= 32);\n                v99 = 36 + ((v27[3] >> 248 << 248 >> 248) - 32);\n                v100 = 32;\n                while (v99 < 36 + ((v27[3] >> 248 << 248 >> 248) - 32) + 32) {\n                    MEM[v96 + v100] = MEM[v27 + v99];\n                    v99 = v99 + 32;\n                    v100 = v100 + 32;\n                }\n                v101 = MEM[64];\n                if (MSIZE() >= v101) {\n                    v101 = v102 = new bytes[](32);\n                }\n                v101 = new bytes[](32);\n                assert(4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1 < v27.length);\n                v103 = new struct(1);\n                v103.word0 = 0;\n                require(v101.length >= 32);\n                v104 = 32 + (4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 + ((v27[4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1] >> 248 << 248 >> 248) - 32));\n                v105 = 32;\n                while (v104 < 32 + (4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 + ((v27[4 + ((v27[3] >> 248 << 248 >> 248) - 32) + 34 - 1] >> 248 << 248 >> 248) - 32)) + 32) {\n                    MEM[v101 + v105] = MEM[v27 + v104];\n                    v104 = v104 + 32;\n                    v105 = v105 + 32;\n                }\n                v106, v107 = ecrecover(v93, 27, MEM[v97.data], MEM[v102.data]);\n                v108 = v108.data;\n                v109 = v53.length;\n                v110 = v53.data;\n                while (v109 >= 32) {\n                    MEM[v108] = MEM[v110];\n                    v108 = v108 + 32;\n                    v110 = v110 + 32;\n                    v109 = v109 - 32;\n                }\n                MEM[v108] = MEM[v110] & ~(256 ** (32 - v109) - 1) | MEM[v108] & 256 ** (32 - v109) - 1;\n                if (address(keccak256(v108)) != address(v107)) {\n                    v111, v112 = ecrecover(v93, 28, MEM[v97.data], MEM[v102.data]);\n                    v113 = v113.data;\n                    v114 = v53.length;\n                    v115 = v53.data;\n                    while (v114 >= 32) {\n                        MEM[v113] = MEM[v115];\n                        v113 = v113 + 32;\n                        v115 = v115 + 32;\n                        v114 = v114 - 32;\n                    }\n                    MEM[v113] = MEM[v115] & ~(256 ** (32 - v114) - 1) | MEM[v113] & 256 ** (32 - v114) - 1;\n                    v116 = address(keccak256(v113)) == address(v112);\n                } else {\n                    v116 = v117 = 1;\n                }\n                return v116, v79, v67, v5 + 32 + 41 + v27.length + 65, v53, v47, v27, v6, v5, 0, varg0;\n            }\n        } else {\n            v76 = v118 = 0;\n        }\n    } else {\n        v76 = v119 = 0;\n    }\n    return v76;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x9af(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction __callback(bytes32 varg0, string varg1) public nonPayable { \n    v0 = v1 = ~0x0 & varg0;\n    v0 = v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new bytes[](0);\n    }\n    v3 = new bytes[](0);\n    v6 = v7 = ___callback == 0;\n    if (___callback != 0) {\n        v6 = ___callback.code.size == 0;\n    }\n    if (v6) {\n        v8 = 0x251b(0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(___callback.code.size);\n    v9, v10 = ___callback.getAddress().gas(msg.gas - 710);\n    require(v9);\n    if (owner_1_0_19 != address(MEM[MEM[0x40]])) {\n        MEM[32 + MEM[64]] = 0;\n        require(___callback.code.size);\n        v11, v12 = ___callback.getAddress().gas(msg.gas - 710);\n        require(v11);\n        owner_1_0_19 = MEM[MEM[64]];\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(owner_1_0_19.code.size);\n    v13, v14 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    require(v13);\n    require(msg.sender == address(MEM[MEM[0x40]]));\n    v15 = 0x1b2b(v3, v2);\n    if (0xff & v15 != 3465) {\n        if (stor_f > 2) {\n            emit LedgerFailed('Stopping');\n        } else {\n            emit LedgerFailed('Requesting new');\n            require(stor_f + 1 >= stor_f);\n            stor_f = stor_f + 1;\n            0x17b6();\n        }\n    } else {\n        v16 = v16.data;\n        v17 = v3.length;\n        v18 = v5.data;\n        while (v17 >= 32) {\n            MEM[v16] = MEM[v18];\n            v16 = v16 + 32;\n            v18 = v18 + 32;\n            v17 = v17 - 32;\n        }\n        MEM[v16] = MEM[v18] & ~(256 ** (32 - v17) - 1) | MEM[v16] & 256 ** (32 - v17) - 1;\n        0xe0e(keccak256(v16), 0xf4240, 1);\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction receiveFromGame() public payable { \n    emit EthReceived(msg.sender, msg.value);\n}\n\nfunction __callback(bytes32 varg0, string varg1, bytes varg2) public nonPayable { \n    v0 = v1 = ~0x0 & varg0;\n    v0 = v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    v3 = new bytes[](varg2.length);\n    CALLDATACOPY(v3.data, 36 + varg2, varg2.length);\n    v4 = v5 = ___callback == 0;\n    if (___callback != 0) {\n        v4 = ___callback.code.size == 0;\n    }\n    if (v4) {\n        v6 = 0x251b(0);\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(___callback.code.size);\n    v7, v8 = ___callback.getAddress().gas(msg.gas - 710);\n    require(v7);\n    if (owner_1_0_19 != address(MEM[MEM[0x40]])) {\n        MEM[32 + MEM[64]] = 0;\n        require(___callback.code.size);\n        v9, v10 = ___callback.getAddress().gas(msg.gas - 710);\n        require(v9);\n        owner_1_0_19 = MEM[MEM[64]];\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(owner_1_0_19.code.size);\n    v11, v12 = owner_1_0_19.cbAddress().gas(msg.gas - 710);\n    require(v11);\n    require(msg.sender == address(MEM[MEM[0x40]]));\n    v13 = 0x1b2b(v3, v2);\n    if (0xff & v13 != 3465) {\n        if (stor_f > 2) {\n            emit LedgerFailed('Stopping');\n        } else {\n            emit LedgerFailed('Requesting new');\n            require(stor_f + 1 >= stor_f);\n            stor_f = stor_f + 1;\n            0x17b6();\n        }\n    } else {\n        v14 = v14.data;\n        v15 = v3.length;\n        v16 = v3.data;\n        while (v15 >= 32) {\n            MEM[v14] = MEM[v16];\n            v14 = v14 + 32;\n            v16 = v16 + 32;\n            v15 = v15 - 32;\n        }\n        MEM[v14] = MEM[v16] & ~(256 ** (32 - v15) - 1) | MEM[v14] & 256 ** (32 - v15) - 1;\n        0xe0e(keccak256(v14), 0xf4240, 1);\n    }\n}\n\nfunction addGame(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _awardToken[varg0] = 0x1 | ~0xff & _awardToken[varg0];\n    owner_e[varg0] = varg1;\n    _allowance[varg0] = stor_5;\n    emit Approval(msg.sender, varg0, stor_5);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _totalSupply[varg0];\n}\n\nfunction 0x47f2(uint256 varg0) private { \n    v0 = v1 = varg0.data;\n    if (31 < varg0.word0) {\n        array_2.length = 1 + (varg0.word0 + varg0.word0);\n        if (varg0.word0) {\n            while (v1 + varg0.word0 > v0) {\n                STORAGE[v2] = MEM[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        array_2.length = varg0.word0 + varg0.word0 | ~0xff & varg0.word1;\n    }\n    while (v3 + (31 + array_2.length >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x4850(uint256 varg0) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(2);\n    v2 = new struct(1);\n    v2.word0 = 0;\n    v1.word0 = v2;\n    v1.word1 = 0;\n    MEM[(MEM[64]) len (MSIZE() - MEM[64])] = this.code[this.code.size len (MSIZE() - MEM[64])];\n    v3 = v4 = 1024;\n    if (0 != 0) {\n        v3 = 1056;\n    }\n    v1.word1 = v3;\n    v1.word0 = MEM[64];\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + v3;\n    0x4978(4, v1);\n    if (0 >= varg0.length) {\n        0x4978(7, v1);\n        return v1.word0;\n    } else {\n        assert(0 < varg0.length);\n        0x499c(MEM[varg0[0]], 2, v1);\n        v5 = 0x4af5(varg0[0], v1);\n        return 0, v1, v0, varg0;\n    }\n}\n\nfunction 0x4978(uint256 varg0, uint256 varg1) private { \n    0x4ba1((0xff & varg0) << 5 | 0x1f, varg1);\n    return ;\n}\n\nfunction 0x499c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 > 23) {\n        if (varg0 > 255) {\n            if (varg0 > 0xffff) {\n                if (varg0 > 0xffffffff) {\n                    if (varg0 <= 0xffffffffffffffff) {\n                        0x4ba1((0xff & varg1) << 5 | 0x1b, varg2);\n                        v0 = 0x4be1(8, varg0, varg2);\n                    }\n                } else {\n                    0x4ba1((0xff & varg1) << 5 | 0x1a, varg2);\n                    v1 = 0x4be1(4, varg0, varg2);\n                }\n            } else {\n                0x4ba1((0xff & varg1) << 5 | 0x19, varg2);\n                v2 = 0x4be1(2, varg0, varg2);\n            }\n        } else {\n            0x4ba1((0xff & varg1) << 5 | 0x18, varg2);\n            v3 = 0x4be1(1, varg0, varg2);\n        }\n    } else {\n        0x4ba1(0xff & (0xff & varg1) << 5 | varg0, varg2);\n    }\n    return ;\n}\n\nfunction 0x4af5(uint256 varg0, uint256 varg1) private { \n    v0 = new struct(2);\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v0.word0 = v1;\n    v0.word1 = 0;\n    if (MEM[varg0] + MEM[varg1.word0] > varg1.word1) {\n        v2 = 0x4c48(MEM[varg0], varg1.word1);\n        0x4c64(v2 << 1, varg1);\n    }\n    v3 = v4 = MEM[varg0];\n    v5 = v6 = varg1.word0 + MEM[varg1.word0] + 32;\n    MEM[varg1.word0] = MEM[varg1.word0] + MEM[varg0];\n    v7 = v8 = varg0 + 32;\n    while (v3 >= 32) {\n        MEM[v5] = MEM[v7];\n        v5 = v5 + 32;\n        v7 = v7 + 32;\n        v3 = v3 - 32;\n    }\n    MEM[v5] = MEM[v5] & 256 ** (32 - v3) - 1 | MEM[v7] & ~(256 ** (32 - v3) - 1);\n    return varg1;\n}\n\nfunction 0x4ba1(uint256 varg0, uint256 varg1) private { \n    if (MEM[MEM[0 + varg1]] + 1 > MEM[32 + varg1]) {\n        0x4c64(MEM[32 + varg1] << 1, varg1);\n    }\n    v0 = MEM[varg1];\n    MEM8[v0 + MEM[v0] + 32] = varg0 & 0xFF;\n    MEM[v0] = MEM[v0] + 1;\n    return ;\n}\n\nfunction 0x4be1(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = new struct(2);\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v0.word0 = v1;\n    v0.word1 = 0;\n    if (varg0 + MEM[MEM[0 + varg2]] > MEM[32 + varg2]) {\n        v2 = 0x4c48(varg0, MEM[32 + varg2]);\n        0x4c64(v2 << 1, varg2);\n    }\n    v3 = MEM[varg2];\n    v4 = v3 + MEM[v3] + varg0;\n    MEM[v4] = MEM[v4] & ~(256 ** varg0 - 1) | varg1;\n    MEM[v3] = MEM[v3] + varg0;\n    return varg2;\n}\n\nfunction 0x4c48(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n    }\n    return varg0;\n}\n\nfunction 0x4c64(uint256 varg0, uint256 varg1) private { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    if (varg0 % 32 != 0) {\n        varg0 = v1 = varg0 + (32 - varg0 % 32);\n    }\n    MEM[32 + varg1] = varg0;\n    MEM[varg1] = MEM[64];\n    MEM[MEM[64]] = 0;\n    MEM[64] = MEM[64] + varg0;\n    v2 = 0x4af5(MEM[0 + varg1], varg1);\n    return ;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x424e530000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1114(varg1, varg0);\n    return v0;\n}\n\nfunction forceRoll() public nonPayable { \n    require(msg.sender == _owner);\n    stor_f = 0;\n    0x17b6();\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction takeAll() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction awardToken(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _awardToken[msg.sender]);\n    v0 = v1 = 1;\n    if ((address(this)).balance >= 0xde0b6b3a7640000) {\n        if ((address(this)).balance >= 0x1bc16d674ec80000) {\n            if ((address(this)).balance >= 0x3782dace9d900000) {\n                if ((address(this)).balance >= 0x6f05b59d3b200000) {\n                    if ((address(this)).balance >= 0xde0b6b3a76400000) {\n                        if ((address(this)).balance >= 0x1bc16d674ec800000) {\n                            if ((address(this)).balance >= 0x3782dace9d9000000) {\n                                if ((address(this)).balance >= 0x6f05b59d3b2000000) {\n                                    if ((address(this)).balance >= 0xde0b6b3a764000000) {\n                                        if ((address(this)).balance < 0x1bc16d674ec8000000) {\n                                            v0 = v2 = 2;\n                                        }\n                                    } else {\n                                        v0 = v3 = 4;\n                                    }\n                                } else {\n                                    v0 = v4 = 6;\n                                }\n                            } else {\n                                v0 = v5 = 8;\n                            }\n                        } else {\n                            v0 = v6 = 10;\n                        }\n                    } else {\n                        v0 = v7 = 15;\n                    }\n                } else {\n                    v0 = v8 = 20;\n                }\n            } else {\n                v0 = v9 = 30;\n            }\n        } else {\n            v0 = v10 = 40;\n        }\n    } else {\n        v0 = v11 = 50;\n    }\n    require(0xff & _awardToken[msg.sender]);\n    v12 = 0x9af(owner_e[msg.sender] * varg1 * 0xe8d4a51000 * v0, varg0, _owner);\n}\n\nfunction 0x9af(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(varg0 <= _totalSupply[v0]);\n    v1 = address(varg2);\n    _totalSupply[v1] = _totalSupply[v0] - varg0;\n    v2 = address(varg2);\n    require(varg0 <= _totalSupply[msg.sender]);\n    v3 = address(varg2);\n    _allowance[msg.sender] = _totalSupply[msg.sender] - varg0;\n    v4 = address(varg1);\n    v5 = _totalSupply[v4] + varg0;\n    require(v5 >= _totalSupply[v4]);\n    v6 = address(varg1);\n    _totalSupply[v6] = v5;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction 0xe0e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 % varg1 + varg2;\n    map_9[stor_c] = ~0xffffffffffffffffffffffffffffffffffffffff & map_9[stor_c];\n    v1 = v2 = map_a[stor_c] == 0;\n    if (map_a[stor_c] != 0) {\n        assert(map_a[stor_c]);\n        v1 = map_a[stor_c] * 10 / map_a[stor_c] == 10;\n    }\n    require(v1);\n    map_a[stor_c] = 0;\n    stor_c = stor_c + 1;\n    emit GotRandom(v0);\n    if (v0 <= map_a[stor_c] * 10) {\n        emit Winner(address(this), address(map_9[stor_c]), (address(this)).balance, v0, 0);\n        require(2 > 0);\n        assert(2);\n        v3 = address(map_9[stor_c]).call().value((address(this)).balance >> 1).gas(!((address(this)).balance >> 1) * 2300);\n        require(v3);\n    }\n    return ;\n}\n\nfunction () public payable { \n    v0 = msg.sender.call().value(msg.value).gas(!msg.value * 2300);\n    require(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x95ea7b3 == uint32(function_selector >> 224)) {\n            approve(address,uint256);\n        } else if (0x18160ddd == uint32(function_selector >> 224)) {\n            totalSupply();\n        } else if (0x1f7b4f30 == uint32(function_selector >> 224)) {\n            roll(uint256);\n        } else if (0x23b872dd == uint32(function_selector >> 224)) {\n            transferFrom(address,address,uint256);\n        } else if (0x27dc297e == uint32(function_selector >> 224)) {\n            __callback(bytes32,string);\n        } else if (0x313ce567 == uint32(function_selector >> 224)) {\n            decimals();\n        } else if (0x386304e4 == uint32(function_selector >> 224)) {\n            receiveFromGame();\n        } else if (0x38bbfa50 == uint32(function_selector >> 224)) {\n            __callback(bytes32,string,bytes);\n        } else if (0x5dce431b == uint32(function_selector >> 224)) {\n            addGame(address,uint256);\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0x95d89b41 == uint32(function_selector >> 224)) {\n            symbol();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xcbc9023c == uint32(function_selector >> 224)) {\n            forceRoll();\n        } else if (0xdd62ed3e == uint32(function_selector >> 224)) {\n            allowance(address,address);\n        } else if (0xde3bcb97 == uint32(function_selector >> 224)) {\n            takeAll();\n        } else if (0xded2d0f4 == uint32(function_selector >> 224)) {\n            awardToken(address,uint256);\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 46.0271110534668,
	"usage": {
		"completion_tokens": 600,
		"prompt_tokens": 13366,
		"total_tokens": 13966
	}
}