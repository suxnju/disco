{
	"address": "0x46403e94529fc04d04c9c393beab1d050ef06409",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is an example of a Solidity contract based on your given pseudo code. Please note that the decompiled pseudo code is not complete and has a lot of missing parts, and therefore this contract is not guaranteed to work as intended. This is just a starting point.\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract BonusToken {\n    string public constant name = \"Bonus Token\";\n    string public constant symbol = \"BNS\";\n    uint8 public constant decimals = 18;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address=>uint256)) public allowance;\n    address public owner;\n    uint256 public totalSupply;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _from, address indexed _spender, uint256 _value);\n\n    // Constructor\n    constructor() public {\n        owner = msg.sender;\n        totalSupply = 0;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Add more functions based on the pseudo code\n}\n```\n\nPlease note that due to the complexity and the specific requirements of your contract, you may need to hire a professional Solidity developer to create a fully functional contract that meets your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1700473800,
	"id": "chatcmpl-8MvCiVsJcdy1qkiFHfsFnpF6oIvNK",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst name = 'Bonus Token'\nconst decimals = 18\nconst symbol = 'BNS'\n\ndef storage:\n  stor0 is address at storage 0\n  stor1 is address at storage 1\n  stor1 is uint256 at storage 1\n  stor2 is bool at storage 2\n  stor2 is uint256 at storage 2 offset 8\n  stor2 is uint256 at storage 2 offset 1\n  stor5 is uint256 at storage 5\n  balanceOf is mapping of uint256 at storage 6\n  allowance is mapping of uint256 at storage 7\n  owner is address at storage 8\n  stor9 is mapping of address at storage 9\n  stor10 is mapping of uint256 at storage 10\n  stor11 is uint256 at storage 11\n  stor13 is mapping of uint8 at storage 13\n  stor14 is mapping of uint256 at storage 14\n  stor15 is uint256 at storage 15\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef owner(): # not payable\n  return owner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef totalSupply(): # not payable\n  return (stor5 - balanceOf[0])\n\ndef receiveFromGame() payable: \n  log EthReceived(\n        address =caller,\n        uint256 =call.value)\n\ndef forceRoll(): # not payable\n  require caller == owner\n  stor15 = 0\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef _fallback(?) payable: # default function\n  call caller with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef takeAll(): # not payable\n  require caller == owner\n  call caller with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef approve(address spender, uint256 amount): # not payable\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef addGame(address ctr, uint256 allocate): # not payable\n  require caller == owner\n  require ctr\n  stor13[address(ctr)] = 1\n  stor14[address(ctr)] = allocate\n  allowance[caller][address(ctr)] = stor5\n  log Approval(\n        address owner=stor5,\n        address spender=caller,\n        uint256 value=ctr)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require balanceOf[address(recipient)] + amount >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[address(sender)]\n  balanceOf[address(sender)] -= amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  require balanceOf[address(recipient)] + amount >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef roll(uint256 _amount): # not payable\n  if _amount != 10:\n      if _amount != 100:\n          require _amount == 1000\n      else:\n          if eth.balance(this.address) < 4 * 10^18:\n              require _amount == 1000\n  else:\n      if eth.balance(this.address) < 256 * 10^18:\n          if _amount != 100:\n              require _amount == 1000\n          else:\n              if eth.balance(this.address) < 4 * 10^18:\n                  require _amount == 1000\n  require balanceOf[caller] >= 10^18 * _amount\n  stor9[stor11] = caller\n  stor10[stor11] = _amount\n  stor11++\n  require owner\n  require 10^18 * _amount <= balanceOf[caller]\n  balanceOf[caller] += -1 * 10^18 * _amount\n  require balanceOf[stor8] + (10^18 * _amount) >= balanceOf[stor8]\n  balanceOf[stor8] += 10^18 * _amount\n  log Transfer(\n        address from=(10^18 * _amount),\n        address to=caller,\n        uint256 value=owner)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef __callback(bytes32 myid, string result): # not payable\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 12\n          Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 9\n          Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      require ext_code.size(stor0)\n      call stor0.getAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      if address(stor1) != ext_call.return_data[12 len 20]:\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n      require ext_code.size(address(stor1))\n      call address(stor1).cbAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require ext_call.return_data[12 len 20] != caller\n      revert\n  if ext_code.size(stor0):\n      require ext_code.size(stor0)\n      call stor0.getAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      if address(stor1) != ext_call.return_data[12 len 20]:\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n      require ext_code.size(address(stor1))\n      call address(stor1).cbAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require ext_call.return_data[12 len 20] != caller\n      revert\n  if result.length < ceil32(result.length):\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                          stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                          stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      if address(stor1) == ext_call.return_data[12 len 20]:\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                      require ext_code.size(address(stor1))\n                      call address(stor1).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      require caller == ext_call.return_data[12 len 20]\n  else:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                          stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                          stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      if address(stor1) == ext_call.return_data[12 len 20]:\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                      require ext_code.size(address(stor1))\n                      call address(stor1).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef awardToken(address toAddress, uint256 ticketAmount): # not payable\n  require stor13[caller]\n  require stor13[caller]\n  require toAddress\n  if eth.balance(this.address) < 10^18:\n      require 5 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n      balanceOf[stor8] += -5 * 10^13 * stor14[caller] * ticketAmount\n      require 5 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n      allowance[stor8][caller] += -5 * 10^13 * stor14[caller] * ticketAmount\n      require balanceOf[address(toAddress)] + (5 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n      balanceOf[address(toAddress)] += 5 * 10^13 * stor14[caller] * ticketAmount\n      log Transfer(\n            address from=(5 * 10^13 * stor14[caller] * ticketAmount),\n            address to=owner,\n            uint256 value=toAddress)\n  else:\n      if eth.balance(this.address) < 2 * 10^18:\n          require 4 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n          balanceOf[stor8] += -4 * 10^13 * stor14[caller] * ticketAmount\n          require 4 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n          allowance[stor8][caller] += -4 * 10^13 * stor14[caller] * ticketAmount\n          require balanceOf[address(toAddress)] + (4 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n          balanceOf[address(toAddress)] += 4 * 10^13 * stor14[caller] * ticketAmount\n          log Transfer(\n                address from=(4 * 10^13 * stor14[caller] * ticketAmount),\n                address to=owner,\n                uint256 value=toAddress)\n      else:\n          if eth.balance(this.address) < 4 * 10^18:\n              require 3 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n              balanceOf[stor8] += -3 * 10^13 * stor14[caller] * ticketAmount\n              require 3 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n              allowance[stor8][caller] += -3 * 10^13 * stor14[caller] * ticketAmount\n              require balanceOf[address(toAddress)] + (3 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n              balanceOf[address(toAddress)] += 3 * 10^13 * stor14[caller] * ticketAmount\n              log Transfer(\n                    address from=(3 * 10^13 * stor14[caller] * ticketAmount),\n                    address to=owner,\n                    uint256 value=toAddress)\n          else:\n              if eth.balance(this.address) < 8 * 10^18:\n                  require 2 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                  balanceOf[stor8] += -2 * 10^13 * stor14[caller] * ticketAmount\n                  require 2 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                  allowance[stor8][caller] += -2 * 10^13 * stor14[caller] * ticketAmount\n                  require balanceOf[address(toAddress)] + (2 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                  balanceOf[address(toAddress)] += 2 * 10^13 * stor14[caller] * ticketAmount\n                  log Transfer(\n                        address from=(2 * 10^13 * stor14[caller] * ticketAmount),\n                        address to=owner,\n                        uint256 value=toAddress)\n              else:\n                  if eth.balance(this.address) < 16 * 10^18:\n                      require 15 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                      balanceOf[stor8] += -15 * 10^12 * stor14[caller] * ticketAmount\n                      require 15 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                      allowance[stor8][caller] += -15 * 10^12 * stor14[caller] * ticketAmount\n                      require balanceOf[address(toAddress)] + (15 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                      balanceOf[address(toAddress)] += 15 * 10^12 * stor14[caller] * ticketAmount\n                      log Transfer(\n                            address from=(15 * 10^12 * stor14[caller] * ticketAmount),\n                            address to=owner,\n                            uint256 value=toAddress)\n                  else:\n                      if eth.balance(this.address) < 32 * 10^18:\n                          require 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                          balanceOf[stor8] += -1 * 10^13 * stor14[caller] * ticketAmount\n                          require 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                          allowance[stor8][caller] += -1 * 10^13 * stor14[caller] * ticketAmount\n                          require balanceOf[address(toAddress)] + (10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                          balanceOf[address(toAddress)] += 10^13 * stor14[caller] * ticketAmount\n                          log Transfer(\n                                address from=(10^13 * stor14[caller] * ticketAmount),\n                                address to=owner,\n                                uint256 value=toAddress)\n                      else:\n                          if eth.balance(this.address) < 64 * 10^18:\n                              require 8 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                              balanceOf[stor8] -= 8 * 10^12 * stor14[caller] * ticketAmount\n                              require 8 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                              allowance[stor8][caller] -= 8 * 10^12 * stor14[caller] * ticketAmount\n                              require balanceOf[address(toAddress)] + (8 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                              balanceOf[address(toAddress)] += 8 * 10^12 * stor14[caller] * ticketAmount\n                              log Transfer(\n                                    address from=(8 * 10^12 * stor14[caller] * ticketAmount),\n                                    address to=owner,\n                                    uint256 value=toAddress)\n                          else:\n                              if eth.balance(this.address) < 128 * 10^18:\n                                  require 6 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                  balanceOf[stor8] += -6 * 10^12 * stor14[caller] * ticketAmount\n                                  require 6 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                  allowance[stor8][caller] += -6 * 10^12 * stor14[caller] * ticketAmount\n                                  require balanceOf[address(toAddress)] + (6 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                  balanceOf[address(toAddress)] += 6 * 10^12 * stor14[caller] * ticketAmount\n                                  log Transfer(\n                                        address from=(6 * 10^12 * stor14[caller] * ticketAmount),\n                                        address to=owner,\n                                        uint256 value=toAddress)\n                              else:\n                                  if eth.balance(this.address) < 256 * 10^18:\n                                      require 4 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                      balanceOf[stor8] -= 4 * 10^12 * stor14[caller] * ticketAmount\n                                      require 4 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                      allowance[stor8][caller] -= 4 * 10^12 * stor14[caller] * ticketAmount\n                                      require balanceOf[address(toAddress)] + (4 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                      balanceOf[address(toAddress)] += 4 * 10^12 * stor14[caller] * ticketAmount\n                                      log Transfer(\n                                            address from=(4 * 10^12 * stor14[caller] * ticketAmount),\n                                            address to=owner,\n                                            uint256 value=toAddress)\n                                  else:\n                                      if eth.balance(this.address) >= 512 * 10^18:\n                                          require 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                          balanceOf[stor8] += -1 * 10^12 * stor14[caller] * ticketAmount\n                                          require 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                          allowance[stor8][caller] += -1 * 10^12 * stor14[caller] * ticketAmount\n                                          require balanceOf[address(toAddress)] + (10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                          balanceOf[address(toAddress)] += 10^12 * stor14[caller] * ticketAmount\n                                          log Transfer(\n                                                address from=(10^12 * stor14[caller] * ticketAmount),\n                                                address to=owner,\n                                                uint256 value=toAddress)\n                                      else:\n                                          require 2 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                          balanceOf[stor8] -= 2 * 10^12 * stor14[caller] * ticketAmount\n                                          require 2 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                          allowance[stor8][caller] -= 2 * 10^12 * stor14[caller] * ticketAmount\n                                          require balanceOf[address(toAddress)] + (2 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                          balanceOf[address(toAddress)] += 2 * 10^12 * stor14[caller] * ticketAmount\n                                          log Transfer(\n                                                address from=(2 * 10^12 * stor14[caller] * ticketAmount),\n                                                address to=owner,\n                                                uint256 value=toAddress)\n\ndef __callback(bytes32 myid, string result, bytes proof): # not payable\n  mem[ceil32(result.length) + 160 len proof.length] = proof[all]\n  if stor0:\n      if ext_code.size(stor0):\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          if address(stor1) != ext_call.return_data[12 len 20]:\n              require ext_code.size(stor0)\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n          mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n          require ext_code.size(address(stor1))\n          call address(stor1).cbAddress() with:\n               gas gas_remaining - 710 wei\n          mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n          require ext_call.success\n          require caller == ext_call.return_data[12 len 20]\n          require 0 < proof.length\n          if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n              if stor15 > 2:\n                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                  stop\n              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n              require stor15 + 1 >= stor15\n              stor15++\n          else:\n              require 1 < proof.length\n              if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                  if stor15 > 2:\n                      log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                      stop\n                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                  require stor15 + 1 >= stor15\n                  stor15++\n              else:\n                  require 2 < proof.length\n                  if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                      if stor15 > 2:\n                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                          stop\n                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                      require stor15 + 1 >= stor15\n                      stor15++\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 11\n              Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n          else:\n              if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n                  stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 12\n                  Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n              else:\n                  if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                      stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 9\n                      Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n                  else:\n                      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                          bool(stor2.field_0) = 0\n                          uint255(stor2.field_1) = 11\n                          Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                      else:\n                          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) <= 0:\n                              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) <= 0:\n                                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  if address(stor1) == ext_call.return_data[12 len 20]:\n                                      mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                      require ext_code.size(address(stor1))\n                                      call address(stor1).cbAddress() with:\n                                           gas gas_remaining - 710 wei\n                                      mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                      require ext_call.success\n                                      require caller == ext_call.return_data[12 len 20]\n                                      require 0 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      else:\n                                          require 1 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                              require 2 < proof.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 1 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 2 < proof.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      else:\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                          require 2 < proof.length\n                          else:\n                              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              stop\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                          require stor15 + 1 >= stor15\n                                          stor15++\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                                  stop\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                              stor15++\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n  else:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) <= 0:\n                          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) <= 0:\n                              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      else:\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                          require 2 < proof.length\n                          else:\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              stop\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                          require stor15 + 1 >= stor15\n                                          stor15++\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                                  stop\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                              stor15++\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                      else:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                          require ext_call.success\n                          require caller == ext_call.return_data[12 len 20]\n                          require 0 < proof.length\n                          if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                              if stor15 > 2:\n                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                  stop\n                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              require stor15 + 1 >= stor15\n                              stor15++\n                          else:\n                              require 1 < proof.length\n                              if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                  if stor15 > 2:\n                                      log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      stop\n                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  require stor15 + 1 >= stor15\n                                  stor15++\n                              else:\n                                  require 2 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'Bonus Token'\nconst decimals = 18\nconst symbol = 'BNS'\n\ndef storage:\n  stor0 is address at storage 0\n  stor1 is address at storage 1\n  stor1 is uint256 at storage 1\n  stor2 is bool at storage 2\n  stor2 is uint256 at storage 2 offset 8\n  stor2 is uint256 at storage 2 offset 1\n  stor5 is uint256 at storage 5\n  balanceOf is mapping of uint256 at storage 6\n  allowance is mapping of uint256 at storage 7\n  owner is address at storage 8\n  stor9 is mapping of address at storage 9\n  stor10 is mapping of uint256 at storage 10\n  stor11 is uint256 at storage 11\n  stor13 is mapping of uint8 at storage 13\n  stor14 is mapping of uint256 at storage 14\n  stor15 is uint256 at storage 15\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef owner(): # not payable\n  return owner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef totalSupply(): # not payable\n  return (stor5 - balanceOf[0])\n\ndef receiveFromGame() payable: \n  log EthReceived(\n        address =caller,\n        uint256 =call.value)\n\ndef forceRoll(): # not payable\n  require caller == owner\n  stor15 = 0\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef _fallback(?) payable: # default function\n  call caller with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef takeAll(): # not payable\n  require caller == owner\n  call caller with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef approve(address spender, uint256 amount): # not payable\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef addGame(address ctr, uint256 allocate): # not payable\n  require caller == owner\n  require ctr\n  stor13[address(ctr)] = 1\n  stor14[address(ctr)] = allocate\n  allowance[caller][address(ctr)] = stor5\n  log Approval(\n        address owner=stor5,\n        address spender=caller,\n        uint256 value=ctr)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require balanceOf[address(recipient)] + amount >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[address(sender)]\n  balanceOf[address(sender)] -= amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  require balanceOf[address(recipient)] + amount >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef roll(uint256 _amount): # not payable\n  if _amount != 10:\n      if _amount != 100:\n          require _amount == 1000\n      else:\n          if eth.balance(this.address) < 4 * 10^18:\n              require _amount == 1000\n  else:\n      if eth.balance(this.address) < 256 * 10^18:\n          if _amount != 100:\n              require _amount == 1000\n          else:\n              if eth.balance(this.address) < 4 * 10^18:\n                  require _amount == 1000\n  require balanceOf[caller] >= 10^18 * _amount\n  stor9[stor11] = caller\n  stor10[stor11] = _amount\n  stor11++\n  require owner\n  require 10^18 * _amount <= balanceOf[caller]\n  balanceOf[caller] += -1 * 10^18 * _amount\n  require balanceOf[stor8] + (10^18 * _amount) >= balanceOf[stor8]\n  balanceOf[stor8] += 10^18 * _amount\n  log Transfer(\n        address from=(10^18 * _amount),\n        address to=caller,\n        uint256 value=owner)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef __callback(bytes32 myid, string result): # not payable\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 12\n          Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 9\n          Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      require ext_code.size(stor0)\n      call stor0.getAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      if address(stor1) != ext_call.return_data[12 len 20]:\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n      require ext_code.size(address(stor1))\n      call address(stor1).cbAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require ext_call.return_data[12 len 20] != caller\n      revert\n  if ext_code.size(stor0):\n      require ext_code.size(stor0)\n      call stor0.getAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      if address(stor1) != ext_call.return_data[12 len 20]:\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n      require ext_code.size(address(stor1))\n      call address(stor1).cbAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require ext_call.return_data[12 len 20] != caller\n      revert\n  if result.length < ceil32(result.length):\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                          stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                          stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      if address(stor1) == ext_call.return_data[12 len 20]:\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                      require ext_code.size(address(stor1))\n                      call address(stor1).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      require caller == ext_call.return_data[12 len 20]\n  else:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                          stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                          stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      if address(stor1) == ext_call.return_data[12 len 20]:\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                      require ext_code.size(address(stor1))\n                      call address(stor1).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef awardToken(address toAddress, uint256 ticketAmount): # not payable\n  require stor13[caller]\n  require stor13[caller]\n  require toAddress\n  if eth.balance(this.address) < 10^18:\n      require 5 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n      balanceOf[stor8] += -5 * 10^13 * stor14[caller] * ticketAmount\n      require 5 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n      allowance[stor8][caller] += -5 * 10^13 * stor14[caller] * ticketAmount\n      require balanceOf[address(toAddress)] + (5 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n      balanceOf[address(toAddress)] += 5 * 10^13 * stor14[caller] * ticketAmount\n      log Transfer(\n            address from=(5 * 10^13 * stor14[caller] * ticketAmount),\n            address to=owner,\n            uint256 value=toAddress)\n  else:\n      if eth.balance(this.address) < 2 * 10^18:\n          require 4 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n          balanceOf[stor8] += -4 * 10^13 * stor14[caller] * ticketAmount\n          require 4 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n          allowance[stor8][caller] += -4 * 10^13 * stor14[caller] * ticketAmount\n          require balanceOf[address(toAddress)] + (4 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n          balanceOf[address(toAddress)] += 4 * 10^13 * stor14[caller] * ticketAmount\n          log Transfer(\n                address from=(4 * 10^13 * stor14[caller] * ticketAmount),\n                address to=owner,\n                uint256 value=toAddress)\n      else:\n          if eth.balance(this.address) < 4 * 10^18:\n              require 3 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n              balanceOf[stor8] += -3 * 10^13 * stor14[caller] * ticketAmount\n              require 3 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n              allowance[stor8][caller] += -3 * 10^13 * stor14[caller] * ticketAmount\n              require balanceOf[address(toAddress)] + (3 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n              balanceOf[address(toAddress)] += 3 * 10^13 * stor14[caller] * ticketAmount\n              log Transfer(\n                    address from=(3 * 10^13 * stor14[caller] * ticketAmount),\n                    address to=owner,\n                    uint256 value=toAddress)\n          else:\n              if eth.balance(this.address) < 8 * 10^18:\n                  require 2 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                  balanceOf[stor8] += -2 * 10^13 * stor14[caller] * ticketAmount\n                  require 2 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                  allowance[stor8][caller] += -2 * 10^13 * stor14[caller] * ticketAmount\n                  require balanceOf[address(toAddress)] + (2 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                  balanceOf[address(toAddress)] += 2 * 10^13 * stor14[caller] * ticketAmount\n                  log Transfer(\n                        address from=(2 * 10^13 * stor14[caller] * ticketAmount),\n                        address to=owner,\n                        uint256 value=toAddress)\n              else:\n                  if eth.balance(this.address) < 16 * 10^18:\n                      require 15 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                      balanceOf[stor8] += -15 * 10^12 * stor14[caller] * ticketAmount\n                      require 15 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                      allowance[stor8][caller] += -15 * 10^12 * stor14[caller] * ticketAmount\n                      require balanceOf[address(toAddress)] + (15 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                      balanceOf[address(toAddress)] += 15 * 10^12 * stor14[caller] * ticketAmount\n                      log Transfer(\n                            address from=(15 * 10^12 * stor14[caller] * ticketAmount),\n                            address to=owner,\n                            uint256 value=toAddress)\n                  else:\n                      if eth.balance(this.address) < 32 * 10^18:\n                          require 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                          balanceOf[stor8] += -1 * 10^13 * stor14[caller] * ticketAmount\n                          require 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                          allowance[stor8][caller] += -1 * 10^13 * stor14[caller] * ticketAmount\n                          require balanceOf[address(toAddress)] + (10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                          balanceOf[address(toAddress)] += 10^13 * stor14[caller] * ticketAmount\n                          log Transfer(\n                                address from=(10^13 * stor14[caller] * ticketAmount),\n                                address to=owner,\n                                uint256 value=toAddress)\n                      else:\n                          if eth.balance(this.address) < 64 * 10^18:\n                              require 8 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                              balanceOf[stor8] -= 8 * 10^12 * stor14[caller] * ticketAmount\n                              require 8 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                              allowance[stor8][caller] -= 8 * 10^12 * stor14[caller] * ticketAmount\n                              require balanceOf[address(toAddress)] + (8 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                              balanceOf[address(toAddress)] += 8 * 10^12 * stor14[caller] * ticketAmount\n                              log Transfer(\n                                    address from=(8 * 10^12 * stor14[caller] * ticketAmount),\n                                    address to=owner,\n                                    uint256 value=toAddress)\n                          else:\n                              if eth.balance(this.address) < 128 * 10^18:\n                                  require 6 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                  balanceOf[stor8] += -6 * 10^12 * stor14[caller] * ticketAmount\n                                  require 6 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                  allowance[stor8][caller] += -6 * 10^12 * stor14[caller] * ticketAmount\n                                  require balanceOf[address(toAddress)] + (6 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                  balanceOf[address(toAddress)] += 6 * 10^12 * stor14[caller] * ticketAmount\n                                  log Transfer(\n                                        address from=(6 * 10^12 * stor14[caller] * ticketAmount),\n                                        address to=owner,\n                                        uint256 value=toAddress)\n                              else:\n                                  if eth.balance(this.address) < 256 * 10^18:\n                                      require 4 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                      balanceOf[stor8] -= 4 * 10^12 * stor14[caller] * ticketAmount\n                                      require 4 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                      allowance[stor8][caller] -= 4 * 10^12 * stor14[caller] * ticketAmount\n                                      require balanceOf[address(toAddress)] + (4 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                      balanceOf[address(toAddress)] += 4 * 10^12 * stor14[caller] * ticketAmount\n                                      log Transfer(\n                                            address from=(4 * 10^12 * stor14[caller] * ticketAmount),\n                                            address to=owner,\n                                            uint256 value=toAddress)\n                                  else:\n                                      if eth.balance(this.address) >= 512 * 10^18:\n                                          require 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                          balanceOf[stor8] += -1 * 10^12 * stor14[caller] * ticketAmount\n                                          require 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                          allowance[stor8][caller] += -1 * 10^12 * stor14[caller] * ticketAmount\n                                          require balanceOf[address(toAddress)] + (10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                          balanceOf[address(toAddress)] += 10^12 * stor14[caller] * ticketAmount\n                                          log Transfer(\n                                                address from=(10^12 * stor14[caller] * ticketAmount),\n                                                address to=owner,\n                                                uint256 value=toAddress)\n                                      else:\n                                          require 2 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                          balanceOf[stor8] -= 2 * 10^12 * stor14[caller] * ticketAmount\n                                          require 2 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                          allowance[stor8][caller] -= 2 * 10^12 * stor14[caller] * ticketAmount\n                                          require balanceOf[address(toAddress)] + (2 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                          balanceOf[address(toAddress)] += 2 * 10^12 * stor14[caller] * ticketAmount\n                                          log Transfer(\n                                                address from=(2 * 10^12 * stor14[caller] * ticketAmount),\n                                                address to=owner,\n                                                uint256 value=toAddress)\n\ndef __callback(bytes32 myid, string result, bytes proof): # not payable\n  mem[ceil32(result.length) + 160 len proof.length] = proof[all]\n  if stor0:\n      if ext_code.size(stor0):\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          if address(stor1) != ext_call.return_data[12 len 20]:\n              require ext_code.size(stor0)\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n          mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n          require ext_code.size(address(stor1))\n          call address(stor1).cbAddress() with:\n               gas gas_remaining - 710 wei\n          mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n          require ext_call.success\n          require caller == ext_call.return_data[12 len 20]\n          require 0 < proof.length\n          if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n              if stor15 > 2:\n                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                  stop\n              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n              require stor15 + 1 >= stor15\n              stor15++\n          else:\n              require 1 < proof.length\n              if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                  if stor15 > 2:\n                      log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                      stop\n                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                  require stor15 + 1 >= stor15\n                  stor15++\n              else:\n                  require 2 < proof.length\n                  if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                      if stor15 > 2:\n                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                          stop\n                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                      require stor15 + 1 >= stor15\n                      stor15++\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 11\n              Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n          else:\n              if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n                  stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 12\n                  Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n              else:\n                  if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                      stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 9\n                      Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n                  else:\n                      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                          bool(stor2.field_0) = 0\n                          uint255(stor2.field_1) = 11\n                          Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                      else:\n                          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) <= 0:\n                              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) <= 0:\n                                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  if address(stor1) == ext_call.return_data[12 len 20]:\n                                      mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                      require ext_code.size(address(stor1))\n                                      call address(stor1).cbAddress() with:\n                                           gas gas_remaining - 710 wei\n                                      mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                      require ext_call.success\n                                      require caller == ext_call.return_data[12 len 20]\n                                      require 0 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      else:\n                                          require 1 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                              require 2 < proof.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 1 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 2 < proof.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      else:\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                          require 2 < proof.length\n                          else:\n                              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              stop\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                          require stor15 + 1 >= stor15\n                                          stor15++\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                                  stop\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                              stor15++\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n  else:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) <= 0:\n                          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) <= 0:\n                              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      else:\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                          require 2 < proof.length\n                          else:\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              stop\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                          require stor15 + 1 >= stor15\n                                          stor15++\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                                  stop\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                              stor15++\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                      else:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                          require ext_call.success\n                          require caller == ext_call.return_data[12 len 20]\n                          require 0 < proof.length\n                          if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                              if stor15 > 2:\n                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                  stop\n                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              require stor15 + 1 >= stor15\n                              stor15++\n                          else:\n                              require 1 < proof.length\n                              if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                  if stor15 > 2:\n                                      log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      stop\n                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  require stor15 + 1 >= stor15\n                                  stor15++\n                              else:\n                                  require 2 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'Bonus Token'\nconst decimals = 18\nconst symbol = 'BNS'\n\ndef storage:\n  stor0 is address at storage 0\n  stor1 is address at storage 1\n  stor1 is uint256 at storage 1\n  stor2 is bool at storage 2\n  stor2 is uint256 at storage 2 offset 8\n  stor2 is uint256 at storage 2 offset 1\n  stor5 is uint256 at storage 5\n  balanceOf is mapping of uint256 at storage 6\n  allowance is mapping of uint256 at storage 7\n  owner is address at storage 8\n  stor9 is mapping of address at storage 9\n  stor10 is mapping of uint256 at storage 10\n  stor11 is uint256 at storage 11\n  stor13 is mapping of uint8 at storage 13\n  stor14 is mapping of uint256 at storage 14\n  stor15 is uint256 at storage 15\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef owner(): # not payable\n  return owner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef totalSupply(): # not payable\n  return (stor5 - balanceOf[0])\n\ndef receiveFromGame() payable: \n  log EthReceived(\n        address =caller,\n        uint256 =call.value)\n\ndef forceRoll(): # not payable\n  require caller == owner\n  stor15 = 0\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef _fallback(?) payable: # default function\n  call caller with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef takeAll(): # not payable\n  require caller == owner\n  call caller with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef approve(address spender, uint256 amount): # not payable\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef addGame(address ctr, uint256 allocate): # not payable\n  require caller == owner\n  require ctr\n  stor13[address(ctr)] = 1\n  stor14[address(ctr)] = allocate\n  allowance[caller][address(ctr)] = stor5\n  log Approval(\n        address owner=stor5,\n        address spender=caller,\n        uint256 value=ctr)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require balanceOf[address(recipient)] + amount >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[address(sender)]\n  balanceOf[address(sender)] -= amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  require balanceOf[address(recipient)] + amount >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef roll(uint256 _amount): # not payable\n  if _amount != 10:\n      if _amount != 100:\n          require _amount == 1000\n      else:\n          if eth.balance(this.address) < 4 * 10^18:\n              require _amount == 1000\n  else:\n      if eth.balance(this.address) < 256 * 10^18:\n          if _amount != 100:\n              require _amount == 1000\n          else:\n              if eth.balance(this.address) < 4 * 10^18:\n                  require _amount == 1000\n  require balanceOf[caller] >= 10^18 * _amount\n  stor9[stor11] = caller\n  stor10[stor11] = _amount\n  stor11++\n  require owner\n  require 10^18 * _amount <= balanceOf[caller]\n  balanceOf[caller] += -1 * 10^18 * _amount\n  require balanceOf[stor8] + (10^18 * _amount) >= balanceOf[stor8]\n  balanceOf[stor8] += 10^18 * _amount\n  log Transfer(\n        address from=(10^18 * _amount),\n        address to=caller,\n        uint256 value=owner)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef __callback(bytes32 myid, string result): # not payable\n  if not stor0:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n          stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 12\n          Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n          stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 9\n          Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n      else:\n          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n          else:\n              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n      require ext_code.size(stor0)\n      call stor0.getAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      if address(stor1) != ext_call.return_data[12 len 20]:\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n      require ext_code.size(address(stor1))\n      call address(stor1).cbAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require ext_call.return_data[12 len 20] != caller\n      revert\n  if ext_code.size(stor0):\n      require ext_code.size(stor0)\n      call stor0.getAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      if address(stor1) != ext_call.return_data[12 len 20]:\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n      require ext_code.size(address(stor1))\n      call address(stor1).cbAddress() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require ext_call.return_data[12 len 20] != caller\n      revert\n  if result.length < ceil32(result.length):\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                          stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                          stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      if address(stor1) == ext_call.return_data[12 len 20]:\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                      require ext_code.size(address(stor1))\n                      call address(stor1).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      require caller == ext_call.return_data[12 len 20]\n  else:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) > 0:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) > 0:\n                          stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                          stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      if address(stor1) == ext_call.return_data[12 len 20]:\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          require ext_call.return_data[12 len 20] != caller\n                          revert\n                      require ext_code.size(stor0)\n                      call stor0.getAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n                      uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                      require ext_code.size(address(stor1))\n                      call address(stor1).cbAddress() with:\n                           gas gas_remaining - 710 wei\n                      require ext_call.success\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef awardToken(address toAddress, uint256 ticketAmount): # not payable\n  require stor13[caller]\n  require stor13[caller]\n  require toAddress\n  if eth.balance(this.address) < 10^18:\n      require 5 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n      balanceOf[stor8] += -5 * 10^13 * stor14[caller] * ticketAmount\n      require 5 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n      allowance[stor8][caller] += -5 * 10^13 * stor14[caller] * ticketAmount\n      require balanceOf[address(toAddress)] + (5 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n      balanceOf[address(toAddress)] += 5 * 10^13 * stor14[caller] * ticketAmount\n      log Transfer(\n            address from=(5 * 10^13 * stor14[caller] * ticketAmount),\n            address to=owner,\n            uint256 value=toAddress)\n  else:\n      if eth.balance(this.address) < 2 * 10^18:\n          require 4 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n          balanceOf[stor8] += -4 * 10^13 * stor14[caller] * ticketAmount\n          require 4 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n          allowance[stor8][caller] += -4 * 10^13 * stor14[caller] * ticketAmount\n          require balanceOf[address(toAddress)] + (4 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n          balanceOf[address(toAddress)] += 4 * 10^13 * stor14[caller] * ticketAmount\n          log Transfer(\n                address from=(4 * 10^13 * stor14[caller] * ticketAmount),\n                address to=owner,\n                uint256 value=toAddress)\n      else:\n          if eth.balance(this.address) < 4 * 10^18:\n              require 3 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n              balanceOf[stor8] += -3 * 10^13 * stor14[caller] * ticketAmount\n              require 3 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n              allowance[stor8][caller] += -3 * 10^13 * stor14[caller] * ticketAmount\n              require balanceOf[address(toAddress)] + (3 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n              balanceOf[address(toAddress)] += 3 * 10^13 * stor14[caller] * ticketAmount\n              log Transfer(\n                    address from=(3 * 10^13 * stor14[caller] * ticketAmount),\n                    address to=owner,\n                    uint256 value=toAddress)\n          else:\n              if eth.balance(this.address) < 8 * 10^18:\n                  require 2 * 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                  balanceOf[stor8] += -2 * 10^13 * stor14[caller] * ticketAmount\n                  require 2 * 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                  allowance[stor8][caller] += -2 * 10^13 * stor14[caller] * ticketAmount\n                  require balanceOf[address(toAddress)] + (2 * 10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                  balanceOf[address(toAddress)] += 2 * 10^13 * stor14[caller] * ticketAmount\n                  log Transfer(\n                        address from=(2 * 10^13 * stor14[caller] * ticketAmount),\n                        address to=owner,\n                        uint256 value=toAddress)\n              else:\n                  if eth.balance(this.address) < 16 * 10^18:\n                      require 15 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                      balanceOf[stor8] += -15 * 10^12 * stor14[caller] * ticketAmount\n                      require 15 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                      allowance[stor8][caller] += -15 * 10^12 * stor14[caller] * ticketAmount\n                      require balanceOf[address(toAddress)] + (15 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                      balanceOf[address(toAddress)] += 15 * 10^12 * stor14[caller] * ticketAmount\n                      log Transfer(\n                            address from=(15 * 10^12 * stor14[caller] * ticketAmount),\n                            address to=owner,\n                            uint256 value=toAddress)\n                  else:\n                      if eth.balance(this.address) < 32 * 10^18:\n                          require 10^13 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                          balanceOf[stor8] += -1 * 10^13 * stor14[caller] * ticketAmount\n                          require 10^13 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                          allowance[stor8][caller] += -1 * 10^13 * stor14[caller] * ticketAmount\n                          require balanceOf[address(toAddress)] + (10^13 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                          balanceOf[address(toAddress)] += 10^13 * stor14[caller] * ticketAmount\n                          log Transfer(\n                                address from=(10^13 * stor14[caller] * ticketAmount),\n                                address to=owner,\n                                uint256 value=toAddress)\n                      else:\n                          if eth.balance(this.address) < 64 * 10^18:\n                              require 8 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                              balanceOf[stor8] -= 8 * 10^12 * stor14[caller] * ticketAmount\n                              require 8 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                              allowance[stor8][caller] -= 8 * 10^12 * stor14[caller] * ticketAmount\n                              require balanceOf[address(toAddress)] + (8 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                              balanceOf[address(toAddress)] += 8 * 10^12 * stor14[caller] * ticketAmount\n                              log Transfer(\n                                    address from=(8 * 10^12 * stor14[caller] * ticketAmount),\n                                    address to=owner,\n                                    uint256 value=toAddress)\n                          else:\n                              if eth.balance(this.address) < 128 * 10^18:\n                                  require 6 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                  balanceOf[stor8] += -6 * 10^12 * stor14[caller] * ticketAmount\n                                  require 6 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                  allowance[stor8][caller] += -6 * 10^12 * stor14[caller] * ticketAmount\n                                  require balanceOf[address(toAddress)] + (6 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                  balanceOf[address(toAddress)] += 6 * 10^12 * stor14[caller] * ticketAmount\n                                  log Transfer(\n                                        address from=(6 * 10^12 * stor14[caller] * ticketAmount),\n                                        address to=owner,\n                                        uint256 value=toAddress)\n                              else:\n                                  if eth.balance(this.address) < 256 * 10^18:\n                                      require 4 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                      balanceOf[stor8] -= 4 * 10^12 * stor14[caller] * ticketAmount\n                                      require 4 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                      allowance[stor8][caller] -= 4 * 10^12 * stor14[caller] * ticketAmount\n                                      require balanceOf[address(toAddress)] + (4 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                      balanceOf[address(toAddress)] += 4 * 10^12 * stor14[caller] * ticketAmount\n                                      log Transfer(\n                                            address from=(4 * 10^12 * stor14[caller] * ticketAmount),\n                                            address to=owner,\n                                            uint256 value=toAddress)\n                                  else:\n                                      if eth.balance(this.address) >= 512 * 10^18:\n                                          require 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                          balanceOf[stor8] += -1 * 10^12 * stor14[caller] * ticketAmount\n                                          require 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                          allowance[stor8][caller] += -1 * 10^12 * stor14[caller] * ticketAmount\n                                          require balanceOf[address(toAddress)] + (10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                          balanceOf[address(toAddress)] += 10^12 * stor14[caller] * ticketAmount\n                                          log Transfer(\n                                                address from=(10^12 * stor14[caller] * ticketAmount),\n                                                address to=owner,\n                                                uint256 value=toAddress)\n                                      else:\n                                          require 2 * 10^12 * stor14[caller] * ticketAmount <= balanceOf[stor8]\n                                          balanceOf[stor8] -= 2 * 10^12 * stor14[caller] * ticketAmount\n                                          require 2 * 10^12 * stor14[caller] * ticketAmount <= allowance[stor8][caller]\n                                          allowance[stor8][caller] -= 2 * 10^12 * stor14[caller] * ticketAmount\n                                          require balanceOf[address(toAddress)] + (2 * 10^12 * stor14[caller] * ticketAmount) >= balanceOf[address(toAddress)]\n                                          balanceOf[address(toAddress)] += 2 * 10^12 * stor14[caller] * ticketAmount\n                                          log Transfer(\n                                                address from=(2 * 10^12 * stor14[caller] * ticketAmount),\n                                                address to=owner,\n                                                uint256 value=toAddress)\n\ndef __callback(bytes32 myid, string result, bytes proof): # not payable\n  mem[ceil32(result.length) + 160 len proof.length] = proof[all]\n  if stor0:\n      if ext_code.size(stor0):\n          require ext_code.size(stor0)\n          call stor0.getAddress() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          if address(stor1) != ext_call.return_data[12 len 20]:\n              require ext_code.size(stor0)\n              call stor0.getAddress() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n          mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n          require ext_code.size(address(stor1))\n          call address(stor1).cbAddress() with:\n               gas gas_remaining - 710 wei\n          mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n          require ext_call.success\n          require caller == ext_call.return_data[12 len 20]\n          require 0 < proof.length\n          if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n              if stor15 > 2:\n                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                  stop\n              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n              require stor15 + 1 >= stor15\n              stor15++\n          else:\n              require 1 < proof.length\n              if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                  if stor15 > 2:\n                      log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                      stop\n                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                  require stor15 + 1 >= stor15\n                  stor15++\n              else:\n                  require 2 < proof.length\n                  if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                      if stor15 > 2:\n                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                          stop\n                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                      require stor15 + 1 >= stor15\n                      stor15++\n      else:\n          if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n              stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 11\n              Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n          else:\n              if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n                  stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 12\n                  Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n              else:\n                  if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                      stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 9\n                      Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n                  else:\n                      if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                          stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                          bool(stor2.field_0) = 0\n                          uint255(stor2.field_1) = 11\n                          Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                      else:\n                          if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) <= 0:\n                              if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) <= 0:\n                                  if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                      stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  if address(stor1) == ext_call.return_data[12 len 20]:\n                                      mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                      require ext_code.size(address(stor1))\n                                      call address(stor1).cbAddress() with:\n                                           gas gas_remaining - 710 wei\n                                      mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                      require ext_call.success\n                                      require caller == ext_call.return_data[12 len 20]\n                                      require 0 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      else:\n                                          require 1 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                              require 2 < proof.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 1 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 2 < proof.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      else:\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                          require 2 < proof.length\n                          else:\n                              stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              stop\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                          require stor15 + 1 >= stor15\n                                          stor15++\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                                  stop\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                              stor15++\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n  else:\n      if ext_code.size(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed) > 0:\n          stor0 = 0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed\n          bool(stor2.field_0) = 0\n          uint255(stor2.field_1) = 11\n          Mask(248, 0, stor2.field_8) = 'eth_mainnet' / 256\n      else:\n          if ext_code.size(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1) > 0:\n              stor0 = 0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1\n              bool(stor2.field_0) = 0\n              uint255(stor2.field_1) = 12\n              Mask(248, 0, stor2.field_8) = 'eth_ropsten3' / 256\n          else:\n              if ext_code.size(0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e) > 0:\n                  stor0 = 0xb7a07bcf2ba2f2703b24c0691b5278999c59ac7e\n                  bool(stor2.field_0) = 0\n                  uint255(stor2.field_1) = 9\n                  Mask(248, 0, stor2.field_8) = 'eth_kovan' / 256\n              else:\n                  if ext_code.size(0x146500cfd35b22e4a392fe0adc06de1a1368ed48) > 0:\n                      stor0 = 0x146500cfd35b22e4a392fe0adc06de1a1368ed48\n                      bool(stor2.field_0) = 0\n                      uint255(stor2.field_1) = 11\n                      Mask(248, 0, stor2.field_8) = 'eth_rinkeby' / 256\n                  else:\n                      if ext_code.size(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475) <= 0:\n                          if ext_code.size(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf) <= 0:\n                              if ext_code.size(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa) > 0:\n                                  stor0 = 0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      else:\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) == 'P':\n                                          require 2 < proof.length\n                          else:\n                              stor0 = 0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              if address(stor1) == ext_call.return_data[12 len 20]:\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              stop\n                                          log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                          require stor15 + 1 >= stor15\n                                          stor15++\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                                  stop\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                              stor15++\n                              else:\n                                  require ext_code.size(stor0)\n                                  call stor0.getAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  require ext_call.success\n                                  uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                                  require ext_code.size(address(stor1))\n                                  call address(stor1).cbAddress() with:\n                                       gas gas_remaining - 710 wei\n                                  mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                                  require ext_call.success\n                                  require caller == ext_call.return_data[12 len 20]\n                                  require 0 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n                                  else:\n                                      require 1 < proof.length\n                                      if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                          if stor15 > 2:\n                                              log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          else:\n                                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                              require stor15 + 1 >= stor15\n                                      else:\n                                          require 2 < proof.length\n                                          if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                              if stor15 > 2:\n                                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                              else:\n                                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                      else:\n                          stor0 = 0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475\n                          require ext_code.size(stor0)\n                          call stor0.getAddress() with:\n                               gas gas_remaining - 710 wei\n                          require ext_call.success\n                          if address(stor1) != ext_call.return_data[12 len 20]:\n                              require ext_code.size(stor0)\n                              call stor0.getAddress() with:\n                                   gas gas_remaining - 710 wei\n                              require ext_call.success\n                              uint256(stor1) = ext_call.return_data[12 len 20] or Mask(96, 160, uint256(stor1))\n                          mem[ceil32(result.length) + ceil32(proof.length) + 192] = 0\n                          require ext_code.size(address(stor1))\n                          call address(stor1).cbAddress() with:\n                               gas gas_remaining - 710 wei\n                          mem[ceil32(result.length) + ceil32(proof.length) + 160] = ext_call.return_data[0]\n                          require ext_call.success\n                          require caller == ext_call.return_data[12 len 20]\n                          require 0 < proof.length\n                          if Mask(8, 248, mem[ceil32(result.length) + 160]) != 'L':\n                              if stor15 > 2:\n                                  log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                  stop\n                              log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                              require stor15 + 1 >= stor15\n                              stor15++\n                          else:\n                              require 1 < proof.length\n                              if Mask(8, 248, mem[ceil32(result.length) + 161]) != 'P':\n                                  if stor15 > 2:\n                                      log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                      stop\n                                  log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                  require stor15 + 1 >= stor15\n                                  stor15++\n                              else:\n                                  require 2 < proof.length\n                                  if Mask(8, 248, mem[ceil32(result.length) + 162]) != 0x100000000000000000000000000000000000000000000000000000000000000:\n                                      if stor15 > 2:\n                                          log LedgerFailed(string status=Array(len=8, data='Stopping'))\n                                          stop\n                                      log LedgerFailed(string status=Array(len=14, data='Requesting new'))\n                                      require stor15 + 1 >= stor15\n                                      stor15++\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
	"status": "1",
	"time_cost": 37.62534284591675,
	"usage": {
		"completion_tokens": 465,
		"prompt_tokens": 13673,
		"total_tokens": 14138
	}
}