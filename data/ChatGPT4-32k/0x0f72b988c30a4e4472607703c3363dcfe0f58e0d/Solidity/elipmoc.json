{
	"address": "0x0f72b988c30a4e4472607703c3363dcfe0f58e0d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the provided decompiled code, the corresponding Solidity smart contract would look something like this:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract TokenSale {\n    uint256 public startTimestamp;\n    uint256 public endTimestamp;\n    uint256 public exchangeRate;\n    uint256 public tokensSold;\n    uint256 public minCap;\n    uint256 public endFirstPeriodTimestamp;\n    uint256 public endSecondPeriodTimestamp;\n    uint256 public endThirdPeriodTimestamp;\n    mapping(address => uint256) public investments;\n    address public owner;\n    bool public paused;\n    IToken public token;\n    IWhitelist public whitelist;\n\n    event Pause();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Unpause();\n\n    constructor(address _token, address _whitelist) public {\n        require(_token != address(0));\n        require(_whitelist != address(0));\n        owner = msg.sender;\n        token = IToken(_token);\n        whitelist = IWhitelist(_whitelist);\n    }\n\n    function fallback() public payable {\n        require(block.timestamp >= startTimestamp && block.timestamp < endTimestamp);\n        require(whitelist.isWhitelisted(msg.sender));\n        require(!paused);\n        require(msg.value > 0x3782dace9d90000);\n        uint256 discount = calculateDiscount(msg.sender);\n        uint256 tokenAmount = calculateTokenAmount(msg.value, discount);\n        require(token.transferFromIco(msg.sender, tokenAmount));\n        tokensSold += tokenAmount;\n        investments[msg.sender] += msg.value;\n    }\n\n    // Other functions go here...\n\n    function calculateDiscount(address investor) private view returns (uint256) {\n        if (block.timestamp <= endFirstPeriodTimestamp) {\n            return 25;\n        } else if (block.timestamp <= endSecondPeriodTimestamp) {\n            return 15;\n        } else if (block.timestamp <= endThirdPeriodTimestamp) {\n            return 5;\n        } else {\n            return 0;\n        }\n    }\n\n    function calculateTokenAmount(uint256 weiAmount, uint256 discount) private view returns (uint256) {\n        uint256 tokenAmount = weiAmount * exchangeRate;\n        return tokenAmount * (100 + discount) / 100;\n    }\n}\n\ninterface IToken {\n    function transferFromIco(address to, uint256 value) external returns (bool);\n}\n\ninterface IWhitelist {\n    function isWhitelisted(address investor) external view returns (bool);\n}\n```\n\nPlease note that this is a simplified contract based on the decompiled code. There are several functions and checks missing. Also, the contract assumes that the token and the whitelist are separate contracts that are passed into the constructor, represented by `IToken` and `IWhitelist` interfaces respectively.\n\nPlease also note that this is a basic implementation and might not cover all the functionalities from the decompiled code. You might need to add more functions, events and modifiers based on the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456198,
	"id": "chatcmpl-8R2lq5aZPlvskS90iELBlxbc08cw8",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 06:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startTimestamp; // STORAGE[0x1]\nuint256 _endTimestamp; // STORAGE[0x2]\nuint256 _exchangeRate; // STORAGE[0x3]\nuint256 _tokensSold; // STORAGE[0x4]\nuint256 _minCap; // STORAGE[0x5]\nuint256 _endFirstPeriodTimestamp; // STORAGE[0x6]\nuint256 _endSecondPeriodTimestamp; // STORAGE[0x7]\nuint256 _endThirdPeriodTimestamp; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _investments; // STORAGE[0xb]\naddress _updateIcoEnding; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_9_0_0; // STORAGE[0x9] bytes 0 to 0\nuint8 stor_a_0_0; // STORAGE[0xa] bytes 0 to 0\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _token; // STORAGE[0x9] bytes 0 to 19\naddress _whitelist; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nPause();\nOwnershipTransferred(address, address);\nUnpause();\n\nfunction fallback() public payable { \n    v0 = v1 = block.timestamp >= _startTimestamp;\n    if (v1) {\n        v0 = block.timestamp < _endTimestamp;\n    }\n    require(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_whitelist.code.size);\n    v2, v3 = _whitelist.isWhitelisted(msg.sender).gas(msg.gas - 710);\n    require(v2);\n    require(v3);\n    require(!_paused);\n    require(msg.value > 0x3782dace9d90000);\n    v4 = 0xb52(msg.sender);\n    v5 = 0x77e();\n    v6 = _SafeAdd(100, v4);\n    v7 = 0xe32(_exchangeRate, msg.value);\n    v8 = 0xe32(v6, v7);\n    assert(100 - v5);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v9, v10 = _token.transferFromIco(msg.sender, v8 / (100 - v5)).gas(msg.gas - 710);\n    require(v9);\n    v11 = _SafeAdd(v8 / (100 - v5), _tokensSold);\n    _tokensSold = v11;\n    v12 = _SafeAdd(msg.value, _investments[msg.sender]);\n    _investments[msg.sender] = v12;\n}\n\nfunction transferTokenOwnership(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(_token.code.size);\n    v0 = _token.transferOwnership(varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction minimumInvestment() public nonPayable { \n    return 0x3782dace9d90000;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction unpause() public nonPayable { \n    0x641();\n}\n\nfunction minCap() public nonPayable { \n    return _minCap;\n}\n\nfunction endThirdPeriodTimestamp() public nonPayable { \n    return _endThirdPeriodTimestamp;\n}\n\nfunction assignTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transferFromIco(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n    v2 = _SafeAdd(varg1, _tokensSold);\n    _tokensSold = v2;\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction discount() public nonPayable { \n    v0 = 0x77e();\n    return v0;\n}\n\nfunction endSecondPeriodTimestamp() public nonPayable { \n    return _endSecondPeriodTimestamp;\n}\n\nfunction pause() public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _updateIcoEnding;\n}\n\nfunction whitelist() public nonPayable { \n    return _whitelist;\n}\n\nfunction withdrawal(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(block.timestamp >= _endTimestamp);\n    require(varg0);\n    v0 = varg0.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n    require(_token.code.size);\n    v1 = _token.transferOwnership(msg.sender).gas(msg.gas - 710);\n    require(v1);\n}\n\nfunction investments(address varg0) public nonPayable { \n    return _investments[varg0];\n}\n\nfunction updateIcoEnding(uint256 varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    _endTimestamp = varg0;\n}\n\nfunction endTimestamp() public nonPayable { \n    return _endTimestamp;\n}\n\nfunction refundPayment() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_whitelist.code.size);\n    v0, v1 = _whitelist.isWhitelisted(msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    require(block.timestamp >= _endTimestamp);\n    require(_tokensSold < _minCap);\n    require(_investments[msg.sender] > 0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.balanceOf(msg.sender).gas(msg.gas - 710);\n    require(v2);\n    require(_token.code.size);\n    v4 = _token.burnFrom(msg.sender, v3).gas(msg.gas - 710);\n    require(v4);\n    _investments[msg.sender] = 0;\n    v5 = msg.sender.call().value(_investments[msg.sender]).gas(2300 * !_investments[msg.sender]);\n    require(v5);\n}\n\nfunction endFirstPeriodTimestamp() public nonPayable { \n    return _endFirstPeriodTimestamp;\n}\n\nfunction bonus(address varg0) public nonPayable { \n    v0 = 0xb52(varg0);\n    return v0;\n}\n\nfunction setExchangeRate(uint256 varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(block.timestamp < _startTimestamp);\n    require(varg0 > 0);\n    _exchangeRate = varg0;\n}\n\nfunction startTimestamp() public nonPayable { \n    return _startTimestamp;\n}\n\nfunction init(address varg0, address varg1) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    v0 = v1 = varg0;\n    if (varg0) {\n        v0 = varg1;\n    }\n    require(v0);\n    v2 = v3 = !_token;\n    if (!stor_9_0_0) {\n        v2 = !_whitelist;\n    }\n    require(v2);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v4, v5 = varg0.owner().gas(msg.gas - 710);\n    require(v4);\n    require(address(v5) == address(this));\n    _token = varg0;\n    _whitelist = varg1;\n    0x641();\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_updateIcoEnding, varg0);\n    _updateIcoEnding = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x641() private { \n    require(_updateIcoEnding == msg.sender);\n    require(_paused);\n    v0 = v1 = stor_9_0_0;\n    if (_token) {\n        v0 = v2 = stor_a_0_0;\n    }\n    require(v0);\n    require(_updateIcoEnding == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n    return ;\n}\n\nfunction 0x77e() private { \n    if (block.timestamp <= _endThirdPeriodTimestamp) {\n        if (block.timestamp <= _endSecondPeriodTimestamp) {\n            if (block.timestamp <= _endFirstPeriodTimestamp) {\n                v0 = v1 = 25;\n            } else {\n                v0 = v2 = 15;\n            }\n        } else {\n            v0 = v3 = 5;\n        }\n    } else {\n        v0 = v4 = 0;\n    }\n    return v0;\n}\n\nfunction 0xb52(uint256 varg0) private { \n    MEM[32 + MEM[64]] = 0;\n    v0 = address(varg0);\n    require(_whitelist.code.size);\n    v1, v2 = _whitelist.walletCreatedTimestamp(v0).gas(msg.gas - 710);\n    require(v1);\n    v3 = v4 = v2 > 0;\n    if (v4) {\n        v3 = v5 = v2 < _startTimestamp;\n    }\n    if (!v3) {\n        v6 = v7 = 0;\n    } else {\n        v6 = v8 = 10;\n    }\n    return v6;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xe32(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x21e6b53d) {\n            transferTokenOwnership(address);\n        } else if (0x2b925b25 == v0) {\n            minimumInvestment();\n        } else if (0x3ba0b9a9 == v0) {\n            exchangeRate();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x3fa615b0 == v0) {\n            minCap();\n        } else if (0x416dc762 == v0) {\n            endThirdPeriodTimestamp();\n        } else if (0x4d7edc15 == v0) {\n            assignTokens(address,uint256);\n        } else if (0x518ab2a8 == v0) {\n            tokensSold();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6b6f4a9d == v0) {\n            discount();\n        } else if (0x7f3e1841 == v0) {\n            endSecondPeriodTimestamp();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x93e59dc1 == v0) {\n            whitelist();\n        } else if (0x96131049 == v0) {\n            withdrawal(address);\n        } else if (0x96b98862 == v0) {\n            investments(address);\n        } else if (0x9904e174 != v0) {\n            if (0x9e4d4d0c == v0) {\n                updateIcoEnding(uint256);\n            } else if (0xa85adeab == v0) {\n                endTimestamp();\n            } else if (0xb65412b5 == v0) {\n                refundPayment();\n            } else if (0xc6f3a895 == v0) {\n                endFirstPeriodTimestamp();\n            } else if (0xd8cb4aa3 == v0) {\n                bonus(address);\n            } else if (0xdb068e0e == v0) {\n                setExchangeRate(uint256);\n            } else if (0xe6fd48bc == v0) {\n                startTimestamp();\n            } else if (0xf09a4016 == v0) {\n                init(address,address);\n            } else if (0xf2fde38b == v0) {\n                transferOwnership(address);\n            } else if (0xfc0c546a == v0) {\n                token();\n            }\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 06:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startTimestamp; // STORAGE[0x1]\nuint256 _endTimestamp; // STORAGE[0x2]\nuint256 _exchangeRate; // STORAGE[0x3]\nuint256 _tokensSold; // STORAGE[0x4]\nuint256 _minCap; // STORAGE[0x5]\nuint256 _endFirstPeriodTimestamp; // STORAGE[0x6]\nuint256 _endSecondPeriodTimestamp; // STORAGE[0x7]\nuint256 _endThirdPeriodTimestamp; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _investments; // STORAGE[0xb]\naddress _updateIcoEnding; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_9_0_0; // STORAGE[0x9] bytes 0 to 0\nuint8 stor_a_0_0; // STORAGE[0xa] bytes 0 to 0\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _token; // STORAGE[0x9] bytes 0 to 19\naddress _whitelist; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nPause();\nOwnershipTransferred(address, address);\nUnpause();\n\nfunction fallback() public payable { \n    v0 = v1 = block.timestamp >= _startTimestamp;\n    if (v1) {\n        v0 = block.timestamp < _endTimestamp;\n    }\n    require(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_whitelist.code.size);\n    v2, v3 = _whitelist.isWhitelisted(msg.sender).gas(msg.gas - 710);\n    require(v2);\n    require(v3);\n    require(!_paused);\n    require(msg.value > 0x3782dace9d90000);\n    v4 = 0xb52(msg.sender);\n    v5 = 0x77e();\n    v6 = _SafeAdd(100, v4);\n    v7 = 0xe32(_exchangeRate, msg.value);\n    v8 = 0xe32(v6, v7);\n    assert(100 - v5);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v9, v10 = _token.transferFromIco(msg.sender, v8 / (100 - v5)).gas(msg.gas - 710);\n    require(v9);\n    v11 = _SafeAdd(v8 / (100 - v5), _tokensSold);\n    _tokensSold = v11;\n    v12 = _SafeAdd(msg.value, _investments[msg.sender]);\n    _investments[msg.sender] = v12;\n}\n\nfunction transferTokenOwnership(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(_token.code.size);\n    v0 = _token.transferOwnership(varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction minimumInvestment() public nonPayable { \n    return 0x3782dace9d90000;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction unpause() public nonPayable { \n    0x641();\n}\n\nfunction minCap() public nonPayable { \n    return _minCap;\n}\n\nfunction endThirdPeriodTimestamp() public nonPayable { \n    return _endThirdPeriodTimestamp;\n}\n\nfunction assignTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transferFromIco(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n    v2 = _SafeAdd(varg1, _tokensSold);\n    _tokensSold = v2;\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction discount() public nonPayable { \n    v0 = 0x77e();\n    return v0;\n}\n\nfunction endSecondPeriodTimestamp() public nonPayable { \n    return _endSecondPeriodTimestamp;\n}\n\nfunction pause() public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _updateIcoEnding;\n}\n\nfunction whitelist() public nonPayable { \n    return _whitelist;\n}\n\nfunction withdrawal(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(block.timestamp >= _endTimestamp);\n    require(varg0);\n    v0 = varg0.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n    require(_token.code.size);\n    v1 = _token.transferOwnership(msg.sender).gas(msg.gas - 710);\n    require(v1);\n}\n\nfunction investments(address varg0) public nonPayable { \n    return _investments[varg0];\n}\n\nfunction updateIcoEnding(uint256 varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    _endTimestamp = varg0;\n}\n\nfunction endTimestamp() public nonPayable { \n    return _endTimestamp;\n}\n\nfunction refundPayment() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_whitelist.code.size);\n    v0, v1 = _whitelist.isWhitelisted(msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    require(block.timestamp >= _endTimestamp);\n    require(_tokensSold < _minCap);\n    require(_investments[msg.sender] > 0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.balanceOf(msg.sender).gas(msg.gas - 710);\n    require(v2);\n    require(_token.code.size);\n    v4 = _token.burnFrom(msg.sender, v3).gas(msg.gas - 710);\n    require(v4);\n    _investments[msg.sender] = 0;\n    v5 = msg.sender.call().value(_investments[msg.sender]).gas(2300 * !_investments[msg.sender]);\n    require(v5);\n}\n\nfunction endFirstPeriodTimestamp() public nonPayable { \n    return _endFirstPeriodTimestamp;\n}\n\nfunction bonus(address varg0) public nonPayable { \n    v0 = 0xb52(varg0);\n    return v0;\n}\n\nfunction setExchangeRate(uint256 varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(block.timestamp < _startTimestamp);\n    require(varg0 > 0);\n    _exchangeRate = varg0;\n}\n\nfunction startTimestamp() public nonPayable { \n    return _startTimestamp;\n}\n\nfunction init(address varg0, address varg1) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    v0 = v1 = varg0;\n    if (varg0) {\n        v0 = varg1;\n    }\n    require(v0);\n    v2 = v3 = !_token;\n    if (!stor_9_0_0) {\n        v2 = !_whitelist;\n    }\n    require(v2);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v4, v5 = varg0.owner().gas(msg.gas - 710);\n    require(v4);\n    require(address(v5) == address(this));\n    _token = varg0;\n    _whitelist = varg1;\n    0x641();\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_updateIcoEnding, varg0);\n    _updateIcoEnding = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x641() private { \n    require(_updateIcoEnding == msg.sender);\n    require(_paused);\n    v0 = v1 = stor_9_0_0;\n    if (_token) {\n        v0 = v2 = stor_a_0_0;\n    }\n    require(v0);\n    require(_updateIcoEnding == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n    return ;\n}\n\nfunction 0x77e() private { \n    if (block.timestamp <= _endThirdPeriodTimestamp) {\n        if (block.timestamp <= _endSecondPeriodTimestamp) {\n            if (block.timestamp <= _endFirstPeriodTimestamp) {\n                v0 = v1 = 25;\n            } else {\n                v0 = v2 = 15;\n            }\n        } else {\n            v0 = v3 = 5;\n        }\n    } else {\n        v0 = v4 = 0;\n    }\n    return v0;\n}\n\nfunction 0xb52(uint256 varg0) private { \n    MEM[32 + MEM[64]] = 0;\n    v0 = address(varg0);\n    require(_whitelist.code.size);\n    v1, v2 = _whitelist.walletCreatedTimestamp(v0).gas(msg.gas - 710);\n    require(v1);\n    v3 = v4 = v2 > 0;\n    if (v4) {\n        v3 = v5 = v2 < _startTimestamp;\n    }\n    if (!v3) {\n        v6 = v7 = 0;\n    } else {\n        v6 = v8 = 10;\n    }\n    return v6;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xe32(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x21e6b53d) {\n            transferTokenOwnership(address);\n        } else if (0x2b925b25 == v0) {\n            minimumInvestment();\n        } else if (0x3ba0b9a9 == v0) {\n            exchangeRate();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x3fa615b0 == v0) {\n            minCap();\n        } else if (0x416dc762 == v0) {\n            endThirdPeriodTimestamp();\n        } else if (0x4d7edc15 == v0) {\n            assignTokens(address,uint256);\n        } else if (0x518ab2a8 == v0) {\n            tokensSold();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6b6f4a9d == v0) {\n            discount();\n        } else if (0x7f3e1841 == v0) {\n            endSecondPeriodTimestamp();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x93e59dc1 == v0) {\n            whitelist();\n        } else if (0x96131049 == v0) {\n            withdrawal(address);\n        } else if (0x96b98862 == v0) {\n            investments(address);\n        } else if (0x9904e174 != v0) {\n            if (0x9e4d4d0c == v0) {\n                updateIcoEnding(uint256);\n            } else if (0xa85adeab == v0) {\n                endTimestamp();\n            } else if (0xb65412b5 == v0) {\n                refundPayment();\n            } else if (0xc6f3a895 == v0) {\n                endFirstPeriodTimestamp();\n            } else if (0xd8cb4aa3 == v0) {\n                bonus(address);\n            } else if (0xdb068e0e == v0) {\n                setExchangeRate(uint256);\n            } else if (0xe6fd48bc == v0) {\n                startTimestamp();\n            } else if (0xf09a4016 == v0) {\n                init(address,address);\n            } else if (0xf2fde38b == v0) {\n                transferOwnership(address);\n            } else if (0xfc0c546a == v0) {\n                token();\n            }\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 06:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startTimestamp; // STORAGE[0x1]\nuint256 _endTimestamp; // STORAGE[0x2]\nuint256 _exchangeRate; // STORAGE[0x3]\nuint256 _tokensSold; // STORAGE[0x4]\nuint256 _minCap; // STORAGE[0x5]\nuint256 _endFirstPeriodTimestamp; // STORAGE[0x6]\nuint256 _endSecondPeriodTimestamp; // STORAGE[0x7]\nuint256 _endThirdPeriodTimestamp; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _investments; // STORAGE[0xb]\naddress _updateIcoEnding; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_9_0_0; // STORAGE[0x9] bytes 0 to 0\nuint8 stor_a_0_0; // STORAGE[0xa] bytes 0 to 0\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _token; // STORAGE[0x9] bytes 0 to 19\naddress _whitelist; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nPause();\nOwnershipTransferred(address, address);\nUnpause();\n\nfunction fallback() public payable { \n    v0 = v1 = block.timestamp >= _startTimestamp;\n    if (v1) {\n        v0 = block.timestamp < _endTimestamp;\n    }\n    require(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_whitelist.code.size);\n    v2, v3 = _whitelist.isWhitelisted(msg.sender).gas(msg.gas - 710);\n    require(v2);\n    require(v3);\n    require(!_paused);\n    require(msg.value > 0x3782dace9d90000);\n    v4 = 0xb52(msg.sender);\n    v5 = 0x77e();\n    v6 = _SafeAdd(100, v4);\n    v7 = 0xe32(_exchangeRate, msg.value);\n    v8 = 0xe32(v6, v7);\n    assert(100 - v5);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v9, v10 = _token.transferFromIco(msg.sender, v8 / (100 - v5)).gas(msg.gas - 710);\n    require(v9);\n    v11 = _SafeAdd(v8 / (100 - v5), _tokensSold);\n    _tokensSold = v11;\n    v12 = _SafeAdd(msg.value, _investments[msg.sender]);\n    _investments[msg.sender] = v12;\n}\n\nfunction transferTokenOwnership(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(_token.code.size);\n    v0 = _token.transferOwnership(varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction minimumInvestment() public nonPayable { \n    return 0x3782dace9d90000;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction unpause() public nonPayable { \n    0x641();\n}\n\nfunction minCap() public nonPayable { \n    return _minCap;\n}\n\nfunction endThirdPeriodTimestamp() public nonPayable { \n    return _endThirdPeriodTimestamp;\n}\n\nfunction assignTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.transferFromIco(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n    v2 = _SafeAdd(varg1, _tokensSold);\n    _tokensSold = v2;\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction discount() public nonPayable { \n    v0 = 0x77e();\n    return v0;\n}\n\nfunction endSecondPeriodTimestamp() public nonPayable { \n    return _endSecondPeriodTimestamp;\n}\n\nfunction pause() public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _updateIcoEnding;\n}\n\nfunction whitelist() public nonPayable { \n    return _whitelist;\n}\n\nfunction withdrawal(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(block.timestamp >= _endTimestamp);\n    require(varg0);\n    v0 = varg0.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n    require(_token.code.size);\n    v1 = _token.transferOwnership(msg.sender).gas(msg.gas - 710);\n    require(v1);\n}\n\nfunction investments(address varg0) public nonPayable { \n    return _investments[varg0];\n}\n\nfunction updateIcoEnding(uint256 varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    _endTimestamp = varg0;\n}\n\nfunction endTimestamp() public nonPayable { \n    return _endTimestamp;\n}\n\nfunction refundPayment() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_whitelist.code.size);\n    v0, v1 = _whitelist.isWhitelisted(msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    require(block.timestamp >= _endTimestamp);\n    require(_tokensSold < _minCap);\n    require(_investments[msg.sender] > 0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.balanceOf(msg.sender).gas(msg.gas - 710);\n    require(v2);\n    require(_token.code.size);\n    v4 = _token.burnFrom(msg.sender, v3).gas(msg.gas - 710);\n    require(v4);\n    _investments[msg.sender] = 0;\n    v5 = msg.sender.call().value(_investments[msg.sender]).gas(2300 * !_investments[msg.sender]);\n    require(v5);\n}\n\nfunction endFirstPeriodTimestamp() public nonPayable { \n    return _endFirstPeriodTimestamp;\n}\n\nfunction bonus(address varg0) public nonPayable { \n    v0 = 0xb52(varg0);\n    return v0;\n}\n\nfunction setExchangeRate(uint256 varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(block.timestamp < _startTimestamp);\n    require(varg0 > 0);\n    _exchangeRate = varg0;\n}\n\nfunction startTimestamp() public nonPayable { \n    return _startTimestamp;\n}\n\nfunction init(address varg0, address varg1) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    v0 = v1 = varg0;\n    if (varg0) {\n        v0 = varg1;\n    }\n    require(v0);\n    v2 = v3 = !_token;\n    if (!stor_9_0_0) {\n        v2 = !_whitelist;\n    }\n    require(v2);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v4, v5 = varg0.owner().gas(msg.gas - 710);\n    require(v4);\n    require(address(v5) == address(this));\n    _token = varg0;\n    _whitelist = varg1;\n    0x641();\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_updateIcoEnding == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_updateIcoEnding, varg0);\n    _updateIcoEnding = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x641() private { \n    require(_updateIcoEnding == msg.sender);\n    require(_paused);\n    v0 = v1 = stor_9_0_0;\n    if (_token) {\n        v0 = v2 = stor_a_0_0;\n    }\n    require(v0);\n    require(_updateIcoEnding == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n    return ;\n}\n\nfunction 0x77e() private { \n    if (block.timestamp <= _endThirdPeriodTimestamp) {\n        if (block.timestamp <= _endSecondPeriodTimestamp) {\n            if (block.timestamp <= _endFirstPeriodTimestamp) {\n                v0 = v1 = 25;\n            } else {\n                v0 = v2 = 15;\n            }\n        } else {\n            v0 = v3 = 5;\n        }\n    } else {\n        v0 = v4 = 0;\n    }\n    return v0;\n}\n\nfunction 0xb52(uint256 varg0) private { \n    MEM[32 + MEM[64]] = 0;\n    v0 = address(varg0);\n    require(_whitelist.code.size);\n    v1, v2 = _whitelist.walletCreatedTimestamp(v0).gas(msg.gas - 710);\n    require(v1);\n    v3 = v4 = v2 > 0;\n    if (v4) {\n        v3 = v5 = v2 < _startTimestamp;\n    }\n    if (!v3) {\n        v6 = v7 = 0;\n    } else {\n        v6 = v8 = 10;\n    }\n    return v6;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xe32(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x21e6b53d) {\n            transferTokenOwnership(address);\n        } else if (0x2b925b25 == v0) {\n            minimumInvestment();\n        } else if (0x3ba0b9a9 == v0) {\n            exchangeRate();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x3fa615b0 == v0) {\n            minCap();\n        } else if (0x416dc762 == v0) {\n            endThirdPeriodTimestamp();\n        } else if (0x4d7edc15 == v0) {\n            assignTokens(address,uint256);\n        } else if (0x518ab2a8 == v0) {\n            tokensSold();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6b6f4a9d == v0) {\n            discount();\n        } else if (0x7f3e1841 == v0) {\n            endSecondPeriodTimestamp();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x93e59dc1 == v0) {\n            whitelist();\n        } else if (0x96131049 == v0) {\n            withdrawal(address);\n        } else if (0x96b98862 == v0) {\n            investments(address);\n        } else if (0x9904e174 != v0) {\n            if (0x9e4d4d0c == v0) {\n                updateIcoEnding(uint256);\n            } else if (0xa85adeab == v0) {\n                endTimestamp();\n            } else if (0xb65412b5 == v0) {\n                refundPayment();\n            } else if (0xc6f3a895 == v0) {\n                endFirstPeriodTimestamp();\n            } else if (0xd8cb4aa3 == v0) {\n                bonus(address);\n            } else if (0xdb068e0e == v0) {\n                setExchangeRate(uint256);\n            } else if (0xe6fd48bc == v0) {\n                startTimestamp();\n            } else if (0xf09a4016 == v0) {\n                init(address,address);\n            } else if (0xf2fde38b == v0) {\n                transferOwnership(address);\n            } else if (0xfc0c546a == v0) {\n                token();\n            }\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 27.794522523880005,
	"usage": {
		"completion_tokens": 623,
		"prompt_tokens": 3005,
		"total_tokens": 3628
	}
}