{
	"address": "0xbd2a43799b83d9d0ff56b85d4c140bce3d1d1c6c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a contract code to represent the decompiled bytecode:\n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract OrderManager {\n    mapping (uint256 => uint256) private _ethDeposits;\n    address private _uniswapFactory;\n\n    event DepositETH(bytes32 indexed orderID, address indexed depositor, uint256 amount, bytes orderData);\n    event OrderExecuted(bytes32 indexed orderID, address indexed from, address to, uint256 amount, uint256 rate, address indexed executor, address receiver, uint256 receivedAmount, uint256 fee);\n    event OrderCancelled(bytes32 indexed orderID, address indexed from, address to, uint256 amount, uint256 rate, address indexed executor, uint256 refund);\n\n    constructor(address uniswapFactory) {\n        _uniswapFactory = uniswapFactory;\n    }\n\n    function encodeEthOrder(address from, address to, uint256 amount, uint256 rate, address executor, bytes32 orderID, address receiver) public {\n        // implementation...\n    }\n\n    function _SafeSub(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function executeOrder(address from, address to, uint256 amount, uint256 rate, address executor, bytes memory orderData) public {\n        // implementation...\n    }\n\n    function cancelOrder(address from, address to, uint256 amount, uint256 rate, address executor, address receiver) public {\n        // implementation...\n    }\n\n    function existOrder(address from, address to, uint256 amount, uint256 rate, address executor, address receiver) public view returns (bool) {\n        // implementation...\n    }\n\n    function canExecuteOrder(address from, address to, uint256 amount, uint256 rate, address executor, address receiver) public view returns (bool) {\n        // implementation...\n    }\n\n    function encodeTokenOrder(address from, address to, uint256 amount, uint256 rate, uint256 fee, address executor, bytes32 orderID, address receiver) public {\n        // implementation...\n    }\n\n    function uniswapFactory() public view returns (address) {\n        return _uniswapFactory;\n    }\n\n    function ETH_ADDRESS() public pure returns (address) {\n        return 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n    }\n\n    function decodeOrder(bytes memory orderData) public pure returns (address from, address to, uint256 amount, uint256 rate, address executor, bytes32 orderID, address receiver) {\n        // implementation...\n    }\n\n    function ethDeposits(bytes32 orderID) public view returns (uint256) {\n        return _ethDeposits[orderID];\n    }\n\n    function vaultOfOrder(address from, address to, uint256 amount, uint256 rate, address executor, address receiver) public pure returns (address) {\n        // implementation...\n    }\n\n    fallback() external payable {\n        // implementation...\n    }\n\n    function depositEth(bytes memory orderData) public payable {\n        // implementation...\n    }\n}\n```\n\nPlease note that the actual logic inside the functions has been replaced with a comment \"// implementation...\" for brevity. The actual logic will depend on your specific use case and can be implemented accordingly.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457789,
	"id": "chatcmpl-8R3BVBmJ0WRYM0TQuhBcTVsGS1cqj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 09:56 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ethDeposits; // STORAGE[0x1]\naddress _uniswapFactory; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nDepositETH(bytes32, address, uint256, bytes);\nOrderExecuted(bytes32, address, address, uint256, uint256, address, address, address, uint256, uint256);\nOrderCancelled(bytes32, address, address, uint256, uint256, address, address, uint256);\n\nfunction encodeEthOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, bytes32 varg5, address varg6) public nonPayable { \n    require(msg.data.length - 4 >= 224);\n    v0 = new array[](varg5);\n    MEM[v0.data] = varg6;\n    v1 = new array[](224);\n    v2 = v3 = 0;\n    while (v2 < 224) {\n        MEM[v2 + v1.data] = MEM[v2 + (MEM[64] + 32)];\n        v2 += 32;\n    }\n    v4 = v5 = 224 + v1.data;\n    if (0) {\n        MEM[v5 - 0] = ~0x0 & MEM[v5 - 0];\n    }\n    return v1, v0, varg0, varg1, varg2, varg3, varg4;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v2 + v0.data] = MEM[v2 + v1.data];\n            v2 += 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x1c27(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = CREATE2(0, v1.data, v1.length, varg2);\n    v2 = address(varg1);\n    require(v2.code.size);\n    v3, v4 = v2.balanceOf(address(v0)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = address(varg0);\n    MEM[MEM[64] + 68] = v4;\n    v6 = v7 = 32 + MEM[64];\n    MEM[v7] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v5;\n    v8 = v9 = 68;\n    v10 = v11 = 32 + MEM[64];\n    while (v8 >= 32) {\n        MEM[v10] = MEM[v6];\n        v8 = v8 + ~31;\n        v10 += 32;\n        v6 += 32;\n    }\n    MEM[v10] = MEM[v6] & ~(256 ** (32 - v8) - 1) | MEM[v10] & 256 ** (32 - v8) - 1;\n    v12 = address(varg1) << 96;\n    v13 = v14 = MEM[64];\n    v15 = v16 = 88;\n    v17 = v18 = 32 + MEM[64];\n    while (v15 >= 32) {\n        MEM[v13] = MEM[v17];\n        v15 = v15 + ~31;\n        v13 += 32;\n        v17 += 32;\n    }\n    MEM[v13] = MEM[v17] & ~(256 ** (32 - v15) - 1) | MEM[v13] & 256 ** (32 - v15) - 1;\n    v19, v20 = address(v0).call(v12, v21, v21, v12).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v22 = new bytes[](RETURNDATASIZE());\n        v20 = v22.data;\n        RETURNDATACOPY(v20, 0, RETURNDATASIZE());\n    }\n    require(v19, 'error pulling tokens');\n    return v4;\n}\n\nfunction executeOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg5, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0xff & MEM[v0 + 65];\n    if (v2 < 27) {\n        v1 = v3 = 27 + v2;\n    }\n    MEM[MEM[64]] = 0;\n    v4, v5 = ecrecover(keccak256(msg.sender), v1 & 0xff, MEM[v0.data], MEM[v0 + 64]);\n    require(v4); // checks call status, propagates error data on error\n    v6 = keccak256(varg0, varg1, varg2, varg3, varg4, address(v5));\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        v7 = v8 = 0x1c27(this, varg0, v6);\n    } else {\n        v7 = v9 = _ethDeposits[v6];\n        _ethDeposits[v6] = 0;\n    }\n    require(v7 > 0, 'The order does not exists');\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg1) {\n            require(_uniswapFactory.code.size);\n            v10, v11 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(address(v11), 'The exchange should exist');\n            require(varg0.code.size);\n            v12, v13 = varg0.allowance(this, address(v11)).gas(msg.gas);\n            require(v12); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v13 < v7) {\n                if (v13) {\n                    require(varg0.code.size);\n                    v14 = varg0.approve(address(v11), 0).gas(msg.gas);\n                    require(v14); // checks call status, propagates error data on error\n                    require(RETURNDATASIZE() >= 32);\n                }\n                require(varg0.code.size);\n                v15 = varg0.approve(address(v11), ~0).gas(msg.gas);\n                require(v15); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            }\n            if (this == address(this)) {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                v16 = v17 = MEM[64];\n                v18 = v19 = address(v11);\n                v20 = v21 = 32;\n                v22 = v23 = 100;\n                v24 = v25 = 0;\n                require(v19.code.size);\n            } else {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                MEM[MEM[64] + 100] = address(this);\n                v16 = v26 = MEM[64];\n                v18 = v27 = address(v11);\n                v20 = v28 = 32;\n                v22 = v29 = 132;\n                v24 = v30 = 0;\n                require(v27.code.size);\n            }\n            v31 = v18.call(MEM[v16 len v22], MEM[v16 len v20]).value(v24).gas(msg.gas);\n            require(v31); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v32 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n            require(v32); // checks call status, propagates error data on error\n            v33 = _SafeSub(varg3, 0x95e3c50b00000000000000000000000000000000000000000000000000000000);\n            require(_uniswapFactory.code.size);\n            v34, v35 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n            require(v34); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (this == varg4) {\n                v36 = v37 = address(v35);\n                MEM[36 + MEM[64]] = ~0;\n                v38 = v39 = 32;\n                v40 = v41 = MEM[64];\n                v42 = v43 = 68;\n                require(v37.code.size);\n            } else {\n                MEM[MEM[64] + 36] = ~0;\n                MEM[MEM[64] + 68] = varg4;\n                v40 = v44 = MEM[64];\n                v36 = v45 = address(v35);\n                v38 = v46 = 32;\n                v42 = v47 = 100;\n                require(v45.code.size);\n            }\n            v48 = v36.call(MEM[v40 len v42], MEM[v40 len v38]).value(v33).gas(msg.gas);\n            require(v48); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v49 = 0xf39b5b9b00000000000000000000000000000000000000000000000000000000;\n        } else {\n            require(_uniswapFactory.code.size);\n            v50, v51 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v50); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(address(v51), 'The exchange should exist');\n            require(varg0.code.size);\n            v52, v53 = varg0.allowance(this, address(v51)).gas(msg.gas);\n            require(v52); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v53 < v7) {\n                if (v53) {\n                    require(varg0.code.size);\n                    v54 = varg0.approve(address(v51), 0).gas(msg.gas);\n                    require(v54); // checks call status, propagates error data on error\n                    require(RETURNDATASIZE() >= 32);\n                }\n                require(varg0.code.size);\n                v55 = varg0.approve(address(v51), ~0).gas(msg.gas);\n                require(v55); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            }\n            if (this == address(this)) {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                v56 = v57 = MEM[64];\n                v58 = v59 = address(v51);\n                v60 = v61 = 32;\n                v62 = v63 = 100;\n                v64 = v65 = 0;\n                require(v59.code.size);\n            } else {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                MEM[MEM[64] + 100] = address(this);\n                v56 = v66 = MEM[64];\n                v58 = v67 = address(v51);\n                v60 = v68 = 32;\n                v62 = v69 = 132;\n                v64 = v70 = 0;\n                require(v67.code.size);\n            }\n            v71 = v58.call(MEM[v56 len v62], MEM[v56 len v60]).value(v64).gas(msg.gas);\n            require(v71); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v49 = v72 = _SafeSub(varg3, v7);\n            v73 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n            require(v73); // checks call status, propagates error data on error\n            v74 = varg4.call().value(v72).gas(2300 * !v72);\n            require(v74); // checks call status, propagates error data on error\n        }\n    } else {\n        v75 = _SafeSub(varg3, v7);\n        require(_uniswapFactory.code.size);\n        v76, v77 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n        require(v76); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (this == varg4) {\n            v78 = v79 = address(v77);\n            MEM[36 + MEM[64]] = ~0;\n            v80 = v81 = 32;\n            v82 = v83 = MEM[64];\n            v84 = v85 = 68;\n            require(v79.code.size);\n        } else {\n            MEM[MEM[64] + 36] = ~0;\n            MEM[MEM[64] + 68] = varg4;\n            v82 = v86 = MEM[64];\n            v78 = v87 = address(v77);\n            v80 = v88 = 32;\n            v84 = v89 = 100;\n            require(v87.code.size);\n        }\n        v90 = v78.call(MEM[v82 len v84], MEM[v82 len v80]).value(v75).gas(msg.gas);\n        require(v90); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v49 = v91 = 0xf39b5b9b00000000000000000000000000000000000000000000000000000000;\n        v92 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n        require(v92); // checks call status, propagates error data on error\n    }\n    require(v49 >= varg2, v93, 28);\n    v93 = new array[](varg1);\n    MEM[v93.data] = varg2;\n    emit OrderExecuted(v6, varg1, varg1, varg3, varg4, address(v5), msg.sender, v7, v7, v7, v49);\n}\n\nfunction cancelOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg4 == msg.sender, 'Only the owner of the order can cancel it');\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        v1 = v2 = 0x1c27(msg.sender, varg0, v0);\n    } else {\n        v1 = v3 = _ethDeposits[v0];\n        _ethDeposits[v0] = 0;\n        v4 = msg.sender.call().value(v3).gas(2300 * !v3);\n        require(v4); // checks call status, propagates error data on error\n    }\n    emit OrderCancelled(v0, varg0, varg1, varg2, varg3, varg4, varg5, v1);\n}\n\nfunction existOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        require(varg0.code.size);\n        v1, v2 = varg0.balanceOf(address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97))).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4 = v2;\n    } else {\n        v3 = v5 = _ethDeposits[v0];\n    }\n    return v3;\n}\n\nfunction canExecuteOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        require(varg0.code.size);\n        v1, v2 = varg0.balanceOf(address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97))).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    } else {\n        v2 = v3 = _ethDeposits[v0];\n    }\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg1) {\n            require(_uniswapFactory.code.size);\n            v4, v5 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(v5)).code.size);\n            v6, v7 = address(v5).getTokenToEthInputPrice(v2).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v7 > varg3) {\n                require(_uniswapFactory.code.size);\n                v8, v9 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n                require(v8); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v10 = _SafeSub(varg3, v7);\n                require((address(v9)).code.size);\n                v11, v12 = address(v9).getEthToTokenInputPrice(v10).gas(msg.gas);\n                require(v11); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            } else {\n                v13 = v14 = 0;\n            }\n        } else {\n            require(_uniswapFactory.code.size);\n            v15, v16 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v15); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(v16)).code.size);\n            v17, v18 = address(v16).getTokenToEthInputPrice(v2).gas(msg.gas);\n            require(v17); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v18 > varg3) {\n                v12 = v19 = _SafeSub(varg3, v18);\n                goto 0x1347;\n            } else {\n                v13 = v20 = 0;\n            }\n        }\n    } else if (v2 > varg3) {\n        v21 = _SafeSub(varg3, v2);\n        require(_uniswapFactory.code.size);\n        v22, v23 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n        require(v22); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v23)).code.size);\n        v24, v12 = address(v23).getEthToTokenInputPrice(v21).gas(msg.gas);\n        require(v24); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    } else {\n        v13 = v25 = 0;\n    }\n    return v13;\n    v13 = v26 = varg2 <= v12;\n    goto 0x3450x359;\n}\n\nfunction encodeTokenOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, uint256 varg4, address varg5, bytes32 varg6, address varg7) public nonPayable { \n    require(msg.data.length - 4 >= 256);\n    v0 = keccak256(varg0, varg1, varg3, varg4, varg5, varg7);\n    MEM[MEM[64] + 32] = varg0;\n    MEM[64 + MEM[64]] = varg1;\n    MEM[MEM[64] + 96] = varg3;\n    MEM[MEM[64] + 128] = varg4;\n    MEM[MEM[64] + 160] = varg5;\n    MEM[MEM[64] + 192] = varg6;\n    MEM[MEM[64] + 224] = varg7;\n    MEM[MEM[64] + 324] = varg2;\n    MEM[MEM[64] + 356] = 96;\n    MEM[MEM[64] + 388] = 224;\n    v1 = v2 = 0;\n    while (v1 < 224) {\n        MEM[v1 + (MEM[64] + 420)] = MEM[v1 + (MEM[64] + 32)];\n        v1 += 32;\n    }\n    v3 = v4 = 224 + (MEM[64] + 420);\n    if (0) {\n        MEM[v4 - 0] = ~0x0 & MEM[v4 - 0];\n        v3 = v5 = 32 + (v4 - 0);\n    }\n    MEM[MEM[64] + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97));\n    v6 = new array[](v3 - MEM[64] + ~31);\n    v7 = v8 = 0;\n    while (v7 < v3 - MEM[64] + ~31) {\n        MEM[v7 + v6.data] = MEM[v7 + (MEM[64] + 32)];\n        v7 += 32;\n    }\n    v9 = v10 = v3 - MEM[64] + ~31 + v6.data;\n    if (0x1f & v3 - MEM[64] + ~31) {\n        MEM[v10 - (0x1f & v3 - MEM[64] + ~31)] = ~(256 ** (32 - (0x1f & v3 - MEM[64] + ~31)) - 1) & MEM[v10 - (0x1f & v3 - MEM[64] + ~31)];\n    }\n    return v6;\n}\n\nfunction uniswapFactory() public nonPayable { \n    return _uniswapFactory;\n}\n\nfunction ETH_ADDRESS() public nonPayable { \n    return 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n}\n\nfunction decodeOrder(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(v0.length >= 224);\n    return address(MEM[v0.data]), address(MEM[v0.data + 32]), MEM[v0.data + 64], MEM[v0.data + 96], address(MEM[v0.data + 128]), MEM[v0.data + 160], address(MEM[v0.data + 192]);\n}\n\nfunction ethDeposits(bytes32 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _ethDeposits[varg0];\n}\n\nfunction vaultOfOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    return address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97));\n}\n\nfunction fallback() public payable { \n}\n\nfunction depositEth(bytes varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + (?).length > 4 + (msg.data.length - 4))));\n    require(msg.value > 0, 'No value provided');\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(v0.length >= 224);\n    require(address(MEM[v0.data]) == 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, 'order is not from ETH');\n    v1 = keccak256(address(MEM[v0.data]), address(MEM[v0.data + 32]), MEM[v0.data + 64], MEM[v0.data + 96], address(MEM[v0.data + 128]), address(MEM[v0.data + 192]));\n    require(msg.value + _ethDeposits[v1] >= _ethDeposits[v1], 'SafeMath: addition overflow');\n    _ethDeposits[v1] += msg.value;\n    MEM[(?).length + v2.data] = 0;\n    emit DepositETH(v1, msg.sender, msg.value, 64 + MEM[64]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x88d13716 > function_selector >> 224) {\n            if (0x13a76c4c == function_selector >> 224) {\n                depositEth(bytes);\n            } else if (0x35f023ff == function_selector >> 224) {\n                encodeEthOrder(address,address,uint256,uint256,address,bytes32,address);\n            } else if (0x37040cb6 == function_selector >> 224) {\n                executeOrder(address,address,uint256,uint256,address,bytes);\n            } else if (0x5e0685c3 == function_selector >> 224) {\n                cancelOrder(address,address,uint256,uint256,address,address);\n            } else if (0x5faead1f == function_selector >> 224) {\n                existOrder(address,address,uint256,uint256,address,address);\n            } else if (0x7aecf6c7 == function_selector >> 224) {\n                canExecuteOrder(address,address,uint256,uint256,address,address);\n            }\n        } else if (0x88d13716 == function_selector >> 224) {\n            encodeTokenOrder(address,address,uint256,uint256,uint256,address,bytes32,address);\n        } else if (0x8bdb2afa == function_selector >> 224) {\n            uniswapFactory();\n        } else if (0xa734f06e == function_selector >> 224) {\n            ETH_ADDRESS();\n        } else if (0xb4c07547 == function_selector >> 224) {\n            decodeOrder(bytes);\n        } else if (0xebd9c39c == function_selector >> 224) {\n            ethDeposits(bytes32);\n        } else if (0xee46b466 == function_selector >> 224) {\n            vaultOfOrder(address,address,uint256,uint256,address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 09:56 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ethDeposits; // STORAGE[0x1]\naddress _uniswapFactory; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nDepositETH(bytes32, address, uint256, bytes);\nOrderExecuted(bytes32, address, address, uint256, uint256, address, address, address, uint256, uint256);\nOrderCancelled(bytes32, address, address, uint256, uint256, address, address, uint256);\n\nfunction encodeEthOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, bytes32 varg5, address varg6) public nonPayable { \n    require(msg.data.length - 4 >= 224);\n    v0 = new array[](varg5);\n    MEM[v0.data] = varg6;\n    v1 = new array[](224);\n    v2 = v3 = 0;\n    while (v2 < 224) {\n        MEM[v2 + v1.data] = MEM[v2 + (MEM[64] + 32)];\n        v2 += 32;\n    }\n    v4 = v5 = 224 + v1.data;\n    if (0) {\n        MEM[v5 - 0] = ~0x0 & MEM[v5 - 0];\n    }\n    return v1, v0, varg0, varg1, varg2, varg3, varg4;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v2 + v0.data] = MEM[v2 + v1.data];\n            v2 += 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x1c27(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = CREATE2(0, v1.data, v1.length, varg2);\n    v2 = address(varg1);\n    require(v2.code.size);\n    v3, v4 = v2.balanceOf(address(v0)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = address(varg0);\n    MEM[MEM[64] + 68] = v4;\n    v6 = v7 = 32 + MEM[64];\n    MEM[v7] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v5;\n    v8 = v9 = 68;\n    v10 = v11 = 32 + MEM[64];\n    while (v8 >= 32) {\n        MEM[v10] = MEM[v6];\n        v8 = v8 + ~31;\n        v10 += 32;\n        v6 += 32;\n    }\n    MEM[v10] = MEM[v6] & ~(256 ** (32 - v8) - 1) | MEM[v10] & 256 ** (32 - v8) - 1;\n    v12 = address(varg1) << 96;\n    v13 = v14 = MEM[64];\n    v15 = v16 = 88;\n    v17 = v18 = 32 + MEM[64];\n    while (v15 >= 32) {\n        MEM[v13] = MEM[v17];\n        v15 = v15 + ~31;\n        v13 += 32;\n        v17 += 32;\n    }\n    MEM[v13] = MEM[v17] & ~(256 ** (32 - v15) - 1) | MEM[v13] & 256 ** (32 - v15) - 1;\n    v19, v20 = address(v0).call(v12, v21, v21, v12).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v22 = new bytes[](RETURNDATASIZE());\n        v20 = v22.data;\n        RETURNDATACOPY(v20, 0, RETURNDATASIZE());\n    }\n    require(v19, 'error pulling tokens');\n    return v4;\n}\n\nfunction executeOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg5, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0xff & MEM[v0 + 65];\n    if (v2 < 27) {\n        v1 = v3 = 27 + v2;\n    }\n    MEM[MEM[64]] = 0;\n    v4, v5 = ecrecover(keccak256(msg.sender), v1 & 0xff, MEM[v0.data], MEM[v0 + 64]);\n    require(v4); // checks call status, propagates error data on error\n    v6 = keccak256(varg0, varg1, varg2, varg3, varg4, address(v5));\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        v7 = v8 = 0x1c27(this, varg0, v6);\n    } else {\n        v7 = v9 = _ethDeposits[v6];\n        _ethDeposits[v6] = 0;\n    }\n    require(v7 > 0, 'The order does not exists');\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg1) {\n            require(_uniswapFactory.code.size);\n            v10, v11 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(address(v11), 'The exchange should exist');\n            require(varg0.code.size);\n            v12, v13 = varg0.allowance(this, address(v11)).gas(msg.gas);\n            require(v12); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v13 < v7) {\n                if (v13) {\n                    require(varg0.code.size);\n                    v14 = varg0.approve(address(v11), 0).gas(msg.gas);\n                    require(v14); // checks call status, propagates error data on error\n                    require(RETURNDATASIZE() >= 32);\n                }\n                require(varg0.code.size);\n                v15 = varg0.approve(address(v11), ~0).gas(msg.gas);\n                require(v15); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            }\n            if (this == address(this)) {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                v16 = v17 = MEM[64];\n                v18 = v19 = address(v11);\n                v20 = v21 = 32;\n                v22 = v23 = 100;\n                v24 = v25 = 0;\n                require(v19.code.size);\n            } else {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                MEM[MEM[64] + 100] = address(this);\n                v16 = v26 = MEM[64];\n                v18 = v27 = address(v11);\n                v20 = v28 = 32;\n                v22 = v29 = 132;\n                v24 = v30 = 0;\n                require(v27.code.size);\n            }\n            v31 = v18.call(MEM[v16 len v22], MEM[v16 len v20]).value(v24).gas(msg.gas);\n            require(v31); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v32 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n            require(v32); // checks call status, propagates error data on error\n            v33 = _SafeSub(varg3, 0x95e3c50b00000000000000000000000000000000000000000000000000000000);\n            require(_uniswapFactory.code.size);\n            v34, v35 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n            require(v34); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (this == varg4) {\n                v36 = v37 = address(v35);\n                MEM[36 + MEM[64]] = ~0;\n                v38 = v39 = 32;\n                v40 = v41 = MEM[64];\n                v42 = v43 = 68;\n                require(v37.code.size);\n            } else {\n                MEM[MEM[64] + 36] = ~0;\n                MEM[MEM[64] + 68] = varg4;\n                v40 = v44 = MEM[64];\n                v36 = v45 = address(v35);\n                v38 = v46 = 32;\n                v42 = v47 = 100;\n                require(v45.code.size);\n            }\n            v48 = v36.call(MEM[v40 len v42], MEM[v40 len v38]).value(v33).gas(msg.gas);\n            require(v48); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v49 = 0xf39b5b9b00000000000000000000000000000000000000000000000000000000;\n        } else {\n            require(_uniswapFactory.code.size);\n            v50, v51 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v50); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(address(v51), 'The exchange should exist');\n            require(varg0.code.size);\n            v52, v53 = varg0.allowance(this, address(v51)).gas(msg.gas);\n            require(v52); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v53 < v7) {\n                if (v53) {\n                    require(varg0.code.size);\n                    v54 = varg0.approve(address(v51), 0).gas(msg.gas);\n                    require(v54); // checks call status, propagates error data on error\n                    require(RETURNDATASIZE() >= 32);\n                }\n                require(varg0.code.size);\n                v55 = varg0.approve(address(v51), ~0).gas(msg.gas);\n                require(v55); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            }\n            if (this == address(this)) {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                v56 = v57 = MEM[64];\n                v58 = v59 = address(v51);\n                v60 = v61 = 32;\n                v62 = v63 = 100;\n                v64 = v65 = 0;\n                require(v59.code.size);\n            } else {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                MEM[MEM[64] + 100] = address(this);\n                v56 = v66 = MEM[64];\n                v58 = v67 = address(v51);\n                v60 = v68 = 32;\n                v62 = v69 = 132;\n                v64 = v70 = 0;\n                require(v67.code.size);\n            }\n            v71 = v58.call(MEM[v56 len v62], MEM[v56 len v60]).value(v64).gas(msg.gas);\n            require(v71); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v49 = v72 = _SafeSub(varg3, v7);\n            v73 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n            require(v73); // checks call status, propagates error data on error\n            v74 = varg4.call().value(v72).gas(2300 * !v72);\n            require(v74); // checks call status, propagates error data on error\n        }\n    } else {\n        v75 = _SafeSub(varg3, v7);\n        require(_uniswapFactory.code.size);\n        v76, v77 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n        require(v76); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (this == varg4) {\n            v78 = v79 = address(v77);\n            MEM[36 + MEM[64]] = ~0;\n            v80 = v81 = 32;\n            v82 = v83 = MEM[64];\n            v84 = v85 = 68;\n            require(v79.code.size);\n        } else {\n            MEM[MEM[64] + 36] = ~0;\n            MEM[MEM[64] + 68] = varg4;\n            v82 = v86 = MEM[64];\n            v78 = v87 = address(v77);\n            v80 = v88 = 32;\n            v84 = v89 = 100;\n            require(v87.code.size);\n        }\n        v90 = v78.call(MEM[v82 len v84], MEM[v82 len v80]).value(v75).gas(msg.gas);\n        require(v90); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v49 = v91 = 0xf39b5b9b00000000000000000000000000000000000000000000000000000000;\n        v92 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n        require(v92); // checks call status, propagates error data on error\n    }\n    require(v49 >= varg2, v93, 28);\n    v93 = new array[](varg1);\n    MEM[v93.data] = varg2;\n    emit OrderExecuted(v6, varg1, varg1, varg3, varg4, address(v5), msg.sender, v7, v7, v7, v49);\n}\n\nfunction cancelOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg4 == msg.sender, 'Only the owner of the order can cancel it');\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        v1 = v2 = 0x1c27(msg.sender, varg0, v0);\n    } else {\n        v1 = v3 = _ethDeposits[v0];\n        _ethDeposits[v0] = 0;\n        v4 = msg.sender.call().value(v3).gas(2300 * !v3);\n        require(v4); // checks call status, propagates error data on error\n    }\n    emit OrderCancelled(v0, varg0, varg1, varg2, varg3, varg4, varg5, v1);\n}\n\nfunction existOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        require(varg0.code.size);\n        v1, v2 = varg0.balanceOf(address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97))).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4 = v2;\n    } else {\n        v3 = v5 = _ethDeposits[v0];\n    }\n    return v3;\n}\n\nfunction canExecuteOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        require(varg0.code.size);\n        v1, v2 = varg0.balanceOf(address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97))).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    } else {\n        v2 = v3 = _ethDeposits[v0];\n    }\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg1) {\n            require(_uniswapFactory.code.size);\n            v4, v5 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(v5)).code.size);\n            v6, v7 = address(v5).getTokenToEthInputPrice(v2).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v7 > varg3) {\n                require(_uniswapFactory.code.size);\n                v8, v9 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n                require(v8); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v10 = _SafeSub(varg3, v7);\n                require((address(v9)).code.size);\n                v11, v12 = address(v9).getEthToTokenInputPrice(v10).gas(msg.gas);\n                require(v11); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            } else {\n                v13 = v14 = 0;\n            }\n        } else {\n            require(_uniswapFactory.code.size);\n            v15, v16 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v15); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(v16)).code.size);\n            v17, v18 = address(v16).getTokenToEthInputPrice(v2).gas(msg.gas);\n            require(v17); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v18 > varg3) {\n                v12 = v19 = _SafeSub(varg3, v18);\n                goto 0x1347;\n            } else {\n                v13 = v20 = 0;\n            }\n        }\n    } else if (v2 > varg3) {\n        v21 = _SafeSub(varg3, v2);\n        require(_uniswapFactory.code.size);\n        v22, v23 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n        require(v22); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v23)).code.size);\n        v24, v12 = address(v23).getEthToTokenInputPrice(v21).gas(msg.gas);\n        require(v24); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    } else {\n        v13 = v25 = 0;\n    }\n    return v13;\n    v13 = v26 = varg2 <= v12;\n    goto 0x3450x359;\n}\n\nfunction encodeTokenOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, uint256 varg4, address varg5, bytes32 varg6, address varg7) public nonPayable { \n    require(msg.data.length - 4 >= 256);\n    v0 = keccak256(varg0, varg1, varg3, varg4, varg5, varg7);\n    MEM[MEM[64] + 32] = varg0;\n    MEM[64 + MEM[64]] = varg1;\n    MEM[MEM[64] + 96] = varg3;\n    MEM[MEM[64] + 128] = varg4;\n    MEM[MEM[64] + 160] = varg5;\n    MEM[MEM[64] + 192] = varg6;\n    MEM[MEM[64] + 224] = varg7;\n    MEM[MEM[64] + 324] = varg2;\n    MEM[MEM[64] + 356] = 96;\n    MEM[MEM[64] + 388] = 224;\n    v1 = v2 = 0;\n    while (v1 < 224) {\n        MEM[v1 + (MEM[64] + 420)] = MEM[v1 + (MEM[64] + 32)];\n        v1 += 32;\n    }\n    v3 = v4 = 224 + (MEM[64] + 420);\n    if (0) {\n        MEM[v4 - 0] = ~0x0 & MEM[v4 - 0];\n        v3 = v5 = 32 + (v4 - 0);\n    }\n    MEM[MEM[64] + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97));\n    v6 = new array[](v3 - MEM[64] + ~31);\n    v7 = v8 = 0;\n    while (v7 < v3 - MEM[64] + ~31) {\n        MEM[v7 + v6.data] = MEM[v7 + (MEM[64] + 32)];\n        v7 += 32;\n    }\n    v9 = v10 = v3 - MEM[64] + ~31 + v6.data;\n    if (0x1f & v3 - MEM[64] + ~31) {\n        MEM[v10 - (0x1f & v3 - MEM[64] + ~31)] = ~(256 ** (32 - (0x1f & v3 - MEM[64] + ~31)) - 1) & MEM[v10 - (0x1f & v3 - MEM[64] + ~31)];\n    }\n    return v6;\n}\n\nfunction uniswapFactory() public nonPayable { \n    return _uniswapFactory;\n}\n\nfunction ETH_ADDRESS() public nonPayable { \n    return 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n}\n\nfunction decodeOrder(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(v0.length >= 224);\n    return address(MEM[v0.data]), address(MEM[v0.data + 32]), MEM[v0.data + 64], MEM[v0.data + 96], address(MEM[v0.data + 128]), MEM[v0.data + 160], address(MEM[v0.data + 192]);\n}\n\nfunction ethDeposits(bytes32 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _ethDeposits[varg0];\n}\n\nfunction vaultOfOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    return address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97));\n}\n\nfunction fallback() public payable { \n}\n\nfunction depositEth(bytes varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + (?).length > 4 + (msg.data.length - 4))));\n    require(msg.value > 0, 'No value provided');\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(v0.length >= 224);\n    require(address(MEM[v0.data]) == 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, 'order is not from ETH');\n    v1 = keccak256(address(MEM[v0.data]), address(MEM[v0.data + 32]), MEM[v0.data + 64], MEM[v0.data + 96], address(MEM[v0.data + 128]), address(MEM[v0.data + 192]));\n    require(msg.value + _ethDeposits[v1] >= _ethDeposits[v1], 'SafeMath: addition overflow');\n    _ethDeposits[v1] += msg.value;\n    MEM[(?).length + v2.data] = 0;\n    emit DepositETH(v1, msg.sender, msg.value, 64 + MEM[64]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x88d13716 > function_selector >> 224) {\n            if (0x13a76c4c == function_selector >> 224) {\n                depositEth(bytes);\n            } else if (0x35f023ff == function_selector >> 224) {\n                encodeEthOrder(address,address,uint256,uint256,address,bytes32,address);\n            } else if (0x37040cb6 == function_selector >> 224) {\n                executeOrder(address,address,uint256,uint256,address,bytes);\n            } else if (0x5e0685c3 == function_selector >> 224) {\n                cancelOrder(address,address,uint256,uint256,address,address);\n            } else if (0x5faead1f == function_selector >> 224) {\n                existOrder(address,address,uint256,uint256,address,address);\n            } else if (0x7aecf6c7 == function_selector >> 224) {\n                canExecuteOrder(address,address,uint256,uint256,address,address);\n            }\n        } else if (0x88d13716 == function_selector >> 224) {\n            encodeTokenOrder(address,address,uint256,uint256,uint256,address,bytes32,address);\n        } else if (0x8bdb2afa == function_selector >> 224) {\n            uniswapFactory();\n        } else if (0xa734f06e == function_selector >> 224) {\n            ETH_ADDRESS();\n        } else if (0xb4c07547 == function_selector >> 224) {\n            decodeOrder(bytes);\n        } else if (0xebd9c39c == function_selector >> 224) {\n            ethDeposits(bytes32);\n        } else if (0xee46b466 == function_selector >> 224) {\n            vaultOfOrder(address,address,uint256,uint256,address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 09:56 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ethDeposits; // STORAGE[0x1]\naddress _uniswapFactory; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nDepositETH(bytes32, address, uint256, bytes);\nOrderExecuted(bytes32, address, address, uint256, uint256, address, address, address, uint256, uint256);\nOrderCancelled(bytes32, address, address, uint256, uint256, address, address, uint256);\n\nfunction encodeEthOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, bytes32 varg5, address varg6) public nonPayable { \n    require(msg.data.length - 4 >= 224);\n    v0 = new array[](varg5);\n    MEM[v0.data] = varg6;\n    v1 = new array[](224);\n    v2 = v3 = 0;\n    while (v2 < 224) {\n        MEM[v2 + v1.data] = MEM[v2 + (MEM[64] + 32)];\n        v2 += 32;\n    }\n    v4 = v5 = 224 + v1.data;\n    if (0) {\n        MEM[v5 - 0] = ~0x0 & MEM[v5 - 0];\n    }\n    return v1, v0, varg0, varg1, varg2, varg3, varg4;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v2 + v0.data] = MEM[v2 + v1.data];\n            v2 += 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x1c27(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = CREATE2(0, v1.data, v1.length, varg2);\n    v2 = address(varg1);\n    require(v2.code.size);\n    v3, v4 = v2.balanceOf(address(v0)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = address(varg0);\n    MEM[MEM[64] + 68] = v4;\n    v6 = v7 = 32 + MEM[64];\n    MEM[v7] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v5;\n    v8 = v9 = 68;\n    v10 = v11 = 32 + MEM[64];\n    while (v8 >= 32) {\n        MEM[v10] = MEM[v6];\n        v8 = v8 + ~31;\n        v10 += 32;\n        v6 += 32;\n    }\n    MEM[v10] = MEM[v6] & ~(256 ** (32 - v8) - 1) | MEM[v10] & 256 ** (32 - v8) - 1;\n    v12 = address(varg1) << 96;\n    v13 = v14 = MEM[64];\n    v15 = v16 = 88;\n    v17 = v18 = 32 + MEM[64];\n    while (v15 >= 32) {\n        MEM[v13] = MEM[v17];\n        v15 = v15 + ~31;\n        v13 += 32;\n        v17 += 32;\n    }\n    MEM[v13] = MEM[v17] & ~(256 ** (32 - v15) - 1) | MEM[v13] & 256 ** (32 - v15) - 1;\n    v19, v20 = address(v0).call(v12, v21, v21, v12).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v22 = new bytes[](RETURNDATASIZE());\n        v20 = v22.data;\n        RETURNDATACOPY(v20, 0, RETURNDATASIZE());\n    }\n    require(v19, 'error pulling tokens');\n    return v4;\n}\n\nfunction executeOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg5, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0xff & MEM[v0 + 65];\n    if (v2 < 27) {\n        v1 = v3 = 27 + v2;\n    }\n    MEM[MEM[64]] = 0;\n    v4, v5 = ecrecover(keccak256(msg.sender), v1 & 0xff, MEM[v0.data], MEM[v0 + 64]);\n    require(v4); // checks call status, propagates error data on error\n    v6 = keccak256(varg0, varg1, varg2, varg3, varg4, address(v5));\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        v7 = v8 = 0x1c27(this, varg0, v6);\n    } else {\n        v7 = v9 = _ethDeposits[v6];\n        _ethDeposits[v6] = 0;\n    }\n    require(v7 > 0, 'The order does not exists');\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg1) {\n            require(_uniswapFactory.code.size);\n            v10, v11 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(address(v11), 'The exchange should exist');\n            require(varg0.code.size);\n            v12, v13 = varg0.allowance(this, address(v11)).gas(msg.gas);\n            require(v12); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v13 < v7) {\n                if (v13) {\n                    require(varg0.code.size);\n                    v14 = varg0.approve(address(v11), 0).gas(msg.gas);\n                    require(v14); // checks call status, propagates error data on error\n                    require(RETURNDATASIZE() >= 32);\n                }\n                require(varg0.code.size);\n                v15 = varg0.approve(address(v11), ~0).gas(msg.gas);\n                require(v15); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            }\n            if (this == address(this)) {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                v16 = v17 = MEM[64];\n                v18 = v19 = address(v11);\n                v20 = v21 = 32;\n                v22 = v23 = 100;\n                v24 = v25 = 0;\n                require(v19.code.size);\n            } else {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                MEM[MEM[64] + 100] = address(this);\n                v16 = v26 = MEM[64];\n                v18 = v27 = address(v11);\n                v20 = v28 = 32;\n                v22 = v29 = 132;\n                v24 = v30 = 0;\n                require(v27.code.size);\n            }\n            v31 = v18.call(MEM[v16 len v22], MEM[v16 len v20]).value(v24).gas(msg.gas);\n            require(v31); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v32 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n            require(v32); // checks call status, propagates error data on error\n            v33 = _SafeSub(varg3, 0x95e3c50b00000000000000000000000000000000000000000000000000000000);\n            require(_uniswapFactory.code.size);\n            v34, v35 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n            require(v34); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (this == varg4) {\n                v36 = v37 = address(v35);\n                MEM[36 + MEM[64]] = ~0;\n                v38 = v39 = 32;\n                v40 = v41 = MEM[64];\n                v42 = v43 = 68;\n                require(v37.code.size);\n            } else {\n                MEM[MEM[64] + 36] = ~0;\n                MEM[MEM[64] + 68] = varg4;\n                v40 = v44 = MEM[64];\n                v36 = v45 = address(v35);\n                v38 = v46 = 32;\n                v42 = v47 = 100;\n                require(v45.code.size);\n            }\n            v48 = v36.call(MEM[v40 len v42], MEM[v40 len v38]).value(v33).gas(msg.gas);\n            require(v48); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v49 = 0xf39b5b9b00000000000000000000000000000000000000000000000000000000;\n        } else {\n            require(_uniswapFactory.code.size);\n            v50, v51 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v50); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(address(v51), 'The exchange should exist');\n            require(varg0.code.size);\n            v52, v53 = varg0.allowance(this, address(v51)).gas(msg.gas);\n            require(v52); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v53 < v7) {\n                if (v53) {\n                    require(varg0.code.size);\n                    v54 = varg0.approve(address(v51), 0).gas(msg.gas);\n                    require(v54); // checks call status, propagates error data on error\n                    require(RETURNDATASIZE() >= 32);\n                }\n                require(varg0.code.size);\n                v55 = varg0.approve(address(v51), ~0).gas(msg.gas);\n                require(v55); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            }\n            if (this == address(this)) {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                v56 = v57 = MEM[64];\n                v58 = v59 = address(v51);\n                v60 = v61 = 32;\n                v62 = v63 = 100;\n                v64 = v65 = 0;\n                require(v59.code.size);\n            } else {\n                MEM[MEM[64] + 36] = 1;\n                MEM[MEM[64] + 68] = ~0;\n                MEM[MEM[64] + 100] = address(this);\n                v56 = v66 = MEM[64];\n                v58 = v67 = address(v51);\n                v60 = v68 = 32;\n                v62 = v69 = 132;\n                v64 = v70 = 0;\n                require(v67.code.size);\n            }\n            v71 = v58.call(MEM[v56 len v62], MEM[v56 len v60]).value(v64).gas(msg.gas);\n            require(v71); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v49 = v72 = _SafeSub(varg3, v7);\n            v73 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n            require(v73); // checks call status, propagates error data on error\n            v74 = varg4.call().value(v72).gas(2300 * !v72);\n            require(v74); // checks call status, propagates error data on error\n        }\n    } else {\n        v75 = _SafeSub(varg3, v7);\n        require(_uniswapFactory.code.size);\n        v76, v77 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n        require(v76); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (this == varg4) {\n            v78 = v79 = address(v77);\n            MEM[36 + MEM[64]] = ~0;\n            v80 = v81 = 32;\n            v82 = v83 = MEM[64];\n            v84 = v85 = 68;\n            require(v79.code.size);\n        } else {\n            MEM[MEM[64] + 36] = ~0;\n            MEM[MEM[64] + 68] = varg4;\n            v82 = v86 = MEM[64];\n            v78 = v87 = address(v77);\n            v80 = v88 = 32;\n            v84 = v89 = 100;\n            require(v87.code.size);\n        }\n        v90 = v78.call(MEM[v82 len v84], MEM[v82 len v80]).value(v75).gas(msg.gas);\n        require(v90); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v49 = v91 = 0xf39b5b9b00000000000000000000000000000000000000000000000000000000;\n        v92 = msg.sender.call().value(varg3).gas(2300 * !varg3);\n        require(v92); // checks call status, propagates error data on error\n    }\n    require(v49 >= varg2, v93, 28);\n    v93 = new array[](varg1);\n    MEM[v93.data] = varg2;\n    emit OrderExecuted(v6, varg1, varg1, varg3, varg4, address(v5), msg.sender, v7, v7, v7, v49);\n}\n\nfunction cancelOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg4 == msg.sender, 'Only the owner of the order can cancel it');\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        v1 = v2 = 0x1c27(msg.sender, varg0, v0);\n    } else {\n        v1 = v3 = _ethDeposits[v0];\n        _ethDeposits[v0] = 0;\n        v4 = msg.sender.call().value(v3).gas(2300 * !v3);\n        require(v4); // checks call status, propagates error data on error\n    }\n    emit OrderCancelled(v0, varg0, varg1, varg2, varg3, varg4, varg5, v1);\n}\n\nfunction existOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        require(varg0.code.size);\n        v1, v2 = varg0.balanceOf(address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97))).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4 = v2;\n    } else {\n        v3 = v5 = _ethDeposits[v0];\n    }\n    return v3;\n}\n\nfunction canExecuteOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        require(varg0.code.size);\n        v1, v2 = varg0.balanceOf(address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97))).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    } else {\n        v2 = v3 = _ethDeposits[v0];\n    }\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg0) {\n        if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != varg1) {\n            require(_uniswapFactory.code.size);\n            v4, v5 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(v5)).code.size);\n            v6, v7 = address(v5).getTokenToEthInputPrice(v2).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v7 > varg3) {\n                require(_uniswapFactory.code.size);\n                v8, v9 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n                require(v8); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v10 = _SafeSub(varg3, v7);\n                require((address(v9)).code.size);\n                v11, v12 = address(v9).getEthToTokenInputPrice(v10).gas(msg.gas);\n                require(v11); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n            } else {\n                v13 = v14 = 0;\n            }\n        } else {\n            require(_uniswapFactory.code.size);\n            v15, v16 = _uniswapFactory.getExchange(varg0).gas(msg.gas);\n            require(v15); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(v16)).code.size);\n            v17, v18 = address(v16).getTokenToEthInputPrice(v2).gas(msg.gas);\n            require(v17); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            if (v18 > varg3) {\n                v12 = v19 = _SafeSub(varg3, v18);\n                goto 0x1347;\n            } else {\n                v13 = v20 = 0;\n            }\n        }\n    } else if (v2 > varg3) {\n        v21 = _SafeSub(varg3, v2);\n        require(_uniswapFactory.code.size);\n        v22, v23 = _uniswapFactory.getExchange(varg1).gas(msg.gas);\n        require(v22); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v23)).code.size);\n        v24, v12 = address(v23).getEthToTokenInputPrice(v21).gas(msg.gas);\n        require(v24); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    } else {\n        v13 = v25 = 0;\n    }\n    return v13;\n    v13 = v26 = varg2 <= v12;\n    goto 0x3450x359;\n}\n\nfunction encodeTokenOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, uint256 varg4, address varg5, bytes32 varg6, address varg7) public nonPayable { \n    require(msg.data.length - 4 >= 256);\n    v0 = keccak256(varg0, varg1, varg3, varg4, varg5, varg7);\n    MEM[MEM[64] + 32] = varg0;\n    MEM[64 + MEM[64]] = varg1;\n    MEM[MEM[64] + 96] = varg3;\n    MEM[MEM[64] + 128] = varg4;\n    MEM[MEM[64] + 160] = varg5;\n    MEM[MEM[64] + 192] = varg6;\n    MEM[MEM[64] + 224] = varg7;\n    MEM[MEM[64] + 324] = varg2;\n    MEM[MEM[64] + 356] = 96;\n    MEM[MEM[64] + 388] = 224;\n    v1 = v2 = 0;\n    while (v1 < 224) {\n        MEM[v1 + (MEM[64] + 420)] = MEM[v1 + (MEM[64] + 32)];\n        v1 += 32;\n    }\n    v3 = v4 = 224 + (MEM[64] + 420);\n    if (0) {\n        MEM[v4 - 0] = ~0x0 & MEM[v4 - 0];\n        v3 = v5 = 32 + (v4 - 0);\n    }\n    MEM[MEM[64] + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97));\n    v6 = new array[](v3 - MEM[64] + ~31);\n    v7 = v8 = 0;\n    while (v7 < v3 - MEM[64] + ~31) {\n        MEM[v7 + v6.data] = MEM[v7 + (MEM[64] + 32)];\n        v7 += 32;\n    }\n    v9 = v10 = v3 - MEM[64] + ~31 + v6.data;\n    if (0x1f & v3 - MEM[64] + ~31) {\n        MEM[v10 - (0x1f & v3 - MEM[64] + ~31)] = ~(256 ** (32 - (0x1f & v3 - MEM[64] + ~31)) - 1) & MEM[v10 - (0x1f & v3 - MEM[64] + ~31)];\n    }\n    return v6;\n}\n\nfunction uniswapFactory() public nonPayable { \n    return _uniswapFactory;\n}\n\nfunction ETH_ADDRESS() public nonPayable { \n    return 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n}\n\nfunction decodeOrder(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(v0.length >= 224);\n    return address(MEM[v0.data]), address(MEM[v0.data + 32]), MEM[v0.data + 64], MEM[v0.data + 96], address(MEM[v0.data + 128]), MEM[v0.data + 160], address(MEM[v0.data + 192]);\n}\n\nfunction ethDeposits(bytes32 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _ethDeposits[varg0];\n}\n\nfunction vaultOfOrder(address varg0, address varg1, uint256 varg2, uint256 varg3, address varg4, address varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = keccak256(varg0, varg1, varg2, varg3, varg4, varg5);\n    return address(keccak256(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, this, v0, 0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97));\n}\n\nfunction fallback() public payable { \n}\n\nfunction depositEth(bytes varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + (?).length > 4 + (msg.data.length - 4))));\n    require(msg.value > 0, 'No value provided');\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(v0.length >= 224);\n    require(address(MEM[v0.data]) == 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, 'order is not from ETH');\n    v1 = keccak256(address(MEM[v0.data]), address(MEM[v0.data + 32]), MEM[v0.data + 64], MEM[v0.data + 96], address(MEM[v0.data + 128]), address(MEM[v0.data + 192]));\n    require(msg.value + _ethDeposits[v1] >= _ethDeposits[v1], 'SafeMath: addition overflow');\n    _ethDeposits[v1] += msg.value;\n    MEM[(?).length + v2.data] = 0;\n    emit DepositETH(v1, msg.sender, msg.value, 64 + MEM[64]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x88d13716 > function_selector >> 224) {\n            if (0x13a76c4c == function_selector >> 224) {\n                depositEth(bytes);\n            } else if (0x35f023ff == function_selector >> 224) {\n                encodeEthOrder(address,address,uint256,uint256,address,bytes32,address);\n            } else if (0x37040cb6 == function_selector >> 224) {\n                executeOrder(address,address,uint256,uint256,address,bytes);\n            } else if (0x5e0685c3 == function_selector >> 224) {\n                cancelOrder(address,address,uint256,uint256,address,address);\n            } else if (0x5faead1f == function_selector >> 224) {\n                existOrder(address,address,uint256,uint256,address,address);\n            } else if (0x7aecf6c7 == function_selector >> 224) {\n                canExecuteOrder(address,address,uint256,uint256,address,address);\n            }\n        } else if (0x88d13716 == function_selector >> 224) {\n            encodeTokenOrder(address,address,uint256,uint256,uint256,address,bytes32,address);\n        } else if (0x8bdb2afa == function_selector >> 224) {\n            uniswapFactory();\n        } else if (0xa734f06e == function_selector >> 224) {\n            ETH_ADDRESS();\n        } else if (0xb4c07547 == function_selector >> 224) {\n            decodeOrder(bytes);\n        } else if (0xebd9c39c == function_selector >> 224) {\n            ethDeposits(bytes32);\n        } else if (0xee46b466 == function_selector >> 224) {\n            vaultOfOrder(address,address,uint256,uint256,address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 30.281312942504883,
	"usage": {
		"completion_tokens": 679,
		"prompt_tokens": 7005,
		"total_tokens": 7684
	}
}