{
	"address": "0x2aea8071b771818e0004d0e5c93fadd9d7f5d31d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The following Solidity contract attempts to replicate the decompiled EVM bytecode:\n\n```solidity\npragma solidity >=0.4.22 <0.7.0;\n\ncontract MyContract {\n    uint256 stor_3; \n    uint256 stor_4; \n    uint256 stor_5; \n    uint256 stor_6; \n    uint256 _refund; \n    mapping (address => uint256) _balances; \n    address _owner; \n    uint8 stor_6_0_0; \n    address _multisig; \n    address _token; \n    address stor_8_0_19; \n    address stor_9_0_19; \n    address stor_a_0_19; \n\n    function refund() public {\n        require((address(this).balance < _refund) && (block.timestamp > stor_3) && (_balances[msg.sender] > 0));\n        _balances[msg.sender] = 0;\n        require(msg.sender.call.value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300)());\n    }\n\n    function finishMinting() public {\n        require(msg.sender == _owner);\n        assert(stor_6_0_0 == 1);\n        if ((address(this)).balance > _refund / stor_6) {\n            require(_multisig.call.value((address(this)).balance).gas(!(address(this)).balance * 2300)());\n            require(_token.call.gas(msg.gas - 710)());\n        }\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function createTokens() public payable {\n        // Implement the function here\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner && newOwner != address(0));\n        _owner = newOwner;\n    }\n\n    function token() public view returns (address) {\n        return _token;\n    }\n\n    function _privateFunc() private {\n        // Implement the function here\n    }\n\n    function fallback() public payable {\n        // Implement the function here\n    }\n\n    function balances(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function multisig() public view returns (address) {\n        return _multisig;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / b == a);\n        return c;\n    }\n}\n```\n\nNote that the function `createTokens()`, `_privateFunc()`, and `fallback()` are not fully implemented in the provided decompiled code. The body of these functions would need to be filled in based on the intended behavior of the contract.\n\nPlease also note that `assert()` statements are used for checks that should never fail if the code is correct. In contrast, `require()` statements are used to check inputs and conditions that could potentially be false due to reasons beyond the contract's control.",
				"role": "assistant"
			}
		}
	],
	"created": 1701458107,
	"id": "chatcmpl-8R3GdETq8LZM8UkhQ62e2XFvygaku",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 01:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 _refund; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\naddress _multisig; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x2] bytes 0 to 19\nuint160 stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\nuint160 stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\nuint160 stor_a_0_19; // STORAGE[0xa] bytes 0 to 19\n\n\nfunction refund() public nonPayable { \n    v0 = v1 = (address(this)).balance < _refund;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_3;\n    }\n    if (v0) {\n        v0 = _balances[msg.sender] > 0;\n    }\n    require(v0);\n    _balances[msg.sender] = 0;\n    v3 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v3);\n}\n\nfunction finishMinting() public nonPayable { \n    require(msg.sender == _owner);\n    assert(stor_6_0_0);\n    if ((address(this)).balance > _refund / stor_6) {\n        v0 = _multisig.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v0);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v1, v2 = _token.finishMinting().gas(msg.gas - 710);\n        require(v1);\n    }\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction createTokens() public payable { \n    0x251();\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x251() private { \n    require((address(this)).balance <= stor_5);\n    v0 = v1 = block.timestamp > stor_3;\n    if (v1) {\n        v0 = v2 = block.timestamp < stor_4;\n    }\n    require(v0);\n    v3 = _SafeMul(msg.value, stor_6);\n    assert(0xde0b6b3a7640000);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v4, v5 = _token.totalSupply().gas(msg.gas - 710);\n    require(v4);\n    v6 = v7 = 0;\n    if (v5 > 0x3f870857a3e0e3800000) {\n        v8 = v9 = v5 > 0x3f870857a3e0e3800000;\n        if (v9) {\n            v8 = v10 = v5 <= 0x54b40b1f852bda000000;\n        }\n        if (!v8) {\n            v11 = v12 = v5 > 0x54b40b1f852bda000000;\n            if (v12) {\n                v11 = v13 = v5 <= 0x69e10de76676d0800000;\n            }\n            if (!v11) {\n                v14 = v15 = v5 > 0x69e10de76676d0800000;\n                if (v15) {\n                    v14 = v16 = v5 <= 0x943b1377290cbd800000;\n                }\n                if (!v14) {\n                    v17 = v18 = v5 > 0x943b1377290cbd800000;\n                    if (v18) {\n                        v17 = v19 = v5 <= 0xd3c21bcecceda1000000;\n                    }\n                    if (!v17) {\n                        if (v5 > 0xd3c21bcecceda1000000) {\n                            v6 = v20 = 0;\n                        }\n                    } else {\n                        v21 = _SafeMul(10, v3 / 0xde0b6b3a7640000);\n                        assert(100);\n                        v6 = v21 / 100;\n                    }\n                } else {\n                    v22 = _SafeMul(15, v3 / 0xde0b6b3a7640000);\n                    assert(100);\n                    v6 = v23 = v22 / 100;\n                }\n            } else {\n                v24 = _SafeMul(20, v3 / 0xde0b6b3a7640000);\n                assert(100);\n                v6 = v25 = v24 / 100;\n            }\n        } else {\n            v26 = _SafeMul(25, v3 / 0xde0b6b3a7640000);\n            assert(100);\n            v6 = v27 = v26 / 100;\n        }\n    } else {\n        v28 = _SafeMul(30, v3 / 0xde0b6b3a7640000);\n        assert(100);\n        v6 = v29 = v28 / 100;\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v30, v31 = _token.mint(msg.sender, v3 / 0xde0b6b3a7640000 + v6).gas(msg.gas - 710);\n    require(v30);\n    assert(_balances[msg.sender] + msg.value >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    v32 = _SafeMul(25, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v33, v34 = _token.mint(stor_8_0_19, v32 / 100).gas(msg.gas - 710);\n    require(v33);\n    v35 = _SafeMul(10, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v36, v37 = _token.mint(stor_9_0_19, v35 / 100).gas(msg.gas - 710);\n    require(v36);\n    v38 = _SafeMul(5, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v39, v40 = _token.mint(stor_a_0_19, v38 / 100).gas(msg.gas - 710);\n    require(v39);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x251();\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction multisig() public nonPayable { \n    return _multisig;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x4783c35b == function_selector) {\n            multisig();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 01:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 _refund; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\naddress _multisig; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x2] bytes 0 to 19\nuint160 stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\nuint160 stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\nuint160 stor_a_0_19; // STORAGE[0xa] bytes 0 to 19\n\n\nfunction refund() public nonPayable { \n    v0 = v1 = (address(this)).balance < _refund;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_3;\n    }\n    if (v0) {\n        v0 = _balances[msg.sender] > 0;\n    }\n    require(v0);\n    _balances[msg.sender] = 0;\n    v3 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v3);\n}\n\nfunction finishMinting() public nonPayable { \n    require(msg.sender == _owner);\n    assert(stor_6_0_0);\n    if ((address(this)).balance > _refund / stor_6) {\n        v0 = _multisig.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v0);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v1, v2 = _token.finishMinting().gas(msg.gas - 710);\n        require(v1);\n    }\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction createTokens() public payable { \n    0x251();\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x251() private { \n    require((address(this)).balance <= stor_5);\n    v0 = v1 = block.timestamp > stor_3;\n    if (v1) {\n        v0 = v2 = block.timestamp < stor_4;\n    }\n    require(v0);\n    v3 = _SafeMul(msg.value, stor_6);\n    assert(0xde0b6b3a7640000);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v4, v5 = _token.totalSupply().gas(msg.gas - 710);\n    require(v4);\n    v6 = v7 = 0;\n    if (v5 > 0x3f870857a3e0e3800000) {\n        v8 = v9 = v5 > 0x3f870857a3e0e3800000;\n        if (v9) {\n            v8 = v10 = v5 <= 0x54b40b1f852bda000000;\n        }\n        if (!v8) {\n            v11 = v12 = v5 > 0x54b40b1f852bda000000;\n            if (v12) {\n                v11 = v13 = v5 <= 0x69e10de76676d0800000;\n            }\n            if (!v11) {\n                v14 = v15 = v5 > 0x69e10de76676d0800000;\n                if (v15) {\n                    v14 = v16 = v5 <= 0x943b1377290cbd800000;\n                }\n                if (!v14) {\n                    v17 = v18 = v5 > 0x943b1377290cbd800000;\n                    if (v18) {\n                        v17 = v19 = v5 <= 0xd3c21bcecceda1000000;\n                    }\n                    if (!v17) {\n                        if (v5 > 0xd3c21bcecceda1000000) {\n                            v6 = v20 = 0;\n                        }\n                    } else {\n                        v21 = _SafeMul(10, v3 / 0xde0b6b3a7640000);\n                        assert(100);\n                        v6 = v21 / 100;\n                    }\n                } else {\n                    v22 = _SafeMul(15, v3 / 0xde0b6b3a7640000);\n                    assert(100);\n                    v6 = v23 = v22 / 100;\n                }\n            } else {\n                v24 = _SafeMul(20, v3 / 0xde0b6b3a7640000);\n                assert(100);\n                v6 = v25 = v24 / 100;\n            }\n        } else {\n            v26 = _SafeMul(25, v3 / 0xde0b6b3a7640000);\n            assert(100);\n            v6 = v27 = v26 / 100;\n        }\n    } else {\n        v28 = _SafeMul(30, v3 / 0xde0b6b3a7640000);\n        assert(100);\n        v6 = v29 = v28 / 100;\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v30, v31 = _token.mint(msg.sender, v3 / 0xde0b6b3a7640000 + v6).gas(msg.gas - 710);\n    require(v30);\n    assert(_balances[msg.sender] + msg.value >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    v32 = _SafeMul(25, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v33, v34 = _token.mint(stor_8_0_19, v32 / 100).gas(msg.gas - 710);\n    require(v33);\n    v35 = _SafeMul(10, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v36, v37 = _token.mint(stor_9_0_19, v35 / 100).gas(msg.gas - 710);\n    require(v36);\n    v38 = _SafeMul(5, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v39, v40 = _token.mint(stor_a_0_19, v38 / 100).gas(msg.gas - 710);\n    require(v39);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x251();\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction multisig() public nonPayable { \n    return _multisig;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x4783c35b == function_selector) {\n            multisig();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 01:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 _refund; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\naddress _multisig; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x2] bytes 0 to 19\nuint160 stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\nuint160 stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\nuint160 stor_a_0_19; // STORAGE[0xa] bytes 0 to 19\n\n\nfunction refund() public nonPayable { \n    v0 = v1 = (address(this)).balance < _refund;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_3;\n    }\n    if (v0) {\n        v0 = _balances[msg.sender] > 0;\n    }\n    require(v0);\n    _balances[msg.sender] = 0;\n    v3 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v3);\n}\n\nfunction finishMinting() public nonPayable { \n    require(msg.sender == _owner);\n    assert(stor_6_0_0);\n    if ((address(this)).balance > _refund / stor_6) {\n        v0 = _multisig.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v0);\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v1, v2 = _token.finishMinting().gas(msg.gas - 710);\n        require(v1);\n    }\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction createTokens() public payable { \n    0x251();\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x251() private { \n    require((address(this)).balance <= stor_5);\n    v0 = v1 = block.timestamp > stor_3;\n    if (v1) {\n        v0 = v2 = block.timestamp < stor_4;\n    }\n    require(v0);\n    v3 = _SafeMul(msg.value, stor_6);\n    assert(0xde0b6b3a7640000);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v4, v5 = _token.totalSupply().gas(msg.gas - 710);\n    require(v4);\n    v6 = v7 = 0;\n    if (v5 > 0x3f870857a3e0e3800000) {\n        v8 = v9 = v5 > 0x3f870857a3e0e3800000;\n        if (v9) {\n            v8 = v10 = v5 <= 0x54b40b1f852bda000000;\n        }\n        if (!v8) {\n            v11 = v12 = v5 > 0x54b40b1f852bda000000;\n            if (v12) {\n                v11 = v13 = v5 <= 0x69e10de76676d0800000;\n            }\n            if (!v11) {\n                v14 = v15 = v5 > 0x69e10de76676d0800000;\n                if (v15) {\n                    v14 = v16 = v5 <= 0x943b1377290cbd800000;\n                }\n                if (!v14) {\n                    v17 = v18 = v5 > 0x943b1377290cbd800000;\n                    if (v18) {\n                        v17 = v19 = v5 <= 0xd3c21bcecceda1000000;\n                    }\n                    if (!v17) {\n                        if (v5 > 0xd3c21bcecceda1000000) {\n                            v6 = v20 = 0;\n                        }\n                    } else {\n                        v21 = _SafeMul(10, v3 / 0xde0b6b3a7640000);\n                        assert(100);\n                        v6 = v21 / 100;\n                    }\n                } else {\n                    v22 = _SafeMul(15, v3 / 0xde0b6b3a7640000);\n                    assert(100);\n                    v6 = v23 = v22 / 100;\n                }\n            } else {\n                v24 = _SafeMul(20, v3 / 0xde0b6b3a7640000);\n                assert(100);\n                v6 = v25 = v24 / 100;\n            }\n        } else {\n            v26 = _SafeMul(25, v3 / 0xde0b6b3a7640000);\n            assert(100);\n            v6 = v27 = v26 / 100;\n        }\n    } else {\n        v28 = _SafeMul(30, v3 / 0xde0b6b3a7640000);\n        assert(100);\n        v6 = v29 = v28 / 100;\n    }\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v30, v31 = _token.mint(msg.sender, v3 / 0xde0b6b3a7640000 + v6).gas(msg.gas - 710);\n    require(v30);\n    assert(_balances[msg.sender] + msg.value >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    v32 = _SafeMul(25, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v33, v34 = _token.mint(stor_8_0_19, v32 / 100).gas(msg.gas - 710);\n    require(v33);\n    v35 = _SafeMul(10, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v36, v37 = _token.mint(stor_9_0_19, v35 / 100).gas(msg.gas - 710);\n    require(v36);\n    v38 = _SafeMul(5, v3 / 0xde0b6b3a7640000 + v6);\n    assert(100);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v39, v40 = _token.mint(stor_a_0_19, v38 / 100).gas(msg.gas - 710);\n    require(v39);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x251();\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction multisig() public nonPayable { \n    return _multisig;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x4783c35b == function_selector) {\n            multisig();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 27.838540077209473,
	"usage": {
		"completion_tokens": 641,
		"prompt_tokens": 2119,
		"total_tokens": 2760
	}
}