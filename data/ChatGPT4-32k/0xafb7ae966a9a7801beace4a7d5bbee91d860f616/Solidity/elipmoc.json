{
	"address": "0xafb7ae966a9a7801beace4a7d5bbee91d860f616",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract that corresponds to the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenContract {\n    uint256[] private _detail;\n    uint256 private _sellAmount;\n    uint256 private _weiRatio;\n    address private _tokenPrice;\n    address private tokenAddress;\n\n    event Buy(address indexed buyer, uint256 weiRatio, uint256 value, uint256 amount);\n    event TokenAddressChange(address newAddress);\n\n    function owner() public view returns (address) {\n        return _tokenPrice;\n    }\n\n    function setTokenAddress(address _address) public {\n        require(_tokenPrice == msg.sender, \"Only owner can set token address\");\n        require(_address != address(0), \"Token address cannot be null-address\");\n        tokenAddress = _address;\n        emit TokenAddressChange(_address);\n    }\n\n    function tokenBalance() public view returns (uint256) {\n        IERC20 token = IERC20(tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    function detail() public view returns (uint256[] memory) {\n        return _detail;\n    }\n\n    function withdrawToken() public {\n        require(_tokenPrice == msg.sender, \"Only owner can withdraw token\");\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(_tokenPrice, tokenBalance()));\n    }\n\n    function setTokenPrice(uint256 _price) public {\n        require(_tokenPrice == msg.sender, \"Only owner can set token price\");\n        _weiRatio = _price;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(_tokenPrice == msg.sender, \"Only owner can transfer ownership\");\n        _tokenPrice = newOwner;\n    }\n\n    function setTokenDetail(uint256[] memory _details) public {\n        require(_tokenPrice == msg.sender, \"Only owner can set token detail\");\n        _detail = _details;\n    }\n\n    fallback() external payable {\n        require(msg.value > 0, \"Must send positive value\");\n        uint256 tokenAmount = msg.value * _weiRatio;\n        require(tokenBalance() >= tokenAmount, \"Not enough tokens for sale\");\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(msg.sender, tokenAmount));\n        _sellAmount += tokenAmount;\n        emit Buy(msg.sender, _weiRatio, msg.value, tokenAmount);\n    }\n\n    function sellAmount() public view returns (uint256) {\n        return _sellAmount;\n    }\n\n    function withdrawEther() public {\n        require(_tokenPrice == msg.sender, \"Only owner can withdraw Ether\");\n        require(address(this).balance > 0, \"Not have Ether for withdraw\");\n        payable(_tokenPrice).transfer(address(this).balance);\n    }\n\n    function weiRatio() public view returns (uint256) {\n        return _weiRatio;\n    }\n}\n```\nPlease note that this contract assumes the existence of an IERC20 interface to interact with the token. It also doesn't include the `__function_selector__` function as this is automatically handled by the Ethereum Virtual Machine (EVM) and is not usually included in Solidity contracts.\nAlso, please be aware that this contract should be thoroughly tested before use in a production environment.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461683,
	"id": "chatcmpl-8R4CJ73S2PQyXpwkLsF5C1TIONovX",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 19:11 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _detail; // STORAGE[0x2]\nuint256 _sellAmount; // STORAGE[0x3]\nuint256 _weiRatio; // STORAGE[0x4]\naddress _tokenPrice; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nBuy(address, uint256, uint256, uint256);\nTokenAddressChange(address);\n\nfunction owner() public nonPayable { \n    return _tokenPrice;\n}\n\nfunction tokenAddress(address varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    require(varg0, 'Token address cannot be null-address', 'Token address cannot be null-address');\n    stor_1_0_19 = varg0;\n    emit TokenAddressChange(varg0);\n}\n\nfunction tokenBalance() public nonPayable { \n    v0 = 0x644();\n    return v0;\n}\n\nfunction Detail() public nonPayable { \n    v0 = new bytes[]((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) {\n        if (31 < (_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _detail.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction withdrawToken() public nonPayable { \n    require(_tokenPrice == msg.sender);\n    v0 = 0x644();\n    require(stor_1_0_19.code.size);\n    v1 = stor_1_0_19.transfer(_tokenPrice, v0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction tokenPrice(uint256 varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    _weiRatio = varg0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    _tokenPrice = varg0;\n}\n\nfunction tokenDetail(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(_tokenPrice == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _detail.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _detail.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _detail.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction 0x644() private { \n    require(stor_1_0_19.code.size);\n    v0, v1 = stor_1_0_19.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction fallback() public payable { \n    require(msg.sender);\n    require(msg.value > 0);\n    v0 = 0x644();\n    require(v0 >= msg.value * _weiRatio, 'Not enough tokens for sale');\n    require(stor_1_0_19.code.size);\n    v1 = stor_1_0_19.transfer(msg.sender, msg.value * _weiRatio).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _sellAmount += msg.value * _weiRatio;\n    emit Buy(msg.sender, _weiRatio, msg.value, msg.value * _weiRatio);\n}\n\nfunction SellAmount() public nonPayable { \n    return _sellAmount;\n}\n\nfunction withdrawEther() public nonPayable { \n    require(_tokenPrice == msg.sender);\n    require((address(this)).balance > 0, 'Not have Ether for withdraw');\n    v0 = _tokenPrice.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction WeiRatio() public nonPayable { \n    return _weiRatio;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x15c64f79) {\n            SellAmount();\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x7eccad5c == function_selector) {\n            WeiRatio();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9884e801 == function_selector) {\n            tokenAddress(address);\n        } else if (0x9e1a4d19 == function_selector) {\n            tokenBalance();\n        } else if (0xa250fc96 == function_selector) {\n            Detail();\n        } else if (0xca628c78 == function_selector) {\n            withdrawToken();\n        } else if (0xd4ddce8a == function_selector) {\n            tokenPrice(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfe7c2265 == function_selector) {\n            tokenDetail(string);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 19:11 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _detail; // STORAGE[0x2]\nuint256 _sellAmount; // STORAGE[0x3]\nuint256 _weiRatio; // STORAGE[0x4]\naddress _tokenPrice; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nBuy(address, uint256, uint256, uint256);\nTokenAddressChange(address);\n\nfunction owner() public nonPayable { \n    return _tokenPrice;\n}\n\nfunction tokenAddress(address varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    require(varg0, 'Token address cannot be null-address', 'Token address cannot be null-address');\n    stor_1_0_19 = varg0;\n    emit TokenAddressChange(varg0);\n}\n\nfunction tokenBalance() public nonPayable { \n    v0 = 0x644();\n    return v0;\n}\n\nfunction Detail() public nonPayable { \n    v0 = new bytes[]((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) {\n        if (31 < (_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _detail.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction withdrawToken() public nonPayable { \n    require(_tokenPrice == msg.sender);\n    v0 = 0x644();\n    require(stor_1_0_19.code.size);\n    v1 = stor_1_0_19.transfer(_tokenPrice, v0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction tokenPrice(uint256 varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    _weiRatio = varg0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    _tokenPrice = varg0;\n}\n\nfunction tokenDetail(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(_tokenPrice == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _detail.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _detail.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _detail.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction 0x644() private { \n    require(stor_1_0_19.code.size);\n    v0, v1 = stor_1_0_19.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction fallback() public payable { \n    require(msg.sender);\n    require(msg.value > 0);\n    v0 = 0x644();\n    require(v0 >= msg.value * _weiRatio, 'Not enough tokens for sale');\n    require(stor_1_0_19.code.size);\n    v1 = stor_1_0_19.transfer(msg.sender, msg.value * _weiRatio).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _sellAmount += msg.value * _weiRatio;\n    emit Buy(msg.sender, _weiRatio, msg.value, msg.value * _weiRatio);\n}\n\nfunction SellAmount() public nonPayable { \n    return _sellAmount;\n}\n\nfunction withdrawEther() public nonPayable { \n    require(_tokenPrice == msg.sender);\n    require((address(this)).balance > 0, 'Not have Ether for withdraw');\n    v0 = _tokenPrice.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction WeiRatio() public nonPayable { \n    return _weiRatio;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x15c64f79) {\n            SellAmount();\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x7eccad5c == function_selector) {\n            WeiRatio();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9884e801 == function_selector) {\n            tokenAddress(address);\n        } else if (0x9e1a4d19 == function_selector) {\n            tokenBalance();\n        } else if (0xa250fc96 == function_selector) {\n            Detail();\n        } else if (0xca628c78 == function_selector) {\n            withdrawToken();\n        } else if (0xd4ddce8a == function_selector) {\n            tokenPrice(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfe7c2265 == function_selector) {\n            tokenDetail(string);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 19:11 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _detail; // STORAGE[0x2]\nuint256 _sellAmount; // STORAGE[0x3]\nuint256 _weiRatio; // STORAGE[0x4]\naddress _tokenPrice; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nBuy(address, uint256, uint256, uint256);\nTokenAddressChange(address);\n\nfunction owner() public nonPayable { \n    return _tokenPrice;\n}\n\nfunction tokenAddress(address varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    require(varg0, 'Token address cannot be null-address', 'Token address cannot be null-address');\n    stor_1_0_19 = varg0;\n    emit TokenAddressChange(varg0);\n}\n\nfunction tokenBalance() public nonPayable { \n    v0 = 0x644();\n    return v0;\n}\n\nfunction Detail() public nonPayable { \n    v0 = new bytes[]((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) {\n        if (31 < (_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_detail.length & ~0 + (!(_detail.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _detail.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction withdrawToken() public nonPayable { \n    require(_tokenPrice == msg.sender);\n    v0 = 0x644();\n    require(stor_1_0_19.code.size);\n    v1 = stor_1_0_19.transfer(_tokenPrice, v0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction tokenPrice(uint256 varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    _weiRatio = varg0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_tokenPrice == msg.sender);\n    _tokenPrice = varg0;\n}\n\nfunction tokenDetail(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(_tokenPrice == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _detail.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _detail.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _detail.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction 0x644() private { \n    require(stor_1_0_19.code.size);\n    v0, v1 = stor_1_0_19.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction fallback() public payable { \n    require(msg.sender);\n    require(msg.value > 0);\n    v0 = 0x644();\n    require(v0 >= msg.value * _weiRatio, 'Not enough tokens for sale');\n    require(stor_1_0_19.code.size);\n    v1 = stor_1_0_19.transfer(msg.sender, msg.value * _weiRatio).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _sellAmount += msg.value * _weiRatio;\n    emit Buy(msg.sender, _weiRatio, msg.value, msg.value * _weiRatio);\n}\n\nfunction SellAmount() public nonPayable { \n    return _sellAmount;\n}\n\nfunction withdrawEther() public nonPayable { \n    require(_tokenPrice == msg.sender);\n    require((address(this)).balance > 0, 'Not have Ether for withdraw');\n    v0 = _tokenPrice.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction WeiRatio() public nonPayable { \n    return _weiRatio;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x15c64f79) {\n            SellAmount();\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x7eccad5c == function_selector) {\n            WeiRatio();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9884e801 == function_selector) {\n            tokenAddress(address);\n        } else if (0x9e1a4d19 == function_selector) {\n            tokenBalance();\n        } else if (0xa250fc96 == function_selector) {\n            Detail();\n        } else if (0xca628c78 == function_selector) {\n            withdrawToken();\n        } else if (0xd4ddce8a == function_selector) {\n            tokenPrice(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfe7c2265 == function_selector) {\n            tokenDetail(string);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 38.95781660079956,
	"usage": {
		"completion_tokens": 669,
		"prompt_tokens": 1675,
		"total_tokens": 2344
	}
}