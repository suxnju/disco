{
	"address": "0x9aca6abfe63a5ae0dc6258cefb65207ec990aa4d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract code equivalent to the decompiled code provided:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract DigiPulse {\n    string public constant name = \"DigiPulse\";\n    string public constant symbol = \"DGT\";\n    uint8 public constant decimals = 8;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) public balanceInEth;\n    address public stor2;\n    uint256 public totalSupply;\n    uint8 stor4;\n    uint256 stor54B8;\n    uint256 stor9515;\n\n    event LogTransfer(address indexed from, address indexed to, uint256 value);\n    event LogRefund(address indexed to, uint256 value);\n\n    function getRemainingSupply() public view returns (uint256) {\n        return 16125 * 10**11 - totalSupply;\n    }\n\n    function withdrawFundsToOwner(uint256 _amount) public {\n        require(stor4 > 0, \"Withdraw not allowed\");\n        require(address(this).balance >= _amount, \"Not enough balance\");\n        payable(stor2).transfer(_amount);\n    }\n\n    function refundEther() public {\n        require(stor4 == 0, \"Refund not allowed\");\n        require(balanceInEth[msg.sender] > 0, \"No balance to refund\");\n        uint256 refundAmount = balanceInEth[msg.sender];\n        balanceInEth[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n        emit LogRefund(msg.sender, refundAmount);\n    }\n\n    function transfer(address recipient, uint256 amount) public {\n        require(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\n        require(balanceOf[recipient] + amount > balanceOf[recipient], \"Addition overflow\");\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit LogTransfer(msg.sender, recipient, amount);\n    }\n\n    function finalise() public {\n        require(stor4 == 0, \"Already finalised\");\n        if (block.timestamp <= 1504223999) {\n            require(totalSupply >= 16125 * 10**11, \"Insufficient total supply\");\n        }\n        if (address(this).balance < 8000 * 10**18) {\n            stor4 = 1;\n        } else {\n            stor54B8 += 961735343125;\n            totalSupply += 961735343125;\n            stor9515 += 2 * 100 * totalSupply / 98 / 100;\n            totalSupply += 2 * 100 * totalSupply / 98 / 100;\n            stor4 = 1;\n        }\n    }\n\n    fallback() external payable {\n        require(block.timestamp > 417176 * 3600 && block.timestamp < 1504223999, \"Invalid timestamp\");\n        require(stor4 == 0, \"Fallback not allowed\");\n        require(msg.value > 0, \"No value sent\");\n        require(250 * msg.value / 10**10 < getRemainingSupply(), \"Exceeding supply\");\n        balanceInEth[msg.sender] += msg.value;\n        emit LogTransfer(address(0), msg.sender, msg.value);\n    }\n}\n```\nPlease note that some assumptions were made due to the lack of context in the decompiled code. For instance, it's not clear what `stor2`, `stor4`, `stor54B8`, and `stor9515` represent, so I kept them as generic variables. You might want to replace them with more descriptive names based on your knowledge of the original contract.\nAlso, note that the `fallback` function in Solidity is a function that is executed when the contract receives plain Ether (without data). This function cannot have arguments, cannot return anything, and must have `external` visibility. It\u2019s also important to note that contracts that receive Ether directly (without a function call, i.e. using `send()` or `transfer()`) have their fallback functions executed.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471897,
	"id": "chatcmpl-8Mui1kpF8ShKRtSZhtXZnTHZJhFHw",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst name = 'DigiPulse'\nconst decimals = 8\nconst symbol = 'DGT'\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  balanceInEth is mapping of uint256 at storage 1\n  stor2 is address at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is uint8 at storage 4\n  stor4 is uint8 at storage 4 offset 8\n  stor54B8 is uint256 at storage 0x54b86b24e0739953f0796bb6750fe9b0cc308d045b20e7ada7524ca2b1c4aa81\n  stor9515 is uint256 at storage 0x9515311a1bc0dcec2209378e0cc30da473dc304936bce99a2a09e48741c7647e\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef getBalanceInEth(address addr): # not payable\n  return balanceInEth[address(addr)]\n\n#\n#  Regular functions\n#\n\ndef getRemainingSupply(): # not payable\n  return (-totalSupply + 16125 * 10^11)\n\ndef withdrawFundsToOwner(uint256 _amount): # not payable\n  require uint8(stor4.field_8)\n  require eth.balance(this.address) >= _amount\n  call stor2 with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef refundEther(): # not payable\n  require uint8(stor4.field_0)\n  require balanceInEth[caller]\n  balanceInEth[caller] = 0\n  call caller with:\n     value balanceInEth[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xbb28353e: balanceInEth[caller], caller\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require balanceOf[caller] >= amount\n  require balanceOf[address(recipient)] + amount > balanceOf[address(recipient)]\n  balanceOf[caller] -= amount\n  balanceOf[recipient] += amount\n  log 0xddf252ad: amount, caller, recipient\n\ndef finalise(): # not payable\n  require not uint8(stor4.field_0)\n  require not uint8(stor4.field_8)\n  if block.timestamp <= 1504223999:\n      require totalSupply >= 16125 * 10^11\n  if eth.balance(this.address) < 8000 * 10^18:\n      uint8(stor4.field_0) = 1\n  else:\n      stor54B8 += 961735343125\n      totalSupply += 961735343125\n      log 0xddf252ad: 961735343125\n      log 0x0: 961735343125\n      log 0x8776a6fa: 961735343125\n      stor9515 += 2 * 100 * totalSupply / 98 / 100\n      totalSupply += 2 * 100 * totalSupply / 98 / 100\n      log 0xddf252ad: (2 * 100 * totalSupply / 98 / 100)\n      log 0x0: (2 * 100 * totalSupply / 98 / 100)\n      log 0x663f98e9: (2 * 100 * totalSupply / 98 / 100)\n      uint8(stor4.field_8) = 1\n\ndef _fallback() payable: # default function\n  require block.timestamp > 417176 * 3600\n  require block.timestamp < 1504223999\n  require not uint8(stor4.field_8)\n  require call.value\n  require 250 * call.value / 10^10 < -totalSupply + 16125 * 10^11\n  s = 0\n  s = 0\n  idx = 0\n  s = 0\n  while uint8(idx) < 4:\n      if totalSupply >= s + 375 * 10^12:\n          s = (-5 * idx) + 115\n          s = 375 * 10^12\n          idx = idx + 1\n          s = s + 375 * 10^12\n          continue \n      if 250 * call.value / 10^10:\n          s = (-5 * idx) + 115\n          s = 375 * 10^12\n          idx = idx + 1\n          s = s + 375 * 10^12\n          continue \n      balanceInEth[caller] += call.value\n      log 0xddf252ad: 0, 0, caller\n      stop\n  balanceInEth[caller] += call.value\n  log 0xddf252ad: 0, 0, caller\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'DigiPulse'\nconst decimals = 8\nconst symbol = 'DGT'\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  balanceInEth is mapping of uint256 at storage 1\n  stor2 is address at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is uint8 at storage 4\n  stor4 is uint8 at storage 4 offset 8\n  stor54B8 is uint256 at storage 0x54b86b24e0739953f0796bb6750fe9b0cc308d045b20e7ada7524ca2b1c4aa81\n  stor9515 is uint256 at storage 0x9515311a1bc0dcec2209378e0cc30da473dc304936bce99a2a09e48741c7647e\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef getBalanceInEth(address addr): # not payable\n  return balanceInEth[address(addr)]\n\n#\n#  Regular functions\n#\n\ndef getRemainingSupply(): # not payable\n  return (-totalSupply + 16125 * 10^11)\n\ndef withdrawFundsToOwner(uint256 _amount): # not payable\n  require uint8(stor4.field_8)\n  require eth.balance(this.address) >= _amount\n  call stor2 with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef refundEther(): # not payable\n  require uint8(stor4.field_0)\n  require balanceInEth[caller]\n  balanceInEth[caller] = 0\n  call caller with:\n     value balanceInEth[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xbb28353e: balanceInEth[caller], caller\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require balanceOf[caller] >= amount\n  require balanceOf[address(recipient)] + amount > balanceOf[address(recipient)]\n  balanceOf[caller] -= amount\n  balanceOf[recipient] += amount\n  log 0xddf252ad: amount, caller, recipient\n\ndef finalise(): # not payable\n  require not uint8(stor4.field_0)\n  require not uint8(stor4.field_8)\n  if block.timestamp <= 1504223999:\n      require totalSupply >= 16125 * 10^11\n  if eth.balance(this.address) < 8000 * 10^18:\n      uint8(stor4.field_0) = 1\n  else:\n      stor54B8 += 961735343125\n      totalSupply += 961735343125\n      log 0xddf252ad: 961735343125\n      log 0x0: 961735343125\n      log 0x8776a6fa: 961735343125\n      stor9515 += 2 * 100 * totalSupply / 98 / 100\n      totalSupply += 2 * 100 * totalSupply / 98 / 100\n      log 0xddf252ad: (2 * 100 * totalSupply / 98 / 100)\n      log 0x0: (2 * 100 * totalSupply / 98 / 100)\n      log 0x663f98e9: (2 * 100 * totalSupply / 98 / 100)\n      uint8(stor4.field_8) = 1\n\ndef _fallback() payable: # default function\n  require block.timestamp > 417176 * 3600\n  require block.timestamp < 1504223999\n  require not uint8(stor4.field_8)\n  require call.value\n  require 250 * call.value / 10^10 < -totalSupply + 16125 * 10^11\n  s = 0\n  s = 0\n  idx = 0\n  s = 0\n  while uint8(idx) < 4:\n      if totalSupply >= s + 375 * 10^12:\n          s = (-5 * idx) + 115\n          s = 375 * 10^12\n          idx = idx + 1\n          s = s + 375 * 10^12\n          continue \n      if 250 * call.value / 10^10:\n          s = (-5 * idx) + 115\n          s = 375 * 10^12\n          idx = idx + 1\n          s = s + 375 * 10^12\n          continue \n      balanceInEth[caller] += call.value\n      log 0xddf252ad: 0, 0, caller\n      stop\n  balanceInEth[caller] += call.value\n  log 0xddf252ad: 0, 0, caller\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'DigiPulse'\nconst decimals = 8\nconst symbol = 'DGT'\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  balanceInEth is mapping of uint256 at storage 1\n  stor2 is address at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is uint8 at storage 4\n  stor4 is uint8 at storage 4 offset 8\n  stor54B8 is uint256 at storage 0x54b86b24e0739953f0796bb6750fe9b0cc308d045b20e7ada7524ca2b1c4aa81\n  stor9515 is uint256 at storage 0x9515311a1bc0dcec2209378e0cc30da473dc304936bce99a2a09e48741c7647e\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef getBalanceInEth(address addr): # not payable\n  return balanceInEth[address(addr)]\n\n#\n#  Regular functions\n#\n\ndef getRemainingSupply(): # not payable\n  return (-totalSupply + 16125 * 10^11)\n\ndef withdrawFundsToOwner(uint256 _amount): # not payable\n  require uint8(stor4.field_8)\n  require eth.balance(this.address) >= _amount\n  call stor2 with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef refundEther(): # not payable\n  require uint8(stor4.field_0)\n  require balanceInEth[caller]\n  balanceInEth[caller] = 0\n  call caller with:\n     value balanceInEth[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xbb28353e: balanceInEth[caller], caller\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require balanceOf[caller] >= amount\n  require balanceOf[address(recipient)] + amount > balanceOf[address(recipient)]\n  balanceOf[caller] -= amount\n  balanceOf[recipient] += amount\n  log 0xddf252ad: amount, caller, recipient\n\ndef finalise(): # not payable\n  require not uint8(stor4.field_0)\n  require not uint8(stor4.field_8)\n  if block.timestamp <= 1504223999:\n      require totalSupply >= 16125 * 10^11\n  if eth.balance(this.address) < 8000 * 10^18:\n      uint8(stor4.field_0) = 1\n  else:\n      stor54B8 += 961735343125\n      totalSupply += 961735343125\n      log 0xddf252ad: 961735343125\n      log 0x0: 961735343125\n      log 0x8776a6fa: 961735343125\n      stor9515 += 2 * 100 * totalSupply / 98 / 100\n      totalSupply += 2 * 100 * totalSupply / 98 / 100\n      log 0xddf252ad: (2 * 100 * totalSupply / 98 / 100)\n      log 0x0: (2 * 100 * totalSupply / 98 / 100)\n      log 0x663f98e9: (2 * 100 * totalSupply / 98 / 100)\n      uint8(stor4.field_8) = 1\n\ndef _fallback() payable: # default function\n  require block.timestamp > 417176 * 3600\n  require block.timestamp < 1504223999\n  require not uint8(stor4.field_8)\n  require call.value\n  require 250 * call.value / 10^10 < -totalSupply + 16125 * 10^11\n  s = 0\n  s = 0\n  idx = 0\n  s = 0\n  while uint8(idx) < 4:\n      if totalSupply >= s + 375 * 10^12:\n          s = (-5 * idx) + 115\n          s = 375 * 10^12\n          idx = idx + 1\n          s = s + 375 * 10^12\n          continue \n      if 250 * call.value / 10^10:\n          s = (-5 * idx) + 115\n          s = 375 * 10^12\n          idx = idx + 1\n          s = s + 375 * 10^12\n          continue \n      balanceInEth[caller] += call.value\n      log 0xddf252ad: 0, 0, caller\n      stop\n  balanceInEth[caller] += call.value\n  log 0xddf252ad: 0, 0, caller\n\n.",
	"status": "1",
	"time_cost": 30.924152612686157,
	"usage": {
		"completion_tokens": 828,
		"prompt_tokens": 1149,
		"total_tokens": 1977
	}
}