{
	"address": "0x9798d857476de56c066abb4f8395e8f061893bac",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.29 23:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _betStart; // STORAGE[0x2]\nuint256 _betFinish; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _winBalance; // STORAGE[0x4]\nuint256 _winBalanceTotal; // STORAGE[0x5]\nuint256 _bossBalance; // STORAGE[0x6]\nuint256 _jackpotBalance; // STORAGE[0x7]\nuint256 _ntsBalance; // STORAGE[0x8]\nuint256 _prizeBalance; // STORAGE[0x9]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _refPayStation; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nOnGotMoney(address, uint256);\nOnPrizePayed(address, uint256, uint8, uint256, uint256, uint256);\nOnSendRef(address, uint256, uint256, address, address);\nOnNTSCharged(uint256);\nOnPrizeFunded(uint256);\nOnBet(address, address, uint256, uint256, uint256, uint256, uint256, uint256);\nOnCorrect(uint256);\nOnBossPayed(address, uint256, uint256);\nOnYJPCharged(uint256);\nOnNewRefPayStation(address, uint256);\nOnWithdrawWin(address, uint256);\n\nfunction () public payable { \n    emit OnGotMoney(msg.sender, msg.value);\n}\n\nfunction jackpotBalance() public nonPayable { \n    return _jackpotBalance;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (24) {\n        MEM[v0.data] = ~0xffffffffffffffff & 'BitcoinPrice.Bet Monthly';\n    }\n    return v0;\n}\n\nfunction payPrize(address varg0, uint256 varg1, uint8 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1 <= _prizeBalance);\n    _winBalance[varg0] += varg1;\n    _winBalanceTotal += varg1;\n    _prizeBalance = _prizeBalance - varg1;\n    emit OnPrizePayed(varg0, varg1, varg2 & 0xff & 0xff, varg3, varg4, varg5);\n}\n\nfunction payPostDrawRef(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg2 <= _prizeBalance);\n    _prizeBalance = _prizeBalance - varg2;\n    require(_refPayStation.code.size);\n    v0 = _refPayStation.put(varg0, varg1).value(varg2).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    emit OnSendRef(varg0, varg1, _refPayStation, varg2, block.timestamp);\n}\n\nfunction payNTS() public nonPayable { \n    require(msg.sender == _owner);\n    require(0 < _ntsBalance);\n    require(0xad0a61589f3559026f00888027beac31a5ac4625.code.size);\n    v0 = 0xad0a61589f3559026f00888027beac31a5ac4625.fund().value(_ntsBalance).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    _ntsBalance = 0;\n    emit OnNTSCharged(_ntsBalance);\n}\n\nfunction fundPrize() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = this.balance - (_winBalanceTotal + _bossBalance + _jackpotBalance + _ntsBalance + _prizeBalance);\n    require(v0 > 0);\n    _prizeBalance += v0;\n    emit OnPrizeFunded(v0);\n}\n\nfunction winBalance(address varg0) public nonPayable { \n    return _winBalance[varg0];\n}\n\nfunction prizeBalance() public nonPayable { \n    return _prizeBalance;\n}\n\nfunction bossBalance() public nonPayable { \n    return _bossBalance;\n}\n\nfunction makeBet(uint256 varg0, address varg1) public payable { \n    v0 = v1 = block.timestamp >= _betStart;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _betFinish;\n    }\n    require(v0);\n    require(msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 > 0);\n    _jackpotBalance += msg.value - msg.value / 0x16345785d8a0000 * 0x16345785d8a0000;\n    v3 = v4 = 17;\n    v5 = v6 = 0;\n    if (varg1) {\n        v3 = v7 = 25;\n        v5 = v8 = (msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 << 3) / 100;\n        require(_refPayStation.code.size);\n        v9 = _refPayStation.put(varg1, msg.sender).value(v8).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        emit OnSendRef(varg1, msg.sender, _refPayStation, v8, block.timestamp);\n    }\n    _prizeBalance += msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 - msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 * (v3 & 0xff) / 100;\n    _bossBalance += msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 * 10 / 100;\n    _jackpotBalance += (msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 << 1) / 100;\n    _ntsBalance = _ntsBalance + msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 * 5 / 100;\n    emit OnBet(msg.sender, varg1, block.timestamp, msg.value / 0x16345785d8a0000 * 0x16345785d8a0000, varg0, msg.value - msg.value / 0x16345785d8a0000 * 0x16345785d8a0000, v5, msg.value / 0x16345785d8a0000 * 0x16345785d8a0000 / 0x16345785d8a0000);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4250424d00000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction canMakeBet() public nonPayable { \n    v0 = v1 = block.timestamp >= _betStart;\n    if (v1) {\n        v0 = block.timestamp <= _betFinish;\n    }\n    return v0;\n}\n\nfunction correct() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = this.balance - (_winBalanceTotal + _bossBalance + _jackpotBalance + _ntsBalance + _prizeBalance);\n    require(v0 > 0);\n    _bossBalance += v0;\n    emit OnCorrect(v0);\n}\n\nfunction ntsBalance() public nonPayable { \n    return _ntsBalance;\n}\n\nfunction betStart() public nonPayable { \n    return _betStart;\n}\n\nfunction refPayStation() public nonPayable { \n    return _refPayStation;\n}\n\nfunction betFinish() public nonPayable { \n    return _betFinish;\n}\n\nfunction winBalanceTotal() public nonPayable { \n    return _winBalanceTotal;\n}\n\nfunction payBoss(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 <= _bossBalance);\n    if (!varg0) {\n        v0 = v1 = _bossBalance;\n    }\n    v2 = 0x42cf5e102deccf8d89e525151c5d5bbeac54200d.call().value(v0 * 90 / 100).gas(2300 * !(v0 * 90 / 100));\n    if (v2) {\n        _bossBalance = _bossBalance - v0 * 90 / 100;\n        emit OnBossPayed(0x42cf5e102deccf8d89e525151c5d5bbeac54200d, v0 * 90 / 100, block.timestamp);\n    }\n    v3 = 0x8d86e611ef0c054fdf04e1c744a8cefc37f00f81.call().value(v0 * 10 / 100).gas(2300 * !(v0 * 10 / 100));\n    if (v3) {\n        _bossBalance = _bossBalance - v0 * 10 / 100;\n        emit OnBossPayed(0x8d86e611ef0c054fdf04e1c744a8cefc37f00f81, v0 * 10 / 100, block.timestamp);\n    }\n}\n\nfunction payYearlyJackpot(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(0 < _jackpotBalance);\n    v0 = varg0.call().value(_jackpotBalance).gas(50000);\n    if (v0) {\n        _jackpotBalance = 0;\n        emit OnYJPCharged(0);\n    }\n}\n\nfunction betStep() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction newRefPayStation(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _refPayStation = varg0;\n    emit OnNewRefPayStation(varg0, block.timestamp);\n}\n\nfunction withdrawWin() public nonPayable { \n    require(0 < _winBalance[msg.sender]);\n    _winBalance[msg.sender] = 0;\n    _winBalanceTotal = _winBalanceTotal - _winBalance[msg.sender];\n    v0 = msg.sender.call().value(_winBalance[msg.sender]).gas(2300 * !_winBalance[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n    emit OnWithdrawWin(msg.sender, _winBalance[msg.sender]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x40da8f4) {\n            jackpotBalance();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0xaa9a4fb == v0) {\n            payPrize(address,uint256,uint8,uint256,uint256,uint256);\n        } else if (0xbd5b493 == v0) {\n            payPostDrawRef(address,address,uint256);\n        } else if (0x200ef97e == v0) {\n            payNTS();\n        } else if (0x3a2bc42b == v0) {\n            fundPrize();\n        } else if (0x4443fbf4 == v0) {\n            winBalance(address);\n        } else if (0x6c6bf551 == v0) {\n            prizeBalance();\n        } else if (0x8a7eac45 == v0) {\n            bossBalance();\n        } else if (0x8ade246a == v0) {\n            makeBet(uint256,address);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0xa5d8746e == v0) {\n            canMakeBet();\n        } else if (0xa9c8733c == v0) {\n            correct();\n        } else if (0xab6840e7 == v0) {\n            ntsBalance();\n        } else if (0xad8b2c77 == v0) {\n            betStart();\n        } else if (0xafafb3f0 == v0) {\n            refPayStation();\n        } else if (0xc5cbbabe == v0) {\n            betFinish();\n        } else if (0xddf8224d == v0) {\n            winBalanceTotal();\n        } else if (0xefbec487 == v0) {\n            payBoss(uint256);\n        } else if (0xf1112e70 == v0) {\n            payYearlyJackpot(address);\n        } else if (0xf4f42358 == v0) {\n            betStep();\n        } else if (0xf9146b2f == v0) {\n            newRefPayStation(address);\n        } else if (0xfb815503 == v0) {\n            withdrawWin();\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}