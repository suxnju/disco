{
	"address": "0x942eae45efbf63dfaaac03203b5ccd61d0ee77ab",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code based on the provided decompiled code:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract InvestmentContract {\n    mapping (address => uint256) private _invested;\n    mapping (address => uint256) private _bonus;\n    mapping (address => uint256) private _atBlock;\n    uint256 private _previousBalance;\n    uint256 private _interestRate;\n    uint256 private _nextBlock;\n\n    function invested(address user) public view returns(uint256) { \n        return _invested[user];\n    }\n\n    function interestRate() public view returns(uint256) { \n        return _interestRate;\n    }\n\n    function nextBlock() public view returns(uint256) { \n        return _nextBlock;\n    }\n\n    function atBlock(address user) public view returns(uint256) { \n        return _atBlock[user];\n    }\n\n    function previousBalance() public view returns(uint256) { \n        return _previousBalance;\n    }\n\n    function bonus(address user) public view returns(uint256) { \n        return _bonus[user];\n    }\n\n    function () external payable { \n        if (block.number >= _nextBlock) {\n            uint256 balance = address(this).balance;\n            if (balance < _previousBalance) {\n                balance = _previousBalance;\n            }\n            _interestRate = 1 + (balance - _previousBalance) / 0x8ac7230489e80000;\n            if (_interestRate > 20) {\n                _interestRate = 20;\n            } else if (_interestRate < 1) {\n                _interestRate = 1;\n            }\n            _previousBalance = balance;\n            _nextBlock += (1 + (block.number - _nextBlock) / 11800) * 11800;\n        }\n        if (_invested[msg.sender] > 0) {\n            uint256 interest = _atBlock[msg.sender] * _interestRate / 100 * (block.number - _atBlock[msg.sender]) / 11800;\n            if (interest > _invested[msg.sender] / 5) {\n                interest = _invested[msg.sender] / 5;\n            }\n            if (block.number - _atBlock[msg.sender] < 5800 && interest > 0x8e1bc9bf040000) {\n                interest = 0x8e1bc9bf040000;\n            }\n            if (interest > address(this).balance / 10) {\n                interest = address(this).balance / 10;\n            }\n            (bool success, ) = msg.sender.call.value(interest)(\"\"); // Forward interest to sender\n            require(success, \"Transfer failed\");\n            if (block.number - _atBlock[msg.sender] > 5800 && msg.value >= 0xde0b6b3a7640000) {\n                _invested[msg.sender] += msg.value;\n                _bonus[msg.sender] += msg.value;\n            }\n        }\n        _atBlock[msg.sender] = block.number;\n        _atBlock[msg.sender] += msg.value;\n    }\n}\n```\nNote that the \"__function_selector__\" function is not typically found in Solidity code and is not included in this contract. It is likely a part of the tool used to decompile the bytecode and doesn't have a direct equivalent in Solidity. The Ethereum Virtual Machine (EVM) uses function selectors to decide which function to call, but this is abstracted away in Solidity. Function selectors are determined by the first 4 bytes of the Keccak (SHA-3) hash of the function signature.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465831,
	"id": "chatcmpl-8R5HDNHikSV27vUzlN6ojismwFiog",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 11:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _bonus; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _atBlock; // STORAGE[0x2]\nuint256 _previousBalance; // STORAGE[0x3]\nuint256 _interestRate; // STORAGE[0x4]\nuint256 _nextBlock; // STORAGE[0x5]\n\n\nfunction invested(address varg0) public nonPayable { \n    return _invested[varg0];\n}\n\nfunction interestRate() public nonPayable { \n    return _interestRate;\n}\n\nfunction nextBlock() public nonPayable { \n    return _nextBlock;\n}\n\nfunction atBlock(address varg0) public nonPayable { \n    return _atBlock[varg0];\n}\n\nfunction previousBalance() public nonPayable { \n    return _previousBalance;\n}\n\nfunction bonus(address varg0) public nonPayable { \n    return _bonus[varg0];\n}\n\nfunction fallback() public payable { \n    if (block.number >= _nextBlock) {\n        v0 = v1 = this.balance;\n        if (v1 < _previousBalance) {\n            v0 = v2 = _previousBalance;\n        }\n        _interestRate = 1 + (v0 - _previousBalance) / 0x8ac7230489e80000;\n        if (_interestRate > 20) {\n            v3 = v4 = 20;\n        } else {\n            if (_interestRate < 1) {\n                v3 = v5 = 1;\n            } else {\n                v3 = v6 = _interestRate;\n            }\n            goto 0xd9;\n        }\n        _interestRate = v3;\n        _previousBalance = v0;\n        _nextBlock += (1 + (block.number - _nextBlock) / 11800) * 11800;\n    }\n    if (_invested[msg.sender]) {\n        v7 = v8 = _atBlock[msg.sender] * _interestRate / 100 * (block.number - _atBlock[msg.sender]) / 11800;\n        if (v8 > _invested[msg.sender] / 5) {\n            v7 = v9 = _invested[msg.sender] / 5;\n        }\n        v10 = v11 = block.number - _atBlock[msg.sender] < 5800;\n        if (v11) {\n            v10 = v12 = v7 > 0x8e1bc9bf040000;\n        }\n        if (v10) {\n            v7 = v13 = 0x8e1bc9bf040000;\n        }\n        if (v7 > this.balance / 10) {\n            v7 = v14 = this.balance / 10;\n        }\n        v15 = msg.sender.call().value(v7).gas(2300 * !v7);\n        require(v15); // checks call status, propagates error data on error\n        v16 = v17 = block.number - _atBlock[msg.sender] > 5800;\n        if (v17) {\n            v16 = v18 = msg.value >= 0xde0b6b3a7640000;\n        }\n        if (v16) {\n            _invested[msg.sender] += msg.value;\n            _bonus[msg.sender] += msg.value;\n        }\n    }\n    _atBlock[msg.sender] = block.number;\n    _atBlock[msg.sender] += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x66b3f6bf) {\n            invested(address);\n        } else if (0x7c3a00fd == function_selector) {\n            interestRate();\n        } else if (0x83788fce == function_selector) {\n            nextBlock();\n        } else if (0x8aac1362 == function_selector) {\n            atBlock(address);\n        } else if (0xb113e7ce == function_selector) {\n            previousBalance();\n        } else if (0xd8cb4aa3 == function_selector) {\n            bonus(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 11:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _bonus; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _atBlock; // STORAGE[0x2]\nuint256 _previousBalance; // STORAGE[0x3]\nuint256 _interestRate; // STORAGE[0x4]\nuint256 _nextBlock; // STORAGE[0x5]\n\n\nfunction invested(address varg0) public nonPayable { \n    return _invested[varg0];\n}\n\nfunction interestRate() public nonPayable { \n    return _interestRate;\n}\n\nfunction nextBlock() public nonPayable { \n    return _nextBlock;\n}\n\nfunction atBlock(address varg0) public nonPayable { \n    return _atBlock[varg0];\n}\n\nfunction previousBalance() public nonPayable { \n    return _previousBalance;\n}\n\nfunction bonus(address varg0) public nonPayable { \n    return _bonus[varg0];\n}\n\nfunction fallback() public payable { \n    if (block.number >= _nextBlock) {\n        v0 = v1 = this.balance;\n        if (v1 < _previousBalance) {\n            v0 = v2 = _previousBalance;\n        }\n        _interestRate = 1 + (v0 - _previousBalance) / 0x8ac7230489e80000;\n        if (_interestRate > 20) {\n            v3 = v4 = 20;\n        } else {\n            if (_interestRate < 1) {\n                v3 = v5 = 1;\n            } else {\n                v3 = v6 = _interestRate;\n            }\n            goto 0xd9;\n        }\n        _interestRate = v3;\n        _previousBalance = v0;\n        _nextBlock += (1 + (block.number - _nextBlock) / 11800) * 11800;\n    }\n    if (_invested[msg.sender]) {\n        v7 = v8 = _atBlock[msg.sender] * _interestRate / 100 * (block.number - _atBlock[msg.sender]) / 11800;\n        if (v8 > _invested[msg.sender] / 5) {\n            v7 = v9 = _invested[msg.sender] / 5;\n        }\n        v10 = v11 = block.number - _atBlock[msg.sender] < 5800;\n        if (v11) {\n            v10 = v12 = v7 > 0x8e1bc9bf040000;\n        }\n        if (v10) {\n            v7 = v13 = 0x8e1bc9bf040000;\n        }\n        if (v7 > this.balance / 10) {\n            v7 = v14 = this.balance / 10;\n        }\n        v15 = msg.sender.call().value(v7).gas(2300 * !v7);\n        require(v15); // checks call status, propagates error data on error\n        v16 = v17 = block.number - _atBlock[msg.sender] > 5800;\n        if (v17) {\n            v16 = v18 = msg.value >= 0xde0b6b3a7640000;\n        }\n        if (v16) {\n            _invested[msg.sender] += msg.value;\n            _bonus[msg.sender] += msg.value;\n        }\n    }\n    _atBlock[msg.sender] = block.number;\n    _atBlock[msg.sender] += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x66b3f6bf) {\n            invested(address);\n        } else if (0x7c3a00fd == function_selector) {\n            interestRate();\n        } else if (0x83788fce == function_selector) {\n            nextBlock();\n        } else if (0x8aac1362 == function_selector) {\n            atBlock(address);\n        } else if (0xb113e7ce == function_selector) {\n            previousBalance();\n        } else if (0xd8cb4aa3 == function_selector) {\n            bonus(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 11:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _bonus; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _atBlock; // STORAGE[0x2]\nuint256 _previousBalance; // STORAGE[0x3]\nuint256 _interestRate; // STORAGE[0x4]\nuint256 _nextBlock; // STORAGE[0x5]\n\n\nfunction invested(address varg0) public nonPayable { \n    return _invested[varg0];\n}\n\nfunction interestRate() public nonPayable { \n    return _interestRate;\n}\n\nfunction nextBlock() public nonPayable { \n    return _nextBlock;\n}\n\nfunction atBlock(address varg0) public nonPayable { \n    return _atBlock[varg0];\n}\n\nfunction previousBalance() public nonPayable { \n    return _previousBalance;\n}\n\nfunction bonus(address varg0) public nonPayable { \n    return _bonus[varg0];\n}\n\nfunction fallback() public payable { \n    if (block.number >= _nextBlock) {\n        v0 = v1 = this.balance;\n        if (v1 < _previousBalance) {\n            v0 = v2 = _previousBalance;\n        }\n        _interestRate = 1 + (v0 - _previousBalance) / 0x8ac7230489e80000;\n        if (_interestRate > 20) {\n            v3 = v4 = 20;\n        } else {\n            if (_interestRate < 1) {\n                v3 = v5 = 1;\n            } else {\n                v3 = v6 = _interestRate;\n            }\n            goto 0xd9;\n        }\n        _interestRate = v3;\n        _previousBalance = v0;\n        _nextBlock += (1 + (block.number - _nextBlock) / 11800) * 11800;\n    }\n    if (_invested[msg.sender]) {\n        v7 = v8 = _atBlock[msg.sender] * _interestRate / 100 * (block.number - _atBlock[msg.sender]) / 11800;\n        if (v8 > _invested[msg.sender] / 5) {\n            v7 = v9 = _invested[msg.sender] / 5;\n        }\n        v10 = v11 = block.number - _atBlock[msg.sender] < 5800;\n        if (v11) {\n            v10 = v12 = v7 > 0x8e1bc9bf040000;\n        }\n        if (v10) {\n            v7 = v13 = 0x8e1bc9bf040000;\n        }\n        if (v7 > this.balance / 10) {\n            v7 = v14 = this.balance / 10;\n        }\n        v15 = msg.sender.call().value(v7).gas(2300 * !v7);\n        require(v15); // checks call status, propagates error data on error\n        v16 = v17 = block.number - _atBlock[msg.sender] > 5800;\n        if (v17) {\n            v16 = v18 = msg.value >= 0xde0b6b3a7640000;\n        }\n        if (v16) {\n            _invested[msg.sender] += msg.value;\n            _bonus[msg.sender] += msg.value;\n        }\n    }\n    _atBlock[msg.sender] = block.number;\n    _atBlock[msg.sender] += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x66b3f6bf) {\n            invested(address);\n        } else if (0x7c3a00fd == function_selector) {\n            interestRate();\n        } else if (0x83788fce == function_selector) {\n            nextBlock();\n        } else if (0x8aac1362 == function_selector) {\n            atBlock(address);\n        } else if (0xb113e7ce == function_selector) {\n            previousBalance();\n        } else if (0xd8cb4aa3 == function_selector) {\n            bonus(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 45.35468077659607,
	"usage": {
		"completion_tokens": 748,
		"prompt_tokens": 1030,
		"total_tokens": 1778
	}
}