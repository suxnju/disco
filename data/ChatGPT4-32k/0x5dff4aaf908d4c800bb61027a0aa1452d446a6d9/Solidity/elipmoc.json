{
	"address": "0x5dff4aaf908d4c800bb61027a0aa1452d446a6d9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity contract based on the decompiled EVM Bytecode is as follows:\n\n```solidity\npragma solidity >=0.6.0 <0.8.0;\n\ncontract SmartContract {\n    mapping (uint256 => uint256) private _ownerMap;\n    uint256[] private _ownerHistoryCount;\n    uint256 private _balance1;\n    uint256 private _balance2;\n    uint256 private _minPaymentWei;\n    uint256 private _tokensPerWei;\n    uint256 private _maxCapTokens;\n    uint256 private _totalTokensSold;\n    uint256 private _totalWeiReceived;\n    mapping (uint256 => uint256) private _isBuyer;\n    address private _owner1;\n    uint8 private _paused;\n    address private _pendingOwner1;\n    address private _owner2;\n    address private _pendingOwner2;\n    address private _token;\n\n    event ReceiveEthEvent(address indexed sender, uint256 value);\n    event ChangeTokenEvent(address indexed oldToken, address newToken);\n    event OwnerRemovedEvent(address indexed owner);\n    event ChangeTokenPriceEvent(uint256 oldPrice, uint256 newPrice);\n    event ChangeMaxCapTokensEvent(uint256 oldCap, uint256 newCap);\n\n    function fallback() external payable {\n        _process(msg.value, msg.sender);\n    }\n\n    function resume() external {\n        require(msg.sender == _owner1 || msg.sender == _owner2, \"Not authorized\");\n        require(_paused == 1, \"Already running\");\n        _paused = 0;\n    }\n\n    function isSuperOwner(address owner) external view returns (bool) {\n        return owner == _owner1 || owner == _owner2;\n    }\n\n    function setToken(address newToken) external {\n        require(msg.sender == _owner1 || msg.sender == _owner2, \"Not authorized\");\n        require(newToken != address(0), \"Invalid token address\");\n        require(_token != newToken, \"Already set as token address\");\n        emit ChangeTokenEvent(_token, newToken);\n        _token = newToken;\n    }\n\n    function removeOwner(address owner) external {\n        require(msg.sender == _owner1 || msg.sender == _owner2, \"Not authorized\");\n        require(_ownerMap[uint256(owner)] & 0xff != 0, \"Not an owner\");\n        _ownerMap[uint256(owner)] = ~uint256(0xff) & _ownerMap[uint256(owner)];\n        emit OwnerRemovedEvent(owner);\n    }\n\n    // ... other functions based on the decompiled code ...\n\n   function _process(uint256 value, address sender) private {\n        require(_paused == 0, \"Paused\");\n        require(value >= _minPaymentWei, \"Payment too low\");\n        uint256 tokens = _tokensPerWei * value;\n        require(_totalTokensSold + tokens <= _maxCapTokens, \"Cap exceeded\");\n        // ... more logic based on the decompiled code ...\n    }\n}\n```\n\nPlease note that the provided decompiled code is incomplete and quite ambiguous. This reconstruction might not accurately represent the original contract. The decompiled code does not provide all the necessary information, such as the complete contract structure, contract and function visibility, function modifiers, and event declarations. The reconstructed contract above is a rough approximation based on the available decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701466135,
	"id": "chatcmpl-8R5M7odslqhK7a9c1Foh5Bwk2zilj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 18:28 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ownerMap; // STORAGE[0x4]\nuint256[] _ownerHistoryCount; // STORAGE[0x5]\nuint256 _balance1; // STORAGE[0x7]\nuint256 _balance2; // STORAGE[0x8]\nuint256 _minPaymentWei; // STORAGE[0xa]\nuint256 _tokensPerWei; // STORAGE[0xb]\nuint256 _maxCapTokens; // STORAGE[0xc]\nuint256 _totalTokensSold; // STORAGE[0xd]\nuint256 _totalWeiReceived; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _isBuyer; // STORAGE[0xf]\naddress _owner1; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x6] bytes 0 to 0\naddress _pendingOwner1; // STORAGE[0x1] bytes 0 to 19\naddress _owner2; // STORAGE[0x2] bytes 0 to 19\naddress _pendingOwner2; // STORAGE[0x3] bytes 0 to 19\naddress _token; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nReceiveEthEvent(address, uint256);\nChangeTokenEvent(address, address);\nOwnerRemovedEvent(address);\nChangeTokenPriceEvent(uint256, uint256);\nChangeMaxCapTokensEvent(uint256, uint256);\n\nfunction fallback() public payable { \n    0x513(msg.value, msg.sender);\n}\n\nfunction resume() public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(_paused);\n    _paused = 0;\n}\n\nfunction isSuperOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == varg0;\n    if (_owner1 != varg0) {\n        v0 = v2 = _owner2 == varg0;\n    }\n    return v0;\n}\n\nfunction setToken(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    require(_token != varg0);\n    emit ChangeTokenEvent(_token, varg0);\n    _token = varg0;\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(0xff & _ownerMap[varg0]);\n    _ownerMap[varg0] = ~0xff & _ownerMap[varg0];\n    emit OwnerRemovedEvent(varg0);\n}\n\nfunction tokensPerWei() public nonPayable { \n    return _tokensPerWei;\n}\n\nfunction isBuyer(address varg0) public nonPayable { \n    return 0xff & _isBuyer[varg0];\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    v0 = 0x86a(varg0);\n    return v0;\n}\n\nfunction ownerHistoryCount() public nonPayable { \n    return _ownerHistoryCount.length;\n}\n\nfunction balance2() public nonPayable { \n    return _balance2;\n}\n\nfunction claimOwnership1() public nonPayable { \n    require(_pendingOwner1 == msg.sender);\n    _owner1 = _pendingOwner1;\n    _pendingOwner1 = 0;\n}\n\nfunction ownerHistory(uint256 varg0) public nonPayable { \n    assert(varg0 < _ownerHistoryCount.length);\n    return address(_ownerHistoryCount[varg0]);\n}\n\nfunction withdraw2(address varg0) public nonPayable { \n    require(_owner2 == msg.sender);\n    if (_balance2 > 0) {\n        v0 = varg0.call().value(_balance2).gas(!_balance2 * 2300);\n        require(v0);\n    }\n}\n\nfunction owner2() public nonPayable { \n    return _owner2;\n}\n\nfunction weiToTokens(uint256 varg0) public nonPayable { \n    v0 = 0x97e(varg0);\n    return v0;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction totalTokensSold() public nonPayable { \n    return _totalTokensSold;\n}\n\nfunction setTokenPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    emit ChangeTokenPriceEvent(_tokensPerWei, varg0);\n    _tokensPerWei = varg0;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    require(!(0xff & _ownerMap[varg0]));\n    _ownerMap[varg0] = 0x1 | ~0xff & _ownerMap[varg0];\n    _ownerHistoryCount.length = _ownerHistoryCount.length + 1;\n    if (!_ownerHistoryCount.length <= _ownerHistoryCount.length + 1) {\n        v3 = v4 = _ownerHistoryCount.length + 1 + keccak256(5);\n        while (keccak256(5) + _ownerHistoryCount.length > v3) {\n            STORAGE[v3] = 0;\n            v3 += 1;\n        }\n    }\n    _ownerHistoryCount[_ownerHistoryCount.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerHistoryCount[_ownerHistoryCount.length];\n    emit 0x775e4f247a7723929d271ccf476b51fb4284053cb3fd6cf3400228a9c02dbb8(varg0);\n}\n\nfunction owner1() public nonPayable { \n    return _owner1;\n}\n\nfunction minPaymentWei() public nonPayable { \n    return _minPaymentWei;\n}\n\nfunction ownerMap(address varg0) public nonPayable { \n    return 0xff & _ownerMap[varg0];\n}\n\nfunction setMaxCapTokens(uint256 varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    emit ChangeMaxCapTokensEvent(_maxCapTokens, varg0);\n    _maxCapTokens = varg0;\n}\n\nfunction pause() public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    _paused = 1;\n}\n\nfunction totalWeiReceived() public nonPayable { \n    return _totalWeiReceived;\n}\n\nfunction claimOwnership2() public nonPayable { \n    require(_pendingOwner2 == msg.sender);\n    _owner2 = _pendingOwner2;\n    _pendingOwner2 = 0;\n}\n\nfunction pendingOwner2() public nonPayable { \n    return _pendingOwner2;\n}\n\nfunction pendingOwner1() public nonPayable { \n    return _pendingOwner1;\n}\n\nfunction maxCapTokens() public nonPayable { \n    return _maxCapTokens;\n}\n\nfunction balance1() public nonPayable { \n    return _balance1;\n}\n\nfunction transferOwnership2(address varg0) public nonPayable { \n    require(_owner2 == msg.sender);\n    _pendingOwner2 = varg0;\n}\n\nfunction transferOwnership1(address varg0) public nonPayable { \n    require(_owner1 == msg.sender);\n    _pendingOwner1 = varg0;\n}\n\nfunction withdraw1(address varg0) public nonPayable { \n    require(_owner1 == msg.sender);\n    if (_balance1 > 0) {\n        v0 = varg0.call().value(_balance1).gas(!_balance1 * 2300);\n        require(v0);\n    }\n}\n\nfunction sellTokensForEth(address varg0, uint256 varg1) public payable { \n    0x513(varg1, varg0);\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x513(uint256 varg0, uint256 varg1) private { \n    require(!_paused);\n    require(varg0 >= _minPaymentWei);\n    v0 = 0x97e(varg0);\n    assert(v0 + _totalTokensSold >= _totalTokensSold);\n    require(v0 + _totalTokensSold <= _maxCapTokens);\n    MEM[32 + MEM[64]] = 0;\n    v1 = address(varg1);\n    require(_token.code.size);\n    v2, v3 = _token.sell(v1, v0).gas(msg.gas - 710);\n    require(v2);\n    require(v3);\n    assert(v0 + _totalTokensSold >= _totalTokensSold);\n    _totalTokensSold += v0;\n    v4 = varg0 + _totalWeiReceived;\n    assert(v4 >= _totalWeiReceived);\n    _totalWeiReceived = v4;\n    v5 = address(varg1);\n    _isBuyer[v5] = 0x1 | ~0xff & _isBuyer[v5];\n    emit ReceiveEthEvent(v5, varg0);\n    v6 = varg0 >> 1;\n    assert(v6 + _balance1 >= _balance1);\n    _balance1 += v6;\n    v7 = varg0 - v6 + _balance2;\n    assert(v7 >= _balance2);\n    _balance2 = v7;\n    return ;\n}\n\nfunction 0x86a(uint256 varg0) private { \n    v0 = v1 = _owner1 == address(varg0);\n    if (_owner1 != address(varg0)) {\n        v0 = v2 = _owner2 == address(varg0);\n    }\n    if (v0) {\n        return v0;\n    } else {\n        v3 = address(varg0);\n        return 0xff & _ownerMap[v3];\n    }\n}\n\nfunction 0x97e(uint256 varg0) private { \n    v0 = _tokensPerWei * varg0;\n    v1 = v2 = !varg0;\n    if (varg0) {\n        assert(varg0);\n        v1 = v0 / varg0 == _tokensPerWei;\n    }\n    assert(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x46f7da2) {\n            resume();\n        } else if (0x133f1389 == function_selector) {\n            isSuperOwner(address);\n        } else if (0x144fa6d7 == function_selector) {\n            setToken(address);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x22d60d17 == function_selector) {\n            tokensPerWei();\n        } else if (0x2a55feec == function_selector) {\n            isBuyer(address);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x37034853 == function_selector) {\n            ownerHistoryCount();\n        } else if (0x40441eec == function_selector) {\n            balance2();\n        } else if (0x45fd9e23 == function_selector) {\n            claimOwnership1();\n        } else if (0x461fc090 == function_selector) {\n            ownerHistory(uint256);\n        } else if (0x4eea9a8d == function_selector) {\n            withdraw2(address);\n        } else if (0x52709725 == function_selector) {\n            owner2();\n        } else if (0x53aaef7d == function_selector) {\n            weiToTokens(uint256);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x63b20117 == function_selector) {\n            totalTokensSold();\n        } else if (0x6a61e5fc == function_selector) {\n            setTokenPrice(uint256);\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x73688914 == function_selector) {\n            owner1();\n        } else if (0x7467bcd9 == function_selector) {\n            minPaymentWei();\n        } else if (0x760a81b6 == function_selector) {\n            ownerMap(address);\n        } else if (0x8433f614 == function_selector) {\n            setMaxCapTokens(uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x88d12a4d == function_selector) {\n            totalWeiReceived();\n        } else if (0xa75343bf == function_selector) {\n            claimOwnership2();\n        } else if (0xab5366dd == function_selector) {\n            pendingOwner2();\n        } else if (0xb174734c == function_selector) {\n            pendingOwner1();\n        } else if (0xbc6f9021 == function_selector) {\n            maxCapTokens();\n        } else if (0xc45c4f58 == function_selector) {\n            balance1();\n        } else if (0xe2b375a9 == function_selector) {\n            transferOwnership2(address);\n        } else if (0xe982d5a9 == function_selector) {\n            transferOwnership1(address);\n        } else if (0xf569a2fc == function_selector) {\n            withdraw1(address);\n        } else if (0xf5af4035 == function_selector) {\n            sellTokensForEth(address,uint256);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 18:28 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ownerMap; // STORAGE[0x4]\nuint256[] _ownerHistoryCount; // STORAGE[0x5]\nuint256 _balance1; // STORAGE[0x7]\nuint256 _balance2; // STORAGE[0x8]\nuint256 _minPaymentWei; // STORAGE[0xa]\nuint256 _tokensPerWei; // STORAGE[0xb]\nuint256 _maxCapTokens; // STORAGE[0xc]\nuint256 _totalTokensSold; // STORAGE[0xd]\nuint256 _totalWeiReceived; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _isBuyer; // STORAGE[0xf]\naddress _owner1; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x6] bytes 0 to 0\naddress _pendingOwner1; // STORAGE[0x1] bytes 0 to 19\naddress _owner2; // STORAGE[0x2] bytes 0 to 19\naddress _pendingOwner2; // STORAGE[0x3] bytes 0 to 19\naddress _token; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nReceiveEthEvent(address, uint256);\nChangeTokenEvent(address, address);\nOwnerRemovedEvent(address);\nChangeTokenPriceEvent(uint256, uint256);\nChangeMaxCapTokensEvent(uint256, uint256);\n\nfunction fallback() public payable { \n    0x513(msg.value, msg.sender);\n}\n\nfunction resume() public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(_paused);\n    _paused = 0;\n}\n\nfunction isSuperOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == varg0;\n    if (_owner1 != varg0) {\n        v0 = v2 = _owner2 == varg0;\n    }\n    return v0;\n}\n\nfunction setToken(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    require(_token != varg0);\n    emit ChangeTokenEvent(_token, varg0);\n    _token = varg0;\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(0xff & _ownerMap[varg0]);\n    _ownerMap[varg0] = ~0xff & _ownerMap[varg0];\n    emit OwnerRemovedEvent(varg0);\n}\n\nfunction tokensPerWei() public nonPayable { \n    return _tokensPerWei;\n}\n\nfunction isBuyer(address varg0) public nonPayable { \n    return 0xff & _isBuyer[varg0];\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    v0 = 0x86a(varg0);\n    return v0;\n}\n\nfunction ownerHistoryCount() public nonPayable { \n    return _ownerHistoryCount.length;\n}\n\nfunction balance2() public nonPayable { \n    return _balance2;\n}\n\nfunction claimOwnership1() public nonPayable { \n    require(_pendingOwner1 == msg.sender);\n    _owner1 = _pendingOwner1;\n    _pendingOwner1 = 0;\n}\n\nfunction ownerHistory(uint256 varg0) public nonPayable { \n    assert(varg0 < _ownerHistoryCount.length);\n    return address(_ownerHistoryCount[varg0]);\n}\n\nfunction withdraw2(address varg0) public nonPayable { \n    require(_owner2 == msg.sender);\n    if (_balance2 > 0) {\n        v0 = varg0.call().value(_balance2).gas(!_balance2 * 2300);\n        require(v0);\n    }\n}\n\nfunction owner2() public nonPayable { \n    return _owner2;\n}\n\nfunction weiToTokens(uint256 varg0) public nonPayable { \n    v0 = 0x97e(varg0);\n    return v0;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction totalTokensSold() public nonPayable { \n    return _totalTokensSold;\n}\n\nfunction setTokenPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    emit ChangeTokenPriceEvent(_tokensPerWei, varg0);\n    _tokensPerWei = varg0;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    require(!(0xff & _ownerMap[varg0]));\n    _ownerMap[varg0] = 0x1 | ~0xff & _ownerMap[varg0];\n    _ownerHistoryCount.length = _ownerHistoryCount.length + 1;\n    if (!_ownerHistoryCount.length <= _ownerHistoryCount.length + 1) {\n        v3 = v4 = _ownerHistoryCount.length + 1 + keccak256(5);\n        while (keccak256(5) + _ownerHistoryCount.length > v3) {\n            STORAGE[v3] = 0;\n            v3 += 1;\n        }\n    }\n    _ownerHistoryCount[_ownerHistoryCount.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerHistoryCount[_ownerHistoryCount.length];\n    emit 0x775e4f247a7723929d271ccf476b51fb4284053cb3fd6cf3400228a9c02dbb8(varg0);\n}\n\nfunction owner1() public nonPayable { \n    return _owner1;\n}\n\nfunction minPaymentWei() public nonPayable { \n    return _minPaymentWei;\n}\n\nfunction ownerMap(address varg0) public nonPayable { \n    return 0xff & _ownerMap[varg0];\n}\n\nfunction setMaxCapTokens(uint256 varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    emit ChangeMaxCapTokensEvent(_maxCapTokens, varg0);\n    _maxCapTokens = varg0;\n}\n\nfunction pause() public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    _paused = 1;\n}\n\nfunction totalWeiReceived() public nonPayable { \n    return _totalWeiReceived;\n}\n\nfunction claimOwnership2() public nonPayable { \n    require(_pendingOwner2 == msg.sender);\n    _owner2 = _pendingOwner2;\n    _pendingOwner2 = 0;\n}\n\nfunction pendingOwner2() public nonPayable { \n    return _pendingOwner2;\n}\n\nfunction pendingOwner1() public nonPayable { \n    return _pendingOwner1;\n}\n\nfunction maxCapTokens() public nonPayable { \n    return _maxCapTokens;\n}\n\nfunction balance1() public nonPayable { \n    return _balance1;\n}\n\nfunction transferOwnership2(address varg0) public nonPayable { \n    require(_owner2 == msg.sender);\n    _pendingOwner2 = varg0;\n}\n\nfunction transferOwnership1(address varg0) public nonPayable { \n    require(_owner1 == msg.sender);\n    _pendingOwner1 = varg0;\n}\n\nfunction withdraw1(address varg0) public nonPayable { \n    require(_owner1 == msg.sender);\n    if (_balance1 > 0) {\n        v0 = varg0.call().value(_balance1).gas(!_balance1 * 2300);\n        require(v0);\n    }\n}\n\nfunction sellTokensForEth(address varg0, uint256 varg1) public payable { \n    0x513(varg1, varg0);\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x513(uint256 varg0, uint256 varg1) private { \n    require(!_paused);\n    require(varg0 >= _minPaymentWei);\n    v0 = 0x97e(varg0);\n    assert(v0 + _totalTokensSold >= _totalTokensSold);\n    require(v0 + _totalTokensSold <= _maxCapTokens);\n    MEM[32 + MEM[64]] = 0;\n    v1 = address(varg1);\n    require(_token.code.size);\n    v2, v3 = _token.sell(v1, v0).gas(msg.gas - 710);\n    require(v2);\n    require(v3);\n    assert(v0 + _totalTokensSold >= _totalTokensSold);\n    _totalTokensSold += v0;\n    v4 = varg0 + _totalWeiReceived;\n    assert(v4 >= _totalWeiReceived);\n    _totalWeiReceived = v4;\n    v5 = address(varg1);\n    _isBuyer[v5] = 0x1 | ~0xff & _isBuyer[v5];\n    emit ReceiveEthEvent(v5, varg0);\n    v6 = varg0 >> 1;\n    assert(v6 + _balance1 >= _balance1);\n    _balance1 += v6;\n    v7 = varg0 - v6 + _balance2;\n    assert(v7 >= _balance2);\n    _balance2 = v7;\n    return ;\n}\n\nfunction 0x86a(uint256 varg0) private { \n    v0 = v1 = _owner1 == address(varg0);\n    if (_owner1 != address(varg0)) {\n        v0 = v2 = _owner2 == address(varg0);\n    }\n    if (v0) {\n        return v0;\n    } else {\n        v3 = address(varg0);\n        return 0xff & _ownerMap[v3];\n    }\n}\n\nfunction 0x97e(uint256 varg0) private { \n    v0 = _tokensPerWei * varg0;\n    v1 = v2 = !varg0;\n    if (varg0) {\n        assert(varg0);\n        v1 = v0 / varg0 == _tokensPerWei;\n    }\n    assert(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x46f7da2) {\n            resume();\n        } else if (0x133f1389 == function_selector) {\n            isSuperOwner(address);\n        } else if (0x144fa6d7 == function_selector) {\n            setToken(address);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x22d60d17 == function_selector) {\n            tokensPerWei();\n        } else if (0x2a55feec == function_selector) {\n            isBuyer(address);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x37034853 == function_selector) {\n            ownerHistoryCount();\n        } else if (0x40441eec == function_selector) {\n            balance2();\n        } else if (0x45fd9e23 == function_selector) {\n            claimOwnership1();\n        } else if (0x461fc090 == function_selector) {\n            ownerHistory(uint256);\n        } else if (0x4eea9a8d == function_selector) {\n            withdraw2(address);\n        } else if (0x52709725 == function_selector) {\n            owner2();\n        } else if (0x53aaef7d == function_selector) {\n            weiToTokens(uint256);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x63b20117 == function_selector) {\n            totalTokensSold();\n        } else if (0x6a61e5fc == function_selector) {\n            setTokenPrice(uint256);\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x73688914 == function_selector) {\n            owner1();\n        } else if (0x7467bcd9 == function_selector) {\n            minPaymentWei();\n        } else if (0x760a81b6 == function_selector) {\n            ownerMap(address);\n        } else if (0x8433f614 == function_selector) {\n            setMaxCapTokens(uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x88d12a4d == function_selector) {\n            totalWeiReceived();\n        } else if (0xa75343bf == function_selector) {\n            claimOwnership2();\n        } else if (0xab5366dd == function_selector) {\n            pendingOwner2();\n        } else if (0xb174734c == function_selector) {\n            pendingOwner1();\n        } else if (0xbc6f9021 == function_selector) {\n            maxCapTokens();\n        } else if (0xc45c4f58 == function_selector) {\n            balance1();\n        } else if (0xe2b375a9 == function_selector) {\n            transferOwnership2(address);\n        } else if (0xe982d5a9 == function_selector) {\n            transferOwnership1(address);\n        } else if (0xf569a2fc == function_selector) {\n            withdraw1(address);\n        } else if (0xf5af4035 == function_selector) {\n            sellTokensForEth(address,uint256);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 18:28 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _ownerMap; // STORAGE[0x4]\nuint256[] _ownerHistoryCount; // STORAGE[0x5]\nuint256 _balance1; // STORAGE[0x7]\nuint256 _balance2; // STORAGE[0x8]\nuint256 _minPaymentWei; // STORAGE[0xa]\nuint256 _tokensPerWei; // STORAGE[0xb]\nuint256 _maxCapTokens; // STORAGE[0xc]\nuint256 _totalTokensSold; // STORAGE[0xd]\nuint256 _totalWeiReceived; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _isBuyer; // STORAGE[0xf]\naddress _owner1; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x6] bytes 0 to 0\naddress _pendingOwner1; // STORAGE[0x1] bytes 0 to 19\naddress _owner2; // STORAGE[0x2] bytes 0 to 19\naddress _pendingOwner2; // STORAGE[0x3] bytes 0 to 19\naddress _token; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nReceiveEthEvent(address, uint256);\nChangeTokenEvent(address, address);\nOwnerRemovedEvent(address);\nChangeTokenPriceEvent(uint256, uint256);\nChangeMaxCapTokensEvent(uint256, uint256);\n\nfunction fallback() public payable { \n    0x513(msg.value, msg.sender);\n}\n\nfunction resume() public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(_paused);\n    _paused = 0;\n}\n\nfunction isSuperOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == varg0;\n    if (_owner1 != varg0) {\n        v0 = v2 = _owner2 == varg0;\n    }\n    return v0;\n}\n\nfunction setToken(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    require(_token != varg0);\n    emit ChangeTokenEvent(_token, varg0);\n    _token = varg0;\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(0xff & _ownerMap[varg0]);\n    _ownerMap[varg0] = ~0xff & _ownerMap[varg0];\n    emit OwnerRemovedEvent(varg0);\n}\n\nfunction tokensPerWei() public nonPayable { \n    return _tokensPerWei;\n}\n\nfunction isBuyer(address varg0) public nonPayable { \n    return 0xff & _isBuyer[varg0];\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    v0 = 0x86a(varg0);\n    return v0;\n}\n\nfunction ownerHistoryCount() public nonPayable { \n    return _ownerHistoryCount.length;\n}\n\nfunction balance2() public nonPayable { \n    return _balance2;\n}\n\nfunction claimOwnership1() public nonPayable { \n    require(_pendingOwner1 == msg.sender);\n    _owner1 = _pendingOwner1;\n    _pendingOwner1 = 0;\n}\n\nfunction ownerHistory(uint256 varg0) public nonPayable { \n    assert(varg0 < _ownerHistoryCount.length);\n    return address(_ownerHistoryCount[varg0]);\n}\n\nfunction withdraw2(address varg0) public nonPayable { \n    require(_owner2 == msg.sender);\n    if (_balance2 > 0) {\n        v0 = varg0.call().value(_balance2).gas(!_balance2 * 2300);\n        require(v0);\n    }\n}\n\nfunction owner2() public nonPayable { \n    return _owner2;\n}\n\nfunction weiToTokens(uint256 varg0) public nonPayable { \n    v0 = 0x97e(varg0);\n    return v0;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction totalTokensSold() public nonPayable { \n    return _totalTokensSold;\n}\n\nfunction setTokenPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    emit ChangeTokenPriceEvent(_tokensPerWei, varg0);\n    _tokensPerWei = varg0;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    require(!(0xff & _ownerMap[varg0]));\n    _ownerMap[varg0] = 0x1 | ~0xff & _ownerMap[varg0];\n    _ownerHistoryCount.length = _ownerHistoryCount.length + 1;\n    if (!_ownerHistoryCount.length <= _ownerHistoryCount.length + 1) {\n        v3 = v4 = _ownerHistoryCount.length + 1 + keccak256(5);\n        while (keccak256(5) + _ownerHistoryCount.length > v3) {\n            STORAGE[v3] = 0;\n            v3 += 1;\n        }\n    }\n    _ownerHistoryCount[_ownerHistoryCount.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerHistoryCount[_ownerHistoryCount.length];\n    emit 0x775e4f247a7723929d271ccf476b51fb4284053cb3fd6cf3400228a9c02dbb8(varg0);\n}\n\nfunction owner1() public nonPayable { \n    return _owner1;\n}\n\nfunction minPaymentWei() public nonPayable { \n    return _minPaymentWei;\n}\n\nfunction ownerMap(address varg0) public nonPayable { \n    return 0xff & _ownerMap[varg0];\n}\n\nfunction setMaxCapTokens(uint256 varg0) public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    emit ChangeMaxCapTokensEvent(_maxCapTokens, varg0);\n    _maxCapTokens = varg0;\n}\n\nfunction pause() public nonPayable { \n    v0 = v1 = _owner1 == msg.sender;\n    if (_owner1 != msg.sender) {\n        v0 = v2 = _owner2 == msg.sender;\n    }\n    require(v0);\n    _paused = 1;\n}\n\nfunction totalWeiReceived() public nonPayable { \n    return _totalWeiReceived;\n}\n\nfunction claimOwnership2() public nonPayable { \n    require(_pendingOwner2 == msg.sender);\n    _owner2 = _pendingOwner2;\n    _pendingOwner2 = 0;\n}\n\nfunction pendingOwner2() public nonPayable { \n    return _pendingOwner2;\n}\n\nfunction pendingOwner1() public nonPayable { \n    return _pendingOwner1;\n}\n\nfunction maxCapTokens() public nonPayable { \n    return _maxCapTokens;\n}\n\nfunction balance1() public nonPayable { \n    return _balance1;\n}\n\nfunction transferOwnership2(address varg0) public nonPayable { \n    require(_owner2 == msg.sender);\n    _pendingOwner2 = varg0;\n}\n\nfunction transferOwnership1(address varg0) public nonPayable { \n    require(_owner1 == msg.sender);\n    _pendingOwner1 = varg0;\n}\n\nfunction withdraw1(address varg0) public nonPayable { \n    require(_owner1 == msg.sender);\n    if (_balance1 > 0) {\n        v0 = varg0.call().value(_balance1).gas(!_balance1 * 2300);\n        require(v0);\n    }\n}\n\nfunction sellTokensForEth(address varg0, uint256 varg1) public payable { \n    0x513(varg1, varg0);\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x513(uint256 varg0, uint256 varg1) private { \n    require(!_paused);\n    require(varg0 >= _minPaymentWei);\n    v0 = 0x97e(varg0);\n    assert(v0 + _totalTokensSold >= _totalTokensSold);\n    require(v0 + _totalTokensSold <= _maxCapTokens);\n    MEM[32 + MEM[64]] = 0;\n    v1 = address(varg1);\n    require(_token.code.size);\n    v2, v3 = _token.sell(v1, v0).gas(msg.gas - 710);\n    require(v2);\n    require(v3);\n    assert(v0 + _totalTokensSold >= _totalTokensSold);\n    _totalTokensSold += v0;\n    v4 = varg0 + _totalWeiReceived;\n    assert(v4 >= _totalWeiReceived);\n    _totalWeiReceived = v4;\n    v5 = address(varg1);\n    _isBuyer[v5] = 0x1 | ~0xff & _isBuyer[v5];\n    emit ReceiveEthEvent(v5, varg0);\n    v6 = varg0 >> 1;\n    assert(v6 + _balance1 >= _balance1);\n    _balance1 += v6;\n    v7 = varg0 - v6 + _balance2;\n    assert(v7 >= _balance2);\n    _balance2 = v7;\n    return ;\n}\n\nfunction 0x86a(uint256 varg0) private { \n    v0 = v1 = _owner1 == address(varg0);\n    if (_owner1 != address(varg0)) {\n        v0 = v2 = _owner2 == address(varg0);\n    }\n    if (v0) {\n        return v0;\n    } else {\n        v3 = address(varg0);\n        return 0xff & _ownerMap[v3];\n    }\n}\n\nfunction 0x97e(uint256 varg0) private { \n    v0 = _tokensPerWei * varg0;\n    v1 = v2 = !varg0;\n    if (varg0) {\n        assert(varg0);\n        v1 = v0 / varg0 == _tokensPerWei;\n    }\n    assert(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x46f7da2) {\n            resume();\n        } else if (0x133f1389 == function_selector) {\n            isSuperOwner(address);\n        } else if (0x144fa6d7 == function_selector) {\n            setToken(address);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x22d60d17 == function_selector) {\n            tokensPerWei();\n        } else if (0x2a55feec == function_selector) {\n            isBuyer(address);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x37034853 == function_selector) {\n            ownerHistoryCount();\n        } else if (0x40441eec == function_selector) {\n            balance2();\n        } else if (0x45fd9e23 == function_selector) {\n            claimOwnership1();\n        } else if (0x461fc090 == function_selector) {\n            ownerHistory(uint256);\n        } else if (0x4eea9a8d == function_selector) {\n            withdraw2(address);\n        } else if (0x52709725 == function_selector) {\n            owner2();\n        } else if (0x53aaef7d == function_selector) {\n            weiToTokens(uint256);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x63b20117 == function_selector) {\n            totalTokensSold();\n        } else if (0x6a61e5fc == function_selector) {\n            setTokenPrice(uint256);\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x73688914 == function_selector) {\n            owner1();\n        } else if (0x7467bcd9 == function_selector) {\n            minPaymentWei();\n        } else if (0x760a81b6 == function_selector) {\n            ownerMap(address);\n        } else if (0x8433f614 == function_selector) {\n            setMaxCapTokens(uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x88d12a4d == function_selector) {\n            totalWeiReceived();\n        } else if (0xa75343bf == function_selector) {\n            claimOwnership2();\n        } else if (0xab5366dd == function_selector) {\n            pendingOwner2();\n        } else if (0xb174734c == function_selector) {\n            pendingOwner1();\n        } else if (0xbc6f9021 == function_selector) {\n            maxCapTokens();\n        } else if (0xc45c4f58 == function_selector) {\n            balance1();\n        } else if (0xe2b375a9 == function_selector) {\n            transferOwnership2(address);\n        } else if (0xe982d5a9 == function_selector) {\n            transferOwnership1(address);\n        } else if (0xf569a2fc == function_selector) {\n            withdraw1(address);\n        } else if (0xf5af4035 == function_selector) {\n            sellTokensForEth(address,uint256);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 48.590789556503296,
	"usage": {
		"completion_tokens": 682,
		"prompt_tokens": 3297,
		"total_tokens": 3979
	}
}