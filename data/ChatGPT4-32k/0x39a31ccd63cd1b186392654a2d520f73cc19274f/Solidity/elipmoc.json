{
	"address": "0x39a31ccd63cd1b186392654a2d520f73cc19274f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The following is a Solidity contract based on the given decompiled code. Please note that the decompiled code is quite complex and contains some elements that do not directly translate to Solidity. This is a simplified version of the contract.\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    uint256[] _totalSupply;\n    mapping (uint256 => address) _itemIndexToOwner;\n    mapping (address => uint256) _ownershipTokenCount;\n    mapping (uint256 => address) _itemIndexToApproved;\n    uint256 _vrcCount;\n    uint256 _vcxCount;\n    uint256 _weiRaised;\n    uint256 _contributorsCompleteCount;\n    mapping (address => uint256) _contributorBalance;\n    mapping (address => bool) _contributorComplete;\n    mapping (address => uint256) _contributorWhiteListTime;\n    uint256[] _contributorsCount;\n    address _owner;\n    bool _paused;\n    address _erc721Metadata;\n    address _vrc;\n    address _vcx;\n    address _vrcWallet;\n    address _vcxWallet;\n\n    event Purchase(address indexed _buyer, uint256 _value);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n    event Unpause();\n    event Pause();\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n    event CreateItem(uint256 _tokenId, uint8 _v1, uint8 _v2, uint8 _v3, uint8 _v4, uint256 _v5, uint256 _v6, address _v7);\n\n    // The following is a simplified version of the original functions as inferred from the decompiled code\n    function setMetadataAddress(address newAddress) public {\n        require(msg.sender == _owner);\n        _erc721Metadata = newAddress;\n    }\n\n    function contributorWhiteListTime(address contributor) public view returns (uint256) {\n        return _contributorWhiteListTime[contributor];\n    }\n\n    function buyTokens(address buyer) public payable {\n        require(!_paused);\n        require(buyer != address(0));\n        require(msg.value >= 0x16345785d8a0000);\n        _weiRaised = _weiRaised + msg.value;\n        require(_weiRaised <= 0xa968163f0a57b400000);\n        emit Purchase(buyer, msg.value);\n        // further logic is omitted for simplicity\n    }\n\n    function setVCX(address newVCX, address newVCXWallet, uint256 newCount) public {\n        require(msg.sender == _owner);\n        require(newVCX != address(0));\n        require(newVCXWallet != address(0));\n        require(newCount > 0);\n        _vcx = newVCX;\n        _vcxWallet = newVCXWallet;\n        _vcxCount = newCount;\n    }\n\n    function vcx() public view returns (address) {\n        return _vcx;\n    }\n\n    function hardCap() public pure returns (uint256) {\n        return 0xa968163f0a57b400000;\n    }\n\n    function itemIndexToOwner(uint256 index) public view returns (address) {\n        return _itemIndexToOwner[index];\n    }\n\n    // further functions are omitted for simplicity\n}\n```\n\nPlease note that this is a simplified version and does not include all the functionality present in the decompiled code. It's recommended to hire a professional smart contract developer to fully convert the decompiled code into a working Solidity contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039942,
	"id": "chatcmpl-8Ci2wFCVpt6KSS5zoEzJb5XMEp8yR",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 06:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _itemIndexToOwner; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _ownershipTokenCount; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _itemIndexToApproved; // STORAGE[0x4]\nuint256 _vrcCount; // STORAGE[0xa]\nuint256 _vcxCount; // STORAGE[0xb]\nuint256 _weiRaised; // STORAGE[0xc]\nuint256 _contributorsCompleteCount; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _contributorBalance; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _contributorComplete; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _contributorWhiteListTime; // STORAGE[0x10]\nuint256[] _contributorsCount; // STORAGE[0x11]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _erc721Metadata; // STORAGE[0x5] bytes 0 to 19\naddress _vrc; // STORAGE[0x6] bytes 0 to 19\naddress _vcx; // STORAGE[0x7] bytes 0 to 19\nuint160 _vrcWallet; // STORAGE[0x8] bytes 0 to 19\nuint160 _vcxWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nPurchase(address, uint256);\nApproval(address, address, uint256);\nUnpause();\nPause();\nTransfer(address, address, uint256);\nCreateItem(uint256, uint8, uint8, uint8, uint8, uint256, uint256, address);\n\nfunction setMetadataAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _erc721Metadata = varg0;\n}\n\nfunction contributorWhiteListTime(address varg0) public nonPayable { \n    return _contributorWhiteListTime[varg0];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x1230(varg0);\n}\n\nfunction setVCX(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    _vcx = varg0;\n    _vcxWallet = varg1;\n    _vcxCount = varg2;\n}\n\nfunction vcx() public nonPayable { \n    return _vcx;\n}\n\nfunction hardCap() public nonPayable { \n    return 0xa968163f0a57b400000;\n}\n\nfunction itemIndexToOwner(uint256 varg0) public nonPayable { \n    return address(_itemIndexToOwner[varg0]);\n}\n\nfunction 0x1230(uint256 varg0) private { \n    require(!_paused);\n    require(address(varg0) != 0);\n    require(msg.value >= 0x16345785d8a0000);\n    _weiRaised = _weiRaised + msg.value;\n    require(_weiRaised <= 0xa968163f0a57b400000);\n    emit Purchase(address(varg0), msg.value);\n    v0 = address(varg0);\n    if (_contributorBalance[v0] != 0) {\n        v1 = address(varg0);\n        require(!(0xff & _contributorComplete[v1]));\n        v2 = address(varg0);\n        require(msg.value >= _contributorBalance[v2] * 99);\n        v3 = address(varg0);\n        v4 = address(varg0);\n        _contributorBalance[v4] = _contributorBalance[v4] + msg.value;\n        v5 = address(varg0);\n        v6 = v7 = _contributorBalance[v5];\n        if (v7 >= 0x22b1c8c1227a00000) {\n            if (v7 >= 0x56bc75e2d63100000) {\n                if (v7 >= 0x1b1ae4d6e2ef500000) {\n                    if (v7 >= 0x3635c9adc5dea00000) {\n                        if (v7 >= 0x10f0cf064dd59200000) {\n                            if (v7 >= 0x10f0cf064dd59200000) {\n                                0x3bf3(varg0, v7);\n                                0x3ccf(varg0, v7);\n                                0x3d42(varg0, v7);\n                                0x3df0(varg0, v7);\n                                v8 = v9 = 14456;\n                                v10 = v11 = 20;\n                                if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                                    v6 = v12 = v7 * 135 / 100;\n                                }\n                                goto 0x3ca10x3623B0x150c;\n                            }\n                        } else {\n                            0x3bf3(varg0, v7);\n                            0x3ccf(varg0, v7);\n                            0x3d42(varg0, v7);\n                            0x3df0(varg0, v7);\n                            v8 = v13 = 14343;\n                            v10 = v14 = 19;\n                            if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                                v6 = v15 = v7 * 120 / 100;\n                            }\n                            goto 0x3ca10x3623B0x150c;\n                        }\n                    } else {\n                        0x3bf3(varg0, v7);\n                        0x3ccf(varg0, v7);\n                        0x3d42(varg0, v7);\n                        0x3db4(varg0, v7);\n                        v8 = v16 = 14231;\n                        v10 = v17 = 18;\n                        if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                            v6 = v18 = v7 * 115 / 100;\n                        }\n                        goto 0x3ca10x3623B0x150c;\n                    }\n                } else {\n                    0x3bf3(varg0, v7);\n                    0x3ccf(varg0, v7);\n                    0x3d42(varg0, v7);\n                    0x3db4(varg0, v7);\n                    v8 = v19 = 14120;\n                    v10 = v20 = 17;\n                    if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                        v6 = v21 = v7 * 110 / 100;\n                    }\n                    goto 0x3ca10x3623B0x150c;\n                }\n            } else {\n                0x3bf3(varg0, v7);\n                0x3ccf(varg0, v7);\n                0x3c65(varg0, v7);\n                v8 = v22 = 14009;\n                v10 = v23 = 16;\n                if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                    v6 = v24 = v7 * 105 / 100;\n                }\n            }\n            v25 = 0x3e76(varg0, v6, 5, 3, v10, 0);\n            goto {'0x3797B0x150c', '0x36b9B0x150c', '0x3728B0x150c', '0x3807B0x150c', '0x3878B0x150c'};\n            v26 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3887B0x150c;\n            v27 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3886B0x150c;\n            v28 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3885B0x150c;\n            v29 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3884B0x150c;\n            v30 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n        } else {\n            0x3bf3(varg0, v7);\n            0x3c65(varg0, v7);\n            v31 = 0x3e76(varg0, v7, 5, 3, 15, 0);\n            v32 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n        }\n        v33 = address(varg0);\n        _contributorComplete[v33] = 0x1 | ~0xff & _contributorComplete[v33];\n        _contributorsCompleteCount += 1;\n    } else {\n        _contributorsCount.length = _contributorsCount.length + 1;\n        _contributorsCount[_contributorsCount.length + 1 - 1] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _contributorsCount[_contributorsCount.length + 1 - 1];\n        v34 = address(varg0);\n        _contributorBalance[v34] = _contributorBalance[v34] + msg.value;\n        v35 = address(varg0);\n        _contributorBalance[v35] = block.timestamp;\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    0x1230(msg.sender);\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    v0 = v1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & keccak256('supportsInterface(bytes4)');\n    if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & keccak256('supportsInterface(bytes4)')) {\n        v0 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (keccak256('name()') ^ keccak256('symbol()') ^ keccak256('totalSupply()') ^ keccak256('balanceOf(address)') ^ keccak256('ownerOf(uint)') ^ keccak256('approve(address,uint)') ^ keccak256('transfer(address,uint)') ^ keccak256('transferFrom(address,address,uin', 0x7429000000000000000000000000000000000000000000000000000000000000) ^ keccak256('tokensOfOwner(address)') ^ keccak256('tokenMetadata(uint,string)'));\n    }\n    return v0;\n}\n\nfunction tokenMetadata(uint256 varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    MEM[(MEM[64]) len 128] = this.code[this.code.size len 128];\n    require(_erc721Metadata != 0);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(_erc721Metadata.code.size);\n    v6 = _erc721Metadata.getMetadata(varg0, v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    v7 = v8 = MEM[64];\n    require(RETURNDATASIZE() >= 160);\n    v9 = v10 = MEM[128 + v8];\n    v11 = new bytes[](v10);\n    if (v10) {\n        MEM[(v11.data) len (v10 << 5)] = this.code[this.code.size len (v10 << 5)];\n    }\n    v12 = v13 = v11.data;\n    while (v9 >= 32) {\n        MEM[v12] = MEM[v7];\n        v12 = v12 + 32;\n        v7 = v7 + 32;\n        v9 = v9 - 32;\n    }\n    MEM[v12] = MEM[v12] & 256 ** (32 - v9) - 1 | MEM[v7] & ~(256 ** (32 - v9) - 1);\n    v14 = new array[](v11.length);\n    v15 = v16 = 0;\n    while (v15 < v11.length) {\n        MEM[v14.data + v15] = MEM[v11.data + v15];\n        v15 = v15 + 32;\n    }\n    v17 = v18 = v11.length + v14.data;\n    if (0x1f & v11.length) {\n        MEM[v18 - (0x1f & v11.length)] = ~(256 ** (32 - (0x1f & v11.length)) - 1) & MEM[v18 - (0x1f & v11.length)];\n    }\n    return v14;\n}\n\nfunction 0x3067(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0);\n    require(address(_itemIndexToOwner[varg0]) == msg.sender);\n    require(address(_itemIndexToOwner[varg0]) != address(varg1));\n    _ownershipTokenCount[msg.sender] = _ownershipTokenCount[msg.sender] - 1;\n    v0 = address(varg1);\n    _ownershipTokenCount[v0] += 1;\n    _ownershipTokenCount[varg0] = address(varg1) | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg0];\n    _ownershipTokenCount[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg0];\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v1.length + v0.data;\n    if (1) {\n        MEM[v5 - 1] = 0x7300000000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0, v6, 'Cryptoverse Preorder Bonus Asset';\n}\n\nfunction 0x3bf3(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 4, 0, 0, 5);\n    v1 = 0x3e76(varg0, varg1, 4, 0, 0, 6);\n    v2 = 0x3e76(varg0, varg1, 4, 0, 0, 7);\n    v3 = 0x3e76(varg0, varg1, 4, 0, 6, 8);\n    v4 = 0x3e76(varg0, varg1, 4, 0, 9, 9);\n    v5 = 0x3e76(varg0, varg1, 4, 0, 12, 10);\n    return ;\n}\n\nfunction 0x3c65(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 4, 3, 5, 2);\n    v1 = 0x3e76(varg0, varg1, 4, 3, 5, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3ccf(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 5, 1, 1, 5);\n    v1 = 0x3e76(varg0, varg1, 5, 1, 1, 6);\n    v2 = 0x3e76(varg0, varg1, 5, 1, 1, 7);\n    v3 = 0x3e76(varg0, varg1, 5, 1, 7, 8);\n    v4 = 0x3e76(varg0, varg1, 5, 1, 10, 9);\n    v5 = 0x3e76(varg0, varg1, 5, 1, 13, 10);\n    return ;\n}\n\nfunction 0x3d42(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 6, 2, 2, 5);\n    v1 = 0x3e76(varg0, varg1, 6, 2, 2, 6);\n    v2 = 0x3e76(varg0, varg1, 6, 2, 2, 7);\n    v3 = 0x3e76(varg0, varg1, 6, 2, 8, 8);\n    v4 = 0x3e76(varg0, varg1, 6, 2, 11, 9);\n    v5 = 0x3e76(varg0, varg1, 6, 2, 14, 10);\n    return ;\n}\n\nfunction 0x3db4(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 5, 3, 4, 2);\n    v1 = 0x3e76(varg0, varg1, 5, 3, 4, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3df0(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 6, 3, 2, 2);\n    v1 = 0x3e76(varg0, varg1, 6, 3, 2, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3e76(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { \n    MEM[64] = MEM[64] + 192;\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    require(address(varg0) != 0);\n    assert(varg5 <= 10);\n    assert(varg4 <= 21);\n    assert(varg3 <= 3);\n    assert(varg2 <= 6);\n    _totalSupply.length = _totalSupply.length + 1;\n    v0 = varg5;\n    assert(v0 <= 10);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v0 | ~0xff & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v1 = varg4;\n    assert(v1 <= 21);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v1 << 8 | ~0xff00 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v2 = varg3;\n    assert(v2 <= 3);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v2 << 16 | ~0xff0000 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v3 = varg2;\n    assert(v3 <= 6);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v3 << 24 | ~0xff000000 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    STORAGE[1 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = block.timestamp;\n    STORAGE[2 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = varg1;\n    assert(varg5 <= 10);\n    v4 = 0xff & varg5;\n    assert(varg4 <= 21);\n    v5 = 0xff & varg4;\n    assert(varg3 <= 3);\n    v6 = 0xff & varg3;\n    assert(varg2 <= 6);\n    v7 = 0xff & varg2;\n    emit CreateItem(address(varg0), _totalSupply.length, v4, v5, v6, v7, block.timestamp, varg1);\n    v8 = address(varg0);\n    _ownershipTokenCount[v8] += 1;\n    _ownershipTokenCount[v8] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[v8];\n    return _totalSupply.length;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(address(_itemIndexToOwner[varg1]) == msg.sender);\n    _itemIndexToApproved[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _itemIndexToApproved[varg1];\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction vcxWallet() public nonPayable { \n    return _vcxWallet;\n}\n\nfunction reclaimToken(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply.length;\n}\n\nfunction isBoxItemId(uint256 varg0) public nonPayable { \n    assert(varg0 < _totalSupply.length);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8 <= 21);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8 <= 21);\n    MEM[32 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8;\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16 <= 3);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16 <= 3);\n    MEM[64 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16;\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24 <= 6);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24 <= 6);\n    MEM[96 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24;\n    MEM[128 + MEM[64]] = STORAGE[3 * varg0 + keccak256(1) + 1];\n    MEM[160 + MEM[64]] = STORAGE[3 * varg0 + keccak256(1) + 2];\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    v0 = v1 = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] == 0;\n    if (0xff & STORAGE[3 * varg0 + keccak256(1) + 0] != 0) {\n        assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n        v0 = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] == 1;\n    }\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg1 != address(this));\n    require(address(_itemIndexToApproved[varg2]) == msg.sender);\n    require(address(_itemIndexToOwner[varg2]) == varg0);\n    _ownershipTokenCount[varg0] = _ownershipTokenCount[varg0] - 1;\n    _ownershipTokenCount[varg1] += 1;\n    _ownershipTokenCount[varg1] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg1];\n    _ownershipTokenCount[varg1] = ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg1];\n    emit Transfer(varg0, varg1, varg2);\n}\n\nfunction vcxCount() public nonPayable { \n    return _vcxCount;\n}\n\nfunction contributorComplete(address varg0) public nonPayable { \n    return 0xff & _contributorComplete[varg0];\n}\n\nfunction vrcWallet() public nonPayable { \n    return _vrcWallet;\n}\n\nfunction contributors(uint256 varg0) public nonPayable { \n    assert(varg0 < _contributorsCount.length);\n    return address(_contributorsCount[varg0]);\n}\n\nfunction openBoxes(uint256[] varg0) public nonPayable { \n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length << 5);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        if (v1 < v0.length) {\n            break;\n        }\n        assert(v1 < v0.length);\n        if (v0[v1] < _totalSupply.length) {\n            break;\n        }\n        assert(v0[v1] < _totalSupply.length);\n        v3 = 3 * v0[v1] + keccak256(1);\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        assert(0xff & STORAGE[v3 + 0] >> 8 <= 21);\n        assert(0xff & STORAGE[v3 + 0] >> 8 <= 21);\n        MEM[32 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 8;\n        assert(0xff & STORAGE[v3 + 0] >> 16 <= 3);\n        assert(0xff & STORAGE[v3 + 0] >> 16 <= 3);\n        MEM[64 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 16;\n        assert(0xff & STORAGE[v3 + 0] >> 24 <= 6);\n        assert(0xff & STORAGE[v3 + 0] >> 24 <= 6);\n        MEM[96 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 24;\n        MEM[128 + MEM[64]] = STORAGE[v3 + 1];\n        MEM[160 + MEM[64]] = STORAGE[v3 + 2];\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        v4 = v5 = 0xff & STORAGE[v3 + 0] == 0;\n        if (0xff & STORAGE[v3 + 0] != 0) {\n            assert(0xff & STORAGE[v3 + 0] <= 10);\n            v4 = 0xff & STORAGE[v3 + 0] == 1;\n        }\n        require(v4);\n        0x3067(v0[v1], this);\n        assert(0xff & STORAGE[0 + v3] <= 10);\n        if (0xff & STORAGE[0 + v3] != 0) {\n            assert(_weiRaised);\n            MEM[MEM[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n            require(_vcx.code.size);\n            v6 = _vcx.call(v7, _vcxWallet, msg.sender, STORAGE[2 + v3] * _vcxCount / _weiRaised).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        } else {\n            assert(_weiRaised);\n            MEM[MEM[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n            require(_vrc.code.size);\n            v8 = _vrc.call(v7, _vrcWallet, msg.sender, STORAGE[2 + v3] * _vrcCount / _weiRaised).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        }\n        v1 += 1;\n    }\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction contributorBalance(address varg0) public nonPayable { \n    return _contributorBalance[varg0];\n}\n\nfunction setVRC(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    _vrc = varg0;\n    _vrcWallet = varg1;\n    _vrcCount = varg2;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(address(_itemIndexToOwner[varg0]) != 0);\n    return address(_itemIndexToOwner[varg0]);\n}\n\nfunction minInvest() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _ownershipTokenCount[varg0];\n}\n\nfunction contributorsCount() public nonPayable { \n    return _contributorsCount.length;\n}\n\nfunction withdrawal(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction tokensOfOwner(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = v1 = new uint256[](_ownershipTokenCount[varg0]);\n        if (_ownershipTokenCount[varg0]) {\n            MEM[(v1.data) len (_ownershipTokenCount[varg0] << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] << 5)];\n        }\n        v2 = v3 = 0;\n        v4 = v5 = 0;\n        while (v4 < _totalSupply.length) {\n            if (address(_itemIndexToOwner[v4]) == varg0) {\n                assert(v2 < v1.length);\n                v1[v2] = v4;\n                v2 += 1;\n            }\n            v4 += 1;\n        }\n    } else {\n        v0 = v6 = new uint256[](0);\n    }\n    v7 = new array[](MEM[v0]);\n    v8 = v9 = 0;\n    while (v8 < MEM[v0] << 5) {\n        MEM[v7.data + v8] = MEM[32 + v0 + v8];\n        v8 = v8 + 32;\n    }\n    return v7;\n}\n\nfunction itemIndexToApproved(uint256 varg0) public nonPayable { \n    return address(_itemIndexToApproved[varg0]);\n}\n\nfunction tokensInfoOfOwner(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = v1 = new uint256[](_ownershipTokenCount[varg0] * 7);\n        if (_ownershipTokenCount[varg0] * 7) {\n            MEM[(v1.data) len (_ownershipTokenCount[varg0] * 7 << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] * 7 << 5)];\n        }\n        v2 = v3 = 0;\n        v4 = v5 = 0;\n        while (v4 < _totalSupply.length) {\n            if (address(_itemIndexToOwner[v4]) == varg0) {\n                assert(v4 < _totalSupply.length);\n                assert(v2 < v1.length);\n                v1[v2] = v4;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] <= 10);\n                assert(1 + v2 < v1.length);\n                v1[1 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))];\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 8 <= 21);\n                assert(2 + v2 < v1.length);\n                v1[2 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 8;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 16 <= 3);\n                assert(3 + v2 < v1.length);\n                v1[3 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 16;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 24 <= 6);\n                assert(4 + v2 < v1.length);\n                v1[4 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 24;\n                assert(5 + v2 < v1.length);\n                v1[5 + v2] = STORAGE[1 + (3 * v4 + keccak256(1))];\n                v2 += 7;\n                assert(6 + v2 < v1.length);\n                v1[6 + v2] = STORAGE[2 + (3 * v4 + keccak256(1))];\n            }\n            v4 += 1;\n        }\n    } else {\n        v0 = v6 = new uint256[](0);\n    }\n    v7 = new array[](MEM[v0]);\n    v8 = v9 = 0;\n    while (v8 < MEM[v0] << 5) {\n        MEM[v7.data + v8] = MEM[32 + v0 + v8];\n        v8 = v8 + 32;\n    }\n    return v7;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4350424100000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction vrcCount() public nonPayable { \n    return _vrcCount;\n}\n\nfunction getBoxes(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = new uint256[](_ownershipTokenCount[varg0]);\n        if (_ownershipTokenCount[varg0]) {\n            MEM[(v0.data) len (_ownershipTokenCount[varg0] << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] << 5)];\n        }\n        v1 = v2 = 0;\n        v3 = v4 = 0;\n        while (v3 < _totalSupply.length) {\n            v5 = v6 = address(_itemIndexToOwner[v3]) == varg0;\n            if (v6) {\n                assert(v3 < _totalSupply.length);\n                v7 = 0xff & STORAGE[3 * v3 + keccak256(1) + 0];\n                assert(v7 <= 10);\n                assert(v7 <= 10);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8 <= 21);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8 <= 21);\n                MEM[32 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8;\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16 <= 3);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16 <= 3);\n                MEM[64 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16;\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24 <= 6);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24 <= 6);\n                MEM[96 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24;\n                MEM[128 + MEM[64]] = STORAGE[3 * v3 + keccak256(1) + 1];\n                MEM[160 + MEM[64]] = STORAGE[3 * v3 + keccak256(1) + 2];\n                assert(v7 <= 10);\n                v5 = v8 = v7 == 0;\n                if (v7 != 0) {\n                    assert(v7 <= 10);\n                    v5 = v7 == 1;\n                }\n            }\n            if (v5) {\n                v1 += 1;\n                assert(v1 < v0.length);\n                v0[v1] = v3;\n            }\n            v3 += 1;\n        }\n        v9 = new uint256[](v1);\n        if (v1) {\n            MEM[(v9.data) len (v1 << 5)] = this.code[this.code.size len (v1 << 5)];\n        }\n        v10 = v11 = 0;\n        while (v10 < v1) {\n            assert(v10 < v0.length);\n            assert(v10 < v9.length);\n            v9[v10] = v0[v10];\n            v10 += 1;\n        }\n    } else {\n        v9 = v12 = new uint256[](0);\n    }\n    v13 = new array[](MEM[v9]);\n    v14 = v15 = 0;\n    while (v14 < MEM[v9] << 5) {\n        MEM[v13.data + v14] = MEM[32 + v9 + v14];\n        v14 = v14 + 32;\n    }\n    return v13;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x3067(varg1, varg0);\n}\n\nfunction vrc() public nonPayable { \n    return _vrc;\n}\n\nfunction erc721Metadata() public nonPayable { \n    return _erc721Metadata;\n}\n\nfunction items(uint256 varg0) public nonPayable { \n    assert(varg0 < _totalSupply.length);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] <= 10);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8 <= 21);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16 <= 3);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24 <= 6);\n    return 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))]), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24), STORAGE[1 + (3 * varg0 + keccak256(1))], STORAGE[2 + (3 * varg0 + keccak256(1))];\n}\n\nfunction tokenInfo(uint256 varg0) public nonPayable { \n    v0 = new uint256[](7);\n    if (7) {\n        MEM[(v0.data) len 224] = this.code[this.code.size len 224];\n    }\n    assert(varg0 < _totalSupply.length);\n    assert(0 < v0.length);\n    v1 = v0.data;\n    v2 = v0.data;\n    v0[0] = varg0;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] <= 10);\n    assert(1 < v0.length);\n    v0[1] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))];\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8 <= 21);\n    assert(2 < v0.length);\n    v0[2] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16 <= 3);\n    assert(3 < v0.length);\n    v0[3] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24 <= 6);\n    assert(4 < v0.length);\n    v0[4] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24;\n    assert(5 < v0.length);\n    v0[5] = STORAGE[1 + (3 * varg0 + keccak256(1))];\n    assert(6 < v0.length);\n    v0[6] = STORAGE[2 + (3 * varg0 + keccak256(1))];\n    v3 = new array[](v0.length);\n    v4 = v5 = 0;\n    while (v4 < 224) {\n        MEM[v3.data + v4] = MEM[v0.data + v4];\n        v4 = v4 + 32;\n    }\n    return v3, v6, varg0, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))], 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24, STORAGE[1 + (3 * varg0 + keccak256(1))], STORAGE[2 + (3 * varg0 + keccak256(1))];\n}\n\nfunction ownershipTokenCount(address varg0) public nonPayable { \n    return _ownershipTokenCount[varg0];\n}\n\nfunction contributorsCompleteCount() public nonPayable { \n    return _contributorsCompleteCount;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1ffc9a7 == function_selector) {\n            supportsInterface(bytes4);\n        } else if (0x560ff44 == function_selector) {\n            tokenMetadata(uint256,string);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc9daf45 == function_selector) {\n            vcxWallet();\n        } else if (0x17ffc320 == function_selector) {\n            reclaimToken(address);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x210e734c == function_selector) {\n            isBoxItemId(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x25402e6c == function_selector) {\n            vcxCount();\n        } else if (0x2ebb5056 == function_selector) {\n            contributorComplete(address);\n        } else if (0x3276249f == function_selector) {\n            vrcWallet();\n        } else if (0x3cb5d100 == function_selector) {\n            contributors(uint256);\n        } else if (0x3e52d5c6 == function_selector) {\n            openBoxes(uint256[]);\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4ab994ad == function_selector) {\n            contributorBalance(address);\n        } else if (0x56ddbe7a == function_selector) {\n            setVRC(address,address,uint256);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x6352211e == function_selector) {\n            ownerOf(uint256);\n        } else if (0x63fd9e38 == function_selector) {\n            minInvest();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7569b3d7 == function_selector) {\n            contributorsCount();\n        } else if (0x835fc6ca == function_selector) {\n            withdrawal(uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8462151c == function_selector) {\n            tokensOfOwner(address);\n        } else if (0x88072700 == function_selector) {\n            itemIndexToApproved(uint256);\n        } else if (0x8b157515 == function_selector) {\n            tokensInfoOfOwner(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa64e920d == function_selector) {\n            vrcCount();\n        } else if (0xa731f31a == function_selector) {\n            getBoxes(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb01454dd == function_selector) {\n            vrc();\n        } else if (0xbc4006f5 == function_selector) {\n            erc721Metadata();\n        } else if (0xbfb231d2 == function_selector) {\n            items(uint256);\n        } else if (0xcc33c875 == function_selector) {\n            tokenInfo(uint256);\n        } else if (0xcec21acb == function_selector) {\n            ownershipTokenCount(address);\n        } else if (0xdc45b93a == function_selector) {\n            contributorsCompleteCount();\n        } else if (0xe17b25af == function_selector) {\n            setMetadataAddress(address);\n        } else if (0xec39d6e6 == function_selector) {\n            contributorWhiteListTime(address);\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf1317352 == function_selector) {\n            setVCX(address,address,uint256);\n        } else if (0xfb7e54eb == function_selector) {\n            vcx();\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        } else if (0xfe9b1a89 == function_selector) {\n            itemIndexToOwner(uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 06:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _itemIndexToOwner; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _ownershipTokenCount; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _itemIndexToApproved; // STORAGE[0x4]\nuint256 _vrcCount; // STORAGE[0xa]\nuint256 _vcxCount; // STORAGE[0xb]\nuint256 _weiRaised; // STORAGE[0xc]\nuint256 _contributorsCompleteCount; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _contributorBalance; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _contributorComplete; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _contributorWhiteListTime; // STORAGE[0x10]\nuint256[] _contributorsCount; // STORAGE[0x11]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _erc721Metadata; // STORAGE[0x5] bytes 0 to 19\naddress _vrc; // STORAGE[0x6] bytes 0 to 19\naddress _vcx; // STORAGE[0x7] bytes 0 to 19\nuint160 _vrcWallet; // STORAGE[0x8] bytes 0 to 19\nuint160 _vcxWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nPurchase(address, uint256);\nApproval(address, address, uint256);\nUnpause();\nPause();\nTransfer(address, address, uint256);\nCreateItem(uint256, uint8, uint8, uint8, uint8, uint256, uint256, address);\n\nfunction setMetadataAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _erc721Metadata = varg0;\n}\n\nfunction contributorWhiteListTime(address varg0) public nonPayable { \n    return _contributorWhiteListTime[varg0];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x1230(varg0);\n}\n\nfunction setVCX(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    _vcx = varg0;\n    _vcxWallet = varg1;\n    _vcxCount = varg2;\n}\n\nfunction vcx() public nonPayable { \n    return _vcx;\n}\n\nfunction hardCap() public nonPayable { \n    return 0xa968163f0a57b400000;\n}\n\nfunction itemIndexToOwner(uint256 varg0) public nonPayable { \n    return address(_itemIndexToOwner[varg0]);\n}\n\nfunction 0x1230(uint256 varg0) private { \n    require(!_paused);\n    require(address(varg0) != 0);\n    require(msg.value >= 0x16345785d8a0000);\n    _weiRaised = _weiRaised + msg.value;\n    require(_weiRaised <= 0xa968163f0a57b400000);\n    emit Purchase(address(varg0), msg.value);\n    v0 = address(varg0);\n    if (_contributorBalance[v0] != 0) {\n        v1 = address(varg0);\n        require(!(0xff & _contributorComplete[v1]));\n        v2 = address(varg0);\n        require(msg.value >= _contributorBalance[v2] * 99);\n        v3 = address(varg0);\n        v4 = address(varg0);\n        _contributorBalance[v4] = _contributorBalance[v4] + msg.value;\n        v5 = address(varg0);\n        v6 = v7 = _contributorBalance[v5];\n        if (v7 >= 0x22b1c8c1227a00000) {\n            if (v7 >= 0x56bc75e2d63100000) {\n                if (v7 >= 0x1b1ae4d6e2ef500000) {\n                    if (v7 >= 0x3635c9adc5dea00000) {\n                        if (v7 >= 0x10f0cf064dd59200000) {\n                            if (v7 >= 0x10f0cf064dd59200000) {\n                                0x3bf3(varg0, v7);\n                                0x3ccf(varg0, v7);\n                                0x3d42(varg0, v7);\n                                0x3df0(varg0, v7);\n                                v8 = v9 = 14456;\n                                v10 = v11 = 20;\n                                if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                                    v6 = v12 = v7 * 135 / 100;\n                                }\n                                goto 0x3ca10x3623B0x150c;\n                            }\n                        } else {\n                            0x3bf3(varg0, v7);\n                            0x3ccf(varg0, v7);\n                            0x3d42(varg0, v7);\n                            0x3df0(varg0, v7);\n                            v8 = v13 = 14343;\n                            v10 = v14 = 19;\n                            if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                                v6 = v15 = v7 * 120 / 100;\n                            }\n                            goto 0x3ca10x3623B0x150c;\n                        }\n                    } else {\n                        0x3bf3(varg0, v7);\n                        0x3ccf(varg0, v7);\n                        0x3d42(varg0, v7);\n                        0x3db4(varg0, v7);\n                        v8 = v16 = 14231;\n                        v10 = v17 = 18;\n                        if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                            v6 = v18 = v7 * 115 / 100;\n                        }\n                        goto 0x3ca10x3623B0x150c;\n                    }\n                } else {\n                    0x3bf3(varg0, v7);\n                    0x3ccf(varg0, v7);\n                    0x3d42(varg0, v7);\n                    0x3db4(varg0, v7);\n                    v8 = v19 = 14120;\n                    v10 = v20 = 17;\n                    if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                        v6 = v21 = v7 * 110 / 100;\n                    }\n                    goto 0x3ca10x3623B0x150c;\n                }\n            } else {\n                0x3bf3(varg0, v7);\n                0x3ccf(varg0, v7);\n                0x3c65(varg0, v7);\n                v8 = v22 = 14009;\n                v10 = v23 = 16;\n                if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                    v6 = v24 = v7 * 105 / 100;\n                }\n            }\n            v25 = 0x3e76(varg0, v6, 5, 3, v10, 0);\n            goto {'0x3797B0x150c', '0x36b9B0x150c', '0x3728B0x150c', '0x3807B0x150c', '0x3878B0x150c'};\n            v26 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3887B0x150c;\n            v27 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3886B0x150c;\n            v28 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3885B0x150c;\n            v29 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3884B0x150c;\n            v30 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n        } else {\n            0x3bf3(varg0, v7);\n            0x3c65(varg0, v7);\n            v31 = 0x3e76(varg0, v7, 5, 3, 15, 0);\n            v32 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n        }\n        v33 = address(varg0);\n        _contributorComplete[v33] = 0x1 | ~0xff & _contributorComplete[v33];\n        _contributorsCompleteCount += 1;\n    } else {\n        _contributorsCount.length = _contributorsCount.length + 1;\n        _contributorsCount[_contributorsCount.length + 1 - 1] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _contributorsCount[_contributorsCount.length + 1 - 1];\n        v34 = address(varg0);\n        _contributorBalance[v34] = _contributorBalance[v34] + msg.value;\n        v35 = address(varg0);\n        _contributorBalance[v35] = block.timestamp;\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    0x1230(msg.sender);\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    v0 = v1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & keccak256('supportsInterface(bytes4)');\n    if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & keccak256('supportsInterface(bytes4)')) {\n        v0 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (keccak256('name()') ^ keccak256('symbol()') ^ keccak256('totalSupply()') ^ keccak256('balanceOf(address)') ^ keccak256('ownerOf(uint)') ^ keccak256('approve(address,uint)') ^ keccak256('transfer(address,uint)') ^ keccak256('transferFrom(address,address,uin', 0x7429000000000000000000000000000000000000000000000000000000000000) ^ keccak256('tokensOfOwner(address)') ^ keccak256('tokenMetadata(uint,string)'));\n    }\n    return v0;\n}\n\nfunction tokenMetadata(uint256 varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    MEM[(MEM[64]) len 128] = this.code[this.code.size len 128];\n    require(_erc721Metadata != 0);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(_erc721Metadata.code.size);\n    v6 = _erc721Metadata.getMetadata(varg0, v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    v7 = v8 = MEM[64];\n    require(RETURNDATASIZE() >= 160);\n    v9 = v10 = MEM[128 + v8];\n    v11 = new bytes[](v10);\n    if (v10) {\n        MEM[(v11.data) len (v10 << 5)] = this.code[this.code.size len (v10 << 5)];\n    }\n    v12 = v13 = v11.data;\n    while (v9 >= 32) {\n        MEM[v12] = MEM[v7];\n        v12 = v12 + 32;\n        v7 = v7 + 32;\n        v9 = v9 - 32;\n    }\n    MEM[v12] = MEM[v12] & 256 ** (32 - v9) - 1 | MEM[v7] & ~(256 ** (32 - v9) - 1);\n    v14 = new array[](v11.length);\n    v15 = v16 = 0;\n    while (v15 < v11.length) {\n        MEM[v14.data + v15] = MEM[v11.data + v15];\n        v15 = v15 + 32;\n    }\n    v17 = v18 = v11.length + v14.data;\n    if (0x1f & v11.length) {\n        MEM[v18 - (0x1f & v11.length)] = ~(256 ** (32 - (0x1f & v11.length)) - 1) & MEM[v18 - (0x1f & v11.length)];\n    }\n    return v14;\n}\n\nfunction 0x3067(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0);\n    require(address(_itemIndexToOwner[varg0]) == msg.sender);\n    require(address(_itemIndexToOwner[varg0]) != address(varg1));\n    _ownershipTokenCount[msg.sender] = _ownershipTokenCount[msg.sender] - 1;\n    v0 = address(varg1);\n    _ownershipTokenCount[v0] += 1;\n    _ownershipTokenCount[varg0] = address(varg1) | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg0];\n    _ownershipTokenCount[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg0];\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v1.length + v0.data;\n    if (1) {\n        MEM[v5 - 1] = 0x7300000000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0, v6, 'Cryptoverse Preorder Bonus Asset';\n}\n\nfunction 0x3bf3(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 4, 0, 0, 5);\n    v1 = 0x3e76(varg0, varg1, 4, 0, 0, 6);\n    v2 = 0x3e76(varg0, varg1, 4, 0, 0, 7);\n    v3 = 0x3e76(varg0, varg1, 4, 0, 6, 8);\n    v4 = 0x3e76(varg0, varg1, 4, 0, 9, 9);\n    v5 = 0x3e76(varg0, varg1, 4, 0, 12, 10);\n    return ;\n}\n\nfunction 0x3c65(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 4, 3, 5, 2);\n    v1 = 0x3e76(varg0, varg1, 4, 3, 5, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3ccf(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 5, 1, 1, 5);\n    v1 = 0x3e76(varg0, varg1, 5, 1, 1, 6);\n    v2 = 0x3e76(varg0, varg1, 5, 1, 1, 7);\n    v3 = 0x3e76(varg0, varg1, 5, 1, 7, 8);\n    v4 = 0x3e76(varg0, varg1, 5, 1, 10, 9);\n    v5 = 0x3e76(varg0, varg1, 5, 1, 13, 10);\n    return ;\n}\n\nfunction 0x3d42(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 6, 2, 2, 5);\n    v1 = 0x3e76(varg0, varg1, 6, 2, 2, 6);\n    v2 = 0x3e76(varg0, varg1, 6, 2, 2, 7);\n    v3 = 0x3e76(varg0, varg1, 6, 2, 8, 8);\n    v4 = 0x3e76(varg0, varg1, 6, 2, 11, 9);\n    v5 = 0x3e76(varg0, varg1, 6, 2, 14, 10);\n    return ;\n}\n\nfunction 0x3db4(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 5, 3, 4, 2);\n    v1 = 0x3e76(varg0, varg1, 5, 3, 4, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3df0(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 6, 3, 2, 2);\n    v1 = 0x3e76(varg0, varg1, 6, 3, 2, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3e76(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { \n    MEM[64] = MEM[64] + 192;\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    require(address(varg0) != 0);\n    assert(varg5 <= 10);\n    assert(varg4 <= 21);\n    assert(varg3 <= 3);\n    assert(varg2 <= 6);\n    _totalSupply.length = _totalSupply.length + 1;\n    v0 = varg5;\n    assert(v0 <= 10);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v0 | ~0xff & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v1 = varg4;\n    assert(v1 <= 21);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v1 << 8 | ~0xff00 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v2 = varg3;\n    assert(v2 <= 3);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v2 << 16 | ~0xff0000 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v3 = varg2;\n    assert(v3 <= 6);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v3 << 24 | ~0xff000000 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    STORAGE[1 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = block.timestamp;\n    STORAGE[2 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = varg1;\n    assert(varg5 <= 10);\n    v4 = 0xff & varg5;\n    assert(varg4 <= 21);\n    v5 = 0xff & varg4;\n    assert(varg3 <= 3);\n    v6 = 0xff & varg3;\n    assert(varg2 <= 6);\n    v7 = 0xff & varg2;\n    emit CreateItem(address(varg0), _totalSupply.length, v4, v5, v6, v7, block.timestamp, varg1);\n    v8 = address(varg0);\n    _ownershipTokenCount[v8] += 1;\n    _ownershipTokenCount[v8] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[v8];\n    return _totalSupply.length;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(address(_itemIndexToOwner[varg1]) == msg.sender);\n    _itemIndexToApproved[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _itemIndexToApproved[varg1];\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction vcxWallet() public nonPayable { \n    return _vcxWallet;\n}\n\nfunction reclaimToken(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply.length;\n}\n\nfunction isBoxItemId(uint256 varg0) public nonPayable { \n    assert(varg0 < _totalSupply.length);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8 <= 21);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8 <= 21);\n    MEM[32 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8;\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16 <= 3);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16 <= 3);\n    MEM[64 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16;\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24 <= 6);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24 <= 6);\n    MEM[96 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24;\n    MEM[128 + MEM[64]] = STORAGE[3 * varg0 + keccak256(1) + 1];\n    MEM[160 + MEM[64]] = STORAGE[3 * varg0 + keccak256(1) + 2];\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    v0 = v1 = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] == 0;\n    if (0xff & STORAGE[3 * varg0 + keccak256(1) + 0] != 0) {\n        assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n        v0 = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] == 1;\n    }\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg1 != address(this));\n    require(address(_itemIndexToApproved[varg2]) == msg.sender);\n    require(address(_itemIndexToOwner[varg2]) == varg0);\n    _ownershipTokenCount[varg0] = _ownershipTokenCount[varg0] - 1;\n    _ownershipTokenCount[varg1] += 1;\n    _ownershipTokenCount[varg1] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg1];\n    _ownershipTokenCount[varg1] = ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg1];\n    emit Transfer(varg0, varg1, varg2);\n}\n\nfunction vcxCount() public nonPayable { \n    return _vcxCount;\n}\n\nfunction contributorComplete(address varg0) public nonPayable { \n    return 0xff & _contributorComplete[varg0];\n}\n\nfunction vrcWallet() public nonPayable { \n    return _vrcWallet;\n}\n\nfunction contributors(uint256 varg0) public nonPayable { \n    assert(varg0 < _contributorsCount.length);\n    return address(_contributorsCount[varg0]);\n}\n\nfunction openBoxes(uint256[] varg0) public nonPayable { \n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length << 5);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        if (v1 < v0.length) {\n            break;\n        }\n        assert(v1 < v0.length);\n        if (v0[v1] < _totalSupply.length) {\n            break;\n        }\n        assert(v0[v1] < _totalSupply.length);\n        v3 = 3 * v0[v1] + keccak256(1);\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        assert(0xff & STORAGE[v3 + 0] >> 8 <= 21);\n        assert(0xff & STORAGE[v3 + 0] >> 8 <= 21);\n        MEM[32 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 8;\n        assert(0xff & STORAGE[v3 + 0] >> 16 <= 3);\n        assert(0xff & STORAGE[v3 + 0] >> 16 <= 3);\n        MEM[64 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 16;\n        assert(0xff & STORAGE[v3 + 0] >> 24 <= 6);\n        assert(0xff & STORAGE[v3 + 0] >> 24 <= 6);\n        MEM[96 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 24;\n        MEM[128 + MEM[64]] = STORAGE[v3 + 1];\n        MEM[160 + MEM[64]] = STORAGE[v3 + 2];\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        v4 = v5 = 0xff & STORAGE[v3 + 0] == 0;\n        if (0xff & STORAGE[v3 + 0] != 0) {\n            assert(0xff & STORAGE[v3 + 0] <= 10);\n            v4 = 0xff & STORAGE[v3 + 0] == 1;\n        }\n        require(v4);\n        0x3067(v0[v1], this);\n        assert(0xff & STORAGE[0 + v3] <= 10);\n        if (0xff & STORAGE[0 + v3] != 0) {\n            assert(_weiRaised);\n            MEM[MEM[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n            require(_vcx.code.size);\n            v6 = _vcx.call(v7, _vcxWallet, msg.sender, STORAGE[2 + v3] * _vcxCount / _weiRaised).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        } else {\n            assert(_weiRaised);\n            MEM[MEM[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n            require(_vrc.code.size);\n            v8 = _vrc.call(v7, _vrcWallet, msg.sender, STORAGE[2 + v3] * _vrcCount / _weiRaised).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        }\n        v1 += 1;\n    }\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction contributorBalance(address varg0) public nonPayable { \n    return _contributorBalance[varg0];\n}\n\nfunction setVRC(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    _vrc = varg0;\n    _vrcWallet = varg1;\n    _vrcCount = varg2;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(address(_itemIndexToOwner[varg0]) != 0);\n    return address(_itemIndexToOwner[varg0]);\n}\n\nfunction minInvest() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _ownershipTokenCount[varg0];\n}\n\nfunction contributorsCount() public nonPayable { \n    return _contributorsCount.length;\n}\n\nfunction withdrawal(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction tokensOfOwner(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = v1 = new uint256[](_ownershipTokenCount[varg0]);\n        if (_ownershipTokenCount[varg0]) {\n            MEM[(v1.data) len (_ownershipTokenCount[varg0] << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] << 5)];\n        }\n        v2 = v3 = 0;\n        v4 = v5 = 0;\n        while (v4 < _totalSupply.length) {\n            if (address(_itemIndexToOwner[v4]) == varg0) {\n                assert(v2 < v1.length);\n                v1[v2] = v4;\n                v2 += 1;\n            }\n            v4 += 1;\n        }\n    } else {\n        v0 = v6 = new uint256[](0);\n    }\n    v7 = new array[](MEM[v0]);\n    v8 = v9 = 0;\n    while (v8 < MEM[v0] << 5) {\n        MEM[v7.data + v8] = MEM[32 + v0 + v8];\n        v8 = v8 + 32;\n    }\n    return v7;\n}\n\nfunction itemIndexToApproved(uint256 varg0) public nonPayable { \n    return address(_itemIndexToApproved[varg0]);\n}\n\nfunction tokensInfoOfOwner(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = v1 = new uint256[](_ownershipTokenCount[varg0] * 7);\n        if (_ownershipTokenCount[varg0] * 7) {\n            MEM[(v1.data) len (_ownershipTokenCount[varg0] * 7 << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] * 7 << 5)];\n        }\n        v2 = v3 = 0;\n        v4 = v5 = 0;\n        while (v4 < _totalSupply.length) {\n            if (address(_itemIndexToOwner[v4]) == varg0) {\n                assert(v4 < _totalSupply.length);\n                assert(v2 < v1.length);\n                v1[v2] = v4;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] <= 10);\n                assert(1 + v2 < v1.length);\n                v1[1 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))];\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 8 <= 21);\n                assert(2 + v2 < v1.length);\n                v1[2 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 8;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 16 <= 3);\n                assert(3 + v2 < v1.length);\n                v1[3 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 16;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 24 <= 6);\n                assert(4 + v2 < v1.length);\n                v1[4 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 24;\n                assert(5 + v2 < v1.length);\n                v1[5 + v2] = STORAGE[1 + (3 * v4 + keccak256(1))];\n                v2 += 7;\n                assert(6 + v2 < v1.length);\n                v1[6 + v2] = STORAGE[2 + (3 * v4 + keccak256(1))];\n            }\n            v4 += 1;\n        }\n    } else {\n        v0 = v6 = new uint256[](0);\n    }\n    v7 = new array[](MEM[v0]);\n    v8 = v9 = 0;\n    while (v8 < MEM[v0] << 5) {\n        MEM[v7.data + v8] = MEM[32 + v0 + v8];\n        v8 = v8 + 32;\n    }\n    return v7;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4350424100000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction vrcCount() public nonPayable { \n    return _vrcCount;\n}\n\nfunction getBoxes(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = new uint256[](_ownershipTokenCount[varg0]);\n        if (_ownershipTokenCount[varg0]) {\n            MEM[(v0.data) len (_ownershipTokenCount[varg0] << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] << 5)];\n        }\n        v1 = v2 = 0;\n        v3 = v4 = 0;\n        while (v3 < _totalSupply.length) {\n            v5 = v6 = address(_itemIndexToOwner[v3]) == varg0;\n            if (v6) {\n                assert(v3 < _totalSupply.length);\n                v7 = 0xff & STORAGE[3 * v3 + keccak256(1) + 0];\n                assert(v7 <= 10);\n                assert(v7 <= 10);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8 <= 21);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8 <= 21);\n                MEM[32 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8;\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16 <= 3);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16 <= 3);\n                MEM[64 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16;\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24 <= 6);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24 <= 6);\n                MEM[96 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24;\n                MEM[128 + MEM[64]] = STORAGE[3 * v3 + keccak256(1) + 1];\n                MEM[160 + MEM[64]] = STORAGE[3 * v3 + keccak256(1) + 2];\n                assert(v7 <= 10);\n                v5 = v8 = v7 == 0;\n                if (v7 != 0) {\n                    assert(v7 <= 10);\n                    v5 = v7 == 1;\n                }\n            }\n            if (v5) {\n                v1 += 1;\n                assert(v1 < v0.length);\n                v0[v1] = v3;\n            }\n            v3 += 1;\n        }\n        v9 = new uint256[](v1);\n        if (v1) {\n            MEM[(v9.data) len (v1 << 5)] = this.code[this.code.size len (v1 << 5)];\n        }\n        v10 = v11 = 0;\n        while (v10 < v1) {\n            assert(v10 < v0.length);\n            assert(v10 < v9.length);\n            v9[v10] = v0[v10];\n            v10 += 1;\n        }\n    } else {\n        v9 = v12 = new uint256[](0);\n    }\n    v13 = new array[](MEM[v9]);\n    v14 = v15 = 0;\n    while (v14 < MEM[v9] << 5) {\n        MEM[v13.data + v14] = MEM[32 + v9 + v14];\n        v14 = v14 + 32;\n    }\n    return v13;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x3067(varg1, varg0);\n}\n\nfunction vrc() public nonPayable { \n    return _vrc;\n}\n\nfunction erc721Metadata() public nonPayable { \n    return _erc721Metadata;\n}\n\nfunction items(uint256 varg0) public nonPayable { \n    assert(varg0 < _totalSupply.length);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] <= 10);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8 <= 21);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16 <= 3);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24 <= 6);\n    return 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))]), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24), STORAGE[1 + (3 * varg0 + keccak256(1))], STORAGE[2 + (3 * varg0 + keccak256(1))];\n}\n\nfunction tokenInfo(uint256 varg0) public nonPayable { \n    v0 = new uint256[](7);\n    if (7) {\n        MEM[(v0.data) len 224] = this.code[this.code.size len 224];\n    }\n    assert(varg0 < _totalSupply.length);\n    assert(0 < v0.length);\n    v1 = v0.data;\n    v2 = v0.data;\n    v0[0] = varg0;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] <= 10);\n    assert(1 < v0.length);\n    v0[1] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))];\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8 <= 21);\n    assert(2 < v0.length);\n    v0[2] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16 <= 3);\n    assert(3 < v0.length);\n    v0[3] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24 <= 6);\n    assert(4 < v0.length);\n    v0[4] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24;\n    assert(5 < v0.length);\n    v0[5] = STORAGE[1 + (3 * varg0 + keccak256(1))];\n    assert(6 < v0.length);\n    v0[6] = STORAGE[2 + (3 * varg0 + keccak256(1))];\n    v3 = new array[](v0.length);\n    v4 = v5 = 0;\n    while (v4 < 224) {\n        MEM[v3.data + v4] = MEM[v0.data + v4];\n        v4 = v4 + 32;\n    }\n    return v3, v6, varg0, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))], 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24, STORAGE[1 + (3 * varg0 + keccak256(1))], STORAGE[2 + (3 * varg0 + keccak256(1))];\n}\n\nfunction ownershipTokenCount(address varg0) public nonPayable { \n    return _ownershipTokenCount[varg0];\n}\n\nfunction contributorsCompleteCount() public nonPayable { \n    return _contributorsCompleteCount;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1ffc9a7 == function_selector) {\n            supportsInterface(bytes4);\n        } else if (0x560ff44 == function_selector) {\n            tokenMetadata(uint256,string);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc9daf45 == function_selector) {\n            vcxWallet();\n        } else if (0x17ffc320 == function_selector) {\n            reclaimToken(address);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x210e734c == function_selector) {\n            isBoxItemId(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x25402e6c == function_selector) {\n            vcxCount();\n        } else if (0x2ebb5056 == function_selector) {\n            contributorComplete(address);\n        } else if (0x3276249f == function_selector) {\n            vrcWallet();\n        } else if (0x3cb5d100 == function_selector) {\n            contributors(uint256);\n        } else if (0x3e52d5c6 == function_selector) {\n            openBoxes(uint256[]);\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4ab994ad == function_selector) {\n            contributorBalance(address);\n        } else if (0x56ddbe7a == function_selector) {\n            setVRC(address,address,uint256);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x6352211e == function_selector) {\n            ownerOf(uint256);\n        } else if (0x63fd9e38 == function_selector) {\n            minInvest();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7569b3d7 == function_selector) {\n            contributorsCount();\n        } else if (0x835fc6ca == function_selector) {\n            withdrawal(uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8462151c == function_selector) {\n            tokensOfOwner(address);\n        } else if (0x88072700 == function_selector) {\n            itemIndexToApproved(uint256);\n        } else if (0x8b157515 == function_selector) {\n            tokensInfoOfOwner(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa64e920d == function_selector) {\n            vrcCount();\n        } else if (0xa731f31a == function_selector) {\n            getBoxes(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb01454dd == function_selector) {\n            vrc();\n        } else if (0xbc4006f5 == function_selector) {\n            erc721Metadata();\n        } else if (0xbfb231d2 == function_selector) {\n            items(uint256);\n        } else if (0xcc33c875 == function_selector) {\n            tokenInfo(uint256);\n        } else if (0xcec21acb == function_selector) {\n            ownershipTokenCount(address);\n        } else if (0xdc45b93a == function_selector) {\n            contributorsCompleteCount();\n        } else if (0xe17b25af == function_selector) {\n            setMetadataAddress(address);\n        } else if (0xec39d6e6 == function_selector) {\n            contributorWhiteListTime(address);\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf1317352 == function_selector) {\n            setVCX(address,address,uint256);\n        } else if (0xfb7e54eb == function_selector) {\n            vcx();\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        } else if (0xfe9b1a89 == function_selector) {\n            itemIndexToOwner(uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 06:23 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _itemIndexToOwner; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _ownershipTokenCount; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _itemIndexToApproved; // STORAGE[0x4]\nuint256 _vrcCount; // STORAGE[0xa]\nuint256 _vcxCount; // STORAGE[0xb]\nuint256 _weiRaised; // STORAGE[0xc]\nuint256 _contributorsCompleteCount; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _contributorBalance; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _contributorComplete; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _contributorWhiteListTime; // STORAGE[0x10]\nuint256[] _contributorsCount; // STORAGE[0x11]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _erc721Metadata; // STORAGE[0x5] bytes 0 to 19\naddress _vrc; // STORAGE[0x6] bytes 0 to 19\naddress _vcx; // STORAGE[0x7] bytes 0 to 19\nuint160 _vrcWallet; // STORAGE[0x8] bytes 0 to 19\nuint160 _vcxWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nPurchase(address, uint256);\nApproval(address, address, uint256);\nUnpause();\nPause();\nTransfer(address, address, uint256);\nCreateItem(uint256, uint8, uint8, uint8, uint8, uint256, uint256, address);\n\nfunction setMetadataAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _erc721Metadata = varg0;\n}\n\nfunction contributorWhiteListTime(address varg0) public nonPayable { \n    return _contributorWhiteListTime[varg0];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x1230(varg0);\n}\n\nfunction setVCX(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    _vcx = varg0;\n    _vcxWallet = varg1;\n    _vcxCount = varg2;\n}\n\nfunction vcx() public nonPayable { \n    return _vcx;\n}\n\nfunction hardCap() public nonPayable { \n    return 0xa968163f0a57b400000;\n}\n\nfunction itemIndexToOwner(uint256 varg0) public nonPayable { \n    return address(_itemIndexToOwner[varg0]);\n}\n\nfunction 0x1230(uint256 varg0) private { \n    require(!_paused);\n    require(address(varg0) != 0);\n    require(msg.value >= 0x16345785d8a0000);\n    _weiRaised = _weiRaised + msg.value;\n    require(_weiRaised <= 0xa968163f0a57b400000);\n    emit Purchase(address(varg0), msg.value);\n    v0 = address(varg0);\n    if (_contributorBalance[v0] != 0) {\n        v1 = address(varg0);\n        require(!(0xff & _contributorComplete[v1]));\n        v2 = address(varg0);\n        require(msg.value >= _contributorBalance[v2] * 99);\n        v3 = address(varg0);\n        v4 = address(varg0);\n        _contributorBalance[v4] = _contributorBalance[v4] + msg.value;\n        v5 = address(varg0);\n        v6 = v7 = _contributorBalance[v5];\n        if (v7 >= 0x22b1c8c1227a00000) {\n            if (v7 >= 0x56bc75e2d63100000) {\n                if (v7 >= 0x1b1ae4d6e2ef500000) {\n                    if (v7 >= 0x3635c9adc5dea00000) {\n                        if (v7 >= 0x10f0cf064dd59200000) {\n                            if (v7 >= 0x10f0cf064dd59200000) {\n                                0x3bf3(varg0, v7);\n                                0x3ccf(varg0, v7);\n                                0x3d42(varg0, v7);\n                                0x3df0(varg0, v7);\n                                v8 = v9 = 14456;\n                                v10 = v11 = 20;\n                                if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                                    v6 = v12 = v7 * 135 / 100;\n                                }\n                                goto 0x3ca10x3623B0x150c;\n                            }\n                        } else {\n                            0x3bf3(varg0, v7);\n                            0x3ccf(varg0, v7);\n                            0x3d42(varg0, v7);\n                            0x3df0(varg0, v7);\n                            v8 = v13 = 14343;\n                            v10 = v14 = 19;\n                            if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                                v6 = v15 = v7 * 120 / 100;\n                            }\n                            goto 0x3ca10x3623B0x150c;\n                        }\n                    } else {\n                        0x3bf3(varg0, v7);\n                        0x3ccf(varg0, v7);\n                        0x3d42(varg0, v7);\n                        0x3db4(varg0, v7);\n                        v8 = v16 = 14231;\n                        v10 = v17 = 18;\n                        if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                            v6 = v18 = v7 * 115 / 100;\n                        }\n                        goto 0x3ca10x3623B0x150c;\n                    }\n                } else {\n                    0x3bf3(varg0, v7);\n                    0x3ccf(varg0, v7);\n                    0x3d42(varg0, v7);\n                    0x3db4(varg0, v7);\n                    v8 = v19 = 14120;\n                    v10 = v20 = 17;\n                    if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                        v6 = v21 = v7 * 110 / 100;\n                    }\n                    goto 0x3ca10x3623B0x150c;\n                }\n            } else {\n                0x3bf3(varg0, v7);\n                0x3ccf(varg0, v7);\n                0x3c65(varg0, v7);\n                v8 = v22 = 14009;\n                v10 = v23 = 16;\n                if (block.timestamp - _contributorWhiteListTime[v3] < 0x3f480) {\n                    v6 = v24 = v7 * 105 / 100;\n                }\n            }\n            v25 = 0x3e76(varg0, v6, 5, 3, v10, 0);\n            goto {'0x3797B0x150c', '0x36b9B0x150c', '0x3728B0x150c', '0x3807B0x150c', '0x3878B0x150c'};\n            v26 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3887B0x150c;\n            v27 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3886B0x150c;\n            v28 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3885B0x150c;\n            v29 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n            goto 0x3884B0x150c;\n            v30 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n        } else {\n            0x3bf3(varg0, v7);\n            0x3c65(varg0, v7);\n            v31 = 0x3e76(varg0, v7, 5, 3, 15, 0);\n            v32 = 0x3e76(varg0, v7, 6, 3, 21, 1);\n        }\n        v33 = address(varg0);\n        _contributorComplete[v33] = 0x1 | ~0xff & _contributorComplete[v33];\n        _contributorsCompleteCount += 1;\n    } else {\n        _contributorsCount.length = _contributorsCount.length + 1;\n        _contributorsCount[_contributorsCount.length + 1 - 1] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _contributorsCount[_contributorsCount.length + 1 - 1];\n        v34 = address(varg0);\n        _contributorBalance[v34] = _contributorBalance[v34] + msg.value;\n        v35 = address(varg0);\n        _contributorBalance[v35] = block.timestamp;\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    0x1230(msg.sender);\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    v0 = v1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & keccak256('supportsInterface(bytes4)');\n    if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & keccak256('supportsInterface(bytes4)')) {\n        v0 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0) == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (keccak256('name()') ^ keccak256('symbol()') ^ keccak256('totalSupply()') ^ keccak256('balanceOf(address)') ^ keccak256('ownerOf(uint)') ^ keccak256('approve(address,uint)') ^ keccak256('transfer(address,uint)') ^ keccak256('transferFrom(address,address,uin', 0x7429000000000000000000000000000000000000000000000000000000000000) ^ keccak256('tokensOfOwner(address)') ^ keccak256('tokenMetadata(uint,string)'));\n    }\n    return v0;\n}\n\nfunction tokenMetadata(uint256 varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    MEM[(MEM[64]) len 128] = this.code[this.code.size len 128];\n    require(_erc721Metadata != 0);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(_erc721Metadata.code.size);\n    v6 = _erc721Metadata.getMetadata(varg0, v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    v7 = v8 = MEM[64];\n    require(RETURNDATASIZE() >= 160);\n    v9 = v10 = MEM[128 + v8];\n    v11 = new bytes[](v10);\n    if (v10) {\n        MEM[(v11.data) len (v10 << 5)] = this.code[this.code.size len (v10 << 5)];\n    }\n    v12 = v13 = v11.data;\n    while (v9 >= 32) {\n        MEM[v12] = MEM[v7];\n        v12 = v12 + 32;\n        v7 = v7 + 32;\n        v9 = v9 - 32;\n    }\n    MEM[v12] = MEM[v12] & 256 ** (32 - v9) - 1 | MEM[v7] & ~(256 ** (32 - v9) - 1);\n    v14 = new array[](v11.length);\n    v15 = v16 = 0;\n    while (v15 < v11.length) {\n        MEM[v14.data + v15] = MEM[v11.data + v15];\n        v15 = v15 + 32;\n    }\n    v17 = v18 = v11.length + v14.data;\n    if (0x1f & v11.length) {\n        MEM[v18 - (0x1f & v11.length)] = ~(256 ** (32 - (0x1f & v11.length)) - 1) & MEM[v18 - (0x1f & v11.length)];\n    }\n    return v14;\n}\n\nfunction 0x3067(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0);\n    require(address(_itemIndexToOwner[varg0]) == msg.sender);\n    require(address(_itemIndexToOwner[varg0]) != address(varg1));\n    _ownershipTokenCount[msg.sender] = _ownershipTokenCount[msg.sender] - 1;\n    v0 = address(varg1);\n    _ownershipTokenCount[v0] += 1;\n    _ownershipTokenCount[varg0] = address(varg1) | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg0];\n    _ownershipTokenCount[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg0];\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v1.length + v0.data;\n    if (1) {\n        MEM[v5 - 1] = 0x7300000000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0, v6, 'Cryptoverse Preorder Bonus Asset';\n}\n\nfunction 0x3bf3(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 4, 0, 0, 5);\n    v1 = 0x3e76(varg0, varg1, 4, 0, 0, 6);\n    v2 = 0x3e76(varg0, varg1, 4, 0, 0, 7);\n    v3 = 0x3e76(varg0, varg1, 4, 0, 6, 8);\n    v4 = 0x3e76(varg0, varg1, 4, 0, 9, 9);\n    v5 = 0x3e76(varg0, varg1, 4, 0, 12, 10);\n    return ;\n}\n\nfunction 0x3c65(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 4, 3, 5, 2);\n    v1 = 0x3e76(varg0, varg1, 4, 3, 5, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3ccf(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 5, 1, 1, 5);\n    v1 = 0x3e76(varg0, varg1, 5, 1, 1, 6);\n    v2 = 0x3e76(varg0, varg1, 5, 1, 1, 7);\n    v3 = 0x3e76(varg0, varg1, 5, 1, 7, 8);\n    v4 = 0x3e76(varg0, varg1, 5, 1, 10, 9);\n    v5 = 0x3e76(varg0, varg1, 5, 1, 13, 10);\n    return ;\n}\n\nfunction 0x3d42(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 6, 2, 2, 5);\n    v1 = 0x3e76(varg0, varg1, 6, 2, 2, 6);\n    v2 = 0x3e76(varg0, varg1, 6, 2, 2, 7);\n    v3 = 0x3e76(varg0, varg1, 6, 2, 8, 8);\n    v4 = 0x3e76(varg0, varg1, 6, 2, 11, 9);\n    v5 = 0x3e76(varg0, varg1, 6, 2, 14, 10);\n    return ;\n}\n\nfunction 0x3db4(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 5, 3, 4, 2);\n    v1 = 0x3e76(varg0, varg1, 5, 3, 4, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3df0(uint256 varg0, uint256 varg1) private { \n    v0 = 0x3e76(varg0, varg1, 6, 3, 2, 2);\n    v1 = 0x3e76(varg0, varg1, 6, 3, 2, 3);\n    v2 = 0x3e76(varg0, varg1, 6, 3, 3, 4);\n    return ;\n}\n\nfunction 0x3e76(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) private { \n    MEM[64] = MEM[64] + 192;\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    require(address(varg0) != 0);\n    assert(varg5 <= 10);\n    assert(varg4 <= 21);\n    assert(varg3 <= 3);\n    assert(varg2 <= 6);\n    _totalSupply.length = _totalSupply.length + 1;\n    v0 = varg5;\n    assert(v0 <= 10);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v0 | ~0xff & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v1 = varg4;\n    assert(v1 <= 21);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v1 << 8 | ~0xff00 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v2 = varg3;\n    assert(v2 <= 3);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v2 << 16 | ~0xff0000 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    v3 = varg2;\n    assert(v3 <= 6);\n    STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = v3 << 24 | ~0xff000000 & STORAGE[0 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))];\n    STORAGE[1 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = block.timestamp;\n    STORAGE[2 + (3 * (_totalSupply.length + 1 - 1) + keccak256(1))] = varg1;\n    assert(varg5 <= 10);\n    v4 = 0xff & varg5;\n    assert(varg4 <= 21);\n    v5 = 0xff & varg4;\n    assert(varg3 <= 3);\n    v6 = 0xff & varg3;\n    assert(varg2 <= 6);\n    v7 = 0xff & varg2;\n    emit CreateItem(address(varg0), _totalSupply.length, v4, v5, v6, v7, block.timestamp, varg1);\n    v8 = address(varg0);\n    _ownershipTokenCount[v8] += 1;\n    _ownershipTokenCount[v8] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[v8];\n    return _totalSupply.length;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(address(_itemIndexToOwner[varg1]) == msg.sender);\n    _itemIndexToApproved[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _itemIndexToApproved[varg1];\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction vcxWallet() public nonPayable { \n    return _vcxWallet;\n}\n\nfunction reclaimToken(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply.length;\n}\n\nfunction isBoxItemId(uint256 varg0) public nonPayable { \n    assert(varg0 < _totalSupply.length);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8 <= 21);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8 <= 21);\n    MEM[32 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 8;\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16 <= 3);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16 <= 3);\n    MEM[64 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 16;\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24 <= 6);\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24 <= 6);\n    MEM[96 + MEM[64]] = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] >> 24;\n    MEM[128 + MEM[64]] = STORAGE[3 * varg0 + keccak256(1) + 1];\n    MEM[160 + MEM[64]] = STORAGE[3 * varg0 + keccak256(1) + 2];\n    assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n    v0 = v1 = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] == 0;\n    if (0xff & STORAGE[3 * varg0 + keccak256(1) + 0] != 0) {\n        assert(0xff & STORAGE[3 * varg0 + keccak256(1) + 0] <= 10);\n        v0 = 0xff & STORAGE[3 * varg0 + keccak256(1) + 0] == 1;\n    }\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg1 != address(this));\n    require(address(_itemIndexToApproved[varg2]) == msg.sender);\n    require(address(_itemIndexToOwner[varg2]) == varg0);\n    _ownershipTokenCount[varg0] = _ownershipTokenCount[varg0] - 1;\n    _ownershipTokenCount[varg1] += 1;\n    _ownershipTokenCount[varg1] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg1];\n    _ownershipTokenCount[varg1] = ~0xffffffffffffffffffffffffffffffffffffffff & _ownershipTokenCount[varg1];\n    emit Transfer(varg0, varg1, varg2);\n}\n\nfunction vcxCount() public nonPayable { \n    return _vcxCount;\n}\n\nfunction contributorComplete(address varg0) public nonPayable { \n    return 0xff & _contributorComplete[varg0];\n}\n\nfunction vrcWallet() public nonPayable { \n    return _vrcWallet;\n}\n\nfunction contributors(uint256 varg0) public nonPayable { \n    assert(varg0 < _contributorsCount.length);\n    return address(_contributorsCount[varg0]);\n}\n\nfunction openBoxes(uint256[] varg0) public nonPayable { \n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length << 5);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        if (v1 < v0.length) {\n            break;\n        }\n        assert(v1 < v0.length);\n        if (v0[v1] < _totalSupply.length) {\n            break;\n        }\n        assert(v0[v1] < _totalSupply.length);\n        v3 = 3 * v0[v1] + keccak256(1);\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        assert(0xff & STORAGE[v3 + 0] >> 8 <= 21);\n        assert(0xff & STORAGE[v3 + 0] >> 8 <= 21);\n        MEM[32 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 8;\n        assert(0xff & STORAGE[v3 + 0] >> 16 <= 3);\n        assert(0xff & STORAGE[v3 + 0] >> 16 <= 3);\n        MEM[64 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 16;\n        assert(0xff & STORAGE[v3 + 0] >> 24 <= 6);\n        assert(0xff & STORAGE[v3 + 0] >> 24 <= 6);\n        MEM[96 + MEM[64]] = 0xff & STORAGE[v3 + 0] >> 24;\n        MEM[128 + MEM[64]] = STORAGE[v3 + 1];\n        MEM[160 + MEM[64]] = STORAGE[v3 + 2];\n        assert(0xff & STORAGE[v3 + 0] <= 10);\n        v4 = v5 = 0xff & STORAGE[v3 + 0] == 0;\n        if (0xff & STORAGE[v3 + 0] != 0) {\n            assert(0xff & STORAGE[v3 + 0] <= 10);\n            v4 = 0xff & STORAGE[v3 + 0] == 1;\n        }\n        require(v4);\n        0x3067(v0[v1], this);\n        assert(0xff & STORAGE[0 + v3] <= 10);\n        if (0xff & STORAGE[0 + v3] != 0) {\n            assert(_weiRaised);\n            MEM[MEM[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n            require(_vcx.code.size);\n            v6 = _vcx.call(v7, _vcxWallet, msg.sender, STORAGE[2 + v3] * _vcxCount / _weiRaised).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        } else {\n            assert(_weiRaised);\n            MEM[MEM[64]] = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n            require(_vrc.code.size);\n            v8 = _vrc.call(v7, _vrcWallet, msg.sender, STORAGE[2 + v3] * _vrcCount / _weiRaised).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        }\n        v1 += 1;\n    }\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction contributorBalance(address varg0) public nonPayable { \n    return _contributorBalance[varg0];\n}\n\nfunction setVRC(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    _vrc = varg0;\n    _vrcWallet = varg1;\n    _vrcCount = varg2;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(address(_itemIndexToOwner[varg0]) != 0);\n    return address(_itemIndexToOwner[varg0]);\n}\n\nfunction minInvest() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _ownershipTokenCount[varg0];\n}\n\nfunction contributorsCount() public nonPayable { \n    return _contributorsCount.length;\n}\n\nfunction withdrawal(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction tokensOfOwner(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = v1 = new uint256[](_ownershipTokenCount[varg0]);\n        if (_ownershipTokenCount[varg0]) {\n            MEM[(v1.data) len (_ownershipTokenCount[varg0] << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] << 5)];\n        }\n        v2 = v3 = 0;\n        v4 = v5 = 0;\n        while (v4 < _totalSupply.length) {\n            if (address(_itemIndexToOwner[v4]) == varg0) {\n                assert(v2 < v1.length);\n                v1[v2] = v4;\n                v2 += 1;\n            }\n            v4 += 1;\n        }\n    } else {\n        v0 = v6 = new uint256[](0);\n    }\n    v7 = new array[](MEM[v0]);\n    v8 = v9 = 0;\n    while (v8 < MEM[v0] << 5) {\n        MEM[v7.data + v8] = MEM[32 + v0 + v8];\n        v8 = v8 + 32;\n    }\n    return v7;\n}\n\nfunction itemIndexToApproved(uint256 varg0) public nonPayable { \n    return address(_itemIndexToApproved[varg0]);\n}\n\nfunction tokensInfoOfOwner(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = v1 = new uint256[](_ownershipTokenCount[varg0] * 7);\n        if (_ownershipTokenCount[varg0] * 7) {\n            MEM[(v1.data) len (_ownershipTokenCount[varg0] * 7 << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] * 7 << 5)];\n        }\n        v2 = v3 = 0;\n        v4 = v5 = 0;\n        while (v4 < _totalSupply.length) {\n            if (address(_itemIndexToOwner[v4]) == varg0) {\n                assert(v4 < _totalSupply.length);\n                assert(v2 < v1.length);\n                v1[v2] = v4;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] <= 10);\n                assert(1 + v2 < v1.length);\n                v1[1 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))];\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 8 <= 21);\n                assert(2 + v2 < v1.length);\n                v1[2 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 8;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 16 <= 3);\n                assert(3 + v2 < v1.length);\n                v1[3 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 16;\n                assert(0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 24 <= 6);\n                assert(4 + v2 < v1.length);\n                v1[4 + v2] = 0xff & STORAGE[0 + (3 * v4 + keccak256(1))] >> 24;\n                assert(5 + v2 < v1.length);\n                v1[5 + v2] = STORAGE[1 + (3 * v4 + keccak256(1))];\n                v2 += 7;\n                assert(6 + v2 < v1.length);\n                v1[6 + v2] = STORAGE[2 + (3 * v4 + keccak256(1))];\n            }\n            v4 += 1;\n        }\n    } else {\n        v0 = v6 = new uint256[](0);\n    }\n    v7 = new array[](MEM[v0]);\n    v8 = v9 = 0;\n    while (v8 < MEM[v0] << 5) {\n        MEM[v7.data + v8] = MEM[32 + v0 + v8];\n        v8 = v8 + 32;\n    }\n    return v7;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4350424100000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction vrcCount() public nonPayable { \n    return _vrcCount;\n}\n\nfunction getBoxes(address varg0) public nonPayable { \n    if (_ownershipTokenCount[varg0] != 0) {\n        v0 = new uint256[](_ownershipTokenCount[varg0]);\n        if (_ownershipTokenCount[varg0]) {\n            MEM[(v0.data) len (_ownershipTokenCount[varg0] << 5)] = this.code[this.code.size len (_ownershipTokenCount[varg0] << 5)];\n        }\n        v1 = v2 = 0;\n        v3 = v4 = 0;\n        while (v3 < _totalSupply.length) {\n            v5 = v6 = address(_itemIndexToOwner[v3]) == varg0;\n            if (v6) {\n                assert(v3 < _totalSupply.length);\n                v7 = 0xff & STORAGE[3 * v3 + keccak256(1) + 0];\n                assert(v7 <= 10);\n                assert(v7 <= 10);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8 <= 21);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8 <= 21);\n                MEM[32 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 8;\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16 <= 3);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16 <= 3);\n                MEM[64 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 16;\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24 <= 6);\n                assert(0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24 <= 6);\n                MEM[96 + MEM[64]] = 0xff & STORAGE[3 * v3 + keccak256(1) + 0] >> 24;\n                MEM[128 + MEM[64]] = STORAGE[3 * v3 + keccak256(1) + 1];\n                MEM[160 + MEM[64]] = STORAGE[3 * v3 + keccak256(1) + 2];\n                assert(v7 <= 10);\n                v5 = v8 = v7 == 0;\n                if (v7 != 0) {\n                    assert(v7 <= 10);\n                    v5 = v7 == 1;\n                }\n            }\n            if (v5) {\n                v1 += 1;\n                assert(v1 < v0.length);\n                v0[v1] = v3;\n            }\n            v3 += 1;\n        }\n        v9 = new uint256[](v1);\n        if (v1) {\n            MEM[(v9.data) len (v1 << 5)] = this.code[this.code.size len (v1 << 5)];\n        }\n        v10 = v11 = 0;\n        while (v10 < v1) {\n            assert(v10 < v0.length);\n            assert(v10 < v9.length);\n            v9[v10] = v0[v10];\n            v10 += 1;\n        }\n    } else {\n        v9 = v12 = new uint256[](0);\n    }\n    v13 = new array[](MEM[v9]);\n    v14 = v15 = 0;\n    while (v14 < MEM[v9] << 5) {\n        MEM[v13.data + v14] = MEM[32 + v9 + v14];\n        v14 = v14 + 32;\n    }\n    return v13;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x3067(varg1, varg0);\n}\n\nfunction vrc() public nonPayable { \n    return _vrc;\n}\n\nfunction erc721Metadata() public nonPayable { \n    return _erc721Metadata;\n}\n\nfunction items(uint256 varg0) public nonPayable { \n    assert(varg0 < _totalSupply.length);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] <= 10);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8 <= 21);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16 <= 3);\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24 <= 6);\n    return 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))]), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16), 0xff & (0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24), STORAGE[1 + (3 * varg0 + keccak256(1))], STORAGE[2 + (3 * varg0 + keccak256(1))];\n}\n\nfunction tokenInfo(uint256 varg0) public nonPayable { \n    v0 = new uint256[](7);\n    if (7) {\n        MEM[(v0.data) len 224] = this.code[this.code.size len 224];\n    }\n    assert(varg0 < _totalSupply.length);\n    assert(0 < v0.length);\n    v1 = v0.data;\n    v2 = v0.data;\n    v0[0] = varg0;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] <= 10);\n    assert(1 < v0.length);\n    v0[1] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))];\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8 <= 21);\n    assert(2 < v0.length);\n    v0[2] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16 <= 3);\n    assert(3 < v0.length);\n    v0[3] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16;\n    assert(0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24 <= 6);\n    assert(4 < v0.length);\n    v0[4] = 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24;\n    assert(5 < v0.length);\n    v0[5] = STORAGE[1 + (3 * varg0 + keccak256(1))];\n    assert(6 < v0.length);\n    v0[6] = STORAGE[2 + (3 * varg0 + keccak256(1))];\n    v3 = new array[](v0.length);\n    v4 = v5 = 0;\n    while (v4 < 224) {\n        MEM[v3.data + v4] = MEM[v0.data + v4];\n        v4 = v4 + 32;\n    }\n    return v3, v6, varg0, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))], 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 8, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 16, 0xff & STORAGE[0 + (3 * varg0 + keccak256(1))] >> 24, STORAGE[1 + (3 * varg0 + keccak256(1))], STORAGE[2 + (3 * varg0 + keccak256(1))];\n}\n\nfunction ownershipTokenCount(address varg0) public nonPayable { \n    return _ownershipTokenCount[varg0];\n}\n\nfunction contributorsCompleteCount() public nonPayable { \n    return _contributorsCompleteCount;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1ffc9a7 == function_selector) {\n            supportsInterface(bytes4);\n        } else if (0x560ff44 == function_selector) {\n            tokenMetadata(uint256,string);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc9daf45 == function_selector) {\n            vcxWallet();\n        } else if (0x17ffc320 == function_selector) {\n            reclaimToken(address);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x210e734c == function_selector) {\n            isBoxItemId(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x25402e6c == function_selector) {\n            vcxCount();\n        } else if (0x2ebb5056 == function_selector) {\n            contributorComplete(address);\n        } else if (0x3276249f == function_selector) {\n            vrcWallet();\n        } else if (0x3cb5d100 == function_selector) {\n            contributors(uint256);\n        } else if (0x3e52d5c6 == function_selector) {\n            openBoxes(uint256[]);\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4ab994ad == function_selector) {\n            contributorBalance(address);\n        } else if (0x56ddbe7a == function_selector) {\n            setVRC(address,address,uint256);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x6352211e == function_selector) {\n            ownerOf(uint256);\n        } else if (0x63fd9e38 == function_selector) {\n            minInvest();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7569b3d7 == function_selector) {\n            contributorsCount();\n        } else if (0x835fc6ca == function_selector) {\n            withdrawal(uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8462151c == function_selector) {\n            tokensOfOwner(address);\n        } else if (0x88072700 == function_selector) {\n            itemIndexToApproved(uint256);\n        } else if (0x8b157515 == function_selector) {\n            tokensInfoOfOwner(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa64e920d == function_selector) {\n            vrcCount();\n        } else if (0xa731f31a == function_selector) {\n            getBoxes(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb01454dd == function_selector) {\n            vrc();\n        } else if (0xbc4006f5 == function_selector) {\n            erc721Metadata();\n        } else if (0xbfb231d2 == function_selector) {\n            items(uint256);\n        } else if (0xcc33c875 == function_selector) {\n            tokenInfo(uint256);\n        } else if (0xcec21acb == function_selector) {\n            ownershipTokenCount(address);\n        } else if (0xdc45b93a == function_selector) {\n            contributorsCompleteCount();\n        } else if (0xe17b25af == function_selector) {\n            setMetadataAddress(address);\n        } else if (0xec39d6e6 == function_selector) {\n            contributorWhiteListTime(address);\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf1317352 == function_selector) {\n            setVCX(address,address,uint256);\n        } else if (0xfb7e54eb == function_selector) {\n            vcx();\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        } else if (0xfe9b1a89 == function_selector) {\n            itemIndexToOwner(uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 42.66455125808716,
	"usage": {
		"completion_tokens": 745,
		"prompt_tokens": 11712,
		"total_tokens": 12457
	}
}