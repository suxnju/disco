{
	"address": "0xf29a03e88c425116c979892d475f5cddf1f742ce",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on your decompiled code, the corresponding Solidity contract could look something like this:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _amountRaised;\n    uint256 private _amountRaisedPhase;\n    uint256 private _price;\n    mapping (address => uint256) private _balanceOf;\n    address private _destroy;\n    address private _tokenReward;\n\n    event FundTransfer(address indexed _backer, uint256 _amount, bool _isContribution);\n\n    function tokenReward() public view returns (address) {\n        return _tokenReward;\n    }\n\n    function balanceOf(address _address) public view returns (uint256) {\n        return _balanceOf[_address];\n    }\n\n    function amountRaised() public view returns (uint256) {\n        return _amountRaised;\n    }\n\n    function destroy() public {\n        require(_destroy == msg.sender);\n        selfdestruct(payable(_destroy));\n    }\n\n    function owner() public view returns (address) {\n        return _destroy;\n    }\n\n    function price() public view returns (uint256) {\n        return _price;\n    }\n\n    function destroyAndSend(address _recipient) public {\n        require(_destroy == msg.sender);\n        selfdestruct(payable(_recipient));\n    }\n\n    function amountRaisedPhase() public view returns (uint256) {\n        return _amountRaisedPhase;\n    }\n\n    function safeWithdrawal() public {\n        require(_destroy == msg.sender);\n        _amountRaisedPhase = 0;\n\n        bool success = payable(_destroy).send(_amountRaisedPhase);\n        require(success, \"Failed to send Ether\");\n        \n        emit FundTransfer(_destroy, _amountRaisedPhase, false);\n    }\n\n    receive() external payable {\n        require(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] += msg.value;\n        require(msg.value + _amountRaised >= _amountRaised);\n        _amountRaised += msg.value;\n        require(msg.value + _amountRaisedPhase >= _amountRaisedPhase);\n        _amountRaisedPhase += msg.value;\n\n        uint256 amount = msg.value * 10000 / _price;\n        (bool success,) = _tokenReward.call{value: msg.value}(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, amount));\n        require(success, \"Failed to send token\");\n\n        emit FundTransfer(msg.sender, msg.value, true);\n    }\n}\n```\n\nPlease note that the actual implementation in Solidity might vary depending on your requirements and the actual logic of the contract. This code does not include any constructor or initialization methods, and does not handle any token logic such as approving and transferring tokens. You should adjust the code to match your exact needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468179,
	"id": "chatcmpl-8R5t50SkA3wKzKYN7AQ6yGXoDvx3n",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 11:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _amountRaised; // STORAGE[0x1]\nuint256 _amountRaisedPhase; // STORAGE[0x2]\nuint256 _price; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\naddress _destroy; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress _tokenReward; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction destroy() public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(_destroy);\n}\n\nfunction owner() public nonPayable { \n    return _destroy;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction destroyAndSend(address varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(varg0);\n}\n\nfunction amountRaisedPhase() public nonPayable { \n    return _amountRaisedPhase;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    require(_destroy == msg.sender);\n    _amountRaisedPhase = 0;\n    emit FundTransfer(_destroy, _amountRaisedPhase, 0);\n    v0 = _destroy.call().value(_amountRaisedPhase).gas(2300 * !_amountRaisedPhase);\n    require(v0);\n}\n\nfunction fallback() public payable { \n    assert(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value;\n    assert(msg.value + _amountRaised >= _amountRaised);\n    _amountRaised += msg.value;\n    assert(msg.value + _amountRaisedPhase >= _amountRaisedPhase);\n    _amountRaisedPhase += msg.value;\n    v0 = v1 = !msg.value;\n    if (msg.value) {\n        assert(msg.value);\n        v0 = 10000 * msg.value / msg.value == 10000;\n    }\n    assert(v0);\n    assert(stor_3_0_0);\n    require(_tokenReward.code.size);\n    v2 = _tokenReward.transfer(msg.sender, 10000 * msg.value / _price).gas(msg.gas - 710);\n    require(v2);\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6e66f6e9) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0x83197ef0 == function_selector) {\n            destroy();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xf5074f41 == function_selector) {\n            destroyAndSend(address);\n        } else if (0xfab4969f == function_selector) {\n            amountRaisedPhase();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 11:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _amountRaised; // STORAGE[0x1]\nuint256 _amountRaisedPhase; // STORAGE[0x2]\nuint256 _price; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\naddress _destroy; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress _tokenReward; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction destroy() public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(_destroy);\n}\n\nfunction owner() public nonPayable { \n    return _destroy;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction destroyAndSend(address varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(varg0);\n}\n\nfunction amountRaisedPhase() public nonPayable { \n    return _amountRaisedPhase;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    require(_destroy == msg.sender);\n    _amountRaisedPhase = 0;\n    emit FundTransfer(_destroy, _amountRaisedPhase, 0);\n    v0 = _destroy.call().value(_amountRaisedPhase).gas(2300 * !_amountRaisedPhase);\n    require(v0);\n}\n\nfunction fallback() public payable { \n    assert(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value;\n    assert(msg.value + _amountRaised >= _amountRaised);\n    _amountRaised += msg.value;\n    assert(msg.value + _amountRaisedPhase >= _amountRaisedPhase);\n    _amountRaisedPhase += msg.value;\n    v0 = v1 = !msg.value;\n    if (msg.value) {\n        assert(msg.value);\n        v0 = 10000 * msg.value / msg.value == 10000;\n    }\n    assert(v0);\n    assert(stor_3_0_0);\n    require(_tokenReward.code.size);\n    v2 = _tokenReward.transfer(msg.sender, 10000 * msg.value / _price).gas(msg.gas - 710);\n    require(v2);\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6e66f6e9) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0x83197ef0 == function_selector) {\n            destroy();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xf5074f41 == function_selector) {\n            destroyAndSend(address);\n        } else if (0xfab4969f == function_selector) {\n            amountRaisedPhase();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 11:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _amountRaised; // STORAGE[0x1]\nuint256 _amountRaisedPhase; // STORAGE[0x2]\nuint256 _price; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\naddress _destroy; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress _tokenReward; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction destroy() public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(_destroy);\n}\n\nfunction owner() public nonPayable { \n    return _destroy;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction destroyAndSend(address varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(varg0);\n}\n\nfunction amountRaisedPhase() public nonPayable { \n    return _amountRaisedPhase;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    require(_destroy == msg.sender);\n    _amountRaisedPhase = 0;\n    emit FundTransfer(_destroy, _amountRaisedPhase, 0);\n    v0 = _destroy.call().value(_amountRaisedPhase).gas(2300 * !_amountRaisedPhase);\n    require(v0);\n}\n\nfunction fallback() public payable { \n    assert(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value;\n    assert(msg.value + _amountRaised >= _amountRaised);\n    _amountRaised += msg.value;\n    assert(msg.value + _amountRaisedPhase >= _amountRaisedPhase);\n    _amountRaisedPhase += msg.value;\n    v0 = v1 = !msg.value;\n    if (msg.value) {\n        assert(msg.value);\n        v0 = 10000 * msg.value / msg.value == 10000;\n    }\n    assert(v0);\n    assert(stor_3_0_0);\n    require(_tokenReward.code.size);\n    v2 = _tokenReward.transfer(msg.sender, 10000 * msg.value / _price).gas(msg.gas - 710);\n    require(v2);\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6e66f6e9) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0x83197ef0 == function_selector) {\n            destroy();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xf5074f41 == function_selector) {\n            destroyAndSend(address);\n        } else if (0xfab4969f == function_selector) {\n            amountRaisedPhase();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 43.55577301979065,
	"usage": {
		"completion_tokens": 566,
		"prompt_tokens": 912,
		"total_tokens": 1478
	}
}