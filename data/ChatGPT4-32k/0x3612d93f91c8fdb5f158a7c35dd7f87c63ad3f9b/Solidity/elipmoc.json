{
	"address": "0x3612d93f91c8fdb5f158a7c35dd7f87c63ad3f9b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code that corresponds to the decompiled code:\n\n```solidity\npragma solidity >=0.5.0;\n\ncontract MyContract {\n    mapping (uint256 => uint256[]) private _mBuyList; \n    address private _owner; \n    address private _mInviteAddr; \n    address private _mPerSellData; \n    uint8 private _isLock;\n\n    event transferToOwnerEvent(uint256);\n    event buyPerSellEvent(uint16, bytes32, uint256);\n    event updateIntefaceEvent();\n\n    function GetPerSellInfo(uint16 varg0) public view returns (uint16, uint256, uint256) { \n        require(_mPerSellData.code.length > 0);\n        (bool v0, bytes memory data) = _mPerSellData.call(abi.encodeWithSignature(\"GetPerSellInfo(uint16)\", varg0));\n        require(v0);\n        (uint16 v1, uint256 v2, uint256 v3) = abi.decode(data, (uint16, uint256, uint256));\n        return (v1, v2, v3);\n    }\n\n    function mInviteAddr() public view returns (address) { \n        return _mInviteAddr;\n    }\n\n    function transferToOwner() public { \n        require(msg.sender == _owner, 'only owner can call this function');\n        require(!isContract(msg.sender), 'address must is not contract');\n        require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n        (bool success,) = _owner.call.value(address(this).balance)(\"\");\n        require(success);\n        emit transferToOwnerEvent(address(this).balance);\n    }\n\n    function getBuyInfo(address varg0) public view returns (uint256[] memory) { \n        return _mBuyList[varg0];\n    }\n\n    function buyPerSell(uint16 varg0, bytes32 varg1) public payable { \n        require(!_isLock, 'contract current is lock status');\n        require(!isContract(msg.sender), 'address must is not contract');\n        require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n        require(_mPerSellData.code.length > 0);\n        (bool v0, bytes memory data) = _mPerSellData.call(abi.encodeWithSignature(\"GetPerSellInfo(uint16)\", varg0));\n        require(v0);\n        (uint16 v1, uint256 v2, bool v3) = abi.decode(data, (uint16, uint256, bool));\n        require(varg0 == v1, 'perSell.Id is error');\n        require(v2 == msg.value, 'msg.value is error');\n        require(!v3, 'persell is over status');\n        require(_mInviteAddr.code.length > 0);\n        (bool success,) = _mInviteAddr.call(abi.encodeWithSignature(\"GetAddressByName(bytes32)\", varg1));\n        require(success);\n        if (v0) {\n            (bool sent,) = _mInviteAddr.call.value(msg.value / 10)(\"\");\n            require(sent);\n        }\n        _mBuyList[msg.sender].push(varg0);\n        emit buyPerSellEvent(varg0, varg1, v2);\n    }\n\n    function updateInteface(address varg0, address varg1) public { \n        require(msg.sender == _owner, 'only owner can call this function');\n        require(!isContract(msg.sender), 'address must is not contract');\n        require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n        _mInviteAddr = varg0;\n        _mPerSellData = varg1;\n        emit updateIntefaceEvent();\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function updateLock(bool varg0) public { \n        require(msg.sender == _owner, 'only owner can call this function');\n        _isLock = varg0;\n    }\n\n    function mBuyList(address varg0, uint256 varg1) public view returns (uint256) { \n        require(varg1 < _mBuyList[varg0].length);\n        return _mBuyList[varg0][varg1];\n    }\n\n    function transferOwnership(address varg0) public { \n        require(msg.sender == _owner, 'only owner can call this function');\n        _owner = varg0;\n    }\n\n    function isLock() public view returns (uint8) { \n        return _isLock;\n    }\n\n    function mPerSellData() public view returns (address) { \n        return _mPerSellData;\n    }\n\n    function() external payable { \n        revert();\n    }\n\n    function isContract(address _addr) private view returns (bool){\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n}\n```\n\nPlease note that Solidity does not support direct calls to `RETURNDATASIZE()`, `msg.gas`, `code.size`, etc., hence I have used the appropriate Solidity alternatives. Also, you need to implement the `GetPerSellInfo` and `GetAddressByName` functions in the `_mPerSellData` and `_mInviteAddr` contracts respectively, and their interfaces should match with the one used in this contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457473,
	"id": "chatcmpl-8R36P0pDYWBZQmOOXlNvnj0tfE9xw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 22:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _mBuyList; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _mInviteAddr; // STORAGE[0x1] bytes 0 to 19\naddress _mPerSellData; // STORAGE[0x2] bytes 0 to 19\nuint8 _isLock; // STORAGE[0x0] bytes 20 to 20\n\n// Events\ntransferToOwnerEvent(uint256);\nbuyPerSellEvent(uint16, bytes32, uint256);\nupdateIntefaceEvent();\n\nfunction GetPerSellInfo(uint16 varg0) public nonPayable { \n    require(_mPerSellData.code.size);\n    v0, v1, v2, v3 = _mPerSellData.GetPerSellInfo(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 96);\n    return uint16(v1), v2, v3;\n}\n\nfunction mInviteAddr() public nonPayable { \n    return _mInviteAddr;\n}\n\nfunction transferToOwner() public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    v0 = _owner.call().value(this.balance).gas(!this.balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit transferToOwnerEvent(this.balance);\n}\n\nfunction getBuyInfo(address varg0) public nonPayable { \n    v0 = v1 = MEM[64] + 32;\n    if (_mBuyList[varg0]) {\n        v2 = v3 = 0;\n        do {\n            MEM[v0] = uint16(STORAGE[v4] / 256 ** v2);\n            v0 += 32;\n            v4 += 3 + v2 >> 5;\n            v2 = (2 + v2) * (1 - (3 + v2 >> 5));\n        } while (v1 + (_mBuyList[varg0] << 5) <= v0);\n    }\n    v5 = new array[](_mBuyList[varg0]);\n    v6 = v7 = 0;\n    while (v6 < _mBuyList[varg0] << 5) {\n        MEM[v6 + v5.data] = MEM[v6 + (32 + MEM[64])];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction buyPerSell(uint16 varg0, bytes32 varg1) public payable { \n    require(!_isLock, 'contract current is lock status');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    require(_mPerSellData.code.size);\n    v0, v1, v2, v3 = _mPerSellData.GetPerSellInfo(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 96);\n    v4 = v5 = varg0 == uint16(v1);\n    if (v5) {\n        v4 = v6 = uint16(v1) > 0;\n    }\n    require(v4, 'perSell.Id is error');\n    require(v2 == msg.value, 'msg.value is error');\n    require(!v3, 'persell is over status');\n    require(_mInviteAddr.code.size);\n    v7, v8 = _mInviteAddr.GetAddressByName(varg1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (address(v8)) {\n        v9 = address(v8).call().value(10 * msg.value / 100).gas(2300 * !(10 * msg.value / 100));\n        require(v9); // checks call status, propagates error data on error\n    }\n    _mBuyList[msg.sender] = _mBuyList[msg.sender] + 1;\n    STORAGE[(_mBuyList[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 3))] = uint16(v1) * 256 ** ((_mBuyList[msg.sender] & 0xf) << 1) | STORAGE[(_mBuyList[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 3))] & ~(0xffff * 256 ** ((_mBuyList[msg.sender] & 0xf) << 1));\n    emit buyPerSellEvent(varg0, varg1, v2);\n}\n\nfunction updateInteface(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    _mInviteAddr = varg0;\n    _mPerSellData = varg1;\n    emit updateIntefaceEvent();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction updateLock(bool varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(varg0 != _isLock, ' updateLock new status == old status', ' updateLock new status == old status');\n    _isLock = varg0;\n}\n\nfunction mBuyList(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 < _mBuyList[varg0]);\n    return uint16(STORAGE[varg1 + keccak256(keccak256(varg0, 3))] / 256 ** (varg1 % 16 << 1));\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    if (varg0) {\n        _owner = varg0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isLock() public nonPayable { \n    return _isLock;\n}\n\nfunction mPerSellData() public nonPayable { \n    return _mPerSellData;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9d8da2e) {\n            isLock();\n        } else if (0x15fdf660 == function_selector) {\n            mPerSellData();\n        } else if (0x227ac0cf == function_selector) {\n            GetPerSellInfo(uint16);\n        } else if (0x2c1ff9f8 == function_selector) {\n            mInviteAddr();\n        } else if (0x2d90ae94 == function_selector) {\n            transferToOwner();\n        } else if (0x390adde5 == function_selector) {\n            getBuyInfo(address);\n        } else if (0x8a3907b9 == function_selector) {\n            buyPerSell(uint16,bytes32);\n        } else if (0x8a874084 == function_selector) {\n            updateInteface(address,address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa1f91057 == function_selector) {\n            updateLock(bool);\n        } else if (0xde10ef9f == function_selector) {\n            mBuyList(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 22:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _mBuyList; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _mInviteAddr; // STORAGE[0x1] bytes 0 to 19\naddress _mPerSellData; // STORAGE[0x2] bytes 0 to 19\nuint8 _isLock; // STORAGE[0x0] bytes 20 to 20\n\n// Events\ntransferToOwnerEvent(uint256);\nbuyPerSellEvent(uint16, bytes32, uint256);\nupdateIntefaceEvent();\n\nfunction GetPerSellInfo(uint16 varg0) public nonPayable { \n    require(_mPerSellData.code.size);\n    v0, v1, v2, v3 = _mPerSellData.GetPerSellInfo(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 96);\n    return uint16(v1), v2, v3;\n}\n\nfunction mInviteAddr() public nonPayable { \n    return _mInviteAddr;\n}\n\nfunction transferToOwner() public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    v0 = _owner.call().value(this.balance).gas(!this.balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit transferToOwnerEvent(this.balance);\n}\n\nfunction getBuyInfo(address varg0) public nonPayable { \n    v0 = v1 = MEM[64] + 32;\n    if (_mBuyList[varg0]) {\n        v2 = v3 = 0;\n        do {\n            MEM[v0] = uint16(STORAGE[v4] / 256 ** v2);\n            v0 += 32;\n            v4 += 3 + v2 >> 5;\n            v2 = (2 + v2) * (1 - (3 + v2 >> 5));\n        } while (v1 + (_mBuyList[varg0] << 5) <= v0);\n    }\n    v5 = new array[](_mBuyList[varg0]);\n    v6 = v7 = 0;\n    while (v6 < _mBuyList[varg0] << 5) {\n        MEM[v6 + v5.data] = MEM[v6 + (32 + MEM[64])];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction buyPerSell(uint16 varg0, bytes32 varg1) public payable { \n    require(!_isLock, 'contract current is lock status');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    require(_mPerSellData.code.size);\n    v0, v1, v2, v3 = _mPerSellData.GetPerSellInfo(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 96);\n    v4 = v5 = varg0 == uint16(v1);\n    if (v5) {\n        v4 = v6 = uint16(v1) > 0;\n    }\n    require(v4, 'perSell.Id is error');\n    require(v2 == msg.value, 'msg.value is error');\n    require(!v3, 'persell is over status');\n    require(_mInviteAddr.code.size);\n    v7, v8 = _mInviteAddr.GetAddressByName(varg1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (address(v8)) {\n        v9 = address(v8).call().value(10 * msg.value / 100).gas(2300 * !(10 * msg.value / 100));\n        require(v9); // checks call status, propagates error data on error\n    }\n    _mBuyList[msg.sender] = _mBuyList[msg.sender] + 1;\n    STORAGE[(_mBuyList[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 3))] = uint16(v1) * 256 ** ((_mBuyList[msg.sender] & 0xf) << 1) | STORAGE[(_mBuyList[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 3))] & ~(0xffff * 256 ** ((_mBuyList[msg.sender] & 0xf) << 1));\n    emit buyPerSellEvent(varg0, varg1, v2);\n}\n\nfunction updateInteface(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    _mInviteAddr = varg0;\n    _mPerSellData = varg1;\n    emit updateIntefaceEvent();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction updateLock(bool varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(varg0 != _isLock, ' updateLock new status == old status', ' updateLock new status == old status');\n    _isLock = varg0;\n}\n\nfunction mBuyList(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 < _mBuyList[varg0]);\n    return uint16(STORAGE[varg1 + keccak256(keccak256(varg0, 3))] / 256 ** (varg1 % 16 << 1));\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    if (varg0) {\n        _owner = varg0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isLock() public nonPayable { \n    return _isLock;\n}\n\nfunction mPerSellData() public nonPayable { \n    return _mPerSellData;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9d8da2e) {\n            isLock();\n        } else if (0x15fdf660 == function_selector) {\n            mPerSellData();\n        } else if (0x227ac0cf == function_selector) {\n            GetPerSellInfo(uint16);\n        } else if (0x2c1ff9f8 == function_selector) {\n            mInviteAddr();\n        } else if (0x2d90ae94 == function_selector) {\n            transferToOwner();\n        } else if (0x390adde5 == function_selector) {\n            getBuyInfo(address);\n        } else if (0x8a3907b9 == function_selector) {\n            buyPerSell(uint16,bytes32);\n        } else if (0x8a874084 == function_selector) {\n            updateInteface(address,address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa1f91057 == function_selector) {\n            updateLock(bool);\n        } else if (0xde10ef9f == function_selector) {\n            mBuyList(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 22:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _mBuyList; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _mInviteAddr; // STORAGE[0x1] bytes 0 to 19\naddress _mPerSellData; // STORAGE[0x2] bytes 0 to 19\nuint8 _isLock; // STORAGE[0x0] bytes 20 to 20\n\n// Events\ntransferToOwnerEvent(uint256);\nbuyPerSellEvent(uint16, bytes32, uint256);\nupdateIntefaceEvent();\n\nfunction GetPerSellInfo(uint16 varg0) public nonPayable { \n    require(_mPerSellData.code.size);\n    v0, v1, v2, v3 = _mPerSellData.GetPerSellInfo(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 96);\n    return uint16(v1), v2, v3;\n}\n\nfunction mInviteAddr() public nonPayable { \n    return _mInviteAddr;\n}\n\nfunction transferToOwner() public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    v0 = _owner.call().value(this.balance).gas(!this.balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit transferToOwnerEvent(this.balance);\n}\n\nfunction getBuyInfo(address varg0) public nonPayable { \n    v0 = v1 = MEM[64] + 32;\n    if (_mBuyList[varg0]) {\n        v2 = v3 = 0;\n        do {\n            MEM[v0] = uint16(STORAGE[v4] / 256 ** v2);\n            v0 += 32;\n            v4 += 3 + v2 >> 5;\n            v2 = (2 + v2) * (1 - (3 + v2 >> 5));\n        } while (v1 + (_mBuyList[varg0] << 5) <= v0);\n    }\n    v5 = new array[](_mBuyList[varg0]);\n    v6 = v7 = 0;\n    while (v6 < _mBuyList[varg0] << 5) {\n        MEM[v6 + v5.data] = MEM[v6 + (32 + MEM[64])];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction buyPerSell(uint16 varg0, bytes32 varg1) public payable { \n    require(!_isLock, 'contract current is lock status');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    require(_mPerSellData.code.size);\n    v0, v1, v2, v3 = _mPerSellData.GetPerSellInfo(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 96);\n    v4 = v5 = varg0 == uint16(v1);\n    if (v5) {\n        v4 = v6 = uint16(v1) > 0;\n    }\n    require(v4, 'perSell.Id is error');\n    require(v2 == msg.value, 'msg.value is error');\n    require(!v3, 'persell is over status');\n    require(_mInviteAddr.code.size);\n    v7, v8 = _mInviteAddr.GetAddressByName(varg1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (address(v8)) {\n        v9 = address(v8).call().value(10 * msg.value / 100).gas(2300 * !(10 * msg.value / 100));\n        require(v9); // checks call status, propagates error data on error\n    }\n    _mBuyList[msg.sender] = _mBuyList[msg.sender] + 1;\n    STORAGE[(_mBuyList[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 3))] = uint16(v1) * 256 ** ((_mBuyList[msg.sender] & 0xf) << 1) | STORAGE[(_mBuyList[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 3))] & ~(0xffff * 256 ** ((_mBuyList[msg.sender] & 0xf) << 1));\n    emit buyPerSellEvent(varg0, varg1, v2);\n}\n\nfunction updateInteface(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    _mInviteAddr = varg0;\n    _mPerSellData = varg1;\n    emit updateIntefaceEvent();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction updateLock(bool varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(varg0 != _isLock, ' updateLock new status == old status', ' updateLock new status == old status');\n    _isLock = varg0;\n}\n\nfunction mBuyList(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 < _mBuyList[varg0]);\n    return uint16(STORAGE[varg1 + keccak256(keccak256(varg0, 3))] / 256 ** (varg1 % 16 << 1));\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    if (varg0) {\n        _owner = varg0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isLock() public nonPayable { \n    return _isLock;\n}\n\nfunction mPerSellData() public nonPayable { \n    return _mPerSellData;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9d8da2e) {\n            isLock();\n        } else if (0x15fdf660 == function_selector) {\n            mPerSellData();\n        } else if (0x227ac0cf == function_selector) {\n            GetPerSellInfo(uint16);\n        } else if (0x2c1ff9f8 == function_selector) {\n            mInviteAddr();\n        } else if (0x2d90ae94 == function_selector) {\n            transferToOwner();\n        } else if (0x390adde5 == function_selector) {\n            getBuyInfo(address);\n        } else if (0x8a3907b9 == function_selector) {\n            buyPerSell(uint16,bytes32);\n        } else if (0x8a874084 == function_selector) {\n            updateInteface(address,address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa1f91057 == function_selector) {\n            updateLock(bool);\n        } else if (0xde10ef9f == function_selector) {\n            mBuyList(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 39.66793251037598,
	"usage": {
		"completion_tokens": 1130,
		"prompt_tokens": 1859,
		"total_tokens": 2989
	}
}