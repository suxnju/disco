{
	"address": "0x9a6a87ff80a327e10f995e747e77d4a29999175e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract based on the provided decompiled code. Note that the original code is quite complex and it's not possible to perfectly reproduce the original Solidity source code from EVM bytecode. However, the following Solidity code should closely resemble the original contract.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    uint256 private _totalSupply;\n    mapping (uint256 => uint256) private _balances;\n    mapping (uint256 => uint256) private _allowed;\n    uint256 private _tranche;\n    mapping (uint256 => uint256) private _developers;\n    uint256 private _outstandingQuarters;\n    uint256 private _trancheDenominator;\n    uint256 private _large;\n    mapping (uint256 => uint256) private _rewards;\n    mapping (uint256 => uint256) private _trueBuy;\n    uint256 private _rewardAmount;\n    uint256 private _disburse;\n    address private _adjustReward;\n    uint8 private _decimals;\n    uint8 private stor_6_1_1;\n    uint16 private _ethRate;\n    uint8 private _rewardNumerator;\n    uint8 private _rewardDenominator;\n    uint8 private stor_11_0_0;\n    address private _migrationTarget;\n    uint8 private _migrating;\n\n    event QuartersOrdered(address indexed from, uint256 value, uint256 amount);\n    event MegaEarnings(address indexed from, uint256 value, uint256 baseRate, uint256 tranche, uint256 outstandingQuarters, uint256 contractBalance);\n    event Withdraw(address indexed from, uint256 value, uint256 baseRate, uint256 tranche, uint256 outstandingQuarters, uint256 contractBalance);\n    event Burn(address indexed from, uint256 amount);\n    event DeveloperStatusChanged(address indexed developer, bool status);\n    event EthRateChanged(uint16 oldRate, uint16 newRate);\n    event Migrate(address indexed from, uint256 amount);\n    event TrancheIncreased(uint256 newTranche, uint256 contractBalance, uint256 outstandingQuarters);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Reward(address indexed from, uint256 amount, uint256 outstandingQuarters, uint256 totalSupply);\n    event BaseRateChanged(uint256 baseRate, uint256 tranche, uint256 outstandingQuarters, uint256 contractBalance, uint256 totalSupply);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        _adjustReward = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[uint256(owner)];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[uint256(spender)];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[uint256(msg.sender)]);\n        require(to != address(0));\n\n        _balances[uint256(msg.sender)] = _balances[uint256(msg.sender)] - value;\n        _balances[uint256(to)] = _balances[uint256(to)] + value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[uint256(msg.sender)] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[uint256(from)]);\n        require(value <= _allowed[uint256(msg.sender)]);\n        require(to != address(0));\n\n        _balances[uint256(from)] = _balances[uint256(from)] - value;\n        _balances[uint256(to)] = _balances[uint256(to)] + value;\n        _allowed[uint256(msg.sender)] = _allowed[uint256(msg.sender)] - value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    // Additional functions and logic go here\n}\n```\nThis is a simple ERC20 token contract template, but the original contract includes additional logic and functions, which would need to be added based on the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460725,
	"id": "chatcmpl-8R3wrrCJeJNtdzKDYWUfHuc3yXDRE",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 11:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _tranche; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _developers; // STORAGE[0x8]\nuint256 _outstandingQuarters; // STORAGE[0x9]\nuint256 _trancheDenominator; // STORAGE[0xa]\nuint256 _large; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rewards; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _trueBuy; // STORAGE[0xd]\nuint256 _rewardAmount; // STORAGE[0xe]\nuint256 _disburse; // STORAGE[0x10]\naddress _adjustReward; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\nuint8 stor_6_1_1; // STORAGE[0x6] bytes 1 to 1\nuint16 _ethRate; // STORAGE[0x6] bytes 1 to 2\nuint8 _rewardNumerator; // STORAGE[0xf] bytes 0 to 0\nuint8 _rewardDenominator; // STORAGE[0xf] bytes 1 to 1\nuint8 stor_11_0_0; // STORAGE[0x11] bytes 0 to 0\naddress _migrationTarget; // STORAGE[0x11] bytes 0 to 19\nuint8 _migrating; // STORAGE[0x11] bytes 20 to 20\n\n// Events\nQuartersOrdered(address, uint256, uint256);\nMegaEarnings(address, uint256, uint256, uint256, uint256, uint256);\nWithdraw(address, uint256, uint256, uint256, uint256, uint256);\nBurn(address, uint256);\nDeveloperStatusChanged(address, bool);\nEthRateChanged(uint16, uint16);\nMigrate(address, uint256);\nTrancheIncreased(uint256, uint256, uint256);\nTransfer(address, address, uint256);\nReward(address, uint256, uint256, uint256);\nBaseRateChanged(uint256, uint256, uint256, uint256, uint256);\nApproval(address, address, uint256);\n\nfunction 0x10a7(uint256 varg0) private { \n    if (varg0 * uint32(_trancheDenominator >> 176) <= _tranche) {\n        if (varg0 * uint32(_large) <= _tranche) {\n            if (varg0 * uint32(_large >> 64) <= _tranche) {\n                if (varg0 * uint32(_large >> 128) <= _tranche) {\n                    return uint32(_large >> 192);\n                } else {\n                    v0 = v1 = uint32(_large >> 160);\n                }\n            } else {\n                v0 = v2 = uint32(_large >> 96);\n            }\n        } else {\n            v0 = v3 = uint32(_large >> 32);\n        }\n    } else {\n        v0 = v4 = uint32(_trancheDenominator >> 208);\n    }\n    return v0;\n}\n\nfunction 0x19f3() private { \n    if (_outstandingQuarters <= 0) {\n        v0 = v1 = (address(this)).balance - _disburse;\n    } else {\n        assert(_outstandingQuarters);\n        v0 = v2 = ((address(this)).balance - _disburse) / _outstandingQuarters;\n    }\n    return v0;\n}\n\nfunction 0x1be6(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2));\n    v0 = address(varg2);\n    v1 = v2 = 0;\n    if (_rewards[v0]) {\n        v3 = address(varg2);\n        if (_rewards[v3] < _tranche) {\n            v4 = address(varg2);\n            assert(_rewardDenominator);\n            v1 = v5 = _rewardNumerator * _trueBuy[v4] / _rewardDenominator;\n        }\n    } else {\n        v1 = v6 = _rewardAmount;\n    }\n    if (v1 > 0) {\n        v7 = address(varg2);\n        _rewards[v7] = _tranche;\n        _rewards[v7] += v1;\n        _allowed[msg.sender] += v1;\n        _totalSupply += v1;\n        _outstandingQuarters += v1;\n        assert(stor_6_1_1);\n        if (_disburse < v1 * 0xde0b6b3a7640000 / _ethRate) {\n            _disburse = 0;\n        } else {\n            _disburse = _disburse - v1 * 0xde0b6b3a7640000 / _ethRate;\n        }\n        0x1e06();\n        emit Approval(address(varg2), msg.sender, v1);\n        emit Reward(address(varg2), v1, _outstandingQuarters, _totalSupply);\n    }\n    v8 = address(varg2);\n    require(varg0 <= _allowed[msg.sender]);\n    v9 = address(varg2);\n    _allowed[msg.sender] = _allowed[msg.sender] - varg0;\n    v10 = 0x1ea6(varg0, varg1, varg2);\n    if (!v10) {\n        return 0;\n    } else {\n        v11 = address(varg1);\n        _allowed[msg.sender] += varg0;\n        emit Approval(v11, msg.sender, varg0);\n        return 1;\n    }\n}\n\nfunction 0x1e06() private { \n    if (_totalSupply >= _tranche) {\n        assert(0xff & _trancheDenominator >> 168);\n        _tranche = (_trancheDenominator >> 160 & 0xff) * _tranche / (0xff & _trancheDenominator >> 168);\n        emit TrancheIncreased(_tranche, (address(this)).balance, _outstandingQuarters);\n    }\n    return ;\n}\n\nfunction 0x1ea6(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balances[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balances[v1] + varg0 > _balances[v1]);\n    v2 = address(varg1);\n    v3 = address(varg2);\n    _balances[v3] = _balances[v3] - varg0;\n    _balances[v2] += varg0;\n    emit Transfer(v3, v2, varg0);\n    v4 = address(varg1);\n    v5 = address(varg2);\n    assert(_balances[v2] + _balances[v3] == _balances[v5] + _balances[v4]);\n    return 1;\n}\n\nfunction fallback() public payable { \n    v0 = 0x914(msg.sender);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction rewards(address varg0) public nonPayable { \n    return _rewards[varg0];\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction adjustNextTranche(uint8 varg0, uint8 varg1) public nonPayable { \n    require(_adjustReward == msg.sender);\n    v0 = v1 = 0xff & (0xff & varg0) > 0;\n    if (v1) {\n        v0 = v2 = 0xff & (varg1 & 0xff) > 0;\n    }\n    require(v0);\n    _trancheDenominator = (_trancheDenominator & ~0xff0000000000000000000000000000000000000000 | (0xff & (0xff & varg0)) << 160) & ~0xff000000000000000000000000000000000000000000 | (0xff & (varg1 & 0xff)) << 168;\n}\n\nfunction reserveETH() public nonPayable { \n    return _disburse;\n}\n\nfunction large() public nonPayable { \n    return uint32(_large);\n}\n\nfunction trueBuy(address varg0) public nonPayable { \n    return _trueBuy[varg0];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction trancheNumerator() public nonPayable { \n    return 0xff & _trancheDenominator >> 160 & 0xff;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowed[msg.sender]);\n    _allowed[msg.sender] = _allowed[msg.sender] - varg2;\n    v0 = 0x1ea6(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(1 == 0xff & _developers[msg.sender]);\n    require(_balances[msg.sender] >= varg0);\n    v0 = 0x19f3();\n    require(v0 > 0);\n    v1 = 0x10a7(varg0);\n    v2 = v3 = uint32(v1) * (varg0 * v0) / 100;\n    if (v3 > (address(this)).balance) {\n        v2 = v4 = (address(this)).balance;\n    }\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _outstandingQuarters = _outstandingQuarters - varg0;\n    if (uint32(v1) == uint32(_trancheDenominator >> 208)) {\n        emit MegaEarnings(msg.sender, v2, v0, _tranche, _outstandingQuarters, (address(this)).balance - v2);\n    }\n    emit Withdraw(msg.sender, v2, v0, _tranche, _outstandingQuarters, (address(this)).balance - v2);\n    v5 = 0x19f3();\n    emit BaseRateChanged(v5, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    v6 = msg.sender.call().value(v2).gas(2300 * !v2);\n    require(v6);\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction smallRate() public nonPayable { \n    return uint32(_large >> 160);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balances[msg.sender] >= varg0);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    _outstandingQuarters = _outstandingQuarters - varg0;\n    emit Burn(msg.sender, varg0);\n    v0 = 0x19f3();\n    emit BaseRateChanged(v0, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    return 1;\n}\n\nfunction migrating() public nonPayable { \n    return _migrating;\n}\n\nfunction outstandingQuarters() public nonPayable { \n    return _outstandingQuarters;\n}\n\nfunction q2() public nonPayable { \n    return address(_trancheDenominator);\n}\n\nfunction getRate(uint256 varg0) public nonPayable { \n    v0 = 0x10a7(varg0);\n    return uint32(v0);\n}\n\nfunction setDeveloperStatus(address varg0, bool varg1) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _developers[varg0] = varg1 | ~0xff & _developers[varg0];\n    emit DeveloperStatusChanged(varg0, varg1);\n}\n\nfunction migrationTarget() public nonPayable { \n    return _migrationTarget;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction developers(address varg0) public nonPayable { \n    return 0xff & _developers[varg0];\n}\n\nfunction adjustWithdrawRate(uint32 varg0, uint32 varg1, uint32 varg2, uint32 varg3, uint32 varg4, uint32 varg5, uint32 varg6, uint32 varg7, uint32 varg8) public nonPayable { \n    require(_adjustReward == msg.sender);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (v0) {\n        _trancheDenominator = (_trancheDenominator & ~0xffffffff00000000000000000000000000000000000000000000 | varg0 << 176) & 0xffff00000000ffffffffffffffffffffffffffffffffffffffffffffffffffff | varg1 << 208;\n    }\n    v2 = v3 = varg2 > 0;\n    if (v3) {\n        v2 = varg3 > 0;\n    }\n    if (v2) {\n        _large = (_large & ~0xffffffff | varg2) & ~0xffffffff00000000 | varg3 << 32;\n    }\n    v4 = v5 = varg4 > 0;\n    if (v5) {\n        v4 = varg5 > 0;\n    }\n    if (v4) {\n        _large = (_large & ~0xffffffff0000000000000000 | varg4 << 64) & ~0xffffffff000000000000000000000000 | varg5 << 96;\n    }\n    v6 = v7 = varg6 > 0;\n    if (v7) {\n        v6 = varg7 > 0;\n    }\n    if (v6) {\n        _large = (_large & ~0xffffffff00000000000000000000000000000000 | varg6 << 128) & ~0xffffffff0000000000000000000000000000000000000000 | varg7 << 160;\n    }\n    if (varg8 > 0) {\n        _large = varg8 << 192 | 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff & _large;\n    }\n}\n\nfunction small() public nonPayable { \n    return uint32(_large >> 128);\n}\n\nfunction tranche() public nonPayable { \n    return _tranche;\n}\n\nfunction buyFor(address varg0) public payable { \n    v0 = 0x914(varg0);\n    _allowed[msg.sender] += v0;\n    emit Approval(varg0, msg.sender, v0);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction adjustReward(uint256 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _rewardAmount = varg0;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[varg0] >= varg1);\n    require(varg1 <= _allowed[msg.sender]);\n    _balances[varg0] = _balances[varg0] - varg1;\n    _allowed[msg.sender] = _allowed[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    _outstandingQuarters = _outstandingQuarters - varg1;\n    emit Burn(varg0, varg1);\n    v0 = 0x19f3();\n    emit BaseRateChanged(v0, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    return 1;\n}\n\nfunction setEthRate(uint16 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0 > 0);\n    _ethRate = varg0;\n    emit EthRateChanged(_ethRate, varg0);\n}\n\nfunction rewardDenominator() public nonPayable { \n    return _rewardDenominator;\n}\n\nfunction owner() public nonPayable { \n    return _adjustReward;\n}\n\nfunction migrate() public nonPayable { \n    require(stor_11_0_0);\n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    _totalSupply = _totalSupply - _balances[msg.sender];\n    _outstandingQuarters = _outstandingQuarters - _balances[msg.sender];\n    _rewards[msg.sender] = 0;\n    _rewards[msg.sender] = 0;\n    _rewards[msg.sender] = ~0xff & _rewards[msg.sender];\n    emit Migrate(msg.sender, _balances[msg.sender]);\n    require(_migrationTarget.code.size);\n    v0 = _migrationTarget.migrateFrom(msg.sender, _balances[msg.sender], _rewards[msg.sender], _rewards[msg.sender], _rewards[msg.sender] & 0xff).gas(msg.gas);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction medium() public nonPayable { \n    return uint32(_large >> 64);\n}\n\nfunction microRate() public nonPayable { \n    return uint32(_large >> 192);\n}\n\nfunction buy() public payable { \n    v0 = 0x914(msg.sender);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1ea6(varg1, varg0, msg.sender);\n    return v0;\n}\n\nfunction disburse() public payable { \n    _disburse += msg.value;\n}\n\nfunction megaRate() public nonPayable { \n    return uint32(_trancheDenominator >> 208);\n}\n\nfunction getBaseRate() public nonPayable { \n    v0 = 0x19f3();\n    return v0;\n}\n\nfunction setMigrationTarget(address varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _migrationTarget = varg0;\n}\n\nfunction trancheDenominator() public nonPayable { \n    return 0xff & _trancheDenominator >> 168 & 0xff;\n}\n\nfunction mega() public nonPayable { \n    return uint32(_trancheDenominator >> 176);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (!1) {\n        v1 = v2 = 0;\n    } else {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v0.data + v4];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8);\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction transferAllowance(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x1be6(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction rewardNumerator() public nonPayable { \n    return _rewardNumerator;\n}\n\nfunction ethRate() public nonPayable { \n    return _ethRate;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction adjustTranche(uint256 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0 > 0);\n    _tranche = varg0;\n}\n\nfunction mediumRate() public nonPayable { \n    return uint32(_large >> 96);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0);\n    emit 0x384899bd253d83b23daa4d29aaa2efe0563d1132b43101e9ad667235aeb951b(_adjustReward, varg0);\n    _adjustReward = varg0;\n}\n\nfunction rewardAmount() public nonPayable { \n    return _rewardAmount;\n}\n\nfunction largeRate() public nonPayable { \n    return uint32(_large >> 32);\n}\n\nfunction 0x914(uint256 varg0) private { \n    require(address(varg0));\n    v0 = v1 = msg.value * _ethRate / 0xde0b6b3a7640000;\n    require(v1);\n    if (v1 > _tranche) {\n        v0 = v2 = _tranche;\n    }\n    _totalSupply += v0;\n    v3 = address(varg0);\n    _balances[v3] += v0;\n    _trueBuy[v3] += v0;\n    _outstandingQuarters += v0;\n    0x1e06();\n    emit QuartersOrdered(address(varg0), msg.value, v0);\n    v4 = 0x19f3();\n    emit BaseRateChanged(v4, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    require((address(_trancheDenominator)).code.size);\n    v5 = address(_trancheDenominator).disburse().value(msg.value * 15 / 100).gas(msg.gas);\n    require(v5);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x6fdde03) {\n            name();\n        } else if (0x700037d == v0) {\n            rewards(address);\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0xd3ade73 == v0) {\n            adjustNextTranche(uint8,uint8);\n        } else if (0x100af203 == v0) {\n            reserveETH();\n        } else if (0x12987c98 == v0) {\n            large();\n        } else if (0x17b1d17c == v0) {\n            trueBuy(address);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x1a833d3f == v0) {\n            trancheNumerator();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == v0) {\n            balances(address);\n        } else if (0x2e1a7d4d == v0) {\n            withdraw(uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x42767018 == v0) {\n            smallRate();\n        } else if (0x42966c68 == v0) {\n            burn(uint256);\n        } else if (0x4956cf1c == v0) {\n            migrating();\n        } else if (0x52812053 == v0) {\n            outstandingQuarters();\n        } else if (0x5615f415 == v0) {\n            q2();\n        } else if (0x57764094 == v0) {\n            getRate(uint256);\n        } else if (0x5a19c201 == v0) {\n            setDeveloperStatus(address,bool);\n        } else if (0x5b51acff == v0) {\n            migrationTarget();\n        } else if (0x5c658165 == v0) {\n            allowed(address,address);\n        } else if (0x61fd5c20 == v0) {\n            developers(address);\n        } else if (0x6433ef42 == v0) {\n            adjustWithdrawRate(uint32,uint32,uint32,uint32,uint32,uint32,uint32,uint32,uint32);\n        } else if (0x6cf3c25e == v0) {\n            small();\n        } else if (0x6ebc0af1 == v0) {\n            tranche();\n        } else if (0x6f0b5180 == v0) {\n            buyFor(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x716d3c6c == v0) {\n            adjustReward(uint256);\n        } else if (0x79cc6790 == v0) {\n            burnFrom(address,uint256);\n        } else if (0x84533794 == v0) {\n            setEthRate(uint16);\n        } else if (0x8509a001 == v0) {\n            rewardDenominator();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x8fd3ab80 == v0) {\n            migrate();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x97ccd07b == v0) {\n            medium();\n        } else if (0xa404f291 == v0) {\n            microRate();\n        } else if (0xa6f2ae3a == v0) {\n            buy();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xabc6fd0b == v0) {\n            disburse();\n        } else if (0xb5c47f69 == v0) {\n            megaRate();\n        } else if (0xb655d0c4 == v0) {\n            getBaseRate();\n        } else if (0xc231bace == v0) {\n            setMigrationTarget(address);\n        } else if (0xc50bd2e4 == v0) {\n            trancheDenominator();\n        } else if (0xc5f98a3f == v0) {\n            mega();\n        } else if (0xcae9ca51 == v0) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcbd2ecd2 == v0) {\n            transferAllowance(address,address,uint256);\n        } else if (0xcdd432d0 == v0) {\n            rewardNumerator();\n        } else if (0xd2d93f90 == v0) {\n            ethRate();\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xdf23128f == v0) {\n            adjustTranche(uint256);\n        } else if (0xed1923ee == v0) {\n            mediumRate();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf7b2a7be == v0) {\n            rewardAmount();\n        } else if (0xfd2dba2f == v0) {\n            largeRate();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 11:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _tranche; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _developers; // STORAGE[0x8]\nuint256 _outstandingQuarters; // STORAGE[0x9]\nuint256 _trancheDenominator; // STORAGE[0xa]\nuint256 _large; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rewards; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _trueBuy; // STORAGE[0xd]\nuint256 _rewardAmount; // STORAGE[0xe]\nuint256 _disburse; // STORAGE[0x10]\naddress _adjustReward; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\nuint8 stor_6_1_1; // STORAGE[0x6] bytes 1 to 1\nuint16 _ethRate; // STORAGE[0x6] bytes 1 to 2\nuint8 _rewardNumerator; // STORAGE[0xf] bytes 0 to 0\nuint8 _rewardDenominator; // STORAGE[0xf] bytes 1 to 1\nuint8 stor_11_0_0; // STORAGE[0x11] bytes 0 to 0\naddress _migrationTarget; // STORAGE[0x11] bytes 0 to 19\nuint8 _migrating; // STORAGE[0x11] bytes 20 to 20\n\n// Events\nQuartersOrdered(address, uint256, uint256);\nMegaEarnings(address, uint256, uint256, uint256, uint256, uint256);\nWithdraw(address, uint256, uint256, uint256, uint256, uint256);\nBurn(address, uint256);\nDeveloperStatusChanged(address, bool);\nEthRateChanged(uint16, uint16);\nMigrate(address, uint256);\nTrancheIncreased(uint256, uint256, uint256);\nTransfer(address, address, uint256);\nReward(address, uint256, uint256, uint256);\nBaseRateChanged(uint256, uint256, uint256, uint256, uint256);\nApproval(address, address, uint256);\n\nfunction 0x10a7(uint256 varg0) private { \n    if (varg0 * uint32(_trancheDenominator >> 176) <= _tranche) {\n        if (varg0 * uint32(_large) <= _tranche) {\n            if (varg0 * uint32(_large >> 64) <= _tranche) {\n                if (varg0 * uint32(_large >> 128) <= _tranche) {\n                    return uint32(_large >> 192);\n                } else {\n                    v0 = v1 = uint32(_large >> 160);\n                }\n            } else {\n                v0 = v2 = uint32(_large >> 96);\n            }\n        } else {\n            v0 = v3 = uint32(_large >> 32);\n        }\n    } else {\n        v0 = v4 = uint32(_trancheDenominator >> 208);\n    }\n    return v0;\n}\n\nfunction 0x19f3() private { \n    if (_outstandingQuarters <= 0) {\n        v0 = v1 = (address(this)).balance - _disburse;\n    } else {\n        assert(_outstandingQuarters);\n        v0 = v2 = ((address(this)).balance - _disburse) / _outstandingQuarters;\n    }\n    return v0;\n}\n\nfunction 0x1be6(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2));\n    v0 = address(varg2);\n    v1 = v2 = 0;\n    if (_rewards[v0]) {\n        v3 = address(varg2);\n        if (_rewards[v3] < _tranche) {\n            v4 = address(varg2);\n            assert(_rewardDenominator);\n            v1 = v5 = _rewardNumerator * _trueBuy[v4] / _rewardDenominator;\n        }\n    } else {\n        v1 = v6 = _rewardAmount;\n    }\n    if (v1 > 0) {\n        v7 = address(varg2);\n        _rewards[v7] = _tranche;\n        _rewards[v7] += v1;\n        _allowed[msg.sender] += v1;\n        _totalSupply += v1;\n        _outstandingQuarters += v1;\n        assert(stor_6_1_1);\n        if (_disburse < v1 * 0xde0b6b3a7640000 / _ethRate) {\n            _disburse = 0;\n        } else {\n            _disburse = _disburse - v1 * 0xde0b6b3a7640000 / _ethRate;\n        }\n        0x1e06();\n        emit Approval(address(varg2), msg.sender, v1);\n        emit Reward(address(varg2), v1, _outstandingQuarters, _totalSupply);\n    }\n    v8 = address(varg2);\n    require(varg0 <= _allowed[msg.sender]);\n    v9 = address(varg2);\n    _allowed[msg.sender] = _allowed[msg.sender] - varg0;\n    v10 = 0x1ea6(varg0, varg1, varg2);\n    if (!v10) {\n        return 0;\n    } else {\n        v11 = address(varg1);\n        _allowed[msg.sender] += varg0;\n        emit Approval(v11, msg.sender, varg0);\n        return 1;\n    }\n}\n\nfunction 0x1e06() private { \n    if (_totalSupply >= _tranche) {\n        assert(0xff & _trancheDenominator >> 168);\n        _tranche = (_trancheDenominator >> 160 & 0xff) * _tranche / (0xff & _trancheDenominator >> 168);\n        emit TrancheIncreased(_tranche, (address(this)).balance, _outstandingQuarters);\n    }\n    return ;\n}\n\nfunction 0x1ea6(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balances[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balances[v1] + varg0 > _balances[v1]);\n    v2 = address(varg1);\n    v3 = address(varg2);\n    _balances[v3] = _balances[v3] - varg0;\n    _balances[v2] += varg0;\n    emit Transfer(v3, v2, varg0);\n    v4 = address(varg1);\n    v5 = address(varg2);\n    assert(_balances[v2] + _balances[v3] == _balances[v5] + _balances[v4]);\n    return 1;\n}\n\nfunction fallback() public payable { \n    v0 = 0x914(msg.sender);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction rewards(address varg0) public nonPayable { \n    return _rewards[varg0];\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction adjustNextTranche(uint8 varg0, uint8 varg1) public nonPayable { \n    require(_adjustReward == msg.sender);\n    v0 = v1 = 0xff & (0xff & varg0) > 0;\n    if (v1) {\n        v0 = v2 = 0xff & (varg1 & 0xff) > 0;\n    }\n    require(v0);\n    _trancheDenominator = (_trancheDenominator & ~0xff0000000000000000000000000000000000000000 | (0xff & (0xff & varg0)) << 160) & ~0xff000000000000000000000000000000000000000000 | (0xff & (varg1 & 0xff)) << 168;\n}\n\nfunction reserveETH() public nonPayable { \n    return _disburse;\n}\n\nfunction large() public nonPayable { \n    return uint32(_large);\n}\n\nfunction trueBuy(address varg0) public nonPayable { \n    return _trueBuy[varg0];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction trancheNumerator() public nonPayable { \n    return 0xff & _trancheDenominator >> 160 & 0xff;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowed[msg.sender]);\n    _allowed[msg.sender] = _allowed[msg.sender] - varg2;\n    v0 = 0x1ea6(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(1 == 0xff & _developers[msg.sender]);\n    require(_balances[msg.sender] >= varg0);\n    v0 = 0x19f3();\n    require(v0 > 0);\n    v1 = 0x10a7(varg0);\n    v2 = v3 = uint32(v1) * (varg0 * v0) / 100;\n    if (v3 > (address(this)).balance) {\n        v2 = v4 = (address(this)).balance;\n    }\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _outstandingQuarters = _outstandingQuarters - varg0;\n    if (uint32(v1) == uint32(_trancheDenominator >> 208)) {\n        emit MegaEarnings(msg.sender, v2, v0, _tranche, _outstandingQuarters, (address(this)).balance - v2);\n    }\n    emit Withdraw(msg.sender, v2, v0, _tranche, _outstandingQuarters, (address(this)).balance - v2);\n    v5 = 0x19f3();\n    emit BaseRateChanged(v5, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    v6 = msg.sender.call().value(v2).gas(2300 * !v2);\n    require(v6);\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction smallRate() public nonPayable { \n    return uint32(_large >> 160);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balances[msg.sender] >= varg0);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    _outstandingQuarters = _outstandingQuarters - varg0;\n    emit Burn(msg.sender, varg0);\n    v0 = 0x19f3();\n    emit BaseRateChanged(v0, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    return 1;\n}\n\nfunction migrating() public nonPayable { \n    return _migrating;\n}\n\nfunction outstandingQuarters() public nonPayable { \n    return _outstandingQuarters;\n}\n\nfunction q2() public nonPayable { \n    return address(_trancheDenominator);\n}\n\nfunction getRate(uint256 varg0) public nonPayable { \n    v0 = 0x10a7(varg0);\n    return uint32(v0);\n}\n\nfunction setDeveloperStatus(address varg0, bool varg1) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _developers[varg0] = varg1 | ~0xff & _developers[varg0];\n    emit DeveloperStatusChanged(varg0, varg1);\n}\n\nfunction migrationTarget() public nonPayable { \n    return _migrationTarget;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction developers(address varg0) public nonPayable { \n    return 0xff & _developers[varg0];\n}\n\nfunction adjustWithdrawRate(uint32 varg0, uint32 varg1, uint32 varg2, uint32 varg3, uint32 varg4, uint32 varg5, uint32 varg6, uint32 varg7, uint32 varg8) public nonPayable { \n    require(_adjustReward == msg.sender);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (v0) {\n        _trancheDenominator = (_trancheDenominator & ~0xffffffff00000000000000000000000000000000000000000000 | varg0 << 176) & 0xffff00000000ffffffffffffffffffffffffffffffffffffffffffffffffffff | varg1 << 208;\n    }\n    v2 = v3 = varg2 > 0;\n    if (v3) {\n        v2 = varg3 > 0;\n    }\n    if (v2) {\n        _large = (_large & ~0xffffffff | varg2) & ~0xffffffff00000000 | varg3 << 32;\n    }\n    v4 = v5 = varg4 > 0;\n    if (v5) {\n        v4 = varg5 > 0;\n    }\n    if (v4) {\n        _large = (_large & ~0xffffffff0000000000000000 | varg4 << 64) & ~0xffffffff000000000000000000000000 | varg5 << 96;\n    }\n    v6 = v7 = varg6 > 0;\n    if (v7) {\n        v6 = varg7 > 0;\n    }\n    if (v6) {\n        _large = (_large & ~0xffffffff00000000000000000000000000000000 | varg6 << 128) & ~0xffffffff0000000000000000000000000000000000000000 | varg7 << 160;\n    }\n    if (varg8 > 0) {\n        _large = varg8 << 192 | 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff & _large;\n    }\n}\n\nfunction small() public nonPayable { \n    return uint32(_large >> 128);\n}\n\nfunction tranche() public nonPayable { \n    return _tranche;\n}\n\nfunction buyFor(address varg0) public payable { \n    v0 = 0x914(varg0);\n    _allowed[msg.sender] += v0;\n    emit Approval(varg0, msg.sender, v0);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction adjustReward(uint256 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _rewardAmount = varg0;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[varg0] >= varg1);\n    require(varg1 <= _allowed[msg.sender]);\n    _balances[varg0] = _balances[varg0] - varg1;\n    _allowed[msg.sender] = _allowed[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    _outstandingQuarters = _outstandingQuarters - varg1;\n    emit Burn(varg0, varg1);\n    v0 = 0x19f3();\n    emit BaseRateChanged(v0, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    return 1;\n}\n\nfunction setEthRate(uint16 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0 > 0);\n    _ethRate = varg0;\n    emit EthRateChanged(_ethRate, varg0);\n}\n\nfunction rewardDenominator() public nonPayable { \n    return _rewardDenominator;\n}\n\nfunction owner() public nonPayable { \n    return _adjustReward;\n}\n\nfunction migrate() public nonPayable { \n    require(stor_11_0_0);\n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    _totalSupply = _totalSupply - _balances[msg.sender];\n    _outstandingQuarters = _outstandingQuarters - _balances[msg.sender];\n    _rewards[msg.sender] = 0;\n    _rewards[msg.sender] = 0;\n    _rewards[msg.sender] = ~0xff & _rewards[msg.sender];\n    emit Migrate(msg.sender, _balances[msg.sender]);\n    require(_migrationTarget.code.size);\n    v0 = _migrationTarget.migrateFrom(msg.sender, _balances[msg.sender], _rewards[msg.sender], _rewards[msg.sender], _rewards[msg.sender] & 0xff).gas(msg.gas);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction medium() public nonPayable { \n    return uint32(_large >> 64);\n}\n\nfunction microRate() public nonPayable { \n    return uint32(_large >> 192);\n}\n\nfunction buy() public payable { \n    v0 = 0x914(msg.sender);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1ea6(varg1, varg0, msg.sender);\n    return v0;\n}\n\nfunction disburse() public payable { \n    _disburse += msg.value;\n}\n\nfunction megaRate() public nonPayable { \n    return uint32(_trancheDenominator >> 208);\n}\n\nfunction getBaseRate() public nonPayable { \n    v0 = 0x19f3();\n    return v0;\n}\n\nfunction setMigrationTarget(address varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _migrationTarget = varg0;\n}\n\nfunction trancheDenominator() public nonPayable { \n    return 0xff & _trancheDenominator >> 168 & 0xff;\n}\n\nfunction mega() public nonPayable { \n    return uint32(_trancheDenominator >> 176);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (!1) {\n        v1 = v2 = 0;\n    } else {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v0.data + v4];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8);\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction transferAllowance(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x1be6(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction rewardNumerator() public nonPayable { \n    return _rewardNumerator;\n}\n\nfunction ethRate() public nonPayable { \n    return _ethRate;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction adjustTranche(uint256 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0 > 0);\n    _tranche = varg0;\n}\n\nfunction mediumRate() public nonPayable { \n    return uint32(_large >> 96);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0);\n    emit 0x384899bd253d83b23daa4d29aaa2efe0563d1132b43101e9ad667235aeb951b(_adjustReward, varg0);\n    _adjustReward = varg0;\n}\n\nfunction rewardAmount() public nonPayable { \n    return _rewardAmount;\n}\n\nfunction largeRate() public nonPayable { \n    return uint32(_large >> 32);\n}\n\nfunction 0x914(uint256 varg0) private { \n    require(address(varg0));\n    v0 = v1 = msg.value * _ethRate / 0xde0b6b3a7640000;\n    require(v1);\n    if (v1 > _tranche) {\n        v0 = v2 = _tranche;\n    }\n    _totalSupply += v0;\n    v3 = address(varg0);\n    _balances[v3] += v0;\n    _trueBuy[v3] += v0;\n    _outstandingQuarters += v0;\n    0x1e06();\n    emit QuartersOrdered(address(varg0), msg.value, v0);\n    v4 = 0x19f3();\n    emit BaseRateChanged(v4, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    require((address(_trancheDenominator)).code.size);\n    v5 = address(_trancheDenominator).disburse().value(msg.value * 15 / 100).gas(msg.gas);\n    require(v5);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x6fdde03) {\n            name();\n        } else if (0x700037d == v0) {\n            rewards(address);\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0xd3ade73 == v0) {\n            adjustNextTranche(uint8,uint8);\n        } else if (0x100af203 == v0) {\n            reserveETH();\n        } else if (0x12987c98 == v0) {\n            large();\n        } else if (0x17b1d17c == v0) {\n            trueBuy(address);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x1a833d3f == v0) {\n            trancheNumerator();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == v0) {\n            balances(address);\n        } else if (0x2e1a7d4d == v0) {\n            withdraw(uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x42767018 == v0) {\n            smallRate();\n        } else if (0x42966c68 == v0) {\n            burn(uint256);\n        } else if (0x4956cf1c == v0) {\n            migrating();\n        } else if (0x52812053 == v0) {\n            outstandingQuarters();\n        } else if (0x5615f415 == v0) {\n            q2();\n        } else if (0x57764094 == v0) {\n            getRate(uint256);\n        } else if (0x5a19c201 == v0) {\n            setDeveloperStatus(address,bool);\n        } else if (0x5b51acff == v0) {\n            migrationTarget();\n        } else if (0x5c658165 == v0) {\n            allowed(address,address);\n        } else if (0x61fd5c20 == v0) {\n            developers(address);\n        } else if (0x6433ef42 == v0) {\n            adjustWithdrawRate(uint32,uint32,uint32,uint32,uint32,uint32,uint32,uint32,uint32);\n        } else if (0x6cf3c25e == v0) {\n            small();\n        } else if (0x6ebc0af1 == v0) {\n            tranche();\n        } else if (0x6f0b5180 == v0) {\n            buyFor(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x716d3c6c == v0) {\n            adjustReward(uint256);\n        } else if (0x79cc6790 == v0) {\n            burnFrom(address,uint256);\n        } else if (0x84533794 == v0) {\n            setEthRate(uint16);\n        } else if (0x8509a001 == v0) {\n            rewardDenominator();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x8fd3ab80 == v0) {\n            migrate();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x97ccd07b == v0) {\n            medium();\n        } else if (0xa404f291 == v0) {\n            microRate();\n        } else if (0xa6f2ae3a == v0) {\n            buy();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xabc6fd0b == v0) {\n            disburse();\n        } else if (0xb5c47f69 == v0) {\n            megaRate();\n        } else if (0xb655d0c4 == v0) {\n            getBaseRate();\n        } else if (0xc231bace == v0) {\n            setMigrationTarget(address);\n        } else if (0xc50bd2e4 == v0) {\n            trancheDenominator();\n        } else if (0xc5f98a3f == v0) {\n            mega();\n        } else if (0xcae9ca51 == v0) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcbd2ecd2 == v0) {\n            transferAllowance(address,address,uint256);\n        } else if (0xcdd432d0 == v0) {\n            rewardNumerator();\n        } else if (0xd2d93f90 == v0) {\n            ethRate();\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xdf23128f == v0) {\n            adjustTranche(uint256);\n        } else if (0xed1923ee == v0) {\n            mediumRate();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf7b2a7be == v0) {\n            rewardAmount();\n        } else if (0xfd2dba2f == v0) {\n            largeRate();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 11:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _tranche; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _developers; // STORAGE[0x8]\nuint256 _outstandingQuarters; // STORAGE[0x9]\nuint256 _trancheDenominator; // STORAGE[0xa]\nuint256 _large; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rewards; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _trueBuy; // STORAGE[0xd]\nuint256 _rewardAmount; // STORAGE[0xe]\nuint256 _disburse; // STORAGE[0x10]\naddress _adjustReward; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\nuint8 stor_6_1_1; // STORAGE[0x6] bytes 1 to 1\nuint16 _ethRate; // STORAGE[0x6] bytes 1 to 2\nuint8 _rewardNumerator; // STORAGE[0xf] bytes 0 to 0\nuint8 _rewardDenominator; // STORAGE[0xf] bytes 1 to 1\nuint8 stor_11_0_0; // STORAGE[0x11] bytes 0 to 0\naddress _migrationTarget; // STORAGE[0x11] bytes 0 to 19\nuint8 _migrating; // STORAGE[0x11] bytes 20 to 20\n\n// Events\nQuartersOrdered(address, uint256, uint256);\nMegaEarnings(address, uint256, uint256, uint256, uint256, uint256);\nWithdraw(address, uint256, uint256, uint256, uint256, uint256);\nBurn(address, uint256);\nDeveloperStatusChanged(address, bool);\nEthRateChanged(uint16, uint16);\nMigrate(address, uint256);\nTrancheIncreased(uint256, uint256, uint256);\nTransfer(address, address, uint256);\nReward(address, uint256, uint256, uint256);\nBaseRateChanged(uint256, uint256, uint256, uint256, uint256);\nApproval(address, address, uint256);\n\nfunction 0x10a7(uint256 varg0) private { \n    if (varg0 * uint32(_trancheDenominator >> 176) <= _tranche) {\n        if (varg0 * uint32(_large) <= _tranche) {\n            if (varg0 * uint32(_large >> 64) <= _tranche) {\n                if (varg0 * uint32(_large >> 128) <= _tranche) {\n                    return uint32(_large >> 192);\n                } else {\n                    v0 = v1 = uint32(_large >> 160);\n                }\n            } else {\n                v0 = v2 = uint32(_large >> 96);\n            }\n        } else {\n            v0 = v3 = uint32(_large >> 32);\n        }\n    } else {\n        v0 = v4 = uint32(_trancheDenominator >> 208);\n    }\n    return v0;\n}\n\nfunction 0x19f3() private { \n    if (_outstandingQuarters <= 0) {\n        v0 = v1 = (address(this)).balance - _disburse;\n    } else {\n        assert(_outstandingQuarters);\n        v0 = v2 = ((address(this)).balance - _disburse) / _outstandingQuarters;\n    }\n    return v0;\n}\n\nfunction 0x1be6(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2));\n    v0 = address(varg2);\n    v1 = v2 = 0;\n    if (_rewards[v0]) {\n        v3 = address(varg2);\n        if (_rewards[v3] < _tranche) {\n            v4 = address(varg2);\n            assert(_rewardDenominator);\n            v1 = v5 = _rewardNumerator * _trueBuy[v4] / _rewardDenominator;\n        }\n    } else {\n        v1 = v6 = _rewardAmount;\n    }\n    if (v1 > 0) {\n        v7 = address(varg2);\n        _rewards[v7] = _tranche;\n        _rewards[v7] += v1;\n        _allowed[msg.sender] += v1;\n        _totalSupply += v1;\n        _outstandingQuarters += v1;\n        assert(stor_6_1_1);\n        if (_disburse < v1 * 0xde0b6b3a7640000 / _ethRate) {\n            _disburse = 0;\n        } else {\n            _disburse = _disburse - v1 * 0xde0b6b3a7640000 / _ethRate;\n        }\n        0x1e06();\n        emit Approval(address(varg2), msg.sender, v1);\n        emit Reward(address(varg2), v1, _outstandingQuarters, _totalSupply);\n    }\n    v8 = address(varg2);\n    require(varg0 <= _allowed[msg.sender]);\n    v9 = address(varg2);\n    _allowed[msg.sender] = _allowed[msg.sender] - varg0;\n    v10 = 0x1ea6(varg0, varg1, varg2);\n    if (!v10) {\n        return 0;\n    } else {\n        v11 = address(varg1);\n        _allowed[msg.sender] += varg0;\n        emit Approval(v11, msg.sender, varg0);\n        return 1;\n    }\n}\n\nfunction 0x1e06() private { \n    if (_totalSupply >= _tranche) {\n        assert(0xff & _trancheDenominator >> 168);\n        _tranche = (_trancheDenominator >> 160 & 0xff) * _tranche / (0xff & _trancheDenominator >> 168);\n        emit TrancheIncreased(_tranche, (address(this)).balance, _outstandingQuarters);\n    }\n    return ;\n}\n\nfunction 0x1ea6(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balances[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balances[v1] + varg0 > _balances[v1]);\n    v2 = address(varg1);\n    v3 = address(varg2);\n    _balances[v3] = _balances[v3] - varg0;\n    _balances[v2] += varg0;\n    emit Transfer(v3, v2, varg0);\n    v4 = address(varg1);\n    v5 = address(varg2);\n    assert(_balances[v2] + _balances[v3] == _balances[v5] + _balances[v4]);\n    return 1;\n}\n\nfunction fallback() public payable { \n    v0 = 0x914(msg.sender);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction rewards(address varg0) public nonPayable { \n    return _rewards[varg0];\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction adjustNextTranche(uint8 varg0, uint8 varg1) public nonPayable { \n    require(_adjustReward == msg.sender);\n    v0 = v1 = 0xff & (0xff & varg0) > 0;\n    if (v1) {\n        v0 = v2 = 0xff & (varg1 & 0xff) > 0;\n    }\n    require(v0);\n    _trancheDenominator = (_trancheDenominator & ~0xff0000000000000000000000000000000000000000 | (0xff & (0xff & varg0)) << 160) & ~0xff000000000000000000000000000000000000000000 | (0xff & (varg1 & 0xff)) << 168;\n}\n\nfunction reserveETH() public nonPayable { \n    return _disburse;\n}\n\nfunction large() public nonPayable { \n    return uint32(_large);\n}\n\nfunction trueBuy(address varg0) public nonPayable { \n    return _trueBuy[varg0];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction trancheNumerator() public nonPayable { \n    return 0xff & _trancheDenominator >> 160 & 0xff;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowed[msg.sender]);\n    _allowed[msg.sender] = _allowed[msg.sender] - varg2;\n    v0 = 0x1ea6(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(1 == 0xff & _developers[msg.sender]);\n    require(_balances[msg.sender] >= varg0);\n    v0 = 0x19f3();\n    require(v0 > 0);\n    v1 = 0x10a7(varg0);\n    v2 = v3 = uint32(v1) * (varg0 * v0) / 100;\n    if (v3 > (address(this)).balance) {\n        v2 = v4 = (address(this)).balance;\n    }\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _outstandingQuarters = _outstandingQuarters - varg0;\n    if (uint32(v1) == uint32(_trancheDenominator >> 208)) {\n        emit MegaEarnings(msg.sender, v2, v0, _tranche, _outstandingQuarters, (address(this)).balance - v2);\n    }\n    emit Withdraw(msg.sender, v2, v0, _tranche, _outstandingQuarters, (address(this)).balance - v2);\n    v5 = 0x19f3();\n    emit BaseRateChanged(v5, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    v6 = msg.sender.call().value(v2).gas(2300 * !v2);\n    require(v6);\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction smallRate() public nonPayable { \n    return uint32(_large >> 160);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balances[msg.sender] >= varg0);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    _outstandingQuarters = _outstandingQuarters - varg0;\n    emit Burn(msg.sender, varg0);\n    v0 = 0x19f3();\n    emit BaseRateChanged(v0, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    return 1;\n}\n\nfunction migrating() public nonPayable { \n    return _migrating;\n}\n\nfunction outstandingQuarters() public nonPayable { \n    return _outstandingQuarters;\n}\n\nfunction q2() public nonPayable { \n    return address(_trancheDenominator);\n}\n\nfunction getRate(uint256 varg0) public nonPayable { \n    v0 = 0x10a7(varg0);\n    return uint32(v0);\n}\n\nfunction setDeveloperStatus(address varg0, bool varg1) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _developers[varg0] = varg1 | ~0xff & _developers[varg0];\n    emit DeveloperStatusChanged(varg0, varg1);\n}\n\nfunction migrationTarget() public nonPayable { \n    return _migrationTarget;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction developers(address varg0) public nonPayable { \n    return 0xff & _developers[varg0];\n}\n\nfunction adjustWithdrawRate(uint32 varg0, uint32 varg1, uint32 varg2, uint32 varg3, uint32 varg4, uint32 varg5, uint32 varg6, uint32 varg7, uint32 varg8) public nonPayable { \n    require(_adjustReward == msg.sender);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (v0) {\n        _trancheDenominator = (_trancheDenominator & ~0xffffffff00000000000000000000000000000000000000000000 | varg0 << 176) & 0xffff00000000ffffffffffffffffffffffffffffffffffffffffffffffffffff | varg1 << 208;\n    }\n    v2 = v3 = varg2 > 0;\n    if (v3) {\n        v2 = varg3 > 0;\n    }\n    if (v2) {\n        _large = (_large & ~0xffffffff | varg2) & ~0xffffffff00000000 | varg3 << 32;\n    }\n    v4 = v5 = varg4 > 0;\n    if (v5) {\n        v4 = varg5 > 0;\n    }\n    if (v4) {\n        _large = (_large & ~0xffffffff0000000000000000 | varg4 << 64) & ~0xffffffff000000000000000000000000 | varg5 << 96;\n    }\n    v6 = v7 = varg6 > 0;\n    if (v7) {\n        v6 = varg7 > 0;\n    }\n    if (v6) {\n        _large = (_large & ~0xffffffff00000000000000000000000000000000 | varg6 << 128) & ~0xffffffff0000000000000000000000000000000000000000 | varg7 << 160;\n    }\n    if (varg8 > 0) {\n        _large = varg8 << 192 | 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff & _large;\n    }\n}\n\nfunction small() public nonPayable { \n    return uint32(_large >> 128);\n}\n\nfunction tranche() public nonPayable { \n    return _tranche;\n}\n\nfunction buyFor(address varg0) public payable { \n    v0 = 0x914(varg0);\n    _allowed[msg.sender] += v0;\n    emit Approval(varg0, msg.sender, v0);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction adjustReward(uint256 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _rewardAmount = varg0;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[varg0] >= varg1);\n    require(varg1 <= _allowed[msg.sender]);\n    _balances[varg0] = _balances[varg0] - varg1;\n    _allowed[msg.sender] = _allowed[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    _outstandingQuarters = _outstandingQuarters - varg1;\n    emit Burn(varg0, varg1);\n    v0 = 0x19f3();\n    emit BaseRateChanged(v0, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    return 1;\n}\n\nfunction setEthRate(uint16 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0 > 0);\n    _ethRate = varg0;\n    emit EthRateChanged(_ethRate, varg0);\n}\n\nfunction rewardDenominator() public nonPayable { \n    return _rewardDenominator;\n}\n\nfunction owner() public nonPayable { \n    return _adjustReward;\n}\n\nfunction migrate() public nonPayable { \n    require(stor_11_0_0);\n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    _totalSupply = _totalSupply - _balances[msg.sender];\n    _outstandingQuarters = _outstandingQuarters - _balances[msg.sender];\n    _rewards[msg.sender] = 0;\n    _rewards[msg.sender] = 0;\n    _rewards[msg.sender] = ~0xff & _rewards[msg.sender];\n    emit Migrate(msg.sender, _balances[msg.sender]);\n    require(_migrationTarget.code.size);\n    v0 = _migrationTarget.migrateFrom(msg.sender, _balances[msg.sender], _rewards[msg.sender], _rewards[msg.sender], _rewards[msg.sender] & 0xff).gas(msg.gas);\n    require(v0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction medium() public nonPayable { \n    return uint32(_large >> 64);\n}\n\nfunction microRate() public nonPayable { \n    return uint32(_large >> 192);\n}\n\nfunction buy() public payable { \n    v0 = 0x914(msg.sender);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1ea6(varg1, varg0, msg.sender);\n    return v0;\n}\n\nfunction disburse() public payable { \n    _disburse += msg.value;\n}\n\nfunction megaRate() public nonPayable { \n    return uint32(_trancheDenominator >> 208);\n}\n\nfunction getBaseRate() public nonPayable { \n    v0 = 0x19f3();\n    return v0;\n}\n\nfunction setMigrationTarget(address varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    _migrationTarget = varg0;\n}\n\nfunction trancheDenominator() public nonPayable { \n    return 0xff & _trancheDenominator >> 168 & 0xff;\n}\n\nfunction mega() public nonPayable { \n    return uint32(_trancheDenominator >> 176);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (!1) {\n        v1 = v2 = 0;\n    } else {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v0.data + v4];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8);\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction transferAllowance(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x1be6(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction rewardNumerator() public nonPayable { \n    return _rewardNumerator;\n}\n\nfunction ethRate() public nonPayable { \n    return _ethRate;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction adjustTranche(uint256 varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0 > 0);\n    _tranche = varg0;\n}\n\nfunction mediumRate() public nonPayable { \n    return uint32(_large >> 96);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_adjustReward == msg.sender);\n    require(varg0);\n    emit 0x384899bd253d83b23daa4d29aaa2efe0563d1132b43101e9ad667235aeb951b(_adjustReward, varg0);\n    _adjustReward = varg0;\n}\n\nfunction rewardAmount() public nonPayable { \n    return _rewardAmount;\n}\n\nfunction largeRate() public nonPayable { \n    return uint32(_large >> 32);\n}\n\nfunction 0x914(uint256 varg0) private { \n    require(address(varg0));\n    v0 = v1 = msg.value * _ethRate / 0xde0b6b3a7640000;\n    require(v1);\n    if (v1 > _tranche) {\n        v0 = v2 = _tranche;\n    }\n    _totalSupply += v0;\n    v3 = address(varg0);\n    _balances[v3] += v0;\n    _trueBuy[v3] += v0;\n    _outstandingQuarters += v0;\n    0x1e06();\n    emit QuartersOrdered(address(varg0), msg.value, v0);\n    v4 = 0x19f3();\n    emit BaseRateChanged(v4, _tranche, _outstandingQuarters, (address(this)).balance, _totalSupply);\n    require((address(_trancheDenominator)).code.size);\n    v5 = address(_trancheDenominator).disburse().value(msg.value * 15 / 100).gas(msg.gas);\n    require(v5);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x6fdde03) {\n            name();\n        } else if (0x700037d == v0) {\n            rewards(address);\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0xd3ade73 == v0) {\n            adjustNextTranche(uint8,uint8);\n        } else if (0x100af203 == v0) {\n            reserveETH();\n        } else if (0x12987c98 == v0) {\n            large();\n        } else if (0x17b1d17c == v0) {\n            trueBuy(address);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x1a833d3f == v0) {\n            trancheNumerator();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == v0) {\n            balances(address);\n        } else if (0x2e1a7d4d == v0) {\n            withdraw(uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x42767018 == v0) {\n            smallRate();\n        } else if (0x42966c68 == v0) {\n            burn(uint256);\n        } else if (0x4956cf1c == v0) {\n            migrating();\n        } else if (0x52812053 == v0) {\n            outstandingQuarters();\n        } else if (0x5615f415 == v0) {\n            q2();\n        } else if (0x57764094 == v0) {\n            getRate(uint256);\n        } else if (0x5a19c201 == v0) {\n            setDeveloperStatus(address,bool);\n        } else if (0x5b51acff == v0) {\n            migrationTarget();\n        } else if (0x5c658165 == v0) {\n            allowed(address,address);\n        } else if (0x61fd5c20 == v0) {\n            developers(address);\n        } else if (0x6433ef42 == v0) {\n            adjustWithdrawRate(uint32,uint32,uint32,uint32,uint32,uint32,uint32,uint32,uint32);\n        } else if (0x6cf3c25e == v0) {\n            small();\n        } else if (0x6ebc0af1 == v0) {\n            tranche();\n        } else if (0x6f0b5180 == v0) {\n            buyFor(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x716d3c6c == v0) {\n            adjustReward(uint256);\n        } else if (0x79cc6790 == v0) {\n            burnFrom(address,uint256);\n        } else if (0x84533794 == v0) {\n            setEthRate(uint16);\n        } else if (0x8509a001 == v0) {\n            rewardDenominator();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x8fd3ab80 == v0) {\n            migrate();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x97ccd07b == v0) {\n            medium();\n        } else if (0xa404f291 == v0) {\n            microRate();\n        } else if (0xa6f2ae3a == v0) {\n            buy();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xabc6fd0b == v0) {\n            disburse();\n        } else if (0xb5c47f69 == v0) {\n            megaRate();\n        } else if (0xb655d0c4 == v0) {\n            getBaseRate();\n        } else if (0xc231bace == v0) {\n            setMigrationTarget(address);\n        } else if (0xc50bd2e4 == v0) {\n            trancheDenominator();\n        } else if (0xc5f98a3f == v0) {\n            mega();\n        } else if (0xcae9ca51 == v0) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcbd2ecd2 == v0) {\n            transferAllowance(address,address,uint256);\n        } else if (0xcdd432d0 == v0) {\n            rewardNumerator();\n        } else if (0xd2d93f90 == v0) {\n            ethRate();\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xdf23128f == v0) {\n            adjustTranche(uint256);\n        } else if (0xed1923ee == v0) {\n            mediumRate();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf7b2a7be == v0) {\n            rewardAmount();\n        } else if (0xfd2dba2f == v0) {\n            largeRate();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 36.78674340248108,
	"usage": {
		"completion_tokens": 914,
		"prompt_tokens": 6820,
		"total_tokens": 7734
	}
}