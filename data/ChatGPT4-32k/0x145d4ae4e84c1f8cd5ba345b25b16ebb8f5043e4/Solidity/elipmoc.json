{
	"address": "0x145d4ae4e84c1f8cd5ba345b25b16ebb8f5043e4",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity smart contract based on the decompiled code logic:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ncontract MyContract {\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => mapping(address => uint256)) private _allowance;\n    mapping(address => uint256) private _isBot;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(address owner_) {\n        _owner = owner_;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function _SafeSub(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b <= a, \"Subtraction overflow\");\n        return a - b;\n    }\n\n    function _SafeAdd(uint256 a, uint256 b) private pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Addition overflow\");\n        return c;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowance[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n\n        _balanceOf[sender] = _SafeSub(_balanceOf[sender], amount);\n        _balanceOf[recipient] = _SafeAdd(_balanceOf[recipient], amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n\n        _allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // Additional functions for the contract\n    // ...\n}\n```\n\nThis is a simple ERC20 contract with balance and allowance mappings, and functions for transfers and approvals. Note that the original decompiled code seems to suggest additional, custom functionalities (like bot detection), which are not included in this version. The implementation of such features would vary greatly depending on the specific requirements of your project.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495461,
	"id": "chatcmpl-8VP89OOCbFVqylXzVTSMK4gPTbpDu",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.21 07:13 UTC\n// Compiled using the solidity compiler version 0.8.18\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x3b9aca00;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction delBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(0) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x3b9aca00;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x3b9aca00;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x3b9aca00);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(v0 * 0x3b9aca00, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction addBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(1) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3468;\n        v10 = v11 = 100;\n        v12 = v13 = 8967;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x1220. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x2307', '0x232c'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0xff0', '0xd8c'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= stor_6 + 3, Panic(17)); // arithmetic overflow or underflow\n                        if (stor_6 + 3 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4080;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9004;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    v56[v57.length] = 0;\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x1297. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x2307', '0x232c'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        if (0x751039fc > function_selector >> 224) {\n            if (0x313ce567 > function_selector >> 224) {\n                if (0x6fdde03 != function_selector >> 224) {\n                    if (0x95ea7b3 == function_selector >> 224) {\n                        approve(address,uint256);\n                    } else if (0xfaee56f == function_selector >> 224) {\n                        _maxTaxSwap();\n                    } else if (0x18160ddd == function_selector >> 224) {\n                        totalSupply();\n                    } else {\n                        require(0x23b872dd == function_selector >> 224);\n                        transferFrom(address,address,uint256);\n                    }\n                }\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x31c2d847 == function_selector >> 224) {\n                delBots(address[]);\n            } else if (0x3bbac579 == function_selector >> 224) {\n                isBot(address);\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else {\n                require(0x715018a6 == function_selector >> 224);\n                renounceOwnership();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x751039fc == function_selector >> 224) {\n                removeLimits();\n            } else if (0x7d1db4a5 == function_selector >> 224) {\n                _maxTxAmount();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x8f9a55c0 == function_selector >> 224) {\n                _maxWalletSize();\n            } else {\n                require(0x95d89b41 == function_selector >> 224);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xbf474bed == function_selector >> 224) {\n            _taxSwapThreshold();\n        } else if (0xc9567bf9 == function_selector >> 224) {\n            openTrading();\n        } else if (0xd34628cc == function_selector >> 224) {\n            addBots(address[]);\n        } else {\n            require(0xdd62ed3e == function_selector >> 224);\n            allowance(address,address);\n        }\n        symbol();\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.21 07:13 UTC\n// Compiled using the solidity compiler version 0.8.18\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x3b9aca00;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction delBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(0) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x3b9aca00;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x3b9aca00;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x3b9aca00);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(v0 * 0x3b9aca00, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction addBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(1) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3468;\n        v10 = v11 = 100;\n        v12 = v13 = 8967;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x1220. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x2307', '0x232c'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0xff0', '0xd8c'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= stor_6 + 3, Panic(17)); // arithmetic overflow or underflow\n                        if (stor_6 + 3 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4080;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9004;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    v56[v57.length] = 0;\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x1297. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x2307', '0x232c'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        if (0x751039fc > function_selector >> 224) {\n            if (0x313ce567 > function_selector >> 224) {\n                if (0x6fdde03 != function_selector >> 224) {\n                    if (0x95ea7b3 == function_selector >> 224) {\n                        approve(address,uint256);\n                    } else if (0xfaee56f == function_selector >> 224) {\n                        _maxTaxSwap();\n                    } else if (0x18160ddd == function_selector >> 224) {\n                        totalSupply();\n                    } else {\n                        require(0x23b872dd == function_selector >> 224);\n                        transferFrom(address,address,uint256);\n                    }\n                }\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x31c2d847 == function_selector >> 224) {\n                delBots(address[]);\n            } else if (0x3bbac579 == function_selector >> 224) {\n                isBot(address);\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else {\n                require(0x715018a6 == function_selector >> 224);\n                renounceOwnership();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x751039fc == function_selector >> 224) {\n                removeLimits();\n            } else if (0x7d1db4a5 == function_selector >> 224) {\n                _maxTxAmount();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x8f9a55c0 == function_selector >> 224) {\n                _maxWalletSize();\n            } else {\n                require(0x95d89b41 == function_selector >> 224);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xbf474bed == function_selector >> 224) {\n            _taxSwapThreshold();\n        } else if (0xc9567bf9 == function_selector >> 224) {\n            openTrading();\n        } else if (0xd34628cc == function_selector >> 224) {\n            addBots(address[]);\n        } else {\n            require(0xdd62ed3e == function_selector >> 224);\n            allowance(address,address);\n        }\n        symbol();\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.21 07:13 UTC\n// Compiled using the solidity compiler version 0.8.18\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x3b9aca00;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction delBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(0) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x3b9aca00;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x3b9aca00;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x3b9aca00);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x3b9aca00 / 0x3b9aca00) | !0x3b9aca00, Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(v0 * 0x3b9aca00, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction addBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(1) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3468;\n        v10 = v11 = 100;\n        v12 = v13 = 8967;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x1220. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x2307', '0x232c'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0xff0', '0xd8c'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= stor_6 + 3, Panic(17)); // arithmetic overflow or underflow\n                        if (stor_6 + 3 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4080;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9004;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    v56[v57.length] = 0;\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x1297. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x2307', '0x232c'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        if (0x751039fc > function_selector >> 224) {\n            if (0x313ce567 > function_selector >> 224) {\n                if (0x6fdde03 != function_selector >> 224) {\n                    if (0x95ea7b3 == function_selector >> 224) {\n                        approve(address,uint256);\n                    } else if (0xfaee56f == function_selector >> 224) {\n                        _maxTaxSwap();\n                    } else if (0x18160ddd == function_selector >> 224) {\n                        totalSupply();\n                    } else {\n                        require(0x23b872dd == function_selector >> 224);\n                        transferFrom(address,address,uint256);\n                    }\n                }\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x31c2d847 == function_selector >> 224) {\n                delBots(address[]);\n            } else if (0x3bbac579 == function_selector >> 224) {\n                isBot(address);\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else {\n                require(0x715018a6 == function_selector >> 224);\n                renounceOwnership();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x751039fc == function_selector >> 224) {\n                removeLimits();\n            } else if (0x7d1db4a5 == function_selector >> 224) {\n                _maxTxAmount();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x8f9a55c0 == function_selector >> 224) {\n                _maxWalletSize();\n            } else {\n                require(0x95d89b41 == function_selector >> 224);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xbf474bed == function_selector >> 224) {\n            _taxSwapThreshold();\n        } else if (0xc9567bf9 == function_selector >> 224) {\n            openTrading();\n        } else if (0xd34628cc == function_selector >> 224) {\n            addBots(address[]);\n        } else {\n            require(0xdd62ed3e == function_selector >> 224);\n            allowance(address,address);\n        }\n        symbol();\n    }\n}\n.",
	"status": "1",
	"time_cost": 39.29848504066467,
	"usage": {
		"completion_tokens": 690,
		"prompt_tokens": 6373,
		"total_tokens": 7063
	}
}