{
	"address": "0xfd4e7b9f4f97330356f7d1b5ddb9843f2c3e9d87",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Contract {\n    uint256[] private _name;\n    uint256[] private _symbol;\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => uint256) private _dividendBalanceOf;\n    uint256 private _dividendPerToken;\n    mapping (address => uint256) private _dividendCreditedTo;\n    mapping (address => mapping(address => uint256)) private _allowance;\n    uint8 private _decimals;\n    bool private _fallback;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[from]);\n        require(value <= _allowance[msg.sender][from]);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[msg.sender][from] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function withdraw() public {\n        uint256 amount = _dividendBalanceOf[msg.sender];\n        require(amount > 0);\n        _dividendBalanceOf[msg.sender] = 0;\n        msg.sender.transfer(amount);\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function dividendPerToken() public view returns (uint256) {\n        return _dividendPerToken;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function dividendBalanceOf(address owner) public view returns (uint256) {\n        return _dividendBalanceOf[owner];\n    }\n\n    function dividendCreditedTo(address owner) public view returns (uint256) {\n        return _dividendCreditedTo[owner];\n    }\n\n    function() external payable {\n        require(_fallback);\n        _dividendPerToken = _dividendPerToken + msg.value / _totalSupply;\n    }\n}\n```\n\nPlease note that the `name` and `symbol` functions are not included in this contract because the decompiled code suggests that they return byte arrays, which are not typical for these functions in ERC20 tokens. Normally, these functions return strings. Additionally, the original code does not provide a clear way to initialize the `_name` and `_symbol` byte arrays.\n\nThe `__function_selector__` function is also not included because function selectors are handled automatically in Solidity. \n\nThis contract is a basic implementation of a dividend-paying ERC20 token where the dividend per token is calculated whenever ether is sent to the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459748,
	"id": "chatcmpl-8R3h6GxZek62C1E2XNodgU4nEwGfI",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 22:54 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _dividendBalanceOf; // STORAGE[0x5]\nuint256 _dividendPerToken; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _dividendCreditedTo; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[varg0] * (_dividendPerToken - _dividendCreditedTo[varg0]);\n    _balanceOf[varg0] = _dividendPerToken;\n    _balanceOf[varg1] = _balanceOf[varg1] + _balanceOf[varg1] * (_dividendPerToken - _dividendCreditedTo[varg1]);\n    _balanceOf[varg1] = _dividendPerToken;\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _balanceOf[msg.sender] * (_dividendPerToken - _dividendCreditedTo[msg.sender]);\n    _balanceOf[msg.sender] = _dividendPerToken;\n    _dividendBalanceOf[msg.sender] = 0;\n    v0 = msg.sender.call().value(_dividendBalanceOf[msg.sender]).gas(!_dividendBalanceOf[msg.sender] * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction dividendPerToken() public nonPayable { \n    return _dividendPerToken;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _balanceOf[msg.sender] * (_dividendPerToken - _dividendCreditedTo[msg.sender]);\n    _balanceOf[msg.sender] = _dividendPerToken;\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[varg0] * (_dividendPerToken - _dividendCreditedTo[varg0]);\n    _balanceOf[varg0] = _dividendPerToken;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction dividendBalanceOf(address varg0) public nonPayable { \n    return _dividendBalanceOf[varg0];\n}\n\nfunction dividendCreditedTo(address varg0) public nonPayable { \n    return _dividendCreditedTo[varg0];\n}\n\nfunction fallback() public payable { \n    assert(_fallback);\n    _dividendPerToken = _dividendPerToken + msg.value / _totalSupply;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x77ec0feb == function_selector) {\n            dividendPerToken();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe083d4c8 == function_selector) {\n            dividendBalanceOf(address);\n        } else if (0xe47224a1 == function_selector) {\n            dividendCreditedTo(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 22:54 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _dividendBalanceOf; // STORAGE[0x5]\nuint256 _dividendPerToken; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _dividendCreditedTo; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[varg0] * (_dividendPerToken - _dividendCreditedTo[varg0]);\n    _balanceOf[varg0] = _dividendPerToken;\n    _balanceOf[varg1] = _balanceOf[varg1] + _balanceOf[varg1] * (_dividendPerToken - _dividendCreditedTo[varg1]);\n    _balanceOf[varg1] = _dividendPerToken;\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _balanceOf[msg.sender] * (_dividendPerToken - _dividendCreditedTo[msg.sender]);\n    _balanceOf[msg.sender] = _dividendPerToken;\n    _dividendBalanceOf[msg.sender] = 0;\n    v0 = msg.sender.call().value(_dividendBalanceOf[msg.sender]).gas(!_dividendBalanceOf[msg.sender] * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction dividendPerToken() public nonPayable { \n    return _dividendPerToken;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _balanceOf[msg.sender] * (_dividendPerToken - _dividendCreditedTo[msg.sender]);\n    _balanceOf[msg.sender] = _dividendPerToken;\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[varg0] * (_dividendPerToken - _dividendCreditedTo[varg0]);\n    _balanceOf[varg0] = _dividendPerToken;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction dividendBalanceOf(address varg0) public nonPayable { \n    return _dividendBalanceOf[varg0];\n}\n\nfunction dividendCreditedTo(address varg0) public nonPayable { \n    return _dividendCreditedTo[varg0];\n}\n\nfunction fallback() public payable { \n    assert(_fallback);\n    _dividendPerToken = _dividendPerToken + msg.value / _totalSupply;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x77ec0feb == function_selector) {\n            dividendPerToken();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe083d4c8 == function_selector) {\n            dividendBalanceOf(address);\n        } else if (0xe47224a1 == function_selector) {\n            dividendCreditedTo(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 22:54 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _dividendBalanceOf; // STORAGE[0x5]\nuint256 _dividendPerToken; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _dividendCreditedTo; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[varg0] * (_dividendPerToken - _dividendCreditedTo[varg0]);\n    _balanceOf[varg0] = _dividendPerToken;\n    _balanceOf[varg1] = _balanceOf[varg1] + _balanceOf[varg1] * (_dividendPerToken - _dividendCreditedTo[varg1]);\n    _balanceOf[varg1] = _dividendPerToken;\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _balanceOf[msg.sender] * (_dividendPerToken - _dividendCreditedTo[msg.sender]);\n    _balanceOf[msg.sender] = _dividendPerToken;\n    _dividendBalanceOf[msg.sender] = 0;\n    v0 = msg.sender.call().value(_dividendBalanceOf[msg.sender]).gas(!_dividendBalanceOf[msg.sender] * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction dividendPerToken() public nonPayable { \n    return _dividendPerToken;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + _balanceOf[msg.sender] * (_dividendPerToken - _dividendCreditedTo[msg.sender]);\n    _balanceOf[msg.sender] = _dividendPerToken;\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[varg0] * (_dividendPerToken - _dividendCreditedTo[varg0]);\n    _balanceOf[varg0] = _dividendPerToken;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction dividendBalanceOf(address varg0) public nonPayable { \n    return _dividendBalanceOf[varg0];\n}\n\nfunction dividendCreditedTo(address varg0) public nonPayable { \n    return _dividendCreditedTo[varg0];\n}\n\nfunction fallback() public payable { \n    assert(_fallback);\n    _dividendPerToken = _dividendPerToken + msg.value / _totalSupply;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x77ec0feb == function_selector) {\n            dividendPerToken();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe083d4c8 == function_selector) {\n            dividendBalanceOf(address);\n        } else if (0xe47224a1 == function_selector) {\n            dividendCreditedTo(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 27.718048095703125,
	"usage": {
		"completion_tokens": 740,
		"prompt_tokens": 1971,
		"total_tokens": 2711
	}
}