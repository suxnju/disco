{
	"address": "0x8d6b6f21e4519ec10f54842cd9c113ee7e50e04a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The original Solidity code for the given decompiled code can't be derived as EVM bytecode to Solidity code conversion is not straightforward due to various reasons such as loss of variable names, comments, original formatting and most importantly the loss of high level abstractions. \n\nHowever, I can provide an example of similar solidity code, but the derived code won't match exactly with the original code.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract VoucherContract {\n    mapping (uint256 => uint256) private _fallback;\n    uint256 private _voucherMthRate;\n    uint256 private _mthEthRate;\n    uint256 private stor_5;\n    mapping (uint256 => uint256) private _purchased;\n    uint256 private _totalPurchased;\n    mapping (uint256 => uint256) private _totalDistributedIn;\n    mapping (uint256 => uint256) private _distributed;\n    address private _owner;\n    uint8 private _paused;\n    address private _mthToken;\n\n    event MthEthRateUpdated(uint256 oldValue, uint256 newValue);\n    event ReclaimTokens(address indexed owner, uint256 amount);\n    event ReclaimEther(address indexed owner, uint256 amount);\n    event Unpause();\n    event VouchersSold(address indexed seller, uint256 amount, uint256 value);\n    event DiscountApplied(address indexed buyer, uint256 amount, uint256 value);\n    event PaybackApplied(address indexed buyer, uint256 amount, uint256 value);\n    event OwnershipRenounced(address indexed owner);\n    event Pause();\n    event VouchersBought(address indexed buyer, uint256 amount);\n    event PurchasedVouchersReleased(address indexed buyer, address indexed seller, uint256 amount);\n    event VoucherMthRateUpdated(uint256 oldValue, uint256 newValue);\n    event MonethaAddressSet(address indexed addr, bool status);\n    event VoucherReleased(address indexed buyer, uint256 amount);\n    event VouchersAdded(address indexed sender, uint256 amount);\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    constructor(address owner, address mthToken) public {\n        _owner = owner;\n        _mthToken = mthToken;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner, \"Only owner can transfer ownership\");\n        _owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    function pause() public {\n        require(msg.sender == _owner, \"Only owner can pause\");\n        _paused = 1;\n        emit Pause();\n    }\n\n    function unpause() public {\n        require(msg.sender == _owner, \"Only owner can unpause\");\n        _paused = 0;\n        emit Unpause();\n    }\n\n    // Other functions similar to the ones mentioned in the bytecode go here\n}\n```\nPlease note that this is a basic template for a contract that involves token operations like buying, selling and transferring ownership. The actual contract derived from the bytecode could have additional logic and different variable names.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456937,
	"id": "chatcmpl-8R2xltm4jF53IInr6fGXFqGepdP2n",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 20:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x1]\nuint256 _voucherMthRate; // STORAGE[0x3]\nuint256 _mthEthRate; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _purchased; // STORAGE[0x7]\nuint256 _totalPurchased; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _totalDistributedIn; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _distributed; // STORAGE[0xa]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x2] bytes 0 to 0\naddress _mthToken; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nMthEthRateUpdated(uint256, uint256);\nReclaimTokens(address, uint256);\nReclaimEther(address, uint256);\nUnpause();\nVouchersSold(address, uint256, uint256);\nDiscountApplied(address, uint256, uint256);\nPaybackApplied(address, uint256, uint256);\nOwnershipRenounced(address);\nPause();\nVouchersBought(address, uint256);\nPurchasedVouchersReleased(address, address, uint256);\nVoucherMthRateUpdated(uint256, uint256);\nMonethaAddressSet(address, bool);\nVoucherReleased(address, uint256);\nVouchersAdded(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1688(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = address(varg1);\n    require(v0.code.size);\n    v2, v3 = v0.transfer(v1, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    return ;\n}\n\nfunction 0x1740() private { \n    require(_mthToken.code.size);\n    v0, v1 = _mthToken.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = 0x1d24(_voucherMthRate, v1);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0x17dd(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    assert(varg0 <= _purchased[v0]);\n    v1 = address(varg1);\n    _purchased[v1] = _purchased[v0] - varg0;\n    assert(varg0 <= _totalPurchased);\n    _totalPurchased = _totalPurchased - varg0;\n    return ;\n}\n\nfunction 0x1839(uint256 varg0) private { \n    v0 = 0x1d24(0xc097ce7bc90715b34b9f1000000000, varg0);\n    assert(stor_5);\n    return v0 / stor_5;\n}\n\nfunction 0x1977(uint256 varg0) private { \n    v0 = 0x1d24(stor_5, varg0);\n    assert(0xc097ce7bc90715b34b9f1000000000);\n    return v0 / 0xc097ce7bc90715b34b9f1000000000;\n}\n\nfunction 0x199c(uint256 varg0) private { \n    require(address(v0), 'zero address is not allowed');\n    v1, v2 = 0x1be4();\n    require(v1 >= v2, 'must be less or equal than vouchers present in shared pool');\n    assert(block.timestamp / 0xf0c3f0 + _totalDistributedIn[0] >= _totalDistributedIn[0]);\n    _totalDistributedIn[0] += block.timestamp / 0xf0c3f0;\n    assert(block.timestamp / 0xf0c3f0 + _distributed[0] >= _distributed[0]);\n    _distributed[0] += block.timestamp / 0xf0c3f0;\n    emit VouchersAdded(0, block.timestamp / 0xf0c3f0);\n    return 1, v0;\n}\n\nfunction 0x1be4() private { \n    v0 = v1 = 0;\n    v2 = v3 = 3229;\n    v0 = v4 = _totalPurchased;\n    v2 = v5 = 7168;\n    v0 = v6 = 0x1c61(v2);\n    v7 = v8 = 0x1740();\n    while (1) {\n        assert(v0 <= v7);\n        v7 = v7 - v0;\n        goto {'0x1c00', '0xc9d0x1be4'};\n        return v7, v2;\n    }\n}\n\nfunction 0x1c61(uint256 varg0) private { \n    v0 = uint16(varg0);\n    if (0 >= v0) {\n        return _totalDistributedIn[v0];\n    } else {\n        v1 = uint16(varg0 + ~0);\n        assert(_totalDistributedIn[v1] + _totalDistributedIn[v0] >= _totalDistributedIn[v0]);\n        return _totalDistributedIn[v1] + _totalDistributedIn[v0];\n    }\n}\n\nfunction 0x1d24(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x1d97(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1) {\n        v0 = uint16(varg0);\n        v1 = address(varg2);\n        varg1 = v2 = _distributed[v1];\n        if (v2 > varg1) {\n            assert(varg1 <= v2);\n            v3 = uint16(varg0);\n            v4 = address(varg2);\n            _distributed[v4] = v2 - varg1;\n        } else {\n            v5 = uint16(varg0);\n            v6 = address(varg2);\n            _distributed[v6] = 0;\n        }\n        v7 = uint16(varg0);\n        if (_totalDistributedIn[v7] != varg1) {\n            assert(varg1 <= _totalDistributedIn[v7]);\n            v8 = uint16(varg0);\n            _totalDistributedIn[v8] = _totalDistributedIn[v7] - varg1;\n        } else {\n            v9 = uint16(varg0);\n            _totalDistributedIn[v9] = 0;\n        }\n    } else {\n        varg1 = v10 = 0;\n    }\n    return varg1;\n}\n\nfunction fallback() public payable { \n    require(0xff & _fallback[msg.sender]);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'Monetha Voucher';\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    revert();\n}\n\nfunction updateMthEthRate(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 > 0, 'should be greater than 0');\n    require(varg0 != _mthEthRate, 'same as previous value');\n    _mthEthRate = varg0;\n    v0 = 0x1d24(_mthEthRate, _voucherMthRate);\n    stor_5 = v0;\n    emit MthEthRateUpdated(_mthEthRate, varg0);\n}\n\nfunction reclaimToken(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    0x1688(v1, _owner, varg0);\n    emit ReclaimTokens(_owner, v1);\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = 0x1740();\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    revert();\n}\n\nfunction reclaimEtherTo(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0, 'zero address is not allowed');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    emit ReclaimEther(varg0, varg1);\n}\n\nfunction decimals() public nonPayable { \n    return 5;\n}\n\nfunction isMonethaAddress(address varg0) public nonPayable { \n    return 0xff & _fallback[varg0];\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction mthEthRate() public nonPayable { \n    return _mthEthRate;\n}\n\nfunction purchased(address varg0) public nonPayable { \n    return _purchased[varg0];\n}\n\nfunction standard() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & 'ERC20';\n    }\n    return v0;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction sellVouchers(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 <= _purchased[msg.sender], 'Insufficient vouchers');\n    0x17dd(varg0, msg.sender);\n    v0 = 0x1839(varg0);\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1); // checks call status, propagates error data on error\n    emit VouchersSold(msg.sender, varg0, v0);\n    return v0;\n}\n\nfunction toWei(uint256 varg0) public nonPayable { \n    v0 = 0x1839(varg0);\n    return v0;\n}\n\nfunction applyDiscount(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0, 'zero address is not allowed');\n    require(varg0, 'must be valid address');\n    v0 = v1 = 0;\n    if (uint16(block.timestamp / 0xf0c3f0) > 0) {\n        v2 = v3 = 6411;\n        v4 = v5 = 0x1d97(block.timestamp / 0xf0c3f0 - 1, varg1, varg0);\n    }\n    v0 += v4;\n    assert(v0 >= v0);\n    goto {'0x190bB0x490', '0x192eB0x490'};\n    assert(v0 <= v6);\n    v6 = v6 - v0;\n    emit VoucherReleased(varg0, v0);\n    if (v0) {\n        v0 = v7 = 0x1839(v0);\n        require(v7 <= this.balance, 'insufficient funds');\n        v8 = varg0.call().value(v7).gas(2300 * !v7);\n        require(v8); // checks call status, propagates error data on error\n        emit DiscountApplied(varg0, v0, v7);\n    } else {\n        v0 = v9 = 0;\n    }\n    return v0, v0;\n    v2 = v10 = 6446;\n    v4 = 0x1d97(block.timestamp / 0xf0c3f0, v6, varg0);\n}\n\nfunction applyPayback(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    v0 = 0x1977(varg1);\n    v1, v2 = 0x199c(v0);\n    require(v1, 'vouchers must be added');\n    emit PaybackApplied(address(v0), v2, 3669);\n    return v2;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    v0 = v1 = _distributed[varg0];\n    if (0 < uint16(block.timestamp / 0xf0c3f0)) {\n        v0 = _distributed[varg0] + v1;\n        assert(v0 >= v1);\n    }\n    assert(_purchased[varg0] + v0 >= v0);\n    return _purchased[varg0] + v0;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction totalDistributedIn(uint16 varg0) public nonPayable { \n    return _totalDistributedIn[varg0];\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction purchasedBy(address varg0) public nonPayable { \n    return _purchased[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction mthToken() public nonPayable { \n    return _mthToken;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4d54485600000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction reclaimEther() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(this.balance).gas(!this.balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit ReclaimEther(_owner, this.balance);\n}\n\nfunction reclaimTokenTo(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1, 'zero address is not allowed');\n    0x1688(varg2, varg1, varg0);\n    emit ReclaimTokens(varg1, varg2);\n}\n\nfunction RATE_COEFFICIENT() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction buyVouchers(uint256 varg0) public payable { \n    require(0xff & _fallback[msg.sender]);\n    v0, v1 = 0x1be4();\n    require(v0 >= v1, 'insufficient vouchers present');\n    v2 = 0x1839(varg0);\n    require(msg.value == v2, 'insufficient funds');\n    assert(varg0 + _purchased[msg.sender] >= _purchased[msg.sender]);\n    _purchased[msg.sender] += varg0;\n    assert(varg0 + _totalPurchased >= _totalPurchased);\n    _totalPurchased += varg0;\n    emit VouchersBought(msg.sender, varg0);\n}\n\nfunction releasePurchasedTo(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg1 <= _purchased[msg.sender], 'Insufficient Vouchers');\n    require(varg0, 'address should be valid');\n    0x17dd(varg1, msg.sender);\n    v0, v1 = 0x199c(varg1);\n    emit PurchasedVouchersReleased(msg.sender, 0, 5129);\n    return 1;\n}\n\nfunction voucherMthRate() public nonPayable { \n    return _voucherMthRate;\n}\n\nfunction updateVoucherMthRate(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 > 0, 'should be greater than 0');\n    require(varg0 != _voucherMthRate, 'same as previous value');\n    _voucherMthRate = varg0;\n    v0 = 0x1d24(_mthEthRate, _voucherMthRate);\n    stor_5 = v0;\n    emit VoucherMthRateUpdated(_voucherMthRate, varg0);\n}\n\nfunction setMonethaAddress(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _fallback[varg0] = varg1 | ~0xff & _fallback[varg0];\n    emit MonethaAddressSet(varg0, varg1);\n}\n\nfunction totalInSharedPool() public nonPayable { \n    v0, v1 = 0x1be4();\n    return v0;\n}\n\nfunction distributed(uint16 varg0, address varg1) public nonPayable { \n    return _distributed[varg1];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return 0;\n}\n\nfunction totalPurchased() public nonPayable { \n    return _totalPurchased;\n}\n\nfunction fromWei(uint256 varg0) public nonPayable { \n    v0 = 0x1977(varg0);\n    return v0;\n}\n\nfunction totalDistributed() public nonPayable { \n    v0 = 0x1c61(block.timestamp / 0xf0c3f0);\n    return v0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else {\n            if (0x95ea7b3 != function_selector) {\n                if (0xce11ded == function_selector) {\n                    updateMthEthRate(uint256);\n                } else if (0x17ffc320 == function_selector) {\n                    reclaimToken(address);\n                } else if (0x18160ddd == function_selector) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                } else if (0x2e84a374 == function_selector) {\n                    reclaimEtherTo(address,uint256);\n                } else if (0x313ce567 == function_selector) {\n                    decimals();\n                } else if (0x31d41325 == function_selector) {\n                    isMonethaAddress(address);\n                } else if (0x3f4ba83a == function_selector) {\n                    unpause();\n                } else if (0x49ff7a62 == function_selector) {\n                    mthEthRate();\n                } else if (0x522fe98e == function_selector) {\n                    purchased(address);\n                } else if (0x5a3b7e42 == function_selector) {\n                    standard();\n                } else if (0x5c975abb == function_selector) {\n                    paused();\n                } else if (0x6481f081 == function_selector) {\n                    sellVouchers(uint256);\n                } else if (0x669dafe8 == function_selector) {\n                    toWei(uint256);\n                } else if (0x6a2b171a == function_selector) {\n                    applyDiscount(address,uint256);\n                } else if (0x6daa212f == function_selector) {\n                    applyPayback(address,uint256);\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x715018a6 == function_selector) {\n                    renounceOwnership();\n                } else if (0x732a935c == function_selector) {\n                    totalDistributedIn(uint16);\n                } else if (0x8456cb59 == function_selector) {\n                    pause();\n                } else if (0x8d8c36e9 == function_selector) {\n                    purchasedBy(address);\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0x93306c43 == function_selector) {\n                    mthToken();\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0x9f727c27 == function_selector) {\n                    reclaimEther();\n                } else if (0x9fe98bda == function_selector) {\n                    reclaimTokenTo(address,address,uint256);\n                } else if (0xa05e0f65 == function_selector) {\n                    RATE_COEFFICIENT();\n                } else if (0xa9059cbb != function_selector) {\n                    if (0xb0408721 == function_selector) {\n                        buyVouchers(uint256);\n                    } else if (0xb2bea9c1 == function_selector) {\n                        releasePurchasedTo(address,uint256);\n                    } else if (0xb6f81724 == function_selector) {\n                        voucherMthRate();\n                    } else if (0xb9c5eb90 == function_selector) {\n                        updateVoucherMthRate(uint256);\n                    } else if (0xc07e3391 == function_selector) {\n                        setMonethaAddress(address,bool);\n                    } else if (0xc3fdbef8 == function_selector) {\n                        totalInSharedPool();\n                    } else if (0xd9582cde == function_selector) {\n                        distributed(uint16,address);\n                    } else if (0xdd62ed3e == function_selector) {\n                        allowance(address,address);\n                    } else if (0xe632c2f3 == function_selector) {\n                        totalPurchased();\n                    } else if (0xe65d1522 == function_selector) {\n                        fromWei(uint256);\n                    } else if (0xefca2eed == function_selector) {\n                        totalDistributed();\n                    } else if (0xf2fde38b == function_selector) {\n                        transferOwnership(address);\n                    }\n                }\n            }\n            transfer(address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 20:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x1]\nuint256 _voucherMthRate; // STORAGE[0x3]\nuint256 _mthEthRate; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _purchased; // STORAGE[0x7]\nuint256 _totalPurchased; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _totalDistributedIn; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _distributed; // STORAGE[0xa]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x2] bytes 0 to 0\naddress _mthToken; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nMthEthRateUpdated(uint256, uint256);\nReclaimTokens(address, uint256);\nReclaimEther(address, uint256);\nUnpause();\nVouchersSold(address, uint256, uint256);\nDiscountApplied(address, uint256, uint256);\nPaybackApplied(address, uint256, uint256);\nOwnershipRenounced(address);\nPause();\nVouchersBought(address, uint256);\nPurchasedVouchersReleased(address, address, uint256);\nVoucherMthRateUpdated(uint256, uint256);\nMonethaAddressSet(address, bool);\nVoucherReleased(address, uint256);\nVouchersAdded(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1688(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = address(varg1);\n    require(v0.code.size);\n    v2, v3 = v0.transfer(v1, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    return ;\n}\n\nfunction 0x1740() private { \n    require(_mthToken.code.size);\n    v0, v1 = _mthToken.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = 0x1d24(_voucherMthRate, v1);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0x17dd(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    assert(varg0 <= _purchased[v0]);\n    v1 = address(varg1);\n    _purchased[v1] = _purchased[v0] - varg0;\n    assert(varg0 <= _totalPurchased);\n    _totalPurchased = _totalPurchased - varg0;\n    return ;\n}\n\nfunction 0x1839(uint256 varg0) private { \n    v0 = 0x1d24(0xc097ce7bc90715b34b9f1000000000, varg0);\n    assert(stor_5);\n    return v0 / stor_5;\n}\n\nfunction 0x1977(uint256 varg0) private { \n    v0 = 0x1d24(stor_5, varg0);\n    assert(0xc097ce7bc90715b34b9f1000000000);\n    return v0 / 0xc097ce7bc90715b34b9f1000000000;\n}\n\nfunction 0x199c(uint256 varg0) private { \n    require(address(v0), 'zero address is not allowed');\n    v1, v2 = 0x1be4();\n    require(v1 >= v2, 'must be less or equal than vouchers present in shared pool');\n    assert(block.timestamp / 0xf0c3f0 + _totalDistributedIn[0] >= _totalDistributedIn[0]);\n    _totalDistributedIn[0] += block.timestamp / 0xf0c3f0;\n    assert(block.timestamp / 0xf0c3f0 + _distributed[0] >= _distributed[0]);\n    _distributed[0] += block.timestamp / 0xf0c3f0;\n    emit VouchersAdded(0, block.timestamp / 0xf0c3f0);\n    return 1, v0;\n}\n\nfunction 0x1be4() private { \n    v0 = v1 = 0;\n    v2 = v3 = 3229;\n    v0 = v4 = _totalPurchased;\n    v2 = v5 = 7168;\n    v0 = v6 = 0x1c61(v2);\n    v7 = v8 = 0x1740();\n    while (1) {\n        assert(v0 <= v7);\n        v7 = v7 - v0;\n        goto {'0x1c00', '0xc9d0x1be4'};\n        return v7, v2;\n    }\n}\n\nfunction 0x1c61(uint256 varg0) private { \n    v0 = uint16(varg0);\n    if (0 >= v0) {\n        return _totalDistributedIn[v0];\n    } else {\n        v1 = uint16(varg0 + ~0);\n        assert(_totalDistributedIn[v1] + _totalDistributedIn[v0] >= _totalDistributedIn[v0]);\n        return _totalDistributedIn[v1] + _totalDistributedIn[v0];\n    }\n}\n\nfunction 0x1d24(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x1d97(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1) {\n        v0 = uint16(varg0);\n        v1 = address(varg2);\n        varg1 = v2 = _distributed[v1];\n        if (v2 > varg1) {\n            assert(varg1 <= v2);\n            v3 = uint16(varg0);\n            v4 = address(varg2);\n            _distributed[v4] = v2 - varg1;\n        } else {\n            v5 = uint16(varg0);\n            v6 = address(varg2);\n            _distributed[v6] = 0;\n        }\n        v7 = uint16(varg0);\n        if (_totalDistributedIn[v7] != varg1) {\n            assert(varg1 <= _totalDistributedIn[v7]);\n            v8 = uint16(varg0);\n            _totalDistributedIn[v8] = _totalDistributedIn[v7] - varg1;\n        } else {\n            v9 = uint16(varg0);\n            _totalDistributedIn[v9] = 0;\n        }\n    } else {\n        varg1 = v10 = 0;\n    }\n    return varg1;\n}\n\nfunction fallback() public payable { \n    require(0xff & _fallback[msg.sender]);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'Monetha Voucher';\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    revert();\n}\n\nfunction updateMthEthRate(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 > 0, 'should be greater than 0');\n    require(varg0 != _mthEthRate, 'same as previous value');\n    _mthEthRate = varg0;\n    v0 = 0x1d24(_mthEthRate, _voucherMthRate);\n    stor_5 = v0;\n    emit MthEthRateUpdated(_mthEthRate, varg0);\n}\n\nfunction reclaimToken(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    0x1688(v1, _owner, varg0);\n    emit ReclaimTokens(_owner, v1);\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = 0x1740();\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    revert();\n}\n\nfunction reclaimEtherTo(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0, 'zero address is not allowed');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    emit ReclaimEther(varg0, varg1);\n}\n\nfunction decimals() public nonPayable { \n    return 5;\n}\n\nfunction isMonethaAddress(address varg0) public nonPayable { \n    return 0xff & _fallback[varg0];\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction mthEthRate() public nonPayable { \n    return _mthEthRate;\n}\n\nfunction purchased(address varg0) public nonPayable { \n    return _purchased[varg0];\n}\n\nfunction standard() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & 'ERC20';\n    }\n    return v0;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction sellVouchers(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 <= _purchased[msg.sender], 'Insufficient vouchers');\n    0x17dd(varg0, msg.sender);\n    v0 = 0x1839(varg0);\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1); // checks call status, propagates error data on error\n    emit VouchersSold(msg.sender, varg0, v0);\n    return v0;\n}\n\nfunction toWei(uint256 varg0) public nonPayable { \n    v0 = 0x1839(varg0);\n    return v0;\n}\n\nfunction applyDiscount(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0, 'zero address is not allowed');\n    require(varg0, 'must be valid address');\n    v0 = v1 = 0;\n    if (uint16(block.timestamp / 0xf0c3f0) > 0) {\n        v2 = v3 = 6411;\n        v4 = v5 = 0x1d97(block.timestamp / 0xf0c3f0 - 1, varg1, varg0);\n    }\n    v0 += v4;\n    assert(v0 >= v0);\n    goto {'0x190bB0x490', '0x192eB0x490'};\n    assert(v0 <= v6);\n    v6 = v6 - v0;\n    emit VoucherReleased(varg0, v0);\n    if (v0) {\n        v0 = v7 = 0x1839(v0);\n        require(v7 <= this.balance, 'insufficient funds');\n        v8 = varg0.call().value(v7).gas(2300 * !v7);\n        require(v8); // checks call status, propagates error data on error\n        emit DiscountApplied(varg0, v0, v7);\n    } else {\n        v0 = v9 = 0;\n    }\n    return v0, v0;\n    v2 = v10 = 6446;\n    v4 = 0x1d97(block.timestamp / 0xf0c3f0, v6, varg0);\n}\n\nfunction applyPayback(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    v0 = 0x1977(varg1);\n    v1, v2 = 0x199c(v0);\n    require(v1, 'vouchers must be added');\n    emit PaybackApplied(address(v0), v2, 3669);\n    return v2;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    v0 = v1 = _distributed[varg0];\n    if (0 < uint16(block.timestamp / 0xf0c3f0)) {\n        v0 = _distributed[varg0] + v1;\n        assert(v0 >= v1);\n    }\n    assert(_purchased[varg0] + v0 >= v0);\n    return _purchased[varg0] + v0;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction totalDistributedIn(uint16 varg0) public nonPayable { \n    return _totalDistributedIn[varg0];\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction purchasedBy(address varg0) public nonPayable { \n    return _purchased[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction mthToken() public nonPayable { \n    return _mthToken;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4d54485600000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction reclaimEther() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(this.balance).gas(!this.balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit ReclaimEther(_owner, this.balance);\n}\n\nfunction reclaimTokenTo(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1, 'zero address is not allowed');\n    0x1688(varg2, varg1, varg0);\n    emit ReclaimTokens(varg1, varg2);\n}\n\nfunction RATE_COEFFICIENT() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction buyVouchers(uint256 varg0) public payable { \n    require(0xff & _fallback[msg.sender]);\n    v0, v1 = 0x1be4();\n    require(v0 >= v1, 'insufficient vouchers present');\n    v2 = 0x1839(varg0);\n    require(msg.value == v2, 'insufficient funds');\n    assert(varg0 + _purchased[msg.sender] >= _purchased[msg.sender]);\n    _purchased[msg.sender] += varg0;\n    assert(varg0 + _totalPurchased >= _totalPurchased);\n    _totalPurchased += varg0;\n    emit VouchersBought(msg.sender, varg0);\n}\n\nfunction releasePurchasedTo(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg1 <= _purchased[msg.sender], 'Insufficient Vouchers');\n    require(varg0, 'address should be valid');\n    0x17dd(varg1, msg.sender);\n    v0, v1 = 0x199c(varg1);\n    emit PurchasedVouchersReleased(msg.sender, 0, 5129);\n    return 1;\n}\n\nfunction voucherMthRate() public nonPayable { \n    return _voucherMthRate;\n}\n\nfunction updateVoucherMthRate(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 > 0, 'should be greater than 0');\n    require(varg0 != _voucherMthRate, 'same as previous value');\n    _voucherMthRate = varg0;\n    v0 = 0x1d24(_mthEthRate, _voucherMthRate);\n    stor_5 = v0;\n    emit VoucherMthRateUpdated(_voucherMthRate, varg0);\n}\n\nfunction setMonethaAddress(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _fallback[varg0] = varg1 | ~0xff & _fallback[varg0];\n    emit MonethaAddressSet(varg0, varg1);\n}\n\nfunction totalInSharedPool() public nonPayable { \n    v0, v1 = 0x1be4();\n    return v0;\n}\n\nfunction distributed(uint16 varg0, address varg1) public nonPayable { \n    return _distributed[varg1];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return 0;\n}\n\nfunction totalPurchased() public nonPayable { \n    return _totalPurchased;\n}\n\nfunction fromWei(uint256 varg0) public nonPayable { \n    v0 = 0x1977(varg0);\n    return v0;\n}\n\nfunction totalDistributed() public nonPayable { \n    v0 = 0x1c61(block.timestamp / 0xf0c3f0);\n    return v0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else {\n            if (0x95ea7b3 != function_selector) {\n                if (0xce11ded == function_selector) {\n                    updateMthEthRate(uint256);\n                } else if (0x17ffc320 == function_selector) {\n                    reclaimToken(address);\n                } else if (0x18160ddd == function_selector) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                } else if (0x2e84a374 == function_selector) {\n                    reclaimEtherTo(address,uint256);\n                } else if (0x313ce567 == function_selector) {\n                    decimals();\n                } else if (0x31d41325 == function_selector) {\n                    isMonethaAddress(address);\n                } else if (0x3f4ba83a == function_selector) {\n                    unpause();\n                } else if (0x49ff7a62 == function_selector) {\n                    mthEthRate();\n                } else if (0x522fe98e == function_selector) {\n                    purchased(address);\n                } else if (0x5a3b7e42 == function_selector) {\n                    standard();\n                } else if (0x5c975abb == function_selector) {\n                    paused();\n                } else if (0x6481f081 == function_selector) {\n                    sellVouchers(uint256);\n                } else if (0x669dafe8 == function_selector) {\n                    toWei(uint256);\n                } else if (0x6a2b171a == function_selector) {\n                    applyDiscount(address,uint256);\n                } else if (0x6daa212f == function_selector) {\n                    applyPayback(address,uint256);\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x715018a6 == function_selector) {\n                    renounceOwnership();\n                } else if (0x732a935c == function_selector) {\n                    totalDistributedIn(uint16);\n                } else if (0x8456cb59 == function_selector) {\n                    pause();\n                } else if (0x8d8c36e9 == function_selector) {\n                    purchasedBy(address);\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0x93306c43 == function_selector) {\n                    mthToken();\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0x9f727c27 == function_selector) {\n                    reclaimEther();\n                } else if (0x9fe98bda == function_selector) {\n                    reclaimTokenTo(address,address,uint256);\n                } else if (0xa05e0f65 == function_selector) {\n                    RATE_COEFFICIENT();\n                } else if (0xa9059cbb != function_selector) {\n                    if (0xb0408721 == function_selector) {\n                        buyVouchers(uint256);\n                    } else if (0xb2bea9c1 == function_selector) {\n                        releasePurchasedTo(address,uint256);\n                    } else if (0xb6f81724 == function_selector) {\n                        voucherMthRate();\n                    } else if (0xb9c5eb90 == function_selector) {\n                        updateVoucherMthRate(uint256);\n                    } else if (0xc07e3391 == function_selector) {\n                        setMonethaAddress(address,bool);\n                    } else if (0xc3fdbef8 == function_selector) {\n                        totalInSharedPool();\n                    } else if (0xd9582cde == function_selector) {\n                        distributed(uint16,address);\n                    } else if (0xdd62ed3e == function_selector) {\n                        allowance(address,address);\n                    } else if (0xe632c2f3 == function_selector) {\n                        totalPurchased();\n                    } else if (0xe65d1522 == function_selector) {\n                        fromWei(uint256);\n                    } else if (0xefca2eed == function_selector) {\n                        totalDistributed();\n                    } else if (0xf2fde38b == function_selector) {\n                        transferOwnership(address);\n                    }\n                }\n            }\n            transfer(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 20:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x1]\nuint256 _voucherMthRate; // STORAGE[0x3]\nuint256 _mthEthRate; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _purchased; // STORAGE[0x7]\nuint256 _totalPurchased; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _totalDistributedIn; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _distributed; // STORAGE[0xa]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x2] bytes 0 to 0\naddress _mthToken; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nMthEthRateUpdated(uint256, uint256);\nReclaimTokens(address, uint256);\nReclaimEther(address, uint256);\nUnpause();\nVouchersSold(address, uint256, uint256);\nDiscountApplied(address, uint256, uint256);\nPaybackApplied(address, uint256, uint256);\nOwnershipRenounced(address);\nPause();\nVouchersBought(address, uint256);\nPurchasedVouchersReleased(address, address, uint256);\nVoucherMthRateUpdated(uint256, uint256);\nMonethaAddressSet(address, bool);\nVoucherReleased(address, uint256);\nVouchersAdded(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1688(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = address(varg1);\n    require(v0.code.size);\n    v2, v3 = v0.transfer(v1, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    return ;\n}\n\nfunction 0x1740() private { \n    require(_mthToken.code.size);\n    v0, v1 = _mthToken.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = 0x1d24(_voucherMthRate, v1);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0x17dd(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    assert(varg0 <= _purchased[v0]);\n    v1 = address(varg1);\n    _purchased[v1] = _purchased[v0] - varg0;\n    assert(varg0 <= _totalPurchased);\n    _totalPurchased = _totalPurchased - varg0;\n    return ;\n}\n\nfunction 0x1839(uint256 varg0) private { \n    v0 = 0x1d24(0xc097ce7bc90715b34b9f1000000000, varg0);\n    assert(stor_5);\n    return v0 / stor_5;\n}\n\nfunction 0x1977(uint256 varg0) private { \n    v0 = 0x1d24(stor_5, varg0);\n    assert(0xc097ce7bc90715b34b9f1000000000);\n    return v0 / 0xc097ce7bc90715b34b9f1000000000;\n}\n\nfunction 0x199c(uint256 varg0) private { \n    require(address(v0), 'zero address is not allowed');\n    v1, v2 = 0x1be4();\n    require(v1 >= v2, 'must be less or equal than vouchers present in shared pool');\n    assert(block.timestamp / 0xf0c3f0 + _totalDistributedIn[0] >= _totalDistributedIn[0]);\n    _totalDistributedIn[0] += block.timestamp / 0xf0c3f0;\n    assert(block.timestamp / 0xf0c3f0 + _distributed[0] >= _distributed[0]);\n    _distributed[0] += block.timestamp / 0xf0c3f0;\n    emit VouchersAdded(0, block.timestamp / 0xf0c3f0);\n    return 1, v0;\n}\n\nfunction 0x1be4() private { \n    v0 = v1 = 0;\n    v2 = v3 = 3229;\n    v0 = v4 = _totalPurchased;\n    v2 = v5 = 7168;\n    v0 = v6 = 0x1c61(v2);\n    v7 = v8 = 0x1740();\n    while (1) {\n        assert(v0 <= v7);\n        v7 = v7 - v0;\n        goto {'0x1c00', '0xc9d0x1be4'};\n        return v7, v2;\n    }\n}\n\nfunction 0x1c61(uint256 varg0) private { \n    v0 = uint16(varg0);\n    if (0 >= v0) {\n        return _totalDistributedIn[v0];\n    } else {\n        v1 = uint16(varg0 + ~0);\n        assert(_totalDistributedIn[v1] + _totalDistributedIn[v0] >= _totalDistributedIn[v0]);\n        return _totalDistributedIn[v1] + _totalDistributedIn[v0];\n    }\n}\n\nfunction 0x1d24(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x1d97(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1) {\n        v0 = uint16(varg0);\n        v1 = address(varg2);\n        varg1 = v2 = _distributed[v1];\n        if (v2 > varg1) {\n            assert(varg1 <= v2);\n            v3 = uint16(varg0);\n            v4 = address(varg2);\n            _distributed[v4] = v2 - varg1;\n        } else {\n            v5 = uint16(varg0);\n            v6 = address(varg2);\n            _distributed[v6] = 0;\n        }\n        v7 = uint16(varg0);\n        if (_totalDistributedIn[v7] != varg1) {\n            assert(varg1 <= _totalDistributedIn[v7]);\n            v8 = uint16(varg0);\n            _totalDistributedIn[v8] = _totalDistributedIn[v7] - varg1;\n        } else {\n            v9 = uint16(varg0);\n            _totalDistributedIn[v9] = 0;\n        }\n    } else {\n        varg1 = v10 = 0;\n    }\n    return varg1;\n}\n\nfunction fallback() public payable { \n    require(0xff & _fallback[msg.sender]);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'Monetha Voucher';\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    revert();\n}\n\nfunction updateMthEthRate(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 > 0, 'should be greater than 0');\n    require(varg0 != _mthEthRate, 'same as previous value');\n    _mthEthRate = varg0;\n    v0 = 0x1d24(_mthEthRate, _voucherMthRate);\n    stor_5 = v0;\n    emit MthEthRateUpdated(_mthEthRate, varg0);\n}\n\nfunction reclaimToken(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    0x1688(v1, _owner, varg0);\n    emit ReclaimTokens(_owner, v1);\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = 0x1740();\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    revert();\n}\n\nfunction reclaimEtherTo(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0, 'zero address is not allowed');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    emit ReclaimEther(varg0, varg1);\n}\n\nfunction decimals() public nonPayable { \n    return 5;\n}\n\nfunction isMonethaAddress(address varg0) public nonPayable { \n    return 0xff & _fallback[varg0];\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction mthEthRate() public nonPayable { \n    return _mthEthRate;\n}\n\nfunction purchased(address varg0) public nonPayable { \n    return _purchased[varg0];\n}\n\nfunction standard() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & 'ERC20';\n    }\n    return v0;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction sellVouchers(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 <= _purchased[msg.sender], 'Insufficient vouchers');\n    0x17dd(varg0, msg.sender);\n    v0 = 0x1839(varg0);\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1); // checks call status, propagates error data on error\n    emit VouchersSold(msg.sender, varg0, v0);\n    return v0;\n}\n\nfunction toWei(uint256 varg0) public nonPayable { \n    v0 = 0x1839(varg0);\n    return v0;\n}\n\nfunction applyDiscount(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0, 'zero address is not allowed');\n    require(varg0, 'must be valid address');\n    v0 = v1 = 0;\n    if (uint16(block.timestamp / 0xf0c3f0) > 0) {\n        v2 = v3 = 6411;\n        v4 = v5 = 0x1d97(block.timestamp / 0xf0c3f0 - 1, varg1, varg0);\n    }\n    v0 += v4;\n    assert(v0 >= v0);\n    goto {'0x190bB0x490', '0x192eB0x490'};\n    assert(v0 <= v6);\n    v6 = v6 - v0;\n    emit VoucherReleased(varg0, v0);\n    if (v0) {\n        v0 = v7 = 0x1839(v0);\n        require(v7 <= this.balance, 'insufficient funds');\n        v8 = varg0.call().value(v7).gas(2300 * !v7);\n        require(v8); // checks call status, propagates error data on error\n        emit DiscountApplied(varg0, v0, v7);\n    } else {\n        v0 = v9 = 0;\n    }\n    return v0, v0;\n    v2 = v10 = 6446;\n    v4 = 0x1d97(block.timestamp / 0xf0c3f0, v6, varg0);\n}\n\nfunction applyPayback(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    v0 = 0x1977(varg1);\n    v1, v2 = 0x199c(v0);\n    require(v1, 'vouchers must be added');\n    emit PaybackApplied(address(v0), v2, 3669);\n    return v2;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    v0 = v1 = _distributed[varg0];\n    if (0 < uint16(block.timestamp / 0xf0c3f0)) {\n        v0 = _distributed[varg0] + v1;\n        assert(v0 >= v1);\n    }\n    assert(_purchased[varg0] + v0 >= v0);\n    return _purchased[varg0] + v0;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipRenounced(_owner);\n    _owner = 0;\n}\n\nfunction totalDistributedIn(uint16 varg0) public nonPayable { \n    return _totalDistributedIn[varg0];\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction purchasedBy(address varg0) public nonPayable { \n    return _purchased[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction mthToken() public nonPayable { \n    return _mthToken;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4d54485600000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction reclaimEther() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(this.balance).gas(!this.balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit ReclaimEther(_owner, this.balance);\n}\n\nfunction reclaimTokenTo(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1, 'zero address is not allowed');\n    0x1688(varg2, varg1, varg0);\n    emit ReclaimTokens(varg1, varg2);\n}\n\nfunction RATE_COEFFICIENT() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction buyVouchers(uint256 varg0) public payable { \n    require(0xff & _fallback[msg.sender]);\n    v0, v1 = 0x1be4();\n    require(v0 >= v1, 'insufficient vouchers present');\n    v2 = 0x1839(varg0);\n    require(msg.value == v2, 'insufficient funds');\n    assert(varg0 + _purchased[msg.sender] >= _purchased[msg.sender]);\n    _purchased[msg.sender] += varg0;\n    assert(varg0 + _totalPurchased >= _totalPurchased);\n    _totalPurchased += varg0;\n    emit VouchersBought(msg.sender, varg0);\n}\n\nfunction releasePurchasedTo(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg1 <= _purchased[msg.sender], 'Insufficient Vouchers');\n    require(varg0, 'address should be valid');\n    0x17dd(varg1, msg.sender);\n    v0, v1 = 0x199c(varg1);\n    emit PurchasedVouchersReleased(msg.sender, 0, 5129);\n    return 1;\n}\n\nfunction voucherMthRate() public nonPayable { \n    return _voucherMthRate;\n}\n\nfunction updateVoucherMthRate(uint256 varg0) public nonPayable { \n    require(0xff & _fallback[msg.sender]);\n    require(varg0 > 0, 'should be greater than 0');\n    require(varg0 != _voucherMthRate, 'same as previous value');\n    _voucherMthRate = varg0;\n    v0 = 0x1d24(_mthEthRate, _voucherMthRate);\n    stor_5 = v0;\n    emit VoucherMthRateUpdated(_voucherMthRate, varg0);\n}\n\nfunction setMonethaAddress(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _fallback[varg0] = varg1 | ~0xff & _fallback[varg0];\n    emit MonethaAddressSet(varg0, varg1);\n}\n\nfunction totalInSharedPool() public nonPayable { \n    v0, v1 = 0x1be4();\n    return v0;\n}\n\nfunction distributed(uint16 varg0, address varg1) public nonPayable { \n    return _distributed[varg1];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return 0;\n}\n\nfunction totalPurchased() public nonPayable { \n    return _totalPurchased;\n}\n\nfunction fromWei(uint256 varg0) public nonPayable { \n    v0 = 0x1977(varg0);\n    return v0;\n}\n\nfunction totalDistributed() public nonPayable { \n    v0 = 0x1c61(block.timestamp / 0xf0c3f0);\n    return v0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else {\n            if (0x95ea7b3 != function_selector) {\n                if (0xce11ded == function_selector) {\n                    updateMthEthRate(uint256);\n                } else if (0x17ffc320 == function_selector) {\n                    reclaimToken(address);\n                } else if (0x18160ddd == function_selector) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                } else if (0x2e84a374 == function_selector) {\n                    reclaimEtherTo(address,uint256);\n                } else if (0x313ce567 == function_selector) {\n                    decimals();\n                } else if (0x31d41325 == function_selector) {\n                    isMonethaAddress(address);\n                } else if (0x3f4ba83a == function_selector) {\n                    unpause();\n                } else if (0x49ff7a62 == function_selector) {\n                    mthEthRate();\n                } else if (0x522fe98e == function_selector) {\n                    purchased(address);\n                } else if (0x5a3b7e42 == function_selector) {\n                    standard();\n                } else if (0x5c975abb == function_selector) {\n                    paused();\n                } else if (0x6481f081 == function_selector) {\n                    sellVouchers(uint256);\n                } else if (0x669dafe8 == function_selector) {\n                    toWei(uint256);\n                } else if (0x6a2b171a == function_selector) {\n                    applyDiscount(address,uint256);\n                } else if (0x6daa212f == function_selector) {\n                    applyPayback(address,uint256);\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x715018a6 == function_selector) {\n                    renounceOwnership();\n                } else if (0x732a935c == function_selector) {\n                    totalDistributedIn(uint16);\n                } else if (0x8456cb59 == function_selector) {\n                    pause();\n                } else if (0x8d8c36e9 == function_selector) {\n                    purchasedBy(address);\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0x93306c43 == function_selector) {\n                    mthToken();\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0x9f727c27 == function_selector) {\n                    reclaimEther();\n                } else if (0x9fe98bda == function_selector) {\n                    reclaimTokenTo(address,address,uint256);\n                } else if (0xa05e0f65 == function_selector) {\n                    RATE_COEFFICIENT();\n                } else if (0xa9059cbb != function_selector) {\n                    if (0xb0408721 == function_selector) {\n                        buyVouchers(uint256);\n                    } else if (0xb2bea9c1 == function_selector) {\n                        releasePurchasedTo(address,uint256);\n                    } else if (0xb6f81724 == function_selector) {\n                        voucherMthRate();\n                    } else if (0xb9c5eb90 == function_selector) {\n                        updateVoucherMthRate(uint256);\n                    } else if (0xc07e3391 == function_selector) {\n                        setMonethaAddress(address,bool);\n                    } else if (0xc3fdbef8 == function_selector) {\n                        totalInSharedPool();\n                    } else if (0xd9582cde == function_selector) {\n                        distributed(uint16,address);\n                    } else if (0xdd62ed3e == function_selector) {\n                        allowance(address,address);\n                    } else if (0xe632c2f3 == function_selector) {\n                        totalPurchased();\n                    } else if (0xe65d1522 == function_selector) {\n                        fromWei(uint256);\n                    } else if (0xefca2eed == function_selector) {\n                        totalDistributed();\n                    } else if (0xf2fde38b == function_selector) {\n                        transferOwnership(address);\n                    }\n                }\n            }\n            transfer(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 48.33455014228821,
	"usage": {
		"completion_tokens": 625,
		"prompt_tokens": 5346,
		"total_tokens": 5971
	}
}