{
	"address": "0xbf001adcb04089dddedcab714f3b4d34ee6d56dc",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a simple translation of the decompiled code into Solidity contract code. Note that the decompiler has made some assumptions and inferences about the code, so the original code may have been slightly different. \n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256[] private _name;\n    uint256[] private _symbol;\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 private _sellPrice;\n    uint256 private _fallback;\n    mapping (address => bool) private _frozenAccount;\n    address private _owner;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function fallback() public payable {\n        require(_fallback > 0);\n        _transfer(msg.value / _fallback, msg.sender, address(this));\n    }\n\n    function setPrices(uint256 newSellPrice, uint256 newFallback) public {\n        require(msg.sender == _owner);\n        _sellPrice = newSellPrice;\n        _fallback = newFallback;\n    }\n\n    function name() public view returns (uint256[] memory) {\n        return _name;\n    }\n\n    // The rest of the contract functions go here, refer to the decompiled code for the function names and parameters\n    // For example:\n    // function approve(address _spender, uint256 _value) public returns (bool success) {...}\n    // function totalSupply() public view returns (uint256) {...}\n    // function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {...}\n    // ... and so on\n\n    function _transfer(uint256 _value, address _from, address _to) private {\n        require(_to != address(0));\n        require(_balanceOf[_from] >= _value);\n        require(_balanceOf[_to] + _value >= _balanceOf[_to]);\n        require(!_frozenAccount[_from]);\n        require(!_frozenAccount[_to]);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n    }\n}\n```\n\nThe above code is a simple contract that has a single owner, who is able to set the prices for selling and buying. The fallback function is used to handle incoming ether transactions. The `_transfer` function is a private function that is used to transfer funds between accounts. Note that the `name()` function in this example returns an array of `uint256`, which in a real-world contract would likely be a string. Please adjust the code as per your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465984,
	"id": "chatcmpl-8R5JgBxQ1o4YEb3Q0kF6AJfLBLxZn",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 12:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _fallback; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nFrozenFunds(address, bool);\n\nfunction fallback() public payable { \n    assert(_fallback);\n    0x8c3(msg.value / _fallback, msg.sender, this);\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _fallback = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x8c3(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction mintToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    emit Transfer(0, address(this), varg1);\n    emit Transfer(address(this), varg0, varg1);\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[varg0] >= varg1);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _fallback;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buy() public payable { \n    assert(_fallback);\n    0x8c3(msg.value / _fallback, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x8c3(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v1 = v2 = 0;\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require((address(this)).balance >= varg0 * _sellPrice);\n    0x8c3(varg0, this, msg.sender);\n    v0 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction 0x8c3(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balanceOf[v2] + varg0 >= _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v5] - varg0;\n    v6 = address(varg1);\n    _balanceOf[v6] = _balanceOf[v6] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79c65068 == function_selector) {\n            mintToken(address,uint256);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 12:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _fallback; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nFrozenFunds(address, bool);\n\nfunction fallback() public payable { \n    assert(_fallback);\n    0x8c3(msg.value / _fallback, msg.sender, this);\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _fallback = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x8c3(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction mintToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    emit Transfer(0, address(this), varg1);\n    emit Transfer(address(this), varg0, varg1);\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[varg0] >= varg1);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _fallback;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buy() public payable { \n    assert(_fallback);\n    0x8c3(msg.value / _fallback, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x8c3(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v1 = v2 = 0;\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require((address(this)).balance >= varg0 * _sellPrice);\n    0x8c3(varg0, this, msg.sender);\n    v0 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction 0x8c3(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balanceOf[v2] + varg0 >= _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v5] - varg0;\n    v6 = address(varg1);\n    _balanceOf[v6] = _balanceOf[v6] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79c65068 == function_selector) {\n            mintToken(address,uint256);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 12:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _fallback; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nFrozenFunds(address, bool);\n\nfunction fallback() public payable { \n    assert(_fallback);\n    0x8c3(msg.value / _fallback, msg.sender, this);\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _fallback = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x8c3(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction mintToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    emit Transfer(0, address(this), varg1);\n    emit Transfer(address(this), varg0, varg1);\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[varg0] >= varg1);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _fallback;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buy() public payable { \n    assert(_fallback);\n    0x8c3(msg.value / _fallback, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x8c3(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v1 = v2 = 0;\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require((address(this)).balance >= varg0 * _sellPrice);\n    0x8c3(varg0, this, msg.sender);\n    v0 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction 0x8c3(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balanceOf[v2] + varg0 >= _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v5] - varg0;\n    v6 = address(varg1);\n    _balanceOf[v6] = _balanceOf[v6] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79c65068 == function_selector) {\n            mintToken(address,uint256);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 23.959142446517944,
	"usage": {
		"completion_tokens": 608,
		"prompt_tokens": 2853,
		"total_tokens": 3461
	}
}