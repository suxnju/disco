{
	"address": "0xd76b5c2a23ef78368d8e34288b5b65d616b746ae",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on your provided decompiled code, here is the Solidity code.\n\n```solidity\npragma solidity >=0.8.0 <0.9.0;\n\ncontract MyContract {\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    address public owner;\n    address public newOwner;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    string public standard;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnerUpdate(address indexed prevOwner, address indexed newOwner);\n    event Issuance(uint256 amount);\n    event Destruction(uint256 amount);\n\n    constructor() {\n        // initialize contract\n    }\n\n    function transferOwnership(address _newOwner) public {\n        require(msg.sender == owner);\n        require(owner != _newOwner);\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public {\n        require(newOwner == msg.sender);\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n\n    function deposit() public payable {\n        require(msg.value + balanceOf[msg.sender] >= balanceOf[msg.sender]);\n        balanceOf[msg.sender] += msg.value;\n        require(msg.value + totalSupply >= totalSupply);\n        totalSupply += msg.value;\n        emit Issuance(msg.value);\n        emit Transfer(msg.value, address(this), msg.sender);\n    }\n\n    function withdrawTokens(address _token, address _to, uint256 _amount) public {\n        require(msg.sender == owner);\n        require(_token != address(0));\n        require(_to != address(0));\n        require(_to != address(this));\n        require(_amount > 0);\n        // Assuming transfer method exists on _token contract\n        // _token.transfer(_to, _amount);\n    }\n\n    fallback() external payable {\n        // default function\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require(_spender != address(0));\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(_value, msg.sender, _spender);\n        return true;\n    }\n\n    function withdraw(uint256 _amount) public {\n        require(balanceOf[msg.sender] >= _amount);\n        balanceOf[msg.sender] -= _amount;\n        require(totalSupply >= _amount);\n        totalSupply -= _amount;\n        payable(msg.sender).transfer(_amount);\n        emit Transfer(_amount, msg.sender, address(this));\n        emit Destruction(_amount);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_to != address(this));\n        require(_to != address(0));\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        require(_value + balanceOf[_to] >= balanceOf[_to]);\n        balanceOf[_to] += _value;\n        emit Transfer(_value, msg.sender, _to);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_to != address(this));\n        require(_from != address(0));\n        require(_to != address(0));\n        require(allowance[_from][msg.sender] >= _value);\n        allowance[_from][msg.sender] -= _value;\n        require(balanceOf[_from] >= _value);\n        balanceOf[_from] -= _value;\n        require(_value + balanceOf[_to] >= balanceOf[_to]);\n        balanceOf[_to] += _value;\n        emit Transfer(_value, _from, _to);\n        return true;\n    }\n}\n```\n\nThis is a simple ERC20 contract with some extra functions such as `transferOwnership`, `acceptOwnership`, `deposit`, and `withdraw`. Please replace the comment in constructor with your own initialization code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471804,
	"id": "chatcmpl-8MugWg5L93Qn9KKZ9sSbgXiU72jag",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  standard is array of uint256 at storage 0\n  name is array of uint256 at storage 1\n  symbol is array of uint256 at storage 2\n  decimals is uint8 at storage 3\n  totalSupply is uint256 at storage 4\n  balanceOf is mapping of uint256 at storage 5\n  allowance is mapping of uint256 at storage 6\n  owner is addr at storage 7\n  newOwner is addr at storage 8\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef decimals(): # not payable\n  return decimals\n\ndef standard(): # not payable\n  return standard[0 len standard.length]\n\ndef balanceOf(address _owner): # not payable\n  return balanceOf[_owner]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address _owner, address _spender): # not payable\n  return allowance[_owner][_spender]\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address _newOwner): # not payable\n  require owner == caller\n  require owner != _newOwner\n  newOwner = _newOwner\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnerUpdate(\n        address prevOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n  newOwner = 0\n\ndef deposit() payable: \n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 tokens=caller)\n\ndef withdrawTokens(address _token, address _to, uint256 _amount): # not payable\n  require owner == caller\n  require _token\n  require _to\n  require _to != this.address\n  require ext_code.size(_token)\n  call _token.transfer(address to, uint256 tokens) with:\n       gas gas_remaining - 710 wei\n      args addr(_to), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n\ndef _fallback() payable: # default function\n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 tokens=caller)\n\ndef approve(address _spender, uint256 _value): # not payable\n  require _spender\n  if _value:\n      require not allowance[caller][addr(_spender)]\n  allowance[caller][addr(_spender)] = _value\n  log Approval(\n        address tokenOwner=_value,\n        address spender=caller,\n        uint256 tokens=_spender)\n  return 1\n\ndef withdraw(uint256 _amount): # not payable\n  require balanceOf[caller] >= _amount\n  balanceOf[caller] -= _amount\n  require totalSupply >= _amount\n  totalSupply -= _amount\n  call caller with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=_amount,\n        address to=caller,\n        uint256 tokens=this.address)\n  log Destruction(uint256 amount=_amount)\n\ndef transfer(address _to, uint256 _value): # not payable\n  require _to != this.address\n  require _to\n  require balanceOf[caller] >= _value\n  balanceOf[caller] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[addr(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=caller,\n        uint256 tokens=_to)\n  return 1\n\ndef transferFrom(address _from, address _to, uint256 _value): # not payable\n  require _to != this.address\n  require _from\n  require _to\n  require allowance[addr(_from)][caller] >= _value\n  allowance[addr(_from)][caller] -= _value\n  require balanceOf[addr(_from)] >= _value\n  balanceOf[addr(_from)] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[addr(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=_from,\n        uint256 tokens=_to)\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  standard is array of uint256 at storage 0\n  name is array of uint256 at storage 1\n  symbol is array of uint256 at storage 2\n  decimals is uint8 at storage 3\n  totalSupply is uint256 at storage 4\n  balanceOf is mapping of uint256 at storage 5\n  allowance is mapping of uint256 at storage 6\n  owner is addr at storage 7\n  newOwner is addr at storage 8\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef decimals(): # not payable\n  return decimals\n\ndef standard(): # not payable\n  return standard[0 len standard.length]\n\ndef balanceOf(address _owner): # not payable\n  return balanceOf[_owner]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address _owner, address _spender): # not payable\n  return allowance[_owner][_spender]\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address _newOwner): # not payable\n  require owner == caller\n  require owner != _newOwner\n  newOwner = _newOwner\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnerUpdate(\n        address prevOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n  newOwner = 0\n\ndef deposit() payable: \n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 tokens=caller)\n\ndef withdrawTokens(address _token, address _to, uint256 _amount): # not payable\n  require owner == caller\n  require _token\n  require _to\n  require _to != this.address\n  require ext_code.size(_token)\n  call _token.transfer(address to, uint256 tokens) with:\n       gas gas_remaining - 710 wei\n      args addr(_to), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n\ndef _fallback() payable: # default function\n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 tokens=caller)\n\ndef approve(address _spender, uint256 _value): # not payable\n  require _spender\n  if _value:\n      require not allowance[caller][addr(_spender)]\n  allowance[caller][addr(_spender)] = _value\n  log Approval(\n        address tokenOwner=_value,\n        address spender=caller,\n        uint256 tokens=_spender)\n  return 1\n\ndef withdraw(uint256 _amount): # not payable\n  require balanceOf[caller] >= _amount\n  balanceOf[caller] -= _amount\n  require totalSupply >= _amount\n  totalSupply -= _amount\n  call caller with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=_amount,\n        address to=caller,\n        uint256 tokens=this.address)\n  log Destruction(uint256 amount=_amount)\n\ndef transfer(address _to, uint256 _value): # not payable\n  require _to != this.address\n  require _to\n  require balanceOf[caller] >= _value\n  balanceOf[caller] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[addr(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=caller,\n        uint256 tokens=_to)\n  return 1\n\ndef transferFrom(address _from, address _to, uint256 _value): # not payable\n  require _to != this.address\n  require _from\n  require _to\n  require allowance[addr(_from)][caller] >= _value\n  allowance[addr(_from)][caller] -= _value\n  require balanceOf[addr(_from)] >= _value\n  balanceOf[addr(_from)] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[addr(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=_from,\n        uint256 tokens=_to)\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  standard is array of uint256 at storage 0\n  name is array of uint256 at storage 1\n  symbol is array of uint256 at storage 2\n  decimals is uint8 at storage 3\n  totalSupply is uint256 at storage 4\n  balanceOf is mapping of uint256 at storage 5\n  allowance is mapping of uint256 at storage 6\n  owner is addr at storage 7\n  newOwner is addr at storage 8\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef decimals(): # not payable\n  return decimals\n\ndef standard(): # not payable\n  return standard[0 len standard.length]\n\ndef balanceOf(address _owner): # not payable\n  return balanceOf[_owner]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address _owner, address _spender): # not payable\n  return allowance[_owner][_spender]\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address _newOwner): # not payable\n  require owner == caller\n  require owner != _newOwner\n  newOwner = _newOwner\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnerUpdate(\n        address prevOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n  newOwner = 0\n\ndef deposit() payable: \n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 tokens=caller)\n\ndef withdrawTokens(address _token, address _to, uint256 _amount): # not payable\n  require owner == caller\n  require _token\n  require _to\n  require _to != this.address\n  require ext_code.size(_token)\n  call _token.transfer(address to, uint256 tokens) with:\n       gas gas_remaining - 710 wei\n      args addr(_to), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n\ndef _fallback() payable: # default function\n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 tokens=caller)\n\ndef approve(address _spender, uint256 _value): # not payable\n  require _spender\n  if _value:\n      require not allowance[caller][addr(_spender)]\n  allowance[caller][addr(_spender)] = _value\n  log Approval(\n        address tokenOwner=_value,\n        address spender=caller,\n        uint256 tokens=_spender)\n  return 1\n\ndef withdraw(uint256 _amount): # not payable\n  require balanceOf[caller] >= _amount\n  balanceOf[caller] -= _amount\n  require totalSupply >= _amount\n  totalSupply -= _amount\n  call caller with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=_amount,\n        address to=caller,\n        uint256 tokens=this.address)\n  log Destruction(uint256 amount=_amount)\n\ndef transfer(address _to, uint256 _value): # not payable\n  require _to != this.address\n  require _to\n  require balanceOf[caller] >= _value\n  balanceOf[caller] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[addr(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=caller,\n        uint256 tokens=_to)\n  return 1\n\ndef transferFrom(address _from, address _to, uint256 _value): # not payable\n  require _to != this.address\n  require _from\n  require _to\n  require allowance[addr(_from)][caller] >= _value\n  allowance[addr(_from)][caller] -= _value\n  require balanceOf[addr(_from)] >= _value\n  balanceOf[addr(_from)] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[addr(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=_from,\n        uint256 tokens=_to)\n  return 1\n\n.",
	"status": "1",
	"time_cost": 46.40449404716492,
	"usage": {
		"completion_tokens": 836,
		"prompt_tokens": 1113,
		"total_tokens": 1949
	}
}