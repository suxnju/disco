{
	"address": "0x43b82a8d1a0d25293b3d128efb358c0b39a777b3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract based on the provided decompiled code:\n\n```solidity\npragma solidity ^0.8.7;\n\ncontract InvestmentContract {\n    mapping (address => uint256) private _balance;\n    mapping (address => uint256) private _time;\n    mapping (address => uint256) private _percentWithdraw;\n    mapping (address => uint256) private _allPercentWithdraw;\n    uint256 private _stepTime;\n    uint256 private _countOfInvestors;\n    uint256 private stor_7;\n    address payable _ownerAddress;\n\n    event Invest(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n\n    function time(address user) public view returns (uint256) { \n        return _time[user];\n    }\n\n    function percentRate() public view returns (uint256) {\n        uint256 rate = 0;\n        if (address(this).balance > 0) {\n            rate = 24;\n        }\n        return rate;\n    }\n\n    function ownerAddress() public view returns (address) {\n        return _ownerAddress;\n    }\n\n    function balance(address user) public view returns (uint256) {\n        return _balance[user];\n    }\n\n    function countOfInvestors() public view returns (uint256) {\n        return _countOfInvestors;\n    }\n\n    function stepTime() public view returns (uint256) {\n        return _stepTime;\n    }\n\n    function safeAdd(uint256 a, uint256 b) private pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= b, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function multiply(uint256 a, uint256 b) private pure returns (uint256) {\n        if (b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / b == a, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function payoutAmount() public view returns (uint256) {\n        return _percentWithdraw[msg.sender];\n    }\n\n    function allPercentWithdraw(address user) public view returns (uint256) {\n        return _allPercentWithdraw[user];\n    }\n\n    function percentWithdraw(address user) public view returns (uint256) {\n        return _percentWithdraw[user];\n    }\n\n    fallback() external payable {\n        if (msg.value > 0) {\n            if (_balance[msg.sender] == 0) {\n                _countOfInvestors += 1;\n            }\n            _balance[msg.sender] += msg.value;\n            _time[msg.sender] = block.timestamp;\n\n            uint256 commission = multiply(stor_7, msg.value) / 100;\n            _ownerAddress.transfer(commission);\n\n            emit Invest(msg.sender, msg.value);\n        } else {\n            require(_balance[msg.sender] > 0, \"Address not found\");\n            require(block.timestamp >= safeAdd(_stepTime, _time[msg.sender]), \"Too fast payout request\");\n\n            uint256 payout = multiply(2, _allPercentWithdraw[msg.sender]);\n            if (payout > _allPercentWithdraw[msg.sender]) {\n                _percentWithdraw[msg.sender] = safeAdd(payout, _percentWithdraw[msg.sender]);\n                _allPercentWithdraw[msg.sender] = safeAdd(payout, _allPercentWithdraw[msg.sender]);\n                payable(msg.sender).transfer(payout);\n\n                emit Withdraw(msg.sender, payout);\n            } else {\n                _balance[msg.sender] = 0;\n                _time[msg.sender] = 0;\n                _percentWithdraw[msg.sender] = 0;\n            }\n        }\n    }\n}\n```\nPlease note that while I have tried to accurately convert the decompiled code to Solidity, there are parts in the decompiled code which are not clear therefore some assumptions were made. Also, this contract seems to be an investment contract and it's highly recommended to have it audited by a professional before deploying.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469716,
	"id": "chatcmpl-8R6Hsi3gze6FhoUjGBf1j6EeqCDJT",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 21:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balance; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _time; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _percentWithdraw; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allPercentWithdraw; // STORAGE[0x3]\nuint256 _stepTime; // STORAGE[0x4]\nuint256 _countOfInvestors; // STORAGE[0x5]\nuint256 stor_7; // STORAGE[0x7]\naddress _ownerAddress; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\n\nfunction time(address varg0) public nonPayable { \n    return _time[varg0];\n}\n\nfunction percentRate() public nonPayable { \n    v0 = v1 = 0;\n    if (this.balance >= v1) {\n        v0 = v2 = 24;\n    }\n    return v0;\n}\n\nfunction ownerAddress() public nonPayable { \n    return _ownerAddress;\n}\n\nfunction balance(address varg0) public nonPayable { \n    return _balance[varg0];\n}\n\nfunction countOfInvestors() public nonPayable { \n    return _countOfInvestors;\n}\n\nfunction stepTime() public nonPayable { \n    return _stepTime;\n}\n\nfunction 0x335(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    if (this.balance >= v3) {\n        v0 = v4 = 24;\n    }\n    v5 = v6 = _stepTime;\n    v7 = v8 = 880;\n    assert(_time[msg.sender] <= block.timestamp);\n    v9 = block.timestamp - _time[msg.sender];\n    while (!v5) {\n        assert(v5);\n        assert(v0 <= v0);\n        return v0 - v0;\n        v0 = v9 / v5;\n        goto {'0x370', '0x39b', '0x3c7'};\n        v7 = v10 = 923;\n        v5 = v11 = 1000;\n        v9 = 0x698(v0, _balance[msg.sender]);\n        v0 = v12 = _percentWithdraw[msg.sender];\n        v0 = v13 = 979;\n        v7 = v14 = 967;\n        v5 = v15 = 24;\n        v9 = 0x698(v0, v0);\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x45b(uint256 varg0) private { \n    require(0 < _balance[msg.sender], 'Address not found');\n    v0 = _SafeAdd(_stepTime, _time[msg.sender]);\n    require(block.timestamp >= v0, 'Too fast payout request');\n    v1 = 0x698(2, _allPercentWithdraw[msg.sender]);\n    if (v1 > _allPercentWithdraw[msg.sender]) {\n        v2 = 0x335(1483, 0);\n        v3 = _SafeAdd(v2, _percentWithdraw[msg.sender]);\n        _percentWithdraw[msg.sender] = v3;\n        v4 = _SafeAdd(v2, _allPercentWithdraw[msg.sender]);\n        _allPercentWithdraw[msg.sender] = v4;\n        v5 = msg.sender.call().value(v2).gas(2300 * !v2);\n        require(v5); // checks call status, propagates error data on error\n        emit Withdraw(msg.sender, v2);\n    } else {\n        _balance[msg.sender] = 0;\n        _time[msg.sender] = 0;\n        _percentWithdraw[msg.sender] = 0;\n    }\n    return ;\n}\n\nfunction 0x698(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        0x45b(801);\n    } else {\n        if (!_balance[msg.sender]) {\n            _countOfInvestors += 1;\n        }\n        v0 = v1 = _balance[msg.sender] > 0;\n        if (v1) {\n            v2 = _SafeAdd(_stepTime, _time[msg.sender]);\n            v0 = block.timestamp > v2;\n        }\n        if (v0) {\n            0x45b(560);\n            _percentWithdraw[msg.sender] = 0;\n        }\n        v3 = _SafeAdd(msg.value, _balance[msg.sender]);\n        _balance[msg.sender] = v3;\n        _time[msg.sender] = block.timestamp;\n        v4 = 0x698(stor_7, msg.value);\n        assert(100);\n        v5 = _ownerAddress.call().value(v4 / 100).gas(2300 * !(v4 / 100));\n        require(v5); // checks call status, propagates error data on error\n        emit Invest(msg.sender, msg.value);\n    }\n}\n\nfunction allPercentWithdraw(address varg0) public nonPayable { \n    return _allPercentWithdraw[varg0];\n}\n\nfunction payoutAmount() public nonPayable { \n    v0 = 0x335(195, v1);\n    return v0;\n}\n\nfunction percentWithdraw(address varg0) public nonPayable { \n    return _percentWithdraw[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x4883c329) {\n            allPercentWithdraw(address);\n        } else if (0x6b46c8c3 == function_selector) {\n            payoutAmount();\n        } else if (0x7960eff8 == function_selector) {\n            percentWithdraw(address);\n        } else if (0x7c67a3e2 == function_selector) {\n            time(address);\n        } else if (0x8090114f == function_selector) {\n            percentRate();\n        } else if (0x8f84aa09 == function_selector) {\n            ownerAddress();\n        } else if (0xe3d670d7 == function_selector) {\n            balance(address);\n        } else if (0xf3f7d633 == function_selector) {\n            countOfInvestors();\n        } else if (0xf488fdd0 == function_selector) {\n            stepTime();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 21:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balance; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _time; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _percentWithdraw; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allPercentWithdraw; // STORAGE[0x3]\nuint256 _stepTime; // STORAGE[0x4]\nuint256 _countOfInvestors; // STORAGE[0x5]\nuint256 stor_7; // STORAGE[0x7]\naddress _ownerAddress; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\n\nfunction time(address varg0) public nonPayable { \n    return _time[varg0];\n}\n\nfunction percentRate() public nonPayable { \n    v0 = v1 = 0;\n    if (this.balance >= v1) {\n        v0 = v2 = 24;\n    }\n    return v0;\n}\n\nfunction ownerAddress() public nonPayable { \n    return _ownerAddress;\n}\n\nfunction balance(address varg0) public nonPayable { \n    return _balance[varg0];\n}\n\nfunction countOfInvestors() public nonPayable { \n    return _countOfInvestors;\n}\n\nfunction stepTime() public nonPayable { \n    return _stepTime;\n}\n\nfunction 0x335(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    if (this.balance >= v3) {\n        v0 = v4 = 24;\n    }\n    v5 = v6 = _stepTime;\n    v7 = v8 = 880;\n    assert(_time[msg.sender] <= block.timestamp);\n    v9 = block.timestamp - _time[msg.sender];\n    while (!v5) {\n        assert(v5);\n        assert(v0 <= v0);\n        return v0 - v0;\n        v0 = v9 / v5;\n        goto {'0x370', '0x39b', '0x3c7'};\n        v7 = v10 = 923;\n        v5 = v11 = 1000;\n        v9 = 0x698(v0, _balance[msg.sender]);\n        v0 = v12 = _percentWithdraw[msg.sender];\n        v0 = v13 = 979;\n        v7 = v14 = 967;\n        v5 = v15 = 24;\n        v9 = 0x698(v0, v0);\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x45b(uint256 varg0) private { \n    require(0 < _balance[msg.sender], 'Address not found');\n    v0 = _SafeAdd(_stepTime, _time[msg.sender]);\n    require(block.timestamp >= v0, 'Too fast payout request');\n    v1 = 0x698(2, _allPercentWithdraw[msg.sender]);\n    if (v1 > _allPercentWithdraw[msg.sender]) {\n        v2 = 0x335(1483, 0);\n        v3 = _SafeAdd(v2, _percentWithdraw[msg.sender]);\n        _percentWithdraw[msg.sender] = v3;\n        v4 = _SafeAdd(v2, _allPercentWithdraw[msg.sender]);\n        _allPercentWithdraw[msg.sender] = v4;\n        v5 = msg.sender.call().value(v2).gas(2300 * !v2);\n        require(v5); // checks call status, propagates error data on error\n        emit Withdraw(msg.sender, v2);\n    } else {\n        _balance[msg.sender] = 0;\n        _time[msg.sender] = 0;\n        _percentWithdraw[msg.sender] = 0;\n    }\n    return ;\n}\n\nfunction 0x698(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        0x45b(801);\n    } else {\n        if (!_balance[msg.sender]) {\n            _countOfInvestors += 1;\n        }\n        v0 = v1 = _balance[msg.sender] > 0;\n        if (v1) {\n            v2 = _SafeAdd(_stepTime, _time[msg.sender]);\n            v0 = block.timestamp > v2;\n        }\n        if (v0) {\n            0x45b(560);\n            _percentWithdraw[msg.sender] = 0;\n        }\n        v3 = _SafeAdd(msg.value, _balance[msg.sender]);\n        _balance[msg.sender] = v3;\n        _time[msg.sender] = block.timestamp;\n        v4 = 0x698(stor_7, msg.value);\n        assert(100);\n        v5 = _ownerAddress.call().value(v4 / 100).gas(2300 * !(v4 / 100));\n        require(v5); // checks call status, propagates error data on error\n        emit Invest(msg.sender, msg.value);\n    }\n}\n\nfunction allPercentWithdraw(address varg0) public nonPayable { \n    return _allPercentWithdraw[varg0];\n}\n\nfunction payoutAmount() public nonPayable { \n    v0 = 0x335(195, v1);\n    return v0;\n}\n\nfunction percentWithdraw(address varg0) public nonPayable { \n    return _percentWithdraw[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x4883c329) {\n            allPercentWithdraw(address);\n        } else if (0x6b46c8c3 == function_selector) {\n            payoutAmount();\n        } else if (0x7960eff8 == function_selector) {\n            percentWithdraw(address);\n        } else if (0x7c67a3e2 == function_selector) {\n            time(address);\n        } else if (0x8090114f == function_selector) {\n            percentRate();\n        } else if (0x8f84aa09 == function_selector) {\n            ownerAddress();\n        } else if (0xe3d670d7 == function_selector) {\n            balance(address);\n        } else if (0xf3f7d633 == function_selector) {\n            countOfInvestors();\n        } else if (0xf488fdd0 == function_selector) {\n            stepTime();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 21:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balance; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _time; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _percentWithdraw; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allPercentWithdraw; // STORAGE[0x3]\nuint256 _stepTime; // STORAGE[0x4]\nuint256 _countOfInvestors; // STORAGE[0x5]\nuint256 stor_7; // STORAGE[0x7]\naddress _ownerAddress; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\n\nfunction time(address varg0) public nonPayable { \n    return _time[varg0];\n}\n\nfunction percentRate() public nonPayable { \n    v0 = v1 = 0;\n    if (this.balance >= v1) {\n        v0 = v2 = 24;\n    }\n    return v0;\n}\n\nfunction ownerAddress() public nonPayable { \n    return _ownerAddress;\n}\n\nfunction balance(address varg0) public nonPayable { \n    return _balance[varg0];\n}\n\nfunction countOfInvestors() public nonPayable { \n    return _countOfInvestors;\n}\n\nfunction stepTime() public nonPayable { \n    return _stepTime;\n}\n\nfunction 0x335(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    if (this.balance >= v3) {\n        v0 = v4 = 24;\n    }\n    v5 = v6 = _stepTime;\n    v7 = v8 = 880;\n    assert(_time[msg.sender] <= block.timestamp);\n    v9 = block.timestamp - _time[msg.sender];\n    while (!v5) {\n        assert(v5);\n        assert(v0 <= v0);\n        return v0 - v0;\n        v0 = v9 / v5;\n        goto {'0x370', '0x39b', '0x3c7'};\n        v7 = v10 = 923;\n        v5 = v11 = 1000;\n        v9 = 0x698(v0, _balance[msg.sender]);\n        v0 = v12 = _percentWithdraw[msg.sender];\n        v0 = v13 = 979;\n        v7 = v14 = 967;\n        v5 = v15 = 24;\n        v9 = 0x698(v0, v0);\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x45b(uint256 varg0) private { \n    require(0 < _balance[msg.sender], 'Address not found');\n    v0 = _SafeAdd(_stepTime, _time[msg.sender]);\n    require(block.timestamp >= v0, 'Too fast payout request');\n    v1 = 0x698(2, _allPercentWithdraw[msg.sender]);\n    if (v1 > _allPercentWithdraw[msg.sender]) {\n        v2 = 0x335(1483, 0);\n        v3 = _SafeAdd(v2, _percentWithdraw[msg.sender]);\n        _percentWithdraw[msg.sender] = v3;\n        v4 = _SafeAdd(v2, _allPercentWithdraw[msg.sender]);\n        _allPercentWithdraw[msg.sender] = v4;\n        v5 = msg.sender.call().value(v2).gas(2300 * !v2);\n        require(v5); // checks call status, propagates error data on error\n        emit Withdraw(msg.sender, v2);\n    } else {\n        _balance[msg.sender] = 0;\n        _time[msg.sender] = 0;\n        _percentWithdraw[msg.sender] = 0;\n    }\n    return ;\n}\n\nfunction 0x698(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        0x45b(801);\n    } else {\n        if (!_balance[msg.sender]) {\n            _countOfInvestors += 1;\n        }\n        v0 = v1 = _balance[msg.sender] > 0;\n        if (v1) {\n            v2 = _SafeAdd(_stepTime, _time[msg.sender]);\n            v0 = block.timestamp > v2;\n        }\n        if (v0) {\n            0x45b(560);\n            _percentWithdraw[msg.sender] = 0;\n        }\n        v3 = _SafeAdd(msg.value, _balance[msg.sender]);\n        _balance[msg.sender] = v3;\n        _time[msg.sender] = block.timestamp;\n        v4 = 0x698(stor_7, msg.value);\n        assert(100);\n        v5 = _ownerAddress.call().value(v4 / 100).gas(2300 * !(v4 / 100));\n        require(v5); // checks call status, propagates error data on error\n        emit Invest(msg.sender, msg.value);\n    }\n}\n\nfunction allPercentWithdraw(address varg0) public nonPayable { \n    return _allPercentWithdraw[varg0];\n}\n\nfunction payoutAmount() public nonPayable { \n    v0 = 0x335(195, v1);\n    return v0;\n}\n\nfunction percentWithdraw(address varg0) public nonPayable { \n    return _percentWithdraw[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x4883c329) {\n            allPercentWithdraw(address);\n        } else if (0x6b46c8c3 == function_selector) {\n            payoutAmount();\n        } else if (0x7960eff8 == function_selector) {\n            percentWithdraw(address);\n        } else if (0x7c67a3e2 == function_selector) {\n            time(address);\n        } else if (0x8090114f == function_selector) {\n            percentRate();\n        } else if (0x8f84aa09 == function_selector) {\n            ownerAddress();\n        } else if (0xe3d670d7 == function_selector) {\n            balance(address);\n        } else if (0xf3f7d633 == function_selector) {\n            countOfInvestors();\n        } else if (0xf488fdd0 == function_selector) {\n            stepTime();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.64779233932495,
	"usage": {
		"completion_tokens": 811,
		"prompt_tokens": 1627,
		"total_tokens": 2438
	}
}