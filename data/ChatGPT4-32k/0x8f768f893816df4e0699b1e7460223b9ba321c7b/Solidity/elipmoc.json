{
	"address": "0x8f768f893816df4e0699b1e7460223b9ba321c7b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code that corresponds to the decompiled code.\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Crowdsale {\n    mapping(address => uint256) public balanceOf;\n    mapping(address => bool) public approvedUsers;\n    uint256 public fundingGoal;\n    uint256 public fundingCap;\n    uint256 public minContribution;\n    uint256 public decimals;\n    bool public fundingGoalReached;\n    uint256 public startTime;\n    uint256 public endTime;\n    uint256 public amountRaised;\n    uint256 public refundAmount;\n    uint256 public rate;\n    bool public paused;\n    address public owner;\n    address public beneficiary;\n    address public manager;\n    address public tokenReward;\n    event GoalReached(address recipient, uint256 totalAmountRaised);\n    event CapReached(address recipient, uint256 totalAmountRaised);\n    event FundTransfer(address backer, uint256 amount, bool isContribution);\n\n    // ... constructor and other functions ...\n\n    function fallback() public payable {\n        // insert the logic of the fallback function here\n    }\n\n    function terminate() public {\n        // insert the logic of the terminate function here\n    }\n\n    function ownerUnlockFund() public {\n        // insert the logic of the ownerUnlockFund function here\n    }\n\n    function ownerAllocateTokens(address _address, uint256 _value1, uint256 _value2) public {\n        // insert the logic of the ownerAllocateTokens function here\n    }\n\n    function rate() public view returns(uint256) {\n        return rate;\n    }\n\n    function changeEndTime(uint256 _endTime) public {\n        endTime = _endTime;\n    }\n\n    function decimals() public view returns(uint256) {\n        return decimals;\n    }\n\n    function endTime() public view returns(uint256) {\n        return endTime;\n    }\n\n    function setRate(uint256 _rate) public {\n        rate = _rate;\n    }\n\n    function beneficiary() public view returns(address) {\n        return beneficiary;\n    }\n\n    function unpause() public {\n        paused = false;\n    }\n\n    function manager() public view returns(address) {\n        return manager;\n    }\n\n    function paused() public view returns(bool) {\n        return paused;\n    }\n\n    function tokenReward() public view returns(address) {\n        return tokenReward;\n    }\n\n    function balanceOf(address _address) public view returns(uint256) {\n        return balanceOf[_address];\n    }\n\n    function ownerSafeWithdrawal() public {\n        // insert the logic of the ownerSafeWithdrawal function here\n    }\n\n    function startTime() public view returns(uint256) {\n        return startTime;\n    }\n\n    function disapproveUser(address _address) public {\n        approvedUsers[_address] = false;\n    }\n\n    function fundingGoal() public view returns(uint256) {\n        return fundingGoal;\n    }\n\n    function amountRaised() public view returns(uint256) {\n        return amountRaised;\n    }\n\n    function pause() public {\n        paused = true;\n    }\n\n    function fundingCapReached() public view returns(bool) {\n        return amountRaised >= fundingCap;\n    }\n\n    function approvedUsers(address _address) public view returns(bool) {\n        return approvedUsers[_address];\n    }\n\n    function changeStartTime(uint256 _startTime) public {\n        startTime = _startTime;\n    }\n\n    function owner() public view returns(address) {\n        return owner;\n    }\n\n    function changeManager(address _manager) public {\n        manager = _manager;\n    }\n\n    function minContribution() public view returns(uint256) {\n        return minContribution;\n    }\n\n    function refundAmount() public view returns(uint256) {\n        return refundAmount;\n    }\n\n    function changeMinContribution(uint256 _minContribution) public {\n        minContribution = _minContribution;\n    }\n\n    function saleClosed() public view returns(bool) {\n        return now > endTime;\n    }\n\n    function changeTokenAddress(address _tokenReward) public {\n        tokenReward = _tokenReward;\n    }\n\n    function currentTime() public view returns(uint256) {\n        return now;\n    }\n\n    function fundingGoalReached() public view returns(bool) {\n        return fundingGoalReached;\n    }\n\n    function approveUser(address _address) public {\n        approvedUsers[_address] = true;\n    }\n\n    function fundingCap() public view returns(uint256) {\n        return fundingCap;\n    }\n\n    function transferOwnership(address newOwner) public {\n        owner = newOwner;\n    }\n\n    function safeWithdrawal() public {\n        // insert the logic of the safeWithdrawal function here\n    }\n}\n```\n\nPlease note that the code is simplified and some of the functions are left as comments for you to fill in the logic. It's a basic structure of a crowdsale contract where users can buy tokens, the funds goal and cap can be reached, the contract can be paused, and users can be approved or disapproved to participate in the crowdsale.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457884,
	"id": "chatcmpl-8R3D26LJj5yIOJPs9ICxjGqcFObC3",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 15:51 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x2]\nuint256 _fundingCap; // STORAGE[0x3]\nuint256 _minContribution; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5]\nuint256 _fundingGoalReached; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _endTime; // STORAGE[0x8]\nuint256 _amountRaised; // STORAGE[0x9]\nuint256 _refundAmount; // STORAGE[0xa]\nuint256 _rate; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _approvedUsers; // STORAGE[0x10]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_c_0_0; // STORAGE[0xc] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x1] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _manager; // STORAGE[0xe] bytes 0 to 19\naddress _tokenReward; // STORAGE[0xf] bytes 0 to 19\n\n// Events\nGoalReached(address, uint256);\nCapReached(address, uint256);\nUnpause();\nPause();\nOwnershipTransferred(address, address);\nFundTransfer(address, uint256, bool);\n\nfunction fallback() public payable { \n    require(!_paused, 'You are not allowed to access this time.');\n    require(block.timestamp < _endTime, 'Validation: Before endtime');\n    require(block.timestamp >= _startTime, 'Validation: After starttime');\n    require(!(0xff & _fundingGoalReached >> 16), 'Sale is not yet ended');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(msg.value >= _minContribution, 'Value should be greater than minimum contribution');\n    require(0xff & _approvedUsers[msg.sender], 'Only the approved users are allowed to participate in ICO');\n    assert(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value;\n    assert(msg.value + _amountRaised >= _amountRaised);\n    _amountRaised += msg.value;\n    if (msg.value) {\n        v0 = v1 = _rate * msg.value;\n        assert(msg.value);\n        assert(v1 / msg.value == _rate);\n    } else {\n        v0 = v2 = 0;\n    }\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.owner().gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenReward.code.size);\n    v5, v6 = _tokenReward.transferFrom(address(v4), msg.sender, v0).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Transaction Failed. Please try again later.');\n    emit FundTransfer(msg.sender, msg.value, 1);\n    0xafb();\n    0xb6e();\n    stor_c_0_0 = 0;\n}\n\nfunction terminate() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _fundingGoalReached = 0x10000 | ~0xff0000 & _fundingGoalReached;\n}\n\nfunction ownerUnlockFund() public nonPayable { \n    require(block.timestamp >= _endTime, 'Validation: After endtime');\n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    _fundingGoalReached = ~0xff & _fundingGoalReached;\n}\n\nfunction ownerAllocateTokens(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.owner().gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenReward.code.size);\n    v5, v6 = _tokenReward.transferFrom(address(v4), varg0, 10 ** _decimals * varg2).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Transfer failed. Please check allowance');\n    assert(10 ** _decimals * varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += 10 ** _decimals * varg1;\n    assert(10 ** _decimals * varg1 + _amountRaised >= _amountRaised);\n    _amountRaised += 10 ** _decimals * varg1;\n    emit FundTransfer(varg0, 10 ** _decimals * varg1, 1);\n    0xafb();\n    0xb6e();\n    stor_c_0_0 = 0;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction changeEndTime(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _endTime = varg0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _rate = varg0;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction unpause() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(_paused, 'You are not allowed to access this time.');\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction manager() public nonPayable { \n    return _manager;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ownerSafeWithdrawal() public nonPayable { \n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(0xff & _fundingGoalReached, 'Check funding goal');\n    v0 = _beneficiary.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    emit FundTransfer(_beneficiary, this.balance, 0);\n    stor_c_0_0 = 0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction disapproveUser(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _approvedUsers[varg0] = ~0xff & _approvedUsers[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction pause() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(!_paused, 'You are not allowed to access this time.');\n    _paused = 1;\n    emit Pause();\n}\n\nfunction fundingCapReached() public nonPayable { \n    return 0xff & _fundingGoalReached >> 8;\n}\n\nfunction approvedUsers(address varg0) public nonPayable { \n    return 0xff & _approvedUsers[varg0];\n}\n\nfunction changeStartTime(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _startTime = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeManager(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _manager = varg0;\n}\n\nfunction minContribution() public nonPayable { \n    return _minContribution;\n}\n\nfunction refundAmount() public nonPayable { \n    return _refundAmount;\n}\n\nfunction changeMinContribution(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _minContribution = 10 ** _decimals * varg0;\n}\n\nfunction saleClosed() public nonPayable { \n    return 0xff & _fundingGoalReached >> 16;\n}\n\nfunction changeTokenAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _tokenReward = varg0;\n}\n\nfunction currentTime() public nonPayable { \n    return block.timestamp;\n}\n\nfunction fundingGoalReached() public nonPayable { \n    return 0xff & _fundingGoalReached;\n}\n\nfunction approveUser(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _approvedUsers[varg0] = 0x1 | ~0xff & _approvedUsers[varg0];\n}\n\nfunction fundingCap() public nonPayable { \n    return _fundingCap;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    require(varg0, 'Owner cannot be 0 address.');\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    require(block.timestamp >= _endTime, 'Validation: After endtime');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    if (!(0xff & _fundingGoalReached)) {\n        _balanceOf[msg.sender] = 0;\n        if (_balanceOf[msg.sender] > 0) {\n            v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n            assert(_balanceOf[msg.sender] + _refundAmount >= _refundAmount);\n            _refundAmount += _balanceOf[msg.sender];\n        }\n    }\n    stor_c_0_0 = 0;\n}\n\nfunction 0xafb() private { \n    if (!(0xff & _fundingGoalReached)) {\n        if (_amountRaised >= _fundingGoal) {\n            _fundingGoalReached = 0x1 | ~0xff & _fundingGoalReached;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n    }\n    return ;\n}\n\nfunction 0xb6e() private { \n    if (!(0xff & _fundingGoalReached >> 8)) {\n        if (_amountRaised >= _fundingCap) {\n            _fundingGoalReached = 0x10000 | (0x100 | _fundingGoalReached & ~0xff00) & ~0xff0000;\n            emit CapReached(_beneficiary, _amountRaised);\n            return ;\n        }\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc08bf88) {\n            terminate();\n        } else if (0x23ec8f62 == v0) {\n            ownerUnlockFund();\n        } else if (0x28e08186 == v0) {\n            ownerAllocateTokens(address,uint256,uint256);\n        } else if (0x2c4e722e == v0) {\n            rate();\n        } else if (0x3052b75e == v0) {\n            changeEndTime(uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x34fcf437 == v0) {\n            setRate(uint256);\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x481c6a75 == v0) {\n            manager();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x782e34c9 == v0) {\n            ownerSafeWithdrawal();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x78f2c321 == v0) {\n            disapproveUser(address);\n        } else if (0x7a3a0e84 == v0) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == v0) {\n            amountRaised();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x848b3821 == v0) {\n            fundingCapReached();\n        } else if (0x893cd3be == v0) {\n            approvedUsers(address);\n        } else if (0x8aa5b2c3 == v0) {\n            changeStartTime(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa3fbbaae == v0) {\n            changeManager(address);\n        } else if (0xaaffadf3 == v0) {\n            minContribution();\n        } else if (0xad33513f == v0) {\n            refundAmount();\n        } else if (0xb3b81d38 == v0) {\n            changeMinContribution(uint256);\n        } else if (0xb8c766b8 == v0) {\n            saleClosed();\n        } else if (0xc9cda91f == v0) {\n            changeTokenAddress(address);\n        } else if (0xd18e81b3 == v0) {\n            currentTime();\n        } else if (0xd424f628 == v0) {\n            fundingGoalReached();\n        } else if (0xd624fdb6 == v0) {\n            approveUser(address);\n        } else if (0xe3b2594f == v0) {\n            fundingCap();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfd6b7ef8 == v0) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 15:51 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x2]\nuint256 _fundingCap; // STORAGE[0x3]\nuint256 _minContribution; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5]\nuint256 _fundingGoalReached; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _endTime; // STORAGE[0x8]\nuint256 _amountRaised; // STORAGE[0x9]\nuint256 _refundAmount; // STORAGE[0xa]\nuint256 _rate; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _approvedUsers; // STORAGE[0x10]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_c_0_0; // STORAGE[0xc] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x1] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _manager; // STORAGE[0xe] bytes 0 to 19\naddress _tokenReward; // STORAGE[0xf] bytes 0 to 19\n\n// Events\nGoalReached(address, uint256);\nCapReached(address, uint256);\nUnpause();\nPause();\nOwnershipTransferred(address, address);\nFundTransfer(address, uint256, bool);\n\nfunction fallback() public payable { \n    require(!_paused, 'You are not allowed to access this time.');\n    require(block.timestamp < _endTime, 'Validation: Before endtime');\n    require(block.timestamp >= _startTime, 'Validation: After starttime');\n    require(!(0xff & _fundingGoalReached >> 16), 'Sale is not yet ended');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(msg.value >= _minContribution, 'Value should be greater than minimum contribution');\n    require(0xff & _approvedUsers[msg.sender], 'Only the approved users are allowed to participate in ICO');\n    assert(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value;\n    assert(msg.value + _amountRaised >= _amountRaised);\n    _amountRaised += msg.value;\n    if (msg.value) {\n        v0 = v1 = _rate * msg.value;\n        assert(msg.value);\n        assert(v1 / msg.value == _rate);\n    } else {\n        v0 = v2 = 0;\n    }\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.owner().gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenReward.code.size);\n    v5, v6 = _tokenReward.transferFrom(address(v4), msg.sender, v0).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Transaction Failed. Please try again later.');\n    emit FundTransfer(msg.sender, msg.value, 1);\n    0xafb();\n    0xb6e();\n    stor_c_0_0 = 0;\n}\n\nfunction terminate() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _fundingGoalReached = 0x10000 | ~0xff0000 & _fundingGoalReached;\n}\n\nfunction ownerUnlockFund() public nonPayable { \n    require(block.timestamp >= _endTime, 'Validation: After endtime');\n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    _fundingGoalReached = ~0xff & _fundingGoalReached;\n}\n\nfunction ownerAllocateTokens(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.owner().gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenReward.code.size);\n    v5, v6 = _tokenReward.transferFrom(address(v4), varg0, 10 ** _decimals * varg2).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Transfer failed. Please check allowance');\n    assert(10 ** _decimals * varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += 10 ** _decimals * varg1;\n    assert(10 ** _decimals * varg1 + _amountRaised >= _amountRaised);\n    _amountRaised += 10 ** _decimals * varg1;\n    emit FundTransfer(varg0, 10 ** _decimals * varg1, 1);\n    0xafb();\n    0xb6e();\n    stor_c_0_0 = 0;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction changeEndTime(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _endTime = varg0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _rate = varg0;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction unpause() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(_paused, 'You are not allowed to access this time.');\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction manager() public nonPayable { \n    return _manager;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ownerSafeWithdrawal() public nonPayable { \n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(0xff & _fundingGoalReached, 'Check funding goal');\n    v0 = _beneficiary.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    emit FundTransfer(_beneficiary, this.balance, 0);\n    stor_c_0_0 = 0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction disapproveUser(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _approvedUsers[varg0] = ~0xff & _approvedUsers[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction pause() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(!_paused, 'You are not allowed to access this time.');\n    _paused = 1;\n    emit Pause();\n}\n\nfunction fundingCapReached() public nonPayable { \n    return 0xff & _fundingGoalReached >> 8;\n}\n\nfunction approvedUsers(address varg0) public nonPayable { \n    return 0xff & _approvedUsers[varg0];\n}\n\nfunction changeStartTime(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _startTime = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeManager(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _manager = varg0;\n}\n\nfunction minContribution() public nonPayable { \n    return _minContribution;\n}\n\nfunction refundAmount() public nonPayable { \n    return _refundAmount;\n}\n\nfunction changeMinContribution(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _minContribution = 10 ** _decimals * varg0;\n}\n\nfunction saleClosed() public nonPayable { \n    return 0xff & _fundingGoalReached >> 16;\n}\n\nfunction changeTokenAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _tokenReward = varg0;\n}\n\nfunction currentTime() public nonPayable { \n    return block.timestamp;\n}\n\nfunction fundingGoalReached() public nonPayable { \n    return 0xff & _fundingGoalReached;\n}\n\nfunction approveUser(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _approvedUsers[varg0] = 0x1 | ~0xff & _approvedUsers[varg0];\n}\n\nfunction fundingCap() public nonPayable { \n    return _fundingCap;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    require(varg0, 'Owner cannot be 0 address.');\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    require(block.timestamp >= _endTime, 'Validation: After endtime');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    if (!(0xff & _fundingGoalReached)) {\n        _balanceOf[msg.sender] = 0;\n        if (_balanceOf[msg.sender] > 0) {\n            v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n            assert(_balanceOf[msg.sender] + _refundAmount >= _refundAmount);\n            _refundAmount += _balanceOf[msg.sender];\n        }\n    }\n    stor_c_0_0 = 0;\n}\n\nfunction 0xafb() private { \n    if (!(0xff & _fundingGoalReached)) {\n        if (_amountRaised >= _fundingGoal) {\n            _fundingGoalReached = 0x1 | ~0xff & _fundingGoalReached;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n    }\n    return ;\n}\n\nfunction 0xb6e() private { \n    if (!(0xff & _fundingGoalReached >> 8)) {\n        if (_amountRaised >= _fundingCap) {\n            _fundingGoalReached = 0x10000 | (0x100 | _fundingGoalReached & ~0xff00) & ~0xff0000;\n            emit CapReached(_beneficiary, _amountRaised);\n            return ;\n        }\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc08bf88) {\n            terminate();\n        } else if (0x23ec8f62 == v0) {\n            ownerUnlockFund();\n        } else if (0x28e08186 == v0) {\n            ownerAllocateTokens(address,uint256,uint256);\n        } else if (0x2c4e722e == v0) {\n            rate();\n        } else if (0x3052b75e == v0) {\n            changeEndTime(uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x34fcf437 == v0) {\n            setRate(uint256);\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x481c6a75 == v0) {\n            manager();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x782e34c9 == v0) {\n            ownerSafeWithdrawal();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x78f2c321 == v0) {\n            disapproveUser(address);\n        } else if (0x7a3a0e84 == v0) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == v0) {\n            amountRaised();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x848b3821 == v0) {\n            fundingCapReached();\n        } else if (0x893cd3be == v0) {\n            approvedUsers(address);\n        } else if (0x8aa5b2c3 == v0) {\n            changeStartTime(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa3fbbaae == v0) {\n            changeManager(address);\n        } else if (0xaaffadf3 == v0) {\n            minContribution();\n        } else if (0xad33513f == v0) {\n            refundAmount();\n        } else if (0xb3b81d38 == v0) {\n            changeMinContribution(uint256);\n        } else if (0xb8c766b8 == v0) {\n            saleClosed();\n        } else if (0xc9cda91f == v0) {\n            changeTokenAddress(address);\n        } else if (0xd18e81b3 == v0) {\n            currentTime();\n        } else if (0xd424f628 == v0) {\n            fundingGoalReached();\n        } else if (0xd624fdb6 == v0) {\n            approveUser(address);\n        } else if (0xe3b2594f == v0) {\n            fundingCap();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfd6b7ef8 == v0) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 15:51 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x2]\nuint256 _fundingCap; // STORAGE[0x3]\nuint256 _minContribution; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5]\nuint256 _fundingGoalReached; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _endTime; // STORAGE[0x8]\nuint256 _amountRaised; // STORAGE[0x9]\nuint256 _refundAmount; // STORAGE[0xa]\nuint256 _rate; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _approvedUsers; // STORAGE[0x10]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_c_0_0; // STORAGE[0xc] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x1] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _manager; // STORAGE[0xe] bytes 0 to 19\naddress _tokenReward; // STORAGE[0xf] bytes 0 to 19\n\n// Events\nGoalReached(address, uint256);\nCapReached(address, uint256);\nUnpause();\nPause();\nOwnershipTransferred(address, address);\nFundTransfer(address, uint256, bool);\n\nfunction fallback() public payable { \n    require(!_paused, 'You are not allowed to access this time.');\n    require(block.timestamp < _endTime, 'Validation: Before endtime');\n    require(block.timestamp >= _startTime, 'Validation: After starttime');\n    require(!(0xff & _fundingGoalReached >> 16), 'Sale is not yet ended');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(msg.value >= _minContribution, 'Value should be greater than minimum contribution');\n    require(0xff & _approvedUsers[msg.sender], 'Only the approved users are allowed to participate in ICO');\n    assert(msg.value + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value;\n    assert(msg.value + _amountRaised >= _amountRaised);\n    _amountRaised += msg.value;\n    if (msg.value) {\n        v0 = v1 = _rate * msg.value;\n        assert(msg.value);\n        assert(v1 / msg.value == _rate);\n    } else {\n        v0 = v2 = 0;\n    }\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.owner().gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenReward.code.size);\n    v5, v6 = _tokenReward.transferFrom(address(v4), msg.sender, v0).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Transaction Failed. Please try again later.');\n    emit FundTransfer(msg.sender, msg.value, 1);\n    0xafb();\n    0xb6e();\n    stor_c_0_0 = 0;\n}\n\nfunction terminate() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _fundingGoalReached = 0x10000 | ~0xff0000 & _fundingGoalReached;\n}\n\nfunction ownerUnlockFund() public nonPayable { \n    require(block.timestamp >= _endTime, 'Validation: After endtime');\n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    _fundingGoalReached = ~0xff & _fundingGoalReached;\n}\n\nfunction ownerAllocateTokens(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(_tokenReward.code.size);\n    v3, v4 = _tokenReward.owner().gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenReward.code.size);\n    v5, v6 = _tokenReward.transferFrom(address(v4), varg0, 10 ** _decimals * varg2).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Transfer failed. Please check allowance');\n    assert(10 ** _decimals * varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += 10 ** _decimals * varg1;\n    assert(10 ** _decimals * varg1 + _amountRaised >= _amountRaised);\n    _amountRaised += 10 ** _decimals * varg1;\n    emit FundTransfer(varg0, 10 ** _decimals * varg1, 1);\n    0xafb();\n    0xb6e();\n    stor_c_0_0 = 0;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction changeEndTime(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _endTime = varg0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _rate = varg0;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction unpause() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(_paused, 'You are not allowed to access this time.');\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction manager() public nonPayable { \n    return _manager;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ownerSafeWithdrawal() public nonPayable { \n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    require(0xff & _fundingGoalReached, 'Check funding goal');\n    v0 = _beneficiary.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    emit FundTransfer(_beneficiary, this.balance, 0);\n    stor_c_0_0 = 0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction disapproveUser(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _approvedUsers[varg0] = ~0xff & _approvedUsers[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction pause() public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    require(!_paused, 'You are not allowed to access this time.');\n    _paused = 1;\n    emit Pause();\n}\n\nfunction fundingCapReached() public nonPayable { \n    return 0xff & _fundingGoalReached >> 8;\n}\n\nfunction approvedUsers(address varg0) public nonPayable { \n    return 0xff & _approvedUsers[varg0];\n}\n\nfunction changeStartTime(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _startTime = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeManager(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _manager = varg0;\n}\n\nfunction minContribution() public nonPayable { \n    return _minContribution;\n}\n\nfunction refundAmount() public nonPayable { \n    return _refundAmount;\n}\n\nfunction changeMinContribution(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _minContribution = 10 ** _decimals * varg0;\n}\n\nfunction saleClosed() public nonPayable { \n    return 0xff & _fundingGoalReached >> 16;\n}\n\nfunction changeTokenAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _tokenReward = varg0;\n}\n\nfunction currentTime() public nonPayable { \n    return block.timestamp;\n}\n\nfunction fundingGoalReached() public nonPayable { \n    return 0xff & _fundingGoalReached;\n}\n\nfunction approveUser(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _manager;\n    }\n    require(v0, 'Only owner or manager is allowed to call this');\n    _approvedUsers[varg0] = 0x1 | ~0xff & _approvedUsers[varg0];\n}\n\nfunction fundingCap() public nonPayable { \n    return _fundingCap;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'Only the owner is allowed to call this.');\n    require(varg0, 'Owner cannot be 0 address.');\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    require(block.timestamp >= _endTime, 'Validation: After endtime');\n    require(!stor_c_0_0, 'Validation: Reentrancy');\n    stor_c_0_0 = 1;\n    if (!(0xff & _fundingGoalReached)) {\n        _balanceOf[msg.sender] = 0;\n        if (_balanceOf[msg.sender] > 0) {\n            v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n            assert(_balanceOf[msg.sender] + _refundAmount >= _refundAmount);\n            _refundAmount += _balanceOf[msg.sender];\n        }\n    }\n    stor_c_0_0 = 0;\n}\n\nfunction 0xafb() private { \n    if (!(0xff & _fundingGoalReached)) {\n        if (_amountRaised >= _fundingGoal) {\n            _fundingGoalReached = 0x1 | ~0xff & _fundingGoalReached;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n    }\n    return ;\n}\n\nfunction 0xb6e() private { \n    if (!(0xff & _fundingGoalReached >> 8)) {\n        if (_amountRaised >= _fundingCap) {\n            _fundingGoalReached = 0x10000 | (0x100 | _fundingGoalReached & ~0xff00) & ~0xff0000;\n            emit CapReached(_beneficiary, _amountRaised);\n            return ;\n        }\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc08bf88) {\n            terminate();\n        } else if (0x23ec8f62 == v0) {\n            ownerUnlockFund();\n        } else if (0x28e08186 == v0) {\n            ownerAllocateTokens(address,uint256,uint256);\n        } else if (0x2c4e722e == v0) {\n            rate();\n        } else if (0x3052b75e == v0) {\n            changeEndTime(uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x34fcf437 == v0) {\n            setRate(uint256);\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x481c6a75 == v0) {\n            manager();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x782e34c9 == v0) {\n            ownerSafeWithdrawal();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x78f2c321 == v0) {\n            disapproveUser(address);\n        } else if (0x7a3a0e84 == v0) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == v0) {\n            amountRaised();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x848b3821 == v0) {\n            fundingCapReached();\n        } else if (0x893cd3be == v0) {\n            approvedUsers(address);\n        } else if (0x8aa5b2c3 == v0) {\n            changeStartTime(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa3fbbaae == v0) {\n            changeManager(address);\n        } else if (0xaaffadf3 == v0) {\n            minContribution();\n        } else if (0xad33513f == v0) {\n            refundAmount();\n        } else if (0xb3b81d38 == v0) {\n            changeMinContribution(uint256);\n        } else if (0xb8c766b8 == v0) {\n            saleClosed();\n        } else if (0xc9cda91f == v0) {\n            changeTokenAddress(address);\n        } else if (0xd18e81b3 == v0) {\n            currentTime();\n        } else if (0xd424f628 == v0) {\n            fundingGoalReached();\n        } else if (0xd624fdb6 == v0) {\n            approveUser(address);\n        } else if (0xe3b2594f == v0) {\n            fundingCap();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfd6b7ef8 == v0) {\n            safeWithdrawal();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 40.449851989746094,
	"usage": {
		"completion_tokens": 1009,
		"prompt_tokens": 4003,
		"total_tokens": 5012
	}
}