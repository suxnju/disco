{
	"address": "0x4ad96fc9f73f84ce7c543af44bdb0279b95a422b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the decompiled code, the Solidity contract might look like this:\n\n```solidity\npragma solidity ^0.8.2;\ncontract MyContract {\n    uint256 _totalSupply;\n    uint256 _decimals;\n    address _owner;\n    mapping (address => uint256) _balanceOf;\n    mapping (address => uint256) _lockValues;\n    mapping (address => mapping (address => uint256)) _allowance;\n    string _name;\n    string _symbol;\n    string _version;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _allowance[from][msg.sender]);\n        require(to != address(0));\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n    function setNameSymbol(string memory name, string memory symbol) public {\n        require(msg.sender == _owner);\n        _name = name;\n        _symbol = symbol;\n    }\n\n    function version() public view returns (string memory) {\n        return _version;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function addLockValue(address account, uint256 value) public {\n        require(msg.sender == _owner);\n        _lockValues[account] += value;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[msg.sender]);\n        require(to != address(0));\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function lockValues(address account) public view returns (uint256) {\n        return _lockValues[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function subLockValue(address account, uint256 value) public {\n        require(msg.sender == _owner);\n        require(value <= _lockValues[account]);\n        _lockValues[account] -= value;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n}\n```\n\nPlease note that the contract above is a simplified version of the decompiled code. Some parts of the original code (like the fallback function and function selector) were omitted as they are not typically used in Solidity contract code. Also, the storage variables `_name`, `_symbol`, and `_version` are assumed to be strings for simplicity, but in the original code, they are byte arrays which might indicate more complex logic.",
				"role": "assistant"
			}
		}
	],
	"created": 1702473515,
	"id": "chatcmpl-8VJQBdrBUhd3PP1bjEGvg3cJgtRdz",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 07:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _decimals; // STORAGE[0x3]\nuint256[] _version; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _lockValues; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction setNameSymbol(string varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    require(msg.sender == _owner);\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + _name.length >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = v8 = v2.data;\n    if (31 < v2.length) {\n        _symbol.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v8 + v2.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v2.length + v2.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _symbol.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[]((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n        if (31 < (_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction addLockValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    assert(varg1 + _lockValues[varg0] >= _lockValues[varg0]);\n    _lockValues[varg0] += varg1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(_lockValues[msg.sender] <= _balanceOf[msg.sender]);\n    require(varg1 <= _balanceOf[msg.sender] - _lockValues[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction lockValues(address varg0) public nonPayable { \n    return _lockValues[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction subLockValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    require(varg1 <= _lockValues[varg0]);\n    assert(varg1 <= _lockValues[varg0]);\n    _lockValues[varg0] = _lockValues[varg0] - varg1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x504334c2 == function_selector) {\n            setNameSymbol(string,string);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79e23483 == function_selector) {\n            addLockValue(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcb619a33 == function_selector) {\n            lockValues(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe59bcf52 == function_selector) {\n            subLockValue(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 07:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _decimals; // STORAGE[0x3]\nuint256[] _version; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _lockValues; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction setNameSymbol(string varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    require(msg.sender == _owner);\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + _name.length >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = v8 = v2.data;\n    if (31 < v2.length) {\n        _symbol.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v8 + v2.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v2.length + v2.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _symbol.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[]((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n        if (31 < (_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction addLockValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    assert(varg1 + _lockValues[varg0] >= _lockValues[varg0]);\n    _lockValues[varg0] += varg1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(_lockValues[msg.sender] <= _balanceOf[msg.sender]);\n    require(varg1 <= _balanceOf[msg.sender] - _lockValues[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction lockValues(address varg0) public nonPayable { \n    return _lockValues[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction subLockValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    require(varg1 <= _lockValues[varg0]);\n    assert(varg1 <= _lockValues[varg0]);\n    _lockValues[varg0] = _lockValues[varg0] - varg1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x504334c2 == function_selector) {\n            setNameSymbol(string,string);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79e23483 == function_selector) {\n            addLockValue(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcb619a33 == function_selector) {\n            lockValues(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe59bcf52 == function_selector) {\n            subLockValue(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 07:57 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _decimals; // STORAGE[0x3]\nuint256[] _version; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _lockValues; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction setNameSymbol(string varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    require(msg.sender == _owner);\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + _name.length >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = v8 = v2.data;\n    if (31 < v2.length) {\n        _symbol.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v8 + v2.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v2.length + v2.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _symbol.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[]((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n        if (31 < (_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction addLockValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    assert(varg1 + _lockValues[varg0] >= _lockValues[varg0]);\n    _lockValues[varg0] += varg1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(_lockValues[msg.sender] <= _balanceOf[msg.sender]);\n    require(varg1 <= _balanceOf[msg.sender] - _lockValues[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction lockValues(address varg0) public nonPayable { \n    return _lockValues[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction subLockValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    require(varg1 <= _lockValues[varg0]);\n    assert(varg1 <= _lockValues[varg0]);\n    _lockValues[varg0] = _lockValues[varg0] - varg1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x504334c2 == function_selector) {\n            setNameSymbol(string,string);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79e23483 == function_selector) {\n            addLockValue(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcb619a33 == function_selector) {\n            lockValues(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe59bcf52 == function_selector) {\n            subLockValue(address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 26.305432081222534,
	"usage": {
		"completion_tokens": 699,
		"prompt_tokens": 2714,
		"total_tokens": 3413
	}
}