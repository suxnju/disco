{
	"address": "0x18639f44f946983bf3413d9b51322d05c29d269e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code that was attempted to be decompiled from EVM Bytecode, with some assumptions for the missing functions:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Contract {\n    mapping(address => bool) public callers;\n    address public debugger;\n    bool public disabled;\n    address public data;\n\n    function func_025E() public payable {\n        emit Log(msg.value, msg.sender);\n    }\n\n    function func_0296(address arg0) public {\n        require(msg.sender == debugger, \"Not authorized\");\n        callers[arg0] = true;\n        emit LogCaller(arg0);\n    }\n\n    function withdrawTo(address payable to, uint256 amount) public {\n        require(!disabled, \"Contract is disabled\");\n        require(msg.sender == debugger, \"Not authorized\");\n        to.transfer(amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        withdrawTo(msg.sender, amount);\n    }\n\n    function calledUpdate(address arg0, address arg1) public {\n        require(msg.sender == debugger, \"Not authorized\");\n        if (data == arg0) {\n            data = arg1;\n            emit LogUpdate(arg0, arg1);\n        }\n    }\n\n    function disable(bool arg0) public {\n        require(msg.sender == debugger, \"Not authorized\");\n        disabled = arg0;\n    }\n\n    function func_0511() public {\n        require(msg.sender == debugger, \"Not authorized\");\n        debugger = address(0);\n    }\n\n    function removeCaller(address arg0) public {\n        require(msg.sender == debugger, \"Not authorized\");\n        callers[arg0] = false;\n        emit LogRemove(arg0);\n    }\n\n    event Log(uint256 value, address indexed sender);\n    event LogCaller(address indexed arg0);\n    event LogUpdate(address indexed arg0, address indexed arg1);\n    event LogRemove(address indexed arg0);\n}\n```\n\nPlease note that the EVM Bytecode decompilation can be challenging, and the recovered Solidity code may not completely match the original source code. It is also important to remember that the contract's storage layout should also be taken into account when decompiling a contract. The above code is the best possible match based on the given decompiled code and might not work as expected without the context of the entire contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472999,
	"id": "chatcmpl-8MuznKp6cB0OCBPum7VG3VGTBOeth",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length < 0x04) {\n        label_00C4:\n            var var0 = 0x00cc;\n            func_025E();\n            stop();\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x0c18865e) {\n                // Dispatch table entry for 0x0c18865e (unknown)\n                var var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                func_0296(var2);\n                stop();\n            } else if (var0 == 0x205c2878) {\n                // Dispatch table entry for withdrawTo(address,uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var var3 = msg.data[0x24:0x44];\n                withdrawTo(var2, var3);\n                stop();\n            } else if (var0 == 0x2e1a7d4d) {\n                // Dispatch table entry for withdraw(uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24];\n                withdraw(var2);\n                stop();\n            } else if (var0 == 0x70cfaa8d) {\n                // Dispatch table entry for calledUpdate(address,address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var temp0 = 0x02 ** 0xa0 - 0x01;\n                var2 = temp0 & msg.data[0x04:0x24];\n                var3 = msg.data[0x24:0x44] & temp0;\n                calledUpdate(var2, var3);\n                stop();\n            } else if (var0 == 0x73d4a13a) {\n                // Dispatch table entry for data()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0167;\n                var2 = data();\n            \n            label_0167:\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp2 = memory[0x40:0x60];\n                return memory[temp2:temp2 + temp1 - temp2 + 0x20];\n            } else if (var0 == 0x7bbf4a3f) {\n                // Dispatch table entry for callers(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01a4;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var2 = callers(var2);\n            \n            label_01A4:\n                var temp3 = memory[0x40:0x60];\n                memory[temp3:temp3 + 0x20] = !!var2;\n                var temp4 = memory[0x40:0x60];\n                return memory[temp4:temp4 + temp3 - temp4 + 0x20];\n            } else if (var0 == 0xa6f2fd5c) {\n                // Dispatch table entry for disable(bool)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = !!msg.data[0x04:0x24];\n                disable(var2);\n                stop();\n            } else if (var0 == 0xb0f545ba) {\n                // Dispatch table entry for debugger()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0167;\n                var2 = debugger();\n                goto label_0167;\n            } else if (var0 == 0xb8b34132) {\n                // Dispatch table entry for 0xb8b34132 (unknown)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                func_0511();\n                stop();\n            } else if (var0 == 0xd0e30db0) { goto label_00C4; }\n                // Dispatch table entry for deposit()\n            else if (var0 == 0xee070805) {\n                // Dispatch table entry for disabled()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01a4;\n                var2 = disabled();\n                goto label_01A4;\n            } else if (var0 == 0xeef21cd2) {\n                // Dispatch table entry for removeCaller(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                removeCaller(var2);\n                stop();\n            } else if (var0 == 0xf359e65f) {\n                // Dispatch table entry for 0xf359e65f (unknown)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var temp5 = msg.data[0x04:0x24];\n                var2 = temp5 + 0x24;\n                var3 = msg.data[temp5 + 0x04:temp5 + 0x04 + 0x20];\n                var temp6 = msg.data[0x24:0x44];\n                var var4 = temp6 + 0x24;\n                var var5 = msg.data[temp6 + 0x04:temp6 + 0x04 + 0x20];\n                func_05D1(var2, var3, var4, var5);\n                stop();\n            } else { goto label_00C4; }\n        }\n    }\n    \n    function func_025E() {\n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = msg.value;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + temp0 - temp1 + 0x20], [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, msg.sender]);\n    }\n    \n    function func_0296(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        storage[temp1] = (storage[temp1] & ~0xff) | 0x01;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = temp0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [0x735c128e3c049ff88e71ee4712b6e7096d53089462c09dd6b3c310f68ea44f8a]);\n    }\n    \n    function withdrawTo(var arg0, var arg1) {\n        if (storage[0x00] / 0x010000000000000000000000000000000000000000 & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x0357;\n        var var1 = 0x456d517565756500000000000000000000000000000000000000000000000000;\n        var0 = func_0731(var1);\n    \n        if (msg.sender != var0 & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = memory[0x40:0x60];\n        var temp1 = arg1;\n        var temp2;\n        temp2, memory[temp0:temp0 + 0x00] = address(arg0 & 0x02 ** 0xa0 - 0x01).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);\n        var0 = !temp2;\n    \n        if (!var0) {\n            var temp3 = memory[0x40:0x60];\n            memory[temp3:temp3 + 0x20] = arg1;\n            var temp4 = memory[0x40:0x60];\n            log(memory[temp4:temp4 + temp3 - temp4 + 0x20], [0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364, stack[-3] & 0x02 ** 0xa0 - 0x01]);\n            return;\n        } else {\n            var temp5 = returndata.length;\n            memory[0x00:0x00 + temp5] = returndata[0x00:0x00 + temp5];\n            revert(memory[0x00:0x00 + returndata.length]);\n        }\n    }\n    \n    function withdraw(var arg0) {\n        var var0 = 0x03ef;\n        var var1 = msg.sender;\n        var var2 = arg0;\n        withdrawTo(var1, var2);\n    }\n    \n    function calledUpdate(var arg0, var arg1) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & arg0) { return; }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = temp1 & arg1;\n        storage[0x02] = temp2 | (storage[0x02] & ~0xffffffffffffffffffffffffffffffffffffffff);\n        var temp3 = memory[0x40:0x60];\n        memory[temp3:temp3 + 0x20] = arg0 & temp1;\n        memory[temp3 + 0x20:temp3 + 0x20 + 0x20] = temp2;\n        var temp4 = memory[0x40:0x60];\n        log(memory[temp4:temp4 + temp3 - temp4 + 0x40], [0x1229c7500af0aab73d8c1cc0ea6c7d65249ebf050e292ce3bdf096fddec699a9]);\n    }\n    \n    function data() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function callers(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])] & 0xff;\n    }\n    \n    function disable(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | !!arg0 * 0x010000000000000000000000000000000000000000;\n    }\n    \n    function debugger() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function func_0511() {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        storage[0x00] = storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff;\n    }\n    \n    function disabled() returns (var r0) { return storage[0x00] / 0x010000000000000000000000000000000000000000 & 0xff; }\n    \n    function removeCaller(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        storage[temp1] = storage[temp1] & ~0xff;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = temp0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [0x3227fe2c42ad401fbb958a2a3205bb30289aa16ca66612b693cad680206b30e8]);\n    }\n    \n    function func_05D1(var arg0, var arg1, var arg2, var arg3) {\n        var var0 = 0x00;\n    \n        if (msg.sender != storage[var0] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var0 = 0x00;\n    \n        if (var0 >= arg1) {\n        label_0684:\n            var0 = 0x00;\n        \n            if (var0 >= arg3) {\n            label_072A:\n                return;\n            } else {\n            label_0691:\n                var var1 = 0x01;\n                var var2 = var1;\n                var var3 = 0x00;\n                var var4 = arg2;\n                var var5 = arg3;\n                var var6 = var0;\n            \n                if (var6 >= var5) { assert(); }\n            \n                var temp0 = var3;\n                memory[temp0:temp0 + 0x20] = msg.data[var6 * 0x20 + var4:var6 * 0x20 + var4 + 0x20] & 0x02 ** 0xa0 - 0x01;\n                memory[temp0 + 0x20:temp0 + 0x20 + 0x20] = var2;\n                var temp1 = keccak256(memory[0x00:0x00 + temp0 + 0x40]);\n                storage[temp1] = !!var1 | (storage[temp1] & ~0xff);\n                var1 = 0x735c128e3c049ff88e71ee4712b6e7096d53089462c09dd6b3c310f68ea44f8a;\n                var2 = arg2;\n                var3 = arg3;\n                var4 = var0;\n            \n                if (var4 >= var3) { assert(); }\n            \n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = msg.data[var4 * 0x20 + var2:var4 * 0x20 + var2 + 0x20] & 0x02 ** 0xa0 - 0x01;\n                var temp3 = memory[0x40:0x60];\n                log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [stack[-4]]);\n                var0 = var0 + 0x01;\n            \n                if (var0 >= arg3) { goto label_072A; }\n                else { goto label_0691; }\n            }\n        } else {\n        label_05F3:\n            var1 = 0x01;\n            var2 = 0x00;\n            var3 = arg0;\n            var4 = arg1;\n            var5 = var0;\n        \n            if (var5 >= var4) { assert(); }\n        \n            var temp4 = var2;\n            memory[temp4:temp4 + 0x20] = msg.data[var5 * 0x20 + var3:var5 * 0x20 + var3 + 0x20] & 0x02 ** 0xa0 - 0x01;\n            memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var1;\n            var temp5 = keccak256(memory[0x00:0x00 + temp4 + 0x40]);\n            storage[temp5] = storage[temp5] & ~0xff;\n            var1 = 0x3227fe2c42ad401fbb958a2a3205bb30289aa16ca66612b693cad680206b30e8;\n            var2 = arg0;\n            var3 = arg1;\n            var4 = var0;\n        \n            if (var4 >= var3) { assert(); }\n        \n            var temp6 = memory[0x40:0x60];\n            memory[temp6:temp6 + 0x20] = msg.data[var4 * 0x20 + var2:var4 * 0x20 + var2 + 0x20] & 0x02 ** 0xa0 - 0x01;\n            var temp7 = memory[0x40:0x60];\n            log(memory[temp7:temp7 + temp6 - temp7 + 0x20], [stack[-4]]);\n            var0 = var0 + 0x01;\n        \n            if (var0 >= arg1) { goto label_0684; }\n            else { goto label_05F3; }\n        }\n    }\n    \n    function func_0731(var arg0) returns (var r0) {\n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = 0x0f75243000000000000000000000000000000000000000000000000000000000;\n        memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = arg0;\n        var var0 = 0x00;\n        var var1 = storage[0x02] & 0x02 ** 0xa0 - 0x01;\n        var var2 = 0x0f752430;\n        var var3 = temp0 + 0x24;\n        var var4 = 0x20;\n        var var5 = memory[0x40:0x60];\n        var var6 = temp0 - var5 + 0x24;\n        var var7 = var5;\n        var var8 = var0;\n        var var9 = var1;\n        var var10 = !address(var9).code.length;\n    \n        if (var10) { revert(memory[0x00:0x00]); }\n    \n        var temp1;\n        temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas).value(var8)(memory[var7:var7 + var6]);\n        var4 = !temp1;\n    \n        if (!var4) {\n            var1 = memory[0x40:0x60];\n            var2 = returndata.length;\n        \n            if (var2 >= 0x20) { return memory[var1:var1 + 0x20]; }\n            else { revert(memory[0x00:0x00]); }\n        } else {\n            var temp2 = returndata.length;\n            memory[0x00:0x00 + temp2] = returndata[0x00:0x00 + temp2];\n            revert(memory[0x00:0x00 + returndata.length]);\n        }\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length < 0x04) {\n        label_00C4:\n            var var0 = 0x00cc;\n            func_025E();\n            stop();\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x0c18865e) {\n                // Dispatch table entry for 0x0c18865e (unknown)\n                var var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                func_0296(var2);\n                stop();\n            } else if (var0 == 0x205c2878) {\n                // Dispatch table entry for withdrawTo(address,uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var var3 = msg.data[0x24:0x44];\n                withdrawTo(var2, var3);\n                stop();\n            } else if (var0 == 0x2e1a7d4d) {\n                // Dispatch table entry for withdraw(uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24];\n                withdraw(var2);\n                stop();\n            } else if (var0 == 0x70cfaa8d) {\n                // Dispatch table entry for calledUpdate(address,address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var temp0 = 0x02 ** 0xa0 - 0x01;\n                var2 = temp0 & msg.data[0x04:0x24];\n                var3 = msg.data[0x24:0x44] & temp0;\n                calledUpdate(var2, var3);\n                stop();\n            } else if (var0 == 0x73d4a13a) {\n                // Dispatch table entry for data()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0167;\n                var2 = data();\n            \n            label_0167:\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp2 = memory[0x40:0x60];\n                return memory[temp2:temp2 + temp1 - temp2 + 0x20];\n            } else if (var0 == 0x7bbf4a3f) {\n                // Dispatch table entry for callers(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01a4;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var2 = callers(var2);\n            \n            label_01A4:\n                var temp3 = memory[0x40:0x60];\n                memory[temp3:temp3 + 0x20] = !!var2;\n                var temp4 = memory[0x40:0x60];\n                return memory[temp4:temp4 + temp3 - temp4 + 0x20];\n            } else if (var0 == 0xa6f2fd5c) {\n                // Dispatch table entry for disable(bool)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = !!msg.data[0x04:0x24];\n                disable(var2);\n                stop();\n            } else if (var0 == 0xb0f545ba) {\n                // Dispatch table entry for debugger()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0167;\n                var2 = debugger();\n                goto label_0167;\n            } else if (var0 == 0xb8b34132) {\n                // Dispatch table entry for 0xb8b34132 (unknown)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                func_0511();\n                stop();\n            } else if (var0 == 0xd0e30db0) { goto label_00C4; }\n                // Dispatch table entry for deposit()\n            else if (var0 == 0xee070805) {\n                // Dispatch table entry for disabled()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01a4;\n                var2 = disabled();\n                goto label_01A4;\n            } else if (var0 == 0xeef21cd2) {\n                // Dispatch table entry for removeCaller(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                removeCaller(var2);\n                stop();\n            } else if (var0 == 0xf359e65f) {\n                // Dispatch table entry for 0xf359e65f (unknown)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var temp5 = msg.data[0x04:0x24];\n                var2 = temp5 + 0x24;\n                var3 = msg.data[temp5 + 0x04:temp5 + 0x04 + 0x20];\n                var temp6 = msg.data[0x24:0x44];\n                var var4 = temp6 + 0x24;\n                var var5 = msg.data[temp6 + 0x04:temp6 + 0x04 + 0x20];\n                func_05D1(var2, var3, var4, var5);\n                stop();\n            } else { goto label_00C4; }\n        }\n    }\n    \n    function func_025E() {\n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = msg.value;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + temp0 - temp1 + 0x20], [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, msg.sender]);\n    }\n    \n    function func_0296(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        storage[temp1] = (storage[temp1] & ~0xff) | 0x01;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = temp0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [0x735c128e3c049ff88e71ee4712b6e7096d53089462c09dd6b3c310f68ea44f8a]);\n    }\n    \n    function withdrawTo(var arg0, var arg1) {\n        if (storage[0x00] / 0x010000000000000000000000000000000000000000 & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x0357;\n        var var1 = 0x456d517565756500000000000000000000000000000000000000000000000000;\n        var0 = func_0731(var1);\n    \n        if (msg.sender != var0 & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = memory[0x40:0x60];\n        var temp1 = arg1;\n        var temp2;\n        temp2, memory[temp0:temp0 + 0x00] = address(arg0 & 0x02 ** 0xa0 - 0x01).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);\n        var0 = !temp2;\n    \n        if (!var0) {\n            var temp3 = memory[0x40:0x60];\n            memory[temp3:temp3 + 0x20] = arg1;\n            var temp4 = memory[0x40:0x60];\n            log(memory[temp4:temp4 + temp3 - temp4 + 0x20], [0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364, stack[-3] & 0x02 ** 0xa0 - 0x01]);\n            return;\n        } else {\n            var temp5 = returndata.length;\n            memory[0x00:0x00 + temp5] = returndata[0x00:0x00 + temp5];\n            revert(memory[0x00:0x00 + returndata.length]);\n        }\n    }\n    \n    function withdraw(var arg0) {\n        var var0 = 0x03ef;\n        var var1 = msg.sender;\n        var var2 = arg0;\n        withdrawTo(var1, var2);\n    }\n    \n    function calledUpdate(var arg0, var arg1) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & arg0) { return; }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = temp1 & arg1;\n        storage[0x02] = temp2 | (storage[0x02] & ~0xffffffffffffffffffffffffffffffffffffffff);\n        var temp3 = memory[0x40:0x60];\n        memory[temp3:temp3 + 0x20] = arg0 & temp1;\n        memory[temp3 + 0x20:temp3 + 0x20 + 0x20] = temp2;\n        var temp4 = memory[0x40:0x60];\n        log(memory[temp4:temp4 + temp3 - temp4 + 0x40], [0x1229c7500af0aab73d8c1cc0ea6c7d65249ebf050e292ce3bdf096fddec699a9]);\n    }\n    \n    function data() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function callers(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])] & 0xff;\n    }\n    \n    function disable(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | !!arg0 * 0x010000000000000000000000000000000000000000;\n    }\n    \n    function debugger() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function func_0511() {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        storage[0x00] = storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff;\n    }\n    \n    function disabled() returns (var r0) { return storage[0x00] / 0x010000000000000000000000000000000000000000 & 0xff; }\n    \n    function removeCaller(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        storage[temp1] = storage[temp1] & ~0xff;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = temp0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [0x3227fe2c42ad401fbb958a2a3205bb30289aa16ca66612b693cad680206b30e8]);\n    }\n    \n    function func_05D1(var arg0, var arg1, var arg2, var arg3) {\n        var var0 = 0x00;\n    \n        if (msg.sender != storage[var0] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var0 = 0x00;\n    \n        if (var0 >= arg1) {\n        label_0684:\n            var0 = 0x00;\n        \n            if (var0 >= arg3) {\n            label_072A:\n                return;\n            } else {\n            label_0691:\n                var var1 = 0x01;\n                var var2 = var1;\n                var var3 = 0x00;\n                var var4 = arg2;\n                var var5 = arg3;\n                var var6 = var0;\n            \n                if (var6 >= var5) { assert(); }\n            \n                var temp0 = var3;\n                memory[temp0:temp0 + 0x20] = msg.data[var6 * 0x20 + var4:var6 * 0x20 + var4 + 0x20] & 0x02 ** 0xa0 - 0x01;\n                memory[temp0 + 0x20:temp0 + 0x20 + 0x20] = var2;\n                var temp1 = keccak256(memory[0x00:0x00 + temp0 + 0x40]);\n                storage[temp1] = !!var1 | (storage[temp1] & ~0xff);\n                var1 = 0x735c128e3c049ff88e71ee4712b6e7096d53089462c09dd6b3c310f68ea44f8a;\n                var2 = arg2;\n                var3 = arg3;\n                var4 = var0;\n            \n                if (var4 >= var3) { assert(); }\n            \n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = msg.data[var4 * 0x20 + var2:var4 * 0x20 + var2 + 0x20] & 0x02 ** 0xa0 - 0x01;\n                var temp3 = memory[0x40:0x60];\n                log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [stack[-4]]);\n                var0 = var0 + 0x01;\n            \n                if (var0 >= arg3) { goto label_072A; }\n                else { goto label_0691; }\n            }\n        } else {\n        label_05F3:\n            var1 = 0x01;\n            var2 = 0x00;\n            var3 = arg0;\n            var4 = arg1;\n            var5 = var0;\n        \n            if (var5 >= var4) { assert(); }\n        \n            var temp4 = var2;\n            memory[temp4:temp4 + 0x20] = msg.data[var5 * 0x20 + var3:var5 * 0x20 + var3 + 0x20] & 0x02 ** 0xa0 - 0x01;\n            memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var1;\n            var temp5 = keccak256(memory[0x00:0x00 + temp4 + 0x40]);\n            storage[temp5] = storage[temp5] & ~0xff;\n            var1 = 0x3227fe2c42ad401fbb958a2a3205bb30289aa16ca66612b693cad680206b30e8;\n            var2 = arg0;\n            var3 = arg1;\n            var4 = var0;\n        \n            if (var4 >= var3) { assert(); }\n        \n            var temp6 = memory[0x40:0x60];\n            memory[temp6:temp6 + 0x20] = msg.data[var4 * 0x20 + var2:var4 * 0x20 + var2 + 0x20] & 0x02 ** 0xa0 - 0x01;\n            var temp7 = memory[0x40:0x60];\n            log(memory[temp7:temp7 + temp6 - temp7 + 0x20], [stack[-4]]);\n            var0 = var0 + 0x01;\n        \n            if (var0 >= arg1) { goto label_0684; }\n            else { goto label_05F3; }\n        }\n    }\n    \n    function func_0731(var arg0) returns (var r0) {\n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = 0x0f75243000000000000000000000000000000000000000000000000000000000;\n        memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = arg0;\n        var var0 = 0x00;\n        var var1 = storage[0x02] & 0x02 ** 0xa0 - 0x01;\n        var var2 = 0x0f752430;\n        var var3 = temp0 + 0x24;\n        var var4 = 0x20;\n        var var5 = memory[0x40:0x60];\n        var var6 = temp0 - var5 + 0x24;\n        var var7 = var5;\n        var var8 = var0;\n        var var9 = var1;\n        var var10 = !address(var9).code.length;\n    \n        if (var10) { revert(memory[0x00:0x00]); }\n    \n        var temp1;\n        temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas).value(var8)(memory[var7:var7 + var6]);\n        var4 = !temp1;\n    \n        if (!var4) {\n            var1 = memory[0x40:0x60];\n            var2 = returndata.length;\n        \n            if (var2 >= 0x20) { return memory[var1:var1 + 0x20]; }\n            else { revert(memory[0x00:0x00]); }\n        } else {\n            var temp2 = returndata.length;\n            memory[0x00:0x00 + temp2] = returndata[0x00:0x00 + temp2];\n            revert(memory[0x00:0x00 + returndata.length]);\n        }\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length < 0x04) {\n        label_00C4:\n            var var0 = 0x00cc;\n            func_025E();\n            stop();\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x0c18865e) {\n                // Dispatch table entry for 0x0c18865e (unknown)\n                var var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                func_0296(var2);\n                stop();\n            } else if (var0 == 0x205c2878) {\n                // Dispatch table entry for withdrawTo(address,uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var var3 = msg.data[0x24:0x44];\n                withdrawTo(var2, var3);\n                stop();\n            } else if (var0 == 0x2e1a7d4d) {\n                // Dispatch table entry for withdraw(uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24];\n                withdraw(var2);\n                stop();\n            } else if (var0 == 0x70cfaa8d) {\n                // Dispatch table entry for calledUpdate(address,address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var temp0 = 0x02 ** 0xa0 - 0x01;\n                var2 = temp0 & msg.data[0x04:0x24];\n                var3 = msg.data[0x24:0x44] & temp0;\n                calledUpdate(var2, var3);\n                stop();\n            } else if (var0 == 0x73d4a13a) {\n                // Dispatch table entry for data()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0167;\n                var2 = data();\n            \n            label_0167:\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp2 = memory[0x40:0x60];\n                return memory[temp2:temp2 + temp1 - temp2 + 0x20];\n            } else if (var0 == 0x7bbf4a3f) {\n                // Dispatch table entry for callers(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01a4;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var2 = callers(var2);\n            \n            label_01A4:\n                var temp3 = memory[0x40:0x60];\n                memory[temp3:temp3 + 0x20] = !!var2;\n                var temp4 = memory[0x40:0x60];\n                return memory[temp4:temp4 + temp3 - temp4 + 0x20];\n            } else if (var0 == 0xa6f2fd5c) {\n                // Dispatch table entry for disable(bool)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = !!msg.data[0x04:0x24];\n                disable(var2);\n                stop();\n            } else if (var0 == 0xb0f545ba) {\n                // Dispatch table entry for debugger()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0167;\n                var2 = debugger();\n                goto label_0167;\n            } else if (var0 == 0xb8b34132) {\n                // Dispatch table entry for 0xb8b34132 (unknown)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                func_0511();\n                stop();\n            } else if (var0 == 0xd0e30db0) { goto label_00C4; }\n                // Dispatch table entry for deposit()\n            else if (var0 == 0xee070805) {\n                // Dispatch table entry for disabled()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x01a4;\n                var2 = disabled();\n                goto label_01A4;\n            } else if (var0 == 0xeef21cd2) {\n                // Dispatch table entry for removeCaller(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                removeCaller(var2);\n                stop();\n            } else if (var0 == 0xf359e65f) {\n                // Dispatch table entry for 0xf359e65f (unknown)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00cc;\n                var temp5 = msg.data[0x04:0x24];\n                var2 = temp5 + 0x24;\n                var3 = msg.data[temp5 + 0x04:temp5 + 0x04 + 0x20];\n                var temp6 = msg.data[0x24:0x44];\n                var var4 = temp6 + 0x24;\n                var var5 = msg.data[temp6 + 0x04:temp6 + 0x04 + 0x20];\n                func_05D1(var2, var3, var4, var5);\n                stop();\n            } else { goto label_00C4; }\n        }\n    }\n    \n    function func_025E() {\n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = msg.value;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + temp0 - temp1 + 0x20], [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, msg.sender]);\n    }\n    \n    function func_0296(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        storage[temp1] = (storage[temp1] & ~0xff) | 0x01;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = temp0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [0x735c128e3c049ff88e71ee4712b6e7096d53089462c09dd6b3c310f68ea44f8a]);\n    }\n    \n    function withdrawTo(var arg0, var arg1) {\n        if (storage[0x00] / 0x010000000000000000000000000000000000000000 & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x0357;\n        var var1 = 0x456d517565756500000000000000000000000000000000000000000000000000;\n        var0 = func_0731(var1);\n    \n        if (msg.sender != var0 & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = memory[0x40:0x60];\n        var temp1 = arg1;\n        var temp2;\n        temp2, memory[temp0:temp0 + 0x00] = address(arg0 & 0x02 ** 0xa0 - 0x01).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);\n        var0 = !temp2;\n    \n        if (!var0) {\n            var temp3 = memory[0x40:0x60];\n            memory[temp3:temp3 + 0x20] = arg1;\n            var temp4 = memory[0x40:0x60];\n            log(memory[temp4:temp4 + temp3 - temp4 + 0x20], [0x884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a9424364, stack[-3] & 0x02 ** 0xa0 - 0x01]);\n            return;\n        } else {\n            var temp5 = returndata.length;\n            memory[0x00:0x00 + temp5] = returndata[0x00:0x00 + temp5];\n            revert(memory[0x00:0x00 + returndata.length]);\n        }\n    }\n    \n    function withdraw(var arg0) {\n        var var0 = 0x03ef;\n        var var1 = msg.sender;\n        var var2 = arg0;\n        withdrawTo(var1, var2);\n    }\n    \n    function calledUpdate(var arg0, var arg1) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x02] & temp0 != temp0 & arg0) { return; }\n    \n        var temp1 = 0x02 ** 0xa0 - 0x01;\n        var temp2 = temp1 & arg1;\n        storage[0x02] = temp2 | (storage[0x02] & ~0xffffffffffffffffffffffffffffffffffffffff);\n        var temp3 = memory[0x40:0x60];\n        memory[temp3:temp3 + 0x20] = arg0 & temp1;\n        memory[temp3 + 0x20:temp3 + 0x20 + 0x20] = temp2;\n        var temp4 = memory[0x40:0x60];\n        log(memory[temp4:temp4 + temp3 - temp4 + 0x40], [0x1229c7500af0aab73d8c1cc0ea6c7d65249ebf050e292ce3bdf096fddec699a9]);\n    }\n    \n    function data() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function callers(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])] & 0xff;\n    }\n    \n    function disable(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        storage[0x00] = (storage[0x00] & ~0xff0000000000000000000000000000000000000000) | !!arg0 * 0x010000000000000000000000000000000000000000;\n    }\n    \n    function debugger() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function func_0511() {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        storage[0x00] = storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff;\n    }\n    \n    function disabled() returns (var r0) { return storage[0x00] / 0x010000000000000000000000000000000000000000 & 0xff; }\n    \n    function removeCaller(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        storage[temp1] = storage[temp1] & ~0xff;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = temp0;\n        var temp3 = memory[0x40:0x60];\n        log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [0x3227fe2c42ad401fbb958a2a3205bb30289aa16ca66612b693cad680206b30e8]);\n    }\n    \n    function func_05D1(var arg0, var arg1, var arg2, var arg3) {\n        var var0 = 0x00;\n    \n        if (msg.sender != storage[var0] & 0x02 ** 0xa0 - 0x01) { assert(); }\n    \n        var0 = 0x00;\n    \n        if (var0 >= arg1) {\n        label_0684:\n            var0 = 0x00;\n        \n            if (var0 >= arg3) {\n            label_072A:\n                return;\n            } else {\n            label_0691:\n                var var1 = 0x01;\n                var var2 = var1;\n                var var3 = 0x00;\n                var var4 = arg2;\n                var var5 = arg3;\n                var var6 = var0;\n            \n                if (var6 >= var5) { assert(); }\n            \n                var temp0 = var3;\n                memory[temp0:temp0 + 0x20] = msg.data[var6 * 0x20 + var4:var6 * 0x20 + var4 + 0x20] & 0x02 ** 0xa0 - 0x01;\n                memory[temp0 + 0x20:temp0 + 0x20 + 0x20] = var2;\n                var temp1 = keccak256(memory[0x00:0x00 + temp0 + 0x40]);\n                storage[temp1] = !!var1 | (storage[temp1] & ~0xff);\n                var1 = 0x735c128e3c049ff88e71ee4712b6e7096d53089462c09dd6b3c310f68ea44f8a;\n                var2 = arg2;\n                var3 = arg3;\n                var4 = var0;\n            \n                if (var4 >= var3) { assert(); }\n            \n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = msg.data[var4 * 0x20 + var2:var4 * 0x20 + var2 + 0x20] & 0x02 ** 0xa0 - 0x01;\n                var temp3 = memory[0x40:0x60];\n                log(memory[temp3:temp3 + temp2 - temp3 + 0x20], [stack[-4]]);\n                var0 = var0 + 0x01;\n            \n                if (var0 >= arg3) { goto label_072A; }\n                else { goto label_0691; }\n            }\n        } else {\n        label_05F3:\n            var1 = 0x01;\n            var2 = 0x00;\n            var3 = arg0;\n            var4 = arg1;\n            var5 = var0;\n        \n            if (var5 >= var4) { assert(); }\n        \n            var temp4 = var2;\n            memory[temp4:temp4 + 0x20] = msg.data[var5 * 0x20 + var3:var5 * 0x20 + var3 + 0x20] & 0x02 ** 0xa0 - 0x01;\n            memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var1;\n            var temp5 = keccak256(memory[0x00:0x00 + temp4 + 0x40]);\n            storage[temp5] = storage[temp5] & ~0xff;\n            var1 = 0x3227fe2c42ad401fbb958a2a3205bb30289aa16ca66612b693cad680206b30e8;\n            var2 = arg0;\n            var3 = arg1;\n            var4 = var0;\n        \n            if (var4 >= var3) { assert(); }\n        \n            var temp6 = memory[0x40:0x60];\n            memory[temp6:temp6 + 0x20] = msg.data[var4 * 0x20 + var2:var4 * 0x20 + var2 + 0x20] & 0x02 ** 0xa0 - 0x01;\n            var temp7 = memory[0x40:0x60];\n            log(memory[temp7:temp7 + temp6 - temp7 + 0x20], [stack[-4]]);\n            var0 = var0 + 0x01;\n        \n            if (var0 >= arg1) { goto label_0684; }\n            else { goto label_05F3; }\n        }\n    }\n    \n    function func_0731(var arg0) returns (var r0) {\n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = 0x0f75243000000000000000000000000000000000000000000000000000000000;\n        memory[temp0 + 0x04:temp0 + 0x04 + 0x20] = arg0;\n        var var0 = 0x00;\n        var var1 = storage[0x02] & 0x02 ** 0xa0 - 0x01;\n        var var2 = 0x0f752430;\n        var var3 = temp0 + 0x24;\n        var var4 = 0x20;\n        var var5 = memory[0x40:0x60];\n        var var6 = temp0 - var5 + 0x24;\n        var var7 = var5;\n        var var8 = var0;\n        var var9 = var1;\n        var var10 = !address(var9).code.length;\n    \n        if (var10) { revert(memory[0x00:0x00]); }\n    \n        var temp1;\n        temp1, memory[var5:var5 + var4] = address(var9).call.gas(msg.gas).value(var8)(memory[var7:var7 + var6]);\n        var4 = !temp1;\n    \n        if (!var4) {\n            var1 = memory[0x40:0x60];\n            var2 = returndata.length;\n        \n            if (var2 >= 0x20) { return memory[var1:var1 + 0x20]; }\n            else { revert(memory[0x00:0x00]); }\n        } else {\n            var temp2 = returndata.length;\n            memory[0x00:0x00 + temp2] = returndata[0x00:0x00 + temp2];\n            revert(memory[0x00:0x00 + returndata.length]);\n        }\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 21.37340211868286,
	"usage": {
		"completion_tokens": 468,
		"prompt_tokens": 4888,
		"total_tokens": 5356
	}
}