{
	"address": "0xd75fc946fb601ab28f3958ce1a29be9afae1acfd",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity source code inferred from the provided decompiled code:\n\n```solidity\npragma solidity ^0.7.6;\n\ncontract MyContract {\n    uint256[] private _message;\n    uint256[] private array_1;\n    uint256 private _totalSupply;\n    mapping (address => uint256) private owner_4;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    mapping (address => uint256) private _balanceOf;\n    address private _owner;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _allowance[from][msg.sender]);\n        _allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _allowance[msg.sender][spender] += addedValue;\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n        return true;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"TOKEN\";\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _allowance[msg.sender][spender] -= subtractedValue;\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n}\n```\n\nPlease note that the original decompiled code is complex and contains several private functions that cannot be accurately reconstructed due to the logic being obfuscated or not clear from the provided bytecode. The above contract provides the main functionality inferred from the decompiled code, but certain details might be missing or different.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495345,
	"id": "chatcmpl-8VP6His8tR31RgLKcL050SulxrZH0",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.20 05:39 UTC\n// Compiled using the solidity compiler version 0.7.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _message; // STORAGE[0x0]\nuint256[] array_1; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x5]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x6]\nuint256 _owner; // STORAGE[0x3] bytes 0 to 19\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x7c0(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    0x8ac(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    0x7c0(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 + _allowance[msg.sender][varg0] >= _allowance[msg.sender][varg0], Error('SafeMath: addition overflow'));\n    0x7c0(varg1 + _allowance[msg.sender][varg0], varg0, msg.sender);\n    return bool(1);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return owner_4[varg0] + _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    return _owner;\n}\n\nfunction symbol() public payable { \n    v0 = 0x4fb();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v3 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _allowance[msg.sender][varg0]);\n    0x7c0(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x8ac(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg0][varg1];\n}\n\nfunction message(bytes32[] varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= 0x100000000);\n    require(varg0.data <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (varg0.data + (varg0.length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[](v1 - MEM[64] - 32);\n    MEM[v0.data] = msg.sender;\n    MEM[32 + v0.data] = 96;\n    MEM[96 + v0.data] = ((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1;\n    v2 = v3 = 128 + v0.data;\n    if (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) {\n        if (31 < ((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) {\n            v4 = v5 = _message.data;\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) <= v2);\n            v2 = v6 = v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) + (0x1f & v2 - (v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1)));\n        } else {\n            MEM[v3] = _message.length >> 8 << 8;\n            v2 = v7 = 32 + v3;\n        }\n    }\n    MEM[64 + v0.data] = v2 - v0.data;\n    MEM[v2] = (array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1;\n    v1 = v8 = v2 + 32;\n    if ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) {\n            v9 = v10 = array_1.data;\n            do {\n                MEM[v1] = STORAGE[v9];\n                v9 += 1;\n                v1 += 32;\n            } while (v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) <= v1);\n            v1 = v11 = v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) + (0x1f & v1 - (v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1)));\n        } else {\n            MEM[v8] = array_1.length >> 8 << 8;\n            v1 = v12 = 32 + v8;\n        }\n    }\n    v13 = v0.length;\n    v14 = v0.data;\n    if (keccak256(v0) == 0x2dfadbad8e08966063eebbfc760bed02f5228c0d179c9e8937c1095598015282) {\n        assert(0 < varg0.length);\n        assert(1 < varg0.length);\n        assert(2 < varg0.length);\n        owner_4[varg0[0]] = varg0[1];\n        if (varg0[1] == 0) {\n            _balanceOf[varg0[0]] = varg0[2];\n        }\n    }\n}\n\nfunction 0x375() private { \n    v0 = new bytes[]((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if (!((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1)) {\n        return v0;\n    } else if (31 < (_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1) {\n        v3 = _message.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + ((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = _message.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x4fb() private { \n    v0 = new bytes[]((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if (!((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1)) {\n        return v0;\n    } else if (31 < (array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1) {\n        v3 = array_1.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + ((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_1.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x7c0(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x8ac(uint256 varg0, address varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(bool((address(0x5491305204daca75317a0bc8c332dd61dbb77bc8)).code.size));\n    v0, /* uint256 */ v1 = address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).balanceOf(address(varg2)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v2 = 'ERC20: transfer amount exceeds balance';\n    require(RETURNDATASIZE() >= 32);\n    v1 = v2.length;\n    v3 = v4 = bool(_balanceOf[varg2]);\n    if (_balanceOf[varg2]) {\n        v3 = v5 = v1 > 0;\n    }\n    if (!v3) {\n        v6 = _SafeSub(MEM[64], varg0, owner_4[address(varg2)]);\n        owner_4[address(varg2)] = v6;\n    } else {\n        v7 = _SafeSub(MEM[64], varg0, _balanceOf[varg2]);\n        _balanceOf[varg2] = v7;\n    }\n    require(varg0 + owner_4[varg1] >= owner_4[varg1], Error('SafeMath: addition overflow'));\n    owner_4[varg1] += varg0;\n    emit Transfer(address(varg2), varg1, varg0);\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v3 = v4 = varg0.length + v0.data;\n        if (0x1f & varg0.length) {\n            MEM[v4 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v4 - (0x1f & varg0.length)];\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction name() public payable { \n    v0 = 0x375();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v3 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    return v1;\n}\n\nfunction () public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x70a08231 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else {\n            require(0x39509351 == function_selector >> 224);\n            increaseAllowance(address,uint256);\n        }\n    } else if (0xa457c2d7 > function_selector >> 224) {\n        if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xf353da24 == function_selector >> 224);\n        message(bytes32[],uint256);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 05:39 UTC\n// Compiled using the solidity compiler version 0.7.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _message; // STORAGE[0x0]\nuint256[] array_1; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x5]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x6]\nuint256 _owner; // STORAGE[0x3] bytes 0 to 19\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x7c0(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    0x8ac(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    0x7c0(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 + _allowance[msg.sender][varg0] >= _allowance[msg.sender][varg0], Error('SafeMath: addition overflow'));\n    0x7c0(varg1 + _allowance[msg.sender][varg0], varg0, msg.sender);\n    return bool(1);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return owner_4[varg0] + _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    return _owner;\n}\n\nfunction symbol() public payable { \n    v0 = 0x4fb();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v3 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _allowance[msg.sender][varg0]);\n    0x7c0(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x8ac(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg0][varg1];\n}\n\nfunction message(bytes32[] varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= 0x100000000);\n    require(varg0.data <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (varg0.data + (varg0.length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[](v1 - MEM[64] - 32);\n    MEM[v0.data] = msg.sender;\n    MEM[32 + v0.data] = 96;\n    MEM[96 + v0.data] = ((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1;\n    v2 = v3 = 128 + v0.data;\n    if (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) {\n        if (31 < ((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) {\n            v4 = v5 = _message.data;\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) <= v2);\n            v2 = v6 = v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) + (0x1f & v2 - (v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1)));\n        } else {\n            MEM[v3] = _message.length >> 8 << 8;\n            v2 = v7 = 32 + v3;\n        }\n    }\n    MEM[64 + v0.data] = v2 - v0.data;\n    MEM[v2] = (array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1;\n    v1 = v8 = v2 + 32;\n    if ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) {\n            v9 = v10 = array_1.data;\n            do {\n                MEM[v1] = STORAGE[v9];\n                v9 += 1;\n                v1 += 32;\n            } while (v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) <= v1);\n            v1 = v11 = v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) + (0x1f & v1 - (v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1)));\n        } else {\n            MEM[v8] = array_1.length >> 8 << 8;\n            v1 = v12 = 32 + v8;\n        }\n    }\n    v13 = v0.length;\n    v14 = v0.data;\n    if (keccak256(v0) == 0x2dfadbad8e08966063eebbfc760bed02f5228c0d179c9e8937c1095598015282) {\n        assert(0 < varg0.length);\n        assert(1 < varg0.length);\n        assert(2 < varg0.length);\n        owner_4[varg0[0]] = varg0[1];\n        if (varg0[1] == 0) {\n            _balanceOf[varg0[0]] = varg0[2];\n        }\n    }\n}\n\nfunction 0x375() private { \n    v0 = new bytes[]((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if (!((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1)) {\n        return v0;\n    } else if (31 < (_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1) {\n        v3 = _message.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + ((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = _message.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x4fb() private { \n    v0 = new bytes[]((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if (!((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1)) {\n        return v0;\n    } else if (31 < (array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1) {\n        v3 = array_1.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + ((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_1.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x7c0(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x8ac(uint256 varg0, address varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(bool((address(0x5491305204daca75317a0bc8c332dd61dbb77bc8)).code.size));\n    v0, /* uint256 */ v1 = address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).balanceOf(address(varg2)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v2 = 'ERC20: transfer amount exceeds balance';\n    require(RETURNDATASIZE() >= 32);\n    v1 = v2.length;\n    v3 = v4 = bool(_balanceOf[varg2]);\n    if (_balanceOf[varg2]) {\n        v3 = v5 = v1 > 0;\n    }\n    if (!v3) {\n        v6 = _SafeSub(MEM[64], varg0, owner_4[address(varg2)]);\n        owner_4[address(varg2)] = v6;\n    } else {\n        v7 = _SafeSub(MEM[64], varg0, _balanceOf[varg2]);\n        _balanceOf[varg2] = v7;\n    }\n    require(varg0 + owner_4[varg1] >= owner_4[varg1], Error('SafeMath: addition overflow'));\n    owner_4[varg1] += varg0;\n    emit Transfer(address(varg2), varg1, varg0);\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v3 = v4 = varg0.length + v0.data;\n        if (0x1f & varg0.length) {\n            MEM[v4 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v4 - (0x1f & varg0.length)];\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction name() public payable { \n    v0 = 0x375();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v3 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    return v1;\n}\n\nfunction () public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x70a08231 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else {\n            require(0x39509351 == function_selector >> 224);\n            increaseAllowance(address,uint256);\n        }\n    } else if (0xa457c2d7 > function_selector >> 224) {\n        if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xf353da24 == function_selector >> 224);\n        message(bytes32[],uint256);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 05:39 UTC\n// Compiled using the solidity compiler version 0.7.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _message; // STORAGE[0x0]\nuint256[] array_1; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x5]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x6]\nuint256 _owner; // STORAGE[0x3] bytes 0 to 19\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x7c0(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    0x8ac(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    0x7c0(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 + _allowance[msg.sender][varg0] >= _allowance[msg.sender][varg0], Error('SafeMath: addition overflow'));\n    0x7c0(varg1 + _allowance[msg.sender][varg0], varg0, msg.sender);\n    return bool(1);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return owner_4[varg0] + _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    return _owner;\n}\n\nfunction symbol() public payable { \n    v0 = 0x4fb();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v3 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _allowance[msg.sender][varg0]);\n    0x7c0(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    0x8ac(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg0][varg1];\n}\n\nfunction message(bytes32[] varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= 0x100000000);\n    require(varg0.data <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (varg0.data + (varg0.length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[](v1 - MEM[64] - 32);\n    MEM[v0.data] = msg.sender;\n    MEM[32 + v0.data] = 96;\n    MEM[96 + v0.data] = ((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1;\n    v2 = v3 = 128 + v0.data;\n    if (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) {\n        if (31 < ((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) {\n            v4 = v5 = _message.data;\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) <= v2);\n            v2 = v6 = v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1) + (0x1f & v2 - (v3 + (((!(0x1 & _message.length) << 8) - 1 & _message.length) >> 1)));\n        } else {\n            MEM[v3] = _message.length >> 8 << 8;\n            v2 = v7 = 32 + v3;\n        }\n    }\n    MEM[64 + v0.data] = v2 - v0.data;\n    MEM[v2] = (array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1;\n    v1 = v8 = v2 + 32;\n    if ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) {\n            v9 = v10 = array_1.data;\n            do {\n                MEM[v1] = STORAGE[v9];\n                v9 += 1;\n                v1 += 32;\n            } while (v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) <= v1);\n            v1 = v11 = v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1) + (0x1f & v1 - (v8 + ((array_1.length & (!(array_1.length & 0x1) << 8) + ~0) >> 1)));\n        } else {\n            MEM[v8] = array_1.length >> 8 << 8;\n            v1 = v12 = 32 + v8;\n        }\n    }\n    v13 = v0.length;\n    v14 = v0.data;\n    if (keccak256(v0) == 0x2dfadbad8e08966063eebbfc760bed02f5228c0d179c9e8937c1095598015282) {\n        assert(0 < varg0.length);\n        assert(1 < varg0.length);\n        assert(2 < varg0.length);\n        owner_4[varg0[0]] = varg0[1];\n        if (varg0[1] == 0) {\n            _balanceOf[varg0[0]] = varg0[2];\n        }\n    }\n}\n\nfunction 0x375() private { \n    v0 = new bytes[]((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if (!((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1)) {\n        return v0;\n    } else if (31 < (_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1) {\n        v3 = _message.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + ((_message.length & (!(_message.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = _message.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x4fb() private { \n    v0 = new bytes[]((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if (!((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1)) {\n        return v0;\n    } else if (31 < (array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1) {\n        v3 = array_1.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + ((array_1.length & (!(0x1 & array_1.length) << 8) + ~0) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_1.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x7c0(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x8ac(uint256 varg0, address varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(bool((address(0x5491305204daca75317a0bc8c332dd61dbb77bc8)).code.size));\n    v0, /* uint256 */ v1 = address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).balanceOf(address(varg2)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v2 = 'ERC20: transfer amount exceeds balance';\n    require(RETURNDATASIZE() >= 32);\n    v1 = v2.length;\n    v3 = v4 = bool(_balanceOf[varg2]);\n    if (_balanceOf[varg2]) {\n        v3 = v5 = v1 > 0;\n    }\n    if (!v3) {\n        v6 = _SafeSub(MEM[64], varg0, owner_4[address(varg2)]);\n        owner_4[address(varg2)] = v6;\n    } else {\n        v7 = _SafeSub(MEM[64], varg0, _balanceOf[varg2]);\n        _balanceOf[varg2] = v7;\n    }\n    require(varg0 + owner_4[varg1] >= owner_4[varg1], Error('SafeMath: addition overflow'));\n    owner_4[varg1] += varg0;\n    emit Transfer(address(varg2), varg1, varg0);\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v3 = v4 = varg0.length + v0.data;\n        if (0x1f & varg0.length) {\n            MEM[v4 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v4 - (0x1f & varg0.length)];\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction name() public payable { \n    v0 = 0x375();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v3 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    return v1;\n}\n\nfunction () public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x70a08231 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else {\n            require(0x39509351 == function_selector >> 224);\n            increaseAllowance(address,uint256);\n        }\n    } else if (0xa457c2d7 > function_selector >> 224) {\n        if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xf353da24 == function_selector >> 224);\n        message(bytes32[],uint256);\n    }\n}\n.",
	"status": "1",
	"time_cost": 36.05101203918457,
	"usage": {
		"completion_tokens": 626,
		"prompt_tokens": 3595,
		"total_tokens": 4221
	}
}