{
	"address": "0xe0b7927c4af23765cb51314a0e0521a9645f0e2a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the equivalent Solidity contract:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenContract {\n\n    address public owner;\n    uint8 public locked;\n    address public configAddress;\n    address public daoAddress;\n    address public unknown4230bb10Address;\n    uint256 public totalSupply;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    mapping (address => uint8) public isSeller;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    modifier onlyDAO() {\n        require(msg.sender == daoAddress, \"Caller is not DAO\");\n        _;\n    }\n\n    function registerSeller(address seller) public onlyDAO returns (bool) {\n        isSeller[seller] = 1;\n        return true;\n    }\n\n    function removeSeller(address seller) public onlyDAO returns (bool) {\n        isSeller[seller] = 0;\n        return true;\n    }\n\n    function setDao(address dao_) public onlyDAO returns (bool) {\n        daoAddress = dao_;\n        return true;\n    }\n\n    function lockContract(uint8 lock) public onlyOwner returns (bool) {\n        locked = lock;\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function mint(address _to, uint256 _amount) public onlyDAO returns(bool) {\n        totalSupply += _amount;\n        balanceOf[_to] += _amount;\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(balanceOf[msg.sender] >= amount, \"Insufficient balance for transfer\");\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(balanceOf[sender] >= amount, \"Insufficient balance for transfer\");\n        require(allowance[sender][msg.sender] >= amount, \"Insufficient allowance for transfer\");\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        allowance[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n}\n```\n\nPlease note that the contracts interacting with `unknown4230bb10Address` in the decompiled code are not included. The actual function of this address is not clear from the given decompiled code, and it seems to be another contract. We would need more information about this contract to write the corresponding Solidity code. Also, the functions `safeToSubtract`, `safeToAdd`, `subtractSafely`, `addSafely` in the decompiled code are not included because they are not needed in Solidity 0.8.0 and later as it has built-in overflow and underflow protection.",
				"role": "assistant"
			}
		}
	],
	"created": 1700473467,
	"id": "chatcmpl-8Mv7LGMdwdFjG5fuXf45P7lAbIPqM",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor0 is uint256 at storage 0\n  locked is uint8 at storage 1 offset 160\n  configAddress is address at storage 1\n  daoAddress is address at storage 2\n  stor2 is uint256 at storage 2\n  unknown4230bb10Address is address at storage 3\n  totalSupply is uint256 at storage 4\n  balanceOf is mapping of uint256 at storage 5\n  allowance is mapping of uint256 at storage 6\n  isSeller is mapping of uint8 at storage 7\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef dao() payable: \n  return address(daoAddress)\n\ndef unknown4230bb10() payable: \n  return unknown4230bb10Address\n\ndef balanceOf(address account) payable: \n  return balanceOf[address(account)]\n\ndef config() payable: \n  return configAddress\n\ndef owner() payable: \n  return address(owner)\n\ndef locked() payable: \n  return locked\n\ndef allowance(address owner, address spender) payable: \n  return allowance[address(owner)][address(spender)]\n\ndef isSeller(address a) payable: \n  return isSeller[address(a)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef safeToSubtract(uint256 a, uint256 b) payable: \n  return b <= a\n\ndef safeToAdd(uint256 a, uint256 b) payable: \n  return b + a >= a\n\ndef subtractSafely(uint256 a, uint256 b) payable: \n  require b <= a\n  return (a - b)\n\ndef addSafely(uint256 a, uint256 b) payable: \n  require b + a >= a\n  return (b + a)\n\ndef registerSeller(address seller) payable: \n  require caller == address(daoAddress)\n  isSeller[address(seller)] = 1\n  return 1\n\ndef unknownac900c2d(address _param1) payable: \n  require caller == address(daoAddress)\n  isSeller[address(_param1)] = 0\n  return 1\n\ndef setDao(address dao_) payable: \n  require caller == address(daoAddress)\n  uint256(stor2) = dao_ or Mask(96, 160, uint256(stor2))\n  return 1\n\ndef unknown2b297f9e(uint256 _param1) payable: \n  require caller == address(owner)\n  if locked == 1:\n      return 0\n  uint256(stor2) = _param1 or Mask(96, 160, uint256(stor2))\n  locked = 1\n  return 1\n\ndef approve(address spender, uint256 amount) payable: \n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef unknowne42bff66(address _param1, uint256 _param2) payable: \n  require isSeller[caller]\n  call unknown4230bb10Address.mint(address _to, uint256 _amount) with:\n       gas gas_remaining - 25050 wei\n      args address(_param1), _param2\n  require ext_call.success\n  if ext_call.return_data[0]:\n      return 1\n  else:\n      return 0\n\ndef setOwner(address _newOwner) payable: \n  require caller == address(daoAddress)\n  call unknown4230bb10Address.setOwner(address _newOwner) with:\n       gas gas_remaining - 25050 wei\n      args _newOwner\n  require ext_call.success\n  if not ext_call.return_data[0]:\n      return 0\n  uint256(stor0) = _newOwner or Mask(96, 160, uint256(stor0))\n  return 1\n\ndef mint(address _to, uint256 _amount) payable: \n  require isSeller[caller]\n  require totalSupply + _amount >= _amount\n  totalSupply += _amount\n  require _amount + balanceOf[address(_to)] >= balanceOf[address(_to)]\n  balanceOf[address(_to)] += _amount\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  if balanceOf[caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  if balanceOf[address(sender)] < amount:\n      return 0\n  if allowance[address(sender)][caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount + balanceOf[address(recipient)] >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  require amount <= balanceOf[sender]\n  balanceOf[address(sender)] = balanceOf[sender] - amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor0 is uint256 at storage 0\n  locked is uint8 at storage 1 offset 160\n  configAddress is address at storage 1\n  daoAddress is address at storage 2\n  stor2 is uint256 at storage 2\n  unknown4230bb10Address is address at storage 3\n  totalSupply is uint256 at storage 4\n  balanceOf is mapping of uint256 at storage 5\n  allowance is mapping of uint256 at storage 6\n  isSeller is mapping of uint8 at storage 7\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef dao() payable: \n  return address(daoAddress)\n\ndef unknown4230bb10() payable: \n  return unknown4230bb10Address\n\ndef balanceOf(address account) payable: \n  return balanceOf[address(account)]\n\ndef config() payable: \n  return configAddress\n\ndef owner() payable: \n  return address(owner)\n\ndef locked() payable: \n  return locked\n\ndef allowance(address owner, address spender) payable: \n  return allowance[address(owner)][address(spender)]\n\ndef isSeller(address a) payable: \n  return isSeller[address(a)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef safeToSubtract(uint256 a, uint256 b) payable: \n  return b <= a\n\ndef safeToAdd(uint256 a, uint256 b) payable: \n  return b + a >= a\n\ndef subtractSafely(uint256 a, uint256 b) payable: \n  require b <= a\n  return (a - b)\n\ndef addSafely(uint256 a, uint256 b) payable: \n  require b + a >= a\n  return (b + a)\n\ndef registerSeller(address seller) payable: \n  require caller == address(daoAddress)\n  isSeller[address(seller)] = 1\n  return 1\n\ndef unknownac900c2d(address _param1) payable: \n  require caller == address(daoAddress)\n  isSeller[address(_param1)] = 0\n  return 1\n\ndef setDao(address dao_) payable: \n  require caller == address(daoAddress)\n  uint256(stor2) = dao_ or Mask(96, 160, uint256(stor2))\n  return 1\n\ndef unknown2b297f9e(uint256 _param1) payable: \n  require caller == address(owner)\n  if locked == 1:\n      return 0\n  uint256(stor2) = _param1 or Mask(96, 160, uint256(stor2))\n  locked = 1\n  return 1\n\ndef approve(address spender, uint256 amount) payable: \n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef unknowne42bff66(address _param1, uint256 _param2) payable: \n  require isSeller[caller]\n  call unknown4230bb10Address.mint(address _to, uint256 _amount) with:\n       gas gas_remaining - 25050 wei\n      args address(_param1), _param2\n  require ext_call.success\n  if ext_call.return_data[0]:\n      return 1\n  else:\n      return 0\n\ndef setOwner(address _newOwner) payable: \n  require caller == address(daoAddress)\n  call unknown4230bb10Address.setOwner(address _newOwner) with:\n       gas gas_remaining - 25050 wei\n      args _newOwner\n  require ext_call.success\n  if not ext_call.return_data[0]:\n      return 0\n  uint256(stor0) = _newOwner or Mask(96, 160, uint256(stor0))\n  return 1\n\ndef mint(address _to, uint256 _amount) payable: \n  require isSeller[caller]\n  require totalSupply + _amount >= _amount\n  totalSupply += _amount\n  require _amount + balanceOf[address(_to)] >= balanceOf[address(_to)]\n  balanceOf[address(_to)] += _amount\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  if balanceOf[caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  if balanceOf[address(sender)] < amount:\n      return 0\n  if allowance[address(sender)][caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount + balanceOf[address(recipient)] >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  require amount <= balanceOf[sender]\n  balanceOf[address(sender)] = balanceOf[sender] - amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor0 is uint256 at storage 0\n  locked is uint8 at storage 1 offset 160\n  configAddress is address at storage 1\n  daoAddress is address at storage 2\n  stor2 is uint256 at storage 2\n  unknown4230bb10Address is address at storage 3\n  totalSupply is uint256 at storage 4\n  balanceOf is mapping of uint256 at storage 5\n  allowance is mapping of uint256 at storage 6\n  isSeller is mapping of uint8 at storage 7\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef dao() payable: \n  return address(daoAddress)\n\ndef unknown4230bb10() payable: \n  return unknown4230bb10Address\n\ndef balanceOf(address account) payable: \n  return balanceOf[address(account)]\n\ndef config() payable: \n  return configAddress\n\ndef owner() payable: \n  return address(owner)\n\ndef locked() payable: \n  return locked\n\ndef allowance(address owner, address spender) payable: \n  return allowance[address(owner)][address(spender)]\n\ndef isSeller(address a) payable: \n  return isSeller[address(a)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef safeToSubtract(uint256 a, uint256 b) payable: \n  return b <= a\n\ndef safeToAdd(uint256 a, uint256 b) payable: \n  return b + a >= a\n\ndef subtractSafely(uint256 a, uint256 b) payable: \n  require b <= a\n  return (a - b)\n\ndef addSafely(uint256 a, uint256 b) payable: \n  require b + a >= a\n  return (b + a)\n\ndef registerSeller(address seller) payable: \n  require caller == address(daoAddress)\n  isSeller[address(seller)] = 1\n  return 1\n\ndef unknownac900c2d(address _param1) payable: \n  require caller == address(daoAddress)\n  isSeller[address(_param1)] = 0\n  return 1\n\ndef setDao(address dao_) payable: \n  require caller == address(daoAddress)\n  uint256(stor2) = dao_ or Mask(96, 160, uint256(stor2))\n  return 1\n\ndef unknown2b297f9e(uint256 _param1) payable: \n  require caller == address(owner)\n  if locked == 1:\n      return 0\n  uint256(stor2) = _param1 or Mask(96, 160, uint256(stor2))\n  locked = 1\n  return 1\n\ndef approve(address spender, uint256 amount) payable: \n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef unknowne42bff66(address _param1, uint256 _param2) payable: \n  require isSeller[caller]\n  call unknown4230bb10Address.mint(address _to, uint256 _amount) with:\n       gas gas_remaining - 25050 wei\n      args address(_param1), _param2\n  require ext_call.success\n  if ext_call.return_data[0]:\n      return 1\n  else:\n      return 0\n\ndef setOwner(address _newOwner) payable: \n  require caller == address(daoAddress)\n  call unknown4230bb10Address.setOwner(address _newOwner) with:\n       gas gas_remaining - 25050 wei\n      args _newOwner\n  require ext_call.success\n  if not ext_call.return_data[0]:\n      return 0\n  uint256(stor0) = _newOwner or Mask(96, 160, uint256(stor0))\n  return 1\n\ndef mint(address _to, uint256 _amount) payable: \n  require isSeller[caller]\n  require totalSupply + _amount >= _amount\n  totalSupply += _amount\n  require _amount + balanceOf[address(_to)] >= balanceOf[address(_to)]\n  balanceOf[address(_to)] += _amount\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  if balanceOf[caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  if balanceOf[address(sender)] < amount:\n      return 0\n  if allowance[address(sender)][caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount + balanceOf[address(recipient)] >= balanceOf[address(recipient)]\n  balanceOf[address(recipient)] += amount\n  require amount <= balanceOf[sender]\n  balanceOf[address(sender)] = balanceOf[sender] - amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\n.",
	"status": "1",
	"time_cost": 37.29624009132385,
	"usage": {
		"completion_tokens": 680,
		"prompt_tokens": 1257,
		"total_tokens": 1937
	}
}