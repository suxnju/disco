{
	"address": "0x06d5697043f8e611807b221e74f08a28bb4e6e13",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the decompiled EVM bytecode, the Solidity code may look something like this. Please note that decompiling EVM bytecode back into high-level Solidity code is not a straightforward process and may result in several inaccuracies.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 public totalSupply = 10000 * (uint256(10) ** decimals);\n    string public name = \"MyToken\";\n    string public symbol = \"MTK\";\n    uint8 public decimals = 18;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= value);\n        balanceOf[msg.sender] -= value;  \n        balanceOf[to] += value;           \n        emit Transfer(msg.sender, to, value); \n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(value <= balanceOf[from]);\n        require(value <= allowance[from][msg.sender]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n}\n```\nThis code creates a basic ERC20 token. The total supply is set to 10,000 tokens with 18 decimal places, and all tokens are initially assigned to the contract creator. The contract also includes functions to transfer tokens, approve a spender, and transfer tokens from a spender.",
				"role": "assistant"
			}
		}
	],
	"created": 1702473385,
	"id": "chatcmpl-8VJO5PLEZHIHf7dNiyXQHaJwAFv9j",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 08:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x4]\nuint256[] _name; // STORAGE[0x5]\nuint256 __totalSupply; // STORAGE[0x7]\nuint256 _startDate; // STORAGE[0x8]\nuint256 _bonusEnd20; // STORAGE[0x9]\nuint256 _bonusEnd10; // STORAGE[0xa]\nuint256 _bonusEnd05; // STORAGE[0xb]\nuint256 _endDate; // STORAGE[0xc]\nuint256 _tradingDate; // STORAGE[0xd]\nuint256 _exchangeRate; // STORAGE[0xe]\nuint256 _maxSupply; // STORAGE[0xf]\nuint256 _soldSupply; // STORAGE[0x10]\nuint256 _maxSellable; // STORAGE[0x11]\nuint256 _minAmountETH; // STORAGE[0x13]\nuint256 _maxAmountETH; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _circulatingSupply; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _depositsOf; // STORAGE[0x17]\nmapping (uint256 => [uint256]) _getAddressKYCState; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x19]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nmapping (uint256 => [uint256]) _burnedBalanceOf; // STORAGE[0x1a]\nuint256 stor_1c; // STORAGE[0x1c]\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\nuint8 stor_12_0_0; // STORAGE[0x12] bytes 0 to 0\nuint8 stor_1b_0_0; // STORAGE[0x1b] bytes 0 to 0\nuint8 _burnMyTokensAndSetAmountForNewBlockchain; // STORAGE[0x1b] bytes 1 to 1\nuint8 _versionIndex; // STORAGE[0x1d] bytes 0 to 0\naddress _ownerAPI; // STORAGE[0x2] bytes 0 to 19\naddress _newOwnerAPI; // STORAGE[0x3] bytes 0 to 19\nuint160 _currentRunningAddress; // STORAGE[0x15] bytes 0 to 19\nuint8 _paused; // STORAGE[0x3] bytes 20 to 20\nuint256 _totalSupply; // STORAGE[0x263c2b778d062355049effc2dece97bc6547ff8a88a3258daa512061c2153dd]\n\n// Events\nTransfer(address, address, uint256);\nOwnershipAPITransferred(address, address);\nApproval(address, address, uint256);\nOwnBlockchainLaunched(uint256);\nUnpause();\nOwnershipTransferred(address, address);\nPause();\nTokensBurned(address, uint256, uint256);\nMintingFinished(uint256);\n\nfunction 0x106e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (v0) {\n        v3 = 0xb90();\n    }\n    v4 = v5 = block.timestamp >= _tradingDate;\n    if (block.timestamp < _tradingDate) {\n        v6 = address(varg1);\n        v4 = v7 = 1 == 0xff & _getAddressKYCState[v6];\n    }\n    require(v4);\n    v8 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v9 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    require(varg0 <= _allowance[msg.sender]);\n    v10 = address(varg2);\n    _circulatingSupply[v10] = _allowance[msg.sender] - varg0;\n    v11 = address(varg1);\n    v12 = varg0 + _circulatingSupply[v11];\n    require(v12 >= _circulatingSupply[v11]);\n    v13 = address(varg1);\n    _circulatingSupply[v13] = v12;\n    emit Transfer(address(varg2), v13, varg0);\n    return 1;\n}\n\nfunction fallback() public payable { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (!v0) {\n        v3 = v4 = block.timestamp >= _startDate;\n        if (v4) {\n            v3 = v5 = block.timestamp <= _endDate;\n        }\n        if (v3) {\n            v3 = v6 = !stor_1b_0_0;\n        }\n        require(v3);\n        v7 = v8 = msg.value >= _minAmountETH;\n        if (v8) {\n            v7 = v9 = msg.value <= _maxAmountETH;\n        }\n        require(v7);\n        require(msg.value + _depositsOf[msg.sender] <= _maxAmountETH);\n        require(1 == 0xff & _getAddressKYCState[msg.sender]);\n        v10 = 0xc29(msg.value);\n        require(v10 + _soldSupply >= _soldSupply);\n        require(v10 + _soldSupply <= _maxSellable);\n        require(v10 + _soldSupply >= _soldSupply);\n        _soldSupply += v10;\n        require(v10 + __totalSupply >= __totalSupply);\n        __totalSupply += v10;\n        require(v10 + _circulatingSupply[msg.sender] >= _circulatingSupply[msg.sender]);\n        _circulatingSupply[msg.sender] += v10;\n        require(msg.value + _circulatingSupply[msg.sender] >= _circulatingSupply[msg.sender]);\n        _depositsOf[msg.sender] = msg.value + _circulatingSupply[msg.sender];\n        emit Transfer(0, msg.sender, v10);\n        v11 = _owner.call().value(msg.value * 15 / 100).gas(!(msg.value * 15 / 100) * 2300);\n        require(v11); // checks call status, propagates error data on error\n    } else {\n        v12 = 0xb90();\n        v13 = msg.sender.call().value(msg.value).gas(2300 * !msg.value);\n        require(v13); // checks call status, propagates error data on error\n    }\n}\n\nfunction acceptOwnershipAPI() public nonPayable { \n    require(msg.sender == _newOwnerAPI);\n    emit OwnershipAPITransferred(_ownerAPI, _newOwnerAPI);\n    _ownerAPI = _newOwnerAPI;\n    _newOwnerAPI = 0;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transferAnyERC20Token(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(varg0.code.size);\n    v3, v4 = varg0.balanceOf(this).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v5, v6 = varg0.transfer(_owner, v4).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v6;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction SetNewBlockchainEnabled() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = stor_1b_0_0;\n    if (v1) {\n        v0 = v2 = !_burnMyTokensAndSetAmountForNewBlockchain;\n    }\n    require(v0);\n    _burnMyTokensAndSetAmountForNewBlockchain = 1;\n    stor_1c = block.timestamp;\n    emit OwnBlockchainLaunched(block.timestamp);\n}\n\nfunction startDate() public nonPayable { \n    return _startDate;\n}\n\nfunction totalSupply() public nonPayable { \n    MEM[0] = 0;\n    MEM[32] = 22;\n    return __totalSupply - _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x106e(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction maxSellable() public nonPayable { \n    return _maxSellable;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction minAmountETH() public nonPayable { \n    return _minAmountETH;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction tradingDate() public nonPayable { \n    return _tradingDate;\n}\n\nfunction transferAPIOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwnerAPI = varg0;\n}\n\nfunction bonusEnd10() public nonPayable { \n    return _bonusEnd10;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction transferVestingMonthlyAmount(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    assert(24);\n    assert(30);\n    v0 = 15 * _maxSupply / 100 * (0xff & 100 - stor_12_0_0) / 100 * ((block.timestamp - _tradingDate) / 3600 / 24 / 30 + 1) / 24 - (15 * _maxSupply / 100 * (0xff & 100 - stor_12_0_0) / 100 - _circulatingSupply[this]);\n    require(v0 > 0);\n    v1 = 0x106e(v0, varg0, this);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _circulatingSupply[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction finishMinting() public nonPayable { \n    v0 = 0xb90();\n    return v0;\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction currentRunningAddress() public nonPayable { \n    return _currentRunningAddress;\n}\n\nfunction BurnMyTokensAndSetAmountForNewBlockchain() public nonPayable { \n    require(_burnMyTokensAndSetAmountForNewBlockchain);\n    require(_circulatingSupply[msg.sender] + _burnedBalanceOf[msg.sender] >= _burnedBalanceOf[msg.sender]);\n    _burnedBalanceOf[msg.sender] += _circulatingSupply[msg.sender];\n    _burnedBalanceOf[msg.sender] = 0;\n    emit TokensBurned(msg.sender, _circulatingSupply[msg.sender], block.timestamp);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction burnedBalanceOf(address varg0) public nonPayable { \n    return _burnedBalanceOf[varg0];\n}\n\nfunction circulatingSupply() public nonPayable { \n    MEM[0] = 0;\n    return __totalSupply - _totalSupply - _circulatingSupply[this];\n}\n\nfunction bonusEnd20() public nonPayable { \n    return _bonusEnd20;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateTokenNameSymbolAddress(string varg0, string varg1, address varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = new bytes[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length);\n    require(_paused);\n    v3 = v4 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v3 = v5 = msg.sender == _ownerAPI;\n    }\n    require(v3);\n    v6 = v7 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v7 + v0.length > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + _name.length >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    v10 = v11 = v2.data;\n    if (31 < v2.length) {\n        _symbol.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v11 + v2.length > v10) {\n                STORAGE[v12] = MEM[v10];\n                v10 += 32;\n                v12 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v2.length + v2.length | ~0xff & MEM[v11];\n    }\n    while (v13 + (31 + _symbol.length >> 5) > v12) {\n        STORAGE[v12] = 0;\n        v12 += 1;\n    }\n    _currentRunningAddress = varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (v0) {\n        v3 = 0xb90();\n    }\n    v4 = v5 = block.timestamp >= _tradingDate;\n    if (block.timestamp < _tradingDate) {\n        v4 = v6 = 1 == 0xff & _getAddressKYCState[varg0];\n    }\n    require(v4);\n    require(varg1 <= _circulatingSupply[msg.sender]);\n    _circulatingSupply[msg.sender] = _circulatingSupply[msg.sender] - varg1;\n    require(varg1 + _circulatingSupply[varg0] >= _circulatingSupply[varg0]);\n    _circulatingSupply[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction isPaused() public nonPayable { \n    return _paused;\n}\n\nfunction updateExchangeRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    _exchangeRate = varg0;\n    return 1;\n}\n\nfunction bonusEnd05() public nonPayable { \n    return _bonusEnd05;\n}\n\nfunction endDate() public nonPayable { \n    return _endDate;\n}\n\nfunction getAmountToIssue(uint256 varg0) public nonPayable { \n    v0 = 0xc29(varg0);\n    return v0;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(!_paused);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v3 + v2.data] = MEM[v3 + v0.data];\n        v3 += 32;\n    }\n    v5 = v6 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v7 = varg0.receiveApproval(msg.sender, varg1, this, v2).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction ownerAPI() public nonPayable { \n    return _ownerAPI;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction transferAllERC20Token(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(varg0.code.size);\n    v3, v4 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v4;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction BurnTokensAndSetAmountForNewBlockchain(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(_burnMyTokensAndSetAmountForNewBlockchain);\n    require(_circulatingSupply[varg0] + _burnedBalanceOf[varg0] >= _burnedBalanceOf[varg0]);\n    _burnedBalanceOf[varg0] += _circulatingSupply[varg0];\n    _burnedBalanceOf[varg0] = 0;\n    emit TokensBurned(varg0, _circulatingSupply[varg0], block.timestamp);\n}\n\nfunction depositsOf(address varg0) public nonPayable { \n    return _depositsOf[varg0];\n}\n\nfunction getExchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction updateEndDate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(!stor_1b_0_0);\n    require(!_burnMyTokensAndSetAmountForNewBlockchain);\n    _endDate = varg0;\n    return 1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction setAddressKYC(address varg0, bool varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    _getAddressKYCState[varg0] = _getAddressKYCState[varg0] & ~0xff | varg1;\n    return 1;\n}\n\nfunction getAddressKYCState(address varg0) public nonPayable { \n    return 0xff & _getAddressKYCState[varg0];\n}\n\nfunction soldSupply() public nonPayable { \n    return _soldSupply;\n}\n\nfunction newOwnerAPI() public nonPayable { \n    return _newOwnerAPI;\n}\n\nfunction maxAmountETH() public nonPayable { \n    return _maxAmountETH;\n}\n\nfunction versionIndex() public nonPayable { \n    return _versionIndex;\n}\n\nfunction 0xb90() private { \n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (!v0) {\n        if (__totalSupply < _maxSupply) {\n            v3 = v4 = block.timestamp > _endDate;\n            if (v4) {\n                v3 = v5 = this.balance > 0;\n            }\n            if (v3) {\n                v6 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n                require(v6); // checks call status, propagates error data on error\n            }\n            v7 = v8 = 0;\n        } else {\n            _tradingDate = block.timestamp + 3600;\n            stor_1b_0_0 = 1;\n            emit MintingFinished(block.timestamp);\n            v9 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n            require(v9); // checks call status, propagates error data on error\n            goto 0xbb3;\n        }\n    } else {\n        _tradingDate = block.timestamp + 3600;\n        stor_1b_0_0 = 1;\n        emit MintingFinished(block.timestamp);\n        v10 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n        require(v10); // checks call status, propagates error data on error\n    }\n    v7 = v11 = 1;\n    return v7;\n}\n\nfunction 0xc29(uint256 varg0) private { \n    v0 = _exchangeRate * varg0;\n    v1 = v2 = !varg0;\n    if (varg0) {\n        assert(varg0);\n        v1 = v0 / varg0 == _exchangeRate;\n    }\n    require(v1);\n    require(0xde0b6b3a7640000 > 0);\n    assert(0xde0b6b3a7640000);\n    v3 = v4 = v0 / 0xde0b6b3a7640000 / 10 * 10 ** _decimals;\n    if (block.timestamp >= _bonusEnd20) {\n        if (block.timestamp >= _bonusEnd10) {\n            if (block.timestamp < _bonusEnd05) {\n                v3 = v5 = v0 / 0xde0b6b3a7640000 * 105 / 10;\n            }\n        } else {\n            v3 = v6 = v0 / 0xde0b6b3a7640000 * 11;\n        }\n    } else {\n        v3 = v7 = v0 / 0xde0b6b3a7640000 * 12;\n    }\n    if (v0 / 0xde0b6b3a7640000 < 50000) {\n        if (v0 / 0xde0b6b3a7640000 >= 10000) {\n            v3 = v8 = v3 * 12 / 10;\n        }\n    } else {\n        v3 = v9 = v3 * 13 / 10;\n    }\n    return v3;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x39e9e00) {\n            acceptOwnershipAPI();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x8b27e3e == function_selector) {\n            transferAnyERC20Token(address);\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xb58dc38 == function_selector) {\n            SetNewBlockchainEnabled();\n        } else if (0xb97bc86 == function_selector) {\n            startDate();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313354dc == function_selector) {\n            maxSellable();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x350a6429 == function_selector) {\n            minAmountETH();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x43f98a56 == function_selector) {\n            tradingDate();\n        } else if (0x4978ddcc == function_selector) {\n            transferAPIOwnership(address);\n        } else if (0x541ee050 == function_selector) {\n            bonusEnd10();\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x705b5c27 == function_selector) {\n            transferVestingMonthlyAmount(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8561d136 == function_selector) {\n            currentRunningAddress();\n        } else if (0x8d44c90b == function_selector) {\n            BurnMyTokensAndSetAmountForNewBlockchain();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91c1e2c1 == function_selector) {\n            burnedBalanceOf(address);\n        } else if (0x9358928b == function_selector) {\n            circulatingSupply();\n        } else if (0x94c70cb1 == function_selector) {\n            bonusEnd20();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa7b2fc00 == function_selector) {\n            updateTokenNameSymbolAddress(string,string,address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb187bd26 == function_selector) {\n            isPaused();\n        } else if (0xb9e205ae == function_selector) {\n            updateExchangeRate(uint256);\n        } else if (0xba16e00e == function_selector) {\n            bonusEnd05();\n        } else if (0xc24a0f8b == function_selector) {\n            endDate();\n        } else if (0xc3f17ae8 == function_selector) {\n            getAmountToIssue(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcb09b0d0 == function_selector) {\n            ownerAPI();\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xd9c1ac25 == function_selector) {\n            transferAllERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xde49bd54 == function_selector) {\n            BurnTokensAndSetAmountForNewBlockchain(address);\n        } else if (0xe3a9db1a == function_selector) {\n            depositsOf(address);\n        } else if (0xe6aa216c == function_selector) {\n            getExchangeRate();\n        } else if (0xef2bbbdf == function_selector) {\n            updateEndDate(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf45ce8d7 == function_selector) {\n            setAddressKYC(address,bool);\n        } else if (0xf74c67b3 == function_selector) {\n            getAddressKYCState(address);\n        } else if (0xfa2299ee == function_selector) {\n            soldSupply();\n        } else if (0xfbaeac89 == function_selector) {\n            newOwnerAPI();\n        } else if (0xfe9b7f2f == function_selector) {\n            maxAmountETH();\n        } else if (0xff1d2712 == function_selector) {\n            versionIndex();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 08:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x4]\nuint256[] _name; // STORAGE[0x5]\nuint256 __totalSupply; // STORAGE[0x7]\nuint256 _startDate; // STORAGE[0x8]\nuint256 _bonusEnd20; // STORAGE[0x9]\nuint256 _bonusEnd10; // STORAGE[0xa]\nuint256 _bonusEnd05; // STORAGE[0xb]\nuint256 _endDate; // STORAGE[0xc]\nuint256 _tradingDate; // STORAGE[0xd]\nuint256 _exchangeRate; // STORAGE[0xe]\nuint256 _maxSupply; // STORAGE[0xf]\nuint256 _soldSupply; // STORAGE[0x10]\nuint256 _maxSellable; // STORAGE[0x11]\nuint256 _minAmountETH; // STORAGE[0x13]\nuint256 _maxAmountETH; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _circulatingSupply; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _depositsOf; // STORAGE[0x17]\nmapping (uint256 => [uint256]) _getAddressKYCState; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x19]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nmapping (uint256 => [uint256]) _burnedBalanceOf; // STORAGE[0x1a]\nuint256 stor_1c; // STORAGE[0x1c]\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\nuint8 stor_12_0_0; // STORAGE[0x12] bytes 0 to 0\nuint8 stor_1b_0_0; // STORAGE[0x1b] bytes 0 to 0\nuint8 _burnMyTokensAndSetAmountForNewBlockchain; // STORAGE[0x1b] bytes 1 to 1\nuint8 _versionIndex; // STORAGE[0x1d] bytes 0 to 0\naddress _ownerAPI; // STORAGE[0x2] bytes 0 to 19\naddress _newOwnerAPI; // STORAGE[0x3] bytes 0 to 19\nuint160 _currentRunningAddress; // STORAGE[0x15] bytes 0 to 19\nuint8 _paused; // STORAGE[0x3] bytes 20 to 20\nuint256 _totalSupply; // STORAGE[0x263c2b778d062355049effc2dece97bc6547ff8a88a3258daa512061c2153dd]\n\n// Events\nTransfer(address, address, uint256);\nOwnershipAPITransferred(address, address);\nApproval(address, address, uint256);\nOwnBlockchainLaunched(uint256);\nUnpause();\nOwnershipTransferred(address, address);\nPause();\nTokensBurned(address, uint256, uint256);\nMintingFinished(uint256);\n\nfunction 0x106e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (v0) {\n        v3 = 0xb90();\n    }\n    v4 = v5 = block.timestamp >= _tradingDate;\n    if (block.timestamp < _tradingDate) {\n        v6 = address(varg1);\n        v4 = v7 = 1 == 0xff & _getAddressKYCState[v6];\n    }\n    require(v4);\n    v8 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v9 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    require(varg0 <= _allowance[msg.sender]);\n    v10 = address(varg2);\n    _circulatingSupply[v10] = _allowance[msg.sender] - varg0;\n    v11 = address(varg1);\n    v12 = varg0 + _circulatingSupply[v11];\n    require(v12 >= _circulatingSupply[v11]);\n    v13 = address(varg1);\n    _circulatingSupply[v13] = v12;\n    emit Transfer(address(varg2), v13, varg0);\n    return 1;\n}\n\nfunction fallback() public payable { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (!v0) {\n        v3 = v4 = block.timestamp >= _startDate;\n        if (v4) {\n            v3 = v5 = block.timestamp <= _endDate;\n        }\n        if (v3) {\n            v3 = v6 = !stor_1b_0_0;\n        }\n        require(v3);\n        v7 = v8 = msg.value >= _minAmountETH;\n        if (v8) {\n            v7 = v9 = msg.value <= _maxAmountETH;\n        }\n        require(v7);\n        require(msg.value + _depositsOf[msg.sender] <= _maxAmountETH);\n        require(1 == 0xff & _getAddressKYCState[msg.sender]);\n        v10 = 0xc29(msg.value);\n        require(v10 + _soldSupply >= _soldSupply);\n        require(v10 + _soldSupply <= _maxSellable);\n        require(v10 + _soldSupply >= _soldSupply);\n        _soldSupply += v10;\n        require(v10 + __totalSupply >= __totalSupply);\n        __totalSupply += v10;\n        require(v10 + _circulatingSupply[msg.sender] >= _circulatingSupply[msg.sender]);\n        _circulatingSupply[msg.sender] += v10;\n        require(msg.value + _circulatingSupply[msg.sender] >= _circulatingSupply[msg.sender]);\n        _depositsOf[msg.sender] = msg.value + _circulatingSupply[msg.sender];\n        emit Transfer(0, msg.sender, v10);\n        v11 = _owner.call().value(msg.value * 15 / 100).gas(!(msg.value * 15 / 100) * 2300);\n        require(v11); // checks call status, propagates error data on error\n    } else {\n        v12 = 0xb90();\n        v13 = msg.sender.call().value(msg.value).gas(2300 * !msg.value);\n        require(v13); // checks call status, propagates error data on error\n    }\n}\n\nfunction acceptOwnershipAPI() public nonPayable { \n    require(msg.sender == _newOwnerAPI);\n    emit OwnershipAPITransferred(_ownerAPI, _newOwnerAPI);\n    _ownerAPI = _newOwnerAPI;\n    _newOwnerAPI = 0;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transferAnyERC20Token(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(varg0.code.size);\n    v3, v4 = varg0.balanceOf(this).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v5, v6 = varg0.transfer(_owner, v4).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v6;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction SetNewBlockchainEnabled() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = stor_1b_0_0;\n    if (v1) {\n        v0 = v2 = !_burnMyTokensAndSetAmountForNewBlockchain;\n    }\n    require(v0);\n    _burnMyTokensAndSetAmountForNewBlockchain = 1;\n    stor_1c = block.timestamp;\n    emit OwnBlockchainLaunched(block.timestamp);\n}\n\nfunction startDate() public nonPayable { \n    return _startDate;\n}\n\nfunction totalSupply() public nonPayable { \n    MEM[0] = 0;\n    MEM[32] = 22;\n    return __totalSupply - _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x106e(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction maxSellable() public nonPayable { \n    return _maxSellable;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction minAmountETH() public nonPayable { \n    return _minAmountETH;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction tradingDate() public nonPayable { \n    return _tradingDate;\n}\n\nfunction transferAPIOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwnerAPI = varg0;\n}\n\nfunction bonusEnd10() public nonPayable { \n    return _bonusEnd10;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction transferVestingMonthlyAmount(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    assert(24);\n    assert(30);\n    v0 = 15 * _maxSupply / 100 * (0xff & 100 - stor_12_0_0) / 100 * ((block.timestamp - _tradingDate) / 3600 / 24 / 30 + 1) / 24 - (15 * _maxSupply / 100 * (0xff & 100 - stor_12_0_0) / 100 - _circulatingSupply[this]);\n    require(v0 > 0);\n    v1 = 0x106e(v0, varg0, this);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _circulatingSupply[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction finishMinting() public nonPayable { \n    v0 = 0xb90();\n    return v0;\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction currentRunningAddress() public nonPayable { \n    return _currentRunningAddress;\n}\n\nfunction BurnMyTokensAndSetAmountForNewBlockchain() public nonPayable { \n    require(_burnMyTokensAndSetAmountForNewBlockchain);\n    require(_circulatingSupply[msg.sender] + _burnedBalanceOf[msg.sender] >= _burnedBalanceOf[msg.sender]);\n    _burnedBalanceOf[msg.sender] += _circulatingSupply[msg.sender];\n    _burnedBalanceOf[msg.sender] = 0;\n    emit TokensBurned(msg.sender, _circulatingSupply[msg.sender], block.timestamp);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction burnedBalanceOf(address varg0) public nonPayable { \n    return _burnedBalanceOf[varg0];\n}\n\nfunction circulatingSupply() public nonPayable { \n    MEM[0] = 0;\n    return __totalSupply - _totalSupply - _circulatingSupply[this];\n}\n\nfunction bonusEnd20() public nonPayable { \n    return _bonusEnd20;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateTokenNameSymbolAddress(string varg0, string varg1, address varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = new bytes[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length);\n    require(_paused);\n    v3 = v4 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v3 = v5 = msg.sender == _ownerAPI;\n    }\n    require(v3);\n    v6 = v7 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v7 + v0.length > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + _name.length >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    v10 = v11 = v2.data;\n    if (31 < v2.length) {\n        _symbol.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v11 + v2.length > v10) {\n                STORAGE[v12] = MEM[v10];\n                v10 += 32;\n                v12 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v2.length + v2.length | ~0xff & MEM[v11];\n    }\n    while (v13 + (31 + _symbol.length >> 5) > v12) {\n        STORAGE[v12] = 0;\n        v12 += 1;\n    }\n    _currentRunningAddress = varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (v0) {\n        v3 = 0xb90();\n    }\n    v4 = v5 = block.timestamp >= _tradingDate;\n    if (block.timestamp < _tradingDate) {\n        v4 = v6 = 1 == 0xff & _getAddressKYCState[varg0];\n    }\n    require(v4);\n    require(varg1 <= _circulatingSupply[msg.sender]);\n    _circulatingSupply[msg.sender] = _circulatingSupply[msg.sender] - varg1;\n    require(varg1 + _circulatingSupply[varg0] >= _circulatingSupply[varg0]);\n    _circulatingSupply[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction isPaused() public nonPayable { \n    return _paused;\n}\n\nfunction updateExchangeRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    _exchangeRate = varg0;\n    return 1;\n}\n\nfunction bonusEnd05() public nonPayable { \n    return _bonusEnd05;\n}\n\nfunction endDate() public nonPayable { \n    return _endDate;\n}\n\nfunction getAmountToIssue(uint256 varg0) public nonPayable { \n    v0 = 0xc29(varg0);\n    return v0;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(!_paused);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v3 + v2.data] = MEM[v3 + v0.data];\n        v3 += 32;\n    }\n    v5 = v6 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v7 = varg0.receiveApproval(msg.sender, varg1, this, v2).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction ownerAPI() public nonPayable { \n    return _ownerAPI;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction transferAllERC20Token(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(varg0.code.size);\n    v3, v4 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v4;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction BurnTokensAndSetAmountForNewBlockchain(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(_burnMyTokensAndSetAmountForNewBlockchain);\n    require(_circulatingSupply[varg0] + _burnedBalanceOf[varg0] >= _burnedBalanceOf[varg0]);\n    _burnedBalanceOf[varg0] += _circulatingSupply[varg0];\n    _burnedBalanceOf[varg0] = 0;\n    emit TokensBurned(varg0, _circulatingSupply[varg0], block.timestamp);\n}\n\nfunction depositsOf(address varg0) public nonPayable { \n    return _depositsOf[varg0];\n}\n\nfunction getExchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction updateEndDate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(!stor_1b_0_0);\n    require(!_burnMyTokensAndSetAmountForNewBlockchain);\n    _endDate = varg0;\n    return 1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction setAddressKYC(address varg0, bool varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    _getAddressKYCState[varg0] = _getAddressKYCState[varg0] & ~0xff | varg1;\n    return 1;\n}\n\nfunction getAddressKYCState(address varg0) public nonPayable { \n    return 0xff & _getAddressKYCState[varg0];\n}\n\nfunction soldSupply() public nonPayable { \n    return _soldSupply;\n}\n\nfunction newOwnerAPI() public nonPayable { \n    return _newOwnerAPI;\n}\n\nfunction maxAmountETH() public nonPayable { \n    return _maxAmountETH;\n}\n\nfunction versionIndex() public nonPayable { \n    return _versionIndex;\n}\n\nfunction 0xb90() private { \n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (!v0) {\n        if (__totalSupply < _maxSupply) {\n            v3 = v4 = block.timestamp > _endDate;\n            if (v4) {\n                v3 = v5 = this.balance > 0;\n            }\n            if (v3) {\n                v6 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n                require(v6); // checks call status, propagates error data on error\n            }\n            v7 = v8 = 0;\n        } else {\n            _tradingDate = block.timestamp + 3600;\n            stor_1b_0_0 = 1;\n            emit MintingFinished(block.timestamp);\n            v9 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n            require(v9); // checks call status, propagates error data on error\n            goto 0xbb3;\n        }\n    } else {\n        _tradingDate = block.timestamp + 3600;\n        stor_1b_0_0 = 1;\n        emit MintingFinished(block.timestamp);\n        v10 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n        require(v10); // checks call status, propagates error data on error\n    }\n    v7 = v11 = 1;\n    return v7;\n}\n\nfunction 0xc29(uint256 varg0) private { \n    v0 = _exchangeRate * varg0;\n    v1 = v2 = !varg0;\n    if (varg0) {\n        assert(varg0);\n        v1 = v0 / varg0 == _exchangeRate;\n    }\n    require(v1);\n    require(0xde0b6b3a7640000 > 0);\n    assert(0xde0b6b3a7640000);\n    v3 = v4 = v0 / 0xde0b6b3a7640000 / 10 * 10 ** _decimals;\n    if (block.timestamp >= _bonusEnd20) {\n        if (block.timestamp >= _bonusEnd10) {\n            if (block.timestamp < _bonusEnd05) {\n                v3 = v5 = v0 / 0xde0b6b3a7640000 * 105 / 10;\n            }\n        } else {\n            v3 = v6 = v0 / 0xde0b6b3a7640000 * 11;\n        }\n    } else {\n        v3 = v7 = v0 / 0xde0b6b3a7640000 * 12;\n    }\n    if (v0 / 0xde0b6b3a7640000 < 50000) {\n        if (v0 / 0xde0b6b3a7640000 >= 10000) {\n            v3 = v8 = v3 * 12 / 10;\n        }\n    } else {\n        v3 = v9 = v3 * 13 / 10;\n    }\n    return v3;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x39e9e00) {\n            acceptOwnershipAPI();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x8b27e3e == function_selector) {\n            transferAnyERC20Token(address);\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xb58dc38 == function_selector) {\n            SetNewBlockchainEnabled();\n        } else if (0xb97bc86 == function_selector) {\n            startDate();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313354dc == function_selector) {\n            maxSellable();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x350a6429 == function_selector) {\n            minAmountETH();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x43f98a56 == function_selector) {\n            tradingDate();\n        } else if (0x4978ddcc == function_selector) {\n            transferAPIOwnership(address);\n        } else if (0x541ee050 == function_selector) {\n            bonusEnd10();\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x705b5c27 == function_selector) {\n            transferVestingMonthlyAmount(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8561d136 == function_selector) {\n            currentRunningAddress();\n        } else if (0x8d44c90b == function_selector) {\n            BurnMyTokensAndSetAmountForNewBlockchain();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91c1e2c1 == function_selector) {\n            burnedBalanceOf(address);\n        } else if (0x9358928b == function_selector) {\n            circulatingSupply();\n        } else if (0x94c70cb1 == function_selector) {\n            bonusEnd20();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa7b2fc00 == function_selector) {\n            updateTokenNameSymbolAddress(string,string,address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb187bd26 == function_selector) {\n            isPaused();\n        } else if (0xb9e205ae == function_selector) {\n            updateExchangeRate(uint256);\n        } else if (0xba16e00e == function_selector) {\n            bonusEnd05();\n        } else if (0xc24a0f8b == function_selector) {\n            endDate();\n        } else if (0xc3f17ae8 == function_selector) {\n            getAmountToIssue(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcb09b0d0 == function_selector) {\n            ownerAPI();\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xd9c1ac25 == function_selector) {\n            transferAllERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xde49bd54 == function_selector) {\n            BurnTokensAndSetAmountForNewBlockchain(address);\n        } else if (0xe3a9db1a == function_selector) {\n            depositsOf(address);\n        } else if (0xe6aa216c == function_selector) {\n            getExchangeRate();\n        } else if (0xef2bbbdf == function_selector) {\n            updateEndDate(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf45ce8d7 == function_selector) {\n            setAddressKYC(address,bool);\n        } else if (0xf74c67b3 == function_selector) {\n            getAddressKYCState(address);\n        } else if (0xfa2299ee == function_selector) {\n            soldSupply();\n        } else if (0xfbaeac89 == function_selector) {\n            newOwnerAPI();\n        } else if (0xfe9b7f2f == function_selector) {\n            maxAmountETH();\n        } else if (0xff1d2712 == function_selector) {\n            versionIndex();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 08:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x4]\nuint256[] _name; // STORAGE[0x5]\nuint256 __totalSupply; // STORAGE[0x7]\nuint256 _startDate; // STORAGE[0x8]\nuint256 _bonusEnd20; // STORAGE[0x9]\nuint256 _bonusEnd10; // STORAGE[0xa]\nuint256 _bonusEnd05; // STORAGE[0xb]\nuint256 _endDate; // STORAGE[0xc]\nuint256 _tradingDate; // STORAGE[0xd]\nuint256 _exchangeRate; // STORAGE[0xe]\nuint256 _maxSupply; // STORAGE[0xf]\nuint256 _soldSupply; // STORAGE[0x10]\nuint256 _maxSellable; // STORAGE[0x11]\nuint256 _minAmountETH; // STORAGE[0x13]\nuint256 _maxAmountETH; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _circulatingSupply; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _depositsOf; // STORAGE[0x17]\nmapping (uint256 => [uint256]) _getAddressKYCState; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x19]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nmapping (uint256 => [uint256]) _burnedBalanceOf; // STORAGE[0x1a]\nuint256 stor_1c; // STORAGE[0x1c]\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\nuint8 stor_12_0_0; // STORAGE[0x12] bytes 0 to 0\nuint8 stor_1b_0_0; // STORAGE[0x1b] bytes 0 to 0\nuint8 _burnMyTokensAndSetAmountForNewBlockchain; // STORAGE[0x1b] bytes 1 to 1\nuint8 _versionIndex; // STORAGE[0x1d] bytes 0 to 0\naddress _ownerAPI; // STORAGE[0x2] bytes 0 to 19\naddress _newOwnerAPI; // STORAGE[0x3] bytes 0 to 19\nuint160 _currentRunningAddress; // STORAGE[0x15] bytes 0 to 19\nuint8 _paused; // STORAGE[0x3] bytes 20 to 20\nuint256 _totalSupply; // STORAGE[0x263c2b778d062355049effc2dece97bc6547ff8a88a3258daa512061c2153dd]\n\n// Events\nTransfer(address, address, uint256);\nOwnershipAPITransferred(address, address);\nApproval(address, address, uint256);\nOwnBlockchainLaunched(uint256);\nUnpause();\nOwnershipTransferred(address, address);\nPause();\nTokensBurned(address, uint256, uint256);\nMintingFinished(uint256);\n\nfunction 0x106e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (v0) {\n        v3 = 0xb90();\n    }\n    v4 = v5 = block.timestamp >= _tradingDate;\n    if (block.timestamp < _tradingDate) {\n        v6 = address(varg1);\n        v4 = v7 = 1 == 0xff & _getAddressKYCState[v6];\n    }\n    require(v4);\n    v8 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v9 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    require(varg0 <= _allowance[msg.sender]);\n    v10 = address(varg2);\n    _circulatingSupply[v10] = _allowance[msg.sender] - varg0;\n    v11 = address(varg1);\n    v12 = varg0 + _circulatingSupply[v11];\n    require(v12 >= _circulatingSupply[v11]);\n    v13 = address(varg1);\n    _circulatingSupply[v13] = v12;\n    emit Transfer(address(varg2), v13, varg0);\n    return 1;\n}\n\nfunction fallback() public payable { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (!v0) {\n        v3 = v4 = block.timestamp >= _startDate;\n        if (v4) {\n            v3 = v5 = block.timestamp <= _endDate;\n        }\n        if (v3) {\n            v3 = v6 = !stor_1b_0_0;\n        }\n        require(v3);\n        v7 = v8 = msg.value >= _minAmountETH;\n        if (v8) {\n            v7 = v9 = msg.value <= _maxAmountETH;\n        }\n        require(v7);\n        require(msg.value + _depositsOf[msg.sender] <= _maxAmountETH);\n        require(1 == 0xff & _getAddressKYCState[msg.sender]);\n        v10 = 0xc29(msg.value);\n        require(v10 + _soldSupply >= _soldSupply);\n        require(v10 + _soldSupply <= _maxSellable);\n        require(v10 + _soldSupply >= _soldSupply);\n        _soldSupply += v10;\n        require(v10 + __totalSupply >= __totalSupply);\n        __totalSupply += v10;\n        require(v10 + _circulatingSupply[msg.sender] >= _circulatingSupply[msg.sender]);\n        _circulatingSupply[msg.sender] += v10;\n        require(msg.value + _circulatingSupply[msg.sender] >= _circulatingSupply[msg.sender]);\n        _depositsOf[msg.sender] = msg.value + _circulatingSupply[msg.sender];\n        emit Transfer(0, msg.sender, v10);\n        v11 = _owner.call().value(msg.value * 15 / 100).gas(!(msg.value * 15 / 100) * 2300);\n        require(v11); // checks call status, propagates error data on error\n    } else {\n        v12 = 0xb90();\n        v13 = msg.sender.call().value(msg.value).gas(2300 * !msg.value);\n        require(v13); // checks call status, propagates error data on error\n    }\n}\n\nfunction acceptOwnershipAPI() public nonPayable { \n    require(msg.sender == _newOwnerAPI);\n    emit OwnershipAPITransferred(_ownerAPI, _newOwnerAPI);\n    _ownerAPI = _newOwnerAPI;\n    _newOwnerAPI = 0;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transferAnyERC20Token(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(varg0.code.size);\n    v3, v4 = varg0.balanceOf(this).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v5, v6 = varg0.transfer(_owner, v4).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v6;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction SetNewBlockchainEnabled() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = stor_1b_0_0;\n    if (v1) {\n        v0 = v2 = !_burnMyTokensAndSetAmountForNewBlockchain;\n    }\n    require(v0);\n    _burnMyTokensAndSetAmountForNewBlockchain = 1;\n    stor_1c = block.timestamp;\n    emit OwnBlockchainLaunched(block.timestamp);\n}\n\nfunction startDate() public nonPayable { \n    return _startDate;\n}\n\nfunction totalSupply() public nonPayable { \n    MEM[0] = 0;\n    MEM[32] = 22;\n    return __totalSupply - _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x106e(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction maxSellable() public nonPayable { \n    return _maxSellable;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction minAmountETH() public nonPayable { \n    return _minAmountETH;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction tradingDate() public nonPayable { \n    return _tradingDate;\n}\n\nfunction transferAPIOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwnerAPI = varg0;\n}\n\nfunction bonusEnd10() public nonPayable { \n    return _bonusEnd10;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction transferVestingMonthlyAmount(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    assert(24);\n    assert(30);\n    v0 = 15 * _maxSupply / 100 * (0xff & 100 - stor_12_0_0) / 100 * ((block.timestamp - _tradingDate) / 3600 / 24 / 30 + 1) / 24 - (15 * _maxSupply / 100 * (0xff & 100 - stor_12_0_0) / 100 - _circulatingSupply[this]);\n    require(v0 > 0);\n    v1 = 0x106e(v0, varg0, this);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _circulatingSupply[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction finishMinting() public nonPayable { \n    v0 = 0xb90();\n    return v0;\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction currentRunningAddress() public nonPayable { \n    return _currentRunningAddress;\n}\n\nfunction BurnMyTokensAndSetAmountForNewBlockchain() public nonPayable { \n    require(_burnMyTokensAndSetAmountForNewBlockchain);\n    require(_circulatingSupply[msg.sender] + _burnedBalanceOf[msg.sender] >= _burnedBalanceOf[msg.sender]);\n    _burnedBalanceOf[msg.sender] += _circulatingSupply[msg.sender];\n    _burnedBalanceOf[msg.sender] = 0;\n    emit TokensBurned(msg.sender, _circulatingSupply[msg.sender], block.timestamp);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction burnedBalanceOf(address varg0) public nonPayable { \n    return _burnedBalanceOf[varg0];\n}\n\nfunction circulatingSupply() public nonPayable { \n    MEM[0] = 0;\n    return __totalSupply - _totalSupply - _circulatingSupply[this];\n}\n\nfunction bonusEnd20() public nonPayable { \n    return _bonusEnd20;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateTokenNameSymbolAddress(string varg0, string varg1, address varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = new bytes[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length);\n    require(_paused);\n    v3 = v4 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v3 = v5 = msg.sender == _ownerAPI;\n    }\n    require(v3);\n    v6 = v7 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v7 + v0.length > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + _name.length >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    v10 = v11 = v2.data;\n    if (31 < v2.length) {\n        _symbol.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v11 + v2.length > v10) {\n                STORAGE[v12] = MEM[v10];\n                v10 += 32;\n                v12 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v2.length + v2.length | ~0xff & MEM[v11];\n    }\n    while (v13 + (31 + _symbol.length >> 5) > v12) {\n        STORAGE[v12] = 0;\n        v12 += 1;\n    }\n    _currentRunningAddress = varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_paused);\n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (v0) {\n        v3 = 0xb90();\n    }\n    v4 = v5 = block.timestamp >= _tradingDate;\n    if (block.timestamp < _tradingDate) {\n        v4 = v6 = 1 == 0xff & _getAddressKYCState[varg0];\n    }\n    require(v4);\n    require(varg1 <= _circulatingSupply[msg.sender]);\n    _circulatingSupply[msg.sender] = _circulatingSupply[msg.sender] - varg1;\n    require(varg1 + _circulatingSupply[varg0] >= _circulatingSupply[varg0]);\n    _circulatingSupply[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction isPaused() public nonPayable { \n    return _paused;\n}\n\nfunction updateExchangeRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    _exchangeRate = varg0;\n    return 1;\n}\n\nfunction bonusEnd05() public nonPayable { \n    return _bonusEnd05;\n}\n\nfunction endDate() public nonPayable { \n    return _endDate;\n}\n\nfunction getAmountToIssue(uint256 varg0) public nonPayable { \n    v0 = 0xc29(varg0);\n    return v0;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(!_paused);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v3 + v2.data] = MEM[v3 + v0.data];\n        v3 += 32;\n    }\n    v5 = v6 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v7 = varg0.receiveApproval(msg.sender, varg1, this, v2).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction ownerAPI() public nonPayable { \n    return _ownerAPI;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction transferAllERC20Token(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(varg0.code.size);\n    v3, v4 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v4;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction BurnTokensAndSetAmountForNewBlockchain(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(_burnMyTokensAndSetAmountForNewBlockchain);\n    require(_circulatingSupply[varg0] + _burnedBalanceOf[varg0] >= _burnedBalanceOf[varg0]);\n    _burnedBalanceOf[varg0] += _circulatingSupply[varg0];\n    _burnedBalanceOf[varg0] = 0;\n    emit TokensBurned(varg0, _circulatingSupply[varg0], block.timestamp);\n}\n\nfunction depositsOf(address varg0) public nonPayable { \n    return _depositsOf[varg0];\n}\n\nfunction getExchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction updateEndDate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    require(!stor_1b_0_0);\n    require(!_burnMyTokensAndSetAmountForNewBlockchain);\n    _endDate = varg0;\n    return 1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction setAddressKYC(address varg0, bool varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == _ownerAPI;\n    }\n    require(v0);\n    _getAddressKYCState[varg0] = _getAddressKYCState[varg0] & ~0xff | varg1;\n    return 1;\n}\n\nfunction getAddressKYCState(address varg0) public nonPayable { \n    return 0xff & _getAddressKYCState[varg0];\n}\n\nfunction soldSupply() public nonPayable { \n    return _soldSupply;\n}\n\nfunction newOwnerAPI() public nonPayable { \n    return _newOwnerAPI;\n}\n\nfunction maxAmountETH() public nonPayable { \n    return _maxAmountETH;\n}\n\nfunction versionIndex() public nonPayable { \n    return _versionIndex;\n}\n\nfunction 0xb90() private { \n    v0 = v1 = block.timestamp > _endDate;\n    if (v1) {\n        v0 = v2 = !stor_1b_0_0;\n    }\n    if (!v0) {\n        if (__totalSupply < _maxSupply) {\n            v3 = v4 = block.timestamp > _endDate;\n            if (v4) {\n                v3 = v5 = this.balance > 0;\n            }\n            if (v3) {\n                v6 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n                require(v6); // checks call status, propagates error data on error\n            }\n            v7 = v8 = 0;\n        } else {\n            _tradingDate = block.timestamp + 3600;\n            stor_1b_0_0 = 1;\n            emit MintingFinished(block.timestamp);\n            v9 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n            require(v9); // checks call status, propagates error data on error\n            goto 0xbb3;\n        }\n    } else {\n        _tradingDate = block.timestamp + 3600;\n        stor_1b_0_0 = 1;\n        emit MintingFinished(block.timestamp);\n        v10 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n        require(v10); // checks call status, propagates error data on error\n    }\n    v7 = v11 = 1;\n    return v7;\n}\n\nfunction 0xc29(uint256 varg0) private { \n    v0 = _exchangeRate * varg0;\n    v1 = v2 = !varg0;\n    if (varg0) {\n        assert(varg0);\n        v1 = v0 / varg0 == _exchangeRate;\n    }\n    require(v1);\n    require(0xde0b6b3a7640000 > 0);\n    assert(0xde0b6b3a7640000);\n    v3 = v4 = v0 / 0xde0b6b3a7640000 / 10 * 10 ** _decimals;\n    if (block.timestamp >= _bonusEnd20) {\n        if (block.timestamp >= _bonusEnd10) {\n            if (block.timestamp < _bonusEnd05) {\n                v3 = v5 = v0 / 0xde0b6b3a7640000 * 105 / 10;\n            }\n        } else {\n            v3 = v6 = v0 / 0xde0b6b3a7640000 * 11;\n        }\n    } else {\n        v3 = v7 = v0 / 0xde0b6b3a7640000 * 12;\n    }\n    if (v0 / 0xde0b6b3a7640000 < 50000) {\n        if (v0 / 0xde0b6b3a7640000 >= 10000) {\n            v3 = v8 = v3 * 12 / 10;\n        }\n    } else {\n        v3 = v9 = v3 * 13 / 10;\n    }\n    return v3;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x39e9e00) {\n            acceptOwnershipAPI();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x8b27e3e == function_selector) {\n            transferAnyERC20Token(address);\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xb58dc38 == function_selector) {\n            SetNewBlockchainEnabled();\n        } else if (0xb97bc86 == function_selector) {\n            startDate();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313354dc == function_selector) {\n            maxSellable();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x350a6429 == function_selector) {\n            minAmountETH();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x43f98a56 == function_selector) {\n            tradingDate();\n        } else if (0x4978ddcc == function_selector) {\n            transferAPIOwnership(address);\n        } else if (0x541ee050 == function_selector) {\n            bonusEnd10();\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x705b5c27 == function_selector) {\n            transferVestingMonthlyAmount(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x7d64bcb4 == function_selector) {\n            finishMinting();\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8561d136 == function_selector) {\n            currentRunningAddress();\n        } else if (0x8d44c90b == function_selector) {\n            BurnMyTokensAndSetAmountForNewBlockchain();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91c1e2c1 == function_selector) {\n            burnedBalanceOf(address);\n        } else if (0x9358928b == function_selector) {\n            circulatingSupply();\n        } else if (0x94c70cb1 == function_selector) {\n            bonusEnd20();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa7b2fc00 == function_selector) {\n            updateTokenNameSymbolAddress(string,string,address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb187bd26 == function_selector) {\n            isPaused();\n        } else if (0xb9e205ae == function_selector) {\n            updateExchangeRate(uint256);\n        } else if (0xba16e00e == function_selector) {\n            bonusEnd05();\n        } else if (0xc24a0f8b == function_selector) {\n            endDate();\n        } else if (0xc3f17ae8 == function_selector) {\n            getAmountToIssue(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcb09b0d0 == function_selector) {\n            ownerAPI();\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xd9c1ac25 == function_selector) {\n            transferAllERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xde49bd54 == function_selector) {\n            BurnTokensAndSetAmountForNewBlockchain(address);\n        } else if (0xe3a9db1a == function_selector) {\n            depositsOf(address);\n        } else if (0xe6aa216c == function_selector) {\n            getExchangeRate();\n        } else if (0xef2bbbdf == function_selector) {\n            updateEndDate(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf45ce8d7 == function_selector) {\n            setAddressKYC(address,bool);\n        } else if (0xf74c67b3 == function_selector) {\n            getAddressKYCState(address);\n        } else if (0xfa2299ee == function_selector) {\n            soldSupply();\n        } else if (0xfbaeac89 == function_selector) {\n            newOwnerAPI();\n        } else if (0xfe9b7f2f == function_selector) {\n            maxAmountETH();\n        } else if (0xff1d2712 == function_selector) {\n            versionIndex();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 21.691936492919922,
	"usage": {
		"completion_tokens": 441,
		"prompt_tokens": 7353,
		"total_tokens": 7794
	}
}