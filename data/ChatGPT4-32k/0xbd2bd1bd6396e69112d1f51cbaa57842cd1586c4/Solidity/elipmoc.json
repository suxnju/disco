{
	"address": "0xbd2bd1bd6396e69112d1f51cbaa57842cd1586c4",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a Solidity contract based on the decompiled code. Please note that it might not work as expected due to a lack of information about the original contract's functionality.\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _totalDepositOf;\n    mapping (address => uint256) private _totalPaidOf;\n    mapping (address => uint256) private _lastPayDateOf;\n    mapping (address => uint256) private owner_4;\n    uint256 private stor_5;\n    uint256 private stor_7;\n    uint256 private _fallback;\n    uint256 private stor_9;\n    address private _transferOwnership;\n    uint8 private stor_6_0_0;\n\n    event DepositIn(address indexed depositor, uint256 amount, uint256 time);\n    event PayOut(address indexed recipient, uint256 amount, uint256 time);\n\n    function totalPaidOf(address user) public view returns (uint256) { \n        return _totalPaidOf[user];\n    }\n\n    function lastPayDateOf(address user) public view returns (uint256) { \n        return _lastPayDateOf[user];\n    }\n\n    function payOut() public { \n        require(_totalDepositOf[msg.sender] > 0);\n        require(block.timestamp > _lastPayDateOf[msg.sender]);\n        assert(stor_6_0_0 != 0);\n        require((block.timestamp - _lastPayDateOf[msg.sender]) / stor_6_0_0 >= 30);\n        _payout((block.timestamp - _lastPayDateOf[msg.sender]) / stor_6_0_0, 0, msg.sender);\n    }\n\n    function payOutFor(address user) public { \n        require(msg.sender == _transferOwnership && _totalDepositOf[user] > 0);\n        require(block.timestamp > _lastPayDateOf[user]);\n        assert(stor_6_0_0 != 0);\n        require((block.timestamp - _lastPayDateOf[user]) / stor_6_0_0 >= 30);\n        _payout((block.timestamp - _lastPayDateOf[user]) / stor_6_0_0, 1, user);\n    }\n\n    function totalDepositOf(address user) public view returns (uint256) { \n        return _totalDepositOf[user];\n    }\n\n    function depositForRecipent(address recipient) public payable { \n        require(block.timestamp >= _fallback && msg.value >= stor_5);\n        _fallback = block.timestamp;\n        if (_totalDepositOf[recipient] <= 0) {\n            _lastPayDateOf[recipient] = block.timestamp;\n        } else {\n            assert(stor_6_0_0 != 0);\n            owner_4[recipient] += (msg.value - msg.value / 100 * stor_9) / 100 * ((block.timestamp - _lastPayDateOf[recipient]) / stor_6_0_0);\n        }\n        _totalDepositOf[recipient] += msg.value - msg.value / 100 * stor_9;\n        emit DepositIn(recipient, msg.value, block.timestamp);\n        (bool success,) = _transferOwnership.call{value: msg.value / 100 * stor_9, gas: 2300}(\"\");\n        require(success);\n    }\n\n    function transferOwnership(address newOwner) public { \n        require(msg.sender == _transferOwnership);\n        _transferOwnership = newOwner;\n    }\n\n    function _payout(uint256 amount, uint256 varg1, address recipient) private { \n        uint256 payout = amount * (owner_4[recipient] / 100) - owner_4[recipient];\n        if (payout >= address(this).balance) {\n            payout = address(this).balance;\n        }\n        assert(payout > 0);\n        if (varg1 > 0) {\n            assert(gasleft() * stor_7 < payout);\n            payout -= gasleft() * stor_7;\n            (bool success,) = _transferOwnership.call{value: gasleft() * stor_7, gas: 2300}(\"\");\n            require(success);\n        }\n        _lastPayDateOf[recipient] = block.timestamp;\n        (bool success,) = recipient.call{value: payout, gas: 2300}(\"\");\n        require(success);\n        _totalPaidOf[recipient] += payout;\n        owner_4[recipient] = 0;\n        emit PayOut(recipient, payout, block.timestamp);\n    }\n\n    fallback() external payable { \n        require(block.timestamp >= _fallback && msg.value >= stor_5);\n        _fallback = block.timestamp;\n        if (_totalDepositOf[msg.sender] <= 0) {\n            _lastPayDateOf[msg.sender] = block.timestamp;\n        } else {\n            assert(stor_6_0_0 != 0);\n            owner_4[msg.sender] += (msg.value - stor_9 * (msg.value / 100)) / 100 * ((block.timestamp - _lastPayDateOf[msg.sender]) / stor_6_0_0);\n        }\n        _totalDepositOf[msg.sender] += msg.value - stor_9 * (msg.value / 100);\n        emit DepositIn(msg.sender, msg.value, block.timestamp);\n        (bool success,) = _transferOwnership.call{value: stor_9 * (msg.value / 100), gas: 2300}(\"\");\n        require(success); \n    }\n}\n```\nPlease note that the function signature selection which was present in the decompiled code has been left out because in Solidity, this is taken care of automatically. The `_payout` function was derived from the `0x5c9` function in the decompiled code, and the STORAGE variable has been replaced by `stor_6_0_0`.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459638,
	"id": "chatcmpl-8R3fKgsrLkqhJN7IM15QnQrUTQW0u",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 21:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _totalDepositOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _totalPaidOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _lastPayDateOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _fallback; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\naddress _transferOwnership; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nDepositIn(address, uint256, uint256);\nPayOut(address, uint256, uint256);\n\nfunction totalPaidOf(address varg0) public nonPayable { \n    return _totalPaidOf[varg0];\n}\n\nfunction lastPayDateOf(address varg0) public nonPayable { \n    return _lastPayDateOf[varg0];\n}\n\nfunction payOut() public nonPayable { \n    require(0 < _totalDepositOf[msg.sender]);\n    require(block.timestamp > _lastPayDateOf[msg.sender]);\n    assert(stor_6_0_0);\n    require((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6] >= 30);\n    0x5c9((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6], 0, msg.sender);\n}\n\nfunction payOutFor(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _transferOwnership;\n    if (v1) {\n        v0 = _totalDepositOf[varg0] > 0;\n    }\n    require(v0);\n    require(block.timestamp > _lastPayDateOf[varg0]);\n    assert(stor_6_0_0);\n    require((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6] >= 30);\n    0x5c9((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6], 1, varg0);\n}\n\nfunction totalDepositOf(address varg0) public nonPayable { \n    return _totalDepositOf[varg0];\n}\n\nfunction depositForRecipent(address varg0) public payable { \n    v0 = v1 = block.timestamp >= _fallback;\n    if (v1) {\n        v0 = msg.value >= stor_5;\n    }\n    require(v0);\n    _fallback = block.timestamp;\n    if (_totalDepositOf[varg0] <= 0) {\n        _lastPayDateOf[varg0] = block.timestamp;\n    } else {\n        assert(stor_6_0_0);\n        owner_4[varg0] += (msg.value - msg.value / 100 * stor_9) / 100 * ((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6]);\n    }\n    _totalDepositOf[varg0] += msg.value - msg.value / 100 * stor_9;\n    emit DepositIn(varg0, msg.value, block.timestamp);\n    v2 = _transferOwnership.call().value(msg.value / 100 * stor_9).gas(2300 * !(msg.value / 100 * stor_9));\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _transferOwnership);\n    _transferOwnership = varg0;\n}\n\nfunction 0x5c9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = v2 = varg0 * (owner_4[v0] / 100) - owner_4[v0];\n    if (v2 >= this.balance) {\n        v1 = v3 = this.balance;\n    }\n    assert(v1 > 0);\n    if (varg1) {\n        assert(msg.gas * stor_7 < v1);\n        v1 = v4 = v1 - msg.gas * stor_7;\n        v5 = _transferOwnership.call().value(msg.gas * stor_7).gas(2300 * !(msg.gas * stor_7));\n        require(v5); // checks call status, propagates error data on error\n    }\n    v6 = address(varg2);\n    _lastPayDateOf[v6] = block.timestamp;\n    v7 = v6.call().value(v1).gas(2300 * !v1);\n    require(v7); // checks call status, propagates error data on error\n    v8 = address(varg2);\n    _totalPaidOf[v8] += v1;\n    owner_4[v8] = 0;\n    emit PayOut(v8, v1, block.timestamp);\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = v1 = block.timestamp >= _fallback;\n    if (v1) {\n        v0 = v2 = msg.value >= stor_5;\n    }\n    require(v0);\n    _fallback = block.timestamp;\n    if (0 >= _totalDepositOf[msg.sender]) {\n        _lastPayDateOf[msg.sender] = block.timestamp;\n    } else {\n        assert(stor_6_0_0);\n        owner_4[msg.sender] += (msg.value - stor_9 * (msg.value / 100)) / 100 * ((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6]);\n    }\n    _totalDepositOf[msg.sender] += msg.value - stor_9 * (msg.value / 100);\n    emit DepositIn(msg.sender, msg.value, block.timestamp);\n    v3 = _transferOwnership.call().value(stor_9 * (msg.value / 100)).gas(2300 * !(stor_9 * (msg.value / 100)));\n    require(v3); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x8fb6939) {\n            totalPaidOf(address);\n        } else if (0x7fdb5396 == function_selector) {\n            lastPayDateOf(address);\n        } else if (0xc2052403 == function_selector) {\n            payOut();\n        } else if (0xc58cb9e3 == function_selector) {\n            payOutFor(address);\n        } else if (0xc5d511e1 == function_selector) {\n            totalDepositOf(address);\n        } else if (0xcd8ceab1 == function_selector) {\n            depositForRecipent(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 21:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _totalDepositOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _totalPaidOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _lastPayDateOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _fallback; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\naddress _transferOwnership; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nDepositIn(address, uint256, uint256);\nPayOut(address, uint256, uint256);\n\nfunction totalPaidOf(address varg0) public nonPayable { \n    return _totalPaidOf[varg0];\n}\n\nfunction lastPayDateOf(address varg0) public nonPayable { \n    return _lastPayDateOf[varg0];\n}\n\nfunction payOut() public nonPayable { \n    require(0 < _totalDepositOf[msg.sender]);\n    require(block.timestamp > _lastPayDateOf[msg.sender]);\n    assert(stor_6_0_0);\n    require((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6] >= 30);\n    0x5c9((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6], 0, msg.sender);\n}\n\nfunction payOutFor(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _transferOwnership;\n    if (v1) {\n        v0 = _totalDepositOf[varg0] > 0;\n    }\n    require(v0);\n    require(block.timestamp > _lastPayDateOf[varg0]);\n    assert(stor_6_0_0);\n    require((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6] >= 30);\n    0x5c9((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6], 1, varg0);\n}\n\nfunction totalDepositOf(address varg0) public nonPayable { \n    return _totalDepositOf[varg0];\n}\n\nfunction depositForRecipent(address varg0) public payable { \n    v0 = v1 = block.timestamp >= _fallback;\n    if (v1) {\n        v0 = msg.value >= stor_5;\n    }\n    require(v0);\n    _fallback = block.timestamp;\n    if (_totalDepositOf[varg0] <= 0) {\n        _lastPayDateOf[varg0] = block.timestamp;\n    } else {\n        assert(stor_6_0_0);\n        owner_4[varg0] += (msg.value - msg.value / 100 * stor_9) / 100 * ((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6]);\n    }\n    _totalDepositOf[varg0] += msg.value - msg.value / 100 * stor_9;\n    emit DepositIn(varg0, msg.value, block.timestamp);\n    v2 = _transferOwnership.call().value(msg.value / 100 * stor_9).gas(2300 * !(msg.value / 100 * stor_9));\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _transferOwnership);\n    _transferOwnership = varg0;\n}\n\nfunction 0x5c9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = v2 = varg0 * (owner_4[v0] / 100) - owner_4[v0];\n    if (v2 >= this.balance) {\n        v1 = v3 = this.balance;\n    }\n    assert(v1 > 0);\n    if (varg1) {\n        assert(msg.gas * stor_7 < v1);\n        v1 = v4 = v1 - msg.gas * stor_7;\n        v5 = _transferOwnership.call().value(msg.gas * stor_7).gas(2300 * !(msg.gas * stor_7));\n        require(v5); // checks call status, propagates error data on error\n    }\n    v6 = address(varg2);\n    _lastPayDateOf[v6] = block.timestamp;\n    v7 = v6.call().value(v1).gas(2300 * !v1);\n    require(v7); // checks call status, propagates error data on error\n    v8 = address(varg2);\n    _totalPaidOf[v8] += v1;\n    owner_4[v8] = 0;\n    emit PayOut(v8, v1, block.timestamp);\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = v1 = block.timestamp >= _fallback;\n    if (v1) {\n        v0 = v2 = msg.value >= stor_5;\n    }\n    require(v0);\n    _fallback = block.timestamp;\n    if (0 >= _totalDepositOf[msg.sender]) {\n        _lastPayDateOf[msg.sender] = block.timestamp;\n    } else {\n        assert(stor_6_0_0);\n        owner_4[msg.sender] += (msg.value - stor_9 * (msg.value / 100)) / 100 * ((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6]);\n    }\n    _totalDepositOf[msg.sender] += msg.value - stor_9 * (msg.value / 100);\n    emit DepositIn(msg.sender, msg.value, block.timestamp);\n    v3 = _transferOwnership.call().value(stor_9 * (msg.value / 100)).gas(2300 * !(stor_9 * (msg.value / 100)));\n    require(v3); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x8fb6939) {\n            totalPaidOf(address);\n        } else if (0x7fdb5396 == function_selector) {\n            lastPayDateOf(address);\n        } else if (0xc2052403 == function_selector) {\n            payOut();\n        } else if (0xc58cb9e3 == function_selector) {\n            payOutFor(address);\n        } else if (0xc5d511e1 == function_selector) {\n            totalDepositOf(address);\n        } else if (0xcd8ceab1 == function_selector) {\n            depositForRecipent(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 21:07 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _totalDepositOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _totalPaidOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _lastPayDateOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _fallback; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\naddress _transferOwnership; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nDepositIn(address, uint256, uint256);\nPayOut(address, uint256, uint256);\n\nfunction totalPaidOf(address varg0) public nonPayable { \n    return _totalPaidOf[varg0];\n}\n\nfunction lastPayDateOf(address varg0) public nonPayable { \n    return _lastPayDateOf[varg0];\n}\n\nfunction payOut() public nonPayable { \n    require(0 < _totalDepositOf[msg.sender]);\n    require(block.timestamp > _lastPayDateOf[msg.sender]);\n    assert(stor_6_0_0);\n    require((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6] >= 30);\n    0x5c9((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6], 0, msg.sender);\n}\n\nfunction payOutFor(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _transferOwnership;\n    if (v1) {\n        v0 = _totalDepositOf[varg0] > 0;\n    }\n    require(v0);\n    require(block.timestamp > _lastPayDateOf[varg0]);\n    assert(stor_6_0_0);\n    require((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6] >= 30);\n    0x5c9((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6], 1, varg0);\n}\n\nfunction totalDepositOf(address varg0) public nonPayable { \n    return _totalDepositOf[varg0];\n}\n\nfunction depositForRecipent(address varg0) public payable { \n    v0 = v1 = block.timestamp >= _fallback;\n    if (v1) {\n        v0 = msg.value >= stor_5;\n    }\n    require(v0);\n    _fallback = block.timestamp;\n    if (_totalDepositOf[varg0] <= 0) {\n        _lastPayDateOf[varg0] = block.timestamp;\n    } else {\n        assert(stor_6_0_0);\n        owner_4[varg0] += (msg.value - msg.value / 100 * stor_9) / 100 * ((block.timestamp - _lastPayDateOf[varg0]) / STORAGE[6]);\n    }\n    _totalDepositOf[varg0] += msg.value - msg.value / 100 * stor_9;\n    emit DepositIn(varg0, msg.value, block.timestamp);\n    v2 = _transferOwnership.call().value(msg.value / 100 * stor_9).gas(2300 * !(msg.value / 100 * stor_9));\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _transferOwnership);\n    _transferOwnership = varg0;\n}\n\nfunction 0x5c9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = v2 = varg0 * (owner_4[v0] / 100) - owner_4[v0];\n    if (v2 >= this.balance) {\n        v1 = v3 = this.balance;\n    }\n    assert(v1 > 0);\n    if (varg1) {\n        assert(msg.gas * stor_7 < v1);\n        v1 = v4 = v1 - msg.gas * stor_7;\n        v5 = _transferOwnership.call().value(msg.gas * stor_7).gas(2300 * !(msg.gas * stor_7));\n        require(v5); // checks call status, propagates error data on error\n    }\n    v6 = address(varg2);\n    _lastPayDateOf[v6] = block.timestamp;\n    v7 = v6.call().value(v1).gas(2300 * !v1);\n    require(v7); // checks call status, propagates error data on error\n    v8 = address(varg2);\n    _totalPaidOf[v8] += v1;\n    owner_4[v8] = 0;\n    emit PayOut(v8, v1, block.timestamp);\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = v1 = block.timestamp >= _fallback;\n    if (v1) {\n        v0 = v2 = msg.value >= stor_5;\n    }\n    require(v0);\n    _fallback = block.timestamp;\n    if (0 >= _totalDepositOf[msg.sender]) {\n        _lastPayDateOf[msg.sender] = block.timestamp;\n    } else {\n        assert(stor_6_0_0);\n        owner_4[msg.sender] += (msg.value - stor_9 * (msg.value / 100)) / 100 * ((block.timestamp - _lastPayDateOf[msg.sender]) / STORAGE[6]);\n    }\n    _totalDepositOf[msg.sender] += msg.value - stor_9 * (msg.value / 100);\n    emit DepositIn(msg.sender, msg.value, block.timestamp);\n    v3 = _transferOwnership.call().value(stor_9 * (msg.value / 100)).gas(2300 * !(stor_9 * (msg.value / 100)));\n    require(v3); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x8fb6939) {\n            totalPaidOf(address);\n        } else if (0x7fdb5396 == function_selector) {\n            lastPayDateOf(address);\n        } else if (0xc2052403 == function_selector) {\n            payOut();\n        } else if (0xc58cb9e3 == function_selector) {\n            payOutFor(address);\n        } else if (0xc5d511e1 == function_selector) {\n            totalDepositOf(address);\n        } else if (0xcd8ceab1 == function_selector) {\n            depositForRecipent(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 64.9861524105072,
	"usage": {
		"completion_tokens": 1215,
		"prompt_tokens": 1640,
		"total_tokens": 2855
	}
}