{
	"address": "0xc9ff899e3cc9a16a09907335297fcfbe774bd8b0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a simplified version of the decompiled code in Solidity. It is important to note that the original contract might be more complex and this is only a simple implementation.\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Contract {\n    mapping (uint256 => uint256) private _supportsInterface;\n    mapping (uint256 => uint256) private _ownerOf;\n    mapping (uint256 => uint256) private _approve;\n    mapping (uint256 => uint256) private _balanceOf;\n    mapping (uint256 => bool) private _isApprovedForAll;\n    mapping (uint256 => uint256) private _tokenData;\n    mapping (uint256 => uint256) private _tokenCost;\n    uint256 private _price;\n    uint256 private _maxTotalSupply;\n    uint256 private _totalSupply;\n    uint256 private _lastTokenId;\n    uint8 private _decimals;\n    address private _isOwner;\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    \n    constructor() public {\n        _isOwner = msg.sender;\n        emit OwnershipTransferred(address(0), _isOwner);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface[interfaceId] == 1;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balanceOf[uint256(owner)];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = address(_ownerOf[tokenId]);\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n        _approve[tokenId] = uint256(to);\n        emit Approval(owner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n        return address(_approve[tokenId]);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        require(operator != msg.sender, \"ERC721: approve to caller\");\n        _isApprovedForAll[uint256(msg.sender)][uint256(operator)] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _isApprovedForAll[uint256(owner)][uint256(operator)];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _ownerOf[tokenId] != 0;\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || uint256(getApproved(tokenId)) == uint256(spender) || isApprovedForAll(owner, spender));\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        _approve[tokenId] = 0;\n        _balanceOf[uint256(from)] -= 1;\n        _balanceOf[uint256(to)] += 1;\n        _ownerOf[tokenId] = uint256(to);\n        emit Transfer(from, to, tokenId);\n    }\n}\n```\nPlease note that the provided decompiled code contains several inconsistencies that have been excluded in the provided Solidity code. It also seems to be a part of ERC721 standard smart contract which is used for Non-Fungible Tokens (NFTs).",
				"role": "assistant"
			}
		}
	],
	"created": 1701462473,
	"id": "chatcmpl-8R4P3oCp1F4qr86sbHfxlIrp6MyYI",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 00:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _supportsInterface; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _ownerOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isApprovedForAll; // STORAGE[0x4]\nuint256[] _name; // STORAGE[0x7]\nuint256[] _symbol; // STORAGE[0x8]\nuint256 _price; // STORAGE[0xa]\nuint256 _maxTotalSupply; // STORAGE[0xb]\nuint256 _totalSupply; // STORAGE[0xc]\nuint256 _lastTokenId; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _tokenData; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _tokenCost; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x9] bytes 0 to 0\naddress _isOwner; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\nApprovalForAll(address, address, bool);\n\nfunction 0x13b3(uint256 varg0, uint256 varg1) private { \n    v0 = address(_ownerOf[varg0]);\n    require(v0);\n    require(address(v0) == address(varg1), 'OWNER_IS_NOT_TOKEN_OWNER');\n    if (address(_approve[varg0])) {\n        _approve[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _approve[varg0];\n    }\n    return ;\n}\n\nfunction 0x1550(uint256 varg0, uint256 varg1) private { \n    require(!address(_ownerOf[varg0]));\n    v0 = address(varg1);\n    _ownerOf[varg0] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n    v1 = _balanceOf[varg0];\n    require(1 + v1 >= v1, 'MATH_ERROR');\n    v2 = address(varg1);\n    _balanceOf[v2] = 1 + v1;\n    return ;\n}\n\nfunction 0x15e0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if ((address(varg2)).code.size > 0) {\n        v0 = address(varg3);\n        v1 = new array[](varg0.length);\n        v2 = v3 = 0;\n        v4 = address(varg2);\n        while (v2 < varg0.length) {\n            MEM[v2 + v1.data] = MEM[v2 + varg0.data];\n            v2 += 32;\n        }\n        v5 = v6 = varg0.length + v1.data;\n        if (0x1f & varg0.length) {\n            MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n        }\n        require(v4.code.size);\n        v7, v8 = v4.onERC721Received(msg.sender, v0, varg1, v1).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        return 0x150b7a0200000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v8;\n    } else {\n        return 1;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdraw(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    require(varg0 <= this.balance, 'NOT_ENOUG_MONEY');\n    v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _supportsInterface[~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0)];\n}\n\nfunction upCost(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _lastTokenId, 'INVALID_TOKEN_ID');\n    require(msg.value + _tokenCost[varg0] >= _tokenCost[varg0], 'MATH_ERROR');\n    _tokenCost[varg0] += msg.value;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getApproved(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]), 'TOKEN_DOES_NOT_EXISTS');\n    return address(_approve[varg0]);\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg1]));\n    require(address(_ownerOf[varg1]) != varg0);\n    v0 = v1 = address(_ownerOf[varg1]) == msg.sender;\n    if (address(_ownerOf[varg1]) != msg.sender) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _approve[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _approve[varg1];\n    emit Approval(address(_ownerOf[varg1]), varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction getInfo(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 >= _lastTokenId, 'TOKEN_DOES_NOT_EXISTS');\n    v0 = new bytes[](v1);\n    v1 = (_tokenData[varg0] & (!(_tokenData[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenData[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5, _tokenData[varg0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v0 = v2 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x44b;\n    }\n    require(v0, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n}\n\nfunction maxTotalSupply() public nonPayable { \n    return _maxTotalSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v0 = v2 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x10eeB0xdf5;\n    }\n    require(v0, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n    v3 = 0x15e0(MEM[64], varg2, varg1, varg0);\n    require(v3, 'TOKEN_IS_NOT_RECIVED');\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    return address(_ownerOf[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction tokenCost(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokenCost[varg0];\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction setApprovalForAll(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender != varg0, 'INVALID_TO_ADDRESS');\n    _isApprovedForAll[varg0] = varg1 | ~0xff & _isApprovedForAll[varg0];\n    emit ApprovalForAll(msg.sender, varg0, varg1);\n}\n\nfunction tokenData(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new bytes[](v1);\n    v1 = (_tokenData[varg0] & (!(_tokenData[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenData[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(address(_ownerOf[varg2]));\n    v1 = v2 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v1 = v3 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x666;\n    }\n    require(v1, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n    v4 = 0x15e0(v0, varg2, varg1, varg0);\n    require(v4, 'TOKEN_IS_NOT_RECIVED');\n}\n\nfunction mint(address varg0, string varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    v0 = v1 = 36 + varg1;\n    require(!(((?).length > 0x100000000) | (v1 + (?).length > 4 + (msg.data.length - 4))));\n    require(msg.value >= _price, 'NOT_ENOUG_MONEY');\n    require(1 + _lastTokenId >= _lastTokenId, 'MATH_ERROR');\n    _lastTokenId += 1;\n    if (31 < (?).length) {\n        _tokenData[1 + _lastTokenId] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v1 + (?).length > v0) {\n                STORAGE[v2] = msg.data[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        _tokenData[1 + _lastTokenId] = msg.data[v1] & ~0xff | (?).length + (?).length;\n    }\n    while (v3 + (31 + (((!(0x1 & _tokenData[1 + _lastTokenId]) << 8) - 1 & _tokenData[1 + _lastTokenId]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    _tokenCost[_lastTokenId] = msg.value;\n    require(1 + _totalSupply >= _totalSupply, 'MATH_ERROR');\n    _totalSupply += 1;\n    require(varg0, 'INVALID_TO_ADDRESS');\n    0x1550(_lastTokenId, varg0);\n    emit Transfer(0, varg0, _lastTokenId);\n    return _lastTokenId;\n}\n\nfunction isApprovedForAll(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _isApprovedForAll[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    require(varg0, 'INVALID_NEW_OWNER');\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction lastTokenId() public nonPayable { \n    return _lastTokenId;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector) {\n            if (0x18160ddd > function_selector) {\n                if (0xf714ce == function_selector) {\n                    withdraw(uint256,address);\n                } else if (0x1ffc9a7 == function_selector) {\n                    supportsInterface(bytes4);\n                } else if (0x4d242ab == function_selector) {\n                    upCost(uint256);\n                } else if (0x6fdde03 == function_selector) {\n                    name();\n                } else if (0x81812fc == function_selector) {\n                    getApproved(uint256);\n                } else if (0x95ea7b3 == function_selector) {\n                    approve(address,uint256);\n                }\n            } else if (0x2ab4d052 > function_selector) {\n                if (0x18160ddd == function_selector) {\n                    totalSupply();\n                } else if (0x1a3cd59a == function_selector) {\n                    getInfo(uint256);\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x2ab4d052 == function_selector) {\n                maxTotalSupply();\n            } else if (0x313ce567 == function_selector) {\n                decimals();\n            } else if (0x42842e0e == function_selector) {\n                safeTransferFrom(address,address,uint256);\n            } else if (0x6352211e == function_selector) {\n                ownerOf(uint256);\n            }\n        } else if (0xa22cb465 > function_selector) {\n            if (0x8f32d59b > function_selector) {\n                if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x715018a6 == function_selector) {\n                    renounceOwnership();\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                }\n            } else if (0x8f32d59b == function_selector) {\n                isOwner();\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0x9fed62c1 == function_selector) {\n                tokenCost(uint256);\n            } else if (0xa035b1fe == function_selector) {\n                price();\n            }\n        } else if (0xd0def521 > function_selector) {\n            if (0xa22cb465 == function_selector) {\n                setApprovalForAll(address,bool);\n            } else if (0xb4b5b48f == function_selector) {\n                tokenData(uint256);\n            } else if (0xb88d4fde == function_selector) {\n                safeTransferFrom(address,address,uint256,bytes);\n            }\n        } else if (0xd0def521 == function_selector) {\n            mint(address,string);\n        } else if (0xe985e9c5 == function_selector) {\n            isApprovedForAll(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf84ddf0b == function_selector) {\n            lastTokenId();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 00:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _supportsInterface; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _ownerOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isApprovedForAll; // STORAGE[0x4]\nuint256[] _name; // STORAGE[0x7]\nuint256[] _symbol; // STORAGE[0x8]\nuint256 _price; // STORAGE[0xa]\nuint256 _maxTotalSupply; // STORAGE[0xb]\nuint256 _totalSupply; // STORAGE[0xc]\nuint256 _lastTokenId; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _tokenData; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _tokenCost; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x9] bytes 0 to 0\naddress _isOwner; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\nApprovalForAll(address, address, bool);\n\nfunction 0x13b3(uint256 varg0, uint256 varg1) private { \n    v0 = address(_ownerOf[varg0]);\n    require(v0);\n    require(address(v0) == address(varg1), 'OWNER_IS_NOT_TOKEN_OWNER');\n    if (address(_approve[varg0])) {\n        _approve[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _approve[varg0];\n    }\n    return ;\n}\n\nfunction 0x1550(uint256 varg0, uint256 varg1) private { \n    require(!address(_ownerOf[varg0]));\n    v0 = address(varg1);\n    _ownerOf[varg0] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n    v1 = _balanceOf[varg0];\n    require(1 + v1 >= v1, 'MATH_ERROR');\n    v2 = address(varg1);\n    _balanceOf[v2] = 1 + v1;\n    return ;\n}\n\nfunction 0x15e0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if ((address(varg2)).code.size > 0) {\n        v0 = address(varg3);\n        v1 = new array[](varg0.length);\n        v2 = v3 = 0;\n        v4 = address(varg2);\n        while (v2 < varg0.length) {\n            MEM[v2 + v1.data] = MEM[v2 + varg0.data];\n            v2 += 32;\n        }\n        v5 = v6 = varg0.length + v1.data;\n        if (0x1f & varg0.length) {\n            MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n        }\n        require(v4.code.size);\n        v7, v8 = v4.onERC721Received(msg.sender, v0, varg1, v1).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        return 0x150b7a0200000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v8;\n    } else {\n        return 1;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdraw(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    require(varg0 <= this.balance, 'NOT_ENOUG_MONEY');\n    v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _supportsInterface[~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0)];\n}\n\nfunction upCost(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _lastTokenId, 'INVALID_TOKEN_ID');\n    require(msg.value + _tokenCost[varg0] >= _tokenCost[varg0], 'MATH_ERROR');\n    _tokenCost[varg0] += msg.value;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getApproved(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]), 'TOKEN_DOES_NOT_EXISTS');\n    return address(_approve[varg0]);\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg1]));\n    require(address(_ownerOf[varg1]) != varg0);\n    v0 = v1 = address(_ownerOf[varg1]) == msg.sender;\n    if (address(_ownerOf[varg1]) != msg.sender) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _approve[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _approve[varg1];\n    emit Approval(address(_ownerOf[varg1]), varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction getInfo(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 >= _lastTokenId, 'TOKEN_DOES_NOT_EXISTS');\n    v0 = new bytes[](v1);\n    v1 = (_tokenData[varg0] & (!(_tokenData[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenData[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5, _tokenData[varg0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v0 = v2 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x44b;\n    }\n    require(v0, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n}\n\nfunction maxTotalSupply() public nonPayable { \n    return _maxTotalSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v0 = v2 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x10eeB0xdf5;\n    }\n    require(v0, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n    v3 = 0x15e0(MEM[64], varg2, varg1, varg0);\n    require(v3, 'TOKEN_IS_NOT_RECIVED');\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    return address(_ownerOf[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction tokenCost(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokenCost[varg0];\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction setApprovalForAll(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender != varg0, 'INVALID_TO_ADDRESS');\n    _isApprovedForAll[varg0] = varg1 | ~0xff & _isApprovedForAll[varg0];\n    emit ApprovalForAll(msg.sender, varg0, varg1);\n}\n\nfunction tokenData(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new bytes[](v1);\n    v1 = (_tokenData[varg0] & (!(_tokenData[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenData[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(address(_ownerOf[varg2]));\n    v1 = v2 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v1 = v3 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x666;\n    }\n    require(v1, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n    v4 = 0x15e0(v0, varg2, varg1, varg0);\n    require(v4, 'TOKEN_IS_NOT_RECIVED');\n}\n\nfunction mint(address varg0, string varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    v0 = v1 = 36 + varg1;\n    require(!(((?).length > 0x100000000) | (v1 + (?).length > 4 + (msg.data.length - 4))));\n    require(msg.value >= _price, 'NOT_ENOUG_MONEY');\n    require(1 + _lastTokenId >= _lastTokenId, 'MATH_ERROR');\n    _lastTokenId += 1;\n    if (31 < (?).length) {\n        _tokenData[1 + _lastTokenId] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v1 + (?).length > v0) {\n                STORAGE[v2] = msg.data[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        _tokenData[1 + _lastTokenId] = msg.data[v1] & ~0xff | (?).length + (?).length;\n    }\n    while (v3 + (31 + (((!(0x1 & _tokenData[1 + _lastTokenId]) << 8) - 1 & _tokenData[1 + _lastTokenId]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    _tokenCost[_lastTokenId] = msg.value;\n    require(1 + _totalSupply >= _totalSupply, 'MATH_ERROR');\n    _totalSupply += 1;\n    require(varg0, 'INVALID_TO_ADDRESS');\n    0x1550(_lastTokenId, varg0);\n    emit Transfer(0, varg0, _lastTokenId);\n    return _lastTokenId;\n}\n\nfunction isApprovedForAll(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _isApprovedForAll[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    require(varg0, 'INVALID_NEW_OWNER');\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction lastTokenId() public nonPayable { \n    return _lastTokenId;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector) {\n            if (0x18160ddd > function_selector) {\n                if (0xf714ce == function_selector) {\n                    withdraw(uint256,address);\n                } else if (0x1ffc9a7 == function_selector) {\n                    supportsInterface(bytes4);\n                } else if (0x4d242ab == function_selector) {\n                    upCost(uint256);\n                } else if (0x6fdde03 == function_selector) {\n                    name();\n                } else if (0x81812fc == function_selector) {\n                    getApproved(uint256);\n                } else if (0x95ea7b3 == function_selector) {\n                    approve(address,uint256);\n                }\n            } else if (0x2ab4d052 > function_selector) {\n                if (0x18160ddd == function_selector) {\n                    totalSupply();\n                } else if (0x1a3cd59a == function_selector) {\n                    getInfo(uint256);\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x2ab4d052 == function_selector) {\n                maxTotalSupply();\n            } else if (0x313ce567 == function_selector) {\n                decimals();\n            } else if (0x42842e0e == function_selector) {\n                safeTransferFrom(address,address,uint256);\n            } else if (0x6352211e == function_selector) {\n                ownerOf(uint256);\n            }\n        } else if (0xa22cb465 > function_selector) {\n            if (0x8f32d59b > function_selector) {\n                if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x715018a6 == function_selector) {\n                    renounceOwnership();\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                }\n            } else if (0x8f32d59b == function_selector) {\n                isOwner();\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0x9fed62c1 == function_selector) {\n                tokenCost(uint256);\n            } else if (0xa035b1fe == function_selector) {\n                price();\n            }\n        } else if (0xd0def521 > function_selector) {\n            if (0xa22cb465 == function_selector) {\n                setApprovalForAll(address,bool);\n            } else if (0xb4b5b48f == function_selector) {\n                tokenData(uint256);\n            } else if (0xb88d4fde == function_selector) {\n                safeTransferFrom(address,address,uint256,bytes);\n            }\n        } else if (0xd0def521 == function_selector) {\n            mint(address,string);\n        } else if (0xe985e9c5 == function_selector) {\n            isApprovedForAll(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf84ddf0b == function_selector) {\n            lastTokenId();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 00:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _supportsInterface; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _ownerOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isApprovedForAll; // STORAGE[0x4]\nuint256[] _name; // STORAGE[0x7]\nuint256[] _symbol; // STORAGE[0x8]\nuint256 _price; // STORAGE[0xa]\nuint256 _maxTotalSupply; // STORAGE[0xb]\nuint256 _totalSupply; // STORAGE[0xc]\nuint256 _lastTokenId; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _tokenData; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _tokenCost; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x9] bytes 0 to 0\naddress _isOwner; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\nApprovalForAll(address, address, bool);\n\nfunction 0x13b3(uint256 varg0, uint256 varg1) private { \n    v0 = address(_ownerOf[varg0]);\n    require(v0);\n    require(address(v0) == address(varg1), 'OWNER_IS_NOT_TOKEN_OWNER');\n    if (address(_approve[varg0])) {\n        _approve[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _approve[varg0];\n    }\n    return ;\n}\n\nfunction 0x1550(uint256 varg0, uint256 varg1) private { \n    require(!address(_ownerOf[varg0]));\n    v0 = address(varg1);\n    _ownerOf[varg0] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n    v1 = _balanceOf[varg0];\n    require(1 + v1 >= v1, 'MATH_ERROR');\n    v2 = address(varg1);\n    _balanceOf[v2] = 1 + v1;\n    return ;\n}\n\nfunction 0x15e0(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if ((address(varg2)).code.size > 0) {\n        v0 = address(varg3);\n        v1 = new array[](varg0.length);\n        v2 = v3 = 0;\n        v4 = address(varg2);\n        while (v2 < varg0.length) {\n            MEM[v2 + v1.data] = MEM[v2 + varg0.data];\n            v2 += 32;\n        }\n        v5 = v6 = varg0.length + v1.data;\n        if (0x1f & varg0.length) {\n            MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n        }\n        require(v4.code.size);\n        v7, v8 = v4.onERC721Received(msg.sender, v0, varg1, v1).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        return 0x150b7a0200000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v8;\n    } else {\n        return 1;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdraw(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    require(varg0 <= this.balance, 'NOT_ENOUG_MONEY');\n    v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _supportsInterface[~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0)];\n}\n\nfunction upCost(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _lastTokenId, 'INVALID_TOKEN_ID');\n    require(msg.value + _tokenCost[varg0] >= _tokenCost[varg0], 'MATH_ERROR');\n    _tokenCost[varg0] += msg.value;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getApproved(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]), 'TOKEN_DOES_NOT_EXISTS');\n    return address(_approve[varg0]);\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg1]));\n    require(address(_ownerOf[varg1]) != varg0);\n    v0 = v1 = address(_ownerOf[varg1]) == msg.sender;\n    if (address(_ownerOf[varg1]) != msg.sender) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _approve[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _approve[varg1];\n    emit Approval(address(_ownerOf[varg1]), varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction getInfo(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 >= _lastTokenId, 'TOKEN_DOES_NOT_EXISTS');\n    v0 = new bytes[](v1);\n    v1 = (_tokenData[varg0] & (!(_tokenData[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenData[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5, _tokenData[varg0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v0 = v2 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x44b;\n    }\n    require(v0, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n}\n\nfunction maxTotalSupply() public nonPayable { \n    return _maxTotalSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    MEM[64] = MEM[64] + 32;\n    MEM[MEM[64]] = 0;\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v0 = v2 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x10eeB0xdf5;\n    }\n    require(v0, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n    v3 = 0x15e0(MEM[64], varg2, varg1, varg0);\n    require(v3, 'TOKEN_IS_NOT_RECIVED');\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    return address(_ownerOf[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction tokenCost(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokenCost[varg0];\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction setApprovalForAll(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender != varg0, 'INVALID_TO_ADDRESS');\n    _isApprovedForAll[varg0] = varg1 | ~0xff & _isApprovedForAll[varg0];\n    emit ApprovalForAll(msg.sender, varg0, varg1);\n}\n\nfunction tokenData(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new bytes[](v1);\n    v1 = (_tokenData[varg0] & (!(_tokenData[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenData[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(address(_ownerOf[varg2]));\n    v1 = v2 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        require(address(_ownerOf[varg2]), 'TOKEN_DOES_NOT_EXISTS');\n        v1 = v3 = address(_approve[varg2]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n        goto 0x13ab0x1354B0xcc20x666;\n    }\n    require(v1, 'IS_NOT_APPOVED');\n    require(varg1, 'INVALID_TO_ADDRESS');\n    0x13b3(varg2, varg0);\n    require(address(_ownerOf[varg2]));\n    require(address(_ownerOf[varg2]) == varg0, 'FROM_IS_NOT_TOKEN_OWNER');\n    require(1 <= _balanceOf[varg0], 'MATH_ERROR');\n    _balanceOf[varg0] = _balanceOf[varg0] - 1;\n    _balanceOf[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _balanceOf[varg0];\n    0x1550(varg2, varg1);\n    emit Transfer(varg0, varg1, varg2);\n    v4 = 0x15e0(v0, varg2, varg1, varg0);\n    require(v4, 'TOKEN_IS_NOT_RECIVED');\n}\n\nfunction mint(address varg0, string varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    v0 = v1 = 36 + varg1;\n    require(!(((?).length > 0x100000000) | (v1 + (?).length > 4 + (msg.data.length - 4))));\n    require(msg.value >= _price, 'NOT_ENOUG_MONEY');\n    require(1 + _lastTokenId >= _lastTokenId, 'MATH_ERROR');\n    _lastTokenId += 1;\n    if (31 < (?).length) {\n        _tokenData[1 + _lastTokenId] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v1 + (?).length > v0) {\n                STORAGE[v2] = msg.data[v0];\n                v0 += 32;\n                v2 += 1;\n            }\n        }\n    } else {\n        _tokenData[1 + _lastTokenId] = msg.data[v1] & ~0xff | (?).length + (?).length;\n    }\n    while (v3 + (31 + (((!(0x1 & _tokenData[1 + _lastTokenId]) << 8) - 1 & _tokenData[1 + _lastTokenId]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    _tokenCost[_lastTokenId] = msg.value;\n    require(1 + _totalSupply >= _totalSupply, 'MATH_ERROR');\n    _totalSupply += 1;\n    require(varg0, 'INVALID_TO_ADDRESS');\n    0x1550(_lastTokenId, varg0);\n    emit Transfer(0, varg0, _lastTokenId);\n    return _lastTokenId;\n}\n\nfunction isApprovedForAll(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _isApprovedForAll[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner, 'SENDER_IS_NOT_OWNER');\n    require(varg0, 'INVALID_NEW_OWNER');\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction lastTokenId() public nonPayable { \n    return _lastTokenId;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector) {\n            if (0x18160ddd > function_selector) {\n                if (0xf714ce == function_selector) {\n                    withdraw(uint256,address);\n                } else if (0x1ffc9a7 == function_selector) {\n                    supportsInterface(bytes4);\n                } else if (0x4d242ab == function_selector) {\n                    upCost(uint256);\n                } else if (0x6fdde03 == function_selector) {\n                    name();\n                } else if (0x81812fc == function_selector) {\n                    getApproved(uint256);\n                } else if (0x95ea7b3 == function_selector) {\n                    approve(address,uint256);\n                }\n            } else if (0x2ab4d052 > function_selector) {\n                if (0x18160ddd == function_selector) {\n                    totalSupply();\n                } else if (0x1a3cd59a == function_selector) {\n                    getInfo(uint256);\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x2ab4d052 == function_selector) {\n                maxTotalSupply();\n            } else if (0x313ce567 == function_selector) {\n                decimals();\n            } else if (0x42842e0e == function_selector) {\n                safeTransferFrom(address,address,uint256);\n            } else if (0x6352211e == function_selector) {\n                ownerOf(uint256);\n            }\n        } else if (0xa22cb465 > function_selector) {\n            if (0x8f32d59b > function_selector) {\n                if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x715018a6 == function_selector) {\n                    renounceOwnership();\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                }\n            } else if (0x8f32d59b == function_selector) {\n                isOwner();\n            } else if (0x95d89b41 == function_selector) {\n                symbol();\n            } else if (0x9fed62c1 == function_selector) {\n                tokenCost(uint256);\n            } else if (0xa035b1fe == function_selector) {\n                price();\n            }\n        } else if (0xd0def521 > function_selector) {\n            if (0xa22cb465 == function_selector) {\n                setApprovalForAll(address,bool);\n            } else if (0xb4b5b48f == function_selector) {\n                tokenData(uint256);\n            } else if (0xb88d4fde == function_selector) {\n                safeTransferFrom(address,address,uint256,bytes);\n            }\n        } else if (0xd0def521 == function_selector) {\n            mint(address,string);\n        } else if (0xe985e9c5 == function_selector) {\n            isApprovedForAll(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf84ddf0b == function_selector) {\n            lastTokenId();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 42.87033534049988,
	"usage": {
		"completion_tokens": 990,
		"prompt_tokens": 5657,
		"total_tokens": 6647
	}
}