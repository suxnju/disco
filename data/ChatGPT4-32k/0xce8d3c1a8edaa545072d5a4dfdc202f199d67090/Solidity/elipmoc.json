{
	"address": "0xce8d3c1a8edaa545072d5a4dfdc202f199d67090",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, the equivalent Solidity code would be as follows:\n\n```solidity\npragma solidity ^0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract MyContract is Context, IERC20, IERC20Metadata, ERC20Burnable, ERC20Snapshot, Ownable, Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint256 private _maxTransactionAmount;\n    uint256 private _swapTokensAtAmount;\n    uint256 private _maxWallet;\n    uint256 private _buyTotalFees;\n    uint256 private _buyMarketingFee;\n    uint256 private _buyLiquidityFee;\n    uint256 private _buyDevFee;\n    uint256 private _sellTotalFees;\n    uint256 private _sellMarketingFee;\n    uint256 private _sellLiquidityFee;\n    uint256 private _sellDevFee;\n    uint256 private _feeDenominator;\n    uint256 private _tokensForMarketing;\n    uint256 private _tokensForLiquidity;\n    uint256 private _tokensForDev;\n\n    mapping (address => bool) private _isExcludedFromFees;\n    mapping (address => bool) private _isExcludedMaxTransactionAmount;\n    mapping (address => bool) private _automatedMarketMakerPairs;\n\n    bool private _limitsInEffect;\n    bool private _tradingActive;\n    bool private _swapEnabled;\n    bool private _transferDelayEnabled;\n\n    address private _owner;\n    address private _marketingWallet;\n    address private _devWallet;\n\n    string private _name;\n    string private _symbol;\n\n    // Additional variables and function definitions\n}\n\n```\nPlease note that the original contract might have more functionalities or events that have not been used or triggered and thus not shown in the decompiled code. Furthermore, the types of some variables and return values of functions are inferred and may not be fully accurate.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495590,
	"id": "chatcmpl-8VPAEo4DKBnYqjbosqednG1MmW2yq",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.16 19:08 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_471; // STORAGE[0x3]\nuint256[] _@symbol_481; // STORAGE[0x4]\nuint256 _maxTransactionAmount; // STORAGE[0x8]\nuint256 _swapTokensAtAmount; // STORAGE[0x9]\nuint256 _maxWallet; // STORAGE[0xa]\nmapping (uint256 => uint256) owner_c; // STORAGE[0xc]\nuint256 _buyTotalFees; // STORAGE[0xf]\nuint256 _buyMarketingFee; // STORAGE[0x10]\nuint256 _buyLiquidityFee; // STORAGE[0x11]\nuint256 _buyDevFee; // STORAGE[0x12]\nuint256 _sellTotalFees; // STORAGE[0x13]\nuint256 _sellMarketingFee; // STORAGE[0x14]\nuint256 _sellLiquidityFee; // STORAGE[0x15]\nuint256 _sellDevFee; // STORAGE[0x16]\nuint256 _feeDenominator; // STORAGE[0x17]\nuint256 _tokensForMarketing; // STORAGE[0x18]\nuint256 _tokensForLiquidity; // STORAGE[0x19]\nuint256 _tokensForDev; // STORAGE[0x1a]\nuint256 stor_1b; // STORAGE[0x1b]\nmapping (uint256 => uint256) _isExcludedFromFees; // STORAGE[0x1c]\nmapping (uint256 => uint256) __isExcludedMaxTransactionAmount; // STORAGE[0x1d]\nmapping (uint256 => uint256) _automatedMarketMakerPairs; // STORAGE[0x1e]\nuint256 _limitsInEffect; // STORAGE[0xb] bytes 0 to 0\nuint256 _tradingActive; // STORAGE[0xb] bytes 1 to 1\nuint256 _swapEnabled; // STORAGE[0xb] bytes 2 to 2\nuint256 _transferDelayEnabled; // STORAGE[0xe] bytes 0 to 0\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _marketingWallet; // STORAGE[0x6] bytes 0 to 19\nuint256 _devWallet; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_5_20_20; // STORAGE[0x5] bytes 20 to 20\n\n\n// Events\ndevWalletUpdated(address, address);\nOwnershipTransferred(address, address);\nmarketingWalletUpdated(address, address);\nExcludeFromFees(address, bool);\nApproval(address, address, uint256);\nSetAutomatedMarketMakerPair(address, bool);\nTransfer(address, address, uint256);\nSwapAndLiquify(uint256, uint256, uint256);\n\nfunction @symbol_481() private { \n    v0 = v1 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_481.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_481.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@symbol_481.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_481.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_892(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2933(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    if (varg0 - 0) {\n        if (_limitsInEffect) {\n            v0 = v1 = address(varg2) != _owner;\n            if (!bool(address(varg2) == _owner)) {\n                v0 = v2 = address(varg1) != _owner;\n            }\n            if (v0) {\n                v0 = v3 = address(varg1) != address(0x0);\n            }\n            if (v0) {\n                v0 = v4 = address(varg1) != address(0xdead);\n            }\n            if (v0) {\n                v0 = v5 = !stor_5_20_20;\n            }\n            if (v0) {\n                if (!_tradingActive) {\n                    v6 = v7 = uint8(_isExcludedFromFees[address(address(varg2))]);\n                    if (!v7) {\n                        v6 = v8 = uint8(_isExcludedFromFees[address(address(varg1))]);\n                    }\n                    require(v6, Error('Trading is not active.'));\n                }\n                if (_transferDelayEnabled) {\n                    v9 = v10 = address(varg1) != _owner;\n                    if (!bool(address(varg1) == _owner)) {\n                        v9 = v11 = address(varg1) != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n                    }\n                    if (v9) {\n                        v9 = v12 = address(varg1) != address(0xacece14434d6b20f4131bf5c953a73f918100137);\n                    }\n                    if (v9) {\n                        require(owner_c[address(tx.origin)] < block.number, Error('_transfer:: Transfer Delay enabled. Only one purchase per block allowed.'));\n                        owner_c[address(tx.origin)] = block.number;\n                    }\n                }\n                v13 = v14 = uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n                if (v14) {\n                    v13 = v15 = !uint8(__isExcludedMaxTransactionAmount[address(address(varg1))]);\n                }\n                if (!v13) {\n                    v16 = v17 = uint8(_automatedMarketMakerPairs[address(address(varg1))]);\n                    if (v17) {\n                        v16 = v18 = !uint8(__isExcludedMaxTransactionAmount[address(address(varg2))]);\n                    }\n                    if (!v16) {\n                        if (!uint8(__isExcludedMaxTransactionAmount[address(address(varg1))])) {\n                            require(varg0 <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                            require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                        }\n                    } else {\n                        require(varg0 <= _maxTransactionAmount, Error('Sell transfer amount exceeds the maxTransactionAmount.'));\n                    }\n                } else {\n                    require(varg0 <= _maxTransactionAmount, Error('Buy transfer amount exceeds the maxTransactionAmount.'));\n                    require(varg0 <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                    require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                }\n            }\n        }\n        v19 = v20 = _balanceOf[address(this)] >= _swapTokensAtAmount;\n        if (!bool(_balanceOf[address(this)] < _swapTokensAtAmount)) {\n            v19 = v21 = _swapEnabled;\n        }\n        if (v19) {\n            v19 = v22 = !stor_5_20_20;\n        }\n        if (v19) {\n            v19 = v23 = !uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n        }\n        if (v19) {\n            v19 = v24 = !uint8(_isExcludedFromFees[address(address(varg2))]);\n        }\n        if (v19) {\n            v19 = v25 = !uint8(_isExcludedFromFees[address(address(varg1))]);\n        }\n        if (v19) {\n            stor_5_20_20 = 1;\n            v26 = v27 = _balanceOf[address(this)];\n            require(_tokensForLiquidity <= _tokensForLiquidity + _tokensForMarketing, Panic(17)); // arithmetic overflow or underflow\n            require(_tokensForLiquidity + _tokensForMarketing <= _tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(17)); // arithmetic overflow or underflow\n            v28 = v29 = v27 == 0;\n            if (v27 != 0) {\n                v28 = _tokensForLiquidity + _tokensForMarketing + _tokensForDev == 0;\n            }\n            if (!v28) {\n                require(!_swapTokensAtAmount | (20 == _swapTokensAtAmount * 20 / _swapTokensAtAmount), Panic(17)); // arithmetic overflow or underflow\n                if (v27 > _swapTokensAtAmount * 20) {\n                    v26 = _swapTokensAtAmount * 20;\n                    require(!_swapTokensAtAmount | (20 == v26 / _swapTokensAtAmount), Panic(17)); // arithmetic overflow or underflow\n                }\n                require(!v26 | (_tokensForLiquidity == v26 * _tokensForLiquidity / v26), Panic(17)); // arithmetic overflow or underflow\n                require(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(18)); // division by zero\n                require(2, Panic(18)); // division by zero\n                v30 = v26 * _tokensForLiquidity / (_tokensForLiquidity + _tokensForMarketing + _tokensForDev) >> 1;\n                v31 = _SafeSub('SafeMath: subtraction overflow', v30, v26);\n                require(2 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n                v32 = new address[](2);\n                if (2) {\n                    CALLDATACOPY(v32.data, msg.data.length, 64);\n                }\n                require(0 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v33 = v32.data;\n                v32[0] = address(this);\n                v34, /* address */ v35 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH().gas(msg.gas);\n                require(bool(v34), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                validator_revert_t_address(v35);\n                require(1 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v32[1] = address(v35);\n                @_approve_892(v31, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                v36 = new address[](v32.length);\n                v37 = v38 = v36.data;\n                v39 = v40 = v32.data;\n                v41 = v42 = 0;\n                while (v41 < v32.length) {\n                    MEM[v37] = address(MEM[v39]);\n                    v37 = v37 + 32;\n                    v39 = v39 + 32;\n                    v41 = v41 + 1;\n                }\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v43 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).swapExactTokensForETHSupportingFeeOnTransferTokens(v31, 0, v36, address(this), block.timestamp, v44, address(this)).gas(msg.gas);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v45 = _SafeSub('SafeMath: subtraction overflow', this.balance, this.balance);\n                v46 = @mul_1006(_tokensForMarketing, v45);\n                v47 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v46);\n                v48 = @mul_1006(_tokensForDev, v45);\n                v49 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v48);\n                require(v45 - v47 <= v45, Panic(17)); // arithmetic overflow or underflow\n                require(v45 - v47 - v49 <= v45 - v47, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = 0;\n                _tokensForMarketing = 0;\n                _tokensForDev = 0;\n                v50, /* uint256 */ v51 = _devWallet.call().value(v49).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v52 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v52.data, 0, RETURNDATASIZE());\n                }\n                v53 = v54 = v30 > 0;\n                if (v54) {\n                    v53 = v45 - v47 - v49 > 0;\n                }\n                if (v53) {\n                    @_approve_892(v30, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                    v55, /* uint256 */ v56, /* uint256 */ v57, /* uint256 */ v58 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).addLiquidityETH(address(this), v30, 0, 0, address(0xdead), block.timestamp).value(v45 - v47 - v49).gas(msg.gas);\n                    require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    validator_revert_t_uint256(v56);\n                    validator_revert_t_uint256(v57);\n                    validator_revert_t_uint256(v58);\n                    emit SwapAndLiquify(v31, v45 - v47 - v49, _tokensForLiquidity);\n                }\n                v59, /* uint256 */ v60 = _marketingWallet.call().value(this.balance).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v61 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v61.data, 0, RETURNDATASIZE());\n                }\n            }\n            stor_5_20_20 = 0;\n        }\n        v62 = v63 = !stor_5_20_20;\n        v64 = v65 = uint8(_isExcludedFromFees[address(address(varg2))]);\n        if (!v65) {\n            v64 = v66 = uint8(_isExcludedFromFees[address(address(varg1))]);\n        }\n        if (v64) {\n            v62 = v67 = 0;\n        }\n        v68 = v69 = 0;\n        if (v62) {\n            v70 = v71 = uint8(_automatedMarketMakerPairs[address(address(varg1))]);\n            if (v71) {\n                v70 = v72 = _sellTotalFees > 0;\n            }\n            if (!v70) {\n                v73 = v74 = uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n                if (v74) {\n                    v73 = v75 = _buyTotalFees > 0;\n                }\n                if (v73) {\n                    v76 = @mul_1006(_buyTotalFees, varg0);\n                    v68 = v77 = _SafeDiv(_feeDenominator, v76);\n                    require(!v77 | (_buyLiquidityFee == v77 * _buyLiquidityFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForLiquidity <= _tokensForLiquidity + v77 * _buyLiquidityFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForLiquidity = _tokensForLiquidity + v77 * _buyLiquidityFee / _buyTotalFees;\n                    require(!v77 | (_buyDevFee == v77 * _buyDevFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForDev <= _tokensForDev + v77 * _buyDevFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForDev = _tokensForDev + v77 * _buyDevFee / _buyTotalFees;\n                    require(!v77 | (_buyMarketingFee == v77 * _buyMarketingFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForMarketing <= _tokensForMarketing + v77 * _buyMarketingFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForMarketing = _tokensForMarketing + v77 * _buyMarketingFee / _buyTotalFees;\n                }\n            } else {\n                v78 = @mul_1006(_sellTotalFees, varg0);\n                v68 = v79 = _SafeDiv(_feeDenominator, v78);\n                require(!v79 | (_sellLiquidityFee == v79 * _sellLiquidityFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForLiquidity <= _tokensForLiquidity + v79 * _sellLiquidityFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = _tokensForLiquidity + v79 * _sellLiquidityFee / _sellTotalFees;\n                require(!v79 | (_sellDevFee == v79 * _sellDevFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForDev <= _tokensForDev + v79 * _sellDevFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForDev = _tokensForDev + v79 * _sellDevFee / _sellTotalFees;\n                require(!v79 | (_sellMarketingFee == v79 * _sellMarketingFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForMarketing <= _tokensForMarketing + v79 * _sellMarketingFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForMarketing = _tokensForMarketing + v79 * _sellMarketingFee / _sellTotalFees;\n            }\n            if (v68 > 0) {\n                @_transfer_736(v68, this, varg2);\n            }\n            varg0 = v80 = varg0 - v68;\n            require(v80 <= varg0, Panic(17)); // arithmetic overflow or underflow\n        }\n        @_transfer_736(varg0, varg1, varg2);\n    } else {\n        @_transfer_736(0, varg1, varg2);\n    }\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 = v2 + 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0, v4, 'SafeMath: division by zero'));\n    }\n}\n\nfunction @_transfer_736(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[address(varg2)]);\n    _balanceOf[address(varg2)] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v1;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_471();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_approve_892(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction @mul_1006(uint256 varg0, uint256 varg1) private { \n    if (varg1 - 0) {\n        v0 = varg1 * varg0;\n        require(!varg1 | (varg0 == v0 / varg1), Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(v0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction _isExcludedMaxTransactionAmount(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(__isExcludedMaxTransactionAmount[varg0]));\n}\n\nfunction validator_revert_t_address(address varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction validator_revert_t_uint256(uint256 varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n}\n\nfunction feeDenominator() public nonPayable { \n    return _feeDenominator;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction updateDevWallet(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit devWalletUpdated(varg0, _devWallet);\n    _devWallet = varg0;\n}\n\nfunction tokensForLiquidity() public nonPayable { \n    return _tokensForLiquidity;\n}\n\nfunction tokensForMarketing() public nonPayable { \n    return _tokensForMarketing;\n}\n\nfunction updateMaxTxnAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (5 == _totalSupply * 5 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply * 5 / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxTransactionAmount lower than 0.5%'));\n    require(!varg0 | (0xde0b6b3a7640000 == varg0 * 0xde0b6b3a7640000 / varg0), Panic(17)); // arithmetic overflow or underflow\n    _maxTransactionAmount = varg0 * 0xde0b6b3a7640000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    validator_revert_t_uint256(varg2);\n    @_transfer_2933(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_892(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction deadAddress() public nonPayable { \n    return address(0xdead);\n}\n\nfunction decimals() public nonPayable { \n    return uint8(18);\n}\n\nfunction () public payable { \n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    v0 = _SafeAdd(varg1, _allowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return address(0xacece14434d6b20f4131bf5c953a73f918100137);\n}\n\nfunction limitsInEffect() public nonPayable { \n    return _limitsInEffect;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_isExcludedFromFees[address(address(varg0))]));\n}\n\nfunction sellTotalFees() public nonPayable { \n    return _sellTotalFees;\n}\n\nfunction swapEnabled() public nonPayable { \n    return _swapEnabled;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, address(0x0));\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _limitsInEffect = 0;\n    return bool(1);\n}\n\nfunction excludeFromMaxTransaction(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    __isExcludedMaxTransactionAmount[varg0] = varg1 | bytes31(__isExcludedMaxTransactionAmount[address(address(varg0))]);\n}\n\nfunction marketingWallet() public nonPayable { \n    return _marketingWallet;\n}\n\nfunction buyMarketingFee() public nonPayable { \n    return _buyMarketingFee;\n}\n\nfunction updateBuyFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_uint256(varg0);\n    validator_revert_t_uint256(varg1);\n    validator_revert_t_uint256(varg2);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _buyMarketingFee = varg0;\n    _buyLiquidityFee = varg1;\n    _buyDevFee = varg2;\n    require(_buyMarketingFee <= _buyMarketingFee + _buyLiquidityFee, Panic(17)); // arithmetic overflow or underflow\n    require(_buyMarketingFee + _buyLiquidityFee <= _buyMarketingFee + _buyLiquidityFee + _buyDevFee, Panic(17)); // arithmetic overflow or underflow\n    _buyTotalFees = _buyMarketingFee + _buyLiquidityFee + _buyDevFee;\n    v0 = _SafeDiv(_feeDenominator, _buyTotalFees);\n    require(v0 <= 10, Error('Must keep fees at 10% or less'));\n}\n\nfunction enableTrading() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _tradingActive = 1;\n    _swapEnabled = 1;\n    stor_1b = block.number;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction devWallet() public nonPayable { \n    return _devWallet;\n}\n\nfunction sellMarketingFee() public nonPayable { \n    return _sellMarketingFee;\n}\n\nfunction updateSwapEnabled(bool varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    require(varg0 == varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _swapEnabled = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_481();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction setAutomatedMarketMakerPair(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(varg0 - address(0xacece14434d6b20f4131bf5c953a73f918100137), Error('The pair cannot be removed from automatedMarketMakerPairs'));\n    _automatedMarketMakerPairs[varg0] = varg1 | bytes31(_automatedMarketMakerPairs[address(address(varg0))]);\n    emit SetAutomatedMarketMakerPair(varg0, varg1);\n}\n\nfunction buyDevFee() public nonPayable { \n    return _buyDevFee;\n}\n\nfunction tokensForDev() public nonPayable { \n    return _tokensForDev;\n}\n\nfunction sellDevFee() public nonPayable { \n    return _sellDevFee;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _allowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_transfer_2933(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateMarketingWallet(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit marketingWalletUpdated(varg0, _marketingWallet);\n    _marketingWallet = varg0;\n}\n\nfunction automatedMarketMakerPairs(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_automatedMarketMakerPairs[varg0]));\n}\n\nfunction tradingActive() public nonPayable { \n    return _tradingActive;\n}\n\nfunction excludeFromFees(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _isExcludedFromFees[varg0] = varg1 | bytes31(_isExcludedFromFees[address(address(varg0))]);\n    emit ExcludeFromFees(varg0, varg1);\n}\n\nfunction updateSellFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_uint256(varg0);\n    validator_revert_t_uint256(varg1);\n    validator_revert_t_uint256(varg2);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _sellMarketingFee = varg0;\n    _sellLiquidityFee = varg1;\n    _sellDevFee = varg2;\n    require(_sellMarketingFee <= _sellMarketingFee + _sellLiquidityFee, Panic(17)); // arithmetic overflow or underflow\n    require(_sellMarketingFee + _sellLiquidityFee <= _sellMarketingFee + _sellLiquidityFee + _sellDevFee, Panic(17)); // arithmetic overflow or underflow\n    _sellTotalFees = _sellMarketingFee + _sellLiquidityFee + _sellDevFee;\n    v0 = _SafeDiv(_feeDenominator, _sellTotalFees);\n    require(v0 <= 10, Error('Must keep fees at 10% or less'));\n}\n\nfunction updateMaxWalletAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (15 == _totalSupply * 15 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply * 15 / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxWallet lower than 1.5%'));\n    require(!varg0 | (0xde0b6b3a7640000 == varg0 * 0xde0b6b3a7640000 / varg0), Panic(17)); // arithmetic overflow or underflow\n    _maxWallet = varg0 * 0xde0b6b3a7640000;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction maxTransactionAmount() public nonPayable { \n    return _maxTransactionAmount;\n}\n\nfunction updateSwapTokensAtAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (1 == _totalSupply / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(0x186a0, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 0x186a0, Error('Swap amount cannot be lower than 0.001% total supply.'));\n    require(!_totalSupply | (5 == _totalSupply * 5 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(varg0 <= _totalSupply * 5 / 1000, Error('Swap amount cannot be higher than 0.5% total supply.'));\n    _swapTokensAtAmount = varg0;\n    return bool(1);\n}\n\nfunction buyTotalFees() public nonPayable { \n    return _buyTotalFees;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction swapTokensAtAmount() public nonPayable { \n    return _swapTokensAtAmount;\n}\n\nfunction disableTransferDelay() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _transferDelayEnabled = 0;\n    return bool(1);\n}\n\nfunction buyLiquidityFee() public nonPayable { \n    return _buyLiquidityFee;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(varg0 - address(0x0), Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction sellLiquidityFee() public nonPayable { \n    return _sellLiquidityFee;\n}\n\nfunction maxWallet() public nonPayable { \n    return _maxWallet;\n}\n\nfunction @name_471() private { \n    v0 = v1 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_471.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_471.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@name_471.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_471.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8da5cb5b > v0) {\n            if (0x39509351 > v0) {\n                if (0x1816467f > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x10d5de53 == v0) {\n                        _isExcludedMaxTransactionAmount(address);\n                    } else if (0x1694505e == v0) {\n                        uniswapV2Router();\n                    } else if (0x180b0d7e == v0) {\n                        feeDenominator();\n                    } else {\n                        require(0x18160ddd == v0);\n                        totalSupply();\n                    }\n                } else if (0x203e727e > v0) {\n                    if (0x1816467f == v0) {\n                        updateDevWallet(address);\n                    } else if (0x1a8145bb == v0) {\n                        tokensForLiquidity();\n                    } else {\n                        require(0x1f3fed8f == v0);\n                        tokensForMarketing();\n                    }\n                } else if (0x203e727e == v0) {\n                    updateMaxTxnAmount(uint256);\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x27c8f835 == v0) {\n                    deadAddress();\n                } else {\n                    require(0x313ce567 == v0);\n                    decimals();\n                }\n            } else if (0x715018a6 > v0) {\n                if (0x4fbee193 > v0) {\n                    if (0x39509351 == v0) {\n                        increaseAllowance(address,uint256);\n                    } else if (0x49bd5a5e == v0) {\n                        uniswapV2Pair();\n                    } else {\n                        require(0x4a62bb65 == v0);\n                        limitsInEffect();\n                    }\n                } else if (0x4fbee193 == v0) {\n                    isExcludedFromFees(address);\n                } else if (0x6a486a8e == v0) {\n                    sellTotalFees();\n                } else if (0x6ddd1713 == v0) {\n                    swapEnabled();\n                } else {\n                    require(0x70a08231 == v0);\n                    balanceOf(address);\n                }\n            } else if (0x75f0a874 > v0) {\n                if (0x715018a6 == v0) {\n                    renounceOwnership();\n                } else if (0x751039fc == v0) {\n                    removeLimits();\n                } else {\n                    require(0x7571336a == v0);\n                    excludeFromMaxTransaction(address,bool);\n                }\n            } else if (0x75f0a874 == v0) {\n                marketingWallet();\n            } else if (0x7bce5a04 == v0) {\n                buyMarketingFee();\n            } else if (0x8095d564 == v0) {\n                updateBuyFees(uint256,uint256,uint256);\n            } else {\n                require(0x8a8c523c == v0);\n                enableTrading();\n            }\n        } else if (0xc0246668 > v0) {\n            if (0x9fccce32 > v0) {\n                if (0x924de9b7 > v0) {\n                    if (0x8da5cb5b == v0) {\n                        owner();\n                    } else if (0x8ea5220f == v0) {\n                        devWallet();\n                    } else {\n                        require(0x92136913 == v0);\n                        sellMarketingFee();\n                    }\n                } else if (0x924de9b7 == v0) {\n                    updateSwapEnabled(bool);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x9a7a23d6 == v0) {\n                    setAutomatedMarketMakerPair(address,bool);\n                } else {\n                    require(0x9c3b4fdc == v0);\n                    buyDevFee();\n                }\n            } else if (0xa9059cbb > v0) {\n                if (0x9fccce32 == v0) {\n                    tokensForDev();\n                } else if (0xa0d82dc5 == v0) {\n                    sellDevFee();\n                } else {\n                    require(0xa457c2d7 == v0);\n                    decreaseAllowance(address,uint256);\n                }\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xaacebbe3 == v0) {\n                updateMarketingWallet(address);\n            } else if (0xb62496f5 == v0) {\n                automatedMarketMakerPairs(address);\n            } else {\n                require(0xbbc0c742 == v0);\n                tradingActive();\n            }\n        } else if (0xdd62ed3e > v0) {\n            if (0xc876d0b9 > v0) {\n                if (0xc0246668 == v0) {\n                    excludeFromFees(address,bool);\n                } else if (0xc17b5b8c == v0) {\n                    updateSellFees(uint256,uint256,uint256);\n                } else {\n                    require(0xc18bc195 == v0);\n                    updateMaxWalletAmount(uint256);\n                }\n            } else if (0xc876d0b9 == v0) {\n                transferDelayEnabled();\n            } else if (0xc8c8ebe4 == v0) {\n                maxTransactionAmount();\n            } else if (0xd257b34f == v0) {\n                updateSwapTokensAtAmount(uint256);\n            } else {\n                require(0xd85ba063 == v0);\n                buyTotalFees();\n            }\n        } else if (0xf11a24d3 > v0) {\n            if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe2f45605 == v0) {\n                swapTokensAtAmount();\n            } else {\n                require(0xe884f260 == v0);\n                disableTransferDelay();\n            }\n        } else if (0xf11a24d3 == v0) {\n            buyLiquidityFee();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf6374342 == v0) {\n            sellLiquidityFee();\n        } else {\n            require(0xf8b45b05 == v0);\n            maxWallet();\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 19:08 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_471; // STORAGE[0x3]\nuint256[] _@symbol_481; // STORAGE[0x4]\nuint256 _maxTransactionAmount; // STORAGE[0x8]\nuint256 _swapTokensAtAmount; // STORAGE[0x9]\nuint256 _maxWallet; // STORAGE[0xa]\nmapping (uint256 => uint256) owner_c; // STORAGE[0xc]\nuint256 _buyTotalFees; // STORAGE[0xf]\nuint256 _buyMarketingFee; // STORAGE[0x10]\nuint256 _buyLiquidityFee; // STORAGE[0x11]\nuint256 _buyDevFee; // STORAGE[0x12]\nuint256 _sellTotalFees; // STORAGE[0x13]\nuint256 _sellMarketingFee; // STORAGE[0x14]\nuint256 _sellLiquidityFee; // STORAGE[0x15]\nuint256 _sellDevFee; // STORAGE[0x16]\nuint256 _feeDenominator; // STORAGE[0x17]\nuint256 _tokensForMarketing; // STORAGE[0x18]\nuint256 _tokensForLiquidity; // STORAGE[0x19]\nuint256 _tokensForDev; // STORAGE[0x1a]\nuint256 stor_1b; // STORAGE[0x1b]\nmapping (uint256 => uint256) _isExcludedFromFees; // STORAGE[0x1c]\nmapping (uint256 => uint256) __isExcludedMaxTransactionAmount; // STORAGE[0x1d]\nmapping (uint256 => uint256) _automatedMarketMakerPairs; // STORAGE[0x1e]\nuint256 _limitsInEffect; // STORAGE[0xb] bytes 0 to 0\nuint256 _tradingActive; // STORAGE[0xb] bytes 1 to 1\nuint256 _swapEnabled; // STORAGE[0xb] bytes 2 to 2\nuint256 _transferDelayEnabled; // STORAGE[0xe] bytes 0 to 0\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _marketingWallet; // STORAGE[0x6] bytes 0 to 19\nuint256 _devWallet; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_5_20_20; // STORAGE[0x5] bytes 20 to 20\n\n\n// Events\ndevWalletUpdated(address, address);\nOwnershipTransferred(address, address);\nmarketingWalletUpdated(address, address);\nExcludeFromFees(address, bool);\nApproval(address, address, uint256);\nSetAutomatedMarketMakerPair(address, bool);\nTransfer(address, address, uint256);\nSwapAndLiquify(uint256, uint256, uint256);\n\nfunction @symbol_481() private { \n    v0 = v1 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_481.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_481.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@symbol_481.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_481.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_892(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2933(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    if (varg0 - 0) {\n        if (_limitsInEffect) {\n            v0 = v1 = address(varg2) != _owner;\n            if (!bool(address(varg2) == _owner)) {\n                v0 = v2 = address(varg1) != _owner;\n            }\n            if (v0) {\n                v0 = v3 = address(varg1) != address(0x0);\n            }\n            if (v0) {\n                v0 = v4 = address(varg1) != address(0xdead);\n            }\n            if (v0) {\n                v0 = v5 = !stor_5_20_20;\n            }\n            if (v0) {\n                if (!_tradingActive) {\n                    v6 = v7 = uint8(_isExcludedFromFees[address(address(varg2))]);\n                    if (!v7) {\n                        v6 = v8 = uint8(_isExcludedFromFees[address(address(varg1))]);\n                    }\n                    require(v6, Error('Trading is not active.'));\n                }\n                if (_transferDelayEnabled) {\n                    v9 = v10 = address(varg1) != _owner;\n                    if (!bool(address(varg1) == _owner)) {\n                        v9 = v11 = address(varg1) != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n                    }\n                    if (v9) {\n                        v9 = v12 = address(varg1) != address(0xacece14434d6b20f4131bf5c953a73f918100137);\n                    }\n                    if (v9) {\n                        require(owner_c[address(tx.origin)] < block.number, Error('_transfer:: Transfer Delay enabled. Only one purchase per block allowed.'));\n                        owner_c[address(tx.origin)] = block.number;\n                    }\n                }\n                v13 = v14 = uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n                if (v14) {\n                    v13 = v15 = !uint8(__isExcludedMaxTransactionAmount[address(address(varg1))]);\n                }\n                if (!v13) {\n                    v16 = v17 = uint8(_automatedMarketMakerPairs[address(address(varg1))]);\n                    if (v17) {\n                        v16 = v18 = !uint8(__isExcludedMaxTransactionAmount[address(address(varg2))]);\n                    }\n                    if (!v16) {\n                        if (!uint8(__isExcludedMaxTransactionAmount[address(address(varg1))])) {\n                            require(varg0 <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                            require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                        }\n                    } else {\n                        require(varg0 <= _maxTransactionAmount, Error('Sell transfer amount exceeds the maxTransactionAmount.'));\n                    }\n                } else {\n                    require(varg0 <= _maxTransactionAmount, Error('Buy transfer amount exceeds the maxTransactionAmount.'));\n                    require(varg0 <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                    require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                }\n            }\n        }\n        v19 = v20 = _balanceOf[address(this)] >= _swapTokensAtAmount;\n        if (!bool(_balanceOf[address(this)] < _swapTokensAtAmount)) {\n            v19 = v21 = _swapEnabled;\n        }\n        if (v19) {\n            v19 = v22 = !stor_5_20_20;\n        }\n        if (v19) {\n            v19 = v23 = !uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n        }\n        if (v19) {\n            v19 = v24 = !uint8(_isExcludedFromFees[address(address(varg2))]);\n        }\n        if (v19) {\n            v19 = v25 = !uint8(_isExcludedFromFees[address(address(varg1))]);\n        }\n        if (v19) {\n            stor_5_20_20 = 1;\n            v26 = v27 = _balanceOf[address(this)];\n            require(_tokensForLiquidity <= _tokensForLiquidity + _tokensForMarketing, Panic(17)); // arithmetic overflow or underflow\n            require(_tokensForLiquidity + _tokensForMarketing <= _tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(17)); // arithmetic overflow or underflow\n            v28 = v29 = v27 == 0;\n            if (v27 != 0) {\n                v28 = _tokensForLiquidity + _tokensForMarketing + _tokensForDev == 0;\n            }\n            if (!v28) {\n                require(!_swapTokensAtAmount | (20 == _swapTokensAtAmount * 20 / _swapTokensAtAmount), Panic(17)); // arithmetic overflow or underflow\n                if (v27 > _swapTokensAtAmount * 20) {\n                    v26 = _swapTokensAtAmount * 20;\n                    require(!_swapTokensAtAmount | (20 == v26 / _swapTokensAtAmount), Panic(17)); // arithmetic overflow or underflow\n                }\n                require(!v26 | (_tokensForLiquidity == v26 * _tokensForLiquidity / v26), Panic(17)); // arithmetic overflow or underflow\n                require(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(18)); // division by zero\n                require(2, Panic(18)); // division by zero\n                v30 = v26 * _tokensForLiquidity / (_tokensForLiquidity + _tokensForMarketing + _tokensForDev) >> 1;\n                v31 = _SafeSub('SafeMath: subtraction overflow', v30, v26);\n                require(2 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n                v32 = new address[](2);\n                if (2) {\n                    CALLDATACOPY(v32.data, msg.data.length, 64);\n                }\n                require(0 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v33 = v32.data;\n                v32[0] = address(this);\n                v34, /* address */ v35 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH().gas(msg.gas);\n                require(bool(v34), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                validator_revert_t_address(v35);\n                require(1 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v32[1] = address(v35);\n                @_approve_892(v31, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                v36 = new address[](v32.length);\n                v37 = v38 = v36.data;\n                v39 = v40 = v32.data;\n                v41 = v42 = 0;\n                while (v41 < v32.length) {\n                    MEM[v37] = address(MEM[v39]);\n                    v37 = v37 + 32;\n                    v39 = v39 + 32;\n                    v41 = v41 + 1;\n                }\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v43 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).swapExactTokensForETHSupportingFeeOnTransferTokens(v31, 0, v36, address(this), block.timestamp, v44, address(this)).gas(msg.gas);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v45 = _SafeSub('SafeMath: subtraction overflow', this.balance, this.balance);\n                v46 = @mul_1006(_tokensForMarketing, v45);\n                v47 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v46);\n                v48 = @mul_1006(_tokensForDev, v45);\n                v49 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v48);\n                require(v45 - v47 <= v45, Panic(17)); // arithmetic overflow or underflow\n                require(v45 - v47 - v49 <= v45 - v47, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = 0;\n                _tokensForMarketing = 0;\n                _tokensForDev = 0;\n                v50, /* uint256 */ v51 = _devWallet.call().value(v49).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v52 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v52.data, 0, RETURNDATASIZE());\n                }\n                v53 = v54 = v30 > 0;\n                if (v54) {\n                    v53 = v45 - v47 - v49 > 0;\n                }\n                if (v53) {\n                    @_approve_892(v30, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                    v55, /* uint256 */ v56, /* uint256 */ v57, /* uint256 */ v58 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).addLiquidityETH(address(this), v30, 0, 0, address(0xdead), block.timestamp).value(v45 - v47 - v49).gas(msg.gas);\n                    require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    validator_revert_t_uint256(v56);\n                    validator_revert_t_uint256(v57);\n                    validator_revert_t_uint256(v58);\n                    emit SwapAndLiquify(v31, v45 - v47 - v49, _tokensForLiquidity);\n                }\n                v59, /* uint256 */ v60 = _marketingWallet.call().value(this.balance).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v61 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v61.data, 0, RETURNDATASIZE());\n                }\n            }\n            stor_5_20_20 = 0;\n        }\n        v62 = v63 = !stor_5_20_20;\n        v64 = v65 = uint8(_isExcludedFromFees[address(address(varg2))]);\n        if (!v65) {\n            v64 = v66 = uint8(_isExcludedFromFees[address(address(varg1))]);\n        }\n        if (v64) {\n            v62 = v67 = 0;\n        }\n        v68 = v69 = 0;\n        if (v62) {\n            v70 = v71 = uint8(_automatedMarketMakerPairs[address(address(varg1))]);\n            if (v71) {\n                v70 = v72 = _sellTotalFees > 0;\n            }\n            if (!v70) {\n                v73 = v74 = uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n                if (v74) {\n                    v73 = v75 = _buyTotalFees > 0;\n                }\n                if (v73) {\n                    v76 = @mul_1006(_buyTotalFees, varg0);\n                    v68 = v77 = _SafeDiv(_feeDenominator, v76);\n                    require(!v77 | (_buyLiquidityFee == v77 * _buyLiquidityFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForLiquidity <= _tokensForLiquidity + v77 * _buyLiquidityFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForLiquidity = _tokensForLiquidity + v77 * _buyLiquidityFee / _buyTotalFees;\n                    require(!v77 | (_buyDevFee == v77 * _buyDevFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForDev <= _tokensForDev + v77 * _buyDevFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForDev = _tokensForDev + v77 * _buyDevFee / _buyTotalFees;\n                    require(!v77 | (_buyMarketingFee == v77 * _buyMarketingFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForMarketing <= _tokensForMarketing + v77 * _buyMarketingFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForMarketing = _tokensForMarketing + v77 * _buyMarketingFee / _buyTotalFees;\n                }\n            } else {\n                v78 = @mul_1006(_sellTotalFees, varg0);\n                v68 = v79 = _SafeDiv(_feeDenominator, v78);\n                require(!v79 | (_sellLiquidityFee == v79 * _sellLiquidityFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForLiquidity <= _tokensForLiquidity + v79 * _sellLiquidityFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = _tokensForLiquidity + v79 * _sellLiquidityFee / _sellTotalFees;\n                require(!v79 | (_sellDevFee == v79 * _sellDevFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForDev <= _tokensForDev + v79 * _sellDevFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForDev = _tokensForDev + v79 * _sellDevFee / _sellTotalFees;\n                require(!v79 | (_sellMarketingFee == v79 * _sellMarketingFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForMarketing <= _tokensForMarketing + v79 * _sellMarketingFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForMarketing = _tokensForMarketing + v79 * _sellMarketingFee / _sellTotalFees;\n            }\n            if (v68 > 0) {\n                @_transfer_736(v68, this, varg2);\n            }\n            varg0 = v80 = varg0 - v68;\n            require(v80 <= varg0, Panic(17)); // arithmetic overflow or underflow\n        }\n        @_transfer_736(varg0, varg1, varg2);\n    } else {\n        @_transfer_736(0, varg1, varg2);\n    }\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 = v2 + 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0, v4, 'SafeMath: division by zero'));\n    }\n}\n\nfunction @_transfer_736(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[address(varg2)]);\n    _balanceOf[address(varg2)] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v1;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_471();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_approve_892(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction @mul_1006(uint256 varg0, uint256 varg1) private { \n    if (varg1 - 0) {\n        v0 = varg1 * varg0;\n        require(!varg1 | (varg0 == v0 / varg1), Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(v0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction _isExcludedMaxTransactionAmount(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(__isExcludedMaxTransactionAmount[varg0]));\n}\n\nfunction validator_revert_t_address(address varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction validator_revert_t_uint256(uint256 varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n}\n\nfunction feeDenominator() public nonPayable { \n    return _feeDenominator;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction updateDevWallet(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit devWalletUpdated(varg0, _devWallet);\n    _devWallet = varg0;\n}\n\nfunction tokensForLiquidity() public nonPayable { \n    return _tokensForLiquidity;\n}\n\nfunction tokensForMarketing() public nonPayable { \n    return _tokensForMarketing;\n}\n\nfunction updateMaxTxnAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (5 == _totalSupply * 5 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply * 5 / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxTransactionAmount lower than 0.5%'));\n    require(!varg0 | (0xde0b6b3a7640000 == varg0 * 0xde0b6b3a7640000 / varg0), Panic(17)); // arithmetic overflow or underflow\n    _maxTransactionAmount = varg0 * 0xde0b6b3a7640000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    validator_revert_t_uint256(varg2);\n    @_transfer_2933(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_892(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction deadAddress() public nonPayable { \n    return address(0xdead);\n}\n\nfunction decimals() public nonPayable { \n    return uint8(18);\n}\n\nfunction () public payable { \n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    v0 = _SafeAdd(varg1, _allowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return address(0xacece14434d6b20f4131bf5c953a73f918100137);\n}\n\nfunction limitsInEffect() public nonPayable { \n    return _limitsInEffect;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_isExcludedFromFees[address(address(varg0))]));\n}\n\nfunction sellTotalFees() public nonPayable { \n    return _sellTotalFees;\n}\n\nfunction swapEnabled() public nonPayable { \n    return _swapEnabled;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, address(0x0));\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _limitsInEffect = 0;\n    return bool(1);\n}\n\nfunction excludeFromMaxTransaction(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    __isExcludedMaxTransactionAmount[varg0] = varg1 | bytes31(__isExcludedMaxTransactionAmount[address(address(varg0))]);\n}\n\nfunction marketingWallet() public nonPayable { \n    return _marketingWallet;\n}\n\nfunction buyMarketingFee() public nonPayable { \n    return _buyMarketingFee;\n}\n\nfunction updateBuyFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_uint256(varg0);\n    validator_revert_t_uint256(varg1);\n    validator_revert_t_uint256(varg2);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _buyMarketingFee = varg0;\n    _buyLiquidityFee = varg1;\n    _buyDevFee = varg2;\n    require(_buyMarketingFee <= _buyMarketingFee + _buyLiquidityFee, Panic(17)); // arithmetic overflow or underflow\n    require(_buyMarketingFee + _buyLiquidityFee <= _buyMarketingFee + _buyLiquidityFee + _buyDevFee, Panic(17)); // arithmetic overflow or underflow\n    _buyTotalFees = _buyMarketingFee + _buyLiquidityFee + _buyDevFee;\n    v0 = _SafeDiv(_feeDenominator, _buyTotalFees);\n    require(v0 <= 10, Error('Must keep fees at 10% or less'));\n}\n\nfunction enableTrading() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _tradingActive = 1;\n    _swapEnabled = 1;\n    stor_1b = block.number;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction devWallet() public nonPayable { \n    return _devWallet;\n}\n\nfunction sellMarketingFee() public nonPayable { \n    return _sellMarketingFee;\n}\n\nfunction updateSwapEnabled(bool varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    require(varg0 == varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _swapEnabled = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_481();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction setAutomatedMarketMakerPair(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(varg0 - address(0xacece14434d6b20f4131bf5c953a73f918100137), Error('The pair cannot be removed from automatedMarketMakerPairs'));\n    _automatedMarketMakerPairs[varg0] = varg1 | bytes31(_automatedMarketMakerPairs[address(address(varg0))]);\n    emit SetAutomatedMarketMakerPair(varg0, varg1);\n}\n\nfunction buyDevFee() public nonPayable { \n    return _buyDevFee;\n}\n\nfunction tokensForDev() public nonPayable { \n    return _tokensForDev;\n}\n\nfunction sellDevFee() public nonPayable { \n    return _sellDevFee;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _allowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_transfer_2933(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateMarketingWallet(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit marketingWalletUpdated(varg0, _marketingWallet);\n    _marketingWallet = varg0;\n}\n\nfunction automatedMarketMakerPairs(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_automatedMarketMakerPairs[varg0]));\n}\n\nfunction tradingActive() public nonPayable { \n    return _tradingActive;\n}\n\nfunction excludeFromFees(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _isExcludedFromFees[varg0] = varg1 | bytes31(_isExcludedFromFees[address(address(varg0))]);\n    emit ExcludeFromFees(varg0, varg1);\n}\n\nfunction updateSellFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_uint256(varg0);\n    validator_revert_t_uint256(varg1);\n    validator_revert_t_uint256(varg2);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _sellMarketingFee = varg0;\n    _sellLiquidityFee = varg1;\n    _sellDevFee = varg2;\n    require(_sellMarketingFee <= _sellMarketingFee + _sellLiquidityFee, Panic(17)); // arithmetic overflow or underflow\n    require(_sellMarketingFee + _sellLiquidityFee <= _sellMarketingFee + _sellLiquidityFee + _sellDevFee, Panic(17)); // arithmetic overflow or underflow\n    _sellTotalFees = _sellMarketingFee + _sellLiquidityFee + _sellDevFee;\n    v0 = _SafeDiv(_feeDenominator, _sellTotalFees);\n    require(v0 <= 10, Error('Must keep fees at 10% or less'));\n}\n\nfunction updateMaxWalletAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (15 == _totalSupply * 15 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply * 15 / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxWallet lower than 1.5%'));\n    require(!varg0 | (0xde0b6b3a7640000 == varg0 * 0xde0b6b3a7640000 / varg0), Panic(17)); // arithmetic overflow or underflow\n    _maxWallet = varg0 * 0xde0b6b3a7640000;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction maxTransactionAmount() public nonPayable { \n    return _maxTransactionAmount;\n}\n\nfunction updateSwapTokensAtAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (1 == _totalSupply / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(0x186a0, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 0x186a0, Error('Swap amount cannot be lower than 0.001% total supply.'));\n    require(!_totalSupply | (5 == _totalSupply * 5 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(varg0 <= _totalSupply * 5 / 1000, Error('Swap amount cannot be higher than 0.5% total supply.'));\n    _swapTokensAtAmount = varg0;\n    return bool(1);\n}\n\nfunction buyTotalFees() public nonPayable { \n    return _buyTotalFees;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction swapTokensAtAmount() public nonPayable { \n    return _swapTokensAtAmount;\n}\n\nfunction disableTransferDelay() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _transferDelayEnabled = 0;\n    return bool(1);\n}\n\nfunction buyLiquidityFee() public nonPayable { \n    return _buyLiquidityFee;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(varg0 - address(0x0), Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction sellLiquidityFee() public nonPayable { \n    return _sellLiquidityFee;\n}\n\nfunction maxWallet() public nonPayable { \n    return _maxWallet;\n}\n\nfunction @name_471() private { \n    v0 = v1 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_471.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_471.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@name_471.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_471.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8da5cb5b > v0) {\n            if (0x39509351 > v0) {\n                if (0x1816467f > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x10d5de53 == v0) {\n                        _isExcludedMaxTransactionAmount(address);\n                    } else if (0x1694505e == v0) {\n                        uniswapV2Router();\n                    } else if (0x180b0d7e == v0) {\n                        feeDenominator();\n                    } else {\n                        require(0x18160ddd == v0);\n                        totalSupply();\n                    }\n                } else if (0x203e727e > v0) {\n                    if (0x1816467f == v0) {\n                        updateDevWallet(address);\n                    } else if (0x1a8145bb == v0) {\n                        tokensForLiquidity();\n                    } else {\n                        require(0x1f3fed8f == v0);\n                        tokensForMarketing();\n                    }\n                } else if (0x203e727e == v0) {\n                    updateMaxTxnAmount(uint256);\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x27c8f835 == v0) {\n                    deadAddress();\n                } else {\n                    require(0x313ce567 == v0);\n                    decimals();\n                }\n            } else if (0x715018a6 > v0) {\n                if (0x4fbee193 > v0) {\n                    if (0x39509351 == v0) {\n                        increaseAllowance(address,uint256);\n                    } else if (0x49bd5a5e == v0) {\n                        uniswapV2Pair();\n                    } else {\n                        require(0x4a62bb65 == v0);\n                        limitsInEffect();\n                    }\n                } else if (0x4fbee193 == v0) {\n                    isExcludedFromFees(address);\n                } else if (0x6a486a8e == v0) {\n                    sellTotalFees();\n                } else if (0x6ddd1713 == v0) {\n                    swapEnabled();\n                } else {\n                    require(0x70a08231 == v0);\n                    balanceOf(address);\n                }\n            } else if (0x75f0a874 > v0) {\n                if (0x715018a6 == v0) {\n                    renounceOwnership();\n                } else if (0x751039fc == v0) {\n                    removeLimits();\n                } else {\n                    require(0x7571336a == v0);\n                    excludeFromMaxTransaction(address,bool);\n                }\n            } else if (0x75f0a874 == v0) {\n                marketingWallet();\n            } else if (0x7bce5a04 == v0) {\n                buyMarketingFee();\n            } else if (0x8095d564 == v0) {\n                updateBuyFees(uint256,uint256,uint256);\n            } else {\n                require(0x8a8c523c == v0);\n                enableTrading();\n            }\n        } else if (0xc0246668 > v0) {\n            if (0x9fccce32 > v0) {\n                if (0x924de9b7 > v0) {\n                    if (0x8da5cb5b == v0) {\n                        owner();\n                    } else if (0x8ea5220f == v0) {\n                        devWallet();\n                    } else {\n                        require(0x92136913 == v0);\n                        sellMarketingFee();\n                    }\n                } else if (0x924de9b7 == v0) {\n                    updateSwapEnabled(bool);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x9a7a23d6 == v0) {\n                    setAutomatedMarketMakerPair(address,bool);\n                } else {\n                    require(0x9c3b4fdc == v0);\n                    buyDevFee();\n                }\n            } else if (0xa9059cbb > v0) {\n                if (0x9fccce32 == v0) {\n                    tokensForDev();\n                } else if (0xa0d82dc5 == v0) {\n                    sellDevFee();\n                } else {\n                    require(0xa457c2d7 == v0);\n                    decreaseAllowance(address,uint256);\n                }\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xaacebbe3 == v0) {\n                updateMarketingWallet(address);\n            } else if (0xb62496f5 == v0) {\n                automatedMarketMakerPairs(address);\n            } else {\n                require(0xbbc0c742 == v0);\n                tradingActive();\n            }\n        } else if (0xdd62ed3e > v0) {\n            if (0xc876d0b9 > v0) {\n                if (0xc0246668 == v0) {\n                    excludeFromFees(address,bool);\n                } else if (0xc17b5b8c == v0) {\n                    updateSellFees(uint256,uint256,uint256);\n                } else {\n                    require(0xc18bc195 == v0);\n                    updateMaxWalletAmount(uint256);\n                }\n            } else if (0xc876d0b9 == v0) {\n                transferDelayEnabled();\n            } else if (0xc8c8ebe4 == v0) {\n                maxTransactionAmount();\n            } else if (0xd257b34f == v0) {\n                updateSwapTokensAtAmount(uint256);\n            } else {\n                require(0xd85ba063 == v0);\n                buyTotalFees();\n            }\n        } else if (0xf11a24d3 > v0) {\n            if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe2f45605 == v0) {\n                swapTokensAtAmount();\n            } else {\n                require(0xe884f260 == v0);\n                disableTransferDelay();\n            }\n        } else if (0xf11a24d3 == v0) {\n            buyLiquidityFee();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf6374342 == v0) {\n            sellLiquidityFee();\n        } else {\n            require(0xf8b45b05 == v0);\n            maxWallet();\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 19:08 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_471; // STORAGE[0x3]\nuint256[] _@symbol_481; // STORAGE[0x4]\nuint256 _maxTransactionAmount; // STORAGE[0x8]\nuint256 _swapTokensAtAmount; // STORAGE[0x9]\nuint256 _maxWallet; // STORAGE[0xa]\nmapping (uint256 => uint256) owner_c; // STORAGE[0xc]\nuint256 _buyTotalFees; // STORAGE[0xf]\nuint256 _buyMarketingFee; // STORAGE[0x10]\nuint256 _buyLiquidityFee; // STORAGE[0x11]\nuint256 _buyDevFee; // STORAGE[0x12]\nuint256 _sellTotalFees; // STORAGE[0x13]\nuint256 _sellMarketingFee; // STORAGE[0x14]\nuint256 _sellLiquidityFee; // STORAGE[0x15]\nuint256 _sellDevFee; // STORAGE[0x16]\nuint256 _feeDenominator; // STORAGE[0x17]\nuint256 _tokensForMarketing; // STORAGE[0x18]\nuint256 _tokensForLiquidity; // STORAGE[0x19]\nuint256 _tokensForDev; // STORAGE[0x1a]\nuint256 stor_1b; // STORAGE[0x1b]\nmapping (uint256 => uint256) _isExcludedFromFees; // STORAGE[0x1c]\nmapping (uint256 => uint256) __isExcludedMaxTransactionAmount; // STORAGE[0x1d]\nmapping (uint256 => uint256) _automatedMarketMakerPairs; // STORAGE[0x1e]\nuint256 _limitsInEffect; // STORAGE[0xb] bytes 0 to 0\nuint256 _tradingActive; // STORAGE[0xb] bytes 1 to 1\nuint256 _swapEnabled; // STORAGE[0xb] bytes 2 to 2\nuint256 _transferDelayEnabled; // STORAGE[0xe] bytes 0 to 0\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _marketingWallet; // STORAGE[0x6] bytes 0 to 19\nuint256 _devWallet; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_5_20_20; // STORAGE[0x5] bytes 20 to 20\n\n\n// Events\ndevWalletUpdated(address, address);\nOwnershipTransferred(address, address);\nmarketingWalletUpdated(address, address);\nExcludeFromFees(address, bool);\nApproval(address, address, uint256);\nSetAutomatedMarketMakerPair(address, bool);\nTransfer(address, address, uint256);\nSwapAndLiquify(uint256, uint256, uint256);\n\nfunction @symbol_481() private { \n    v0 = v1 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_481.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_481.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@symbol_481.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_481.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_892(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2933(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    if (varg0 - 0) {\n        if (_limitsInEffect) {\n            v0 = v1 = address(varg2) != _owner;\n            if (!bool(address(varg2) == _owner)) {\n                v0 = v2 = address(varg1) != _owner;\n            }\n            if (v0) {\n                v0 = v3 = address(varg1) != address(0x0);\n            }\n            if (v0) {\n                v0 = v4 = address(varg1) != address(0xdead);\n            }\n            if (v0) {\n                v0 = v5 = !stor_5_20_20;\n            }\n            if (v0) {\n                if (!_tradingActive) {\n                    v6 = v7 = uint8(_isExcludedFromFees[address(address(varg2))]);\n                    if (!v7) {\n                        v6 = v8 = uint8(_isExcludedFromFees[address(address(varg1))]);\n                    }\n                    require(v6, Error('Trading is not active.'));\n                }\n                if (_transferDelayEnabled) {\n                    v9 = v10 = address(varg1) != _owner;\n                    if (!bool(address(varg1) == _owner)) {\n                        v9 = v11 = address(varg1) != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n                    }\n                    if (v9) {\n                        v9 = v12 = address(varg1) != address(0xacece14434d6b20f4131bf5c953a73f918100137);\n                    }\n                    if (v9) {\n                        require(owner_c[address(tx.origin)] < block.number, Error('_transfer:: Transfer Delay enabled. Only one purchase per block allowed.'));\n                        owner_c[address(tx.origin)] = block.number;\n                    }\n                }\n                v13 = v14 = uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n                if (v14) {\n                    v13 = v15 = !uint8(__isExcludedMaxTransactionAmount[address(address(varg1))]);\n                }\n                if (!v13) {\n                    v16 = v17 = uint8(_automatedMarketMakerPairs[address(address(varg1))]);\n                    if (v17) {\n                        v16 = v18 = !uint8(__isExcludedMaxTransactionAmount[address(address(varg2))]);\n                    }\n                    if (!v16) {\n                        if (!uint8(__isExcludedMaxTransactionAmount[address(address(varg1))])) {\n                            require(varg0 <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                            require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                        }\n                    } else {\n                        require(varg0 <= _maxTransactionAmount, Error('Sell transfer amount exceeds the maxTransactionAmount.'));\n                    }\n                } else {\n                    require(varg0 <= _maxTransactionAmount, Error('Buy transfer amount exceeds the maxTransactionAmount.'));\n                    require(varg0 <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                    require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                }\n            }\n        }\n        v19 = v20 = _balanceOf[address(this)] >= _swapTokensAtAmount;\n        if (!bool(_balanceOf[address(this)] < _swapTokensAtAmount)) {\n            v19 = v21 = _swapEnabled;\n        }\n        if (v19) {\n            v19 = v22 = !stor_5_20_20;\n        }\n        if (v19) {\n            v19 = v23 = !uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n        }\n        if (v19) {\n            v19 = v24 = !uint8(_isExcludedFromFees[address(address(varg2))]);\n        }\n        if (v19) {\n            v19 = v25 = !uint8(_isExcludedFromFees[address(address(varg1))]);\n        }\n        if (v19) {\n            stor_5_20_20 = 1;\n            v26 = v27 = _balanceOf[address(this)];\n            require(_tokensForLiquidity <= _tokensForLiquidity + _tokensForMarketing, Panic(17)); // arithmetic overflow or underflow\n            require(_tokensForLiquidity + _tokensForMarketing <= _tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(17)); // arithmetic overflow or underflow\n            v28 = v29 = v27 == 0;\n            if (v27 != 0) {\n                v28 = _tokensForLiquidity + _tokensForMarketing + _tokensForDev == 0;\n            }\n            if (!v28) {\n                require(!_swapTokensAtAmount | (20 == _swapTokensAtAmount * 20 / _swapTokensAtAmount), Panic(17)); // arithmetic overflow or underflow\n                if (v27 > _swapTokensAtAmount * 20) {\n                    v26 = _swapTokensAtAmount * 20;\n                    require(!_swapTokensAtAmount | (20 == v26 / _swapTokensAtAmount), Panic(17)); // arithmetic overflow or underflow\n                }\n                require(!v26 | (_tokensForLiquidity == v26 * _tokensForLiquidity / v26), Panic(17)); // arithmetic overflow or underflow\n                require(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(18)); // division by zero\n                require(2, Panic(18)); // division by zero\n                v30 = v26 * _tokensForLiquidity / (_tokensForLiquidity + _tokensForMarketing + _tokensForDev) >> 1;\n                v31 = _SafeSub('SafeMath: subtraction overflow', v30, v26);\n                require(2 <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n                v32 = new address[](2);\n                if (2) {\n                    CALLDATACOPY(v32.data, msg.data.length, 64);\n                }\n                require(0 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v33 = v32.data;\n                v32[0] = address(this);\n                v34, /* address */ v35 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH().gas(msg.gas);\n                require(bool(v34), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                validator_revert_t_address(v35);\n                require(1 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v32[1] = address(v35);\n                @_approve_892(v31, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                v36 = new address[](v32.length);\n                v37 = v38 = v36.data;\n                v39 = v40 = v32.data;\n                v41 = v42 = 0;\n                while (v41 < v32.length) {\n                    MEM[v37] = address(MEM[v39]);\n                    v37 = v37 + 32;\n                    v39 = v39 + 32;\n                    v41 = v41 + 1;\n                }\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v43 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).swapExactTokensForETHSupportingFeeOnTransferTokens(v31, 0, v36, address(this), block.timestamp, v44, address(this)).gas(msg.gas);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v45 = _SafeSub('SafeMath: subtraction overflow', this.balance, this.balance);\n                v46 = @mul_1006(_tokensForMarketing, v45);\n                v47 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v46);\n                v48 = @mul_1006(_tokensForDev, v45);\n                v49 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v48);\n                require(v45 - v47 <= v45, Panic(17)); // arithmetic overflow or underflow\n                require(v45 - v47 - v49 <= v45 - v47, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = 0;\n                _tokensForMarketing = 0;\n                _tokensForDev = 0;\n                v50, /* uint256 */ v51 = _devWallet.call().value(v49).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v52 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v52.data, 0, RETURNDATASIZE());\n                }\n                v53 = v54 = v30 > 0;\n                if (v54) {\n                    v53 = v45 - v47 - v49 > 0;\n                }\n                if (v53) {\n                    @_approve_892(v30, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                    v55, /* uint256 */ v56, /* uint256 */ v57, /* uint256 */ v58 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).addLiquidityETH(address(this), v30, 0, 0, address(0xdead), block.timestamp).value(v45 - v47 - v49).gas(msg.gas);\n                    require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    validator_revert_t_uint256(v56);\n                    validator_revert_t_uint256(v57);\n                    validator_revert_t_uint256(v58);\n                    emit SwapAndLiquify(v31, v45 - v47 - v49, _tokensForLiquidity);\n                }\n                v59, /* uint256 */ v60 = _marketingWallet.call().value(this.balance).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v61 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v61.data, 0, RETURNDATASIZE());\n                }\n            }\n            stor_5_20_20 = 0;\n        }\n        v62 = v63 = !stor_5_20_20;\n        v64 = v65 = uint8(_isExcludedFromFees[address(address(varg2))]);\n        if (!v65) {\n            v64 = v66 = uint8(_isExcludedFromFees[address(address(varg1))]);\n        }\n        if (v64) {\n            v62 = v67 = 0;\n        }\n        v68 = v69 = 0;\n        if (v62) {\n            v70 = v71 = uint8(_automatedMarketMakerPairs[address(address(varg1))]);\n            if (v71) {\n                v70 = v72 = _sellTotalFees > 0;\n            }\n            if (!v70) {\n                v73 = v74 = uint8(_automatedMarketMakerPairs[address(address(varg2))]);\n                if (v74) {\n                    v73 = v75 = _buyTotalFees > 0;\n                }\n                if (v73) {\n                    v76 = @mul_1006(_buyTotalFees, varg0);\n                    v68 = v77 = _SafeDiv(_feeDenominator, v76);\n                    require(!v77 | (_buyLiquidityFee == v77 * _buyLiquidityFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForLiquidity <= _tokensForLiquidity + v77 * _buyLiquidityFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForLiquidity = _tokensForLiquidity + v77 * _buyLiquidityFee / _buyTotalFees;\n                    require(!v77 | (_buyDevFee == v77 * _buyDevFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForDev <= _tokensForDev + v77 * _buyDevFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForDev = _tokensForDev + v77 * _buyDevFee / _buyTotalFees;\n                    require(!v77 | (_buyMarketingFee == v77 * _buyMarketingFee / v77), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForMarketing <= _tokensForMarketing + v77 * _buyMarketingFee / _buyTotalFees, Panic(17)); // arithmetic overflow or underflow\n                    _tokensForMarketing = _tokensForMarketing + v77 * _buyMarketingFee / _buyTotalFees;\n                }\n            } else {\n                v78 = @mul_1006(_sellTotalFees, varg0);\n                v68 = v79 = _SafeDiv(_feeDenominator, v78);\n                require(!v79 | (_sellLiquidityFee == v79 * _sellLiquidityFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForLiquidity <= _tokensForLiquidity + v79 * _sellLiquidityFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = _tokensForLiquidity + v79 * _sellLiquidityFee / _sellTotalFees;\n                require(!v79 | (_sellDevFee == v79 * _sellDevFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForDev <= _tokensForDev + v79 * _sellDevFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForDev = _tokensForDev + v79 * _sellDevFee / _sellTotalFees;\n                require(!v79 | (_sellMarketingFee == v79 * _sellMarketingFee / v79), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForMarketing <= _tokensForMarketing + v79 * _sellMarketingFee / _sellTotalFees, Panic(17)); // arithmetic overflow or underflow\n                _tokensForMarketing = _tokensForMarketing + v79 * _sellMarketingFee / _sellTotalFees;\n            }\n            if (v68 > 0) {\n                @_transfer_736(v68, this, varg2);\n            }\n            varg0 = v80 = varg0 - v68;\n            require(v80 <= varg0, Panic(17)); // arithmetic overflow or underflow\n        }\n        @_transfer_736(varg0, varg1, varg2);\n    } else {\n        @_transfer_736(0, varg1, varg2);\n    }\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 = v2 + 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0, v4, 'SafeMath: division by zero'));\n    }\n}\n\nfunction @_transfer_736(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[address(varg2)]);\n    _balanceOf[address(varg2)] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v1;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_471();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_approve_892(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction @mul_1006(uint256 varg0, uint256 varg1) private { \n    if (varg1 - 0) {\n        v0 = varg1 * varg0;\n        require(!varg1 | (varg0 == v0 / varg1), Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(v0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction _isExcludedMaxTransactionAmount(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(__isExcludedMaxTransactionAmount[varg0]));\n}\n\nfunction validator_revert_t_address(address varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction validator_revert_t_uint256(uint256 varg0) private { \n    require(varg0 == varg0);\n    return ;\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n}\n\nfunction feeDenominator() public nonPayable { \n    return _feeDenominator;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction updateDevWallet(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit devWalletUpdated(varg0, _devWallet);\n    _devWallet = varg0;\n}\n\nfunction tokensForLiquidity() public nonPayable { \n    return _tokensForLiquidity;\n}\n\nfunction tokensForMarketing() public nonPayable { \n    return _tokensForMarketing;\n}\n\nfunction updateMaxTxnAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (5 == _totalSupply * 5 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply * 5 / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxTransactionAmount lower than 0.5%'));\n    require(!varg0 | (0xde0b6b3a7640000 == varg0 * 0xde0b6b3a7640000 / varg0), Panic(17)); // arithmetic overflow or underflow\n    _maxTransactionAmount = varg0 * 0xde0b6b3a7640000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    validator_revert_t_uint256(varg2);\n    @_transfer_2933(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_892(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction deadAddress() public nonPayable { \n    return address(0xdead);\n}\n\nfunction decimals() public nonPayable { \n    return uint8(18);\n}\n\nfunction () public payable { \n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    v0 = _SafeAdd(varg1, _allowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return address(0xacece14434d6b20f4131bf5c953a73f918100137);\n}\n\nfunction limitsInEffect() public nonPayable { \n    return _limitsInEffect;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_isExcludedFromFees[address(address(varg0))]));\n}\n\nfunction sellTotalFees() public nonPayable { \n    return _sellTotalFees;\n}\n\nfunction swapEnabled() public nonPayable { \n    return _swapEnabled;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, address(0x0));\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _limitsInEffect = 0;\n    return bool(1);\n}\n\nfunction excludeFromMaxTransaction(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    __isExcludedMaxTransactionAmount[varg0] = varg1 | bytes31(__isExcludedMaxTransactionAmount[address(address(varg0))]);\n}\n\nfunction marketingWallet() public nonPayable { \n    return _marketingWallet;\n}\n\nfunction buyMarketingFee() public nonPayable { \n    return _buyMarketingFee;\n}\n\nfunction updateBuyFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_uint256(varg0);\n    validator_revert_t_uint256(varg1);\n    validator_revert_t_uint256(varg2);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _buyMarketingFee = varg0;\n    _buyLiquidityFee = varg1;\n    _buyDevFee = varg2;\n    require(_buyMarketingFee <= _buyMarketingFee + _buyLiquidityFee, Panic(17)); // arithmetic overflow or underflow\n    require(_buyMarketingFee + _buyLiquidityFee <= _buyMarketingFee + _buyLiquidityFee + _buyDevFee, Panic(17)); // arithmetic overflow or underflow\n    _buyTotalFees = _buyMarketingFee + _buyLiquidityFee + _buyDevFee;\n    v0 = _SafeDiv(_feeDenominator, _buyTotalFees);\n    require(v0 <= 10, Error('Must keep fees at 10% or less'));\n}\n\nfunction enableTrading() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _tradingActive = 1;\n    _swapEnabled = 1;\n    stor_1b = block.number;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction devWallet() public nonPayable { \n    return _devWallet;\n}\n\nfunction sellMarketingFee() public nonPayable { \n    return _sellMarketingFee;\n}\n\nfunction updateSwapEnabled(bool varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    require(varg0 == varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _swapEnabled = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_481();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction setAutomatedMarketMakerPair(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(varg0 - address(0xacece14434d6b20f4131bf5c953a73f918100137), Error('The pair cannot be removed from automatedMarketMakerPairs'));\n    _automatedMarketMakerPairs[varg0] = varg1 | bytes31(_automatedMarketMakerPairs[address(address(varg0))]);\n    emit SetAutomatedMarketMakerPair(varg0, varg1);\n}\n\nfunction buyDevFee() public nonPayable { \n    return _buyDevFee;\n}\n\nfunction tokensForDev() public nonPayable { \n    return _tokensForDev;\n}\n\nfunction sellDevFee() public nonPayable { \n    return _sellDevFee;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _allowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_uint256(varg1);\n    @_transfer_2933(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateMarketingWallet(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    emit marketingWalletUpdated(varg0, _marketingWallet);\n    _marketingWallet = varg0;\n}\n\nfunction automatedMarketMakerPairs(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    return bool(uint8(_automatedMarketMakerPairs[varg0]));\n}\n\nfunction tradingActive() public nonPayable { \n    return _tradingActive;\n}\n\nfunction excludeFromFees(address varg0, bool varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    require(varg1 == varg1);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _isExcludedFromFees[varg0] = varg1 | bytes31(_isExcludedFromFees[address(address(varg0))]);\n    emit ExcludeFromFees(varg0, varg1);\n}\n\nfunction updateSellFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    validator_revert_t_uint256(varg0);\n    validator_revert_t_uint256(varg1);\n    validator_revert_t_uint256(varg2);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _sellMarketingFee = varg0;\n    _sellLiquidityFee = varg1;\n    _sellDevFee = varg2;\n    require(_sellMarketingFee <= _sellMarketingFee + _sellLiquidityFee, Panic(17)); // arithmetic overflow or underflow\n    require(_sellMarketingFee + _sellLiquidityFee <= _sellMarketingFee + _sellLiquidityFee + _sellDevFee, Panic(17)); // arithmetic overflow or underflow\n    _sellTotalFees = _sellMarketingFee + _sellLiquidityFee + _sellDevFee;\n    v0 = _SafeDiv(_feeDenominator, _sellTotalFees);\n    require(v0 <= 10, Error('Must keep fees at 10% or less'));\n}\n\nfunction updateMaxWalletAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (15 == _totalSupply * 15 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply * 15 / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxWallet lower than 1.5%'));\n    require(!varg0 | (0xde0b6b3a7640000 == varg0 * 0xde0b6b3a7640000 / varg0), Panic(17)); // arithmetic overflow or underflow\n    _maxWallet = varg0 * 0xde0b6b3a7640000;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction maxTransactionAmount() public nonPayable { \n    return _maxTransactionAmount;\n}\n\nfunction updateSwapTokensAtAmount(uint256 varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_uint256(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(!_totalSupply | (1 == _totalSupply / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(0x186a0, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 0x186a0, Error('Swap amount cannot be lower than 0.001% total supply.'));\n    require(!_totalSupply | (5 == _totalSupply * 5 / _totalSupply), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(varg0 <= _totalSupply * 5 / 1000, Error('Swap amount cannot be higher than 0.5% total supply.'));\n    _swapTokensAtAmount = varg0;\n    return bool(1);\n}\n\nfunction buyTotalFees() public nonPayable { \n    return _buyTotalFees;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    validator_revert_t_address(varg0);\n    validator_revert_t_address(varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction swapTokensAtAmount() public nonPayable { \n    return _swapTokensAtAmount;\n}\n\nfunction disableTransferDelay() public nonPayable { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    _transferDelayEnabled = 0;\n    return bool(1);\n}\n\nfunction buyLiquidityFee() public nonPayable { \n    return _buyLiquidityFee;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    validator_revert_t_address(varg0);\n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    require(varg0 - address(0x0), Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction sellLiquidityFee() public nonPayable { \n    return _sellLiquidityFee;\n}\n\nfunction maxWallet() public nonPayable { \n    return _maxWallet;\n}\n\nfunction @name_471() private { \n    v0 = v1 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_471.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_471.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@name_471.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_471.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8da5cb5b > v0) {\n            if (0x39509351 > v0) {\n                if (0x1816467f > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x10d5de53 == v0) {\n                        _isExcludedMaxTransactionAmount(address);\n                    } else if (0x1694505e == v0) {\n                        uniswapV2Router();\n                    } else if (0x180b0d7e == v0) {\n                        feeDenominator();\n                    } else {\n                        require(0x18160ddd == v0);\n                        totalSupply();\n                    }\n                } else if (0x203e727e > v0) {\n                    if (0x1816467f == v0) {\n                        updateDevWallet(address);\n                    } else if (0x1a8145bb == v0) {\n                        tokensForLiquidity();\n                    } else {\n                        require(0x1f3fed8f == v0);\n                        tokensForMarketing();\n                    }\n                } else if (0x203e727e == v0) {\n                    updateMaxTxnAmount(uint256);\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x27c8f835 == v0) {\n                    deadAddress();\n                } else {\n                    require(0x313ce567 == v0);\n                    decimals();\n                }\n            } else if (0x715018a6 > v0) {\n                if (0x4fbee193 > v0) {\n                    if (0x39509351 == v0) {\n                        increaseAllowance(address,uint256);\n                    } else if (0x49bd5a5e == v0) {\n                        uniswapV2Pair();\n                    } else {\n                        require(0x4a62bb65 == v0);\n                        limitsInEffect();\n                    }\n                } else if (0x4fbee193 == v0) {\n                    isExcludedFromFees(address);\n                } else if (0x6a486a8e == v0) {\n                    sellTotalFees();\n                } else if (0x6ddd1713 == v0) {\n                    swapEnabled();\n                } else {\n                    require(0x70a08231 == v0);\n                    balanceOf(address);\n                }\n            } else if (0x75f0a874 > v0) {\n                if (0x715018a6 == v0) {\n                    renounceOwnership();\n                } else if (0x751039fc == v0) {\n                    removeLimits();\n                } else {\n                    require(0x7571336a == v0);\n                    excludeFromMaxTransaction(address,bool);\n                }\n            } else if (0x75f0a874 == v0) {\n                marketingWallet();\n            } else if (0x7bce5a04 == v0) {\n                buyMarketingFee();\n            } else if (0x8095d564 == v0) {\n                updateBuyFees(uint256,uint256,uint256);\n            } else {\n                require(0x8a8c523c == v0);\n                enableTrading();\n            }\n        } else if (0xc0246668 > v0) {\n            if (0x9fccce32 > v0) {\n                if (0x924de9b7 > v0) {\n                    if (0x8da5cb5b == v0) {\n                        owner();\n                    } else if (0x8ea5220f == v0) {\n                        devWallet();\n                    } else {\n                        require(0x92136913 == v0);\n                        sellMarketingFee();\n                    }\n                } else if (0x924de9b7 == v0) {\n                    updateSwapEnabled(bool);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x9a7a23d6 == v0) {\n                    setAutomatedMarketMakerPair(address,bool);\n                } else {\n                    require(0x9c3b4fdc == v0);\n                    buyDevFee();\n                }\n            } else if (0xa9059cbb > v0) {\n                if (0x9fccce32 == v0) {\n                    tokensForDev();\n                } else if (0xa0d82dc5 == v0) {\n                    sellDevFee();\n                } else {\n                    require(0xa457c2d7 == v0);\n                    decreaseAllowance(address,uint256);\n                }\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xaacebbe3 == v0) {\n                updateMarketingWallet(address);\n            } else if (0xb62496f5 == v0) {\n                automatedMarketMakerPairs(address);\n            } else {\n                require(0xbbc0c742 == v0);\n                tradingActive();\n            }\n        } else if (0xdd62ed3e > v0) {\n            if (0xc876d0b9 > v0) {\n                if (0xc0246668 == v0) {\n                    excludeFromFees(address,bool);\n                } else if (0xc17b5b8c == v0) {\n                    updateSellFees(uint256,uint256,uint256);\n                } else {\n                    require(0xc18bc195 == v0);\n                    updateMaxWalletAmount(uint256);\n                }\n            } else if (0xc876d0b9 == v0) {\n                transferDelayEnabled();\n            } else if (0xc8c8ebe4 == v0) {\n                maxTransactionAmount();\n            } else if (0xd257b34f == v0) {\n                updateSwapTokensAtAmount(uint256);\n            } else {\n                require(0xd85ba063 == v0);\n                buyTotalFees();\n            }\n        } else if (0xf11a24d3 > v0) {\n            if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe2f45605 == v0) {\n                swapTokensAtAmount();\n            } else {\n                require(0xe884f260 == v0);\n                disableTransferDelay();\n            }\n        } else if (0xf11a24d3 == v0) {\n            buyLiquidityFee();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf6374342 == v0) {\n            sellLiquidityFee();\n        } else {\n            require(0xf8b45b05 == v0);\n            maxWallet();\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 26.131868839263916,
	"usage": {
		"completion_tokens": 565,
		"prompt_tokens": 11368,
		"total_tokens": 11933
	}
}