{
	"address": "0x7da82c7ab4771ff031b66538d2fb9b0b047f6cf9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the corresponding contract code in Solidity:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Contract {\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        uint256 nonce;\n        bool executed;\n    }\n\n    mapping(bytes32 => Transaction) public transactions;\n    mapping(bytes32 => mapping(address => bool)) public confirmations;\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint256 public required;\n\n    event Confirmation(address indexed owner, bytes32 indexed transactionId);\n    event Execution(bytes32 indexed transactionId);\n    event Deposit(address indexed sender, uint256 value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event Submission(bytes32 indexed transactionId);\n    event RequiredUpdate(uint256 required);\n\n    modifier onlyOwner {\n        require(isOwner[msg.sender], \"Not an owner\");\n        _;\n    }\n\n    modifier transactionExists(bytes32 transactionId) {\n        require(transactions[transactionId].destination != address(0), \"Transaction does not exist\");\n        _;\n    }\n\n    modifier confirmed(bytes32 transactionId, address owner) {\n        require(confirmations[transactionId][owner], \"Not confirmed\");\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionId, address owner) {\n        require(!confirmations[transactionId][owner], \"Already confirmed\");\n        _;\n    }\n\n    modifier notExecuted(bytes32 transactionId) {\n        require(!transactions[transactionId].executed, \"Already executed\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0), \"Null address\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint256 _required) {\n        require(_owners.length <= 10, \"Too many owners\");\n        require(_required <= _owners.length, \"Too many required confirmations\");\n        require(_required != 0 && _required != 0, \"Invalid required confirmations\");\n        for (uint256 i = 0; i < _owners.length; i++) {\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    receive() payable external {\n        if (msg.value > 0) {\n            emit Deposit(msg.sender, msg.value);\n        }\n    }\n\n    function addOwner(address owner) public onlyOwner notNull(owner) {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    function removeOwner(address owner) public onlyOwner {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.pop();\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    function changeRequirement(uint256 _required) public onlyOwner {\n        required = _required;\n        emit RequiredUpdate(_required);\n    }\n\n    function submitTransaction(address destination, uint value, bytes memory data) public returns (bytes32 transactionId) {\n        transactionId = keccak256(abi.encodePacked(this, destination, value, data));\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            nonce: 0,\n            executed: false\n        });\n        emit Submission(transactionId);\n    }\n\n    function confirmTransaction(bytes32 transactionId) public onlyOwner transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    function executeTransaction(bytes32 transactionId) public onlyOwner confirmed(transactionId, msg.sender) notExecuted(transactionId) {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            (bool success,) = txn.destination.call{value: txn.value}(txn.data);\n            if (success)\n                emit Execution(transactionId);\n        }\n    }\n\n    function isConfirmed(bytes32 transactionId) public view returns (bool) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n}\n```\n\nPlease note that this code is not optimized and can be improved in several ways. For example, the `owners` array could be replaced with a more efficient data structure to avoid looping through the entire list. The code also lacks access controls and error handling for some functions. It is crucial to thoroughly test this contract in a safe environment before deploying it on the main network.\n\nThe code provided is a simple multisig wallet. It allows multiple owners to submit, confirm, and execute transactions. The number of confirmations required to execute a transaction is set at contract deployment and can be changed by the contract owners. If a transaction receives enough confirmations, it is executed and the money is sent. A transaction can only be executed once.\n",
				"role": "assistant"
			}
		}
	],
	"created": 1700470515,
	"id": "chatcmpl-8MuLjDOXpK5lub5gqZxWcuJiNSD32",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  stor3 is array of struct at storage 3\n  stor4 is array of uint256 at storage 4\n  required is uint256 at storage 5\n\ndef confirmations(bytes32 _param1, address _param2): # not payable\n  return bool(stor1[_param1][_param2])\n\ndef isOwner(address _owner): # not payable\n  return bool(stor2[_owner])\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef updateRequired(uint256 _required): # not payable\n  require caller == this.address\n  require _required <= stor3.length\n  require _required\n  require stor3.length\n  required = _required\n  log RequiredUpdate(uint256 required=_required)\n\ndef revokeConfirmation(bytes32 _transactionId): # not payable\n  require stor2[caller]\n  require stor1[_transactionId][caller]\n  require not uint8(stor0[_transactionId].field_1024)\n  stor1[_transactionId][caller] = 0\n  log Revocation(\n        address sender=caller,\n        bytes32 transactionHash=_transactionId)\n\ndef confirmationCount(bytes32 _TransHash): # not payable\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(bytes32 _TransHash): # not payable\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s != required:\n      return 0\n  return 1\n\ndef addOwner(address _owner): # not payable\n  require caller == this.address\n  require not stor2[addr(_owner)]\n  stor2[addr(_owner)] = 1\n  stor3.length++\n  if not stor3.length <= stor3.length + 1:\n      idx = stor3.length + 1\n      while stor3.length > idx:\n          stor3[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  addr(stor3[stor3.length].field_0) = _owner\n  log OwnerAddition(address owner=_owner)\n\ndef transactions(bytes32 _param1): # not payable\n  mem[288] = stor0[_param1][2].field_0\n  idx = 288\n  s = 0\n  while stor0[_param1][2].length + 288 > idx + 32:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return addr(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[288 len stor0[_param1][2].length + (floor32(stor0[_param1][2].length - 1) + -stor0[_param1][2].length + 32 % 32)]),\n         stor0[_param1].field_768,\n         bool(uint8(stor0[_param1].field_1024))\n\ndef getPendingTransactions(): # not payable\n  idx = 0\n  while idx < stor4.length:\n      require idx < stor4.length\n      mem[0] = stor4[idx]\n      mem[32] = 0\n      if not uint8(stor0[stor4[idx]].field_1024):\n          require idx < stor4.length\n          mem[0] = 4\n          require 0 < stor4.length\n          mem[224] = stor4[idx]\n      idx = idx + 1\n      continue \n  if 256 >= (32 * stor4.length) + 224:\n      return ''\n  mem[(32 * stor4.length) + 256] = 32\n  mem[(32 * stor4.length) + 288] = mem[(32 * stor4.length) + 224]\n  mem[(32 * stor4.length) + 320 len 32 * mem[(32 * stor4.length) + 224]] = mem[(32 * stor4.length) + 256 len 32 * mem[(32 * stor4.length) + 224]]\n  return 32, mem[(32 * stor4.length) + 288 len (32 * mem[(32 * stor4.length) + 224]) + 32]\n\ndef executeTransaction(bytes32 _TransHash): # not payable\n  require not uint8(stor0[_TransHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_TransHash].field_1024) = 1\n      mem[96] = stor0[_TransHash][2].field_0\n      idx = 96\n      s = 0\n      while stor0[_TransHash][2].length + 96 > idx + 32:\n          mem[idx + 32] = stor0[_TransHash][s + 2].field_256\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_TransHash].field_0).mem[96 len 4] with:\n         value stor0[_TransHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[100 len stor0[_TransHash][2].length + (floor32(stor0[_TransHash][2].length - 1) + -stor0[_TransHash][2].length + 32 % 32) - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_TransHash)\n\ndef confirmTransaction(bytes32 _dataHash): # not payable\n  require stor2[caller]\n  require not stor1[_dataHash][caller]\n  stor1[_dataHash][caller] = 1\n  mem[128] = _dataHash\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=_dataHash)\n  require not uint8(stor0[_dataHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_dataHash, 1)\n      if not stor1[_dataHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_dataHash].field_1024) = 1\n      mem[96] = stor0[_dataHash][2].field_0\n      idx = 96\n      s = 0\n      while stor0[_dataHash][2].length + 96 > idx + 32:\n          mem[idx + 32] = stor0[_dataHash][s + 2].field_256\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_dataHash].field_0).mem[96 len 4] with:\n         value stor0[_dataHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[100 len stor0[_dataHash][2].length + (floor32(stor0[_dataHash][2].length - 1) + -stor0[_dataHash][2].length + 32 % 32) - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_dataHash)\n\ndef removeOwner(address _owner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  stor2[addr(_owner)] = 0\n  idx = 0\n  while idx < stor3.length - 1:\n      require idx < stor3.length\n      mem[0] = 3\n      if addr(stor3[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require stor3.length - 1 < stor3.length\n      require idx < stor3.length\n      uint64(stor3[idx].field_0) = uint64(stor3[stor3.length].field_0)\n      Mask(96, 0, stor3[idx].field_64) = 0\n      stor3.length--\n      if not stor3.length <= stor3.length - 1:\n          idx = stor3.length + sha3(3) - 1\n          while sha3(3) + stor3.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > stor3.length:\n          require caller == this.address\n          require stor3.length <= stor3.length\n          require stor3.length\n          require stor3.length\n          required = stor3.length\n          log RequiredUpdate(uint256 required=stor3.length)\n      log OwnerRemoval(address owner=_owner)\n      stop\n  stor3.length--\n  if not stor3.length <= stor3.length - 1:\n      idx = stor3.length - 1\n      while stor3.length > idx:\n          stor3[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > stor3.length:\n      require caller == this.address\n      require stor3.length <= stor3.length\n      require stor3.length\n      require stor3.length\n      required = stor3.length\n      log RequiredUpdate(uint256 required=stor3.length)\n  log OwnerRemoval(address owner=_owner)\n\ndef getExecutedTransactions(): # not payable\n  idx = 0\n  s = 0\n  while idx < stor4.length:\n      require idx < stor4.length\n      mem[0] = stor4[idx]\n      mem[32] = 0\n      if not uint8(stor0[stor4[idx]].field_1024):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < stor4.length\n      mem[0] = 4\n      require s < stor4.length\n      mem[(32 * s) + 224] = stor4[idx]\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 256 < (32 * stor4.length) + 224:\n      mem[(32 * stor4.length) + 224] = s\n      t = 0\n      while t < s:\n          require t < stor4.length\n          if mem[(32 * t) + 224] > 0:\n              require t < stor4.length\n              require t < s\n              mem[(32 * stor4.length) + (32 * t) + 256] = mem[(32 * t) + 224]\n          t = t + 1\n          continue \n      return Array(len=s, data=mem[(32 * stor4.length) + 256 len 32 * s])\n  mem[(32 * s) + 256] = s\n  t = 0\n  while t < s:\n      require t < stor4.length\n      if mem[(32 * t) + 224] > 0:\n          require t < stor4.length\n          require t < s, None\n          mem[(32 * s) + (32 * t) + 288] = mem[(32 * t) + 224]\n      t = t + 1\n      continue \n  mem[(64 * s) + 288] = 32\n  mem[(64 * s) + 320] = s, None\n  mem[(64 * s) + 352 len 32 * s] = mem[(32 * s) + 288 len 32 * s]\n  return memory\n    from (64 * s) + 288\n     len (32 * s, None) + 64\n\ndef confirmTransactionWithSignatures(bytes32 _transactionHash, uint8[] _v, bytes32[] _rs): # not payable\n  mem[96] = _v.length\n  mem[128 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n  mem[64] = (32 * _rs.length) + (32 * _v.length) + 160\n  mem[(32 * _v.length) + 128] = _rs.length\n  mem[(32 * _v.length) + 160 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n  idx = 0\n  while idx < _v.length:\n      require idx < mem[96]\n      _55 = mem[(32 * idx) + 128]\n      require idx < mem[(32 * _v.length) + 128]\n      _58 = mem[(32 * idx) + (32 * _v.length) + 160]\n      require mem[96] + idx < mem[(32 * _v.length) + 128]\n      _64 = mem[(32 * _v.length) + (32 * mem[96] + idx) + 160]\n      _65 = mem[64]\n      mem[64] = mem[64] + 32\n      mem[_65 + 64] = 0\n      mem[mem[64]] = _transactionHash\n      mem[mem[64] + 32] = uint8(_55)\n      mem[mem[64] + 64] = _58\n      mem[mem[64] + 96] = _64\n      signer = erecover(_transactionHash, _55 << 248, _58, _64) # precompiled\n      mem[mem[64] - 32] = signer\n      require erecover.result\n      mem[0] = addr(signer)\n      mem[32] = 2\n      require stor2[addr(signer)]\n      idx = idx + 1\n      continue \n  _101 = mem[96]\n  idx = 0\n  while idx < _101:\n      require idx < mem[96]\n      _104 = mem[(32 * idx) + 128]\n      require idx < mem[(32 * _v.length) + 128]\n      _106 = mem[(32 * idx) + (32 * _v.length) + 160]\n      require idx + mem[96] < mem[(32 * _v.length) + 128]\n      _109 = mem[(32 * _v.length) + (32 * idx + mem[96]) + 160]\n      _110 = mem[64]\n      mem[64] = mem[64] + 32\n      mem[_110 + 64] = 0\n      mem[mem[64] + 32] = uint8(_104)\n      mem[mem[64] + 64] = _106\n      mem[mem[64] + 96] = _109\n      signer = erecover(_transactionHash, _104 << 248, _106, _109) # precompiled\n      mem[mem[64] - 32] = signer\n      require erecover.result\n      require not stor1[_transactionHash][addr(signer)]\n      mem[0] = addr(signer)\n      mem[32] = sha3(_transactionHash, 1)\n      stor1[_transactionHash][addr(signer)] = 1\n      mem[mem[64]] = addr(signer)\n      mem[mem[64] + 32] = _transactionHash\n      log Confirmation(\n            address owner=addr(signer),\n            bytes32 operation=_transactionHash)\n      _101 = mem[96]\n      idx = idx + 1\n      continue \n  require not uint8(stor0[_transactionHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_transactionHash, 1)\n      if not stor1[_transactionHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_transactionHash].field_1024) = 1\n      _140 = mem[64]\n      mem[0] = sha3(_transactionHash, 0) + 2\n      mem[mem[64]] = stor0[_transactionHash][2].field_0\n      idx = mem[64]\n      s = 0\n      while _140 + stor0[_transactionHash][2].length > idx + 32:\n          mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionHash].field_0).mem[mem[64] len 4] with:\n         value stor0[_transactionHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[mem[64] + 4 len _140 + stor0[_transactionHash][2].length + (floor32(stor0[_transactionHash][2].length - 1) + -stor0[_transactionHash][2].length + 32 % 32) + -mem[64] - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_transactionHash)\n\ndef submitTransaction(address _destination, uint256 _value, bytes _data, uint256 _nonce): # not payable\n  mem[128 len _data.length] = _data[all]\n  require _destination\n  mem[ceil32(_data.length) + 180 len _data.length] = _data[all]\n  mem[_data.length + ceil32(_data.length) + 180] = _nonce\n  if addr(stor0[_destination][_value][_data[all]][_nonce].field_0):\n      require stor2[caller]\n      require not stor1[_destination][_value][_data[all]][_nonce][caller]\n      stor1[_destination][_value][_data[all]][_nonce][caller] = 1\n      mem[ceil32(_data.length) + 160] = sha3(_destination, _value, _data[all], _nonce)\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          mem[ceil32(_data.length) + 128] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = ceil32(_data.length) + 128\n          s = 0\n          while ceil32(_data.length) + stor0[_destination][_value][_data[all]][_nonce][2].length + 128 > idx + 32:\n              mem[idx + 32] = stor0[_destination][_value][_data[all]][_nonce][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[ceil32(_data.length) + 128 len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[ceil32(_data.length) + 132 len stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  else:\n      addr(stor0[_destination][_value][_data[all]][_nonce].field_0) = _destination\n      stor0[_destination][_value][_data[all]][_nonce].field_256 = _value\n      stor0[_destination][_value][_data[all]][_nonce][2][].field_0 = Array(len=_data.length, data=_data[all])\n      stor0[_destination][_value][_data[all]][_nonce].field_768 = _nonce\n      uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 0\n      stor0[_destination][_value][_data[all]][_nonce].field_1280 % 1 = 0\n      stor4.length++\n      if not stor4.length <= stor4.length + 1:\n          idx = stor4.length + 1\n          while stor4.length > idx:\n              stor4[idx] = 0\n              idx = idx + 1\n              continue \n      stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n      log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n      require stor2[caller]\n      require not stor1[_destination][_value][_data[all]][_nonce][caller]\n      stor1[_destination][_value][_data[all]][_nonce][caller] = 1\n      mem[ceil32(_data.length) + 320] = sha3(_destination, _value, _data[all], _nonce)\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          mem[ceil32(_data.length) + 288] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = ceil32(_data.length) + 288\n          s = 0\n          while ceil32(_data.length) + stor0[_destination][_value][_data[all]][_nonce][2].length + 288 > idx + 32:\n              mem[idx + 32] = stor0[_destination][_value][_data[all]][_nonce][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[ceil32(_data.length) + 288 len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[ceil32(_data.length) + 292 len stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  return sha3(_destination, _value, _data[all], _nonce)\n\ndef submitTransactionWithSignatures(address _destination, uint256 _value, bytes _data, uint256 _nonce, uint8[] _v, bytes32[] _rs): # not payable\n  mem[96] = _data.length\n  mem[128 len _data.length] = _data[all]\n  require _destination\n  mem[ceil32(_data.length) + 148] = _value\n  mem[ceil32(_data.length) + 180 len _data.length] = _data[all]\n  mem[_data.length + ceil32(_data.length) + 180] = _nonce\n  if addr(stor0[_destination][_value][_data[all]][_nonce].field_0):\n      mem[ceil32(_data.length) + 128] = _v.length\n      mem[ceil32(_data.length) + 160 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n      mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 192\n      mem[ceil32(_data.length) + (32 * _v.length) + 160] = _rs.length\n      mem[ceil32(_data.length) + (32 * _v.length) + 192 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n      idx = 0\n      while idx < _v.length:\n          require idx < mem[ceil32(_data.length) + 128]\n          _460 = mem[(32 * idx) + ceil32(_data.length) + 160]\n          require idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _467 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 192]\n          require mem[ceil32(_data.length) + 128] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _481 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 128] + idx) + 192]\n          _482 = mem[64]\n          mem[64] = mem[64] + 32\n          mem[_482 + 64] = 0\n          mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n          mem[mem[64] + 32] = uint8(_460)\n          mem[mem[64] + 64] = _467\n          mem[mem[64] + 96] = _481\n          signer = erecover(sha3(_destination, _value, _data[all], _nonce), _460 << 248, _467, _481) # precompiled\n          mem[mem[64] - 32] = signer\n          require erecover.result\n          mem[0] = addr(signer)\n          mem[32] = 2\n          require stor2[addr(signer)]\n          idx = idx + 1\n          continue \n      _895 = mem[ceil32(_data.length) + 128]\n      idx = 0\n      while idx < _895:\n          require idx < mem[ceil32(_data.length) + 128]\n          _902 = mem[(32 * idx) + ceil32(_data.length) + 160]\n          require idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _918 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 192]\n          require idx + mem[ceil32(_data.length) + 128] < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _933 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 128]) + 192]\n          _934 = mem[64]\n          mem[64] = mem[64] + 32\n          mem[_934 + 64] = 0\n          mem[mem[64] + 32] = uint8(_902)\n          mem[mem[64] + 64] = _918\n          mem[mem[64] + 96] = _933\n          signer = erecover(sha3(_destination, _value, _data[all], _nonce), _902 << 248, _918, _933) # precompiled\n          mem[mem[64] - 32] = signer\n          require erecover.result\n          require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n          mem[0] = addr(signer)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n          mem[mem[64]] = addr(signer)\n          mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n          log Confirmation(\n                address owner=addr(signer),\n                bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n          _895 = mem[ceil32(_data.length) + 128]\n          idx = idx + 1\n          continue \n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          _1384 = mem[64]\n          mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n          mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = mem[64]\n          s = 0\n          while _1384 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n              mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[mem[64] + 4 len _1384 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  else:\n      mem[ceil32(_data.length) + 128] = _destination\n      mem[ceil32(_data.length) + 160] = _value\n      mem[ceil32(_data.length) + 192] = 96\n      mem[ceil32(_data.length) + 224] = _nonce\n      mem[ceil32(_data.length) + 256] = 0\n      addr(stor0[_destination][_value][_data[all]][_nonce].field_0) = _destination\n      stor0[_destination][_value][_data[all]][_nonce].field_256 = _value\n      stor0[_destination][_value][_data[all]][_nonce][2][].field_0 = Array(len=_data.length, data=_data[all])\n      stor0[_destination][_value][_data[all]][_nonce].field_768 = _nonce\n      uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 0\n      stor0[_destination][_value][_data[all]][_nonce].field_1280 % 1 = 0\n      stor4.length++\n      if not stor4.length > stor4.length + 1:\n          stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n          log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n          mem[ceil32(_data.length) + 288] = _v.length\n          mem[ceil32(_data.length) + 320 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n          mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 352\n          mem[ceil32(_data.length) + (32 * _v.length) + 320] = _rs.length\n          mem[ceil32(_data.length) + (32 * _v.length) + 352 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n          idx = 0\n          while idx < _v.length:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1323 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1342 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require mem[ceil32(_data.length) + 288] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1366 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 288] + idx) + 352]\n              _1367 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1367 + 64] = 0\n              mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n              mem[mem[64] + 32] = uint8(_1323)\n              mem[mem[64] + 64] = _1342\n              mem[mem[64] + 96] = _1366\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1323 << 248, _1342, _1366) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              mem[0] = addr(signer)\n              mem[32] = 2\n              require stor2[addr(signer)]\n              idx = idx + 1\n              continue \n          _1646 = mem[ceil32(_data.length) + 288]\n          idx = 0\n          while idx < _1646:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1662 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1677 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require idx + mem[ceil32(_data.length) + 288] < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1691 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 288]) + 352]\n              _1692 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1692 + 64] = 0\n              mem[mem[64] + 32] = uint8(_1662)\n              mem[mem[64] + 64] = _1677\n              mem[mem[64] + 96] = _1691\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1662 << 248, _1677, _1691) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n              mem[0] = addr(signer)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n              mem[mem[64]] = addr(signer)\n              mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n              log Confirmation(\n                    address owner=addr(signer),\n                    bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n              _1646 = mem[ceil32(_data.length) + 288]\n              idx = idx + 1\n              continue \n          require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n          idx = 0\n          s = 0\n          while idx < stor3.length:\n              mem[0] = addr(stor3[idx].field_0)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n                  idx = idx + 1\n                  s = s\n                  continue \n              idx = idx + 1\n              s = s + 1\n              continue \n          if s == required:\n              uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n              _1912 = mem[64]\n              mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n              mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n              idx = mem[64]\n              s = 0\n              while _1912 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n                  mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n                 value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[mem[64] + 4 len _1912 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n              require ext_call.success\n              log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n      else:\n          idx = stor4.length + 1\n          while stor4.length > idx:\n              stor4[idx] = 0\n              idx = idx + 1\n              continue \n          stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n          log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n          mem[ceil32(_data.length) + 288] = _v.length\n          mem[ceil32(_data.length) + 320 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n          mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 352\n          mem[ceil32(_data.length) + (32 * _v.length) + 320] = _rs.length\n          mem[ceil32(_data.length) + (32 * _v.length) + 352 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n          idx = 0\n          while idx < _v.length:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1665 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1681 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require mem[ceil32(_data.length) + 288] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1698 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 288] + idx) + 352]\n              _1699 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1699 + 64] = 0\n              mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n              mem[mem[64] + 32] = uint8(_1665)\n              mem[mem[64] + 64] = _1681\n              mem[mem[64] + 96] = _1698\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1665 << 248, _1681, _1698) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              mem[0] = addr(signer)\n              mem[32] = 2\n              require stor2[addr(signer)]\n              idx = idx + 1\n              continue \n          _1882 = mem[ceil32(_data.length) + 288]\n          idx = 0\n          while idx < _1882:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1893 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1900 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require idx + mem[ceil32(_data.length) + 288] < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1905 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 288]) + 352]\n              _1906 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1906 + 64] = 0\n              mem[mem[64] + 32] = uint8(_1893)\n              mem[mem[64] + 64] = _1900\n              mem[mem[64] + 96] = _1905\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1893 << 248, _1900, _1905) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n              mem[0] = addr(signer)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n              mem[mem[64]] = addr(signer)\n              mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n              log Confirmation(\n                    address owner=addr(signer),\n                    bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n              _1882 = mem[ceil32(_data.length) + 288]\n              idx = idx + 1\n              continue \n          require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n          idx = 0\n          s = 0\n          while idx < stor3.length:\n              mem[0] = addr(stor3[idx].field_0)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n                  idx = idx + 1\n                  s = s\n                  continue \n              idx = idx + 1\n              s = s + 1\n              continue \n          if s == required:\n              uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n              _2017 = mem[64]\n              mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n              mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n              idx = mem[64]\n              s = 0\n              while _2017 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n                  mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n                 value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[mem[64] + 4 len _2017 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n              require ext_call.success\n              log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  return sha3(_destination, _value, _data[all], _nonce)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  stor3 is array of struct at storage 3\n  stor4 is array of uint256 at storage 4\n  required is uint256 at storage 5\n\ndef confirmations(bytes32 _param1, address _param2): # not payable\n  return bool(stor1[_param1][_param2])\n\ndef isOwner(address _owner): # not payable\n  return bool(stor2[_owner])\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef updateRequired(uint256 _required): # not payable\n  require caller == this.address\n  require _required <= stor3.length\n  require _required\n  require stor3.length\n  required = _required\n  log RequiredUpdate(uint256 required=_required)\n\ndef revokeConfirmation(bytes32 _transactionId): # not payable\n  require stor2[caller]\n  require stor1[_transactionId][caller]\n  require not uint8(stor0[_transactionId].field_1024)\n  stor1[_transactionId][caller] = 0\n  log Revocation(\n        address sender=caller,\n        bytes32 transactionHash=_transactionId)\n\ndef confirmationCount(bytes32 _TransHash): # not payable\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(bytes32 _TransHash): # not payable\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s != required:\n      return 0\n  return 1\n\ndef addOwner(address _owner): # not payable\n  require caller == this.address\n  require not stor2[addr(_owner)]\n  stor2[addr(_owner)] = 1\n  stor3.length++\n  if not stor3.length <= stor3.length + 1:\n      idx = stor3.length + 1\n      while stor3.length > idx:\n          stor3[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  addr(stor3[stor3.length].field_0) = _owner\n  log OwnerAddition(address owner=_owner)\n\ndef transactions(bytes32 _param1): # not payable\n  mem[288] = stor0[_param1][2].field_0\n  idx = 288\n  s = 0\n  while stor0[_param1][2].length + 288 > idx + 32:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return addr(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[288 len stor0[_param1][2].length + (floor32(stor0[_param1][2].length - 1) + -stor0[_param1][2].length + 32 % 32)]),\n         stor0[_param1].field_768,\n         bool(uint8(stor0[_param1].field_1024))\n\ndef getPendingTransactions(): # not payable\n  idx = 0\n  while idx < stor4.length:\n      require idx < stor4.length\n      mem[0] = stor4[idx]\n      mem[32] = 0\n      if not uint8(stor0[stor4[idx]].field_1024):\n          require idx < stor4.length\n          mem[0] = 4\n          require 0 < stor4.length\n          mem[224] = stor4[idx]\n      idx = idx + 1\n      continue \n  if 256 >= (32 * stor4.length) + 224:\n      return ''\n  mem[(32 * stor4.length) + 256] = 32\n  mem[(32 * stor4.length) + 288] = mem[(32 * stor4.length) + 224]\n  mem[(32 * stor4.length) + 320 len 32 * mem[(32 * stor4.length) + 224]] = mem[(32 * stor4.length) + 256 len 32 * mem[(32 * stor4.length) + 224]]\n  return 32, mem[(32 * stor4.length) + 288 len (32 * mem[(32 * stor4.length) + 224]) + 32]\n\ndef executeTransaction(bytes32 _TransHash): # not payable\n  require not uint8(stor0[_TransHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_TransHash].field_1024) = 1\n      mem[96] = stor0[_TransHash][2].field_0\n      idx = 96\n      s = 0\n      while stor0[_TransHash][2].length + 96 > idx + 32:\n          mem[idx + 32] = stor0[_TransHash][s + 2].field_256\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_TransHash].field_0).mem[96 len 4] with:\n         value stor0[_TransHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[100 len stor0[_TransHash][2].length + (floor32(stor0[_TransHash][2].length - 1) + -stor0[_TransHash][2].length + 32 % 32) - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_TransHash)\n\ndef confirmTransaction(bytes32 _dataHash): # not payable\n  require stor2[caller]\n  require not stor1[_dataHash][caller]\n  stor1[_dataHash][caller] = 1\n  mem[128] = _dataHash\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=_dataHash)\n  require not uint8(stor0[_dataHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_dataHash, 1)\n      if not stor1[_dataHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_dataHash].field_1024) = 1\n      mem[96] = stor0[_dataHash][2].field_0\n      idx = 96\n      s = 0\n      while stor0[_dataHash][2].length + 96 > idx + 32:\n          mem[idx + 32] = stor0[_dataHash][s + 2].field_256\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_dataHash].field_0).mem[96 len 4] with:\n         value stor0[_dataHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[100 len stor0[_dataHash][2].length + (floor32(stor0[_dataHash][2].length - 1) + -stor0[_dataHash][2].length + 32 % 32) - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_dataHash)\n\ndef removeOwner(address _owner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  stor2[addr(_owner)] = 0\n  idx = 0\n  while idx < stor3.length - 1:\n      require idx < stor3.length\n      mem[0] = 3\n      if addr(stor3[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require stor3.length - 1 < stor3.length\n      require idx < stor3.length\n      uint64(stor3[idx].field_0) = uint64(stor3[stor3.length].field_0)\n      Mask(96, 0, stor3[idx].field_64) = 0\n      stor3.length--\n      if not stor3.length <= stor3.length - 1:\n          idx = stor3.length + sha3(3) - 1\n          while sha3(3) + stor3.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > stor3.length:\n          require caller == this.address\n          require stor3.length <= stor3.length\n          require stor3.length\n          require stor3.length\n          required = stor3.length\n          log RequiredUpdate(uint256 required=stor3.length)\n      log OwnerRemoval(address owner=_owner)\n      stop\n  stor3.length--\n  if not stor3.length <= stor3.length - 1:\n      idx = stor3.length - 1\n      while stor3.length > idx:\n          stor3[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > stor3.length:\n      require caller == this.address\n      require stor3.length <= stor3.length\n      require stor3.length\n      require stor3.length\n      required = stor3.length\n      log RequiredUpdate(uint256 required=stor3.length)\n  log OwnerRemoval(address owner=_owner)\n\ndef getExecutedTransactions(): # not payable\n  idx = 0\n  s = 0\n  while idx < stor4.length:\n      require idx < stor4.length\n      mem[0] = stor4[idx]\n      mem[32] = 0\n      if not uint8(stor0[stor4[idx]].field_1024):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < stor4.length\n      mem[0] = 4\n      require s < stor4.length\n      mem[(32 * s) + 224] = stor4[idx]\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 256 < (32 * stor4.length) + 224:\n      mem[(32 * stor4.length) + 224] = s\n      t = 0\n      while t < s:\n          require t < stor4.length\n          if mem[(32 * t) + 224] > 0:\n              require t < stor4.length\n              require t < s\n              mem[(32 * stor4.length) + (32 * t) + 256] = mem[(32 * t) + 224]\n          t = t + 1\n          continue \n      return Array(len=s, data=mem[(32 * stor4.length) + 256 len 32 * s])\n  mem[(32 * s) + 256] = s\n  t = 0\n  while t < s:\n      require t < stor4.length\n      if mem[(32 * t) + 224] > 0:\n          require t < stor4.length\n          require t < s, None\n          mem[(32 * s) + (32 * t) + 288] = mem[(32 * t) + 224]\n      t = t + 1\n      continue \n  mem[(64 * s) + 288] = 32\n  mem[(64 * s) + 320] = s, None\n  mem[(64 * s) + 352 len 32 * s] = mem[(32 * s) + 288 len 32 * s]\n  return memory\n    from (64 * s) + 288\n     len (32 * s, None) + 64\n\ndef confirmTransactionWithSignatures(bytes32 _transactionHash, uint8[] _v, bytes32[] _rs): # not payable\n  mem[96] = _v.length\n  mem[128 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n  mem[64] = (32 * _rs.length) + (32 * _v.length) + 160\n  mem[(32 * _v.length) + 128] = _rs.length\n  mem[(32 * _v.length) + 160 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n  idx = 0\n  while idx < _v.length:\n      require idx < mem[96]\n      _55 = mem[(32 * idx) + 128]\n      require idx < mem[(32 * _v.length) + 128]\n      _58 = mem[(32 * idx) + (32 * _v.length) + 160]\n      require mem[96] + idx < mem[(32 * _v.length) + 128]\n      _64 = mem[(32 * _v.length) + (32 * mem[96] + idx) + 160]\n      _65 = mem[64]\n      mem[64] = mem[64] + 32\n      mem[_65 + 64] = 0\n      mem[mem[64]] = _transactionHash\n      mem[mem[64] + 32] = uint8(_55)\n      mem[mem[64] + 64] = _58\n      mem[mem[64] + 96] = _64\n      signer = erecover(_transactionHash, _55 << 248, _58, _64) # precompiled\n      mem[mem[64] - 32] = signer\n      require erecover.result\n      mem[0] = addr(signer)\n      mem[32] = 2\n      require stor2[addr(signer)]\n      idx = idx + 1\n      continue \n  _101 = mem[96]\n  idx = 0\n  while idx < _101:\n      require idx < mem[96]\n      _104 = mem[(32 * idx) + 128]\n      require idx < mem[(32 * _v.length) + 128]\n      _106 = mem[(32 * idx) + (32 * _v.length) + 160]\n      require idx + mem[96] < mem[(32 * _v.length) + 128]\n      _109 = mem[(32 * _v.length) + (32 * idx + mem[96]) + 160]\n      _110 = mem[64]\n      mem[64] = mem[64] + 32\n      mem[_110 + 64] = 0\n      mem[mem[64] + 32] = uint8(_104)\n      mem[mem[64] + 64] = _106\n      mem[mem[64] + 96] = _109\n      signer = erecover(_transactionHash, _104 << 248, _106, _109) # precompiled\n      mem[mem[64] - 32] = signer\n      require erecover.result\n      require not stor1[_transactionHash][addr(signer)]\n      mem[0] = addr(signer)\n      mem[32] = sha3(_transactionHash, 1)\n      stor1[_transactionHash][addr(signer)] = 1\n      mem[mem[64]] = addr(signer)\n      mem[mem[64] + 32] = _transactionHash\n      log Confirmation(\n            address owner=addr(signer),\n            bytes32 operation=_transactionHash)\n      _101 = mem[96]\n      idx = idx + 1\n      continue \n  require not uint8(stor0[_transactionHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_transactionHash, 1)\n      if not stor1[_transactionHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_transactionHash].field_1024) = 1\n      _140 = mem[64]\n      mem[0] = sha3(_transactionHash, 0) + 2\n      mem[mem[64]] = stor0[_transactionHash][2].field_0\n      idx = mem[64]\n      s = 0\n      while _140 + stor0[_transactionHash][2].length > idx + 32:\n          mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionHash].field_0).mem[mem[64] len 4] with:\n         value stor0[_transactionHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[mem[64] + 4 len _140 + stor0[_transactionHash][2].length + (floor32(stor0[_transactionHash][2].length - 1) + -stor0[_transactionHash][2].length + 32 % 32) + -mem[64] - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_transactionHash)\n\ndef submitTransaction(address _destination, uint256 _value, bytes _data, uint256 _nonce): # not payable\n  mem[128 len _data.length] = _data[all]\n  require _destination\n  mem[ceil32(_data.length) + 180 len _data.length] = _data[all]\n  mem[_data.length + ceil32(_data.length) + 180] = _nonce\n  if addr(stor0[_destination][_value][_data[all]][_nonce].field_0):\n      require stor2[caller]\n      require not stor1[_destination][_value][_data[all]][_nonce][caller]\n      stor1[_destination][_value][_data[all]][_nonce][caller] = 1\n      mem[ceil32(_data.length) + 160] = sha3(_destination, _value, _data[all], _nonce)\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          mem[ceil32(_data.length) + 128] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = ceil32(_data.length) + 128\n          s = 0\n          while ceil32(_data.length) + stor0[_destination][_value][_data[all]][_nonce][2].length + 128 > idx + 32:\n              mem[idx + 32] = stor0[_destination][_value][_data[all]][_nonce][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[ceil32(_data.length) + 128 len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[ceil32(_data.length) + 132 len stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  else:\n      addr(stor0[_destination][_value][_data[all]][_nonce].field_0) = _destination\n      stor0[_destination][_value][_data[all]][_nonce].field_256 = _value\n      stor0[_destination][_value][_data[all]][_nonce][2][].field_0 = Array(len=_data.length, data=_data[all])\n      stor0[_destination][_value][_data[all]][_nonce].field_768 = _nonce\n      uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 0\n      stor0[_destination][_value][_data[all]][_nonce].field_1280 % 1 = 0\n      stor4.length++\n      if not stor4.length <= stor4.length + 1:\n          idx = stor4.length + 1\n          while stor4.length > idx:\n              stor4[idx] = 0\n              idx = idx + 1\n              continue \n      stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n      log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n      require stor2[caller]\n      require not stor1[_destination][_value][_data[all]][_nonce][caller]\n      stor1[_destination][_value][_data[all]][_nonce][caller] = 1\n      mem[ceil32(_data.length) + 320] = sha3(_destination, _value, _data[all], _nonce)\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          mem[ceil32(_data.length) + 288] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = ceil32(_data.length) + 288\n          s = 0\n          while ceil32(_data.length) + stor0[_destination][_value][_data[all]][_nonce][2].length + 288 > idx + 32:\n              mem[idx + 32] = stor0[_destination][_value][_data[all]][_nonce][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[ceil32(_data.length) + 288 len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[ceil32(_data.length) + 292 len stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  return sha3(_destination, _value, _data[all], _nonce)\n\ndef submitTransactionWithSignatures(address _destination, uint256 _value, bytes _data, uint256 _nonce, uint8[] _v, bytes32[] _rs): # not payable\n  mem[96] = _data.length\n  mem[128 len _data.length] = _data[all]\n  require _destination\n  mem[ceil32(_data.length) + 148] = _value\n  mem[ceil32(_data.length) + 180 len _data.length] = _data[all]\n  mem[_data.length + ceil32(_data.length) + 180] = _nonce\n  if addr(stor0[_destination][_value][_data[all]][_nonce].field_0):\n      mem[ceil32(_data.length) + 128] = _v.length\n      mem[ceil32(_data.length) + 160 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n      mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 192\n      mem[ceil32(_data.length) + (32 * _v.length) + 160] = _rs.length\n      mem[ceil32(_data.length) + (32 * _v.length) + 192 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n      idx = 0\n      while idx < _v.length:\n          require idx < mem[ceil32(_data.length) + 128]\n          _460 = mem[(32 * idx) + ceil32(_data.length) + 160]\n          require idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _467 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 192]\n          require mem[ceil32(_data.length) + 128] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _481 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 128] + idx) + 192]\n          _482 = mem[64]\n          mem[64] = mem[64] + 32\n          mem[_482 + 64] = 0\n          mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n          mem[mem[64] + 32] = uint8(_460)\n          mem[mem[64] + 64] = _467\n          mem[mem[64] + 96] = _481\n          signer = erecover(sha3(_destination, _value, _data[all], _nonce), _460 << 248, _467, _481) # precompiled\n          mem[mem[64] - 32] = signer\n          require erecover.result\n          mem[0] = addr(signer)\n          mem[32] = 2\n          require stor2[addr(signer)]\n          idx = idx + 1\n          continue \n      _895 = mem[ceil32(_data.length) + 128]\n      idx = 0\n      while idx < _895:\n          require idx < mem[ceil32(_data.length) + 128]\n          _902 = mem[(32 * idx) + ceil32(_data.length) + 160]\n          require idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _918 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 192]\n          require idx + mem[ceil32(_data.length) + 128] < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _933 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 128]) + 192]\n          _934 = mem[64]\n          mem[64] = mem[64] + 32\n          mem[_934 + 64] = 0\n          mem[mem[64] + 32] = uint8(_902)\n          mem[mem[64] + 64] = _918\n          mem[mem[64] + 96] = _933\n          signer = erecover(sha3(_destination, _value, _data[all], _nonce), _902 << 248, _918, _933) # precompiled\n          mem[mem[64] - 32] = signer\n          require erecover.result\n          require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n          mem[0] = addr(signer)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n          mem[mem[64]] = addr(signer)\n          mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n          log Confirmation(\n                address owner=addr(signer),\n                bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n          _895 = mem[ceil32(_data.length) + 128]\n          idx = idx + 1\n          continue \n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          _1384 = mem[64]\n          mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n          mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = mem[64]\n          s = 0\n          while _1384 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n              mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[mem[64] + 4 len _1384 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  else:\n      mem[ceil32(_data.length) + 128] = _destination\n      mem[ceil32(_data.length) + 160] = _value\n      mem[ceil32(_data.length) + 192] = 96\n      mem[ceil32(_data.length) + 224] = _nonce\n      mem[ceil32(_data.length) + 256] = 0\n      addr(stor0[_destination][_value][_data[all]][_nonce].field_0) = _destination\n      stor0[_destination][_value][_data[all]][_nonce].field_256 = _value\n      stor0[_destination][_value][_data[all]][_nonce][2][].field_0 = Array(len=_data.length, data=_data[all])\n      stor0[_destination][_value][_data[all]][_nonce].field_768 = _nonce\n      uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 0\n      stor0[_destination][_value][_data[all]][_nonce].field_1280 % 1 = 0\n      stor4.length++\n      if not stor4.length > stor4.length + 1:\n          stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n          log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n          mem[ceil32(_data.length) + 288] = _v.length\n          mem[ceil32(_data.length) + 320 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n          mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 352\n          mem[ceil32(_data.length) + (32 * _v.length) + 320] = _rs.length\n          mem[ceil32(_data.length) + (32 * _v.length) + 352 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n          idx = 0\n          while idx < _v.length:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1323 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1342 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require mem[ceil32(_data.length) + 288] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1366 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 288] + idx) + 352]\n              _1367 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1367 + 64] = 0\n              mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n              mem[mem[64] + 32] = uint8(_1323)\n              mem[mem[64] + 64] = _1342\n              mem[mem[64] + 96] = _1366\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1323 << 248, _1342, _1366) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              mem[0] = addr(signer)\n              mem[32] = 2\n              require stor2[addr(signer)]\n              idx = idx + 1\n              continue \n          _1646 = mem[ceil32(_data.length) + 288]\n          idx = 0\n          while idx < _1646:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1662 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1677 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require idx + mem[ceil32(_data.length) + 288] < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1691 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 288]) + 352]\n              _1692 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1692 + 64] = 0\n              mem[mem[64] + 32] = uint8(_1662)\n              mem[mem[64] + 64] = _1677\n              mem[mem[64] + 96] = _1691\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1662 << 248, _1677, _1691) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n              mem[0] = addr(signer)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n              mem[mem[64]] = addr(signer)\n              mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n              log Confirmation(\n                    address owner=addr(signer),\n                    bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n              _1646 = mem[ceil32(_data.length) + 288]\n              idx = idx + 1\n              continue \n          require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n          idx = 0\n          s = 0\n          while idx < stor3.length:\n              mem[0] = addr(stor3[idx].field_0)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n                  idx = idx + 1\n                  s = s\n                  continue \n              idx = idx + 1\n              s = s + 1\n              continue \n          if s == required:\n              uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n              _1912 = mem[64]\n              mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n              mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n              idx = mem[64]\n              s = 0\n              while _1912 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n                  mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n                 value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[mem[64] + 4 len _1912 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n              require ext_call.success\n              log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n      else:\n          idx = stor4.length + 1\n          while stor4.length > idx:\n              stor4[idx] = 0\n              idx = idx + 1\n              continue \n          stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n          log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n          mem[ceil32(_data.length) + 288] = _v.length\n          mem[ceil32(_data.length) + 320 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n          mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 352\n          mem[ceil32(_data.length) + (32 * _v.length) + 320] = _rs.length\n          mem[ceil32(_data.length) + (32 * _v.length) + 352 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n          idx = 0\n          while idx < _v.length:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1665 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1681 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require mem[ceil32(_data.length) + 288] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1698 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 288] + idx) + 352]\n              _1699 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1699 + 64] = 0\n              mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n              mem[mem[64] + 32] = uint8(_1665)\n              mem[mem[64] + 64] = _1681\n              mem[mem[64] + 96] = _1698\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1665 << 248, _1681, _1698) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              mem[0] = addr(signer)\n              mem[32] = 2\n              require stor2[addr(signer)]\n              idx = idx + 1\n              continue \n          _1882 = mem[ceil32(_data.length) + 288]\n          idx = 0\n          while idx < _1882:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1893 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1900 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require idx + mem[ceil32(_data.length) + 288] < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1905 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 288]) + 352]\n              _1906 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1906 + 64] = 0\n              mem[mem[64] + 32] = uint8(_1893)\n              mem[mem[64] + 64] = _1900\n              mem[mem[64] + 96] = _1905\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1893 << 248, _1900, _1905) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n              mem[0] = addr(signer)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n              mem[mem[64]] = addr(signer)\n              mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n              log Confirmation(\n                    address owner=addr(signer),\n                    bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n              _1882 = mem[ceil32(_data.length) + 288]\n              idx = idx + 1\n              continue \n          require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n          idx = 0\n          s = 0\n          while idx < stor3.length:\n              mem[0] = addr(stor3[idx].field_0)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n                  idx = idx + 1\n                  s = s\n                  continue \n              idx = idx + 1\n              s = s + 1\n              continue \n          if s == required:\n              uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n              _2017 = mem[64]\n              mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n              mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n              idx = mem[64]\n              s = 0\n              while _2017 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n                  mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n                 value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[mem[64] + 4 len _2017 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n              require ext_call.success\n              log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  return sha3(_destination, _value, _data[all], _nonce)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  stor3 is array of struct at storage 3\n  stor4 is array of uint256 at storage 4\n  required is uint256 at storage 5\n\ndef confirmations(bytes32 _param1, address _param2): # not payable\n  return bool(stor1[_param1][_param2])\n\ndef isOwner(address _owner): # not payable\n  return bool(stor2[_owner])\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=caller,\n            uint256 value=call.value)\n\ndef updateRequired(uint256 _required): # not payable\n  require caller == this.address\n  require _required <= stor3.length\n  require _required\n  require stor3.length\n  required = _required\n  log RequiredUpdate(uint256 required=_required)\n\ndef revokeConfirmation(bytes32 _transactionId): # not payable\n  require stor2[caller]\n  require stor1[_transactionId][caller]\n  require not uint8(stor0[_transactionId].field_1024)\n  stor1[_transactionId][caller] = 0\n  log Revocation(\n        address sender=caller,\n        bytes32 transactionHash=_transactionId)\n\ndef confirmationCount(bytes32 _TransHash): # not payable\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(bytes32 _TransHash): # not payable\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s != required:\n      return 0\n  return 1\n\ndef addOwner(address _owner): # not payable\n  require caller == this.address\n  require not stor2[addr(_owner)]\n  stor2[addr(_owner)] = 1\n  stor3.length++\n  if not stor3.length <= stor3.length + 1:\n      idx = stor3.length + 1\n      while stor3.length > idx:\n          stor3[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  addr(stor3[stor3.length].field_0) = _owner\n  log OwnerAddition(address owner=_owner)\n\ndef transactions(bytes32 _param1): # not payable\n  mem[288] = stor0[_param1][2].field_0\n  idx = 288\n  s = 0\n  while stor0[_param1][2].length + 288 > idx + 32:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return addr(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[288 len stor0[_param1][2].length + (floor32(stor0[_param1][2].length - 1) + -stor0[_param1][2].length + 32 % 32)]),\n         stor0[_param1].field_768,\n         bool(uint8(stor0[_param1].field_1024))\n\ndef getPendingTransactions(): # not payable\n  idx = 0\n  while idx < stor4.length:\n      require idx < stor4.length\n      mem[0] = stor4[idx]\n      mem[32] = 0\n      if not uint8(stor0[stor4[idx]].field_1024):\n          require idx < stor4.length\n          mem[0] = 4\n          require 0 < stor4.length\n          mem[224] = stor4[idx]\n      idx = idx + 1\n      continue \n  if 256 >= (32 * stor4.length) + 224:\n      return ''\n  mem[(32 * stor4.length) + 256] = 32\n  mem[(32 * stor4.length) + 288] = mem[(32 * stor4.length) + 224]\n  mem[(32 * stor4.length) + 320 len 32 * mem[(32 * stor4.length) + 224]] = mem[(32 * stor4.length) + 256 len 32 * mem[(32 * stor4.length) + 224]]\n  return 32, mem[(32 * stor4.length) + 288 len (32 * mem[(32 * stor4.length) + 224]) + 32]\n\ndef executeTransaction(bytes32 _TransHash): # not payable\n  require not uint8(stor0[_TransHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_TransHash, 1)\n      if not stor1[_TransHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_TransHash].field_1024) = 1\n      mem[96] = stor0[_TransHash][2].field_0\n      idx = 96\n      s = 0\n      while stor0[_TransHash][2].length + 96 > idx + 32:\n          mem[idx + 32] = stor0[_TransHash][s + 2].field_256\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_TransHash].field_0).mem[96 len 4] with:\n         value stor0[_TransHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[100 len stor0[_TransHash][2].length + (floor32(stor0[_TransHash][2].length - 1) + -stor0[_TransHash][2].length + 32 % 32) - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_TransHash)\n\ndef confirmTransaction(bytes32 _dataHash): # not payable\n  require stor2[caller]\n  require not stor1[_dataHash][caller]\n  stor1[_dataHash][caller] = 1\n  mem[128] = _dataHash\n  log Confirmation(\n        address owner=caller,\n        bytes32 operation=_dataHash)\n  require not uint8(stor0[_dataHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_dataHash, 1)\n      if not stor1[_dataHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_dataHash].field_1024) = 1\n      mem[96] = stor0[_dataHash][2].field_0\n      idx = 96\n      s = 0\n      while stor0[_dataHash][2].length + 96 > idx + 32:\n          mem[idx + 32] = stor0[_dataHash][s + 2].field_256\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_dataHash].field_0).mem[96 len 4] with:\n         value stor0[_dataHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[100 len stor0[_dataHash][2].length + (floor32(stor0[_dataHash][2].length - 1) + -stor0[_dataHash][2].length + 32 % 32) - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_dataHash)\n\ndef removeOwner(address _owner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  stor2[addr(_owner)] = 0\n  idx = 0\n  while idx < stor3.length - 1:\n      require idx < stor3.length\n      mem[0] = 3\n      if addr(stor3[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require stor3.length - 1 < stor3.length\n      require idx < stor3.length\n      uint64(stor3[idx].field_0) = uint64(stor3[stor3.length].field_0)\n      Mask(96, 0, stor3[idx].field_64) = 0\n      stor3.length--\n      if not stor3.length <= stor3.length - 1:\n          idx = stor3.length + sha3(3) - 1\n          while sha3(3) + stor3.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > stor3.length:\n          require caller == this.address\n          require stor3.length <= stor3.length\n          require stor3.length\n          require stor3.length\n          required = stor3.length\n          log RequiredUpdate(uint256 required=stor3.length)\n      log OwnerRemoval(address owner=_owner)\n      stop\n  stor3.length--\n  if not stor3.length <= stor3.length - 1:\n      idx = stor3.length - 1\n      while stor3.length > idx:\n          stor3[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > stor3.length:\n      require caller == this.address\n      require stor3.length <= stor3.length\n      require stor3.length\n      require stor3.length\n      required = stor3.length\n      log RequiredUpdate(uint256 required=stor3.length)\n  log OwnerRemoval(address owner=_owner)\n\ndef getExecutedTransactions(): # not payable\n  idx = 0\n  s = 0\n  while idx < stor4.length:\n      require idx < stor4.length\n      mem[0] = stor4[idx]\n      mem[32] = 0\n      if not uint8(stor0[stor4[idx]].field_1024):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < stor4.length\n      mem[0] = 4\n      require s < stor4.length\n      mem[(32 * s) + 224] = stor4[idx]\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 256 < (32 * stor4.length) + 224:\n      mem[(32 * stor4.length) + 224] = s\n      t = 0\n      while t < s:\n          require t < stor4.length\n          if mem[(32 * t) + 224] > 0:\n              require t < stor4.length\n              require t < s\n              mem[(32 * stor4.length) + (32 * t) + 256] = mem[(32 * t) + 224]\n          t = t + 1\n          continue \n      return Array(len=s, data=mem[(32 * stor4.length) + 256 len 32 * s])\n  mem[(32 * s) + 256] = s\n  t = 0\n  while t < s:\n      require t < stor4.length\n      if mem[(32 * t) + 224] > 0:\n          require t < stor4.length\n          require t < s, None\n          mem[(32 * s) + (32 * t) + 288] = mem[(32 * t) + 224]\n      t = t + 1\n      continue \n  mem[(64 * s) + 288] = 32\n  mem[(64 * s) + 320] = s, None\n  mem[(64 * s) + 352 len 32 * s] = mem[(32 * s) + 288 len 32 * s]\n  return memory\n    from (64 * s) + 288\n     len (32 * s, None) + 64\n\ndef confirmTransactionWithSignatures(bytes32 _transactionHash, uint8[] _v, bytes32[] _rs): # not payable\n  mem[96] = _v.length\n  mem[128 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n  mem[64] = (32 * _rs.length) + (32 * _v.length) + 160\n  mem[(32 * _v.length) + 128] = _rs.length\n  mem[(32 * _v.length) + 160 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n  idx = 0\n  while idx < _v.length:\n      require idx < mem[96]\n      _55 = mem[(32 * idx) + 128]\n      require idx < mem[(32 * _v.length) + 128]\n      _58 = mem[(32 * idx) + (32 * _v.length) + 160]\n      require mem[96] + idx < mem[(32 * _v.length) + 128]\n      _64 = mem[(32 * _v.length) + (32 * mem[96] + idx) + 160]\n      _65 = mem[64]\n      mem[64] = mem[64] + 32\n      mem[_65 + 64] = 0\n      mem[mem[64]] = _transactionHash\n      mem[mem[64] + 32] = uint8(_55)\n      mem[mem[64] + 64] = _58\n      mem[mem[64] + 96] = _64\n      signer = erecover(_transactionHash, _55 << 248, _58, _64) # precompiled\n      mem[mem[64] - 32] = signer\n      require erecover.result\n      mem[0] = addr(signer)\n      mem[32] = 2\n      require stor2[addr(signer)]\n      idx = idx + 1\n      continue \n  _101 = mem[96]\n  idx = 0\n  while idx < _101:\n      require idx < mem[96]\n      _104 = mem[(32 * idx) + 128]\n      require idx < mem[(32 * _v.length) + 128]\n      _106 = mem[(32 * idx) + (32 * _v.length) + 160]\n      require idx + mem[96] < mem[(32 * _v.length) + 128]\n      _109 = mem[(32 * _v.length) + (32 * idx + mem[96]) + 160]\n      _110 = mem[64]\n      mem[64] = mem[64] + 32\n      mem[_110 + 64] = 0\n      mem[mem[64] + 32] = uint8(_104)\n      mem[mem[64] + 64] = _106\n      mem[mem[64] + 96] = _109\n      signer = erecover(_transactionHash, _104 << 248, _106, _109) # precompiled\n      mem[mem[64] - 32] = signer\n      require erecover.result\n      require not stor1[_transactionHash][addr(signer)]\n      mem[0] = addr(signer)\n      mem[32] = sha3(_transactionHash, 1)\n      stor1[_transactionHash][addr(signer)] = 1\n      mem[mem[64]] = addr(signer)\n      mem[mem[64] + 32] = _transactionHash\n      log Confirmation(\n            address owner=addr(signer),\n            bytes32 operation=_transactionHash)\n      _101 = mem[96]\n      idx = idx + 1\n      continue \n  require not uint8(stor0[_transactionHash].field_1024)\n  idx = 0\n  s = 0\n  while idx < stor3.length:\n      mem[0] = addr(stor3[idx].field_0)\n      mem[32] = sha3(_transactionHash, 1)\n      if not stor1[_transactionHash][addr(stor3[idx].field_0)]:\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  if s == required:\n      uint8(stor0[_transactionHash].field_1024) = 1\n      _140 = mem[64]\n      mem[0] = sha3(_transactionHash, 0) + 2\n      mem[mem[64]] = stor0[_transactionHash][2].field_0\n      idx = mem[64]\n      s = 0\n      while _140 + stor0[_transactionHash][2].length > idx + 32:\n          mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionHash].field_0).mem[mem[64] len 4] with:\n         value stor0[_transactionHash].field_256 wei\n           gas gas_remaining - 34050 wei\n          args mem[mem[64] + 4 len _140 + stor0[_transactionHash][2].length + (floor32(stor0[_transactionHash][2].length - 1) + -stor0[_transactionHash][2].length + 32 % 32) + -mem[64] - 4]\n      require ext_call.success\n      log Execution(bytes32 transactionHash=_transactionHash)\n\ndef submitTransaction(address _destination, uint256 _value, bytes _data, uint256 _nonce): # not payable\n  mem[128 len _data.length] = _data[all]\n  require _destination\n  mem[ceil32(_data.length) + 180 len _data.length] = _data[all]\n  mem[_data.length + ceil32(_data.length) + 180] = _nonce\n  if addr(stor0[_destination][_value][_data[all]][_nonce].field_0):\n      require stor2[caller]\n      require not stor1[_destination][_value][_data[all]][_nonce][caller]\n      stor1[_destination][_value][_data[all]][_nonce][caller] = 1\n      mem[ceil32(_data.length) + 160] = sha3(_destination, _value, _data[all], _nonce)\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          mem[ceil32(_data.length) + 128] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = ceil32(_data.length) + 128\n          s = 0\n          while ceil32(_data.length) + stor0[_destination][_value][_data[all]][_nonce][2].length + 128 > idx + 32:\n              mem[idx + 32] = stor0[_destination][_value][_data[all]][_nonce][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[ceil32(_data.length) + 128 len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[ceil32(_data.length) + 132 len stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  else:\n      addr(stor0[_destination][_value][_data[all]][_nonce].field_0) = _destination\n      stor0[_destination][_value][_data[all]][_nonce].field_256 = _value\n      stor0[_destination][_value][_data[all]][_nonce][2][].field_0 = Array(len=_data.length, data=_data[all])\n      stor0[_destination][_value][_data[all]][_nonce].field_768 = _nonce\n      uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 0\n      stor0[_destination][_value][_data[all]][_nonce].field_1280 % 1 = 0\n      stor4.length++\n      if not stor4.length <= stor4.length + 1:\n          idx = stor4.length + 1\n          while stor4.length > idx:\n              stor4[idx] = 0\n              idx = idx + 1\n              continue \n      stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n      log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n      require stor2[caller]\n      require not stor1[_destination][_value][_data[all]][_nonce][caller]\n      stor1[_destination][_value][_data[all]][_nonce][caller] = 1\n      mem[ceil32(_data.length) + 320] = sha3(_destination, _value, _data[all], _nonce)\n      log Confirmation(\n            address owner=caller,\n            bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          mem[ceil32(_data.length) + 288] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = ceil32(_data.length) + 288\n          s = 0\n          while ceil32(_data.length) + stor0[_destination][_value][_data[all]][_nonce][2].length + 288 > idx + 32:\n              mem[idx + 32] = stor0[_destination][_value][_data[all]][_nonce][s + 2].field_256\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[ceil32(_data.length) + 288 len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[ceil32(_data.length) + 292 len stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  return sha3(_destination, _value, _data[all], _nonce)\n\ndef submitTransactionWithSignatures(address _destination, uint256 _value, bytes _data, uint256 _nonce, uint8[] _v, bytes32[] _rs): # not payable\n  mem[96] = _data.length\n  mem[128 len _data.length] = _data[all]\n  require _destination\n  mem[ceil32(_data.length) + 148] = _value\n  mem[ceil32(_data.length) + 180 len _data.length] = _data[all]\n  mem[_data.length + ceil32(_data.length) + 180] = _nonce\n  if addr(stor0[_destination][_value][_data[all]][_nonce].field_0):\n      mem[ceil32(_data.length) + 128] = _v.length\n      mem[ceil32(_data.length) + 160 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n      mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 192\n      mem[ceil32(_data.length) + (32 * _v.length) + 160] = _rs.length\n      mem[ceil32(_data.length) + (32 * _v.length) + 192 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n      idx = 0\n      while idx < _v.length:\n          require idx < mem[ceil32(_data.length) + 128]\n          _460 = mem[(32 * idx) + ceil32(_data.length) + 160]\n          require idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _467 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 192]\n          require mem[ceil32(_data.length) + 128] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _481 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 128] + idx) + 192]\n          _482 = mem[64]\n          mem[64] = mem[64] + 32\n          mem[_482 + 64] = 0\n          mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n          mem[mem[64] + 32] = uint8(_460)\n          mem[mem[64] + 64] = _467\n          mem[mem[64] + 96] = _481\n          signer = erecover(sha3(_destination, _value, _data[all], _nonce), _460 << 248, _467, _481) # precompiled\n          mem[mem[64] - 32] = signer\n          require erecover.result\n          mem[0] = addr(signer)\n          mem[32] = 2\n          require stor2[addr(signer)]\n          idx = idx + 1\n          continue \n      _895 = mem[ceil32(_data.length) + 128]\n      idx = 0\n      while idx < _895:\n          require idx < mem[ceil32(_data.length) + 128]\n          _902 = mem[(32 * idx) + ceil32(_data.length) + 160]\n          require idx < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _918 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 192]\n          require idx + mem[ceil32(_data.length) + 128] < mem[ceil32(_data.length) + (32 * _v.length) + 160]\n          _933 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 128]) + 192]\n          _934 = mem[64]\n          mem[64] = mem[64] + 32\n          mem[_934 + 64] = 0\n          mem[mem[64] + 32] = uint8(_902)\n          mem[mem[64] + 64] = _918\n          mem[mem[64] + 96] = _933\n          signer = erecover(sha3(_destination, _value, _data[all], _nonce), _902 << 248, _918, _933) # precompiled\n          mem[mem[64] - 32] = signer\n          require erecover.result\n          require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n          mem[0] = addr(signer)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n          mem[mem[64]] = addr(signer)\n          mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n          log Confirmation(\n                address owner=addr(signer),\n                bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n          _895 = mem[ceil32(_data.length) + 128]\n          idx = idx + 1\n          continue \n      require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n      idx = 0\n      s = 0\n      while idx < stor3.length:\n          mem[0] = addr(stor3[idx].field_0)\n          mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n          if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n              idx = idx + 1\n              s = s\n              continue \n          idx = idx + 1\n          s = s + 1\n          continue \n      if s == required:\n          uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n          _1384 = mem[64]\n          mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n          mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n          idx = mem[64]\n          s = 0\n          while _1384 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n              mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n              idx = idx + 32\n              s = s + 1\n              continue \n          call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n             value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n               gas gas_remaining - 34050 wei\n              args mem[mem[64] + 4 len _1384 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n          require ext_call.success\n          log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  else:\n      mem[ceil32(_data.length) + 128] = _destination\n      mem[ceil32(_data.length) + 160] = _value\n      mem[ceil32(_data.length) + 192] = 96\n      mem[ceil32(_data.length) + 224] = _nonce\n      mem[ceil32(_data.length) + 256] = 0\n      addr(stor0[_destination][_value][_data[all]][_nonce].field_0) = _destination\n      stor0[_destination][_value][_data[all]][_nonce].field_256 = _value\n      stor0[_destination][_value][_data[all]][_nonce][2][].field_0 = Array(len=_data.length, data=_data[all])\n      stor0[_destination][_value][_data[all]][_nonce].field_768 = _nonce\n      uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 0\n      stor0[_destination][_value][_data[all]][_nonce].field_1280 % 1 = 0\n      stor4.length++\n      if not stor4.length > stor4.length + 1:\n          stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n          log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n          mem[ceil32(_data.length) + 288] = _v.length\n          mem[ceil32(_data.length) + 320 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n          mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 352\n          mem[ceil32(_data.length) + (32 * _v.length) + 320] = _rs.length\n          mem[ceil32(_data.length) + (32 * _v.length) + 352 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n          idx = 0\n          while idx < _v.length:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1323 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1342 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require mem[ceil32(_data.length) + 288] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1366 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 288] + idx) + 352]\n              _1367 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1367 + 64] = 0\n              mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n              mem[mem[64] + 32] = uint8(_1323)\n              mem[mem[64] + 64] = _1342\n              mem[mem[64] + 96] = _1366\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1323 << 248, _1342, _1366) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              mem[0] = addr(signer)\n              mem[32] = 2\n              require stor2[addr(signer)]\n              idx = idx + 1\n              continue \n          _1646 = mem[ceil32(_data.length) + 288]\n          idx = 0\n          while idx < _1646:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1662 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1677 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require idx + mem[ceil32(_data.length) + 288] < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1691 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 288]) + 352]\n              _1692 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1692 + 64] = 0\n              mem[mem[64] + 32] = uint8(_1662)\n              mem[mem[64] + 64] = _1677\n              mem[mem[64] + 96] = _1691\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1662 << 248, _1677, _1691) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n              mem[0] = addr(signer)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n              mem[mem[64]] = addr(signer)\n              mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n              log Confirmation(\n                    address owner=addr(signer),\n                    bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n              _1646 = mem[ceil32(_data.length) + 288]\n              idx = idx + 1\n              continue \n          require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n          idx = 0\n          s = 0\n          while idx < stor3.length:\n              mem[0] = addr(stor3[idx].field_0)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n                  idx = idx + 1\n                  s = s\n                  continue \n              idx = idx + 1\n              s = s + 1\n              continue \n          if s == required:\n              uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n              _1912 = mem[64]\n              mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n              mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n              idx = mem[64]\n              s = 0\n              while _1912 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n                  mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n                 value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[mem[64] + 4 len _1912 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n              require ext_call.success\n              log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n      else:\n          idx = stor4.length + 1\n          while stor4.length > idx:\n              stor4[idx] = 0\n              idx = idx + 1\n              continue \n          stor4[stor4.length] = sha3(_destination, _value, _data[all], _nonce)\n          log Submission(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n          mem[ceil32(_data.length) + 288] = _v.length\n          mem[ceil32(_data.length) + 320 len 32 * _v.length] = call.data[_v + 36 len 32 * _v.length]\n          mem[64] = (32 * _rs.length) + ceil32(_data.length) + (32 * _v.length) + 352\n          mem[ceil32(_data.length) + (32 * _v.length) + 320] = _rs.length\n          mem[ceil32(_data.length) + (32 * _v.length) + 352 len 32 * _rs.length] = call.data[_rs + 36 len 32 * _rs.length]\n          idx = 0\n          while idx < _v.length:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1665 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1681 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require mem[ceil32(_data.length) + 288] + idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1698 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * mem[ceil32(_data.length) + 288] + idx) + 352]\n              _1699 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1699 + 64] = 0\n              mem[mem[64]] = sha3(_destination, _value, _data[all], _nonce)\n              mem[mem[64] + 32] = uint8(_1665)\n              mem[mem[64] + 64] = _1681\n              mem[mem[64] + 96] = _1698\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1665 << 248, _1681, _1698) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              mem[0] = addr(signer)\n              mem[32] = 2\n              require stor2[addr(signer)]\n              idx = idx + 1\n              continue \n          _1882 = mem[ceil32(_data.length) + 288]\n          idx = 0\n          while idx < _1882:\n              require idx < mem[ceil32(_data.length) + 288]\n              _1893 = mem[(32 * idx) + ceil32(_data.length) + 320]\n              require idx < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1900 = mem[(32 * idx) + ceil32(_data.length) + (32 * _v.length) + 352]\n              require idx + mem[ceil32(_data.length) + 288] < mem[ceil32(_data.length) + (32 * _v.length) + 320]\n              _1905 = mem[ceil32(_data.length) + (32 * _v.length) + (32 * idx + mem[ceil32(_data.length) + 288]) + 352]\n              _1906 = mem[64]\n              mem[64] = mem[64] + 32\n              mem[_1906 + 64] = 0\n              mem[mem[64] + 32] = uint8(_1893)\n              mem[mem[64] + 64] = _1900\n              mem[mem[64] + 96] = _1905\n              signer = erecover(sha3(_destination, _value, _data[all], _nonce), _1893 << 248, _1900, _1905) # precompiled\n              mem[mem[64] - 32] = signer\n              require erecover.result\n              require not stor1[_destination][_value][_data[all]][_nonce][addr(signer)]\n              mem[0] = addr(signer)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              stor1[_destination][_value][_data[all]][_nonce][addr(signer)] = 1\n              mem[mem[64]] = addr(signer)\n              mem[mem[64] + 32] = sha3(_destination, _value, _data[all], _nonce)\n              log Confirmation(\n                    address owner=addr(signer),\n                    bytes32 operation=sha3(_destination, _value, _data[all], _nonce))\n              _1882 = mem[ceil32(_data.length) + 288]\n              idx = idx + 1\n              continue \n          require not uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024)\n          idx = 0\n          s = 0\n          while idx < stor3.length:\n              mem[0] = addr(stor3[idx].field_0)\n              mem[32] = sha3(sha3(_destination, _value, _data[all], _nonce), 1)\n              if not stor1[_destination][_value][_data[all]][_nonce][addr(stor3[idx].field_0)]:\n                  idx = idx + 1\n                  s = s\n                  continue \n              idx = idx + 1\n              s = s + 1\n              continue \n          if s == required:\n              uint8(stor0[_destination][_value][_data[all]][_nonce].field_1024) = 1\n              _2017 = mem[64]\n              mem[0] = sha3(sha3(_destination, _value, _data[all], _nonce), 0) + 2\n              mem[mem[64]] = stor0[_destination][_value][_data[all]][_nonce][2].field_0\n              idx = mem[64]\n              s = 0\n              while _2017 + stor0[_destination][_value][_data[all]][_nonce][2].length > idx + 32:\n                  mem[idx + 32] = stor[s + sha3(mem[0]) + 1]\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call addr(stor0[_destination][_value][_data[all]][_nonce].field_0).mem[mem[64] len 4] with:\n                 value stor0[_destination][_value][_data[all]][_nonce].field_256 wei\n                   gas gas_remaining - 34050 wei\n                  args mem[mem[64] + 4 len _2017 + stor0[_destination][_value][_data[all]][_nonce][2].length + (floor32(stor0[_destination][_value][_data[all]][_nonce][2].length - 1) + -stor0[_destination][_value][_data[all]][_nonce][2].length + 32 % 32) + -mem[64] - 4]\n              require ext_call.success\n              log Execution(bytes32 transactionHash=sha3(_destination, _value, _data[all], _nonce))\n  return sha3(_destination, _value, _data[all], _nonce)\n\n.",
	"status": "1",
	"time_cost": 62.25412654876709,
	"usage": {
		"completion_tokens": 1098,
		"prompt_tokens": 11224,
		"total_tokens": 12322
	}
}