{
	"address": "0x7da82c7ab4771ff031b66538d2fb9b0b047f6cf9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Apologies for the confusion, but the provided decompiled code is quite complex and not easy to translate directly into Solidity due to some unclear instructions and operations. It's difficult to infer the original Solidity code solely based on this decompiled code.\n\nHowever, this seems like a multi-signature wallet contract. The following is a simplified version of a multi-signature contract in Solidity. It's not an exact representation of your provided decompiled code, but it might be helpful for you to understand the basic structure and operations of a multi-signature wallet contract.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MultiSigWallet {\n    address[] public owners;\n    uint public required;\n    mapping (address => bool) public isOwner;\n    mapping (uint => Transaction) public transactions;\n    uint public transactionCount;\n    \n    struct Transaction {\n        bool executed;\n        address destination;\n        uint value;\n        bytes data;\n    }\n\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n\n    modifier onlyOwner {\n        require(isOwner[msg.sender]);\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _required) {\n        require(_owners.length >= _required && _required > 0);\n        for (uint i = 0; i < _owners.length; i++) {\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    function submitTransaction(address destination, uint value, bytes memory data) public onlyOwner {\n        uint transactionId = addTransaction(destination, value, data);\n        emit Submission(transactionId);\n    }\n\n    function addTransaction(address destination, uint value, bytes memory data) internal returns (uint transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            executed: false,\n            destination: destination,\n            value: value,\n            data: data\n        });\n        transactionCount += 1;\n    }\n\n    function executeTransaction(uint transactionId) public onlyOwner {\n        require(!transactions[transactionId].executed, \"Transaction has been executed already\");\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            (bool success, ) = txn.destination.call{value: txn.value}(txn.data);\n            if (success)\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    function isConfirmed(uint transactionId) public view returns (bool) {\n        // implement your confirmation logic\n    }\n\n    receive() external payable {\n        if (msg.value > 0) {\n            emit Deposit(msg.sender, msg.value);\n        }\n    }\n}\n```\n\nAgain, this is a simple example and doesn't cover all the functionality in your decompiled code. Please use this as a reference and modify it according to your requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038513,
	"id": "chatcmpl-8ChftM89ZoXYTj8CFMulgDPvOGApF",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 15:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _updateRequired; // STORAGE[0x3]\nuint256[] _getPendingTransactions; // STORAGE[0x4]\nuint256 _required; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nOwnerAddition(address);\nExecution(bytes32);\nRevocation(address, bytes32);\nSubmission(bytes32);\nConfirmation(address, bytes32);\n\nfunction confirmations(bytes32 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = 1549;\n    v0 = v2 = varg2 + 36;\n    v3 = v4 = (?).length;\n    v5 = new bytes[](v4);\n    assert(varg0);\n    MEM[MEM[64]] = varg0 << 96;\n    MEM[20 + MEM[64]] = varg1;\n    v6 = dataCopy(MEM[(v5.data) len (v5.length)], MEM[(52 + MEM[64]) len (v5.length)]);\n    MEM[v5.length + (52 + MEM[64])] = varg3;\n    v0 = v7 = keccak256(v8.data);\n    if (0 == address(_transactions[~0x0 & v7][0])) {\n        _transactions[v7] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[v7];\n        _transactions[v7][1] = varg1;\n        v9 = v10 = 32 + v5;\n        if (31 < MEM[v5]) {\n            _transactions[v7][2] = 1 + (MEM[v5] + MEM[v5]);\n            if (MEM[v5]) {\n                while (v10 + MEM[v5] > v9) {\n                    STORAGE[v11] = MEM[v9];\n                    v9 += 32;\n                    v11 += 1;\n                }\n            }\n        } else {\n            _transactions[v7][2] = MEM[v5] + MEM[v5] | ~0xff & MEM[v10];\n        }\n        while (v12 + (31 + ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) >> 5) > v11) {\n            STORAGE[v11] = 0;\n            v11 += 1;\n        }\n        _transactions[v7][3] = varg3;\n        _transactions[v7][4] = 0 >> 248 | ~0xff & _transactions[v7][0x4];\n        _getPendingTransactions.length = _getPendingTransactions.length + 1;\n        if (!_getPendingTransactions.length <= _getPendingTransactions.length + 1) {\n            v13 = v14 = _getPendingTransactions.length + 1 + keccak256(4);\n            while (keccak256(4) + _getPendingTransactions.length > v13) {\n                STORAGE[v13] = 0;\n                v13 += 1;\n            }\n            goto 0x107a0x14e;\n        }\n        _getPendingTransactions[_getPendingTransactions.length] = v7;\n        emit Submission(v7);\n    }\n    v3 = v15 = 2336;\n    v0 = msg.sender;\n    assert(0xff & _isOwner[address(v0)]);\n    assert(!(0xff & _confirmations[v7]));\n    _confirmations[v7] = 0x1 | ~0xff & _confirmations[v7];\n    emit Confirmation(msg.sender, v7);\n    v3 = v16 = 2408;\n    assert(!(0xff & _transactions[v7][0x4]));\n    v17 = v18 = 0;\n    while (v17 < _updateRequired.length) {\n        assert(v17 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v17]), keccak256(v7, 0x1))]) {\n            v17 += 1;\n        }\n        v17 += 1;\n    }\n    if (v17 == _required) {\n        v17 = v19 = 1;\n    }\n    if (v17) {\n        _transactions[v7][4] = 0x1 | ~0xff & _transactions[v7][0x4];\n        v20 = v21 = MEM[64];\n        if ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) {\n            if (31 < (_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v20] = STORAGE[v22];\n                    v22 += 1;\n                    v20 += 32;\n                } while (v21 + ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) <= v20);\n            }\n        }\n        v23 = address(_transactions[v7]).call(_transactions[v7][2] >> 8 << 8, v7).value(_transactions[v7][1]).gas(msg.gas - 34050);\n        assert(v23);\n        emit Execution(v7);\n    }\n    while (1) {\n        goto {'0x920', '0x9680x14e'};\n    }\n    return v0;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _updateRequired.length) {\n        if (v0 < _updateRequired.length) {\n            break;\n        }\n        assert(v0 < _updateRequired.length);\n        if (address(_updateRequired[v0]) != varg0) {\n            break;\n        }\n        if (address(_updateRequired[v0]) == varg0) {\n            assert(_updateRequired.length + ~0 < _updateRequired.length);\n            assert(v0 < _updateRequired.length);\n            _updateRequired[v0] = address(_updateRequired[_updateRequired.length + ~0]) << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _updateRequired[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _updateRequired.length = _updateRequired.length + ~0;\n    if (!_updateRequired.length <= _updateRequired.length + ~0) {\n        v2 = v3 = _updateRequired.length + ~0 + keccak256(3);\n        while (keccak256(3) + _updateRequired.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _updateRequired.length) {\n        assert(msg.sender == address(this));\n        v4 = v5 = _updateRequired.length > _updateRequired.length;\n        if (_updateRequired.length <= _updateRequired.length) {\n            v4 = v6 = !_updateRequired.length;\n        }\n        if (!v4) {\n            v4 = !_updateRequired.length;\n        }\n        assert(!v4);\n        _required = _updateRequired.length;\n        emit 0xcfd262243fb0dd33ba2604015772142a737b088fb078ec5aa18bea2c58c29a2(_updateRequired.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmationCount(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction updateRequired(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    v0 = v1 = varg0 > _updateRequired.length;\n    if (varg0 <= _updateRequired.length) {\n        v0 = v2 = !varg0;\n    }\n    if (!v0) {\n        v0 = !_updateRequired.length;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit 0xcfd262243fb0dd33ba2604015772142a737b088fb078ec5aa18bea2c58c29a2(varg0);\n}\n\nfunction transactions(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[]((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v0, _transactions[varg0][3], 0xff & _transactions[varg0][0x4];\n}\n\nfunction isConfirmed(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v2 = 1;\n    }\n    return v0;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _updateRequired.length = _updateRequired.length + 1;\n    if (!_updateRequired.length <= _updateRequired.length + 1) {\n        v0 = v1 = _updateRequired.length + 1 + keccak256(3);\n        while (keccak256(3) + _updateRequired.length > v0) {\n            STORAGE[v0] = 0;\n            v0 += 1;\n        }\n    }\n    _updateRequired[_updateRequired.length] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _updateRequired[_updateRequired.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction confirmTransaction(bytes32 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(!(0xff & _confirmations[msg.sender]));\n    _confirmations[msg.sender] = 0x1 | ~0xff & _confirmations[msg.sender];\n    emit Confirmation(msg.sender, varg0);\n    assert(!(0xff & _transactions[varg0][0x4]));\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v2 = 1;\n    }\n    if (v0) {\n        _transactions[varg0][4] = 0x1 | ~0xff & _transactions[varg0][0x4];\n        v3 = v4 = MEM[64];\n        if ((_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) {\n            if (31 < (_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v3] = STORAGE[v5];\n                    v5 += 1;\n                    v3 += 32;\n                } while (v4 + ((_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) <= v3);\n            }\n        }\n        v6 = address(_transactions[varg0]).call(_transactions[varg0][2] >> 8 << 8, varg0).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        assert(v6);\n        emit Execution(varg0);\n    }\n}\n\nfunction submitTransactionWithSignatures(address varg0, uint256 varg1, bytes varg2, uint256 varg3, uint8[] varg4, bytes32[] varg5) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    assert(varg0);\n    MEM[MEM[64]] = varg0 << 96;\n    MEM[20 + MEM[64]] = varg1;\n    v1 = dataCopy(MEM[(v0.data) len (v0.length)], MEM[(52 + MEM[64]) len (v0.length)]);\n    MEM[v0.length + (52 + MEM[64])] = varg3;\n    v2 = keccak256(v3.data);\n    if (0 == address(_transactions[~0x0 & v2][0])) {\n        _transactions[v2] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[v2];\n        _transactions[v2][1] = varg1;\n        v4 = v5 = 32 + v0;\n        if (31 < MEM[v0]) {\n            _transactions[v2][2] = 1 + (MEM[v0] + MEM[v0]);\n            if (MEM[v0]) {\n                while (v5 + MEM[v0] > v4) {\n                    STORAGE[v6] = MEM[v4];\n                    v4 += 32;\n                    v6 += 1;\n                }\n            }\n        } else {\n            _transactions[v2][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v5];\n        }\n        while (v7 + (31 + ((_transactions[v2][0x2] & ~0 + (!(_transactions[v2][0x2] & 0x1) << 8)) >> 1) >> 5) > v6) {\n            STORAGE[v6] = 0;\n            v6 += 1;\n        }\n        _transactions[v2][3] = varg3;\n        _transactions[v2][4] = 0 >> 248 | ~0xff & _transactions[v2][0x4];\n        _getPendingTransactions.length = _getPendingTransactions.length + 1;\n        if (!_getPendingTransactions.length <= _getPendingTransactions.length + 1) {\n            v8 = v9 = _getPendingTransactions.length + 1 + keccak256(4);\n            while (keccak256(4) + _getPendingTransactions.length > v8) {\n                STORAGE[v8] = 0;\n                v8 += 1;\n            }\n            goto 0x107a0x1a6B0x12f4;\n        }\n        _getPendingTransactions[_getPendingTransactions.length] = v2;\n        emit Submission(v2);\n    }\n    v10 = new uint256[]((?).length);\n    CALLDATACOPY(v10.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v11.data, varg5 + 36, (?).length << 5);\n    v12 = v13 = 0;\n    while (v12 < v10.length) {\n        assert(v12 < v10.length);\n        assert(v12 < v11.length);\n        assert(v10.length + v12 < v11.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v14, v15 = ecrecover(v2, v10[v12] & 0xff, v11[v12], v11[v10.length + v12]);\n        assert(v14);\n        assert(0xff & _isOwner[address(v15)]);\n        v12 += 1;\n    }\n    v16 = v17 = 0;\n    while (v16 < v10.length) {\n        assert(v16 < v10.length);\n        assert(v16 < v11.length);\n        assert(v16 + v10.length < v11.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v18 = ecrecover(v2, v10[v16] & 0xff, v11[v16], v11[v16 + v10.length]);\n        assert(v18);\n        assert(!(0xff & _confirmations[v2]));\n        _confirmations[v2] = 0x1 | ~0xff & _confirmations[v2];\n        emit Confirmation(address(v2), v2);\n        v16 = v16 + 1;\n    }\n    0x774(v2);\n    return v2;\n}\n\nfunction executeTransaction(bytes32 varg0) public payable { \n    assert(!msg.value);\n    0x774(varg0);\n}\n\nfunction getPendingTransactions() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = v1 = 1;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = new uint256[](_getPendingTransactions.length);\n    }\n    v2 = new uint256[](_getPendingTransactions.length);\n    v4 = v5 = 0;\n    v6 = v7 = 0;\n    while (v6 < _getPendingTransactions.length) {\n        if (v1) {\n            assert(v6 < _getPendingTransactions.length);\n            v0 = v8 = !(0xff & _transactions[_getPendingTransactions[v6]][0x4]);\n        }\n        if (!v0) {\n            v0 = v9 = !v1;\n            if (v9) {\n                assert(v6 < _getPendingTransactions.length);\n                v0 = 0xff & _transactions[_getPendingTransactions[v6]][0x4];\n            }\n        }\n        if (v0) {\n            assert(v6 < _getPendingTransactions.length);\n            assert(v4 < v2.length);\n            v2[v4] = _getPendingTransactions[v6];\n            v4 += 1;\n        }\n        v6 += 1;\n    }\n    v10 = v11 = MEM[64];\n    if (MSIZE() >= v11) {\n        v10 = new uint256[](v4);\n    }\n    v10 = new uint256[](v4);\n    v12 = v13 = 0;\n    while (v12 < v4) {\n        assert(v12 < v2.length);\n        if (v2[v12] > 0) {\n            assert(v12 < v2.length);\n            assert(v12 < v10.length);\n            v10[v12] = v2[v12];\n        }\n        v12 += 1;\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v10.length;\n    v14 = dataCopy(MEM[(v10.data) len (v10.length << 5)], MEM[(64 + MEM[64]) len (v10.length << 5)]);\n    return MEM[(MEM[64]) len ((v10.length << 5) + (64 + MEM[64]) - MEM[64])];\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction getExecutedTransactions() public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    MEM[MEM[64]] = v1;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_getPendingTransactions.length);\n    }\n    v2 = new uint256[](_getPendingTransactions.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _getPendingTransactions.length) {\n        if (v1) {\n            assert(v7 < _getPendingTransactions.length);\n            v0 = v9 = !(0xff & _transactions[_getPendingTransactions[v7]][0x4]);\n        }\n        if (!v0) {\n            v0 = v10 = !v1;\n            if (v10) {\n                assert(v7 < _getPendingTransactions.length);\n                v0 = 0xff & _transactions[_getPendingTransactions[v7]][0x4];\n            }\n        }\n        if (v0) {\n            assert(v7 < _getPendingTransactions.length);\n            assert(v5 < v2.length);\n            v2[v5] = _getPendingTransactions[v7];\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v11 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v11 = v13 = new uint256[](v5);\n    }\n    v11 = new uint256[](v5);\n    v14 = v15 = 0;\n    while (v14 < v5) {\n        assert(v14 < v2.length);\n        if (v2[v14] > 0) {\n            assert(v14 < v2.length);\n            assert(v14 < v11.length);\n            v11[v14] = v2[v14];\n        }\n        v14 += 1;\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v11.length;\n    v16 = dataCopy(MEM[(v11.data) len (v11.length << 5)], MEM[(64 + MEM[64]) len (v11.length << 5)]);\n    return MEM[(MEM[64]) len ((v11.length << 5) + (64 + MEM[64]) - MEM[64])];\n}\n\nfunction revokeConfirmation(bytes32 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][0x4]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction confirmTransactionWithSignatures(bytes32 varg0, uint8[] varg1, bytes32[] varg2) public payable { \n    assert(!msg.value);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length << 5);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        assert(v2 < v0.length);\n        assert(v2 < v1.length);\n        assert(v0.length + v2 < v1.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v4, v5 = ecrecover(varg0, v0[v2] & 0xff, v1[v2], v1[v0.length + v2]);\n        assert(v4);\n        assert(0xff & _isOwner[address(v5)]);\n        v2 += 1;\n    }\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        assert(v6 < v0.length);\n        assert(v6 < v1.length);\n        assert(v6 + v0.length < v1.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v8 = ecrecover(varg0, v0[v6] & 0xff, v1[v6], v1[v6 + v0.length]);\n        assert(v8);\n        assert(!(0xff & _confirmations[address(varg0)]));\n        _confirmations[address(varg0)] = 0x1 | ~0xff & _confirmations[address(varg0)];\n        emit Confirmation(address(varg0), varg0);\n        v6 = v6 + 1;\n    }\n    0x774(varg0);\n}\n\nfunction 0x774(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][0x4]));\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), v2)]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v3 = 1;\n    }\n    if (!v0) {\n        return ;\n    } else {\n        _transactions[varg0][4] = 0x1 | ~0xff & _transactions[varg0][0x4];\n        v4 = v5 = MEM[64];\n        v6 = _transactions[varg0][2];\n        if ((v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) {\n            if (31 < (v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v4] = STORAGE[v7];\n                    v7 += 1;\n                    v4 += 32;\n                } while (v5 + ((v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) <= v4);\n            } else {\n                v8 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v9 = address(_transactions[varg0]).call(v8).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        assert(v9);\n        emit Execution(varg0);\n        return ;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    if (msg.data.length) {\n        if (function_selector >> 224 == 0xc4ecab4) {\n            confirmations(bytes32,address);\n        } else if (0xd59b564 == function_selector >> 224) {\n            submitTransaction(address,uint256,bytes,uint256);\n        } else if (0x173825d9 == function_selector >> 224) {\n            removeOwner(address);\n        } else if (0x2f54bf6e == function_selector >> 224) {\n            isOwner(address);\n        } else if (0x59bf77df == function_selector >> 224) {\n            confirmationCount(bytes32);\n        } else if (0x607fa5a4 == function_selector >> 224) {\n            updateRequired(uint256);\n        } else if (0x642f2eaf == function_selector >> 224) {\n            transactions(bytes32);\n        } else if (0x6486aa51 == function_selector >> 224) {\n            isConfirmed(bytes32);\n        } else if (0x7065cb48 == function_selector >> 224) {\n            addOwner(address);\n        } else if (0x79716e43 == function_selector >> 224) {\n            confirmTransaction(bytes32);\n        } else if (0x9119e5fb == function_selector >> 224) {\n            submitTransactionWithSignatures(address,uint256,bytes,uint256,uint8[],bytes32[]);\n        } else if (0xc69ed5f2 == function_selector >> 224) {\n            executeTransaction(bytes32);\n        } else if (0xd11db83f == function_selector >> 224) {\n            getPendingTransactions();\n        } else if (0xdc8452cd == function_selector >> 224) {\n            required();\n        } else if (0xe6a6d4c8 == function_selector >> 224) {\n            getExecutedTransactions();\n        } else if (0xf3fc536d == function_selector >> 224) {\n            revokeConfirmation(bytes32);\n        } else if (0xfbc6d0ff == function_selector >> 224) {\n            confirmTransactionWithSignatures(bytes32,uint8[],bytes32[]);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 15:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _updateRequired; // STORAGE[0x3]\nuint256[] _getPendingTransactions; // STORAGE[0x4]\nuint256 _required; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nOwnerAddition(address);\nExecution(bytes32);\nRevocation(address, bytes32);\nSubmission(bytes32);\nConfirmation(address, bytes32);\n\nfunction confirmations(bytes32 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = 1549;\n    v0 = v2 = varg2 + 36;\n    v3 = v4 = (?).length;\n    v5 = new bytes[](v4);\n    assert(varg0);\n    MEM[MEM[64]] = varg0 << 96;\n    MEM[20 + MEM[64]] = varg1;\n    v6 = dataCopy(MEM[(v5.data) len (v5.length)], MEM[(52 + MEM[64]) len (v5.length)]);\n    MEM[v5.length + (52 + MEM[64])] = varg3;\n    v0 = v7 = keccak256(v8.data);\n    if (0 == address(_transactions[~0x0 & v7][0])) {\n        _transactions[v7] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[v7];\n        _transactions[v7][1] = varg1;\n        v9 = v10 = 32 + v5;\n        if (31 < MEM[v5]) {\n            _transactions[v7][2] = 1 + (MEM[v5] + MEM[v5]);\n            if (MEM[v5]) {\n                while (v10 + MEM[v5] > v9) {\n                    STORAGE[v11] = MEM[v9];\n                    v9 += 32;\n                    v11 += 1;\n                }\n            }\n        } else {\n            _transactions[v7][2] = MEM[v5] + MEM[v5] | ~0xff & MEM[v10];\n        }\n        while (v12 + (31 + ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) >> 5) > v11) {\n            STORAGE[v11] = 0;\n            v11 += 1;\n        }\n        _transactions[v7][3] = varg3;\n        _transactions[v7][4] = 0 >> 248 | ~0xff & _transactions[v7][0x4];\n        _getPendingTransactions.length = _getPendingTransactions.length + 1;\n        if (!_getPendingTransactions.length <= _getPendingTransactions.length + 1) {\n            v13 = v14 = _getPendingTransactions.length + 1 + keccak256(4);\n            while (keccak256(4) + _getPendingTransactions.length > v13) {\n                STORAGE[v13] = 0;\n                v13 += 1;\n            }\n            goto 0x107a0x14e;\n        }\n        _getPendingTransactions[_getPendingTransactions.length] = v7;\n        emit Submission(v7);\n    }\n    v3 = v15 = 2336;\n    v0 = msg.sender;\n    assert(0xff & _isOwner[address(v0)]);\n    assert(!(0xff & _confirmations[v7]));\n    _confirmations[v7] = 0x1 | ~0xff & _confirmations[v7];\n    emit Confirmation(msg.sender, v7);\n    v3 = v16 = 2408;\n    assert(!(0xff & _transactions[v7][0x4]));\n    v17 = v18 = 0;\n    while (v17 < _updateRequired.length) {\n        assert(v17 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v17]), keccak256(v7, 0x1))]) {\n            v17 += 1;\n        }\n        v17 += 1;\n    }\n    if (v17 == _required) {\n        v17 = v19 = 1;\n    }\n    if (v17) {\n        _transactions[v7][4] = 0x1 | ~0xff & _transactions[v7][0x4];\n        v20 = v21 = MEM[64];\n        if ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) {\n            if (31 < (_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v20] = STORAGE[v22];\n                    v22 += 1;\n                    v20 += 32;\n                } while (v21 + ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) <= v20);\n            }\n        }\n        v23 = address(_transactions[v7]).call(_transactions[v7][2] >> 8 << 8, v7).value(_transactions[v7][1]).gas(msg.gas - 34050);\n        assert(v23);\n        emit Execution(v7);\n    }\n    while (1) {\n        goto {'0x920', '0x9680x14e'};\n    }\n    return v0;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _updateRequired.length) {\n        if (v0 < _updateRequired.length) {\n            break;\n        }\n        assert(v0 < _updateRequired.length);\n        if (address(_updateRequired[v0]) != varg0) {\n            break;\n        }\n        if (address(_updateRequired[v0]) == varg0) {\n            assert(_updateRequired.length + ~0 < _updateRequired.length);\n            assert(v0 < _updateRequired.length);\n            _updateRequired[v0] = address(_updateRequired[_updateRequired.length + ~0]) << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _updateRequired[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _updateRequired.length = _updateRequired.length + ~0;\n    if (!_updateRequired.length <= _updateRequired.length + ~0) {\n        v2 = v3 = _updateRequired.length + ~0 + keccak256(3);\n        while (keccak256(3) + _updateRequired.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _updateRequired.length) {\n        assert(msg.sender == address(this));\n        v4 = v5 = _updateRequired.length > _updateRequired.length;\n        if (_updateRequired.length <= _updateRequired.length) {\n            v4 = v6 = !_updateRequired.length;\n        }\n        if (!v4) {\n            v4 = !_updateRequired.length;\n        }\n        assert(!v4);\n        _required = _updateRequired.length;\n        emit 0xcfd262243fb0dd33ba2604015772142a737b088fb078ec5aa18bea2c58c29a2(_updateRequired.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmationCount(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction updateRequired(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    v0 = v1 = varg0 > _updateRequired.length;\n    if (varg0 <= _updateRequired.length) {\n        v0 = v2 = !varg0;\n    }\n    if (!v0) {\n        v0 = !_updateRequired.length;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit 0xcfd262243fb0dd33ba2604015772142a737b088fb078ec5aa18bea2c58c29a2(varg0);\n}\n\nfunction transactions(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[]((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v0, _transactions[varg0][3], 0xff & _transactions[varg0][0x4];\n}\n\nfunction isConfirmed(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v2 = 1;\n    }\n    return v0;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _updateRequired.length = _updateRequired.length + 1;\n    if (!_updateRequired.length <= _updateRequired.length + 1) {\n        v0 = v1 = _updateRequired.length + 1 + keccak256(3);\n        while (keccak256(3) + _updateRequired.length > v0) {\n            STORAGE[v0] = 0;\n            v0 += 1;\n        }\n    }\n    _updateRequired[_updateRequired.length] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _updateRequired[_updateRequired.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction confirmTransaction(bytes32 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(!(0xff & _confirmations[msg.sender]));\n    _confirmations[msg.sender] = 0x1 | ~0xff & _confirmations[msg.sender];\n    emit Confirmation(msg.sender, varg0);\n    assert(!(0xff & _transactions[varg0][0x4]));\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v2 = 1;\n    }\n    if (v0) {\n        _transactions[varg0][4] = 0x1 | ~0xff & _transactions[varg0][0x4];\n        v3 = v4 = MEM[64];\n        if ((_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) {\n            if (31 < (_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v3] = STORAGE[v5];\n                    v5 += 1;\n                    v3 += 32;\n                } while (v4 + ((_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) <= v3);\n            }\n        }\n        v6 = address(_transactions[varg0]).call(_transactions[varg0][2] >> 8 << 8, varg0).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        assert(v6);\n        emit Execution(varg0);\n    }\n}\n\nfunction submitTransactionWithSignatures(address varg0, uint256 varg1, bytes varg2, uint256 varg3, uint8[] varg4, bytes32[] varg5) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    assert(varg0);\n    MEM[MEM[64]] = varg0 << 96;\n    MEM[20 + MEM[64]] = varg1;\n    v1 = dataCopy(MEM[(v0.data) len (v0.length)], MEM[(52 + MEM[64]) len (v0.length)]);\n    MEM[v0.length + (52 + MEM[64])] = varg3;\n    v2 = keccak256(v3.data);\n    if (0 == address(_transactions[~0x0 & v2][0])) {\n        _transactions[v2] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[v2];\n        _transactions[v2][1] = varg1;\n        v4 = v5 = 32 + v0;\n        if (31 < MEM[v0]) {\n            _transactions[v2][2] = 1 + (MEM[v0] + MEM[v0]);\n            if (MEM[v0]) {\n                while (v5 + MEM[v0] > v4) {\n                    STORAGE[v6] = MEM[v4];\n                    v4 += 32;\n                    v6 += 1;\n                }\n            }\n        } else {\n            _transactions[v2][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v5];\n        }\n        while (v7 + (31 + ((_transactions[v2][0x2] & ~0 + (!(_transactions[v2][0x2] & 0x1) << 8)) >> 1) >> 5) > v6) {\n            STORAGE[v6] = 0;\n            v6 += 1;\n        }\n        _transactions[v2][3] = varg3;\n        _transactions[v2][4] = 0 >> 248 | ~0xff & _transactions[v2][0x4];\n        _getPendingTransactions.length = _getPendingTransactions.length + 1;\n        if (!_getPendingTransactions.length <= _getPendingTransactions.length + 1) {\n            v8 = v9 = _getPendingTransactions.length + 1 + keccak256(4);\n            while (keccak256(4) + _getPendingTransactions.length > v8) {\n                STORAGE[v8] = 0;\n                v8 += 1;\n            }\n            goto 0x107a0x1a6B0x12f4;\n        }\n        _getPendingTransactions[_getPendingTransactions.length] = v2;\n        emit Submission(v2);\n    }\n    v10 = new uint256[]((?).length);\n    CALLDATACOPY(v10.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v11.data, varg5 + 36, (?).length << 5);\n    v12 = v13 = 0;\n    while (v12 < v10.length) {\n        assert(v12 < v10.length);\n        assert(v12 < v11.length);\n        assert(v10.length + v12 < v11.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v14, v15 = ecrecover(v2, v10[v12] & 0xff, v11[v12], v11[v10.length + v12]);\n        assert(v14);\n        assert(0xff & _isOwner[address(v15)]);\n        v12 += 1;\n    }\n    v16 = v17 = 0;\n    while (v16 < v10.length) {\n        assert(v16 < v10.length);\n        assert(v16 < v11.length);\n        assert(v16 + v10.length < v11.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v18 = ecrecover(v2, v10[v16] & 0xff, v11[v16], v11[v16 + v10.length]);\n        assert(v18);\n        assert(!(0xff & _confirmations[v2]));\n        _confirmations[v2] = 0x1 | ~0xff & _confirmations[v2];\n        emit Confirmation(address(v2), v2);\n        v16 = v16 + 1;\n    }\n    0x774(v2);\n    return v2;\n}\n\nfunction executeTransaction(bytes32 varg0) public payable { \n    assert(!msg.value);\n    0x774(varg0);\n}\n\nfunction getPendingTransactions() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = v1 = 1;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = new uint256[](_getPendingTransactions.length);\n    }\n    v2 = new uint256[](_getPendingTransactions.length);\n    v4 = v5 = 0;\n    v6 = v7 = 0;\n    while (v6 < _getPendingTransactions.length) {\n        if (v1) {\n            assert(v6 < _getPendingTransactions.length);\n            v0 = v8 = !(0xff & _transactions[_getPendingTransactions[v6]][0x4]);\n        }\n        if (!v0) {\n            v0 = v9 = !v1;\n            if (v9) {\n                assert(v6 < _getPendingTransactions.length);\n                v0 = 0xff & _transactions[_getPendingTransactions[v6]][0x4];\n            }\n        }\n        if (v0) {\n            assert(v6 < _getPendingTransactions.length);\n            assert(v4 < v2.length);\n            v2[v4] = _getPendingTransactions[v6];\n            v4 += 1;\n        }\n        v6 += 1;\n    }\n    v10 = v11 = MEM[64];\n    if (MSIZE() >= v11) {\n        v10 = new uint256[](v4);\n    }\n    v10 = new uint256[](v4);\n    v12 = v13 = 0;\n    while (v12 < v4) {\n        assert(v12 < v2.length);\n        if (v2[v12] > 0) {\n            assert(v12 < v2.length);\n            assert(v12 < v10.length);\n            v10[v12] = v2[v12];\n        }\n        v12 += 1;\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v10.length;\n    v14 = dataCopy(MEM[(v10.data) len (v10.length << 5)], MEM[(64 + MEM[64]) len (v10.length << 5)]);\n    return MEM[(MEM[64]) len ((v10.length << 5) + (64 + MEM[64]) - MEM[64])];\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction getExecutedTransactions() public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    MEM[MEM[64]] = v1;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_getPendingTransactions.length);\n    }\n    v2 = new uint256[](_getPendingTransactions.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _getPendingTransactions.length) {\n        if (v1) {\n            assert(v7 < _getPendingTransactions.length);\n            v0 = v9 = !(0xff & _transactions[_getPendingTransactions[v7]][0x4]);\n        }\n        if (!v0) {\n            v0 = v10 = !v1;\n            if (v10) {\n                assert(v7 < _getPendingTransactions.length);\n                v0 = 0xff & _transactions[_getPendingTransactions[v7]][0x4];\n            }\n        }\n        if (v0) {\n            assert(v7 < _getPendingTransactions.length);\n            assert(v5 < v2.length);\n            v2[v5] = _getPendingTransactions[v7];\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v11 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v11 = v13 = new uint256[](v5);\n    }\n    v11 = new uint256[](v5);\n    v14 = v15 = 0;\n    while (v14 < v5) {\n        assert(v14 < v2.length);\n        if (v2[v14] > 0) {\n            assert(v14 < v2.length);\n            assert(v14 < v11.length);\n            v11[v14] = v2[v14];\n        }\n        v14 += 1;\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v11.length;\n    v16 = dataCopy(MEM[(v11.data) len (v11.length << 5)], MEM[(64 + MEM[64]) len (v11.length << 5)]);\n    return MEM[(MEM[64]) len ((v11.length << 5) + (64 + MEM[64]) - MEM[64])];\n}\n\nfunction revokeConfirmation(bytes32 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][0x4]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction confirmTransactionWithSignatures(bytes32 varg0, uint8[] varg1, bytes32[] varg2) public payable { \n    assert(!msg.value);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length << 5);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        assert(v2 < v0.length);\n        assert(v2 < v1.length);\n        assert(v0.length + v2 < v1.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v4, v5 = ecrecover(varg0, v0[v2] & 0xff, v1[v2], v1[v0.length + v2]);\n        assert(v4);\n        assert(0xff & _isOwner[address(v5)]);\n        v2 += 1;\n    }\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        assert(v6 < v0.length);\n        assert(v6 < v1.length);\n        assert(v6 + v0.length < v1.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v8 = ecrecover(varg0, v0[v6] & 0xff, v1[v6], v1[v6 + v0.length]);\n        assert(v8);\n        assert(!(0xff & _confirmations[address(varg0)]));\n        _confirmations[address(varg0)] = 0x1 | ~0xff & _confirmations[address(varg0)];\n        emit Confirmation(address(varg0), varg0);\n        v6 = v6 + 1;\n    }\n    0x774(varg0);\n}\n\nfunction 0x774(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][0x4]));\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), v2)]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v3 = 1;\n    }\n    if (!v0) {\n        return ;\n    } else {\n        _transactions[varg0][4] = 0x1 | ~0xff & _transactions[varg0][0x4];\n        v4 = v5 = MEM[64];\n        v6 = _transactions[varg0][2];\n        if ((v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) {\n            if (31 < (v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v4] = STORAGE[v7];\n                    v7 += 1;\n                    v4 += 32;\n                } while (v5 + ((v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) <= v4);\n            } else {\n                v8 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v9 = address(_transactions[varg0]).call(v8).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        assert(v9);\n        emit Execution(varg0);\n        return ;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    if (msg.data.length) {\n        if (function_selector >> 224 == 0xc4ecab4) {\n            confirmations(bytes32,address);\n        } else if (0xd59b564 == function_selector >> 224) {\n            submitTransaction(address,uint256,bytes,uint256);\n        } else if (0x173825d9 == function_selector >> 224) {\n            removeOwner(address);\n        } else if (0x2f54bf6e == function_selector >> 224) {\n            isOwner(address);\n        } else if (0x59bf77df == function_selector >> 224) {\n            confirmationCount(bytes32);\n        } else if (0x607fa5a4 == function_selector >> 224) {\n            updateRequired(uint256);\n        } else if (0x642f2eaf == function_selector >> 224) {\n            transactions(bytes32);\n        } else if (0x6486aa51 == function_selector >> 224) {\n            isConfirmed(bytes32);\n        } else if (0x7065cb48 == function_selector >> 224) {\n            addOwner(address);\n        } else if (0x79716e43 == function_selector >> 224) {\n            confirmTransaction(bytes32);\n        } else if (0x9119e5fb == function_selector >> 224) {\n            submitTransactionWithSignatures(address,uint256,bytes,uint256,uint8[],bytes32[]);\n        } else if (0xc69ed5f2 == function_selector >> 224) {\n            executeTransaction(bytes32);\n        } else if (0xd11db83f == function_selector >> 224) {\n            getPendingTransactions();\n        } else if (0xdc8452cd == function_selector >> 224) {\n            required();\n        } else if (0xe6a6d4c8 == function_selector >> 224) {\n            getExecutedTransactions();\n        } else if (0xf3fc536d == function_selector >> 224) {\n            revokeConfirmation(bytes32);\n        } else if (0xfbc6d0ff == function_selector >> 224) {\n            confirmTransactionWithSignatures(bytes32,uint8[],bytes32[]);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 15:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _updateRequired; // STORAGE[0x3]\nuint256[] _getPendingTransactions; // STORAGE[0x4]\nuint256 _required; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nOwnerAddition(address);\nExecution(bytes32);\nRevocation(address, bytes32);\nSubmission(bytes32);\nConfirmation(address, bytes32);\n\nfunction confirmations(bytes32 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2, uint256 varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = 1549;\n    v0 = v2 = varg2 + 36;\n    v3 = v4 = (?).length;\n    v5 = new bytes[](v4);\n    assert(varg0);\n    MEM[MEM[64]] = varg0 << 96;\n    MEM[20 + MEM[64]] = varg1;\n    v6 = dataCopy(MEM[(v5.data) len (v5.length)], MEM[(52 + MEM[64]) len (v5.length)]);\n    MEM[v5.length + (52 + MEM[64])] = varg3;\n    v0 = v7 = keccak256(v8.data);\n    if (0 == address(_transactions[~0x0 & v7][0])) {\n        _transactions[v7] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[v7];\n        _transactions[v7][1] = varg1;\n        v9 = v10 = 32 + v5;\n        if (31 < MEM[v5]) {\n            _transactions[v7][2] = 1 + (MEM[v5] + MEM[v5]);\n            if (MEM[v5]) {\n                while (v10 + MEM[v5] > v9) {\n                    STORAGE[v11] = MEM[v9];\n                    v9 += 32;\n                    v11 += 1;\n                }\n            }\n        } else {\n            _transactions[v7][2] = MEM[v5] + MEM[v5] | ~0xff & MEM[v10];\n        }\n        while (v12 + (31 + ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) >> 5) > v11) {\n            STORAGE[v11] = 0;\n            v11 += 1;\n        }\n        _transactions[v7][3] = varg3;\n        _transactions[v7][4] = 0 >> 248 | ~0xff & _transactions[v7][0x4];\n        _getPendingTransactions.length = _getPendingTransactions.length + 1;\n        if (!_getPendingTransactions.length <= _getPendingTransactions.length + 1) {\n            v13 = v14 = _getPendingTransactions.length + 1 + keccak256(4);\n            while (keccak256(4) + _getPendingTransactions.length > v13) {\n                STORAGE[v13] = 0;\n                v13 += 1;\n            }\n            goto 0x107a0x14e;\n        }\n        _getPendingTransactions[_getPendingTransactions.length] = v7;\n        emit Submission(v7);\n    }\n    v3 = v15 = 2336;\n    v0 = msg.sender;\n    assert(0xff & _isOwner[address(v0)]);\n    assert(!(0xff & _confirmations[v7]));\n    _confirmations[v7] = 0x1 | ~0xff & _confirmations[v7];\n    emit Confirmation(msg.sender, v7);\n    v3 = v16 = 2408;\n    assert(!(0xff & _transactions[v7][0x4]));\n    v17 = v18 = 0;\n    while (v17 < _updateRequired.length) {\n        assert(v17 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v17]), keccak256(v7, 0x1))]) {\n            v17 += 1;\n        }\n        v17 += 1;\n    }\n    if (v17 == _required) {\n        v17 = v19 = 1;\n    }\n    if (v17) {\n        _transactions[v7][4] = 0x1 | ~0xff & _transactions[v7][0x4];\n        v20 = v21 = MEM[64];\n        if ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) {\n            if (31 < (_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v20] = STORAGE[v22];\n                    v22 += 1;\n                    v20 += 32;\n                } while (v21 + ((_transactions[v7][0x2] & ~0 + (!(_transactions[v7][0x2] & 0x1) << 8)) >> 1) <= v20);\n            }\n        }\n        v23 = address(_transactions[v7]).call(_transactions[v7][2] >> 8 << 8, v7).value(_transactions[v7][1]).gas(msg.gas - 34050);\n        assert(v23);\n        emit Execution(v7);\n    }\n    while (1) {\n        goto {'0x920', '0x9680x14e'};\n    }\n    return v0;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _updateRequired.length) {\n        if (v0 < _updateRequired.length) {\n            break;\n        }\n        assert(v0 < _updateRequired.length);\n        if (address(_updateRequired[v0]) != varg0) {\n            break;\n        }\n        if (address(_updateRequired[v0]) == varg0) {\n            assert(_updateRequired.length + ~0 < _updateRequired.length);\n            assert(v0 < _updateRequired.length);\n            _updateRequired[v0] = address(_updateRequired[_updateRequired.length + ~0]) << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _updateRequired[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _updateRequired.length = _updateRequired.length + ~0;\n    if (!_updateRequired.length <= _updateRequired.length + ~0) {\n        v2 = v3 = _updateRequired.length + ~0 + keccak256(3);\n        while (keccak256(3) + _updateRequired.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _updateRequired.length) {\n        assert(msg.sender == address(this));\n        v4 = v5 = _updateRequired.length > _updateRequired.length;\n        if (_updateRequired.length <= _updateRequired.length) {\n            v4 = v6 = !_updateRequired.length;\n        }\n        if (!v4) {\n            v4 = !_updateRequired.length;\n        }\n        assert(!v4);\n        _required = _updateRequired.length;\n        emit 0xcfd262243fb0dd33ba2604015772142a737b088fb078ec5aa18bea2c58c29a2(_updateRequired.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmationCount(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction updateRequired(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    v0 = v1 = varg0 > _updateRequired.length;\n    if (varg0 <= _updateRequired.length) {\n        v0 = v2 = !varg0;\n    }\n    if (!v0) {\n        v0 = !_updateRequired.length;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit 0xcfd262243fb0dd33ba2604015772142a737b088fb078ec5aa18bea2c58c29a2(varg0);\n}\n\nfunction transactions(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[]((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v0, _transactions[varg0][3], 0xff & _transactions[varg0][0x4];\n}\n\nfunction isConfirmed(bytes32 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v2 = 1;\n    }\n    return v0;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _updateRequired.length = _updateRequired.length + 1;\n    if (!_updateRequired.length <= _updateRequired.length + 1) {\n        v0 = v1 = _updateRequired.length + 1 + keccak256(3);\n        while (keccak256(3) + _updateRequired.length > v0) {\n            STORAGE[v0] = 0;\n            v0 += 1;\n        }\n    }\n    _updateRequired[_updateRequired.length] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _updateRequired[_updateRequired.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction confirmTransaction(bytes32 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(!(0xff & _confirmations[msg.sender]));\n    _confirmations[msg.sender] = 0x1 | ~0xff & _confirmations[msg.sender];\n    emit Confirmation(msg.sender, varg0);\n    assert(!(0xff & _transactions[varg0][0x4]));\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), keccak256(varg0, 0x1))]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v2 = 1;\n    }\n    if (v0) {\n        _transactions[varg0][4] = 0x1 | ~0xff & _transactions[varg0][0x4];\n        v3 = v4 = MEM[64];\n        if ((_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) {\n            if (31 < (_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v3] = STORAGE[v5];\n                    v5 += 1;\n                    v3 += 32;\n                } while (v4 + ((_transactions[varg0][0x2] & ~0 + (!(_transactions[varg0][0x2] & 0x1) << 8)) >> 1) <= v3);\n            }\n        }\n        v6 = address(_transactions[varg0]).call(_transactions[varg0][2] >> 8 << 8, varg0).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        assert(v6);\n        emit Execution(varg0);\n    }\n}\n\nfunction submitTransactionWithSignatures(address varg0, uint256 varg1, bytes varg2, uint256 varg3, uint8[] varg4, bytes32[] varg5) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    assert(varg0);\n    MEM[MEM[64]] = varg0 << 96;\n    MEM[20 + MEM[64]] = varg1;\n    v1 = dataCopy(MEM[(v0.data) len (v0.length)], MEM[(52 + MEM[64]) len (v0.length)]);\n    MEM[v0.length + (52 + MEM[64])] = varg3;\n    v2 = keccak256(v3.data);\n    if (0 == address(_transactions[~0x0 & v2][0])) {\n        _transactions[v2] = varg0 << 96 >> 96 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[v2];\n        _transactions[v2][1] = varg1;\n        v4 = v5 = 32 + v0;\n        if (31 < MEM[v0]) {\n            _transactions[v2][2] = 1 + (MEM[v0] + MEM[v0]);\n            if (MEM[v0]) {\n                while (v5 + MEM[v0] > v4) {\n                    STORAGE[v6] = MEM[v4];\n                    v4 += 32;\n                    v6 += 1;\n                }\n            }\n        } else {\n            _transactions[v2][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v5];\n        }\n        while (v7 + (31 + ((_transactions[v2][0x2] & ~0 + (!(_transactions[v2][0x2] & 0x1) << 8)) >> 1) >> 5) > v6) {\n            STORAGE[v6] = 0;\n            v6 += 1;\n        }\n        _transactions[v2][3] = varg3;\n        _transactions[v2][4] = 0 >> 248 | ~0xff & _transactions[v2][0x4];\n        _getPendingTransactions.length = _getPendingTransactions.length + 1;\n        if (!_getPendingTransactions.length <= _getPendingTransactions.length + 1) {\n            v8 = v9 = _getPendingTransactions.length + 1 + keccak256(4);\n            while (keccak256(4) + _getPendingTransactions.length > v8) {\n                STORAGE[v8] = 0;\n                v8 += 1;\n            }\n            goto 0x107a0x1a6B0x12f4;\n        }\n        _getPendingTransactions[_getPendingTransactions.length] = v2;\n        emit Submission(v2);\n    }\n    v10 = new uint256[]((?).length);\n    CALLDATACOPY(v10.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v11.data, varg5 + 36, (?).length << 5);\n    v12 = v13 = 0;\n    while (v12 < v10.length) {\n        assert(v12 < v10.length);\n        assert(v12 < v11.length);\n        assert(v10.length + v12 < v11.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v14, v15 = ecrecover(v2, v10[v12] & 0xff, v11[v12], v11[v10.length + v12]);\n        assert(v14);\n        assert(0xff & _isOwner[address(v15)]);\n        v12 += 1;\n    }\n    v16 = v17 = 0;\n    while (v16 < v10.length) {\n        assert(v16 < v10.length);\n        assert(v16 < v11.length);\n        assert(v16 + v10.length < v11.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v18 = ecrecover(v2, v10[v16] & 0xff, v11[v16], v11[v16 + v10.length]);\n        assert(v18);\n        assert(!(0xff & _confirmations[v2]));\n        _confirmations[v2] = 0x1 | ~0xff & _confirmations[v2];\n        emit Confirmation(address(v2), v2);\n        v16 = v16 + 1;\n    }\n    0x774(v2);\n    return v2;\n}\n\nfunction executeTransaction(bytes32 varg0) public payable { \n    assert(!msg.value);\n    0x774(varg0);\n}\n\nfunction getPendingTransactions() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = v1 = 1;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = new uint256[](_getPendingTransactions.length);\n    }\n    v2 = new uint256[](_getPendingTransactions.length);\n    v4 = v5 = 0;\n    v6 = v7 = 0;\n    while (v6 < _getPendingTransactions.length) {\n        if (v1) {\n            assert(v6 < _getPendingTransactions.length);\n            v0 = v8 = !(0xff & _transactions[_getPendingTransactions[v6]][0x4]);\n        }\n        if (!v0) {\n            v0 = v9 = !v1;\n            if (v9) {\n                assert(v6 < _getPendingTransactions.length);\n                v0 = 0xff & _transactions[_getPendingTransactions[v6]][0x4];\n            }\n        }\n        if (v0) {\n            assert(v6 < _getPendingTransactions.length);\n            assert(v4 < v2.length);\n            v2[v4] = _getPendingTransactions[v6];\n            v4 += 1;\n        }\n        v6 += 1;\n    }\n    v10 = v11 = MEM[64];\n    if (MSIZE() >= v11) {\n        v10 = new uint256[](v4);\n    }\n    v10 = new uint256[](v4);\n    v12 = v13 = 0;\n    while (v12 < v4) {\n        assert(v12 < v2.length);\n        if (v2[v12] > 0) {\n            assert(v12 < v2.length);\n            assert(v12 < v10.length);\n            v10[v12] = v2[v12];\n        }\n        v12 += 1;\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v10.length;\n    v14 = dataCopy(MEM[(v10.data) len (v10.length << 5)], MEM[(64 + MEM[64]) len (v10.length << 5)]);\n    return MEM[(MEM[64]) len ((v10.length << 5) + (64 + MEM[64]) - MEM[64])];\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction getExecutedTransactions() public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    MEM[MEM[64]] = v1;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_getPendingTransactions.length);\n    }\n    v2 = new uint256[](_getPendingTransactions.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _getPendingTransactions.length) {\n        if (v1) {\n            assert(v7 < _getPendingTransactions.length);\n            v0 = v9 = !(0xff & _transactions[_getPendingTransactions[v7]][0x4]);\n        }\n        if (!v0) {\n            v0 = v10 = !v1;\n            if (v10) {\n                assert(v7 < _getPendingTransactions.length);\n                v0 = 0xff & _transactions[_getPendingTransactions[v7]][0x4];\n            }\n        }\n        if (v0) {\n            assert(v7 < _getPendingTransactions.length);\n            assert(v5 < v2.length);\n            v2[v5] = _getPendingTransactions[v7];\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v11 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v11 = v13 = new uint256[](v5);\n    }\n    v11 = new uint256[](v5);\n    v14 = v15 = 0;\n    while (v14 < v5) {\n        assert(v14 < v2.length);\n        if (v2[v14] > 0) {\n            assert(v14 < v2.length);\n            assert(v14 < v11.length);\n            v11[v14] = v2[v14];\n        }\n        v14 += 1;\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v11.length;\n    v16 = dataCopy(MEM[(v11.data) len (v11.length << 5)], MEM[(64 + MEM[64]) len (v11.length << 5)]);\n    return MEM[(MEM[64]) len ((v11.length << 5) + (64 + MEM[64]) - MEM[64])];\n}\n\nfunction revokeConfirmation(bytes32 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][0x4]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction confirmTransactionWithSignatures(bytes32 varg0, uint8[] varg1, bytes32[] varg2) public payable { \n    assert(!msg.value);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length << 5);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        assert(v2 < v0.length);\n        assert(v2 < v1.length);\n        assert(v0.length + v2 < v1.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v4, v5 = ecrecover(varg0, v0[v2] & 0xff, v1[v2], v1[v0.length + v2]);\n        assert(v4);\n        assert(0xff & _isOwner[address(v5)]);\n        v2 += 1;\n    }\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        assert(v6 < v0.length);\n        assert(v6 < v1.length);\n        assert(v6 + v0.length < v1.length);\n        MEM[0] = MEM[64];\n        MEM[64 + MEM[64]] = 0;\n        v8 = ecrecover(varg0, v0[v6] & 0xff, v1[v6], v1[v6 + v0.length]);\n        assert(v8);\n        assert(!(0xff & _confirmations[address(varg0)]));\n        _confirmations[address(varg0)] = 0x1 | ~0xff & _confirmations[address(varg0)];\n        emit Confirmation(address(varg0), varg0);\n        v6 = v6 + 1;\n    }\n    0x774(varg0);\n}\n\nfunction 0x774(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][0x4]));\n    v0 = v1 = 0;\n    while (v0 < _updateRequired.length) {\n        assert(v0 < _updateRequired.length);\n        if (0xff & STORAGE[keccak256(address(_updateRequired[v0]), v2)]) {\n            v0 += 1;\n        }\n        v0 += 1;\n    }\n    if (v0 == _required) {\n        v0 = v3 = 1;\n    }\n    if (!v0) {\n        return ;\n    } else {\n        _transactions[varg0][4] = 0x1 | ~0xff & _transactions[varg0][0x4];\n        v4 = v5 = MEM[64];\n        v6 = _transactions[varg0][2];\n        if ((v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) {\n            if (31 < (v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) {\n                do {\n                    MEM[v4] = STORAGE[v7];\n                    v7 += 1;\n                    v4 += 32;\n                } while (v5 + ((v6 & ~0 + (!(v6 & 0x1) << 8)) >> 1) <= v4);\n            } else {\n                v8 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v9 = address(_transactions[varg0]).call(v8).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        assert(v9);\n        emit Execution(varg0);\n        return ;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    if (msg.data.length) {\n        if (function_selector >> 224 == 0xc4ecab4) {\n            confirmations(bytes32,address);\n        } else if (0xd59b564 == function_selector >> 224) {\n            submitTransaction(address,uint256,bytes,uint256);\n        } else if (0x173825d9 == function_selector >> 224) {\n            removeOwner(address);\n        } else if (0x2f54bf6e == function_selector >> 224) {\n            isOwner(address);\n        } else if (0x59bf77df == function_selector >> 224) {\n            confirmationCount(bytes32);\n        } else if (0x607fa5a4 == function_selector >> 224) {\n            updateRequired(uint256);\n        } else if (0x642f2eaf == function_selector >> 224) {\n            transactions(bytes32);\n        } else if (0x6486aa51 == function_selector >> 224) {\n            isConfirmed(bytes32);\n        } else if (0x7065cb48 == function_selector >> 224) {\n            addOwner(address);\n        } else if (0x79716e43 == function_selector >> 224) {\n            confirmTransaction(bytes32);\n        } else if (0x9119e5fb == function_selector >> 224) {\n            submitTransactionWithSignatures(address,uint256,bytes,uint256,uint8[],bytes32[]);\n        } else if (0xc69ed5f2 == function_selector >> 224) {\n            executeTransaction(bytes32);\n        } else if (0xd11db83f == function_selector >> 224) {\n            getPendingTransactions();\n        } else if (0xdc8452cd == function_selector >> 224) {\n            required();\n        } else if (0xe6a6d4c8 == function_selector >> 224) {\n            getExecutedTransactions();\n        } else if (0xf3fc536d == function_selector >> 224) {\n            revokeConfirmation(bytes32);\n        } else if (0xfbc6d0ff == function_selector >> 224) {\n            confirmTransactionWithSignatures(bytes32,uint8[],bytes32[]);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
	"status": "1",
	"time_cost": 27.125535249710083,
	"usage": {
		"completion_tokens": 623,
		"prompt_tokens": 6780,
		"total_tokens": 7403
	}
}