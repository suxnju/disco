{
	"address": "0x936d118702ad19aa39d6e0aed5efd434a577f6bf",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code that follows the decompiled code you shared:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyToken {\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => uint256) private _allowance;\n    uint256 private _oneTokenInWei;\n    uint256 private _totalEthRecieved;\n    address private _owner;\n    bool private _paused;\n\n    event PriceChanged(string, uint256);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Unpause();\n    event Pause();\n    event Withdraw(address indexed receiver, uint256 amount);\n\n    constructor() {\n        _owner = msg.sender;\n        _paused = false;\n    }\n\n    function fallback() external payable { \n        require(!_paused);\n        require(_oneTokenInWei > 0);\n        require(msg.value == _oneTokenInWei * (msg.value / _oneTokenInWei) + msg.value % _oneTokenInWei);\n        uint256 v0 = SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n        require(v0 <= 0x1312d00);\n        require(msg.value > 0);\n        _balanceOf[msg.sender] += msg.value / _oneTokenInWei;\n        uint256 v1 = SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n        _totalSupply = v1;\n        _totalEthRecieved += msg.value;\n        emit Transfer(address(0), msg.sender, msg.value / _oneTokenInWei);\n    }\n\n    function setEthPrice(uint256 newPrice) public { \n        require(_owner == msg.sender);\n        _oneTokenInWei = newPrice;\n        emit PriceChanged('New price set', newPrice);\n    }\n\n    function name() public pure returns (string memory) { \n        return \"ACI Token\";\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) { \n        _allowance[spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) { \n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) { \n        require(_balanceOf[from] >= value);\n        require(_allowance[msg.sender] >= value);\n        require(value > 0);\n        _balanceOf[to] += value;\n        _balanceOf[from] -= value;\n        _allowance[msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) { \n        return 18;\n    }\n\n    function unpause() public { \n        require(_owner == msg.sender);\n        require(_paused);\n        _paused = false;\n        emit Unpause();\n    }\n\n    function paused() public view returns (bool) { \n        return _paused;\n    }\n\n    function totalEthRecieved() public view returns (uint256) { \n        return _totalEthRecieved;\n    }\n\n    function balanceOf(address account) public view returns (uint256) { \n        return _balanceOf[account];\n    }\n\n    function generateTokens(address to, uint256 value) public { \n        require(_owner == msg.sender);\n        _balanceOf[to] += value;\n        uint256 v0 = SafeAdd(value, _totalSupply);\n        _totalSupply = v0;\n        emit Transfer(address(0), to, value);\n    }\n\n    function pause() public { \n        require(_owner == msg.sender);\n        require(!_paused);\n        _paused = true;\n        emit Pause();\n    }\n\n    function oneTokenInWei() public view returns (uint256) { \n        return _oneTokenInWei;\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function symbol() public pure returns (string memory) { \n        return \"ACI\";\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) { \n        require(_balanceOf[msg.sender] >= value);\n        require(value > 0);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) { \n        return _allowance[spender];\n    }\n\n    function maxTokens() public pure returns (uint256) { \n        return 0x1312d00;\n    }\n\n    function transferOwnership(address newOwner) public { \n        require(_owner == msg.sender);\n        _owner = newOwner;\n    }\n\n    function withdraw(address payable to, uint256 amount) public { \n        require(_owner == msg.sender);\n        (bool success,) = to.call{value: amount}(\"\");\n        require(success);\n        emit Withdraw(to, amount);\n    }\n\n    function SafeAdd(uint256 a, uint256 b) private pure returns (uint256) { \n        uint256 c = a + b;\n        require(c >= a, \"SafeAdd: addition overflow\");\n        return c;\n    }\n}\n```\nPlease note that this code is not exactly the same as the decompiled code, some parts are not included because they are not needed or not applicable in Solidity. Also, please note that this is a basic contract and it lacks some important features such as the ERC20 standard definitions and SafeMath library usage for safe arithmetic operations. Please make sure to revise and test this code before using it in production.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465011,
	"id": "chatcmpl-8R53zhmFRKvoH2RH2eqhEPgMFPIxD",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 05:28 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _oneTokenInWei; // STORAGE[0x4]\nuint256 _totalEthRecieved; // STORAGE[0x5]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint8 _paused; // STORAGE[0x3] bytes 20 to 20\n\n// Events\nPriceChanged(string, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nUnpause();\nPause();\nWithdraw(address, uint256);\n\nfunction fallback() public payable { \n    require(!_paused);\n    assert(_oneTokenInWei > 0);\n    assert(_oneTokenInWei);\n    assert(_oneTokenInWei);\n    assert(msg.value == _oneTokenInWei * (msg.value / _oneTokenInWei) + msg.value % _oneTokenInWei);\n    v0 = _SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n    require(v0 <= 0x1312d00);\n    require(msg.value > 0);\n    _balanceOf[msg.sender] += msg.value / _oneTokenInWei;\n    v1 = _SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n    _totalSupply = v1;\n    _totalEthRecieved += msg.value;\n    emit 0xb247b1b34db16e7eea7a3c0f261bb2bbaa1067b3a0f1eafea8986af22978f4d(msg.sender, msg.value / _oneTokenInWei);\n}\n\nfunction setEthPrice(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _oneTokenInWei = varg0;\n    emit PriceChanged('New price set', varg0);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (9) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & 'ACI Token';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] += varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = v5 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction totalEthRecieved() public nonPayable { \n    return _totalEthRecieved;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction generateTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _balanceOf[varg0] += varg1;\n    v0 = _SafeAdd(varg1, _totalSupply);\n    _totalSupply = v0;\n    emit 0xb247b1b34db16e7eea7a3c0f261bb2bbaa1067b3a0f1eafea8986af22978f4d(varg0, varg1);\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction oneTokenInWei() public nonPayable { \n    return _oneTokenInWei;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4143490000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (_balanceOf[msg.sender] >= varg1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x5520x878B0x33d;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = v4 = 1;\n    }\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction maxTokens() public nonPayable { \n    return 0x1312d00;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0);\n    emit Withdraw(varg0, varg1);\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9f9262) {\n            setEthPrice(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x6e4ca716 == function_selector) {\n            totalEthRecieved();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x827f32c0 == function_selector) {\n            generateTokens(address,uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x84e3ac94 == function_selector) {\n            oneTokenInWei();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe8315742 == function_selector) {\n            maxTokens();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 05:28 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _oneTokenInWei; // STORAGE[0x4]\nuint256 _totalEthRecieved; // STORAGE[0x5]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint8 _paused; // STORAGE[0x3] bytes 20 to 20\n\n// Events\nPriceChanged(string, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nUnpause();\nPause();\nWithdraw(address, uint256);\n\nfunction fallback() public payable { \n    require(!_paused);\n    assert(_oneTokenInWei > 0);\n    assert(_oneTokenInWei);\n    assert(_oneTokenInWei);\n    assert(msg.value == _oneTokenInWei * (msg.value / _oneTokenInWei) + msg.value % _oneTokenInWei);\n    v0 = _SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n    require(v0 <= 0x1312d00);\n    require(msg.value > 0);\n    _balanceOf[msg.sender] += msg.value / _oneTokenInWei;\n    v1 = _SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n    _totalSupply = v1;\n    _totalEthRecieved += msg.value;\n    emit 0xb247b1b34db16e7eea7a3c0f261bb2bbaa1067b3a0f1eafea8986af22978f4d(msg.sender, msg.value / _oneTokenInWei);\n}\n\nfunction setEthPrice(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _oneTokenInWei = varg0;\n    emit PriceChanged('New price set', varg0);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (9) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & 'ACI Token';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] += varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = v5 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction totalEthRecieved() public nonPayable { \n    return _totalEthRecieved;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction generateTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _balanceOf[varg0] += varg1;\n    v0 = _SafeAdd(varg1, _totalSupply);\n    _totalSupply = v0;\n    emit 0xb247b1b34db16e7eea7a3c0f261bb2bbaa1067b3a0f1eafea8986af22978f4d(varg0, varg1);\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction oneTokenInWei() public nonPayable { \n    return _oneTokenInWei;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4143490000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (_balanceOf[msg.sender] >= varg1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x5520x878B0x33d;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = v4 = 1;\n    }\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction maxTokens() public nonPayable { \n    return 0x1312d00;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0);\n    emit Withdraw(varg0, varg1);\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9f9262) {\n            setEthPrice(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x6e4ca716 == function_selector) {\n            totalEthRecieved();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x827f32c0 == function_selector) {\n            generateTokens(address,uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x84e3ac94 == function_selector) {\n            oneTokenInWei();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe8315742 == function_selector) {\n            maxTokens();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 05:28 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _oneTokenInWei; // STORAGE[0x4]\nuint256 _totalEthRecieved; // STORAGE[0x5]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint8 _paused; // STORAGE[0x3] bytes 20 to 20\n\n// Events\nPriceChanged(string, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nUnpause();\nPause();\nWithdraw(address, uint256);\n\nfunction fallback() public payable { \n    require(!_paused);\n    assert(_oneTokenInWei > 0);\n    assert(_oneTokenInWei);\n    assert(_oneTokenInWei);\n    assert(msg.value == _oneTokenInWei * (msg.value / _oneTokenInWei) + msg.value % _oneTokenInWei);\n    v0 = _SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n    require(v0 <= 0x1312d00);\n    require(msg.value > 0);\n    _balanceOf[msg.sender] += msg.value / _oneTokenInWei;\n    v1 = _SafeAdd(msg.value / _oneTokenInWei, _totalSupply);\n    _totalSupply = v1;\n    _totalEthRecieved += msg.value;\n    emit 0xb247b1b34db16e7eea7a3c0f261bb2bbaa1067b3a0f1eafea8986af22978f4d(msg.sender, msg.value / _oneTokenInWei);\n}\n\nfunction setEthPrice(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _oneTokenInWei = varg0;\n    emit PriceChanged('New price set', varg0);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (9) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & 'ACI Token';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] += varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = v5 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction totalEthRecieved() public nonPayable { \n    return _totalEthRecieved;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction generateTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _balanceOf[varg0] += varg1;\n    v0 = _SafeAdd(varg1, _totalSupply);\n    _totalSupply = v0;\n    emit 0xb247b1b34db16e7eea7a3c0f261bb2bbaa1067b3a0f1eafea8986af22978f4d(varg0, varg1);\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction oneTokenInWei() public nonPayable { \n    return _oneTokenInWei;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4143490000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (_balanceOf[msg.sender] >= varg1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x5520x878B0x33d;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = v4 = 1;\n    }\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction maxTokens() public nonPayable { \n    return 0x1312d00;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0);\n    emit Withdraw(varg0, varg1);\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9f9262) {\n            setEthPrice(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x6e4ca716 == function_selector) {\n            totalEthRecieved();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x827f32c0 == function_selector) {\n            generateTokens(address,uint256);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x84e3ac94 == function_selector) {\n            oneTokenInWei();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe8315742 == function_selector) {\n            maxTokens();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 50.829829931259155,
	"usage": {
		"completion_tokens": 1198,
		"prompt_tokens": 2230,
		"total_tokens": 3428
	}
}