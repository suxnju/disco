{
	"address": "0x8ed6ae0903c66484bcafd7528d284b324207f620",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Based on your provided decompiled code, here is the recompiled Solidity contract code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract TokenContract {\n    uint256[] private _name;\n    uint256 private _total_supply;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns(bool) {\n        require(_balanceOf[from] >= value);\n        require(_allowance[from][msg.sender] >= value);\n\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function withdraw(uint256 value) public {\n        require(_balanceOf[msg.sender] >= value);\n\n        _balanceOf[msg.sender] -= value;\n        _total_supply -= value;\n\n        msg.sender.transfer(value);\n    }\n\n    function total_supply() public view returns (uint256) {\n        return _total_supply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function createToken() public payable {\n        require(msg.value > 0);\n\n        _balanceOf[msg.sender] += msg.value;\n        _total_supply += msg.value;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(_balanceOf[msg.sender] >= value);\n\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function name() public view returns (string memory) {\n        return string(abi.encodePacked(_name));\n    }\n\n    fallback() external payable {\n        revert();\n    }\n}\n```\n\nPlease note that the \"__function_selector__\" function is not included because it's not a standard Solidity function. The Solidity compiler generates code to handle function selector dispatch, so this is not something you typically write yourself. Also, the original EVM bytecode was probably optimized, so the resulting Solidity code might not be 1:1 equivalent but it should function the same way.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711533771,
	"id": "chatcmpl-97KPLpwf7ht3mesnjusmv1E65LAH8",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 18:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _total_supply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    if (!v0) {\n        v4 = v5 = 0;\n    } else {\n        assert(varg2 <= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        assert(varg2 <= _allowance[msg.sender]);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n        _balanceOf[varg1] = _allowance[varg1] + varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v4 = v6 = 1;\n    }\n    return v4;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _total_supply);\n    _total_supply = _total_supply - varg0;\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction total_supply() public nonPayable { \n    return _total_supply;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction CreateToken() public payable { \n    require(msg.value > 0);\n    assert(_balanceOf[msg.sender] + msg.value >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    assert(_total_supply + msg.value >= _total_supply);\n    _total_supply = _total_supply + msg.value;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        assert(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v3 = v5 = 1;\n    }\n    return v3;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x95ea7b3 == uint32(function_selector >> 224)) {\n            approve(address,uint256);\n        } else if (0x23b872dd == uint32(function_selector >> 224)) {\n            transferFrom(address,address,uint256);\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x3940e9ee == uint32(function_selector >> 224)) {\n            total_supply();\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0xa2ea2aaf == uint32(function_selector >> 224)) {\n            CreateToken();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == uint32(function_selector >> 224)) {\n            allowance(address,address);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 18:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _total_supply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    if (!v0) {\n        v4 = v5 = 0;\n    } else {\n        assert(varg2 <= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        assert(varg2 <= _allowance[msg.sender]);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n        _balanceOf[varg1] = _allowance[varg1] + varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v4 = v6 = 1;\n    }\n    return v4;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _total_supply);\n    _total_supply = _total_supply - varg0;\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction total_supply() public nonPayable { \n    return _total_supply;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction CreateToken() public payable { \n    require(msg.value > 0);\n    assert(_balanceOf[msg.sender] + msg.value >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    assert(_total_supply + msg.value >= _total_supply);\n    _total_supply = _total_supply + msg.value;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        assert(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v3 = v5 = 1;\n    }\n    return v3;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x95ea7b3 == uint32(function_selector >> 224)) {\n            approve(address,uint256);\n        } else if (0x23b872dd == uint32(function_selector >> 224)) {\n            transferFrom(address,address,uint256);\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x3940e9ee == uint32(function_selector >> 224)) {\n            total_supply();\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0xa2ea2aaf == uint32(function_selector >> 224)) {\n            CreateToken();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == uint32(function_selector >> 224)) {\n            allowance(address,address);\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 18:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _total_supply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    if (!v0) {\n        v4 = v5 = 0;\n    } else {\n        assert(varg2 <= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        assert(varg2 <= _allowance[msg.sender]);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n        _balanceOf[varg1] = _allowance[varg1] + varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v4 = v6 = 1;\n    }\n    return v4;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _total_supply);\n    _total_supply = _total_supply - varg0;\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction total_supply() public nonPayable { \n    return _total_supply;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction CreateToken() public payable { \n    require(msg.value > 0);\n    assert(_balanceOf[msg.sender] + msg.value >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    assert(_total_supply + msg.value >= _total_supply);\n    _total_supply = _total_supply + msg.value;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        assert(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v3 = v5 = 1;\n    }\n    return v3;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x95ea7b3 == uint32(function_selector >> 224)) {\n            approve(address,uint256);\n        } else if (0x23b872dd == uint32(function_selector >> 224)) {\n            transferFrom(address,address,uint256);\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x3940e9ee == uint32(function_selector >> 224)) {\n            total_supply();\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0xa2ea2aaf == uint32(function_selector >> 224)) {\n            CreateToken();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == uint32(function_selector >> 224)) {\n            allowance(address,address);\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 109.06523704528809,
	"usage": {
		"completion_tokens": 578,
		"prompt_tokens": 1550,
		"total_tokens": 2128
	}
}