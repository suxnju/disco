{
	"address": "0xb9dad061b4ada5825abc2c9914e89181c0cdc56c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is a simplified version of the contract in Solidity:\n\n```Solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint8 private _decimals;\n    uint256 private _totalSupply;\n    uint256 private _totalSold;\n    string private _name;\n    string private _symbol;\n    mapping (address => uint256) private _withdraw;\n    uint256 private _increaseProfit;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    address private _owner;\n    address private _finance;\n    address private _jackpot;\n    address private _shareContract;\n\n    event AddProfit(address indexed sender, uint256 amount, uint256 profit);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Withdraw(address indexed sender, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    constructor() {\n        _decimals = 18;\n        _totalSupply = 1000000;\n        _totalSold = 0;\n        _name = \"MyToken\";\n        _symbol = \"MTK\";\n        _owner = msg.sender;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function totalSold() public view returns (uint256) {\n        return _totalSold;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"Transfer from the zero address is not allowed.\");\n        require(recipient != address(0), \"Transfer to the zero address is not allowed.\");\n        require(_balances[msg.sender] >= amount, \"Transfer amount exceeds balance\");\n\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0), \"Transfer from the zero address is not allowed.\");\n        require(recipient != address(0), \"Transfer to the zero address is not allowed.\");\n        require(_balances[sender] >= amount, \"Transfer amount exceeds balance\");\n        require(_allowances[sender][msg.sender] >= amount, \"Transfer amount exceeds allowance\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n}\n```\nThis contract is a simple ERC20 token contract with additional functionality. It has the standard ERC20 functions: `totalSupply`, `balanceOf`, `transfer`, `allowance`, `approve`, `transferFrom`. It also has additional functions like `totalSold` to keep track of the number of tokens sold, `withdraw` to withdraw funds from the contract, and `increaseProfit` to increase the profit of the contract. \n\nPlease note that some functions from the provided code are not included in this Solidity contract because the logic is unclear or hard to infer from the provided code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701455726,
	"id": "chatcmpl-8R2eED1DrLMvJukqnqx7ized30q6Y",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 09:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 _decimals; // STORAGE[0x0] bytes 0 to 0\nuint256 _totalSupply; // STORAGE[0x1]\nuint256 _totalSold; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _withdraw; // STORAGE[0x7]\nuint256 _increaseProfit; // STORAGE[0x8]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xd]\naddress _owner; // STORAGE[0x5] bytes 0 to 19\naddress _finance; // STORAGE[0x6] bytes 0 to 19\naddress _jackpot; // STORAGE[0x9] bytes 0 to 19\naddress _shareContract; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nAddProfit(address, uint256, uint256);\nApproval(address, address, uint256);\nWithdraw(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1112(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0, 'Amount must be provided');\n    v0 = _SafeDiv(_totalSupply, msg.value);\n    v1 = _SafeAdd(_increaseProfit, v0);\n    _increaseProfit = v1;\n    emit AddProfit(msg.sender, msg.value, v1);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 > 0;\n    if (v1) {\n        v0 = v2 = !_allowance[varg0];\n    }\n    require(v0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    v0 = 0xf25(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction increaseProfit() public payable { \n    if (msg.value <= 0) {\n        v0 = v1 = 0;\n    } else {\n        v2 = _SafeDiv(_totalSupply, msg.value);\n        v3 = _SafeAdd(_increaseProfit, v2);\n        _increaseProfit = v3;\n        emit AddProfit(msg.sender, msg.value, v3);\n        v0 = v4 = 1;\n        goto 0x69e0x716B0x310;\n    }\n    return v0;\n}\n\nfunction finance() public nonPayable { \n    return _finance;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0xc21(msg.sender);\n    require(v0 > 0, 'No cash available');\n    emit Withdraw(msg.sender, v0);\n    v1 = _SafeAdd(v0, _withdraw[msg.sender]);\n    _withdraw[msg.sender] = v1;\n    v2 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction jackpot() public nonPayable { \n    return _jackpot;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction setShare(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _shareContract = varg0;\n}\n\nfunction setJackpot(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _jackpot = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalSold() public nonPayable { \n    return _totalSold;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setFinance(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _finance = varg0;\n}\n\nfunction price() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xf25(varg1, varg0, msg.sender);\n    return v0;\n}\n\nfunction devWithdraw() public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    v0 = 0xc21(this);\n    emit Withdraw(msg.sender, v0);\n    v1 = _SafeAdd(v0, _withdraw[address(this)]);\n    _withdraw[address(this)] = v1;\n    v2 = _owner.call().value(v0).gas(2300 * !v0);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0xc21(varg0);\n    return v0;\n}\n\nfunction shareContract() public nonPayable { \n    return _shareContract;\n}\n\nfunction buy(uint256 varg0) public payable { \n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 > 0);\n    v0 = 0x1112(0xde0b6b3a7640000, varg0);\n    require(v0 == msg.value);\n    require(varg0 <= _balanceOf[address(this)]);\n    require(varg0 <= _totalSupply - _totalSold, 'Sold out');\n    v1 = 0xf25(varg0, msg.sender, this);\n    v2 = v3 = _finance;\n    v4 = v5 = 2300;\n    v6 = v7 = 3545;\n    v8 = v9 = 100;\n    v10 = v11 = 0x1112(60, v0);\n    while (1) {\n        v12 = _SafeDiv(v8, v10);\n        v13 = v2.call().value(v12).gas(v4 * !v12);\n        require(v13); // checks call status, propagates error data on error\n        v2 = v14 = _jackpot;\n        v4 = v15 = 2300;\n        v6 = v16 = 3623;\n        v8 = v17 = 100;\n        v10 = v18 = 0x1112(20, v0);\n        v19 = v2.call().value(v12).gas(v4 * !v12);\n        require(v19); // checks call status, propagates error data on error\n        v2 = v20 = _shareContract;\n        v4 = v21 = 0x30cc248e;\n        v6 = v22 = 3703;\n        v8 = v23 = 100;\n        v10 = v24 = 0x1112(20, v0);\n    }\n    require(v2.code.size);\n    v25 = v2.increaseProfit().value(v12).gas(msg.gas);\n    require(v25); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _totalSold += varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0 > 0);\n    assert(varg0);\n    v0 = varg1 / varg0;\n    assert(varg0);\n    assert(varg1 == varg0 * v0 + varg1 % varg0);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xc21(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = 0x1112(owner_b[v0], _increaseProfit);\n    v2 = _SafeAdd(owner_b[v0], v1);\n    assert(_withdraw[v0] <= v2);\n    return v2 - _withdraw[v0];\n}\n\nfunction 0xf25(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1), 'Receiver address cannot be null');\n    require(address(varg1) != address(varg2));\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = address(varg2);\n        v0 = v3 = varg0 <= _balanceOf[v2];\n    }\n    require(v0);\n    v4 = address(varg1);\n    v5 = varg0 + _balanceOf[v4];\n    assert(v5 >= _balanceOf[v4]);\n    v6 = address(varg2);\n    v7 = address(varg1);\n    _balanceOf[v7] = v5;\n    MEM[0] = v6;\n    _balanceOf[v6] = _balanceOf[v6] - varg0;\n    v8 = 0x1112(_increaseProfit, varg0);\n    v9 = address(varg2);\n    v10 = _SafeAdd(v8, owner_b[v9]);\n    v11 = address(varg2);\n    owner_b[v11] = v10;\n    v12 = address(varg1);\n    v13 = _SafeAdd(v8, owner_b[v12]);\n    v14 = address(varg1);\n    _withdraw[v14] = v13;\n    emit Transfer(address(varg2), v14, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x30cc248e == function_selector) {\n            increaseProfit();\n        } else if (0x313b7b19 == function_selector) {\n            finance();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x6b31ee01 == function_selector) {\n            jackpot();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7de7a18d == function_selector) {\n            setShare(address);\n        } else if (0x7e95385c == function_selector) {\n            setJackpot(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9106d7ba == function_selector) {\n            totalSold();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9b8d3064 == function_selector) {\n            setFinance(address);\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xad606c72 == function_selector) {\n            devWithdraw();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd1f55764 == function_selector) {\n            shareContract();\n        } else if (0xd96a094a == function_selector) {\n            buy(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 09:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 _decimals; // STORAGE[0x0] bytes 0 to 0\nuint256 _totalSupply; // STORAGE[0x1]\nuint256 _totalSold; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _withdraw; // STORAGE[0x7]\nuint256 _increaseProfit; // STORAGE[0x8]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xd]\naddress _owner; // STORAGE[0x5] bytes 0 to 19\naddress _finance; // STORAGE[0x6] bytes 0 to 19\naddress _jackpot; // STORAGE[0x9] bytes 0 to 19\naddress _shareContract; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nAddProfit(address, uint256, uint256);\nApproval(address, address, uint256);\nWithdraw(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1112(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0, 'Amount must be provided');\n    v0 = _SafeDiv(_totalSupply, msg.value);\n    v1 = _SafeAdd(_increaseProfit, v0);\n    _increaseProfit = v1;\n    emit AddProfit(msg.sender, msg.value, v1);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 > 0;\n    if (v1) {\n        v0 = v2 = !_allowance[varg0];\n    }\n    require(v0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    v0 = 0xf25(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction increaseProfit() public payable { \n    if (msg.value <= 0) {\n        v0 = v1 = 0;\n    } else {\n        v2 = _SafeDiv(_totalSupply, msg.value);\n        v3 = _SafeAdd(_increaseProfit, v2);\n        _increaseProfit = v3;\n        emit AddProfit(msg.sender, msg.value, v3);\n        v0 = v4 = 1;\n        goto 0x69e0x716B0x310;\n    }\n    return v0;\n}\n\nfunction finance() public nonPayable { \n    return _finance;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0xc21(msg.sender);\n    require(v0 > 0, 'No cash available');\n    emit Withdraw(msg.sender, v0);\n    v1 = _SafeAdd(v0, _withdraw[msg.sender]);\n    _withdraw[msg.sender] = v1;\n    v2 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction jackpot() public nonPayable { \n    return _jackpot;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction setShare(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _shareContract = varg0;\n}\n\nfunction setJackpot(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _jackpot = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalSold() public nonPayable { \n    return _totalSold;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setFinance(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _finance = varg0;\n}\n\nfunction price() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xf25(varg1, varg0, msg.sender);\n    return v0;\n}\n\nfunction devWithdraw() public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    v0 = 0xc21(this);\n    emit Withdraw(msg.sender, v0);\n    v1 = _SafeAdd(v0, _withdraw[address(this)]);\n    _withdraw[address(this)] = v1;\n    v2 = _owner.call().value(v0).gas(2300 * !v0);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0xc21(varg0);\n    return v0;\n}\n\nfunction shareContract() public nonPayable { \n    return _shareContract;\n}\n\nfunction buy(uint256 varg0) public payable { \n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 > 0);\n    v0 = 0x1112(0xde0b6b3a7640000, varg0);\n    require(v0 == msg.value);\n    require(varg0 <= _balanceOf[address(this)]);\n    require(varg0 <= _totalSupply - _totalSold, 'Sold out');\n    v1 = 0xf25(varg0, msg.sender, this);\n    v2 = v3 = _finance;\n    v4 = v5 = 2300;\n    v6 = v7 = 3545;\n    v8 = v9 = 100;\n    v10 = v11 = 0x1112(60, v0);\n    while (1) {\n        v12 = _SafeDiv(v8, v10);\n        v13 = v2.call().value(v12).gas(v4 * !v12);\n        require(v13); // checks call status, propagates error data on error\n        v2 = v14 = _jackpot;\n        v4 = v15 = 2300;\n        v6 = v16 = 3623;\n        v8 = v17 = 100;\n        v10 = v18 = 0x1112(20, v0);\n        v19 = v2.call().value(v12).gas(v4 * !v12);\n        require(v19); // checks call status, propagates error data on error\n        v2 = v20 = _shareContract;\n        v4 = v21 = 0x30cc248e;\n        v6 = v22 = 3703;\n        v8 = v23 = 100;\n        v10 = v24 = 0x1112(20, v0);\n    }\n    require(v2.code.size);\n    v25 = v2.increaseProfit().value(v12).gas(msg.gas);\n    require(v25); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _totalSold += varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0 > 0);\n    assert(varg0);\n    v0 = varg1 / varg0;\n    assert(varg0);\n    assert(varg1 == varg0 * v0 + varg1 % varg0);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xc21(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = 0x1112(owner_b[v0], _increaseProfit);\n    v2 = _SafeAdd(owner_b[v0], v1);\n    assert(_withdraw[v0] <= v2);\n    return v2 - _withdraw[v0];\n}\n\nfunction 0xf25(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1), 'Receiver address cannot be null');\n    require(address(varg1) != address(varg2));\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = address(varg2);\n        v0 = v3 = varg0 <= _balanceOf[v2];\n    }\n    require(v0);\n    v4 = address(varg1);\n    v5 = varg0 + _balanceOf[v4];\n    assert(v5 >= _balanceOf[v4]);\n    v6 = address(varg2);\n    v7 = address(varg1);\n    _balanceOf[v7] = v5;\n    MEM[0] = v6;\n    _balanceOf[v6] = _balanceOf[v6] - varg0;\n    v8 = 0x1112(_increaseProfit, varg0);\n    v9 = address(varg2);\n    v10 = _SafeAdd(v8, owner_b[v9]);\n    v11 = address(varg2);\n    owner_b[v11] = v10;\n    v12 = address(varg1);\n    v13 = _SafeAdd(v8, owner_b[v12]);\n    v14 = address(varg1);\n    _withdraw[v14] = v13;\n    emit Transfer(address(varg2), v14, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x30cc248e == function_selector) {\n            increaseProfit();\n        } else if (0x313b7b19 == function_selector) {\n            finance();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x6b31ee01 == function_selector) {\n            jackpot();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7de7a18d == function_selector) {\n            setShare(address);\n        } else if (0x7e95385c == function_selector) {\n            setJackpot(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9106d7ba == function_selector) {\n            totalSold();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9b8d3064 == function_selector) {\n            setFinance(address);\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xad606c72 == function_selector) {\n            devWithdraw();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd1f55764 == function_selector) {\n            shareContract();\n        } else if (0xd96a094a == function_selector) {\n            buy(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 09:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 _decimals; // STORAGE[0x0] bytes 0 to 0\nuint256 _totalSupply; // STORAGE[0x1]\nuint256 _totalSold; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _withdraw; // STORAGE[0x7]\nuint256 _increaseProfit; // STORAGE[0x8]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xd]\naddress _owner; // STORAGE[0x5] bytes 0 to 19\naddress _finance; // STORAGE[0x6] bytes 0 to 19\naddress _jackpot; // STORAGE[0x9] bytes 0 to 19\naddress _shareContract; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nAddProfit(address, uint256, uint256);\nApproval(address, address, uint256);\nWithdraw(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1112(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0, 'Amount must be provided');\n    v0 = _SafeDiv(_totalSupply, msg.value);\n    v1 = _SafeAdd(_increaseProfit, v0);\n    _increaseProfit = v1;\n    emit AddProfit(msg.sender, msg.value, v1);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 > 0;\n    if (v1) {\n        v0 = v2 = !_allowance[varg0];\n    }\n    require(v0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    v0 = 0xf25(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction increaseProfit() public payable { \n    if (msg.value <= 0) {\n        v0 = v1 = 0;\n    } else {\n        v2 = _SafeDiv(_totalSupply, msg.value);\n        v3 = _SafeAdd(_increaseProfit, v2);\n        _increaseProfit = v3;\n        emit AddProfit(msg.sender, msg.value, v3);\n        v0 = v4 = 1;\n        goto 0x69e0x716B0x310;\n    }\n    return v0;\n}\n\nfunction finance() public nonPayable { \n    return _finance;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0xc21(msg.sender);\n    require(v0 > 0, 'No cash available');\n    emit Withdraw(msg.sender, v0);\n    v1 = _SafeAdd(v0, _withdraw[msg.sender]);\n    _withdraw[msg.sender] = v1;\n    v2 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction jackpot() public nonPayable { \n    return _jackpot;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction setShare(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _shareContract = varg0;\n}\n\nfunction setJackpot(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _jackpot = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalSold() public nonPayable { \n    return _totalSold;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setFinance(address varg0) public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    _finance = varg0;\n}\n\nfunction price() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xf25(varg1, varg0, msg.sender);\n    return v0;\n}\n\nfunction devWithdraw() public nonPayable { \n    require(_owner == msg.sender, 'only owner');\n    v0 = 0xc21(this);\n    emit Withdraw(msg.sender, v0);\n    v1 = _SafeAdd(v0, _withdraw[address(this)]);\n    _withdraw[address(this)] = v1;\n    v2 = _owner.call().value(v0).gas(2300 * !v0);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0xc21(varg0);\n    return v0;\n}\n\nfunction shareContract() public nonPayable { \n    return _shareContract;\n}\n\nfunction buy(uint256 varg0) public payable { \n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 > 0);\n    v0 = 0x1112(0xde0b6b3a7640000, varg0);\n    require(v0 == msg.value);\n    require(varg0 <= _balanceOf[address(this)]);\n    require(varg0 <= _totalSupply - _totalSold, 'Sold out');\n    v1 = 0xf25(varg0, msg.sender, this);\n    v2 = v3 = _finance;\n    v4 = v5 = 2300;\n    v6 = v7 = 3545;\n    v8 = v9 = 100;\n    v10 = v11 = 0x1112(60, v0);\n    while (1) {\n        v12 = _SafeDiv(v8, v10);\n        v13 = v2.call().value(v12).gas(v4 * !v12);\n        require(v13); // checks call status, propagates error data on error\n        v2 = v14 = _jackpot;\n        v4 = v15 = 2300;\n        v6 = v16 = 3623;\n        v8 = v17 = 100;\n        v10 = v18 = 0x1112(20, v0);\n        v19 = v2.call().value(v12).gas(v4 * !v12);\n        require(v19); // checks call status, propagates error data on error\n        v2 = v20 = _shareContract;\n        v4 = v21 = 0x30cc248e;\n        v6 = v22 = 3703;\n        v8 = v23 = 100;\n        v10 = v24 = 0x1112(20, v0);\n    }\n    require(v2.code.size);\n    v25 = v2.increaseProfit().value(v12).gas(msg.gas);\n    require(v25); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _totalSold += varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0 > 0);\n    assert(varg0);\n    v0 = varg1 / varg0;\n    assert(varg0);\n    assert(varg1 == varg0 * v0 + varg1 % varg0);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xc21(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = 0x1112(owner_b[v0], _increaseProfit);\n    v2 = _SafeAdd(owner_b[v0], v1);\n    assert(_withdraw[v0] <= v2);\n    return v2 - _withdraw[v0];\n}\n\nfunction 0xf25(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1), 'Receiver address cannot be null');\n    require(address(varg1) != address(varg2));\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = address(varg2);\n        v0 = v3 = varg0 <= _balanceOf[v2];\n    }\n    require(v0);\n    v4 = address(varg1);\n    v5 = varg0 + _balanceOf[v4];\n    assert(v5 >= _balanceOf[v4]);\n    v6 = address(varg2);\n    v7 = address(varg1);\n    _balanceOf[v7] = v5;\n    MEM[0] = v6;\n    _balanceOf[v6] = _balanceOf[v6] - varg0;\n    v8 = 0x1112(_increaseProfit, varg0);\n    v9 = address(varg2);\n    v10 = _SafeAdd(v8, owner_b[v9]);\n    v11 = address(varg2);\n    owner_b[v11] = v10;\n    v12 = address(varg1);\n    v13 = _SafeAdd(v8, owner_b[v12]);\n    v14 = address(varg1);\n    _withdraw[v14] = v13;\n    emit Transfer(address(varg2), v14, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x30cc248e == function_selector) {\n            increaseProfit();\n        } else if (0x313b7b19 == function_selector) {\n            finance();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x6b31ee01 == function_selector) {\n            jackpot();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7de7a18d == function_selector) {\n            setShare(address);\n        } else if (0x7e95385c == function_selector) {\n            setJackpot(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9106d7ba == function_selector) {\n            totalSold();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9b8d3064 == function_selector) {\n            setFinance(address);\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xad606c72 == function_selector) {\n            devWithdraw();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd1f55764 == function_selector) {\n            shareContract();\n        } else if (0xd96a094a == function_selector) {\n            buy(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 55.55928826332092,
	"usage": {
		"completion_tokens": 815,
		"prompt_tokens": 3613,
		"total_tokens": 4428
	}
}