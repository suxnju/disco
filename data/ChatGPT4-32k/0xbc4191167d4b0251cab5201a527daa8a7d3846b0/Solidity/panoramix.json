{
	"address": "0xbc4191167d4b0251cab5201a527daa8a7d3846b0",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is address at storage 1\n  contributionsEth is mapping of uint256 at storage 2\n  contributionsToken is mapping of uint256 at storage 3\n  indexes is mapping of uint256 at storage 4\n  addresses is mapping of address at storage 5\n  lastIndex is uint256 at storage 6\n  stor7 is mapping of uint8 at storage 7\n  totalTokens is uint256 at storage 8\n  totalWei is uint256 at storage 9\n  stor10 is uint256 at storage 10\n  last6EthDivPoints is mapping of uint256 at storage 11\n  total6EthDivPoints is uint256 at storage 12\n  last4EthDivPoints is mapping of uint256 at storage 13\n  total4EthDivPoints is uint256 at storage 14\n  last6TokenDivPoints is mapping of uint256 at storage 15\n  total6TokenDivPoints is uint256 at storage 16\n  last4TokenDivPoints is mapping of uint256 at storage 17\n  total4TokenDivPoints is uint256 at storage 18\n\ndef last6EthDivPoints(address _param1): # not payable\n  return last6EthDivPoints[_param1]\n\ndef total6EthDivPoints(): # not payable\n  return total6EthDivPoints\n\ndef getTotalWei(): # not payable\n  return totalWei\n\ndef contributionsToken(address _param1): # not payable\n  return contributionsToken[_param1]\n\ndef last6TokenDivPoints(address _param1): # not payable\n  return last6TokenDivPoints[_param1]\n\ndef indexes(address _param1): # not payable\n  return indexes[_param1]\n\ndef addedToList(address _param1): # not payable\n  return bool(stor7[_param1])\n\ndef total4EthDivPoints(): # not payable\n  return total4EthDivPoints\n\ndef owner(): # not payable\n  return owner\n\ndef total4TokenDivPoints(): # not payable\n  return total4TokenDivPoints\n\ndef contributionsEth(address _param1): # not payable\n  return contributionsEth[_param1]\n\ndef last4EthDivPoints(address _param1): # not payable\n  return last4EthDivPoints[_param1]\n\ndef last4TokenDivPoints(address _param1): # not payable\n  return last4TokenDivPoints[_param1]\n\ndef total6TokenDivPoints(): # not payable\n  return total6TokenDivPoints\n\ndef addresses(uint256 _param1): # not payable\n  return addresses[_param1]\n\ndef getTotalTokens(): # not payable\n  return totalTokens\n\ndef lastIndex(): # not payable\n  return lastIndex\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef eth4DivsOwing(address _addr): # not payable\n  if not stor7[address(_addr)]:\n      return 0\n  require last4EthDivPoints[address(_addr)] <= total4EthDivPoints\n  if not contributionsEth[address(_addr)]:\n      require stor10 > 0\n      if stor10:\n          return (0 / stor10)\n  else:\n      require (total4EthDivPoints * contributionsEth[address(_addr)]) - (last4EthDivPoints[address(_addr)] * contributionsEth[address(_addr)]) / contributionsEth[address(_addr)] == total4EthDivPoints - last4EthDivPoints[address(_addr)]\n      require stor10 > 0\n      if stor10:\n          return ((total4EthDivPoints * contributionsEth[address(_addr)]) - (last4EthDivPoints[address(_addr)] * contributionsEth[address(_addr)]) / stor10)\n  ('iszero', ('stor', ('name', 'stor10', 10)))\n  revert\n\ndef eth6DivsOwing(address _addr): # not payable\n  if not stor7[address(_addr)]:\n      return 0\n  require last6EthDivPoints[address(_addr)] <= total6EthDivPoints\n  if not contributionsToken[address(_addr)]:\n      require stor10 > 0\n      if stor10:\n          return (0 / stor10)\n  else:\n      require (total6EthDivPoints * contributionsToken[address(_addr)]) - (last6EthDivPoints[address(_addr)] * contributionsToken[address(_addr)]) / contributionsToken[address(_addr)] == total6EthDivPoints - last6EthDivPoints[address(_addr)]\n      require stor10 > 0\n      if stor10:\n          return ((total6EthDivPoints * contributionsToken[address(_addr)]) - (last6EthDivPoints[address(_addr)] * contributionsToken[address(_addr)]) / stor10)\n  ('iszero', ('stor', ('name', 'stor10', 10)))\n  revert\n\ndef token4DivsOwing(address _addr): # not payable\n  if not stor7[address(_addr)]:\n      return 0\n  require last4TokenDivPoints[address(_addr)] <= total4TokenDivPoints\n  if not contributionsEth[address(_addr)]:\n      require stor10 > 0\n      if stor10:\n          return (0 / stor10)\n  else:\n      require (total4TokenDivPoints * contributionsEth[address(_addr)]) - (last4TokenDivPoints[address(_addr)] * contributionsEth[address(_addr)]) / contributionsEth[address(_addr)] == total4TokenDivPoints - last4TokenDivPoints[address(_addr)]\n      require stor10 > 0\n      if stor10:\n          return ((total4TokenDivPoints * contributionsEth[address(_addr)]) - (last4TokenDivPoints[address(_addr)] * contributionsEth[address(_addr)]) / stor10)\n  ('iszero', ('stor', ('name', 'stor10', 10)))\n  revert\n\ndef token6DivsOwing(address _addr): # not payable\n  if not stor7[address(_addr)]:\n      return 0\n  require last6TokenDivPoints[address(_addr)] <= total6TokenDivPoints\n  if not contributionsToken[address(_addr)]:\n      require stor10 > 0\n      if stor10:\n          return (0 / stor10)\n  else:\n      require (total6TokenDivPoints * contributionsToken[address(_addr)]) - (last6TokenDivPoints[address(_addr)] * contributionsToken[address(_addr)]) / contributionsToken[address(_addr)] == total6TokenDivPoints - last6TokenDivPoints[address(_addr)]\n      require stor10 > 0\n      if stor10:\n          return ((total6TokenDivPoints * contributionsToken[address(_addr)]) - (last6TokenDivPoints[address(_addr)] * contributionsToken[address(_addr)]) / stor10)\n  ('iszero', ('stor', ('name', 'stor10', 10)))\n  revert\n\ndef getList(): # not payable\n  if not lastIndex:\n      mem[(32 * lastIndex) + 128] = lastIndex\n  else:\n      mem[128 len 32 * lastIndex] = code.data[6336 len 32 * lastIndex]\n      mem[(32 * lastIndex) + 128] = lastIndex\n      mem[(32 * lastIndex) + 160 len 32 * lastIndex] = code.data[6336 len 32 * lastIndex]\n  idx = 1\n  while idx <= lastIndex:\n      require idx - 1 < lastIndex\n      mem[(32 * idx - 1) + 128] = addresses[idx]\n      mem[0] = addresses[idx]\n      mem[32] = 3\n      require idx - 1 < mem[(32 * lastIndex) + 128]\n      mem[(32 * lastIndex) + (32 * idx - 1) + 160] = contributionsToken[stor5[idx]]\n      idx = idx + 1\n      continue \n  mem[(64 * lastIndex) + 160] = 64\n  mem[(64 * lastIndex) + 224] = lastIndex\n  mem[(64 * lastIndex) + 256 len floor32(lastIndex)] = mem[128 len floor32(lastIndex)]\n  mem[(64 * lastIndex) + 192] = (32 * lastIndex) + 96\n  mem[(98 * lastIndex) + 256] = mem[(32 * lastIndex) + 128]\n  mem[(98 * lastIndex) + 288 len floor32(mem[(32 * lastIndex) + 128])] = mem[(32 * lastIndex) + 160 len floor32(mem[(32 * lastIndex) + 128])]\n  return memory\n    from (64 * lastIndex) + 160\n     len (32 * mem[(32 * lastIndex) + 128]) + (161 * lastIndex) + 128\n\ndef ethDivsOwing(address account): # not payable\n  if not stor7[address(account)]:\n      if not stor7[address(account)]:\n          return 0\n      require last4EthDivPoints[address(account)] <= total4EthDivPoints\n      if not contributionsEth[address(account)]:\n          require stor10 > 0\n          require stor10\n          require 0 / stor10 >= 0 / stor10\n          return (0 / stor10)\n      require (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / contributionsEth[address(account)] == total4EthDivPoints - last4EthDivPoints[address(account)]\n      require stor10 > 0\n      require stor10\n      require (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10 >= (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10\n      return ((total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10)\n  require last6EthDivPoints[address(account)] <= total6EthDivPoints\n  if not contributionsToken[address(account)]:\n      require stor10 > 0\n      require stor10\n      if not stor7[address(account)]:\n          require 0 / stor10 >= 0\n          return (0 / stor10)\n      require last4EthDivPoints[address(account)] <= total4EthDivPoints\n      if not contributionsEth[address(account)]:\n          require stor10 > 0\n          require stor10\n          require 2 * 0 / stor10 >= 0 / stor10\n          return (2 * 0 / stor10)\n      require (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / contributionsEth[address(account)] == total4EthDivPoints - last4EthDivPoints[address(account)]\n      require stor10 > 0\n      require stor10\n      require (0 / stor10) + ((total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10) >= (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10\n      return ((0 / stor10) + ((total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10))\n  require (total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / contributionsToken[address(account)] == total6EthDivPoints - last6EthDivPoints[address(account)]\n  require stor10 > 0\n  require stor10\n  if not stor7[address(account)]:\n      require (total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / stor10 >= 0\n      return ((total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / stor10)\n  require last4EthDivPoints[address(account)] <= total4EthDivPoints\n  if not contributionsEth[address(account)]:\n      require stor10 > 0\n      require stor10\n      require ((total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + (0 / stor10) >= 0 / stor10\n      return (((total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + (0 / stor10))\n  require (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / contributionsEth[address(account)] == total4EthDivPoints - last4EthDivPoints[address(account)]\n  require stor10 > 0\n  require stor10\n  require ((total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + ((total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10) >= (total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10\n  return (((total6EthDivPoints * contributionsToken[address(account)]) - (last6EthDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + ((total4EthDivPoints * contributionsEth[address(account)]) - (last4EthDivPoints[address(account)] * contributionsEth[address(account)]) / stor10))\n\ndef tokenDivsOwing(address account): # not payable\n  if not stor7[address(account)]:\n      if not stor7[address(account)]:\n          return 0\n      require last4TokenDivPoints[address(account)] <= total4TokenDivPoints\n      if not contributionsEth[address(account)]:\n          require stor10 > 0\n          require stor10\n          require 0 / stor10 >= 0 / stor10\n          return (0 / stor10)\n      require (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / contributionsEth[address(account)] == total4TokenDivPoints - last4TokenDivPoints[address(account)]\n      require stor10 > 0\n      require stor10\n      require (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10 >= (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10\n      return ((total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10)\n  require last6TokenDivPoints[address(account)] <= total6TokenDivPoints\n  if not contributionsToken[address(account)]:\n      require stor10 > 0\n      require stor10\n      if not stor7[address(account)]:\n          require 0 / stor10 >= 0\n          return (0 / stor10)\n      require last4TokenDivPoints[address(account)] <= total4TokenDivPoints\n      if not contributionsEth[address(account)]:\n          require stor10 > 0\n          require stor10\n          require 2 * 0 / stor10 >= 0 / stor10\n          return (2 * 0 / stor10)\n      require (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / contributionsEth[address(account)] == total4TokenDivPoints - last4TokenDivPoints[address(account)]\n      require stor10 > 0\n      require stor10\n      require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10) >= (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10\n      return ((0 / stor10) + ((total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10))\n  require (total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / contributionsToken[address(account)] == total6TokenDivPoints - last6TokenDivPoints[address(account)]\n  require stor10 > 0\n  require stor10\n  if not stor7[address(account)]:\n      require (total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / stor10 >= 0\n      return ((total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / stor10)\n  require last4TokenDivPoints[address(account)] <= total4TokenDivPoints\n  if not contributionsEth[address(account)]:\n      require stor10 > 0\n      require stor10\n      require ((total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + (0 / stor10) >= 0 / stor10\n      return (((total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + (0 / stor10))\n  require (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / contributionsEth[address(account)] == total4TokenDivPoints - last4TokenDivPoints[address(account)]\n  require stor10 > 0\n  require stor10\n  require ((total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + ((total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10) >= (total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10\n  return (((total6TokenDivPoints * contributionsToken[address(account)]) - (last6TokenDivPoints[address(account)] * contributionsToken[address(account)]) / stor10) + ((total4TokenDivPoints * contributionsEth[address(account)]) - (last4TokenDivPoints[address(account)] * contributionsEth[address(account)]) / stor10))\n\ndef withdrawEth(uint256 _amount): # not payable\n  require _amount > 0\n  require _amount <= contributionsEth[caller]\n  if stor7[caller]:\n      require last6EthDivPoints[caller] <= total6EthDivPoints\n      if contributionsToken[caller]:\n          require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6EthDivPoints - last6EthDivPoints[caller]\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if not contributionsEth[caller]:\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n              else:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n          else:\n              require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n              else:\n                  if not stor7[caller]:\n                      if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                      else:\n                          call caller with:\n                             value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          if not _amount:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n      else:\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if contributionsEth[caller]:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                      else:\n                          if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n              else:\n                  require stor10 > 0\n                  require stor10\n                  require 2 * 0 / stor10 >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              else:\n                          else:\n                              require 0 / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 <= 0:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                  else:\n                      if not stor7[caller]:\n                          if 2 * 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 2 * 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 <= 0:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n          else:\n              require 0 / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 <= 0:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                          else:\n                              if not _amount:\n                                  if _amount:\n                                      require 4 * _amount / _amount == 4\n                              else:\n                                  require 6 * _amount / _amount == 6\n                                  if _amount:\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n  else:\n      if not stor7[caller]:\n          if not stor7[caller]:\n              if not stor7[caller]:\n                  last6EthDivPoints[caller] = total6EthDivPoints\n                  last4EthDivPoints[caller] = total4EthDivPoints\n                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                  log DividendsTransferred(\n                        address to=caller,\n                        uint256 ethAmount=0,\n                        uint256 novaAmount=0)\n                  if _amount:\n                      require 89 * _amount / _amount == 89\n                      if _amount:\n                          require 6 * _amount / _amount == 6\n                          if _amount:\n                              require 4 * _amount / _amount == 4\n                          else:\n                              if _amount:\n                                  require _amount / _amount == 1\n                      else:\n                          if _amount:\n                              require 4 * _amount / _amount == 4\n                          if _amount:\n                              require _amount / _amount == 1\n                  else:\n                      if _amount:\n                          require 6 * _amount / _amount == 6\n                      if _amount:\n                          require 4 * _amount / _amount == 4\n                      if _amount:\n                          require _amount / _amount == 1\n              else:\n                  require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  if not contributionsEth[caller]:\n                      require stor10 > 0\n                      require stor10\n                      require 0 / stor10 >= 0 / stor10\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                          else:\n                              if not _amount:\n                                  if _amount:\n                                      require 4 * _amount / _amount == 4\n                              else:\n                                  require 6 * _amount / _amount == 6\n                                  if _amount:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          if not _amount:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                  else:\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                      if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                          if _amount:\n                              require 6 * _amount / _amount == 6\n          else:\n              require last6TokenDivPoints[caller] <= total6TokenDivPoints\n              if contributionsToken[caller]:\n                  require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                      if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                          if _amount:\n                              require 6 * _amount / _amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n              else:\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require 0 / stor10 >= 0\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                          else:\n                              if not _amount:\n                                  if _amount:\n                                      require 4 * _amount / _amount == 4\n                              else:\n                                  require 6 * _amount / _amount == 6\n                                  if _amount:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          if not _amount:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 2 * 0 / stor10 >= 0 / stor10\n                          if 2 * 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                              else:\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 2 * 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n      else:\n          require last4EthDivPoints[caller] <= total4EthDivPoints\n          if contributionsEth[caller]:\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n              require stor10 > 0\n              require stor10\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n              else:\n                  if not stor7[caller]:\n                      if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                      else:\n                          call caller with:\n                             value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          if not _amount:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n          else:\n              require stor10 > 0\n              require stor10\n              require 0 / stor10 >= 0 / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 <= 0:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                          else:\n                              if not _amount:\n                                  if _amount:\n                                      require 4 * _amount / _amount == 4\n                              else:\n                                  require 6 * _amount / _amount == 6\n                                  if _amount:\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          if _amount:\n                              require 89 * _amount / _amount == 89\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                          else:\n                              if _amount:\n                                  require 6 * _amount / _amount == 6\n                              else:\n                                  if _amount:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if _amount:\n                                      require 89 * _amount / _amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              if _amount:\n                                  require 89 * _amount / _amount == 89\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef _fallback(?) payable: # default function\n  require not ext_code.size(caller)\n  if stor7[caller]:\n      require last6EthDivPoints[caller] <= total6EthDivPoints\n      if contributionsToken[caller]:\n          require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6EthDivPoints - last6EthDivPoints[caller]\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if not contributionsEth[caller]:\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require 0 / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n              else:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          else:\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n          else:\n              require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require call.value > 0\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n              else:\n                  if not stor7[caller]:\n                      if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                      else:\n                          call caller with:\n                             value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if not call.value:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require call.value > 0\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n      else:\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if contributionsEth[caller]:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require 0 / stor10 >= 0\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n              else:\n                  require stor10 > 0\n                  require stor10\n                  require 2 * 0 / stor10 >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              else:\n                                  require stor10 > 0\n                          else:\n                              require 0 / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                  else:\n                      if not stor7[caller]:\n                          if 2 * 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 2 * 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n          else:\n              require 0 / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require call.value > 0\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                          else:\n                              if not call.value:\n                                  if call.value:\n                                      require 4 * call.value / call.value == 4\n                              else:\n                                  require 6 * call.value / call.value == 6\n                                  if call.value:\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require call.value > 0\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n  else:\n      if not stor7[caller]:\n          if not stor7[caller]:\n              if not stor7[caller]:\n                  last6EthDivPoints[caller] = total6EthDivPoints\n                  last4EthDivPoints[caller] = total4EthDivPoints\n                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                  log DividendsTransferred(\n                        address to=caller,\n                        uint256 ethAmount=0,\n                        uint256 novaAmount=0)\n                  require call.value > 0\n                  if call.value:\n                      require 89 * call.value / call.value == 89\n                      if call.value:\n                          require 6 * call.value / call.value == 6\n                          if call.value:\n                              require 4 * call.value / call.value == 4\n                          else:\n                              if call.value:\n                                  require call.value / call.value == 1\n                      else:\n                          if call.value:\n                              require 4 * call.value / call.value == 4\n                          if call.value:\n                              require call.value / call.value == 1\n                  else:\n                      if call.value:\n                          require 6 * call.value / call.value == 6\n                      if call.value:\n                          require 4 * call.value / call.value == 4\n                      if call.value:\n                          require call.value / call.value == 1\n              else:\n                  require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  if not contributionsEth[caller]:\n                      require stor10 > 0\n                      require stor10\n                      require 0 / stor10 >= 0 / stor10\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                          else:\n                              if not call.value:\n                                  if call.value:\n                                      require 4 * call.value / call.value == 4\n                              else:\n                                  require 6 * call.value / call.value == 6\n                                  if call.value:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require call.value > 0\n                          if not call.value:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                  else:\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                      if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                          if call.value:\n                              require 6 * call.value / call.value == 6\n          else:\n              require last6TokenDivPoints[caller] <= total6TokenDivPoints\n              if contributionsToken[caller]:\n                  require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                      if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                          if call.value:\n                              require 6 * call.value / call.value == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require call.value > 0\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n              else:\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require 0 / stor10 >= 0\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                          else:\n                              if not call.value:\n                                  if call.value:\n                                      require 4 * call.value / call.value == 4\n                              else:\n                                  require 6 * call.value / call.value == 6\n                                  if call.value:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require call.value > 0\n                          if not call.value:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 2 * 0 / stor10 >= 0 / stor10\n                          if 2 * 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                              else:\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 2 * 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n      else:\n          require last4EthDivPoints[caller] <= total4EthDivPoints\n          if contributionsEth[caller]:\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n              require stor10 > 0\n              require stor10\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require call.value > 0\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n              else:\n                  if not stor7[caller]:\n                      if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                      else:\n                          call caller with:\n                             value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if not call.value:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require call.value > 0\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require call.value > 0\n          else:\n              require stor10 > 0\n              require stor10\n              require 0 / stor10 >= 0 / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require call.value > 0\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                          else:\n                              if not call.value:\n                                  if call.value:\n                                      require 4 * call.value / call.value == 4\n                              else:\n                                  require 6 * call.value / call.value == 6\n                                  if call.value:\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require call.value > 0\n                          if call.value:\n                              require 89 * call.value / call.value == 89\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                          else:\n                              if call.value:\n                                  require 6 * call.value / call.value == 6\n                              else:\n                                  if call.value:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require call.value > 0\n                                  if call.value:\n                                      require 89 * call.value / call.value == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require call.value > 0\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n                              else:\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require call.value > 0\n                              if call.value:\n                                  require 89 * call.value / call.value == 89\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef withdrawTokens(uint256 amount, address randomAddr, uint256 randomTicket): # not payable\n  if stor7[caller]:\n      require last6EthDivPoints[caller] <= total6EthDivPoints\n      if contributionsToken[caller]:\n          require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6EthDivPoints - last6EthDivPoints[caller]\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if contributionsEth[caller]:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          else:\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n              else:\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require 0 / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n          else:\n              require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n              else:\n                  if not stor7[caller]:\n                      if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                      else:\n                          call caller with:\n                             value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                          if amount:\n                              require 6 * amount / amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n      else:\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if contributionsEth[caller]:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require 0 / stor10 >= 0\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n              else:\n                  require stor10 > 0\n                  require stor10\n                  require 2 * 0 / stor10 >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              else:\n                                  require stor10 > 0\n                          else:\n                              require 0 / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                  else:\n                      if not stor7[caller]:\n                          if 2 * 0 / stor10 > 0:\n                              call caller with:\n                                 value 2 * 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=2 * 0 / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n          else:\n              require 0 / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                                  if amount:\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n  else:\n      if not stor7[caller]:\n          if not stor7[caller]:\n              if not stor7[caller]:\n                  last6EthDivPoints[caller] = total6EthDivPoints\n                  last4EthDivPoints[caller] = total4EthDivPoints\n                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                  log DividendsTransferred(\n                        address to=caller,\n                        uint256 ethAmount=0,\n                        uint256 novaAmount=0)\n                  require amount > 0\n                  require amount <= contributionsToken[caller]\n                  if amount:\n                      require 89 * amount / amount == 89\n                      if amount:\n                          require 6 * amount / amount == 6\n                          if amount:\n                              require 4 * amount / amount == 4\n                          else:\n                      else:\n                          if amount:\n                              require 4 * amount / amount == 4\n                          else:\n                              if amount:\n                                  require amount / amount == 1\n                  else:\n                      if amount:\n                          require 6 * amount / amount == 6\n                          if amount:\n                              require 4 * amount / amount == 4\n                          else:\n                              if amount:\n                                  require amount / amount == 1\n                      else:\n                          if amount:\n                              require 4 * amount / amount == 4\n                          if amount:\n                              require amount / amount == 1\n              else:\n                  require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  if not contributionsEth[caller]:\n                      require stor10 > 0\n                      require stor10\n                      require 0 / stor10 >= 0 / stor10\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                                  if amount:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                          if amount:\n                              require 6 * amount / amount == 6\n                  else:\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                      if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n          else:\n              require last6TokenDivPoints[caller] <= total6TokenDivPoints\n              if contributionsToken[caller]:\n                  require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                      if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n              else:\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require 0 / stor10 >= 0\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                                  if amount:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                          if amount:\n                              require 6 * amount / amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 2 * 0 / stor10 >= 0 / stor10\n                          if 2 * 0 / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 2 * 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=2 * 0 / stor10)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n      else:\n          require last4EthDivPoints[caller] <= total4EthDivPoints\n          if contributionsEth[caller]:\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n              require stor10 > 0\n              require stor10\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n              else:\n                  if not stor7[caller]:\n                      if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                      else:\n                          call caller with:\n                             value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                          if amount:\n                              require 6 * amount / amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n          else:\n              require stor10 > 0\n              require stor10\n              require 0 / stor10 >= 0 / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if amount:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                                  if amount:\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require amount > 0\n                          require amount <= contributionsToken[caller]\n                          if not amount:\n                              if amount:\n                                  require 6 * amount / amount == 6\n                              else:\n                          else:\n                              require 89 * amount / amount == 89\n                              if amount:\n                                  require 6 * amount / amount == 6\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require amount > 0\n                              require amount <= contributionsToken[caller]\n                              if amount:\n                                  require 89 * amount / amount == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n                                  if amount:\n                                      require 89 * amount / amount == 89\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require amount > 0\n                                  require amount <= contributionsToken[caller]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef withdrawDivs(): # not payable\n  if not stor7[caller]:\n      if not stor7[caller]:\n          if not stor7[caller]:\n              if not stor7[caller]:\n                  last6EthDivPoints[caller] = total6EthDivPoints\n                  last4EthDivPoints[caller] = total4EthDivPoints\n                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                  log DividendsTransferred(\n                        address to=caller,\n                        uint256 ethAmount=0,\n                        uint256 novaAmount=0)\n              else:\n                  require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  if not contributionsEth[caller]:\n                      require stor10 > 0\n                      require stor10\n                      require 0 / stor10 >= 0 / stor10\n                      if 0 / stor10 > 0:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=0,\n                            uint256 novaAmount=0 / stor10)\n                  else:\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                      if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=0,\n                            uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n          else:\n              require last6TokenDivPoints[caller] <= total6TokenDivPoints\n              if not contributionsToken[caller]:\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require 0 / stor10 >= 0\n                      if 0 / stor10 > 0:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=0,\n                            uint256 novaAmount=0 / stor10)\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 2 * 0 / stor10 >= 0 / stor10\n                          if 2 * 0 / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 2 * 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n              else:\n                  require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                      if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=0,\n                            uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n      else:\n          require last4EthDivPoints[caller] <= total4EthDivPoints\n          if not contributionsEth[caller]:\n              require stor10 > 0\n              require stor10\n              require 0 / stor10 >= 0 / stor10\n              if not stor7[caller]:\n                  if not stor7[caller]:\n                      if 0 / stor10 > 0:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=0 / stor10,\n                            uint256 novaAmount=0)\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n              else:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if not contributionsToken[caller]:\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 2 * 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 2 * 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                  else:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n          else:\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n              require stor10 > 0\n              require stor10\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n              if not stor7[caller]:\n                  if not stor7[caller]:\n                      if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                          call caller with:\n                             value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                            uint256 novaAmount=0)\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n              else:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if not contributionsToken[caller]:\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require 0 / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 2 * 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 2 * 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                  else:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n  else:\n      require last6EthDivPoints[caller] <= total6EthDivPoints\n      if not contributionsToken[caller]:\n          require stor10 > 0\n          require stor10\n          if not stor7[caller]:\n              require 0 / stor10 >= 0\n              if not stor7[caller]:\n                  if not stor7[caller]:\n                      if 0 / stor10 > 0:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=0 / stor10,\n                            uint256 novaAmount=0)\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n              else:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if not contributionsToken[caller]:\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 2 * 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 2 * 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                  else:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 > 0:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n          else:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if not contributionsEth[caller]:\n                  require stor10 > 0\n                  require stor10\n                  require 2 * 0 / stor10 >= 0 / stor10\n                  if not stor7[caller]:\n                      if not stor7[caller]:\n                          if 2 * 0 / stor10 > 0:\n                              call caller with:\n                                 value 2 * 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=2 * 0 / stor10,\n                                uint256 novaAmount=0)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                  else:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if not contributionsToken[caller]:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require 2 * 0 / stor10 >= 0 / stor10\n                                  if 2 * 0 / stor10 > 0:\n                                      call caller with:\n                                         value 2 * 0 / stor10 wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      if 2 * 0 / stor10 > 0:\n                                          require ext_code.size(stor1)\n                                          call stor1.transfer(address recipient, uint256 amount) with:\n                                               gas gas_remaining wei\n                                              args caller, 2 * 0 / stor10\n                                          if not ext_call.success:\n                                              revert with ext_call.return_data[0 len return_data.size]\n                                          require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=2 * 0 / stor10,\n                                        uint256 novaAmount=2 * 0 / stor10)\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if 2 * 0 / stor10 > 0:\n                                      call caller with:\n                                         value 2 * 0 / stor10 wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=2 * 0 / stor10,\n                                        uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                                  if 2 * 0 / stor10 > 0:\n                                      call caller with:\n                                         value 2 * 0 / stor10 wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=2 * 0 / stor10,\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if 2 * 0 / stor10 > 0:\n                                      call caller with:\n                                         value 2 * 0 / stor10 wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=2 * 0 / stor10,\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n              else:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if not stor7[caller]:\n                      if not stor7[caller]:\n                          if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                  else:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if not contributionsToken[caller]:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require 2 * 0 / stor10 >= 0 / stor10\n                                  if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=2 * 0 / stor10)\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                                  if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n      else:\n          require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6EthDivPoints - last6EthDivPoints[caller]\n          require stor10 > 0\n          require stor10\n          if not stor7[caller]:\n              require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n              if not stor7[caller]:\n                  if not stor7[caller]:\n                      if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                          call caller with:\n                             value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                      last6EthDivPoints[caller] = total6EthDivPoints\n                      last4EthDivPoints[caller] = total4EthDivPoints\n                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                      log DividendsTransferred(\n                            address to=caller,\n                            uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                            uint256 novaAmount=0)\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if not contributionsEth[caller]:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n              else:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if not contributionsToken[caller]:\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require 0 / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if 0 / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0 / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 2 * 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 2 * 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                  else:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if not stor7[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n          else:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if not contributionsEth[caller]:\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                  if not stor7[caller]:\n                      if not stor7[caller]:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                uint256 novaAmount=0)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                  else:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if not contributionsToken[caller]:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require 2 * 0 / stor10 >= 0 / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                        uint256 novaAmount=2 * 0 / stor10)\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                        uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n              else:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if not stor7[caller]:\n                      if not stor7[caller]:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                      else:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if not contributionsEth[caller]:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                  else:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if not contributionsToken[caller]:\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require 0 / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0 / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require 2 * 0 / stor10 >= 0 / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=2 * 0 / stor10)\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              else:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                                  require stor10 > 0\n                                  require stor10\n                                  require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      call caller with:\n                                         value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                           gas 2300 * is_zero(value) wei\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                        uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n\ndef depositTokens(address wallet_, uint256 amount_): # not payable\n  if stor7[caller]:\n      require last6EthDivPoints[caller] <= total6EthDivPoints\n      if contributionsToken[caller]:\n          require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6EthDivPoints - last6EthDivPoints[caller]\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if contributionsEth[caller]:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if not stor7[caller]:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          else:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require 0 / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                          else:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                    uint256 novaAmount=0)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n              else:\n                  require stor10 > 0\n                  require stor10\n                  require ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              else:\n                                  require stor10 > 0\n                          else:\n                              require 0 / stor10 >= 0\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                            uint256 novaAmount=0 / stor10)\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                  call caller with:\n                                     value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                            uint256 novaAmount=0 / stor10)\n                      else:\n                          if ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                              call caller with:\n                                 value ((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=((total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10),\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n          else:\n              require (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          else:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n              else:\n                  if not stor7[caller]:\n                      if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if not ext_call.return_data[0]:\n                              if ext_call.return_data[0]:\n                                  require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          else:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                              if ext_call.return_data[0]:\n                      else:\n                          call caller with:\n                             value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              if ext_call.return_data[0]:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          else:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value (total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total6EthDivPoints * contributionsToken[caller]) - (last6EthDivPoints[caller] * contributionsToken[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n      else:\n          require stor10 > 0\n          require stor10\n          if stor7[caller]:\n              require last4EthDivPoints[caller] <= total4EthDivPoints\n              if contributionsEth[caller]:\n                  require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  require (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          else:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              else:\n                                  require stor10 > 0\n                          else:\n                              require 0 / stor10 >= 0\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                            uint256 novaAmount=0 / stor10)\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                  call caller with:\n                                     value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                            uint256 novaAmount=0 / stor10)\n                      else:\n                          if (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                              call caller with:\n                                 value (0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10) wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(0 / stor10) + ((total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10),\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n              else:\n                  require stor10 > 0\n                  require stor10\n                  require 2 * 0 / stor10 >= 0 / stor10\n                  if stor7[caller]:\n                      require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                      if contributionsToken[caller]:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if contributionsEth[caller]:\n                                  require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              else:\n                                  require stor10 > 0\n                          else:\n                              require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          if stor7[caller]:\n                              require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                              if not contributionsEth[caller]:\n                                  require stor10 > 0\n                                  require stor10\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                          else:\n                              require 0 / stor10 >= 0\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                                      require ext_code.size(stor1)\n                                      call stor1.allowance(address owner, address spender) with:\n                                           gas gas_remaining wei\n                                          args caller, this.address\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                  else:\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 0 / stor10 >= 0 / stor10\n                              if 2 * 0 / stor10 > 0:\n                                  call caller with:\n                                     value 2 * 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                              else:\n                                  if 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=2 * 0 / stor10,\n                                            uint256 novaAmount=0 / stor10)\n                                      require ext_code.size(stor1)\n                                      call stor1.allowance(address owner, address spender) with:\n                                           gas gas_remaining wei\n                                          args caller, this.address\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                      else:\n                          if 2 * 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                              if ext_call.return_data[0]:\n                                  require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              call caller with:\n                                 value 2 * 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=2 * 0 / stor10,\n                                    uint256 novaAmount=0)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n          else:\n              require 0 / stor10 >= 0\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                                      require ext_code.size(stor1)\n                                      call stor1.allowance(address owner, address spender) with:\n                                           gas gas_remaining wei\n                                          args caller, this.address\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                              if ext_call.return_data[0]:\n                                  require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          if ext_call.return_data[0]:\n                              require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if not ext_call.return_data[0]:\n                              if ext_call.return_data[0]:\n                                  require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          else:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                              if ext_call.return_data[0]:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                              if ext_call.return_data[0]:\n                                  require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n  else:\n      if not stor7[caller]:\n          if not stor7[caller]:\n              if not stor7[caller]:\n                  last6EthDivPoints[caller] = total6EthDivPoints\n                  last4EthDivPoints[caller] = total4EthDivPoints\n                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                  log DividendsTransferred(\n                        address to=caller,\n                        uint256 ethAmount=0,\n                        uint256 novaAmount=0)\n                  require ext_code.size(stor1)\n                  call stor1.allowance(address owner, address spender) with:\n                       gas gas_remaining wei\n                      args caller, this.address\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require ext_call.return_data[0] > 0\n                  require ext_code.size(stor1)\n                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, this.address, ext_call.return_data[0]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require ext_call.return_data[0]\n                  if not ext_call.return_data[0]:\n                      if not ext_call.return_data[0]:\n                          if ext_call.return_data[0]:\n                              require 4 * ext_call.return_data[0] / ext_call.return_data[0] == 4\n                          else:\n                      else:\n                          require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          if ext_call.return_data[0]:\n                              require 4 * ext_call.return_data[0] / ext_call.return_data[0] == 4\n                  else:\n                      require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                      if ext_call.return_data[0]:\n                          require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                      if ext_call.return_data[0]:\n                          require 4 * ext_call.return_data[0] / ext_call.return_data[0] == 4\n              else:\n                  require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                  if contributionsEth[caller]:\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                      if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if not ext_call.return_data[0]:\n                              if ext_call.return_data[0]:\n                                  require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          else:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                              if ext_call.return_data[0]:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      require 0 / stor10 >= 0 / stor10\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          if ext_call.return_data[0]:\n                              require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              if ext_call.return_data[0]:\n          else:\n              require last6TokenDivPoints[caller] <= total6TokenDivPoints\n              if contributionsToken[caller]:\n                  require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                      if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if not ext_call.return_data[0]:\n                              if ext_call.return_data[0]:\n                                  require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          else:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                              if ext_call.return_data[0]:\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                          if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n              else:\n                  require stor10 > 0\n                  require stor10\n                  if not stor7[caller]:\n                      require 0 / stor10 >= 0\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          if ext_call.return_data[0]:\n                              require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                      else:\n                          require ext_code.size(stor1)\n                          call stor1.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / stor10\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0,\n                                uint256 novaAmount=0 / stor10)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              if ext_call.return_data[0]:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 2 * 0 / stor10 >= 0 / stor10\n                          if 2 * 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                              if ext_call.return_data[0]:\n                                  require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              require ext_code.size(stor1)\n                              call stor1.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 2 * 0 / stor10\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0,\n                                    uint256 novaAmount=2 * 0 / stor10)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n      else:\n          require last4EthDivPoints[caller] <= total4EthDivPoints\n          if contributionsEth[caller]:\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4EthDivPoints - last4EthDivPoints[caller]\n              require stor10 > 0\n              require stor10\n              require (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          else:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                                  call caller with:\n                                     value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                      else:\n                          require 0 / stor10 >= 0\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n              else:\n                  if not stor7[caller]:\n                      if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if not ext_call.return_data[0]:\n                              if ext_call.return_data[0]:\n                                  require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          else:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                              if ext_call.return_data[0]:\n                      else:\n                          call caller with:\n                             value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              if ext_call.return_data[0]:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 > 0:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                          else:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value (total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=(total4EthDivPoints * contributionsEth[caller]) - (last4EthDivPoints[caller] * contributionsEth[caller]) / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n          else:\n              require stor10 > 0\n              require stor10\n              require 0 / stor10 >= 0 / stor10\n              if stor7[caller]:\n                  require last6TokenDivPoints[caller] <= total6TokenDivPoints\n                  if contributionsToken[caller]:\n                      require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / contributionsToken[caller] == total6TokenDivPoints - last6TokenDivPoints[caller]\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, ((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10)\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=((total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10) + (0 / stor10))\n                      else:\n                          require (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total6TokenDivPoints * contributionsToken[caller]) - (last6TokenDivPoints[caller] * contributionsToken[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                  else:\n                      require stor10 > 0\n                      require stor10\n                      if stor7[caller]:\n                          require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                          if contributionsEth[caller]:\n                              require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                              require stor10 > 0\n                              require stor10\n                              require (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                              else:\n                                  if (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10) > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, (0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=(0 / stor10) + ((total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10))\n                          else:\n                              require stor10 > 0\n                              require stor10\n                              require 2 * 0 / stor10 >= 0 / stor10\n                              if 0 / stor10 > 0:\n                                  call caller with:\n                                     value 0 / stor10 wei\n                                       gas 2300 * is_zero(value) wei\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                              else:\n                                  if 2 * 0 / stor10 > 0:\n                                      require ext_code.size(stor1)\n                                      call stor1.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args caller, 2 * 0 / stor10\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                  else:\n                                      last6EthDivPoints[caller] = total6EthDivPoints\n                                      last4EthDivPoints[caller] = total4EthDivPoints\n                                      last6TokenDivPoints[caller] = total6TokenDivPoints\n                                      last4TokenDivPoints[caller] = total4TokenDivPoints\n                                      log DividendsTransferred(\n                                            address to=caller,\n                                            uint256 ethAmount=0 / stor10,\n                                            uint256 novaAmount=2 * 0 / stor10)\n                                      require ext_code.size(stor1)\n                                      call stor1.allowance(address owner, address spender) with:\n                                           gas gas_remaining wei\n                                          args caller, this.address\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                      else:\n                          require 0 / stor10 >= 0\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                              if ext_call.return_data[0]:\n                                  require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n              else:\n                  if not stor7[caller]:\n                      if 0 / stor10 <= 0:\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if ext_call.return_data[0]:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          if ext_call.return_data[0]:\n                              require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                      else:\n                          call caller with:\n                             value 0 / stor10 wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          last6EthDivPoints[caller] = total6EthDivPoints\n                          last4EthDivPoints[caller] = total4EthDivPoints\n                          last6TokenDivPoints[caller] = total6TokenDivPoints\n                          last4TokenDivPoints[caller] = total4TokenDivPoints\n                          log DividendsTransferred(\n                                address to=caller,\n                                uint256 ethAmount=0 / stor10,\n                                uint256 novaAmount=0)\n                          require ext_code.size(stor1)\n                          call stor1.allowance(address owner, address spender) with:\n                               gas gas_remaining wei\n                              args caller, this.address\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0] > 0\n                          require ext_code.size(stor1)\n                          call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, this.address, ext_call.return_data[0]\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require ext_call.return_data[0]\n                          if not ext_call.return_data[0]:\n                              if ext_call.return_data[0]:\n                                  require 6 * ext_call.return_data[0] / ext_call.return_data[0] == 6\n                          else:\n                              require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                              if ext_call.return_data[0]:\n                  else:\n                      require last4TokenDivPoints[caller] <= total4TokenDivPoints\n                      if contributionsEth[caller]:\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / contributionsEth[caller] == total4TokenDivPoints - last4TokenDivPoints[caller]\n                          require stor10 > 0\n                          require stor10\n                          require (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 >= (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                          if 0 / stor10 <= 0:\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, (total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=(total4TokenDivPoints * contributionsEth[caller]) - (last4TokenDivPoints[caller] * contributionsEth[caller]) / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                      else:\n                          require stor10 > 0\n                          require stor10\n                          require 0 / stor10 >= 0 / stor10\n                          if 0 / stor10 <= 0:\n                              last6EthDivPoints[caller] = total6EthDivPoints\n                              last4EthDivPoints[caller] = total4EthDivPoints\n                              last6TokenDivPoints[caller] = total6TokenDivPoints\n                              last4TokenDivPoints[caller] = total4TokenDivPoints\n                              log DividendsTransferred(\n                                    address to=caller,\n                                    uint256 ethAmount=0 / stor10,\n                                    uint256 novaAmount=0 / stor10)\n                              require ext_code.size(stor1)\n                              call stor1.allowance(address owner, address spender) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0] > 0\n                              require ext_code.size(stor1)\n                              call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, this.address, ext_call.return_data[0]\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require ext_call.return_data[0]\n                              if ext_call.return_data[0]:\n                                  require 89 * ext_call.return_data[0] / ext_call.return_data[0] == 89\n                          else:\n                              call caller with:\n                                 value 0 / stor10 wei\n                                   gas 2300 * is_zero(value) wei\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              if 0 / stor10 <= 0:\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0]\n                              else:\n                                  require ext_code.size(stor1)\n                                  call stor1.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, 0 / stor10\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  last6EthDivPoints[caller] = total6EthDivPoints\n                                  last4EthDivPoints[caller] = total4EthDivPoints\n                                  last6TokenDivPoints[caller] = total6TokenDivPoints\n                                  last4TokenDivPoints[caller] = total4TokenDivPoints\n                                  log DividendsTransferred(\n                                        address to=caller,\n                                        uint256 ethAmount=0 / stor10,\n                                        uint256 novaAmount=0 / stor10)\n                                  require ext_code.size(stor1)\n                                  call stor1.allowance(address owner, address spender) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n                                  require ext_call.return_data[0] > 0\n                                  require ext_code.size(stor1)\n                                  call stor1.transferFrom(address sender, address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args caller, this.address, ext_call.return_data[0]\n                                  if not ext_call.success:\n                                      revert with ext_call.return_data[0 len return_data.size]\n                                  require return_data.size >= 32\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 160979 tokens. Please reduce the length of the messages."
}