{
	"address": "0xe56b4d8d42b1c9ea7dda8a6950e3699755943de7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.14 21:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _orgName; // STORAGE[0x1]\nuint256 _isOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 _nativeToken; // STORAGE[0x2] bytes 0 to 19\nuint256 _nativeReputation; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nReceiveEther(address, uint256);\nGenericCall(address, bytes, uint256, bool);\nOwnershipTransferred(address, address);\nMetaData(string);\nExternalTokenApproval(address, address, uint256);\nExternalTokenTransferFrom(address, address, address, uint256);\nSendEther(uint256, address);\nExternalTokenTransfer(address, address, uint256);\n\nfunction genericCall(address varg0, bytes varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg1.length > 0x100000000) | (36 + varg1 + varg1.length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v0[varg1.length] = 0;\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    v1 = v2 = v2.data;\n    v3 = v4 = v0.length;\n    v5 = v6 = v0.data;\n    while (v3 >= 32) {\n        MEM[v1] = MEM[v5];\n        v3 = v3 + ~31;\n        v1 += 32;\n        v5 += 32;\n    }\n    MEM[v1] = MEM[v5] & ~(256 ** (32 - v3) - 1) | MEM[v1] & 256 ** (32 - v3) - 1;\n    v7, v8, v9 = varg0.call(v2.data).value(varg2).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v10 = v11 = 96;\n    } else {\n        v10 = v12 = new bytes[](RETURNDATASIZE());\n        v9 = v12.data;\n        RETURNDATACOPY(v9, 0, RETURNDATASIZE());\n    }\n    v13 = new array[](v0.length);\n    v14 = v15 = 0;\n    while (v14 < v0.length) {\n        v13[v14] = v0[v14];\n        v14 += 32;\n    }\n    v16 = v17 = v0.length + v13.data;\n    if (0x1f & v0.length) {\n        MEM[v17 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v17 - (0x1f & v0.length)];\n    }\n    emit GenericCall(varg0, v13, varg2, v7);\n    v18 = new array[](MEM[v10]);\n    v19 = v20 = 0;\n    while (v19 < MEM[v10]) {\n        v18[v19] = MEM[v19 + (32 + v10)];\n        v19 += 32;\n    }\n    v21 = v22 = MEM[v10] + v18.data;\n    if (0x1f & MEM[v10]) {\n        MEM[v22 - (0x1f & MEM[v10])] = ~(256 ** (32 - (0x1f & MEM[v10])) - 1) & MEM[v22 - (0x1f & MEM[v10])];\n    }\n    return v7, v18, v23, v0.length;\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction metaData(string varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    emit MetaData(v1);\n    return 1;\n}\n\nfunction nativeReputation() public nonPayable { \n    return _nativeReputation;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction externalTokenApproval(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    require(varg0.code.size);\n    v0 = v1 = !varg2;\n    if (varg2) {\n        require(varg0.code.size);\n        v2, v3 = varg0.allowance(this, varg1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        v4 = 'approve(address,uint256)';\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4.length;\n        v0 = !v3;\n    }\n    require(v0);\n    v5 = v6 = MEM[64] + 32;\n    v7 = v8 = MEM[64];\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v5];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v5 += 32;\n    }\n    MEM[v7] = MEM[v5] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n    v10, v11 = varg0.approve(varg1, varg2).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = 96;\n    } else {\n        v12 = v13 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v13.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    v14 = !MEM[v12];\n    if (MEM[v12]) {\n        v14 = v15 = 32 == MEM[v12];\n        if (v15) {\n            assert(31 < MEM[v12]);\n            v14 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[63 + v12];\n        }\n    }\n    require(v14);\n    emit ExternalTokenApproval(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction externalTokenTransferFrom(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    require(varg0.code.size);\n    MEM[64] = MEM[64] + 132;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = varg0.call(keccak256(MEM[(v7.data) len (v7.length)]) & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1, keccak256(MEM[(v7.data) len (v7.length)]) & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1, varg2, varg3).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v8 = v9 = 96;\n    } else {\n        v8 = v10 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v10.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n    v11 = v12 = !MEM[v8];\n    if (MEM[v8]) {\n        v11 = 32 == MEM[v8];\n        if (v11) {\n            assert(31 < MEM[v8]);\n            v11 = v13 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[63 + v8];\n        }\n    }\n    require(v11);\n    emit ExternalTokenTransferFrom(varg0, varg1, varg2, varg3);\n    return 1;\n}\n\nfunction sendEther(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    v0 = varg1.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n    emit SendEther(varg1, varg0);\n    return 1;\n}\n\nfunction externalTokenTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    require(varg0.code.size);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = varg0.call(0xa9059cbb00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg1, v11, varg2).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = 96;\n    } else {\n        v12 = v13 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v13.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n    v14 = !MEM[v12];\n    if (MEM[v12]) {\n        v14 = v15 = 32 == MEM[v12];\n        if (v15) {\n            assert(31 < MEM[v12]);\n            v14 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[63 + v12];\n        }\n    }\n    require(v14);\n    emit ExternalTokenTransfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction nativeToken() public nonPayable { \n    return _nativeToken;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction () public payable { \n    emit ReceiveEther(msg.sender, msg.value);\n}\n\nfunction orgName() public nonPayable { \n    v0 = new bytes[]((_orgName.length & ~0 + (!(0x1 & _orgName.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_orgName.length & ~0 + (!(0x1 & _orgName.length) << 8)) >> 1) {\n        if (31 < (_orgName.length & ~0 + (!(0x1 & _orgName.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_orgName.length & ~0 + (!(0x1 & _orgName.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _orgName.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8f32d59b > function_selector >> 224) {\n            if (0x1386dc2d == function_selector >> 224) {\n                orgName();\n            } else if (0x2bf16458 == function_selector >> 224) {\n                genericCall(address,bytes,uint256);\n            } else if (0x715018a6 == function_selector >> 224) {\n                renounceOwnership();\n            } else if (0x890ac46c == function_selector >> 224) {\n                metaData(string);\n            } else if (0x89ae1c90 == function_selector >> 224) {\n                nativeReputation();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            }\n        } else if (0xcb16d4a2 > function_selector >> 224) {\n            if (0x8f32d59b == function_selector >> 224) {\n                isOwner();\n            } else if (0xab751f71 == function_selector >> 224) {\n                externalTokenApproval(address,address,uint256);\n            } else if (0xb756d5a2 == function_selector >> 224) {\n                externalTokenTransferFrom(address,address,address,uint256);\n            }\n        } else if (0xcb16d4a2 == function_selector >> 224) {\n            sendEther(uint256,address);\n        } else if (0xdab0efff == function_selector >> 224) {\n            externalTokenTransfer(address,address,uint256);\n        } else if (0xe1758bd8 == function_selector >> 224) {\n            nativeToken();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}