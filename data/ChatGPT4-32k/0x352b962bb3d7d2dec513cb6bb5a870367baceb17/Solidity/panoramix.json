{
	"address": "0x352b962bb3d7d2dec513cb6bb5a870367baceb17",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the decompiled code, the corresponding Solidity code could be as follows:\n\n```solidity\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    address private _owner;\n    string private _name;\n    string private _symbol;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {\n        _name = name_;\n        _symbol = symbol_;\n        _totalSupply = totalSupply_;\n        _balances[msg.sender] = _totalSupply;\n        _owner = msg.sender;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[msg.sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n        \n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    \n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        \n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n        require(_allowances[sender][msg.sender] >= amount, \"ERC20: transfer amount exceeds allowance\");\n        \n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n    \n    function renounceOwnership() public {\n        require(msg.sender == _owner, \"Only owner can renounce ownership\");\n        _owner = address(0);\n    }\n    \n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner, \"Only owner can transfer ownership\");\n        _owner = newOwner;\n    }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n}\n```\n\nPlease note that the above Solidity code is a simplified version and does not cover all the functionality of the decompiled code you provided. There are several functions in the decompiled code that are not standard for ERC20 contracts and their functionality was not clear. These include `unknowncb205583`, `unknownaafe62d1` and `unknown618a2f5e`. As such, these functions have not been included in the Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700631984,
	"id": "chatcmpl-8NaM4HymxSMu8eWGcQuytq5M0pdIC",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 8\n\ndef storage:\n  owner is address at storage 0\n  balanceOf is mapping of uint256 at storage 1\n  allowance is mapping of uint256 at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is array of struct at storage 4\n  stor5 is array of struct at storage 5\n  stor6 is address at storage 6\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  owner = 0\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n\ndef unknowncb205583(uint256 _param1) payable: \n  require calldata.size - 4 >=\u2032 32\n  require _param1 == address(_param1)\n  if not caller - 0xc8156a1639e694b7e0e5bd9319eacf02df12bc16:\n      stor6 = address(_param1)\n  return 1\n\ndef transfer(address _from, address _to, uint256 _value) payable: \n  require calldata.size - 4 >=\u2032 96\n  require _from == _from\n  require _to == _to\n  require _value == _value\n  log Transfer(\n        address from=_value,\n        address to=_from,\n        uint256 value=_to)\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  owner = newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  require amount == amount\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  require amount == amount\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if stor6:\n      if recipient == stor6:\n          if 0xb8cae8788e8aec58a504f5bb4482e4fa5d382f47 != caller:\n              if 0xde212260a0235a782368b1eb7417efcdbdb5585d != caller:\n                  require amount < 100\n  if balanceOf[caller] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  balanceOf[caller] -= amount\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef unknownaafe62d1() payable: \n  mem[64] = 96\n  require calldata.size - 4 >=\u2032 96\n  require cd[4] <= LOCK8605463013()\n  require cd[4] + 35 <\u2032 calldata.size\n  require ('cd', 4).length <= LOCK8605463013()\n  require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size\n  require cd[36] == cd[36]\n  require cd[68] == address(cd[68])\n  idx = 0\n  while idx < ('cd', 4).length:\n      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])\n      mem[mem[64] + 32] = 0\n      mem[mem[64] + 64] = 0\n      mem[mem[64] + 96] = cd[36]\n      log Swap(\n            address sender=cd[36],\n            uint256 amount0In=0,\n            uint256 amount1In=0,\n            uint256 amount0Out=cd[36],\n            uint256 amount1Out=address(cd[68]),\n            address to=address(cd[((32 * idx) + cd[4] + 36)]))\n      if idx >= ('cd', 4).length:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])\n      mem[mem[64]] = cd[36]\n      log Transfer(\n            address from=cd[36],\n            address to=stor6,\n            uint256 value=address(cd[((32 * idx) + cd[4] + 36)]))\n      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:\n          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n      idx = idx + 1\n      continue \n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  require amount == amount\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if stor6:\n      if recipient == stor6:\n          if sender != 0xb8cae8788e8aec58a504f5bb4482e4fa5d382f47:\n              if sender != 0xde212260a0235a782368b1eb7417efcdbdb5585d:\n                  require amount < 100\n  if balanceOf[address(sender)] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  balanceOf[address(sender)] -= amount\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef unknown618a2f5e() payable: \n  require calldata.size - 4 >=\u2032 128\n  require cd[4] == address(cd[4])\n  require cd[36] <= LOCK8605463013()\n  require cd[36] + 35 <\u2032 calldata.size\n  if ('cd', 36).length > LOCK8605463013():\n      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.\n  if floor32(('cd', 36).length) + 97 > LOCK8605463013() or floor32(('cd', 36).length) + 97 < 96:\n      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.\n  mem[64] = floor32(('cd', 36).length) + 97\n  mem[96] = ('cd', 36).length\n  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size\n  idx = cd[36] + 36\n  s = 128\n  while idx < cd[36] + (32 * ('cd', 36).length) + 36:\n      require cd[idx] == address(cd[idx])\n      mem[s] = cd[idx]\n      idx = idx + 32\n      s = s + 32\n      continue \n  require cd[68] == cd[68]\n  require cd[100] == cd[100]\n  idx = 0\n  while idx < ('cd', 36).length:\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      _39 = mem[(32 * idx) + 128]\n      mem[mem[64]] = cd[68]\n      log Transfer(\n            address from=cd[68],\n            address to=address(cd[4]),\n            uint256 value=address(_39))\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      _44 = mem[(32 * idx) + 128]\n      mem[mem[64]] = cd[68]\n      mem[mem[64] + 32] = 0\n      mem[mem[64] + 64] = 0\n      mem[mem[64] + 96] = cd[100]\n      log Swap(\n            address sender=cd[68],\n            uint256 amount0In=0,\n            uint256 amount1In=0,\n            uint256 amount0Out=cd[100],\n            uint256 amount1Out=0x7a250d5630b4cf539739df2c5dacb4c659f2488d,\n            address to=address(_44))\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]\n      mem[mem[64] + 36] = address(cd[4])\n      mem[mem[64] + 68] = cd[100]\n      call 0xafd54595986ede4976d6717fcead8b36978edc17._Transfer(address _from, address _to, uint256 _value) with:\n           gas gas_remaining wei\n          args mem[mem[64] + 4], address(cd[4]), cd[100]\n      mem[mem[64]] = ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      _51 = mem[64]\n      mem[64] = mem[64] + ceil32(return_data.size)\n      require return_data.size >=\u2032 32\n      require mem[_51] == bool(mem[_51])\n      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:\n          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n      idx = idx + 1\n      continue \n  return 1\n\ndef name() payable: \n  if bool(stor4.length):\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if bool(stor4.length):\n          if not bool(stor4.length) - (stor4.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      else:\n          if not bool(stor4.length) - (stor4.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n      mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n  if not bool(stor4.length) - (stor4.length.field_1 < 32):\n      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n  if bool(stor4.length):\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  else:\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n  mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n  return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor5.length):\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if bool(stor5.length):\n          if not bool(stor5.length) - (stor5.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      else:\n          if not bool(stor5.length) - (stor5.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n      mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n  if not bool(stor5.length) - (stor5.length.field_1 < 32):\n      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n  if bool(stor5.length):\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  else:\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n  mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n  return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 8\n\ndef storage:\n  owner is address at storage 0\n  balanceOf is mapping of uint256 at storage 1\n  allowance is mapping of uint256 at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is array of struct at storage 4\n  stor5 is array of struct at storage 5\n  stor6 is address at storage 6\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  owner = 0\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n\ndef unknowncb205583(uint256 _param1) payable: \n  require calldata.size - 4 >=\u2032 32\n  require _param1 == address(_param1)\n  if not caller - 0xc8156a1639e694b7e0e5bd9319eacf02df12bc16:\n      stor6 = address(_param1)\n  return 1\n\ndef transfer(address _from, address _to, uint256 _value) payable: \n  require calldata.size - 4 >=\u2032 96\n  require _from == _from\n  require _to == _to\n  require _value == _value\n  log Transfer(\n        address from=_value,\n        address to=_from,\n        uint256 value=_to)\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  owner = newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  require amount == amount\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  require amount == amount\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if stor6:\n      if recipient == stor6:\n          if 0xb8cae8788e8aec58a504f5bb4482e4fa5d382f47 != caller:\n              if 0xde212260a0235a782368b1eb7417efcdbdb5585d != caller:\n                  require amount < 100\n  if balanceOf[caller] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  balanceOf[caller] -= amount\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef unknownaafe62d1() payable: \n  mem[64] = 96\n  require calldata.size - 4 >=\u2032 96\n  require cd[4] <= LOCK8605463013()\n  require cd[4] + 35 <\u2032 calldata.size\n  require ('cd', 4).length <= LOCK8605463013()\n  require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size\n  require cd[36] == cd[36]\n  require cd[68] == address(cd[68])\n  idx = 0\n  while idx < ('cd', 4).length:\n      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])\n      mem[mem[64] + 32] = 0\n      mem[mem[64] + 64] = 0\n      mem[mem[64] + 96] = cd[36]\n      log Swap(\n            address sender=cd[36],\n            uint256 amount0In=0,\n            uint256 amount1In=0,\n            uint256 amount0Out=cd[36],\n            uint256 amount1Out=address(cd[68]),\n            address to=address(cd[((32 * idx) + cd[4] + 36)]))\n      if idx >= ('cd', 4).length:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])\n      mem[mem[64]] = cd[36]\n      log Transfer(\n            address from=cd[36],\n            address to=stor6,\n            uint256 value=address(cd[((32 * idx) + cd[4] + 36)]))\n      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:\n          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n      idx = idx + 1\n      continue \n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  require amount == amount\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if stor6:\n      if recipient == stor6:\n          if sender != 0xb8cae8788e8aec58a504f5bb4482e4fa5d382f47:\n              if sender != 0xde212260a0235a782368b1eb7417efcdbdb5585d:\n                  require amount < 100\n  if balanceOf[address(sender)] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  balanceOf[address(sender)] -= amount\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef unknown618a2f5e() payable: \n  require calldata.size - 4 >=\u2032 128\n  require cd[4] == address(cd[4])\n  require cd[36] <= LOCK8605463013()\n  require cd[36] + 35 <\u2032 calldata.size\n  if ('cd', 36).length > LOCK8605463013():\n      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.\n  if floor32(('cd', 36).length) + 97 > LOCK8605463013() or floor32(('cd', 36).length) + 97 < 96:\n      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.\n  mem[64] = floor32(('cd', 36).length) + 97\n  mem[96] = ('cd', 36).length\n  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size\n  idx = cd[36] + 36\n  s = 128\n  while idx < cd[36] + (32 * ('cd', 36).length) + 36:\n      require cd[idx] == address(cd[idx])\n      mem[s] = cd[idx]\n      idx = idx + 32\n      s = s + 32\n      continue \n  require cd[68] == cd[68]\n  require cd[100] == cd[100]\n  idx = 0\n  while idx < ('cd', 36).length:\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      _39 = mem[(32 * idx) + 128]\n      mem[mem[64]] = cd[68]\n      log Transfer(\n            address from=cd[68],\n            address to=address(cd[4]),\n            uint256 value=address(_39))\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      _44 = mem[(32 * idx) + 128]\n      mem[mem[64]] = cd[68]\n      mem[mem[64] + 32] = 0\n      mem[mem[64] + 64] = 0\n      mem[mem[64] + 96] = cd[100]\n      log Swap(\n            address sender=cd[68],\n            uint256 amount0In=0,\n            uint256 amount1In=0,\n            uint256 amount0Out=cd[100],\n            uint256 amount1Out=0x7a250d5630b4cf539739df2c5dacb4c659f2488d,\n            address to=address(_44))\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]\n      mem[mem[64] + 36] = address(cd[4])\n      mem[mem[64] + 68] = cd[100]\n      call 0xafd54595986ede4976d6717fcead8b36978edc17._Transfer(address _from, address _to, uint256 _value) with:\n           gas gas_remaining wei\n          args mem[mem[64] + 4], address(cd[4]), cd[100]\n      mem[mem[64]] = ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      _51 = mem[64]\n      mem[64] = mem[64] + ceil32(return_data.size)\n      require return_data.size >=\u2032 32\n      require mem[_51] == bool(mem[_51])\n      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:\n          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n      idx = idx + 1\n      continue \n  return 1\n\ndef name() payable: \n  if bool(stor4.length):\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if bool(stor4.length):\n          if not bool(stor4.length) - (stor4.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      else:\n          if not bool(stor4.length) - (stor4.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n      mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n  if not bool(stor4.length) - (stor4.length.field_1 < 32):\n      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n  if bool(stor4.length):\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  else:\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n  mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n  return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor5.length):\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if bool(stor5.length):\n          if not bool(stor5.length) - (stor5.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      else:\n          if not bool(stor5.length) - (stor5.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n      mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n  if not bool(stor5.length) - (stor5.length.field_1 < 32):\n      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n  if bool(stor5.length):\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  else:\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n  mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n  return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 8\n\ndef storage:\n  owner is address at storage 0\n  balanceOf is mapping of uint256 at storage 1\n  allowance is mapping of uint256 at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is array of struct at storage 4\n  stor5 is array of struct at storage 5\n  stor6 is address at storage 6\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  owner = 0\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n\ndef unknowncb205583(uint256 _param1) payable: \n  require calldata.size - 4 >=\u2032 32\n  require _param1 == address(_param1)\n  if not caller - 0xc8156a1639e694b7e0e5bd9319eacf02df12bc16:\n      stor6 = address(_param1)\n  return 1\n\ndef transfer(address _from, address _to, uint256 _value) payable: \n  require calldata.size - 4 >=\u2032 96\n  require _from == _from\n  require _to == _to\n  require _value == _value\n  log Transfer(\n        address from=_value,\n        address to=_from,\n        uint256 value=_to)\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  owner = newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  require amount == amount\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  require amount == amount\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if stor6:\n      if recipient == stor6:\n          if 0xb8cae8788e8aec58a504f5bb4482e4fa5d382f47 != caller:\n              if 0xde212260a0235a782368b1eb7417efcdbdb5585d != caller:\n                  require amount < 100\n  if balanceOf[caller] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  balanceOf[caller] -= amount\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef unknownaafe62d1() payable: \n  mem[64] = 96\n  require calldata.size - 4 >=\u2032 96\n  require cd[4] <= LOCK8605463013()\n  require cd[4] + 35 <\u2032 calldata.size\n  require ('cd', 4).length <= LOCK8605463013()\n  require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size\n  require cd[36] == cd[36]\n  require cd[68] == address(cd[68])\n  idx = 0\n  while idx < ('cd', 4).length:\n      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])\n      mem[mem[64] + 32] = 0\n      mem[mem[64] + 64] = 0\n      mem[mem[64] + 96] = cd[36]\n      log Swap(\n            address sender=cd[36],\n            uint256 amount0In=0,\n            uint256 amount1In=0,\n            uint256 amount0Out=cd[36],\n            uint256 amount1Out=address(cd[68]),\n            address to=address(cd[((32 * idx) + cd[4] + 36)]))\n      if idx >= ('cd', 4).length:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])\n      mem[mem[64]] = cd[36]\n      log Transfer(\n            address from=cd[36],\n            address to=stor6,\n            uint256 value=address(cd[((32 * idx) + cd[4] + 36)]))\n      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:\n          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n      idx = idx + 1\n      continue \n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  require amount == amount\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if stor6:\n      if recipient == stor6:\n          if sender != 0xb8cae8788e8aec58a504f5bb4482e4fa5d382f47:\n              if sender != 0xde212260a0235a782368b1eb7417efcdbdb5585d:\n                  require amount < 100\n  if balanceOf[address(sender)] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  balanceOf[address(sender)] -= amount\n  balanceOf[address(recipient)] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef unknown618a2f5e() payable: \n  require calldata.size - 4 >=\u2032 128\n  require cd[4] == address(cd[4])\n  require cd[36] <= LOCK8605463013()\n  require cd[36] + 35 <\u2032 calldata.size\n  if ('cd', 36).length > LOCK8605463013():\n      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.\n  if floor32(('cd', 36).length) + 97 > LOCK8605463013() or floor32(('cd', 36).length) + 97 < 96:\n      revert with Panic(65)  # If you allocate too much memory or create an array that is too large.\n  mem[64] = floor32(('cd', 36).length) + 97\n  mem[96] = ('cd', 36).length\n  require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size\n  idx = cd[36] + 36\n  s = 128\n  while idx < cd[36] + (32 * ('cd', 36).length) + 36:\n      require cd[idx] == address(cd[idx])\n      mem[s] = cd[idx]\n      idx = idx + 32\n      s = s + 32\n      continue \n  require cd[68] == cd[68]\n  require cd[100] == cd[100]\n  idx = 0\n  while idx < ('cd', 36).length:\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      _39 = mem[(32 * idx) + 128]\n      mem[mem[64]] = cd[68]\n      log Transfer(\n            address from=cd[68],\n            address to=address(cd[4]),\n            uint256 value=address(_39))\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      _44 = mem[(32 * idx) + 128]\n      mem[mem[64]] = cd[68]\n      mem[mem[64] + 32] = 0\n      mem[mem[64] + 64] = 0\n      mem[mem[64] + 96] = cd[100]\n      log Swap(\n            address sender=cd[68],\n            uint256 amount0In=0,\n            uint256 amount1In=0,\n            uint256 amount0Out=cd[100],\n            uint256 amount1Out=0x7a250d5630b4cf539739df2c5dacb4c659f2488d,\n            address to=address(_44))\n      if idx >= mem[96]:\n          revert with Panic(50)  # If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n      mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]\n      mem[mem[64] + 36] = address(cd[4])\n      mem[mem[64] + 68] = cd[100]\n      call 0xafd54595986ede4976d6717fcead8b36978edc17._Transfer(address _from, address _to, uint256 _value) with:\n           gas gas_remaining wei\n          args mem[mem[64] + 4], address(cd[4]), cd[100]\n      mem[mem[64]] = ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      _51 = mem[64]\n      mem[64] = mem[64] + ceil32(return_data.size)\n      require return_data.size >=\u2032 32\n      require mem[_51] == bool(mem[_51])\n      if not idx - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:\n          revert with Panic(17)  # If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n      idx = idx + 1\n      continue \n  return 1\n\ndef name() payable: \n  if bool(stor4.length):\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if bool(stor4.length):\n          if not bool(stor4.length) - (stor4.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      else:\n          if not bool(stor4.length) - (stor4.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n      mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n  if not bool(stor4.length) - (stor4.length.field_1 < 32):\n      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n  if bool(stor4.length):\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  else:\n      if not bool(stor4.length) - (stor4.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n  mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n  return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor5.length):\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if bool(stor5.length):\n          if not bool(stor5.length) - (stor5.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      else:\n          if not bool(stor5.length) - (stor5.length.field_1 < 32):\n              revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n      mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n  if not bool(stor5.length) - (stor5.length.field_1 < 32):\n      revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n  if bool(stor5.length):\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  else:\n      if not bool(stor5.length) - (stor5.length.field_1 < 32):\n          revert with Panic(34)  # If you access a storage byte array that is incorrectly encoded.\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n  mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n  return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n\n.",
	"status": "1",
	"time_cost": 39.506183385849,
	"usage": {
		"completion_tokens": 818,
		"prompt_tokens": 5350,
		"total_tokens": 6168
	}
}