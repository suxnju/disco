{
	"address": "0x336db6c1ead9cc4d5b0a33ac03c057e20640126a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Due to the complexity and the size of the code, I'll provide a simplified Solidity contract which represents some of the main functionalities mentioned in your decompiled EVM Bytecode. Here is a simple Solidity contract that includes functionalities like getting tank details, upgrading a tank, and transferring a tank:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TankGame {\n    struct Tank {\n        uint32 id;\n        uint32 details;\n        uint32 price;\n        address owner;\n    }\n\n    mapping(uint32 => Tank) public tanks;\n    address public upgradeMasterAddress;\n    uint32 public newIdTank = 1;\n    uint256 public upgradePrice = 5 * 10**16;\n\n    modifier onlyUpgradeMaster() {\n        require(msg.sender == upgradeMasterAddress, \"Only UpgradeMaster can call this function.\");\n        _;\n    }\n\n    function getTankDetails(uint32 _ID) public view returns (uint32, uint32, address) {\n        Tank memory tank = tanks[_ID];\n        return (tank.id, tank.details, tank.owner);\n    }\n\n    function upgradeTank(uint32 _ID) public payable onlyUpgradeMaster {\n        require(msg.value >= upgradePrice, \"Not enough Ether for upgrade.\");\n        tanks[_ID].details += 1;\n    }\n\n    function transferTank(uint32 _ID, address _receiver) public {\n        require(msg.sender == tanks[_ID].owner, \"Only owner can transfer the tank.\");\n        tanks[_ID].owner = _receiver;\n    }\n}\n```\nPlease note that this is a highly simplified version of your game and does not cover all functionalities of your original code. You may need to add more complex features like auctioning, getting tank earnings, etc. It's also essential to ensure that the game logic is secure and fair, and that it handles Ethereum transactions correctly.",
				"role": "assistant"
			}
		}
	],
	"created": 1700473264,
	"id": "chatcmpl-8Mv44JXZo7zOCebX64TFvPV59nFJb",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst upgradePrice = 5 * 10^16\nconst getContractBalance = eth.balance(this.address)\n\ndef storage:\n  upgradeMasterAddress is address at storage 0\n  auctionMasterAddress is address at storage 1\n  stor10 is mapping of uint32 at storage 10\n  stor11 is mapping of struct at storage 11\n  playerBalance is mapping of struct at storage 12\n  tankSellMasterAddress is address at storage 2\n  canExport is uint8 at storage 3 offset 160\n  stor3 is uint32 at storage 3\n  newIdTank is uint32 at storage 3 offset 168\n  howManyTanks is uint32 at storage 3 offset 200\n  stor3 is uint128 at storage 3 offset 160\n  exportMasterAddress is address at storage 3\n  stor4 is uint8 at storage 4 offset 96\n  stor4 is uint32 at storage 4 offset 104\n  newIdTankHull is uint32 at storage 4\n  newIdTankWeapon is uint32 at storage 4 offset 32\n  createNewTankHull is uint32 at storage 4 offset 64\n  createNewTankWeapon is uint32 at storage 4 offset 96\n  newIdAuctionEntity is uint256 at storage 5\n  tankDetails is mapping of struct at storage 6\n  tankName is mapping of struct at storage 7\n  stor8 is mapping of uint32 at storage 8\n\ndef getTankSell(uint32 _ID): # not payable\n  return bool(uint8(tankDetails[_ID << 224].field_928))\n\ndef getTankName(uint32 _ID): # not payable\n  return tankName[_ID << 224][0 len tankName[_ID << 224].length].field_0\n\ndef getCurrentPrice(uint32 _ID): # not payable\n  return tankName[_ID << 224].field_768\n\ndef getTankDetails(uint32 _ID): # not payable\n  return uint32(tankDetails[_ID << 224].field_0), \n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint32(tankDetails[_ID << 224].field_1536)\n\ndef newIdTankProduct(): # not payable\n  return howManyTanks\n\ndef UpgradeMaster(): # not payable\n  return upgradeMasterAddress\n\ndef newIdTank(): # not payable\n  return newIdTank\n\ndef canExport(): # not payable\n  return bool(canExport)\n\ndef getTankAuctionEntity(uint32 _ID): # not payable\n  return tankDetails[_ID << 224].field_1024\n\ndef getTankTotalEarned(uint32 _ID): # not payable\n  return tankDetails[_ID << 224].field_1280\n\ndef getTankOwner(uint32 _ID): # not payable\n  return address(tankDetails[_ID << 224].field_512)\n\ndef createNewTankWeapon(): # not payable\n  return createNewTankWeapon\n\ndef AuctionMaster(): # not payable\n  return auctionMasterAddress\n\ndef newIdTankWeapon(): # not payable\n  return newIdTankWeapon\n\ndef howManyTanks(): # not payable\n  return howManyTanks\n\ndef getProductEarning(uint32 _ID): # not payable\n  return tankName[_ID << 224].field_1024\n\ndef ExportMaster(): # not payable\n  return exportMasterAddress\n\ndef TankSellMaster(): # not payable\n  return tankSellMasterAddress\n\ndef createNewTankHull(): # not payable\n  return createNewTankHull\n\ndef getPlayerBalance(address _player): # not payable\n  return playerBalance[address(_player)].field_0\n\ndef newIdAuctionEntity(): # not payable\n  return newIdAuctionEntity\n\ndef newIdTankHull(): # not payable\n  return newIdTankHull\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef FinishedExporting(): # not payable\n  require caller == exportMasterAddress\n  Mask(96, 0, stor3.field_160) = 0\n\ndef ChangeAuctionMaster(address _newMaster): # not payable\n  require caller == auctionMasterAddress\n  auctionMasterAddress = _newMaster\n\ndef ChangeUpgradeMaster(address _newMaster): # not payable\n  require caller == upgradeMasterAddress\n  upgradeMasterAddress = _newMaster\n\ndef ChangeTankSellMaster(address _newMaster): # not payable\n  require caller == tankSellMasterAddress\n  tankSellMasterAddress = _newMaster\n\ndef login(string _hash): # not payable\n  log EventLogin(\n        address player=Array(len=_hash.length, data=_hash[all]),\n        string hash=caller)\n\ndef tanksBeforeTheNewTankType(): # not payable\n  return uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100)\n\ndef exportTankResetEarning(uint32 _tankID): # not payable\n  require bool(canExport) == 1\n  require caller == exportMasterAddress\n  Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536)\n\ndef getTankEarning(uint32 _ID): # not payable\n  return (tankName[uint32(stor6[_ID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_ID << 224].field_0)].field_1536) - uint32(tankDetails[_ID << 224].field_1568)))\n\ndef _transferAction(uint32 _tankID, address _receiver, uint8 _ActionType): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _receiver != caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  address(tankDetails[_tankID << 224].field_512) = _receiver\n  log EventTransferAction(\n        address player=_tankID << 224,\n        address receiver=_ActionType,\n        uint32 tankID=caller,\n        uint8 ActionType=_receiver)\n\ndef _transfer(uint32 _tankID, address _receiver): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _receiver != caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  address(tankDetails[_tankID << 224].field_512) = _receiver\n  address(tankDetails[_tankID << 224].field_768) = _receiver\n  log EventTransfer(\n        address player=_tankID,\n        address receiver=caller,\n        uint32 tankID=_receiver)\n\ndef getTankProduct(uint32 _ID): # not payable\n  return stor8[uint32(stor7[_ID << 224].field_256)], \n         stor8[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         uint32(tankName[_ID << 224].field_1280)\n\ndef cancelAuction(uint32 _tankID): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require bool(uint8(tankDetails[_tankID << 224].field_928)) == 1\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 0\n  uint32(stor11[stor6[_tankID << 224].field_1024].field_0) = 0\n  stor11[stor6[_tankID << 224].field_1024].field_256 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_512 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_768 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_1024 = 0\n  tankDetails[_tankID << 224].field_1024 = 0\n  log EventCancelAuction(uint32 tankID=_tankID)\n\ndef cashOut(uint256 _amount) payable: \n  require not canExport\n  require _amount >= 0\n  require _amount == uint128(_amount)\n  require eth.balance(this.address) >= _amount\n  require playerBalance[caller].field_0 >= _amount\n  if _amount:\n      playerBalance[caller].field_0 -= _amount\n      call caller with:\n         value _amount wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          playerBalance[caller].field_0 += _amount\n      log EventCashOut(\n            address player=_amount,\n            uint256 amount=caller)\n  else:\n      playerBalance[caller].field_0 = 0\n      call caller with:\n         value playerBalance[caller].field_0 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          bool(playerBalance[caller].field_0) = 0\n          uint255(playerBalance[caller].field_1) = uint255(playerBalance[caller].field_0)\n      log EventCashOut(\n            address player=playerBalance[caller].field_0,\n            uint256 amount=caller)\n\ndef upgradeTank(uint32 _tankID, uint8 _upgradeChoice) payable: \n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _upgradeChoice >= 0\n  require _upgradeChoice < 4\n  require stor((Mask(3, 5, _upgradeChoice) >> 5) + ('map', ('mask_shl', 32, 0, 224, ('param', '_tankID')), ('name', 'stor6', 6)) + 1)[uint8(_upgradeChoice)] < 5\n  require call.value >= 5 * 10^16\n  require _upgradeChoice < 4\n  tankDetails[_tankID << 224][uint8(_upgradeChoice) / 32].field_256 = uint8(stor((Mask(3, 5, _upgradeChoice) >> 5) + ('map', ('mask_shl', 32, 0, 224, ('param', '_tankID')), ('name', 'stor6', 6)) + 1)[uint8(_upgradeChoice)] + 1) * 256^(_upgradeChoice % 32) or !(255 * 256^(_upgradeChoice % 32)) and tankDetails[_tankID << 224][uint8(_upgradeChoice) / 32].field_256\n  playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - 5 * 10^16\n  playerBalance[stor0].field_0 += 5 * 10^16\n  log EventUpgradeTank(\n        address player=_tankID << 224,\n        uint32 tankID=_upgradeChoice,\n        uint8 upgradeChoice=caller)\n\ndef sellTank(uint32 _tankID, uint256 _startPrice, uint256 _finishPrice, uint256 _duration): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  require _startPrice >= _finishPrice\n  require _startPrice > 0\n  require _finishPrice >= 0\n  require _duration > 0\n  require _startPrice == uint128(_startPrice)\n  require _finishPrice == uint128(_finishPrice)\n  uint32(stor11[stor5].field_0) = _tankID\n  stor11[stor5].field_256 = _startPrice\n  stor11[stor5].field_512 = _finishPrice\n  stor11[stor5].field_768 = block.timestamp\n  stor11[stor5].field_1024 = _duration\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 1\n  newIdAuctionEntity++\n  tankDetails[_tankID << 224].field_1024 = newIdAuctionEntity\n  log EventAuction(\n        address player=_tankID << 224,\n        uint32 tankID=_startPrice,\n        uint256 startPrice=_finishPrice,\n        uint256 finishPrice=_duration,\n        uint256 duration=block.timestamp,\n        uint256 currentTime=caller)\n\ndef getCurrentPriceAuction(uint32 _ID): # not payable\n  require uint8(tankDetails[_ID << 224].field_928)\n  require stor11[stor6[_ID << 224].field_1024].field_1024\n  if stor11[stor6[_ID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) + (stor11[stor6[_ID << 224].field_1024].field_768 * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) >= stor11[stor6[_ID << 224].field_1024].field_512:\n      return (stor11[stor6[_ID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) + (stor11[stor6[_ID << 224].field_1024].field_768 * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024))\n  return stor11[stor6[_ID << 224].field_1024].field_512\n\ndef cashOutTank(uint32 _tankID) payable: \n  require not canExport\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require eth.balance(this.address) >= tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568))\n  require tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568)) > 0\n  Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536)\n  call address(tankDetails[_tankID << 224].field_512) with:\n     value tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568)) wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankDetails[_tankID << 224].field_1568)\n  log EventCashOut(\n        address player=(tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568))),\n        uint256 amount=caller)\n\ndef exportTank(address _owner, uint32 _tankproductID): # not payable\n  require bool(canExport) == 1\n  require caller == exportMasterAddress\n  tankName[_tankproductID << 224].field_768 += tankName[_tankproductID << 224].field_1024\n  mem[384] = 0\n  mem[416] = 0\n  mem[448] = 0\n  mem[480] = 0\n  uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n  newIdTank = uint32(newIdTank + 1)\n  uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n  s = 0\n  idx = 384\n  while 512 > idx:\n      tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n      s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n      idx = idx + 32\n      continue \n  idx = 4\n  s = sha3(uint32(stor3.field_0), 6) + 1\n  while idx:\n      stor[s] = !(255 * 256^idx) and stor[s]\n      idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n      s = (idx + 1 / 32) + s\n      continue \n  idx = (-2 * None + 3 / 32) + (None * None + 3 / 32) + 1\n  while 2 > idx:\n      uint8(tankDetails[uint32(stor3.field_0)][idx].field_0) = 0\n      idx = idx + 1\n      continue \n  address(tankDetails[uint32(stor3.field_0)].field_512) = _owner\n  address(tankDetails[uint32(stor3.field_0)].field_768) = _owner\n  Mask(96, 0, tankDetails[uint32(stor3.field_0)].field_928) = 0\n  tankDetails[uint32(stor3.field_0)].field_1024 = 0\n  tankDetails[uint32(stor3.field_0)].field_1280 = 0\n  uint32(tankDetails[uint32(stor3.field_0)].field_1536) = 0\n  tankDetails[uint32(stor3.field_0)].field_1792 % 1 = 0\n  uint32(tankDetails[uint32(stor3.field_0)].field_1568) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n  if not uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100):\n      if howManyTanks <= 121:\n          if createNewTankHull >= uint32(newIdTankHull - 1):\n              createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              if createNewTankHull == createNewTankWeapon:\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n          else:\n              if createNewTankWeapon < uint32(newIdTankWeapon - 1):\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n                  if createNewTankHull == createNewTankWeapon:\n                      createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              else:\n                  uint8(stor4.field_96) = 1\n                  stor4.field_104 % unknown01000000() = 0\n                  createNewTankHull = uint32(createNewTankHull + 1)\n          howManyTanks = uint32(howManyTanks + 1)\n          bool(tankName[uint32(stor3.field_0)].field_0) = 0\n          uint255(tankName[uint32(stor3.field_0)].field_1) = 4\n          Mask(248, 0, tankName[uint32(stor3.field_0)].field_8) = 'Tank' / 256\n          idx = 0\n          while tankName[uint32(stor3.field_0)].length + 31 / 32 > idx:\n              tankName[uint32(stor3.field_0)][idx].field_0 = 0\n              idx = idx + 1\n              continue \n          uint32(tankName[uint32(stor3.field_0)].field_256) = createNewTankHull\n          uint32(tankName[uint32(stor3.field_0)].field_288) = createNewTankWeapon\n          tankName[uint32(stor3.field_0)].field_512 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_768 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_1024 = 3 * 10^15\n          tankName[uint32(stor3.field_0)].field_1280 = block.timestamp + 3600\n          uint32(tankName[uint32(stor3.field_0)].field_1536) = 0\n          tankName[uint32(stor3.field_0)].field_1792 % 1 = 0\n          log EventProduct(uint32 productID, string name, uint32 hull, uint32 weapon, uint256 price, uint256 earning, uint256 releaseTime, uint256 currentTime):\n                           howManyTanks - 1 << 224,\n                           256,\n                           newIdTankHull,\n                           newIdTankHull,\n                           2 * 10^17,\n                           3 * 10^15,\n                           block.timestamp + 3600,\n                           block.timestamp,\n                           4,\n                           uint32('Tank'),\n  log EventBuyTank(\n        address player=_tankproductID << 224,\n        uint32 productID=uint32(newIdTank - 1),\n        uint32 tankID=_owner)\n\ndef buyTank(uint32 _tankproductID) payable: \n  require not canExport\n  require tankName[_tankproductID << 224].field_768 > 0\n  require call.value > 0\n  require call.value >= tankName[_tankproductID << 224].field_768\n  require tankName[_tankproductID << 224].field_1280 <= block.timestamp\n  if call.value > tankName[_tankproductID << 224].field_768:\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - tankName[_tankproductID << 224].field_768\n  tankName[_tankproductID << 224].field_768 += tankName[_tankproductID << 224].field_1024\n  if uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100):\n      mem[384] = 0\n      mem[416] = 0\n      mem[448] = 0\n      mem[480] = 0\n      uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n      newIdTank = uint32(newIdTank + 1)\n      uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n      s = 0\n      idx = 384\n      while 512 > idx:\n          tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n          s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      s = sha3(uint32(stor3.field_0), 6) + 1\n      while idx:\n          stor[s] = !(255 * 256^idx) and stor[s]\n          idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n          s = (idx + 1 / 32) + s\n          continue \n  else:\n      if howManyTanks > 121:\n          mem[384] = 0\n          mem[416] = 0\n          mem[448] = 0\n          mem[480] = 0\n          uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n          newIdTank = uint32(newIdTank + 1)\n          uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n          s = 0\n          idx = 384\n          while 512 > idx:\n              tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n              s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n              idx = idx + 32\n              continue \n          idx = 4\n          s = sha3(uint32(stor3.field_0), 6) + 1\n          while idx:\n              stor[s] = !(255 * 256^idx) and stor[s]\n              idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n              s = (idx + 1 / 32) + s\n              continue \n      else:\n          if createNewTankHull >= uint32(newIdTankHull - 1):\n              createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              if createNewTankHull == createNewTankWeapon:\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n          else:\n              if createNewTankWeapon < uint32(newIdTankWeapon - 1):\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n                  if createNewTankHull == createNewTankWeapon:\n                      createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              else:\n                  uint8(stor4.field_96) = 1\n                  stor4.field_104 % unknown01000000() = 0\n                  createNewTankHull = uint32(createNewTankHull + 1)\n          howManyTanks = uint32(howManyTanks + 1)\n          bool(tankName[uint32(stor3.field_0)].field_0) = 0\n          uint255(tankName[uint32(stor3.field_0)].field_1) = 4\n          Mask(248, 0, tankName[uint32(stor3.field_0)].field_8) = 'Tank' / 256\n          idx = 0\n          while tankName[uint32(stor3.field_0)].length + 31 / 32 > idx:\n              tankName[uint32(stor3.field_0)][idx].field_0 = 0\n              idx = idx + 1\n              continue \n          uint32(tankName[uint32(stor3.field_0)].field_256) = createNewTankHull\n          uint32(tankName[uint32(stor3.field_0)].field_288) = createNewTankWeapon\n          tankName[uint32(stor3.field_0)].field_512 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_768 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_1024 = 3 * 10^15\n          tankName[uint32(stor3.field_0)].field_1280 = block.timestamp + 3600\n          uint32(tankName[uint32(stor3.field_0)].field_1536) = 0\n          tankName[uint32(stor3.field_0)].field_1792 % 1 = 0\n          log EventProduct(uint32 productID, string name, uint32 hull, uint32 weapon, uint256 price, uint256 earning, uint256 releaseTime, uint256 currentTime):\n                           howManyTanks - 1 << 224,\n                           256,\n                           newIdTankHull,\n                           newIdTankHull,\n                           2 * 10^17,\n                           3 * 10^15,\n                           block.timestamp + 3600,\n                           block.timestamp,\n                           4,\n                           uint32('Tank'),\n          uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n          newIdTank = uint32(newIdTank + 1)\n          uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef bid(uint32 _tankID) payable: \n  require _tankID > 0\n  require _tankID < newIdTank\n  require bool(uint8(tankDetails[_tankID << 224].field_928)) == 1\n  require stor11[stor6[_tankID << 224].field_1024].field_1024\n  if stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) >= stor11[stor6[_tankID << 224].field_1024].field_512:\n      require stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) >= 0\n      require call.value >= stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024)\n      playerBalance[address(stor6[_tankID << 224].field_512)].field_0 = playerBalance[address(stor6[_tankID << 224].field_512)].field_0 + stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) - (3 * stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) / 100)\n      playerBalance[stor1].field_0 += 3 * stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) / 100\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - stor11[stor6[_tankID << 224].field_1024].field_256 + (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) - (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024)\n  else:\n      require stor11[stor6[_tankID << 224].field_1024].field_512 >= 0\n      require call.value >= stor11[stor6[_tankID << 224].field_1024].field_512\n      playerBalance[address(stor6[_tankID << 224].field_512)].field_0 = playerBalance[address(stor6[_tankID << 224].field_512)].field_0 + stor11[stor6[_tankID << 224].field_1024].field_512 - (3 * stor11[stor6[_tankID << 224].field_1024].field_512 / 100)\n      playerBalance[stor1].field_0 += 3 * stor11[stor6[_tankID << 224].field_1024].field_512 / 100\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - stor11[stor6[_tankID << 224].field_1024].field_512\n  address(tankDetails[_tankID << 224].field_512) = caller\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 0\n  uint32(stor11[stor6[_tankID << 224].field_1024].field_0) = 0\n  stor11[stor6[_tankID << 224].field_1024].field_256 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_512 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_768 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_1024 = 0\n  tankDetails[_tankID << 224].field_1024 = 0\n  log EventBid(uint32 tankID=_tankID)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst upgradePrice = 5 * 10^16\nconst getContractBalance = eth.balance(this.address)\n\ndef storage:\n  upgradeMasterAddress is address at storage 0\n  auctionMasterAddress is address at storage 1\n  stor10 is mapping of uint32 at storage 10\n  stor11 is mapping of struct at storage 11\n  playerBalance is mapping of struct at storage 12\n  tankSellMasterAddress is address at storage 2\n  canExport is uint8 at storage 3 offset 160\n  stor3 is uint32 at storage 3\n  newIdTank is uint32 at storage 3 offset 168\n  howManyTanks is uint32 at storage 3 offset 200\n  stor3 is uint128 at storage 3 offset 160\n  exportMasterAddress is address at storage 3\n  stor4 is uint8 at storage 4 offset 96\n  stor4 is uint32 at storage 4 offset 104\n  newIdTankHull is uint32 at storage 4\n  newIdTankWeapon is uint32 at storage 4 offset 32\n  createNewTankHull is uint32 at storage 4 offset 64\n  createNewTankWeapon is uint32 at storage 4 offset 96\n  newIdAuctionEntity is uint256 at storage 5\n  tankDetails is mapping of struct at storage 6\n  tankName is mapping of struct at storage 7\n  stor8 is mapping of uint32 at storage 8\n\ndef getTankSell(uint32 _ID): # not payable\n  return bool(uint8(tankDetails[_ID << 224].field_928))\n\ndef getTankName(uint32 _ID): # not payable\n  return tankName[_ID << 224][0 len tankName[_ID << 224].length].field_0\n\ndef getCurrentPrice(uint32 _ID): # not payable\n  return tankName[_ID << 224].field_768\n\ndef getTankDetails(uint32 _ID): # not payable\n  return uint32(tankDetails[_ID << 224].field_0), \n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint32(tankDetails[_ID << 224].field_1536)\n\ndef newIdTankProduct(): # not payable\n  return howManyTanks\n\ndef UpgradeMaster(): # not payable\n  return upgradeMasterAddress\n\ndef newIdTank(): # not payable\n  return newIdTank\n\ndef canExport(): # not payable\n  return bool(canExport)\n\ndef getTankAuctionEntity(uint32 _ID): # not payable\n  return tankDetails[_ID << 224].field_1024\n\ndef getTankTotalEarned(uint32 _ID): # not payable\n  return tankDetails[_ID << 224].field_1280\n\ndef getTankOwner(uint32 _ID): # not payable\n  return address(tankDetails[_ID << 224].field_512)\n\ndef createNewTankWeapon(): # not payable\n  return createNewTankWeapon\n\ndef AuctionMaster(): # not payable\n  return auctionMasterAddress\n\ndef newIdTankWeapon(): # not payable\n  return newIdTankWeapon\n\ndef howManyTanks(): # not payable\n  return howManyTanks\n\ndef getProductEarning(uint32 _ID): # not payable\n  return tankName[_ID << 224].field_1024\n\ndef ExportMaster(): # not payable\n  return exportMasterAddress\n\ndef TankSellMaster(): # not payable\n  return tankSellMasterAddress\n\ndef createNewTankHull(): # not payable\n  return createNewTankHull\n\ndef getPlayerBalance(address _player): # not payable\n  return playerBalance[address(_player)].field_0\n\ndef newIdAuctionEntity(): # not payable\n  return newIdAuctionEntity\n\ndef newIdTankHull(): # not payable\n  return newIdTankHull\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef FinishedExporting(): # not payable\n  require caller == exportMasterAddress\n  Mask(96, 0, stor3.field_160) = 0\n\ndef ChangeAuctionMaster(address _newMaster): # not payable\n  require caller == auctionMasterAddress\n  auctionMasterAddress = _newMaster\n\ndef ChangeUpgradeMaster(address _newMaster): # not payable\n  require caller == upgradeMasterAddress\n  upgradeMasterAddress = _newMaster\n\ndef ChangeTankSellMaster(address _newMaster): # not payable\n  require caller == tankSellMasterAddress\n  tankSellMasterAddress = _newMaster\n\ndef login(string _hash): # not payable\n  log EventLogin(\n        address player=Array(len=_hash.length, data=_hash[all]),\n        string hash=caller)\n\ndef tanksBeforeTheNewTankType(): # not payable\n  return uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100)\n\ndef exportTankResetEarning(uint32 _tankID): # not payable\n  require bool(canExport) == 1\n  require caller == exportMasterAddress\n  Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536)\n\ndef getTankEarning(uint32 _ID): # not payable\n  return (tankName[uint32(stor6[_ID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_ID << 224].field_0)].field_1536) - uint32(tankDetails[_ID << 224].field_1568)))\n\ndef _transferAction(uint32 _tankID, address _receiver, uint8 _ActionType): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _receiver != caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  address(tankDetails[_tankID << 224].field_512) = _receiver\n  log EventTransferAction(\n        address player=_tankID << 224,\n        address receiver=_ActionType,\n        uint32 tankID=caller,\n        uint8 ActionType=_receiver)\n\ndef _transfer(uint32 _tankID, address _receiver): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _receiver != caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  address(tankDetails[_tankID << 224].field_512) = _receiver\n  address(tankDetails[_tankID << 224].field_768) = _receiver\n  log EventTransfer(\n        address player=_tankID,\n        address receiver=caller,\n        uint32 tankID=_receiver)\n\ndef getTankProduct(uint32 _ID): # not payable\n  return stor8[uint32(stor7[_ID << 224].field_256)], \n         stor8[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         uint32(tankName[_ID << 224].field_1280)\n\ndef cancelAuction(uint32 _tankID): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require bool(uint8(tankDetails[_tankID << 224].field_928)) == 1\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 0\n  uint32(stor11[stor6[_tankID << 224].field_1024].field_0) = 0\n  stor11[stor6[_tankID << 224].field_1024].field_256 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_512 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_768 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_1024 = 0\n  tankDetails[_tankID << 224].field_1024 = 0\n  log EventCancelAuction(uint32 tankID=_tankID)\n\ndef cashOut(uint256 _amount) payable: \n  require not canExport\n  require _amount >= 0\n  require _amount == uint128(_amount)\n  require eth.balance(this.address) >= _amount\n  require playerBalance[caller].field_0 >= _amount\n  if _amount:\n      playerBalance[caller].field_0 -= _amount\n      call caller with:\n         value _amount wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          playerBalance[caller].field_0 += _amount\n      log EventCashOut(\n            address player=_amount,\n            uint256 amount=caller)\n  else:\n      playerBalance[caller].field_0 = 0\n      call caller with:\n         value playerBalance[caller].field_0 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          bool(playerBalance[caller].field_0) = 0\n          uint255(playerBalance[caller].field_1) = uint255(playerBalance[caller].field_0)\n      log EventCashOut(\n            address player=playerBalance[caller].field_0,\n            uint256 amount=caller)\n\ndef upgradeTank(uint32 _tankID, uint8 _upgradeChoice) payable: \n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _upgradeChoice >= 0\n  require _upgradeChoice < 4\n  require stor((Mask(3, 5, _upgradeChoice) >> 5) + ('map', ('mask_shl', 32, 0, 224, ('param', '_tankID')), ('name', 'stor6', 6)) + 1)[uint8(_upgradeChoice)] < 5\n  require call.value >= 5 * 10^16\n  require _upgradeChoice < 4\n  tankDetails[_tankID << 224][uint8(_upgradeChoice) / 32].field_256 = uint8(stor((Mask(3, 5, _upgradeChoice) >> 5) + ('map', ('mask_shl', 32, 0, 224, ('param', '_tankID')), ('name', 'stor6', 6)) + 1)[uint8(_upgradeChoice)] + 1) * 256^(_upgradeChoice % 32) or !(255 * 256^(_upgradeChoice % 32)) and tankDetails[_tankID << 224][uint8(_upgradeChoice) / 32].field_256\n  playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - 5 * 10^16\n  playerBalance[stor0].field_0 += 5 * 10^16\n  log EventUpgradeTank(\n        address player=_tankID << 224,\n        uint32 tankID=_upgradeChoice,\n        uint8 upgradeChoice=caller)\n\ndef sellTank(uint32 _tankID, uint256 _startPrice, uint256 _finishPrice, uint256 _duration): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  require _startPrice >= _finishPrice\n  require _startPrice > 0\n  require _finishPrice >= 0\n  require _duration > 0\n  require _startPrice == uint128(_startPrice)\n  require _finishPrice == uint128(_finishPrice)\n  uint32(stor11[stor5].field_0) = _tankID\n  stor11[stor5].field_256 = _startPrice\n  stor11[stor5].field_512 = _finishPrice\n  stor11[stor5].field_768 = block.timestamp\n  stor11[stor5].field_1024 = _duration\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 1\n  newIdAuctionEntity++\n  tankDetails[_tankID << 224].field_1024 = newIdAuctionEntity\n  log EventAuction(\n        address player=_tankID << 224,\n        uint32 tankID=_startPrice,\n        uint256 startPrice=_finishPrice,\n        uint256 finishPrice=_duration,\n        uint256 duration=block.timestamp,\n        uint256 currentTime=caller)\n\ndef getCurrentPriceAuction(uint32 _ID): # not payable\n  require uint8(tankDetails[_ID << 224].field_928)\n  require stor11[stor6[_ID << 224].field_1024].field_1024\n  if stor11[stor6[_ID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) + (stor11[stor6[_ID << 224].field_1024].field_768 * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) >= stor11[stor6[_ID << 224].field_1024].field_512:\n      return (stor11[stor6[_ID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) + (stor11[stor6[_ID << 224].field_1024].field_768 * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024))\n  return stor11[stor6[_ID << 224].field_1024].field_512\n\ndef cashOutTank(uint32 _tankID) payable: \n  require not canExport\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require eth.balance(this.address) >= tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568))\n  require tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568)) > 0\n  Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536)\n  call address(tankDetails[_tankID << 224].field_512) with:\n     value tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568)) wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankDetails[_tankID << 224].field_1568)\n  log EventCashOut(\n        address player=(tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568))),\n        uint256 amount=caller)\n\ndef exportTank(address _owner, uint32 _tankproductID): # not payable\n  require bool(canExport) == 1\n  require caller == exportMasterAddress\n  tankName[_tankproductID << 224].field_768 += tankName[_tankproductID << 224].field_1024\n  mem[384] = 0\n  mem[416] = 0\n  mem[448] = 0\n  mem[480] = 0\n  uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n  newIdTank = uint32(newIdTank + 1)\n  uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n  s = 0\n  idx = 384\n  while 512 > idx:\n      tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n      s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n      idx = idx + 32\n      continue \n  idx = 4\n  s = sha3(uint32(stor3.field_0), 6) + 1\n  while idx:\n      stor[s] = !(255 * 256^idx) and stor[s]\n      idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n      s = (idx + 1 / 32) + s\n      continue \n  idx = (-2 * None + 3 / 32) + (None * None + 3 / 32) + 1\n  while 2 > idx:\n      uint8(tankDetails[uint32(stor3.field_0)][idx].field_0) = 0\n      idx = idx + 1\n      continue \n  address(tankDetails[uint32(stor3.field_0)].field_512) = _owner\n  address(tankDetails[uint32(stor3.field_0)].field_768) = _owner\n  Mask(96, 0, tankDetails[uint32(stor3.field_0)].field_928) = 0\n  tankDetails[uint32(stor3.field_0)].field_1024 = 0\n  tankDetails[uint32(stor3.field_0)].field_1280 = 0\n  uint32(tankDetails[uint32(stor3.field_0)].field_1536) = 0\n  tankDetails[uint32(stor3.field_0)].field_1792 % 1 = 0\n  uint32(tankDetails[uint32(stor3.field_0)].field_1568) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n  if not uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100):\n      if howManyTanks <= 121:\n          if createNewTankHull >= uint32(newIdTankHull - 1):\n              createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              if createNewTankHull == createNewTankWeapon:\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n          else:\n              if createNewTankWeapon < uint32(newIdTankWeapon - 1):\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n                  if createNewTankHull == createNewTankWeapon:\n                      createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              else:\n                  uint8(stor4.field_96) = 1\n                  stor4.field_104 % unknown01000000() = 0\n                  createNewTankHull = uint32(createNewTankHull + 1)\n          howManyTanks = uint32(howManyTanks + 1)\n          bool(tankName[uint32(stor3.field_0)].field_0) = 0\n          uint255(tankName[uint32(stor3.field_0)].field_1) = 4\n          Mask(248, 0, tankName[uint32(stor3.field_0)].field_8) = 'Tank' / 256\n          idx = 0\n          while tankName[uint32(stor3.field_0)].length + 31 / 32 > idx:\n              tankName[uint32(stor3.field_0)][idx].field_0 = 0\n              idx = idx + 1\n              continue \n          uint32(tankName[uint32(stor3.field_0)].field_256) = createNewTankHull\n          uint32(tankName[uint32(stor3.field_0)].field_288) = createNewTankWeapon\n          tankName[uint32(stor3.field_0)].field_512 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_768 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_1024 = 3 * 10^15\n          tankName[uint32(stor3.field_0)].field_1280 = block.timestamp + 3600\n          uint32(tankName[uint32(stor3.field_0)].field_1536) = 0\n          tankName[uint32(stor3.field_0)].field_1792 % 1 = 0\n          log EventProduct(uint32 productID, string name, uint32 hull, uint32 weapon, uint256 price, uint256 earning, uint256 releaseTime, uint256 currentTime):\n                           howManyTanks - 1 << 224,\n                           256,\n                           newIdTankHull,\n                           newIdTankHull,\n                           2 * 10^17,\n                           3 * 10^15,\n                           block.timestamp + 3600,\n                           block.timestamp,\n                           4,\n                           uint32('Tank'),\n  log EventBuyTank(\n        address player=_tankproductID << 224,\n        uint32 productID=uint32(newIdTank - 1),\n        uint32 tankID=_owner)\n\ndef buyTank(uint32 _tankproductID) payable: \n  require not canExport\n  require tankName[_tankproductID << 224].field_768 > 0\n  require call.value > 0\n  require call.value >= tankName[_tankproductID << 224].field_768\n  require tankName[_tankproductID << 224].field_1280 <= block.timestamp\n  if call.value > tankName[_tankproductID << 224].field_768:\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - tankName[_tankproductID << 224].field_768\n  tankName[_tankproductID << 224].field_768 += tankName[_tankproductID << 224].field_1024\n  if uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100):\n      mem[384] = 0\n      mem[416] = 0\n      mem[448] = 0\n      mem[480] = 0\n      uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n      newIdTank = uint32(newIdTank + 1)\n      uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n      s = 0\n      idx = 384\n      while 512 > idx:\n          tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n          s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      s = sha3(uint32(stor3.field_0), 6) + 1\n      while idx:\n          stor[s] = !(255 * 256^idx) and stor[s]\n          idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n          s = (idx + 1 / 32) + s\n          continue \n  else:\n      if howManyTanks > 121:\n          mem[384] = 0\n          mem[416] = 0\n          mem[448] = 0\n          mem[480] = 0\n          uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n          newIdTank = uint32(newIdTank + 1)\n          uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n          s = 0\n          idx = 384\n          while 512 > idx:\n              tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n              s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n              idx = idx + 32\n              continue \n          idx = 4\n          s = sha3(uint32(stor3.field_0), 6) + 1\n          while idx:\n              stor[s] = !(255 * 256^idx) and stor[s]\n              idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n              s = (idx + 1 / 32) + s\n              continue \n      else:\n          if createNewTankHull >= uint32(newIdTankHull - 1):\n              createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              if createNewTankHull == createNewTankWeapon:\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n          else:\n              if createNewTankWeapon < uint32(newIdTankWeapon - 1):\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n                  if createNewTankHull == createNewTankWeapon:\n                      createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              else:\n                  uint8(stor4.field_96) = 1\n                  stor4.field_104 % unknown01000000() = 0\n                  createNewTankHull = uint32(createNewTankHull + 1)\n          howManyTanks = uint32(howManyTanks + 1)\n          bool(tankName[uint32(stor3.field_0)].field_0) = 0\n          uint255(tankName[uint32(stor3.field_0)].field_1) = 4\n          Mask(248, 0, tankName[uint32(stor3.field_0)].field_8) = 'Tank' / 256\n          idx = 0\n          while tankName[uint32(stor3.field_0)].length + 31 / 32 > idx:\n              tankName[uint32(stor3.field_0)][idx].field_0 = 0\n              idx = idx + 1\n              continue \n          uint32(tankName[uint32(stor3.field_0)].field_256) = createNewTankHull\n          uint32(tankName[uint32(stor3.field_0)].field_288) = createNewTankWeapon\n          tankName[uint32(stor3.field_0)].field_512 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_768 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_1024 = 3 * 10^15\n          tankName[uint32(stor3.field_0)].field_1280 = block.timestamp + 3600\n          uint32(tankName[uint32(stor3.field_0)].field_1536) = 0\n          tankName[uint32(stor3.field_0)].field_1792 % 1 = 0\n          log EventProduct(uint32 productID, string name, uint32 hull, uint32 weapon, uint256 price, uint256 earning, uint256 releaseTime, uint256 currentTime):\n                           howManyTanks - 1 << 224,\n                           256,\n                           newIdTankHull,\n                           newIdTankHull,\n                           2 * 10^17,\n                           3 * 10^15,\n                           block.timestamp + 3600,\n                           block.timestamp,\n                           4,\n                           uint32('Tank'),\n          uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n          newIdTank = uint32(newIdTank + 1)\n          uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef bid(uint32 _tankID) payable: \n  require _tankID > 0\n  require _tankID < newIdTank\n  require bool(uint8(tankDetails[_tankID << 224].field_928)) == 1\n  require stor11[stor6[_tankID << 224].field_1024].field_1024\n  if stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) >= stor11[stor6[_tankID << 224].field_1024].field_512:\n      require stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) >= 0\n      require call.value >= stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024)\n      playerBalance[address(stor6[_tankID << 224].field_512)].field_0 = playerBalance[address(stor6[_tankID << 224].field_512)].field_0 + stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) - (3 * stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) / 100)\n      playerBalance[stor1].field_0 += 3 * stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) / 100\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - stor11[stor6[_tankID << 224].field_1024].field_256 + (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) - (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024)\n  else:\n      require stor11[stor6[_tankID << 224].field_1024].field_512 >= 0\n      require call.value >= stor11[stor6[_tankID << 224].field_1024].field_512\n      playerBalance[address(stor6[_tankID << 224].field_512)].field_0 = playerBalance[address(stor6[_tankID << 224].field_512)].field_0 + stor11[stor6[_tankID << 224].field_1024].field_512 - (3 * stor11[stor6[_tankID << 224].field_1024].field_512 / 100)\n      playerBalance[stor1].field_0 += 3 * stor11[stor6[_tankID << 224].field_1024].field_512 / 100\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - stor11[stor6[_tankID << 224].field_1024].field_512\n  address(tankDetails[_tankID << 224].field_512) = caller\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 0\n  uint32(stor11[stor6[_tankID << 224].field_1024].field_0) = 0\n  stor11[stor6[_tankID << 224].field_1024].field_256 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_512 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_768 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_1024 = 0\n  tankDetails[_tankID << 224].field_1024 = 0\n  log EventBid(uint32 tankID=_tankID)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst upgradePrice = 5 * 10^16\nconst getContractBalance = eth.balance(this.address)\n\ndef storage:\n  upgradeMasterAddress is address at storage 0\n  auctionMasterAddress is address at storage 1\n  stor10 is mapping of uint32 at storage 10\n  stor11 is mapping of struct at storage 11\n  playerBalance is mapping of struct at storage 12\n  tankSellMasterAddress is address at storage 2\n  canExport is uint8 at storage 3 offset 160\n  stor3 is uint32 at storage 3\n  newIdTank is uint32 at storage 3 offset 168\n  howManyTanks is uint32 at storage 3 offset 200\n  stor3 is uint128 at storage 3 offset 160\n  exportMasterAddress is address at storage 3\n  stor4 is uint8 at storage 4 offset 96\n  stor4 is uint32 at storage 4 offset 104\n  newIdTankHull is uint32 at storage 4\n  newIdTankWeapon is uint32 at storage 4 offset 32\n  createNewTankHull is uint32 at storage 4 offset 64\n  createNewTankWeapon is uint32 at storage 4 offset 96\n  newIdAuctionEntity is uint256 at storage 5\n  tankDetails is mapping of struct at storage 6\n  tankName is mapping of struct at storage 7\n  stor8 is mapping of uint32 at storage 8\n\ndef getTankSell(uint32 _ID): # not payable\n  return bool(uint8(tankDetails[_ID << 224].field_928))\n\ndef getTankName(uint32 _ID): # not payable\n  return tankName[_ID << 224][0 len tankName[_ID << 224].length].field_0\n\ndef getCurrentPrice(uint32 _ID): # not payable\n  return tankName[_ID << 224].field_768\n\ndef getTankDetails(uint32 _ID): # not payable\n  return uint32(tankDetails[_ID << 224].field_0), \n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint8(tankDetails[_ID << 224].field_256),\n         uint32(tankDetails[_ID << 224].field_1536)\n\ndef newIdTankProduct(): # not payable\n  return howManyTanks\n\ndef UpgradeMaster(): # not payable\n  return upgradeMasterAddress\n\ndef newIdTank(): # not payable\n  return newIdTank\n\ndef canExport(): # not payable\n  return bool(canExport)\n\ndef getTankAuctionEntity(uint32 _ID): # not payable\n  return tankDetails[_ID << 224].field_1024\n\ndef getTankTotalEarned(uint32 _ID): # not payable\n  return tankDetails[_ID << 224].field_1280\n\ndef getTankOwner(uint32 _ID): # not payable\n  return address(tankDetails[_ID << 224].field_512)\n\ndef createNewTankWeapon(): # not payable\n  return createNewTankWeapon\n\ndef AuctionMaster(): # not payable\n  return auctionMasterAddress\n\ndef newIdTankWeapon(): # not payable\n  return newIdTankWeapon\n\ndef howManyTanks(): # not payable\n  return howManyTanks\n\ndef getProductEarning(uint32 _ID): # not payable\n  return tankName[_ID << 224].field_1024\n\ndef ExportMaster(): # not payable\n  return exportMasterAddress\n\ndef TankSellMaster(): # not payable\n  return tankSellMasterAddress\n\ndef createNewTankHull(): # not payable\n  return createNewTankHull\n\ndef getPlayerBalance(address _player): # not payable\n  return playerBalance[address(_player)].field_0\n\ndef newIdAuctionEntity(): # not payable\n  return newIdAuctionEntity\n\ndef newIdTankHull(): # not payable\n  return newIdTankHull\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef FinishedExporting(): # not payable\n  require caller == exportMasterAddress\n  Mask(96, 0, stor3.field_160) = 0\n\ndef ChangeAuctionMaster(address _newMaster): # not payable\n  require caller == auctionMasterAddress\n  auctionMasterAddress = _newMaster\n\ndef ChangeUpgradeMaster(address _newMaster): # not payable\n  require caller == upgradeMasterAddress\n  upgradeMasterAddress = _newMaster\n\ndef ChangeTankSellMaster(address _newMaster): # not payable\n  require caller == tankSellMasterAddress\n  tankSellMasterAddress = _newMaster\n\ndef login(string _hash): # not payable\n  log EventLogin(\n        address player=Array(len=_hash.length, data=_hash[all]),\n        string hash=caller)\n\ndef tanksBeforeTheNewTankType(): # not payable\n  return uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100)\n\ndef exportTankResetEarning(uint32 _tankID): # not payable\n  require bool(canExport) == 1\n  require caller == exportMasterAddress\n  Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536)\n\ndef getTankEarning(uint32 _ID): # not payable\n  return (tankName[uint32(stor6[_ID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_ID << 224].field_0)].field_1536) - uint32(tankDetails[_ID << 224].field_1568)))\n\ndef _transferAction(uint32 _tankID, address _receiver, uint8 _ActionType): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _receiver != caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  address(tankDetails[_tankID << 224].field_512) = _receiver\n  log EventTransferAction(\n        address player=_tankID << 224,\n        address receiver=_ActionType,\n        uint32 tankID=caller,\n        uint8 ActionType=_receiver)\n\ndef _transfer(uint32 _tankID, address _receiver): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _receiver != caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  address(tankDetails[_tankID << 224].field_512) = _receiver\n  address(tankDetails[_tankID << 224].field_768) = _receiver\n  log EventTransfer(\n        address player=_tankID,\n        address receiver=caller,\n        uint32 tankID=_receiver)\n\ndef getTankProduct(uint32 _ID): # not payable\n  return stor8[uint32(stor7[_ID << 224].field_256)], \n         stor8[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         stor10[uint32(stor7[_ID << 224].field_256)],\n         uint32(tankName[_ID << 224].field_1280)\n\ndef cancelAuction(uint32 _tankID): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require bool(uint8(tankDetails[_tankID << 224].field_928)) == 1\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 0\n  uint32(stor11[stor6[_tankID << 224].field_1024].field_0) = 0\n  stor11[stor6[_tankID << 224].field_1024].field_256 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_512 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_768 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_1024 = 0\n  tankDetails[_tankID << 224].field_1024 = 0\n  log EventCancelAuction(uint32 tankID=_tankID)\n\ndef cashOut(uint256 _amount) payable: \n  require not canExport\n  require _amount >= 0\n  require _amount == uint128(_amount)\n  require eth.balance(this.address) >= _amount\n  require playerBalance[caller].field_0 >= _amount\n  if _amount:\n      playerBalance[caller].field_0 -= _amount\n      call caller with:\n         value _amount wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          playerBalance[caller].field_0 += _amount\n      log EventCashOut(\n            address player=_amount,\n            uint256 amount=caller)\n  else:\n      playerBalance[caller].field_0 = 0\n      call caller with:\n         value playerBalance[caller].field_0 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          bool(playerBalance[caller].field_0) = 0\n          uint255(playerBalance[caller].field_1) = uint255(playerBalance[caller].field_0)\n      log EventCashOut(\n            address player=playerBalance[caller].field_0,\n            uint256 amount=caller)\n\ndef upgradeTank(uint32 _tankID, uint8 _upgradeChoice) payable: \n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require _upgradeChoice >= 0\n  require _upgradeChoice < 4\n  require stor((Mask(3, 5, _upgradeChoice) >> 5) + ('map', ('mask_shl', 32, 0, 224, ('param', '_tankID')), ('name', 'stor6', 6)) + 1)[uint8(_upgradeChoice)] < 5\n  require call.value >= 5 * 10^16\n  require _upgradeChoice < 4\n  tankDetails[_tankID << 224][uint8(_upgradeChoice) / 32].field_256 = uint8(stor((Mask(3, 5, _upgradeChoice) >> 5) + ('map', ('mask_shl', 32, 0, 224, ('param', '_tankID')), ('name', 'stor6', 6)) + 1)[uint8(_upgradeChoice)] + 1) * 256^(_upgradeChoice % 32) or !(255 * 256^(_upgradeChoice % 32)) and tankDetails[_tankID << 224][uint8(_upgradeChoice) / 32].field_256\n  playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - 5 * 10^16\n  playerBalance[stor0].field_0 += 5 * 10^16\n  log EventUpgradeTank(\n        address player=_tankID << 224,\n        uint32 tankID=_upgradeChoice,\n        uint8 upgradeChoice=caller)\n\ndef sellTank(uint32 _tankID, uint256 _startPrice, uint256 _finishPrice, uint256 _duration): # not payable\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require not uint8(tankDetails[_tankID << 224].field_928)\n  require _startPrice >= _finishPrice\n  require _startPrice > 0\n  require _finishPrice >= 0\n  require _duration > 0\n  require _startPrice == uint128(_startPrice)\n  require _finishPrice == uint128(_finishPrice)\n  uint32(stor11[stor5].field_0) = _tankID\n  stor11[stor5].field_256 = _startPrice\n  stor11[stor5].field_512 = _finishPrice\n  stor11[stor5].field_768 = block.timestamp\n  stor11[stor5].field_1024 = _duration\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 1\n  newIdAuctionEntity++\n  tankDetails[_tankID << 224].field_1024 = newIdAuctionEntity\n  log EventAuction(\n        address player=_tankID << 224,\n        uint32 tankID=_startPrice,\n        uint256 startPrice=_finishPrice,\n        uint256 finishPrice=_duration,\n        uint256 duration=block.timestamp,\n        uint256 currentTime=caller)\n\ndef getCurrentPriceAuction(uint32 _ID): # not payable\n  require uint8(tankDetails[_ID << 224].field_928)\n  require stor11[stor6[_ID << 224].field_1024].field_1024\n  if stor11[stor6[_ID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) + (stor11[stor6[_ID << 224].field_1024].field_768 * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) >= stor11[stor6[_ID << 224].field_1024].field_512:\n      return (stor11[stor6[_ID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024) + (stor11[stor6[_ID << 224].field_1024].field_768 * stor11[stor6[_ID << 224].field_1024].field_256 - stor11[stor6[_ID << 224].field_1024].field_512 / stor11[stor6[_ID << 224].field_1024].field_1024))\n  return stor11[stor6[_ID << 224].field_1024].field_512\n\ndef cashOutTank(uint32 _tankID) payable: \n  require not canExport\n  require _tankID > 0\n  require _tankID < newIdTank\n  require address(tankDetails[_tankID << 224].field_512) == caller\n  require eth.balance(this.address) >= tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568))\n  require tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568)) > 0\n  Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536)\n  call address(tankDetails[_tankID << 224].field_512) with:\n     value tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568)) wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      Mask(224, 0, tankDetails[_tankID << 224].field_1568) = uint32(tankDetails[_tankID << 224].field_1568)\n  log EventCashOut(\n        address player=(tankName[uint32(stor6[_tankID << 224].field_0)].field_1024 * uint32(uint32(tankName[uint32(stor6[_tankID << 224].field_0)].field_1536) - uint32(tankDetails[_tankID << 224].field_1568))),\n        uint256 amount=caller)\n\ndef exportTank(address _owner, uint32 _tankproductID): # not payable\n  require bool(canExport) == 1\n  require caller == exportMasterAddress\n  tankName[_tankproductID << 224].field_768 += tankName[_tankproductID << 224].field_1024\n  mem[384] = 0\n  mem[416] = 0\n  mem[448] = 0\n  mem[480] = 0\n  uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n  newIdTank = uint32(newIdTank + 1)\n  uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n  s = 0\n  idx = 384\n  while 512 > idx:\n      tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n      s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n      idx = idx + 32\n      continue \n  idx = 4\n  s = sha3(uint32(stor3.field_0), 6) + 1\n  while idx:\n      stor[s] = !(255 * 256^idx) and stor[s]\n      idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n      s = (idx + 1 / 32) + s\n      continue \n  idx = (-2 * None + 3 / 32) + (None * None + 3 / 32) + 1\n  while 2 > idx:\n      uint8(tankDetails[uint32(stor3.field_0)][idx].field_0) = 0\n      idx = idx + 1\n      continue \n  address(tankDetails[uint32(stor3.field_0)].field_512) = _owner\n  address(tankDetails[uint32(stor3.field_0)].field_768) = _owner\n  Mask(96, 0, tankDetails[uint32(stor3.field_0)].field_928) = 0\n  tankDetails[uint32(stor3.field_0)].field_1024 = 0\n  tankDetails[uint32(stor3.field_0)].field_1280 = 0\n  uint32(tankDetails[uint32(stor3.field_0)].field_1536) = 0\n  tankDetails[uint32(stor3.field_0)].field_1792 % 1 = 0\n  uint32(tankDetails[uint32(stor3.field_0)].field_1568) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n  if not uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100):\n      if howManyTanks <= 121:\n          if createNewTankHull >= uint32(newIdTankHull - 1):\n              createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              if createNewTankHull == createNewTankWeapon:\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n          else:\n              if createNewTankWeapon < uint32(newIdTankWeapon - 1):\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n                  if createNewTankHull == createNewTankWeapon:\n                      createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              else:\n                  uint8(stor4.field_96) = 1\n                  stor4.field_104 % unknown01000000() = 0\n                  createNewTankHull = uint32(createNewTankHull + 1)\n          howManyTanks = uint32(howManyTanks + 1)\n          bool(tankName[uint32(stor3.field_0)].field_0) = 0\n          uint255(tankName[uint32(stor3.field_0)].field_1) = 4\n          Mask(248, 0, tankName[uint32(stor3.field_0)].field_8) = 'Tank' / 256\n          idx = 0\n          while tankName[uint32(stor3.field_0)].length + 31 / 32 > idx:\n              tankName[uint32(stor3.field_0)][idx].field_0 = 0\n              idx = idx + 1\n              continue \n          uint32(tankName[uint32(stor3.field_0)].field_256) = createNewTankHull\n          uint32(tankName[uint32(stor3.field_0)].field_288) = createNewTankWeapon\n          tankName[uint32(stor3.field_0)].field_512 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_768 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_1024 = 3 * 10^15\n          tankName[uint32(stor3.field_0)].field_1280 = block.timestamp + 3600\n          uint32(tankName[uint32(stor3.field_0)].field_1536) = 0\n          tankName[uint32(stor3.field_0)].field_1792 % 1 = 0\n          log EventProduct(uint32 productID, string name, uint32 hull, uint32 weapon, uint256 price, uint256 earning, uint256 releaseTime, uint256 currentTime):\n                           howManyTanks - 1 << 224,\n                           256,\n                           newIdTankHull,\n                           newIdTankHull,\n                           2 * 10^17,\n                           3 * 10^15,\n                           block.timestamp + 3600,\n                           block.timestamp,\n                           4,\n                           uint32('Tank'),\n  log EventBuyTank(\n        address player=_tankproductID << 224,\n        uint32 productID=uint32(newIdTank - 1),\n        uint32 tankID=_owner)\n\ndef buyTank(uint32 _tankproductID) payable: \n  require not canExport\n  require tankName[_tankproductID << 224].field_768 > 0\n  require call.value > 0\n  require call.value >= tankName[_tankproductID << 224].field_768\n  require tankName[_tankproductID << 224].field_1280 <= block.timestamp\n  if call.value > tankName[_tankproductID << 224].field_768:\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - tankName[_tankproductID << 224].field_768\n  tankName[_tankproductID << 224].field_768 += tankName[_tankproductID << 224].field_1024\n  if uint32((-120 * howManyTanks) + (20 * howManyTanks * howManyTanks) + (-11 * howManyTanks * howManyTanks) + (howManyTanks * howManyTanks * howManyTanks) + -newIdTank - 100):\n      mem[384] = 0\n      mem[416] = 0\n      mem[448] = 0\n      mem[480] = 0\n      uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n      newIdTank = uint32(newIdTank + 1)\n      uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n      s = 0\n      idx = 384\n      while 512 > idx:\n          tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n          s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      s = sha3(uint32(stor3.field_0), 6) + 1\n      while idx:\n          stor[s] = !(255 * 256^idx) and stor[s]\n          idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n          s = (idx + 1 / 32) + s\n          continue \n  else:\n      if howManyTanks > 121:\n          mem[384] = 0\n          mem[416] = 0\n          mem[448] = 0\n          mem[480] = 0\n          uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n          newIdTank = uint32(newIdTank + 1)\n          uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n          s = 0\n          idx = 384\n          while 512 > idx:\n              tankDetails[uint32(stor3.field_0)].field_256 = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and tankDetails[uint32(stor3.field_0)].field_256\n              s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1\n              idx = idx + 32\n              continue \n          idx = 4\n          s = sha3(uint32(stor3.field_0), 6) + 1\n          while idx:\n              stor[s] = !(255 * 256^idx) and stor[s]\n              idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1\n              s = (idx + 1 / 32) + s\n              continue \n      else:\n          if createNewTankHull >= uint32(newIdTankHull - 1):\n              createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              if createNewTankHull == createNewTankWeapon:\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n          else:\n              if createNewTankWeapon < uint32(newIdTankWeapon - 1):\n                  createNewTankWeapon = uint32(createNewTankWeapon + 1)\n                  if createNewTankHull == createNewTankWeapon:\n                      createNewTankWeapon = uint32(createNewTankWeapon + 1)\n              else:\n                  uint8(stor4.field_96) = 1\n                  stor4.field_104 % unknown01000000() = 0\n                  createNewTankHull = uint32(createNewTankHull + 1)\n          howManyTanks = uint32(howManyTanks + 1)\n          bool(tankName[uint32(stor3.field_0)].field_0) = 0\n          uint255(tankName[uint32(stor3.field_0)].field_1) = 4\n          Mask(248, 0, tankName[uint32(stor3.field_0)].field_8) = 'Tank' / 256\n          idx = 0\n          while tankName[uint32(stor3.field_0)].length + 31 / 32 > idx:\n              tankName[uint32(stor3.field_0)][idx].field_0 = 0\n              idx = idx + 1\n              continue \n          uint32(tankName[uint32(stor3.field_0)].field_256) = createNewTankHull\n          uint32(tankName[uint32(stor3.field_0)].field_288) = createNewTankWeapon\n          tankName[uint32(stor3.field_0)].field_512 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_768 = 2 * 10^17\n          tankName[uint32(stor3.field_0)].field_1024 = 3 * 10^15\n          tankName[uint32(stor3.field_0)].field_1280 = block.timestamp + 3600\n          uint32(tankName[uint32(stor3.field_0)].field_1536) = 0\n          tankName[uint32(stor3.field_0)].field_1792 % 1 = 0\n          log EventProduct(uint32 productID, string name, uint32 hull, uint32 weapon, uint256 price, uint256 earning, uint256 releaseTime, uint256 currentTime):\n                           howManyTanks - 1 << 224,\n                           256,\n                           newIdTankHull,\n                           newIdTankHull,\n                           2 * 10^17,\n                           3 * 10^15,\n                           block.timestamp + 3600,\n                           block.timestamp,\n                           4,\n                           uint32('Tank'),\n          uint32(tankName[_tankproductID << 224].field_1536) = uint32(uint32(tankName[_tankproductID << 224].field_1536) + 1)\n          newIdTank = uint32(newIdTank + 1)\n          uint32(tankDetails[uint32(stor3.field_0)].field_0) = _tankproductID\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef bid(uint32 _tankID) payable: \n  require _tankID > 0\n  require _tankID < newIdTank\n  require bool(uint8(tankDetails[_tankID << 224].field_928)) == 1\n  require stor11[stor6[_tankID << 224].field_1024].field_1024\n  if stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) >= stor11[stor6[_tankID << 224].field_1024].field_512:\n      require stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) >= 0\n      require call.value >= stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024)\n      playerBalance[address(stor6[_tankID << 224].field_512)].field_0 = playerBalance[address(stor6[_tankID << 224].field_512)].field_0 + stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) - (3 * stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) / 100)\n      playerBalance[stor1].field_0 += 3 * stor11[stor6[_tankID << 224].field_1024].field_256 - (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) + (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) / 100\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - stor11[stor6[_tankID << 224].field_1024].field_256 + (block.timestamp * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024) - (stor11[stor6[_tankID << 224].field_1024].field_768 * stor11[stor6[_tankID << 224].field_1024].field_256 - stor11[stor6[_tankID << 224].field_1024].field_512 / stor11[stor6[_tankID << 224].field_1024].field_1024)\n  else:\n      require stor11[stor6[_tankID << 224].field_1024].field_512 >= 0\n      require call.value >= stor11[stor6[_tankID << 224].field_1024].field_512\n      playerBalance[address(stor6[_tankID << 224].field_512)].field_0 = playerBalance[address(stor6[_tankID << 224].field_512)].field_0 + stor11[stor6[_tankID << 224].field_1024].field_512 - (3 * stor11[stor6[_tankID << 224].field_1024].field_512 / 100)\n      playerBalance[stor1].field_0 += 3 * stor11[stor6[_tankID << 224].field_1024].field_512 / 100\n      playerBalance[caller].field_0 = playerBalance[caller].field_0 + call.value - stor11[stor6[_tankID << 224].field_1024].field_512\n  address(tankDetails[_tankID << 224].field_512) = caller\n  Mask(96, 0, tankDetails[_tankID << 224].field_928) = 0\n  uint32(stor11[stor6[_tankID << 224].field_1024].field_0) = 0\n  stor11[stor6[_tankID << 224].field_1024].field_256 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_512 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_768 = 0\n  stor11[stor6[_tankID << 224].field_1024].field_1024 = 0\n  tankDetails[_tankID << 224].field_1024 = 0\n  log EventBid(uint32 tankID=_tankID)\n\n.",
	"status": "1",
	"time_cost": 35.297181129455566,
	"usage": {
		"completion_tokens": 376,
		"prompt_tokens": 8989,
		"total_tokens": 9365
	}
}