{
	"address": "0x41a5b8aa081dcd69ace566061d5b6adcb92cae1c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a possible Solidity code interpretation of the given pseudocode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _makerFee;\n    uint256 private _takerFee;\n    uint256 private _inactivityReleasePeriod;\n    mapping (uint256 => uint256[]) private _approvedCurrencyTokens;\n    mapping (uint256 => uint256[]) private _invalidOrder;\n    mapping (uint256 => uint256[]) private _tokens;\n    mapping (uint256 => uint256[]) private _admins;\n    mapping (uint256 => uint256[]) private _lastActiveTransaction;\n    mapping (uint256 => uint256[]) private _orderFills;\n    mapping (uint256 => uint256[]) private _withdrawn;\n    address private _owner;\n    uint160 private _feeAccount;\n    mapping (uint256 => uint256[]) private _deposit;\n\n    event Withdraw(address indexed varg0, address indexed varg1, uint256 varg2, uint256 varg3);\n    event Deposit(address indexed varg0, address indexed varg1, uint256 varg2, uint256 varg3);\n    event MakerFeeUpdated(uint256 oldFee, uint256 newFee);\n    event Trade(address indexed varg0, uint256 varg1, address indexed varg2, uint256 varg3, address indexed varg4, address varg5);\n    event TakerFeeUpdated(uint256 oldFee, uint256 newFee);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    // Implement the functions according to the pseudocode\n}\n```\n\nPlease note that the pseudocode provided is a complex one and it seems to be a part of a decentralized exchange contract. Also, it uses a lot of low-level operations (like inline assembly, raw calls, etc) that do not have direct equivalents in high-level Solidity language. Therefore, it's hard to provide a direct interpretation without making assumptions about the logic of the contract. A complete and accurate interpretation of the pseudocode would require a deep understanding of the EVM and the contract's intended behavior.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460584,
	"id": "chatcmpl-8R3uaF4O3I8MHSNumcv8IzI2N63kA",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 08:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _makerFee; // STORAGE[0x2]\nuint256 _takerFee; // STORAGE[0x3]\nuint256 _inactivityReleasePeriod; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _approvedCurrencyTokens; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0x6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df]\n\n// Events\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\nMakerFeeUpdated(uint256, uint256);\nTrade(address, uint256, address, uint256, address, address);\nTakerFeeUpdated(uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg7 > 0x6a94d74f430000) {\n        v3 = v4 = 0x6a94d74f430000;\n    }\n    if (varg0) {\n        require(v3 <= _deposit[varg2]);\n        require(varg1 <= _tokens[varg2]);\n    } else {\n        v5 = _SafeAdd(varg1, v3);\n        require(_deposit[varg2] >= v5);\n    }\n    v6 = keccak256(this, varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v6]));\n    _withdrawn[v6] = 0x1 | ~0xff & _withdrawn[v6];\n    MEM[v7.data] = 0;\n    MEM[32 + v7.data] = keccak256('\\x19Ethereum Signed Message:\\n32', v6);\n    MEM[64 + v7.data] = varg4 & 0xff & 0xff;\n    MEM[v7.data + 96] = varg5;\n    MEM[v7.data + 128] = varg6;\n    v8 = ecrecover(MEM[(MEM[64]) len (160 + (v7.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n    require(v8); // checks call status, propagates error data on error\n    require(address(MEM[MEM[64] - 32]) == varg2);\n    if (varg0) {\n        require(varg1 <= _tokens[varg2]);\n        _tokens[varg2] = _tokens[varg2] - varg1;\n        require(v3 <= _deposit[varg2]);\n        _deposit[varg2] = _deposit[varg2] - v3;\n        v9 = _SafeAdd(v3, _deposit[_feeAccount]);\n        _deposit[_feeAccount] = v9;\n        require(varg0.code.size);\n        v10, v11 = varg0.transfer(varg2, varg1).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v11);\n    } else {\n        v12 = _SafeAdd(varg1, v3);\n        require(v12 <= _deposit[varg2]);\n        _deposit[varg2] = _deposit[varg2] - v12;\n        v13 = _SafeAdd(v3, _deposit[_feeAccount]);\n        _deposit[_feeAccount] = v13;\n        v14 = varg2.call().value(varg1).gas(2300 * !varg1);\n        require(v14); // checks call status, propagates error data on error\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, varg1, _lastActiveTransaction[varg0]);\n    return 1;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    0xbac(varg1, msg.sender, varg0);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction takerFee() public nonPayable { \n    return _takerFee;\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction approveCurrencyTokenAddress(address varg0, bool varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    _approvedCurrencyTokens[varg0] = varg1 | ~0xff & _approvedCurrencyTokens[varg0];\n}\n\nfunction receiveTokenDeposit(address varg0, address varg1, uint256 varg2) public nonPayable { \n    0xbac(varg2, varg1, varg0);\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction setMakerFee(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg0 > 0x2386f26fc10000) {\n        v3 = v4 = 0x2386f26fc10000;\n    }\n    require(v3 != _makerFee);\n    _makerFee = v3;\n    emit MakerFeeUpdated(_makerFee, v3);\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = MEM[64];\n    v0 = v2 = 405;\n    v3 = msg.data.length;\n    CALLDATACOPY(v1, 4, 352);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 356, 128);\n    v0 = v5 = MEM[64];\n    CALLDATACOPY(v5, 484, 64);\n    v0 = v6 = MEM[64];\n    CALLDATACOPY(v6, 548, 128);\n    v0 = v7 = 0;\n    v8 = v9 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v8 = v10 = 0xff & _admins[msg.sender];\n    }\n    require(v8);\n    v0 = v11 = MEM[v1 + 32];\n    v0 = v12 = 3797;\n    v0 = v13 = 3785;\n    v14 = v15 = 0xde0b6b3a7640000;\n    v16 = MEM[0 + v1];\n    while (1) {\n        if (v16) {\n            goto 0x230a0x390;\n        }\n        v17 = v18 = 0;\n        goto {'0x188a', '0x1992', '0x178a', '0x18d7', '0x1476', '0x14b3', '0xec9'};\n        while (!v0) {\n            assert(v0);\n            v19 = v20 = 7;\n            v21 = v22 = 0;\n            v23 = v24 = 7;\n            v25 = v26 = 0;\n            goto 0x14d10x390;\n            v27 = address(MEM[0 + v0]);\n            v28 = v29 = _tokens[v27];\n            goto 0x22c50x390;\n            v0 = v17 / v0;\n            goto {'0x17e8', '0x1b9d', '0xefd', '0x1841', '0x1c58', '0xf3b', '0x16e1', '0xed5', '0x1adb'};\n            v0 = v30 = 3849;\n            v0 = v31 = 0x186a0;\n            v0 = v32 = 3837;\n            v0 = v33 = MEM[256 + v0];\n            if (MEM[224 + v0]) {\n                v17 = v34 = 0xde0b6b3a7640000 * MEM[224 + v0];\n                assert(MEM[224 + v0]);\n                require(v34 / MEM[224 + v0] == 0xde0b6b3a7640000);\n            } else {\n                v17 = v35 = 0;\n            }\n            goto 0xec9;\n            require(v0 <= v0);\n            require(v0 >= v0 - v0);\n            v0 = v36 = 3911;\n            v0 = v37 = 0x186a0;\n            v0 = v38 = 3899;\n            v0 = v39 = MEM[96 + v0];\n            if (MEM[128 + v0]) {\n                v17 = v40 = 0xde0b6b3a7640000 * MEM[128 + v0];\n                assert(MEM[128 + v0]);\n                require(v40 / MEM[128 + v0] == 0xde0b6b3a7640000);\n            } else {\n                v17 = v41 = 0;\n            }\n            goto 0xec9;\n            v42 = _SafeAdd(v0, v0);\n            require(v0 <= v42);\n            require(block.number < MEM[v0 + 288]);\n            require(block.number < MEM[v0 + 160]);\n            v43 = address(MEM[64 + v0]);\n            require(_invalidOrder[v43] <= MEM[v0 + 64]);\n            v44 = address(MEM[v0 + 96]);\n            require(_invalidOrder[v44] <= MEM[v0 + 192]);\n            v0 = v45 = keccak256(address(this), address(MEM[0 + v0]), MEM[224 + v0], address(MEM[32 + v0]), MEM[256 + v0], MEM[288 + v0], MEM[64 + v0], address(MEM[64 + v0]));\n            v0 = v46 = keccak256(address(this), address(MEM[32 + v0]), MEM[96 + v0], address(MEM[0 + v0]), MEM[128 + v0], MEM[160 + v0], MEM[192 + v0], address(MEM[96 + v0]));\n            v47 = MEM[0 + v0] & 0xff;\n            v48 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v45), v47, MEM[0 + v0], MEM[32 + v0], MEM[32 + v0], address(MEM[96 + v0]) << 96);\n            require(v48); // checks call status, propagates error data on error\n            require(0 == address(MEM[64 + v0]));\n            MEM[v49.data] = 0;\n            MEM[v49.data + 32] = keccak256('\\x19Ethereum Signed Message:\\n32', v46);\n            v50 = MEM[32 + v0] & 0xff;\n            MEM[64 + v49.data] = v50;\n            MEM[v49.data + 96] = MEM[64 + v0];\n            MEM[v49.data + 128] = MEM[96 + v0];\n            v51 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v46), v50, MEM[64 + v0], MEM[96 + v0]);\n            require(v51); // checks call status, propagates error data on error\n            require(address(MEM[MEM[64] - 32]) == address(MEM[96 + v0]));\n            require(_tokens[address(MEM[v0 + 96])] >= MEM[v0]);\n            require(_tokens[address(MEM[v0 + 64])] >= MEM[32 + v0]);\n            v52 = v53 = !address(MEM[v0]);\n            if (address(MEM[v0])) {\n                v52 = v54 = !address(MEM[v0 + 32]);\n            }\n            if (v52) {\n                v52 = v55 = 0x6a94d74f430000 < MEM[v0 + 320];\n            }\n            if (v52) {\n                MEM[v0 + 320] = 0x6a94d74f430000;\n            }\n            v56 = address(MEM[v0]);\n            v57 = v58 = 1 == 0xff & _approvedCurrencyTokens[v56];\n            if (1 != 0xff & _approvedCurrencyTokens[v56]) {\n                v59 = address(MEM[v0 + 32]);\n                v57 = v60 = 1 == 0xff & _approvedCurrencyTokens[v59];\n            }\n            if (v57) {\n                v57 = v61 = 0x8ac7230489e80000 < MEM[v0 + 320];\n            }\n            if (v57) {\n                MEM[v0 + 320] = 0x8ac7230489e80000;\n            }\n            v62 = v63 = !address(MEM[v0]);\n            if (address(MEM[v0])) {\n                v64 = address(MEM[v0]);\n                v62 = v65 = 1 == 0xff & _approvedCurrencyTokens[v64];\n            }\n            if (!v62) {\n                require(MEM[0 + v0] + _orderFills[v45] >= _orderFills[v45]);\n                require(MEM[0 + v0] + _orderFills[v45] <= MEM[v0 + 224]);\n                require(MEM[0 + v0] + _orderFills[v46] >= _orderFills[v46]);\n                require(MEM[0 + v0] + _orderFills[v46] <= MEM[v0 + 128]);\n                v0 = v66 = MEM[v0 + 32];\n                require(MEM[0 + v0] <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))]);\n                _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))] - MEM[0 + v0];\n                v67 = MEM[0 + v0] + STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))];\n                require(v67 >= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))]);\n                _tokens[address(MEM[64 + v0])] = v67;\n                require(v0 <= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n                _tokens[address(MEM[v0 + 64])] = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n                v0 = v68 = 6887;\n                v0 = v69 = 6875;\n                v0 = v70 = 0xde0b6b3a7640000;\n                if (_makerFee) {\n                    v17 = v0 * _makerFee;\n                    assert(_makerFee);\n                    require(v17 / _makerFee == v0);\n                } else {\n                    v17 = v71 = 0;\n                }\n                goto 0xec9;\n            } else {\n                v0 = v72 = MEM[v0 + 256];\n                v0 = v73 = 5238;\n                v0 = v74 = MEM[32 + v0];\n                v28 = _orderFills[v45];\n            }\n            require(v0 <= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[64 + v0])] = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n            v75 = v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))];\n            require(v75 >= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[v0 + 96])] = v75;\n            v0 = v76 = 7081;\n            v0 = v77 = 7069;\n            v0 = v78 = 0xde0b6b3a7640000;\n            if (_takerFee) {\n                v17 = v0 * _takerFee;\n                assert(_takerFee);\n                require(v17 / _takerFee == v0);\n            } else {\n                v17 = v79 = 0;\n            }\n            goto 0xec9;\n            require(v0 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[96 + v0])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n            v80 = MEM[320 + v0];\n            require(v80 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v80;\n            v0 = v81 = 7268;\n            v0 = v82 = 7256;\n            v0 = v83 = 0xde0b6b3a7640000;\n            if (_makerFee) {\n                v17 = v0 * _makerFee;\n                assert(_makerFee);\n                require(v17 / _makerFee == v0);\n            } else {\n                v17 = v84 = 0;\n            }\n            goto 0xec9;\n            v85 = address(MEM[32 + v0]);\n            require(v0 + _tokens[_feeAccount] >= _tokens[_feeAccount]);\n            goto {'0x1cb1', '0x1c64'};\n            v86 = address(MEM[v0 + 32]);\n            _tokens[_feeAccount] += v0;\n            v0 = v87 = 7345;\n            v0 = v88 = 7256;\n            v0 = v89 = 0xde0b6b3a7640000;\n            if (_takerFee) {\n                v17 = v0 * _takerFee;\n                assert(_takerFee);\n                require(v17 / _takerFee == v0);\n            } else {\n                v17 = v90 = 0;\n            }\n            goto 0xec9;\n            _tokens[_feeAccount] += v0;\n            v91 = MEM[v0 + 320] + _tokens[_feeAccount];\n            require(v91 >= _tokens[_feeAccount]);\n            v92 = address(MEM[v0 + 32]);\n            _tokens[_feeAccount] = v91;\n            v93 = MEM[0 + v0] + _orderFills[v0];\n            require(v93 >= _orderFills[v0]);\n            _orderFills[v0] = v93;\n            v94 = MEM[0 + v0] + _orderFills[v0];\n            require(v94 >= _orderFills[v0]);\n            _orderFills[v0] = v94;\n        }\n        MEM[v21] = address(MEM[(v21 << 5) + v0]);\n        MEM[32 + v21] = v19;\n        v95 = v96 = keccak256(MEM[0 len (64 + v21)]);\n        v97 = v98 = 0;\n        v99 = v100 = 3;\n        goto 0x15070x390;\n        require(v17 <= v0);\n        v0 = v101 = MEM[v0 + 96];\n        v0 = v102 = 5299;\n        v0 = v103 = MEM[32 + v0];\n        v28 = v104 = _orderFills[v0];\n        v17 = v0 + v28;\n        require(v17 >= v28);\n        require(v17 <= v0);\n        v0 = v105 = MEM[v0 + 32];\n        v0 = v106 = 5435;\n        v23 = v107 = 7;\n        v25 = v108 = 0;\n        v25 = v109 = 1;\n        MEM[v25] = address(MEM[(v25 << 5) + v0]);\n        MEM[32 + v25] = v23;\n        v95 = keccak256(MEM[0 len (64 + v25)]);\n        v97 = v110 = 0;\n        v99 = v111 = 2;\n        MEM[v97] = address(MEM[(v99 << 5) + v0]);\n        MEM[32 + v97] = v95;\n        require(v0 <= STORAGE[keccak256(MEM[0 len (64 + v97)])]);\n        goto {'0x1682', '0x17f3', '0x16ec', '0x153b'};\n        _tokens[address(MEM[64 + v0])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        require(v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] >= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n        _tokens[address(MEM[v0 + 96])] = v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))];\n        v0 = v112 = 5762;\n        v0 = MEM[0 + v0];\n        v19 = v113 = 7;\n        v21 = v114 = 0;\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v0 = v115 = 5868;\n        v0 = v116 = 5857;\n        v0 = v117 = 0xde0b6b3a7640000;\n        v0 = v118 = 3785;\n        v14 = MEM[0 + v0];\n        v16 = v119 = _takerFee;\n        continue;\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v120 = MEM[320 + v0];\n        require(v120 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))]);\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))] - v120;\n        v0 = v121 = 6026;\n        v0 = v122 = MEM[0 + v0];\n        v28 = v123 = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))];\n        goto 0x22c50x390;\n        _tokens[address(MEM[v0 + 64])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v0 = v124 = 6282;\n        v0 = v125 = 6209;\n        v0 = v126 = 0xde0b6b3a7640000;\n        v127 = MEM[0 + v0];\n        if (_makerFee) {\n            v17 = v128 = v127 * _makerFee;\n            assert(_makerFee);\n            require(v128 / _makerFee == v127);\n        } else {\n            v17 = v129 = 0;\n        }\n        goto 0xec9;\n        _tokens[address(MEM[v0 + 64])] = v17;\n        v0 = v130 = 6131;\n        v0 = v131 = 6120;\n        v0 = v132 = 0xde0b6b3a7640000;\n        v0 = v133 = 3785;\n        v14 = v134 = MEM[0 + v0];\n        v16 = v135 = _makerFee;\n        continue;\n        v136 = address(MEM[v0]);\n        _tokens[_feeAccount] = v17;\n        v0 = v137 = 6359;\n        v0 = v138 = 6209;\n        v0 = v139 = 0xde0b6b3a7640000;\n        v140 = MEM[0 + v0];\n        if (_takerFee) {\n            v17 = v141 = v140 * _takerFee;\n            assert(_takerFee);\n            require(v141 / _takerFee == v140);\n        } else {\n            v17 = v142 = 0;\n        }\n        goto 0xec9;\n        _tokens[_feeAccount] = v17;\n        v143 = MEM[v0 + 320] + _tokens[_feeAccount];\n        require(v143 >= _tokens[_feeAccount]);\n        v144 = address(MEM[v0]);\n        _tokens[_feeAccount] = v143;\n        v145 = MEM[32 + v0] + _orderFills[v0];\n        require(v145 >= _orderFills[v0]);\n        _orderFills[v0] = v145;\n        v0 = v146 = 6546;\n        v0 = v147 = MEM[32 + v0];\n        v28 = v148 = _orderFills[v0];\n        v17 = v149 = v14 * v16;\n        assert(v16);\n        require(v149 / v16 == v14);\n    }\n    _orderFills[v0] = v17;\n    _lastActiveTransaction[address(MEM[64 + v0])] = block.number;\n    _lastActiveTransaction[address(MEM[v0 + 96])] = block.number;\n    emit Trade(address(MEM[0 + v0]), MEM[0 + v0], address(MEM[32 + v0]), MEM[32 + v0], address(MEM[64 + v0]), address(MEM[96 + v0]));\n    return 1;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[32] = 0x6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction approvedCurrencyTokens(address varg0) public nonPayable { \n    return 0xff & _approvedCurrencyTokens[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    require(varg0 <= 50000);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction setTakerFee(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg0 > 0x470de4df820000) {\n        v3 = v4 = 0x470de4df820000;\n    }\n    require(v3 != _takerFee);\n    _takerFee = v3;\n    emit TakerFeeUpdated(_takerFee, v3);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_lastActiveTransaction[msg.sender] <= block.number);\n    require(block.number - _lastActiveTransaction[msg.sender] >= _inactivityReleasePeriod);\n    require(varg1 <= _tokens[msg.sender]);\n    require(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    if (varg0) {\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v2); // checks call status, propagates error data on error\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 1;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction makerFee() public nonPayable { \n    return _makerFee;\n}\n\nfunction 0xbac(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = address(varg1);\n    v2 = _SafeAdd(varg0, _tokens[v1]);\n    v3 = address(varg2);\n    v4 = address(varg1);\n    _tokens[v4] = v2;\n    _lastActiveTransaction[v4] = block.number;\n    require(v3.code.size);\n    v5, v6 = v3.transferFrom(v4, this, varg0).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6);\n    v7 = address(varg2);\n    v8 = address(varg1);\n    emit Deposit(v7, v8, varg0, _tokens[v8]);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x2295115b) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == function_selector) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == function_selector) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == function_selector) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == function_selector) {\n            admins(address);\n        } else if (0x43f0179b == function_selector) {\n            takerFee();\n        } else if (0x4b0bddd2 == function_selector) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == function_selector) {\n            tokens(address,address);\n        } else if (0x65e17c9d == function_selector) {\n            feeAccount();\n        } else if (0x7ca1cb48 == function_selector) {\n            approveCurrencyTokenAddress(address,bool);\n        } else if (0x8192433f == function_selector) {\n            receiveTokenDeposit(address,address,uint256);\n        } else if (0x83dbb27b == function_selector) {\n            invalidOrder(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xb12de559 == function_selector) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xb8bd3dbb == function_selector) {\n            setMakerFee(uint256);\n        } else if (0xc1204caa == function_selector) {\n            trade(uint256[11],address[4],uint8[2],bytes32[4]);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xd6d7479d == function_selector) {\n            approvedCurrencyTokens(address);\n        } else if (0xdd93c74a == function_selector) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xf1cca8aa == function_selector) {\n            setTakerFee(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf31174ee == function_selector) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == function_selector) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xfc741c7c == function_selector) {\n            makerFee();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 08:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _makerFee; // STORAGE[0x2]\nuint256 _takerFee; // STORAGE[0x3]\nuint256 _inactivityReleasePeriod; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _approvedCurrencyTokens; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0x6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df]\n\n// Events\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\nMakerFeeUpdated(uint256, uint256);\nTrade(address, uint256, address, uint256, address, address);\nTakerFeeUpdated(uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg7 > 0x6a94d74f430000) {\n        v3 = v4 = 0x6a94d74f430000;\n    }\n    if (varg0) {\n        require(v3 <= _deposit[varg2]);\n        require(varg1 <= _tokens[varg2]);\n    } else {\n        v5 = _SafeAdd(varg1, v3);\n        require(_deposit[varg2] >= v5);\n    }\n    v6 = keccak256(this, varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v6]));\n    _withdrawn[v6] = 0x1 | ~0xff & _withdrawn[v6];\n    MEM[v7.data] = 0;\n    MEM[32 + v7.data] = keccak256('\\x19Ethereum Signed Message:\\n32', v6);\n    MEM[64 + v7.data] = varg4 & 0xff & 0xff;\n    MEM[v7.data + 96] = varg5;\n    MEM[v7.data + 128] = varg6;\n    v8 = ecrecover(MEM[(MEM[64]) len (160 + (v7.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n    require(v8); // checks call status, propagates error data on error\n    require(address(MEM[MEM[64] - 32]) == varg2);\n    if (varg0) {\n        require(varg1 <= _tokens[varg2]);\n        _tokens[varg2] = _tokens[varg2] - varg1;\n        require(v3 <= _deposit[varg2]);\n        _deposit[varg2] = _deposit[varg2] - v3;\n        v9 = _SafeAdd(v3, _deposit[_feeAccount]);\n        _deposit[_feeAccount] = v9;\n        require(varg0.code.size);\n        v10, v11 = varg0.transfer(varg2, varg1).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v11);\n    } else {\n        v12 = _SafeAdd(varg1, v3);\n        require(v12 <= _deposit[varg2]);\n        _deposit[varg2] = _deposit[varg2] - v12;\n        v13 = _SafeAdd(v3, _deposit[_feeAccount]);\n        _deposit[_feeAccount] = v13;\n        v14 = varg2.call().value(varg1).gas(2300 * !varg1);\n        require(v14); // checks call status, propagates error data on error\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, varg1, _lastActiveTransaction[varg0]);\n    return 1;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    0xbac(varg1, msg.sender, varg0);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction takerFee() public nonPayable { \n    return _takerFee;\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction approveCurrencyTokenAddress(address varg0, bool varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    _approvedCurrencyTokens[varg0] = varg1 | ~0xff & _approvedCurrencyTokens[varg0];\n}\n\nfunction receiveTokenDeposit(address varg0, address varg1, uint256 varg2) public nonPayable { \n    0xbac(varg2, varg1, varg0);\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction setMakerFee(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg0 > 0x2386f26fc10000) {\n        v3 = v4 = 0x2386f26fc10000;\n    }\n    require(v3 != _makerFee);\n    _makerFee = v3;\n    emit MakerFeeUpdated(_makerFee, v3);\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = MEM[64];\n    v0 = v2 = 405;\n    v3 = msg.data.length;\n    CALLDATACOPY(v1, 4, 352);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 356, 128);\n    v0 = v5 = MEM[64];\n    CALLDATACOPY(v5, 484, 64);\n    v0 = v6 = MEM[64];\n    CALLDATACOPY(v6, 548, 128);\n    v0 = v7 = 0;\n    v8 = v9 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v8 = v10 = 0xff & _admins[msg.sender];\n    }\n    require(v8);\n    v0 = v11 = MEM[v1 + 32];\n    v0 = v12 = 3797;\n    v0 = v13 = 3785;\n    v14 = v15 = 0xde0b6b3a7640000;\n    v16 = MEM[0 + v1];\n    while (1) {\n        if (v16) {\n            goto 0x230a0x390;\n        }\n        v17 = v18 = 0;\n        goto {'0x188a', '0x1992', '0x178a', '0x18d7', '0x1476', '0x14b3', '0xec9'};\n        while (!v0) {\n            assert(v0);\n            v19 = v20 = 7;\n            v21 = v22 = 0;\n            v23 = v24 = 7;\n            v25 = v26 = 0;\n            goto 0x14d10x390;\n            v27 = address(MEM[0 + v0]);\n            v28 = v29 = _tokens[v27];\n            goto 0x22c50x390;\n            v0 = v17 / v0;\n            goto {'0x17e8', '0x1b9d', '0xefd', '0x1841', '0x1c58', '0xf3b', '0x16e1', '0xed5', '0x1adb'};\n            v0 = v30 = 3849;\n            v0 = v31 = 0x186a0;\n            v0 = v32 = 3837;\n            v0 = v33 = MEM[256 + v0];\n            if (MEM[224 + v0]) {\n                v17 = v34 = 0xde0b6b3a7640000 * MEM[224 + v0];\n                assert(MEM[224 + v0]);\n                require(v34 / MEM[224 + v0] == 0xde0b6b3a7640000);\n            } else {\n                v17 = v35 = 0;\n            }\n            goto 0xec9;\n            require(v0 <= v0);\n            require(v0 >= v0 - v0);\n            v0 = v36 = 3911;\n            v0 = v37 = 0x186a0;\n            v0 = v38 = 3899;\n            v0 = v39 = MEM[96 + v0];\n            if (MEM[128 + v0]) {\n                v17 = v40 = 0xde0b6b3a7640000 * MEM[128 + v0];\n                assert(MEM[128 + v0]);\n                require(v40 / MEM[128 + v0] == 0xde0b6b3a7640000);\n            } else {\n                v17 = v41 = 0;\n            }\n            goto 0xec9;\n            v42 = _SafeAdd(v0, v0);\n            require(v0 <= v42);\n            require(block.number < MEM[v0 + 288]);\n            require(block.number < MEM[v0 + 160]);\n            v43 = address(MEM[64 + v0]);\n            require(_invalidOrder[v43] <= MEM[v0 + 64]);\n            v44 = address(MEM[v0 + 96]);\n            require(_invalidOrder[v44] <= MEM[v0 + 192]);\n            v0 = v45 = keccak256(address(this), address(MEM[0 + v0]), MEM[224 + v0], address(MEM[32 + v0]), MEM[256 + v0], MEM[288 + v0], MEM[64 + v0], address(MEM[64 + v0]));\n            v0 = v46 = keccak256(address(this), address(MEM[32 + v0]), MEM[96 + v0], address(MEM[0 + v0]), MEM[128 + v0], MEM[160 + v0], MEM[192 + v0], address(MEM[96 + v0]));\n            v47 = MEM[0 + v0] & 0xff;\n            v48 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v45), v47, MEM[0 + v0], MEM[32 + v0], MEM[32 + v0], address(MEM[96 + v0]) << 96);\n            require(v48); // checks call status, propagates error data on error\n            require(0 == address(MEM[64 + v0]));\n            MEM[v49.data] = 0;\n            MEM[v49.data + 32] = keccak256('\\x19Ethereum Signed Message:\\n32', v46);\n            v50 = MEM[32 + v0] & 0xff;\n            MEM[64 + v49.data] = v50;\n            MEM[v49.data + 96] = MEM[64 + v0];\n            MEM[v49.data + 128] = MEM[96 + v0];\n            v51 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v46), v50, MEM[64 + v0], MEM[96 + v0]);\n            require(v51); // checks call status, propagates error data on error\n            require(address(MEM[MEM[64] - 32]) == address(MEM[96 + v0]));\n            require(_tokens[address(MEM[v0 + 96])] >= MEM[v0]);\n            require(_tokens[address(MEM[v0 + 64])] >= MEM[32 + v0]);\n            v52 = v53 = !address(MEM[v0]);\n            if (address(MEM[v0])) {\n                v52 = v54 = !address(MEM[v0 + 32]);\n            }\n            if (v52) {\n                v52 = v55 = 0x6a94d74f430000 < MEM[v0 + 320];\n            }\n            if (v52) {\n                MEM[v0 + 320] = 0x6a94d74f430000;\n            }\n            v56 = address(MEM[v0]);\n            v57 = v58 = 1 == 0xff & _approvedCurrencyTokens[v56];\n            if (1 != 0xff & _approvedCurrencyTokens[v56]) {\n                v59 = address(MEM[v0 + 32]);\n                v57 = v60 = 1 == 0xff & _approvedCurrencyTokens[v59];\n            }\n            if (v57) {\n                v57 = v61 = 0x8ac7230489e80000 < MEM[v0 + 320];\n            }\n            if (v57) {\n                MEM[v0 + 320] = 0x8ac7230489e80000;\n            }\n            v62 = v63 = !address(MEM[v0]);\n            if (address(MEM[v0])) {\n                v64 = address(MEM[v0]);\n                v62 = v65 = 1 == 0xff & _approvedCurrencyTokens[v64];\n            }\n            if (!v62) {\n                require(MEM[0 + v0] + _orderFills[v45] >= _orderFills[v45]);\n                require(MEM[0 + v0] + _orderFills[v45] <= MEM[v0 + 224]);\n                require(MEM[0 + v0] + _orderFills[v46] >= _orderFills[v46]);\n                require(MEM[0 + v0] + _orderFills[v46] <= MEM[v0 + 128]);\n                v0 = v66 = MEM[v0 + 32];\n                require(MEM[0 + v0] <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))]);\n                _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))] - MEM[0 + v0];\n                v67 = MEM[0 + v0] + STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))];\n                require(v67 >= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))]);\n                _tokens[address(MEM[64 + v0])] = v67;\n                require(v0 <= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n                _tokens[address(MEM[v0 + 64])] = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n                v0 = v68 = 6887;\n                v0 = v69 = 6875;\n                v0 = v70 = 0xde0b6b3a7640000;\n                if (_makerFee) {\n                    v17 = v0 * _makerFee;\n                    assert(_makerFee);\n                    require(v17 / _makerFee == v0);\n                } else {\n                    v17 = v71 = 0;\n                }\n                goto 0xec9;\n            } else {\n                v0 = v72 = MEM[v0 + 256];\n                v0 = v73 = 5238;\n                v0 = v74 = MEM[32 + v0];\n                v28 = _orderFills[v45];\n            }\n            require(v0 <= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[64 + v0])] = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n            v75 = v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))];\n            require(v75 >= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[v0 + 96])] = v75;\n            v0 = v76 = 7081;\n            v0 = v77 = 7069;\n            v0 = v78 = 0xde0b6b3a7640000;\n            if (_takerFee) {\n                v17 = v0 * _takerFee;\n                assert(_takerFee);\n                require(v17 / _takerFee == v0);\n            } else {\n                v17 = v79 = 0;\n            }\n            goto 0xec9;\n            require(v0 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[96 + v0])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n            v80 = MEM[320 + v0];\n            require(v80 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v80;\n            v0 = v81 = 7268;\n            v0 = v82 = 7256;\n            v0 = v83 = 0xde0b6b3a7640000;\n            if (_makerFee) {\n                v17 = v0 * _makerFee;\n                assert(_makerFee);\n                require(v17 / _makerFee == v0);\n            } else {\n                v17 = v84 = 0;\n            }\n            goto 0xec9;\n            v85 = address(MEM[32 + v0]);\n            require(v0 + _tokens[_feeAccount] >= _tokens[_feeAccount]);\n            goto {'0x1cb1', '0x1c64'};\n            v86 = address(MEM[v0 + 32]);\n            _tokens[_feeAccount] += v0;\n            v0 = v87 = 7345;\n            v0 = v88 = 7256;\n            v0 = v89 = 0xde0b6b3a7640000;\n            if (_takerFee) {\n                v17 = v0 * _takerFee;\n                assert(_takerFee);\n                require(v17 / _takerFee == v0);\n            } else {\n                v17 = v90 = 0;\n            }\n            goto 0xec9;\n            _tokens[_feeAccount] += v0;\n            v91 = MEM[v0 + 320] + _tokens[_feeAccount];\n            require(v91 >= _tokens[_feeAccount]);\n            v92 = address(MEM[v0 + 32]);\n            _tokens[_feeAccount] = v91;\n            v93 = MEM[0 + v0] + _orderFills[v0];\n            require(v93 >= _orderFills[v0]);\n            _orderFills[v0] = v93;\n            v94 = MEM[0 + v0] + _orderFills[v0];\n            require(v94 >= _orderFills[v0]);\n            _orderFills[v0] = v94;\n        }\n        MEM[v21] = address(MEM[(v21 << 5) + v0]);\n        MEM[32 + v21] = v19;\n        v95 = v96 = keccak256(MEM[0 len (64 + v21)]);\n        v97 = v98 = 0;\n        v99 = v100 = 3;\n        goto 0x15070x390;\n        require(v17 <= v0);\n        v0 = v101 = MEM[v0 + 96];\n        v0 = v102 = 5299;\n        v0 = v103 = MEM[32 + v0];\n        v28 = v104 = _orderFills[v0];\n        v17 = v0 + v28;\n        require(v17 >= v28);\n        require(v17 <= v0);\n        v0 = v105 = MEM[v0 + 32];\n        v0 = v106 = 5435;\n        v23 = v107 = 7;\n        v25 = v108 = 0;\n        v25 = v109 = 1;\n        MEM[v25] = address(MEM[(v25 << 5) + v0]);\n        MEM[32 + v25] = v23;\n        v95 = keccak256(MEM[0 len (64 + v25)]);\n        v97 = v110 = 0;\n        v99 = v111 = 2;\n        MEM[v97] = address(MEM[(v99 << 5) + v0]);\n        MEM[32 + v97] = v95;\n        require(v0 <= STORAGE[keccak256(MEM[0 len (64 + v97)])]);\n        goto {'0x1682', '0x17f3', '0x16ec', '0x153b'};\n        _tokens[address(MEM[64 + v0])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        require(v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] >= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n        _tokens[address(MEM[v0 + 96])] = v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))];\n        v0 = v112 = 5762;\n        v0 = MEM[0 + v0];\n        v19 = v113 = 7;\n        v21 = v114 = 0;\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v0 = v115 = 5868;\n        v0 = v116 = 5857;\n        v0 = v117 = 0xde0b6b3a7640000;\n        v0 = v118 = 3785;\n        v14 = MEM[0 + v0];\n        v16 = v119 = _takerFee;\n        continue;\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v120 = MEM[320 + v0];\n        require(v120 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))]);\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))] - v120;\n        v0 = v121 = 6026;\n        v0 = v122 = MEM[0 + v0];\n        v28 = v123 = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))];\n        goto 0x22c50x390;\n        _tokens[address(MEM[v0 + 64])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v0 = v124 = 6282;\n        v0 = v125 = 6209;\n        v0 = v126 = 0xde0b6b3a7640000;\n        v127 = MEM[0 + v0];\n        if (_makerFee) {\n            v17 = v128 = v127 * _makerFee;\n            assert(_makerFee);\n            require(v128 / _makerFee == v127);\n        } else {\n            v17 = v129 = 0;\n        }\n        goto 0xec9;\n        _tokens[address(MEM[v0 + 64])] = v17;\n        v0 = v130 = 6131;\n        v0 = v131 = 6120;\n        v0 = v132 = 0xde0b6b3a7640000;\n        v0 = v133 = 3785;\n        v14 = v134 = MEM[0 + v0];\n        v16 = v135 = _makerFee;\n        continue;\n        v136 = address(MEM[v0]);\n        _tokens[_feeAccount] = v17;\n        v0 = v137 = 6359;\n        v0 = v138 = 6209;\n        v0 = v139 = 0xde0b6b3a7640000;\n        v140 = MEM[0 + v0];\n        if (_takerFee) {\n            v17 = v141 = v140 * _takerFee;\n            assert(_takerFee);\n            require(v141 / _takerFee == v140);\n        } else {\n            v17 = v142 = 0;\n        }\n        goto 0xec9;\n        _tokens[_feeAccount] = v17;\n        v143 = MEM[v0 + 320] + _tokens[_feeAccount];\n        require(v143 >= _tokens[_feeAccount]);\n        v144 = address(MEM[v0]);\n        _tokens[_feeAccount] = v143;\n        v145 = MEM[32 + v0] + _orderFills[v0];\n        require(v145 >= _orderFills[v0]);\n        _orderFills[v0] = v145;\n        v0 = v146 = 6546;\n        v0 = v147 = MEM[32 + v0];\n        v28 = v148 = _orderFills[v0];\n        v17 = v149 = v14 * v16;\n        assert(v16);\n        require(v149 / v16 == v14);\n    }\n    _orderFills[v0] = v17;\n    _lastActiveTransaction[address(MEM[64 + v0])] = block.number;\n    _lastActiveTransaction[address(MEM[v0 + 96])] = block.number;\n    emit Trade(address(MEM[0 + v0]), MEM[0 + v0], address(MEM[32 + v0]), MEM[32 + v0], address(MEM[64 + v0]), address(MEM[96 + v0]));\n    return 1;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[32] = 0x6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction approvedCurrencyTokens(address varg0) public nonPayable { \n    return 0xff & _approvedCurrencyTokens[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    require(varg0 <= 50000);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction setTakerFee(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg0 > 0x470de4df820000) {\n        v3 = v4 = 0x470de4df820000;\n    }\n    require(v3 != _takerFee);\n    _takerFee = v3;\n    emit TakerFeeUpdated(_takerFee, v3);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_lastActiveTransaction[msg.sender] <= block.number);\n    require(block.number - _lastActiveTransaction[msg.sender] >= _inactivityReleasePeriod);\n    require(varg1 <= _tokens[msg.sender]);\n    require(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    if (varg0) {\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v2); // checks call status, propagates error data on error\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 1;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction makerFee() public nonPayable { \n    return _makerFee;\n}\n\nfunction 0xbac(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = address(varg1);\n    v2 = _SafeAdd(varg0, _tokens[v1]);\n    v3 = address(varg2);\n    v4 = address(varg1);\n    _tokens[v4] = v2;\n    _lastActiveTransaction[v4] = block.number;\n    require(v3.code.size);\n    v5, v6 = v3.transferFrom(v4, this, varg0).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6);\n    v7 = address(varg2);\n    v8 = address(varg1);\n    emit Deposit(v7, v8, varg0, _tokens[v8]);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x2295115b) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == function_selector) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == function_selector) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == function_selector) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == function_selector) {\n            admins(address);\n        } else if (0x43f0179b == function_selector) {\n            takerFee();\n        } else if (0x4b0bddd2 == function_selector) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == function_selector) {\n            tokens(address,address);\n        } else if (0x65e17c9d == function_selector) {\n            feeAccount();\n        } else if (0x7ca1cb48 == function_selector) {\n            approveCurrencyTokenAddress(address,bool);\n        } else if (0x8192433f == function_selector) {\n            receiveTokenDeposit(address,address,uint256);\n        } else if (0x83dbb27b == function_selector) {\n            invalidOrder(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xb12de559 == function_selector) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xb8bd3dbb == function_selector) {\n            setMakerFee(uint256);\n        } else if (0xc1204caa == function_selector) {\n            trade(uint256[11],address[4],uint8[2],bytes32[4]);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xd6d7479d == function_selector) {\n            approvedCurrencyTokens(address);\n        } else if (0xdd93c74a == function_selector) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xf1cca8aa == function_selector) {\n            setTakerFee(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf31174ee == function_selector) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == function_selector) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xfc741c7c == function_selector) {\n            makerFee();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 08:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _makerFee; // STORAGE[0x2]\nuint256 _takerFee; // STORAGE[0x3]\nuint256 _inactivityReleasePeriod; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _approvedCurrencyTokens; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0xb]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0x6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df]\n\n// Events\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\nMakerFeeUpdated(uint256, uint256);\nTrade(address, uint256, address, uint256, address, address);\nTakerFeeUpdated(uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg7 > 0x6a94d74f430000) {\n        v3 = v4 = 0x6a94d74f430000;\n    }\n    if (varg0) {\n        require(v3 <= _deposit[varg2]);\n        require(varg1 <= _tokens[varg2]);\n    } else {\n        v5 = _SafeAdd(varg1, v3);\n        require(_deposit[varg2] >= v5);\n    }\n    v6 = keccak256(this, varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v6]));\n    _withdrawn[v6] = 0x1 | ~0xff & _withdrawn[v6];\n    MEM[v7.data] = 0;\n    MEM[32 + v7.data] = keccak256('\\x19Ethereum Signed Message:\\n32', v6);\n    MEM[64 + v7.data] = varg4 & 0xff & 0xff;\n    MEM[v7.data + 96] = varg5;\n    MEM[v7.data + 128] = varg6;\n    v8 = ecrecover(MEM[(MEM[64]) len (160 + (v7.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n    require(v8); // checks call status, propagates error data on error\n    require(address(MEM[MEM[64] - 32]) == varg2);\n    if (varg0) {\n        require(varg1 <= _tokens[varg2]);\n        _tokens[varg2] = _tokens[varg2] - varg1;\n        require(v3 <= _deposit[varg2]);\n        _deposit[varg2] = _deposit[varg2] - v3;\n        v9 = _SafeAdd(v3, _deposit[_feeAccount]);\n        _deposit[_feeAccount] = v9;\n        require(varg0.code.size);\n        v10, v11 = varg0.transfer(varg2, varg1).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v11);\n    } else {\n        v12 = _SafeAdd(varg1, v3);\n        require(v12 <= _deposit[varg2]);\n        _deposit[varg2] = _deposit[varg2] - v12;\n        v13 = _SafeAdd(v3, _deposit[_feeAccount]);\n        _deposit[_feeAccount] = v13;\n        v14 = varg2.call().value(varg1).gas(2300 * !varg1);\n        require(v14); // checks call status, propagates error data on error\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, varg1, _lastActiveTransaction[varg0]);\n    return 1;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    0xbac(varg1, msg.sender, varg0);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction takerFee() public nonPayable { \n    return _takerFee;\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction approveCurrencyTokenAddress(address varg0, bool varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    _approvedCurrencyTokens[varg0] = varg1 | ~0xff & _approvedCurrencyTokens[varg0];\n}\n\nfunction receiveTokenDeposit(address varg0, address varg1, uint256 varg2) public nonPayable { \n    0xbac(varg2, varg1, varg0);\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction setMakerFee(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg0 > 0x2386f26fc10000) {\n        v3 = v4 = 0x2386f26fc10000;\n    }\n    require(v3 != _makerFee);\n    _makerFee = v3;\n    emit MakerFeeUpdated(_makerFee, v3);\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = MEM[64];\n    v0 = v2 = 405;\n    v3 = msg.data.length;\n    CALLDATACOPY(v1, 4, 352);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 356, 128);\n    v0 = v5 = MEM[64];\n    CALLDATACOPY(v5, 484, 64);\n    v0 = v6 = MEM[64];\n    CALLDATACOPY(v6, 548, 128);\n    v0 = v7 = 0;\n    v8 = v9 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v8 = v10 = 0xff & _admins[msg.sender];\n    }\n    require(v8);\n    v0 = v11 = MEM[v1 + 32];\n    v0 = v12 = 3797;\n    v0 = v13 = 3785;\n    v14 = v15 = 0xde0b6b3a7640000;\n    v16 = MEM[0 + v1];\n    while (1) {\n        if (v16) {\n            goto 0x230a0x390;\n        }\n        v17 = v18 = 0;\n        goto {'0x188a', '0x1992', '0x178a', '0x18d7', '0x1476', '0x14b3', '0xec9'};\n        while (!v0) {\n            assert(v0);\n            v19 = v20 = 7;\n            v21 = v22 = 0;\n            v23 = v24 = 7;\n            v25 = v26 = 0;\n            goto 0x14d10x390;\n            v27 = address(MEM[0 + v0]);\n            v28 = v29 = _tokens[v27];\n            goto 0x22c50x390;\n            v0 = v17 / v0;\n            goto {'0x17e8', '0x1b9d', '0xefd', '0x1841', '0x1c58', '0xf3b', '0x16e1', '0xed5', '0x1adb'};\n            v0 = v30 = 3849;\n            v0 = v31 = 0x186a0;\n            v0 = v32 = 3837;\n            v0 = v33 = MEM[256 + v0];\n            if (MEM[224 + v0]) {\n                v17 = v34 = 0xde0b6b3a7640000 * MEM[224 + v0];\n                assert(MEM[224 + v0]);\n                require(v34 / MEM[224 + v0] == 0xde0b6b3a7640000);\n            } else {\n                v17 = v35 = 0;\n            }\n            goto 0xec9;\n            require(v0 <= v0);\n            require(v0 >= v0 - v0);\n            v0 = v36 = 3911;\n            v0 = v37 = 0x186a0;\n            v0 = v38 = 3899;\n            v0 = v39 = MEM[96 + v0];\n            if (MEM[128 + v0]) {\n                v17 = v40 = 0xde0b6b3a7640000 * MEM[128 + v0];\n                assert(MEM[128 + v0]);\n                require(v40 / MEM[128 + v0] == 0xde0b6b3a7640000);\n            } else {\n                v17 = v41 = 0;\n            }\n            goto 0xec9;\n            v42 = _SafeAdd(v0, v0);\n            require(v0 <= v42);\n            require(block.number < MEM[v0 + 288]);\n            require(block.number < MEM[v0 + 160]);\n            v43 = address(MEM[64 + v0]);\n            require(_invalidOrder[v43] <= MEM[v0 + 64]);\n            v44 = address(MEM[v0 + 96]);\n            require(_invalidOrder[v44] <= MEM[v0 + 192]);\n            v0 = v45 = keccak256(address(this), address(MEM[0 + v0]), MEM[224 + v0], address(MEM[32 + v0]), MEM[256 + v0], MEM[288 + v0], MEM[64 + v0], address(MEM[64 + v0]));\n            v0 = v46 = keccak256(address(this), address(MEM[32 + v0]), MEM[96 + v0], address(MEM[0 + v0]), MEM[128 + v0], MEM[160 + v0], MEM[192 + v0], address(MEM[96 + v0]));\n            v47 = MEM[0 + v0] & 0xff;\n            v48 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v45), v47, MEM[0 + v0], MEM[32 + v0], MEM[32 + v0], address(MEM[96 + v0]) << 96);\n            require(v48); // checks call status, propagates error data on error\n            require(0 == address(MEM[64 + v0]));\n            MEM[v49.data] = 0;\n            MEM[v49.data + 32] = keccak256('\\x19Ethereum Signed Message:\\n32', v46);\n            v50 = MEM[32 + v0] & 0xff;\n            MEM[64 + v49.data] = v50;\n            MEM[v49.data + 96] = MEM[64 + v0];\n            MEM[v49.data + 128] = MEM[96 + v0];\n            v51 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v46), v50, MEM[64 + v0], MEM[96 + v0]);\n            require(v51); // checks call status, propagates error data on error\n            require(address(MEM[MEM[64] - 32]) == address(MEM[96 + v0]));\n            require(_tokens[address(MEM[v0 + 96])] >= MEM[v0]);\n            require(_tokens[address(MEM[v0 + 64])] >= MEM[32 + v0]);\n            v52 = v53 = !address(MEM[v0]);\n            if (address(MEM[v0])) {\n                v52 = v54 = !address(MEM[v0 + 32]);\n            }\n            if (v52) {\n                v52 = v55 = 0x6a94d74f430000 < MEM[v0 + 320];\n            }\n            if (v52) {\n                MEM[v0 + 320] = 0x6a94d74f430000;\n            }\n            v56 = address(MEM[v0]);\n            v57 = v58 = 1 == 0xff & _approvedCurrencyTokens[v56];\n            if (1 != 0xff & _approvedCurrencyTokens[v56]) {\n                v59 = address(MEM[v0 + 32]);\n                v57 = v60 = 1 == 0xff & _approvedCurrencyTokens[v59];\n            }\n            if (v57) {\n                v57 = v61 = 0x8ac7230489e80000 < MEM[v0 + 320];\n            }\n            if (v57) {\n                MEM[v0 + 320] = 0x8ac7230489e80000;\n            }\n            v62 = v63 = !address(MEM[v0]);\n            if (address(MEM[v0])) {\n                v64 = address(MEM[v0]);\n                v62 = v65 = 1 == 0xff & _approvedCurrencyTokens[v64];\n            }\n            if (!v62) {\n                require(MEM[0 + v0] + _orderFills[v45] >= _orderFills[v45]);\n                require(MEM[0 + v0] + _orderFills[v45] <= MEM[v0 + 224]);\n                require(MEM[0 + v0] + _orderFills[v46] >= _orderFills[v46]);\n                require(MEM[0 + v0] + _orderFills[v46] <= MEM[v0 + 128]);\n                v0 = v66 = MEM[v0 + 32];\n                require(MEM[0 + v0] <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))]);\n                _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))] - MEM[0 + v0];\n                v67 = MEM[0 + v0] + STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))];\n                require(v67 >= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))]);\n                _tokens[address(MEM[64 + v0])] = v67;\n                require(v0 <= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n                _tokens[address(MEM[v0 + 64])] = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n                v0 = v68 = 6887;\n                v0 = v69 = 6875;\n                v0 = v70 = 0xde0b6b3a7640000;\n                if (_makerFee) {\n                    v17 = v0 * _makerFee;\n                    assert(_makerFee);\n                    require(v17 / _makerFee == v0);\n                } else {\n                    v17 = v71 = 0;\n                }\n                goto 0xec9;\n            } else {\n                v0 = v72 = MEM[v0 + 256];\n                v0 = v73 = 5238;\n                v0 = v74 = MEM[32 + v0];\n                v28 = _orderFills[v45];\n            }\n            require(v0 <= STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[64 + v0])] = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n            v75 = v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))];\n            require(v75 >= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[v0 + 96])] = v75;\n            v0 = v76 = 7081;\n            v0 = v77 = 7069;\n            v0 = v78 = 0xde0b6b3a7640000;\n            if (_takerFee) {\n                v17 = v0 * _takerFee;\n                assert(_takerFee);\n                require(v17 / _takerFee == v0);\n            } else {\n                v17 = v79 = 0;\n            }\n            goto 0xec9;\n            require(v0 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[96 + v0])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v0;\n            v80 = MEM[320 + v0];\n            require(v80 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n            _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] - v80;\n            v0 = v81 = 7268;\n            v0 = v82 = 7256;\n            v0 = v83 = 0xde0b6b3a7640000;\n            if (_makerFee) {\n                v17 = v0 * _makerFee;\n                assert(_makerFee);\n                require(v17 / _makerFee == v0);\n            } else {\n                v17 = v84 = 0;\n            }\n            goto 0xec9;\n            v85 = address(MEM[32 + v0]);\n            require(v0 + _tokens[_feeAccount] >= _tokens[_feeAccount]);\n            goto {'0x1cb1', '0x1c64'};\n            v86 = address(MEM[v0 + 32]);\n            _tokens[_feeAccount] += v0;\n            v0 = v87 = 7345;\n            v0 = v88 = 7256;\n            v0 = v89 = 0xde0b6b3a7640000;\n            if (_takerFee) {\n                v17 = v0 * _takerFee;\n                assert(_takerFee);\n                require(v17 / _takerFee == v0);\n            } else {\n                v17 = v90 = 0;\n            }\n            goto 0xec9;\n            _tokens[_feeAccount] += v0;\n            v91 = MEM[v0 + 320] + _tokens[_feeAccount];\n            require(v91 >= _tokens[_feeAccount]);\n            v92 = address(MEM[v0 + 32]);\n            _tokens[_feeAccount] = v91;\n            v93 = MEM[0 + v0] + _orderFills[v0];\n            require(v93 >= _orderFills[v0]);\n            _orderFills[v0] = v93;\n            v94 = MEM[0 + v0] + _orderFills[v0];\n            require(v94 >= _orderFills[v0]);\n            _orderFills[v0] = v94;\n        }\n        MEM[v21] = address(MEM[(v21 << 5) + v0]);\n        MEM[32 + v21] = v19;\n        v95 = v96 = keccak256(MEM[0 len (64 + v21)]);\n        v97 = v98 = 0;\n        v99 = v100 = 3;\n        goto 0x15070x390;\n        require(v17 <= v0);\n        v0 = v101 = MEM[v0 + 96];\n        v0 = v102 = 5299;\n        v0 = v103 = MEM[32 + v0];\n        v28 = v104 = _orderFills[v0];\n        v17 = v0 + v28;\n        require(v17 >= v28);\n        require(v17 <= v0);\n        v0 = v105 = MEM[v0 + 32];\n        v0 = v106 = 5435;\n        v23 = v107 = 7;\n        v25 = v108 = 0;\n        v25 = v109 = 1;\n        MEM[v25] = address(MEM[(v25 << 5) + v0]);\n        MEM[32 + v25] = v23;\n        v95 = keccak256(MEM[0 len (64 + v25)]);\n        v97 = v110 = 0;\n        v99 = v111 = 2;\n        MEM[v97] = address(MEM[(v99 << 5) + v0]);\n        MEM[32 + v97] = v95;\n        require(v0 <= STORAGE[keccak256(MEM[0 len (64 + v97)])]);\n        goto {'0x1682', '0x17f3', '0x16ec', '0x153b'};\n        _tokens[address(MEM[64 + v0])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        require(v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))] >= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))]);\n        _tokens[address(MEM[v0 + 96])] = v0 + STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[32 + v0]), 7))];\n        v0 = v112 = 5762;\n        v0 = MEM[0 + v0];\n        v19 = v113 = 7;\n        v21 = v114 = 0;\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v0 = v115 = 5868;\n        v0 = v116 = 5857;\n        v0 = v117 = 0xde0b6b3a7640000;\n        v0 = v118 = 3785;\n        v14 = MEM[0 + v0];\n        v16 = v119 = _takerFee;\n        continue;\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v120 = MEM[320 + v0];\n        require(v120 <= STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))]);\n        _tokens[address(MEM[v0 + 96])] = STORAGE[keccak256(address(MEM[96 + v0]), keccak256(address(MEM[0 + v0]), 7))] - v120;\n        v0 = v121 = 6026;\n        v0 = v122 = MEM[0 + v0];\n        v28 = v123 = STORAGE[keccak256(address(MEM[64 + v0]), keccak256(address(MEM[v0]), 7))];\n        goto 0x22c50x390;\n        _tokens[address(MEM[v0 + 64])] = STORAGE[keccak256(MEM[0 len (64 + v97)])] - v0;\n        v0 = v124 = 6282;\n        v0 = v125 = 6209;\n        v0 = v126 = 0xde0b6b3a7640000;\n        v127 = MEM[0 + v0];\n        if (_makerFee) {\n            v17 = v128 = v127 * _makerFee;\n            assert(_makerFee);\n            require(v128 / _makerFee == v127);\n        } else {\n            v17 = v129 = 0;\n        }\n        goto 0xec9;\n        _tokens[address(MEM[v0 + 64])] = v17;\n        v0 = v130 = 6131;\n        v0 = v131 = 6120;\n        v0 = v132 = 0xde0b6b3a7640000;\n        v0 = v133 = 3785;\n        v14 = v134 = MEM[0 + v0];\n        v16 = v135 = _makerFee;\n        continue;\n        v136 = address(MEM[v0]);\n        _tokens[_feeAccount] = v17;\n        v0 = v137 = 6359;\n        v0 = v138 = 6209;\n        v0 = v139 = 0xde0b6b3a7640000;\n        v140 = MEM[0 + v0];\n        if (_takerFee) {\n            v17 = v141 = v140 * _takerFee;\n            assert(_takerFee);\n            require(v141 / _takerFee == v140);\n        } else {\n            v17 = v142 = 0;\n        }\n        goto 0xec9;\n        _tokens[_feeAccount] = v17;\n        v143 = MEM[v0 + 320] + _tokens[_feeAccount];\n        require(v143 >= _tokens[_feeAccount]);\n        v144 = address(MEM[v0]);\n        _tokens[_feeAccount] = v143;\n        v145 = MEM[32 + v0] + _orderFills[v0];\n        require(v145 >= _orderFills[v0]);\n        _orderFills[v0] = v145;\n        v0 = v146 = 6546;\n        v0 = v147 = MEM[32 + v0];\n        v28 = v148 = _orderFills[v0];\n        v17 = v149 = v14 * v16;\n        assert(v16);\n        require(v149 / v16 == v14);\n    }\n    _orderFills[v0] = v17;\n    _lastActiveTransaction[address(MEM[64 + v0])] = block.number;\n    _lastActiveTransaction[address(MEM[v0 + 96])] = block.number;\n    emit Trade(address(MEM[0 + v0]), MEM[0 + v0], address(MEM[32 + v0]), MEM[32 + v0], address(MEM[64 + v0]), address(MEM[96 + v0]));\n    return 1;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[32] = 0x6d5257204ebe7d88fd91ae87941cb2dd9d8062b64ae5a2bd2d28ec40b9fbf6df;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction approvedCurrencyTokens(address varg0) public nonPayable { \n    return 0xff & _approvedCurrencyTokens[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    require(varg0 <= 50000);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction setTakerFee(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = 0xff & _admins[msg.sender];\n    }\n    require(v0);\n    if (varg0 > 0x470de4df820000) {\n        v3 = v4 = 0x470de4df820000;\n    }\n    require(v3 != _takerFee);\n    _takerFee = v3;\n    emit TakerFeeUpdated(_takerFee, v3);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_lastActiveTransaction[msg.sender] <= block.number);\n    require(block.number - _lastActiveTransaction[msg.sender] >= _inactivityReleasePeriod);\n    require(varg1 <= _tokens[msg.sender]);\n    require(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    if (varg0) {\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v2); // checks call status, propagates error data on error\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 1;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction makerFee() public nonPayable { \n    return _makerFee;\n}\n\nfunction 0xbac(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = address(varg1);\n    v2 = _SafeAdd(varg0, _tokens[v1]);\n    v3 = address(varg2);\n    v4 = address(varg1);\n    _tokens[v4] = v2;\n    _lastActiveTransaction[v4] = block.number;\n    require(v3.code.size);\n    v5, v6 = v3.transferFrom(v4, this, varg0).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6);\n    v7 = address(varg2);\n    v8 = address(varg1);\n    emit Deposit(v7, v8, varg0, _tokens[v8]);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x2295115b) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == function_selector) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == function_selector) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == function_selector) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == function_selector) {\n            admins(address);\n        } else if (0x43f0179b == function_selector) {\n            takerFee();\n        } else if (0x4b0bddd2 == function_selector) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == function_selector) {\n            tokens(address,address);\n        } else if (0x65e17c9d == function_selector) {\n            feeAccount();\n        } else if (0x7ca1cb48 == function_selector) {\n            approveCurrencyTokenAddress(address,bool);\n        } else if (0x8192433f == function_selector) {\n            receiveTokenDeposit(address,address,uint256);\n        } else if (0x83dbb27b == function_selector) {\n            invalidOrder(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xb12de559 == function_selector) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xb8bd3dbb == function_selector) {\n            setMakerFee(uint256);\n        } else if (0xc1204caa == function_selector) {\n            trade(uint256[11],address[4],uint8[2],bytes32[4]);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xd6d7479d == function_selector) {\n            approvedCurrencyTokens(address);\n        } else if (0xdd93c74a == function_selector) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xf1cca8aa == function_selector) {\n            setTakerFee(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf31174ee == function_selector) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == function_selector) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xfc741c7c == function_selector) {\n            makerFee();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 25.762405395507812,
	"usage": {
		"completion_tokens": 451,
		"prompt_tokens": 8172,
		"total_tokens": 8623
	}
}