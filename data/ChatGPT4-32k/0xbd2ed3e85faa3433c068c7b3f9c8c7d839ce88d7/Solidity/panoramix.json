{
	"address": "0xbd2ed3e85faa3433c068c7b3f9c8c7d839ce88d7",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code that would produce the given decompiled code:\n\n```solidity\npragma solidity >=0.4.22 <0.7.0;\n\ncontract TokenSale {\n    address public owner;\n    address public pendingOwner;\n    uint256 public startTime;\n    uint256 public endTime;\n    address public tokenAddress;\n    address public walletAddress;\n    mapping (address => uint8) public stor6;\n\n    event LogUserAddedToWhiteList(address indexed user);\n    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\n\n    constructor(address _tokenAddress, address _walletAddress, uint256 _startTime, uint256 _endTime) public {\n        owner = msg.sender;\n        tokenAddress = _tokenAddress;\n        walletAddress = _walletAddress;\n        startTime = _startTime;\n        endTime = _endTime;\n    }\n\n    function destroy() public {\n        require(msg.sender == owner);\n        // NotifiableToken(tokenAddress).finishMinting();\n        // NotifiableToken(tokenAddress).transferOwnership(msg.sender);\n        selfdestruct(msg.sender);\n    }\n\n    function hasEnded() public view returns (bool) {\n        return (block.timestamp > endTime);\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        pendingOwner = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    function removeWhiteListedAddress(address _address) public {\n        require(msg.sender == owner);\n        stor6[_address] = 0;\n    }\n\n    function whiteListAddress(address _address) public {\n        require(msg.sender == owner);\n        stor6[_address] = 1;\n        emit LogUserAddedToWhiteList(_address);\n    }\n\n    function addWhiteListedAddressesInBatch(address[] memory _buyers) public {\n        require(msg.sender == owner);\n        require(_buyers.length < 1000);\n        for (uint i = 0; i < _buyers.length; i++) {\n            stor6[_buyers[i]] = 1;\n            emit LogUserAddedToWhiteList(_buyers[i]);\n        }\n    }\n\n    function buyTokens() public payable {\n        require(msg.value > 0);\n        require(block.timestamp >= startTime && block.timestamp <= endTime);\n\n        uint256 tokens;\n        if (block.timestamp >= startTime + (192 * 24 * 3600)) {\n            tokens = 3000 * msg.value;\n        } else if (block.timestamp >= startTime + (24 * 3600)) {\n            tokens = 3250 * msg.value;\n        } else if (block.timestamp < startTime) {\n            tokens = 3750 * msg.value;\n        } else {\n            tokens = 3500 * msg.value;\n        }\n\n        // NotifiableToken(tokenAddress).mint(msg.sender, tokens);\n        walletAddress.transfer(msg.value);\n\n        emit TokenPurchase(msg.sender, msg.value, tokens);\n    }\n\n    function() external payable {\n        buyTokens();\n    }\n}\n```\nPlease note that the above Solidity code is a rough approximation of the original contract and may not compile or function as expected. The contract is assuming a standard ERC20 token interface with additional `mint` and `finishMinting` functions, which are not part of the standard ERC20. Also, the contract assumes that the token contract contains a `transferOwnership` function, which is also not part of the standard ERC20. Changes may be needed depending on the actual token contract interface.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472228,
	"id": "chatcmpl-8MunM3LnYMU4VKPfnalvZZYRq7c7I",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst earlyBirdTokenRate = 3500\nconst secondStageTokenRate = 3250\nconst tokenReserve = 400000000 * 10^18\nconst presaleTokenRate = 3750\nconst tokenCap = 1000000000 * 10^18\nconst thirdStageTokenRate = 3000\n\ndef storage:\n  owner is address at storage 0\n  pendingOwner is address at storage 1\n  startTime is uint256 at storage 2\n  endTime is uint256 at storage 3\n  tokenAddress is address at storage 4\n  walletAddress is address at storage 5\n  stor6 is mapping of uint8 at storage 6\n\ndef endTime(): # not payable\n  return endTime\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef startTime(): # not payable\n  return startTime\n\ndef owner(): # not payable\n  return owner\n\ndef pendingOwner(): # not payable\n  return pendingOwner\n\ndef token(): # not payable\n  return tokenAddress\n\n#\n#  Regular functions\n#\n\ndef destroy(): # not payable\n  require owner == caller\n  require ext_code.size(tokenAddress)\n  call tokenAddress.finishMinting() with:\n       gas gas_remaining - 710 wei\n  require ext_call.success\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transferOwnership(address newOwner) with:\n       gas gas_remaining - 710 wei\n      args caller\n  require ext_call.success\n  selfdestruct(owner)\n\ndef hasEnded(): # not payable\n  return (block.timestamp > endTime)\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  pendingOwner = newOwner\n\ndef claimOwnership(): # not payable\n  require pendingOwner == caller\n  owner = pendingOwner\n  pendingOwner = 0\n\ndef removeWhiteListedAddress(address _address): # not payable\n  require owner == caller\n  stor6[address(_address)] = 0\n\ndef whiteListAddress(address _address): # not payable\n  require owner == caller\n  require _address\n  stor6[address(_address)] = 1\n  log LogUserAddedToWhiteList(address user=_address)\n\ndef addWhiteListedAddressesInBatch(address[] _buyers): # not payable\n  mem[128 len 32 * _buyers.length] = call.data[_buyers + 36 len 32 * _buyers.length]\n  require owner == caller\n  require _buyers.length < 1000\n  idx = 0\n  while idx < _buyers.length:\n      require idx < _buyers.length\n      require owner == caller\n      require mem[(32 * idx) + 140 len 20]\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 6\n      stor6[mem[(32 * idx) + 140 len 20]] = 1\n      log LogUserAddedToWhiteList(address user=mem[(32 * idx) + 140 len 20])\n      idx = idx + 1\n      continue \n\ndef buyTokens() payable: \n  require caller\n  require call.value\n  if not stor6[caller]:\n      require block.timestamp >= startTime\n  require block.timestamp <= endTime\n  if block.timestamp >= startTime + (192 * 24 * 3600):\n      if call.value:\n          require call.value\n          require 3000 * call.value / call.value == 3000\n      require ext_code.size(tokenAddress)\n      call tokenAddress.totalSupply() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require (3000 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n      require (3000 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n      require ext_code.size(tokenAddress)\n      call tokenAddress.mint(address _to, uint256 _amount) with:\n           gas gas_remaining - 710 wei\n          args caller, 3000 * call.value\n      require ext_call.success\n      log TokenPurchase(\n            address beneficiary=call.value,\n            uint256 value=3000 * call.value,\n            uint256 amount=caller)\n  else:\n      if block.timestamp >= startTime + (24 * 3600):\n          if call.value:\n              require call.value\n              require 3250 * call.value / call.value == 3250\n          require ext_code.size(tokenAddress)\n          call tokenAddress.totalSupply() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          require (3250 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n          require (3250 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n          require ext_code.size(tokenAddress)\n          call tokenAddress.mint(address _to, uint256 _amount) with:\n               gas gas_remaining - 710 wei\n              args caller, 3250 * call.value\n          require ext_call.success\n          log TokenPurchase(\n                address beneficiary=call.value,\n                uint256 value=3250 * call.value,\n                uint256 amount=caller)\n      else:\n          if block.timestamp < startTime:\n              if call.value:\n                  require call.value\n                  require 3750 * call.value / call.value == 3750\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3750 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3750 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3750 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3750 * call.value,\n                    uint256 amount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require 3500 * call.value / call.value == 3500\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3500 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3500 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3500 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3500 * call.value,\n                    uint256 amount=caller)\n  call walletAddress with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n\ndef _fallback(?) payable: # default function\n  require caller\n  require call.value\n  if not stor6[caller]:\n      require block.timestamp >= startTime\n  require block.timestamp <= endTime\n  if block.timestamp >= startTime + (192 * 24 * 3600):\n      if call.value:\n          require call.value\n          require 3000 * call.value / call.value == 3000\n      require ext_code.size(tokenAddress)\n      call tokenAddress.totalSupply() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require (3000 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n      require (3000 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n      require ext_code.size(tokenAddress)\n      call tokenAddress.mint(address _to, uint256 _amount) with:\n           gas gas_remaining - 710 wei\n          args caller, 3000 * call.value\n      require ext_call.success\n      log TokenPurchase(\n            address beneficiary=call.value,\n            uint256 value=3000 * call.value,\n            uint256 amount=caller)\n  else:\n      if block.timestamp >= startTime + (24 * 3600):\n          if call.value:\n              require call.value\n              require 3250 * call.value / call.value == 3250\n          require ext_code.size(tokenAddress)\n          call tokenAddress.totalSupply() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          require (3250 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n          require (3250 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n          require ext_code.size(tokenAddress)\n          call tokenAddress.mint(address _to, uint256 _amount) with:\n               gas gas_remaining - 710 wei\n              args caller, 3250 * call.value\n          require ext_call.success\n          log TokenPurchase(\n                address beneficiary=call.value,\n                uint256 value=3250 * call.value,\n                uint256 amount=caller)\n      else:\n          if block.timestamp < startTime:\n              if call.value:\n                  require call.value\n                  require 3750 * call.value / call.value == 3750\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3750 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3750 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3750 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3750 * call.value,\n                    uint256 amount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require 3500 * call.value / call.value == 3500\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3500 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3500 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3500 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3500 * call.value,\n                    uint256 amount=caller)\n  call walletAddress with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst earlyBirdTokenRate = 3500\nconst secondStageTokenRate = 3250\nconst tokenReserve = 400000000 * 10^18\nconst presaleTokenRate = 3750\nconst tokenCap = 1000000000 * 10^18\nconst thirdStageTokenRate = 3000\n\ndef storage:\n  owner is address at storage 0\n  pendingOwner is address at storage 1\n  startTime is uint256 at storage 2\n  endTime is uint256 at storage 3\n  tokenAddress is address at storage 4\n  walletAddress is address at storage 5\n  stor6 is mapping of uint8 at storage 6\n\ndef endTime(): # not payable\n  return endTime\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef startTime(): # not payable\n  return startTime\n\ndef owner(): # not payable\n  return owner\n\ndef pendingOwner(): # not payable\n  return pendingOwner\n\ndef token(): # not payable\n  return tokenAddress\n\n#\n#  Regular functions\n#\n\ndef destroy(): # not payable\n  require owner == caller\n  require ext_code.size(tokenAddress)\n  call tokenAddress.finishMinting() with:\n       gas gas_remaining - 710 wei\n  require ext_call.success\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transferOwnership(address newOwner) with:\n       gas gas_remaining - 710 wei\n      args caller\n  require ext_call.success\n  selfdestruct(owner)\n\ndef hasEnded(): # not payable\n  return (block.timestamp > endTime)\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  pendingOwner = newOwner\n\ndef claimOwnership(): # not payable\n  require pendingOwner == caller\n  owner = pendingOwner\n  pendingOwner = 0\n\ndef removeWhiteListedAddress(address _address): # not payable\n  require owner == caller\n  stor6[address(_address)] = 0\n\ndef whiteListAddress(address _address): # not payable\n  require owner == caller\n  require _address\n  stor6[address(_address)] = 1\n  log LogUserAddedToWhiteList(address user=_address)\n\ndef addWhiteListedAddressesInBatch(address[] _buyers): # not payable\n  mem[128 len 32 * _buyers.length] = call.data[_buyers + 36 len 32 * _buyers.length]\n  require owner == caller\n  require _buyers.length < 1000\n  idx = 0\n  while idx < _buyers.length:\n      require idx < _buyers.length\n      require owner == caller\n      require mem[(32 * idx) + 140 len 20]\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 6\n      stor6[mem[(32 * idx) + 140 len 20]] = 1\n      log LogUserAddedToWhiteList(address user=mem[(32 * idx) + 140 len 20])\n      idx = idx + 1\n      continue \n\ndef buyTokens() payable: \n  require caller\n  require call.value\n  if not stor6[caller]:\n      require block.timestamp >= startTime\n  require block.timestamp <= endTime\n  if block.timestamp >= startTime + (192 * 24 * 3600):\n      if call.value:\n          require call.value\n          require 3000 * call.value / call.value == 3000\n      require ext_code.size(tokenAddress)\n      call tokenAddress.totalSupply() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require (3000 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n      require (3000 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n      require ext_code.size(tokenAddress)\n      call tokenAddress.mint(address _to, uint256 _amount) with:\n           gas gas_remaining - 710 wei\n          args caller, 3000 * call.value\n      require ext_call.success\n      log TokenPurchase(\n            address beneficiary=call.value,\n            uint256 value=3000 * call.value,\n            uint256 amount=caller)\n  else:\n      if block.timestamp >= startTime + (24 * 3600):\n          if call.value:\n              require call.value\n              require 3250 * call.value / call.value == 3250\n          require ext_code.size(tokenAddress)\n          call tokenAddress.totalSupply() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          require (3250 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n          require (3250 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n          require ext_code.size(tokenAddress)\n          call tokenAddress.mint(address _to, uint256 _amount) with:\n               gas gas_remaining - 710 wei\n              args caller, 3250 * call.value\n          require ext_call.success\n          log TokenPurchase(\n                address beneficiary=call.value,\n                uint256 value=3250 * call.value,\n                uint256 amount=caller)\n      else:\n          if block.timestamp < startTime:\n              if call.value:\n                  require call.value\n                  require 3750 * call.value / call.value == 3750\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3750 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3750 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3750 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3750 * call.value,\n                    uint256 amount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require 3500 * call.value / call.value == 3500\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3500 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3500 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3500 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3500 * call.value,\n                    uint256 amount=caller)\n  call walletAddress with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n\ndef _fallback(?) payable: # default function\n  require caller\n  require call.value\n  if not stor6[caller]:\n      require block.timestamp >= startTime\n  require block.timestamp <= endTime\n  if block.timestamp >= startTime + (192 * 24 * 3600):\n      if call.value:\n          require call.value\n          require 3000 * call.value / call.value == 3000\n      require ext_code.size(tokenAddress)\n      call tokenAddress.totalSupply() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require (3000 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n      require (3000 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n      require ext_code.size(tokenAddress)\n      call tokenAddress.mint(address _to, uint256 _amount) with:\n           gas gas_remaining - 710 wei\n          args caller, 3000 * call.value\n      require ext_call.success\n      log TokenPurchase(\n            address beneficiary=call.value,\n            uint256 value=3000 * call.value,\n            uint256 amount=caller)\n  else:\n      if block.timestamp >= startTime + (24 * 3600):\n          if call.value:\n              require call.value\n              require 3250 * call.value / call.value == 3250\n          require ext_code.size(tokenAddress)\n          call tokenAddress.totalSupply() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          require (3250 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n          require (3250 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n          require ext_code.size(tokenAddress)\n          call tokenAddress.mint(address _to, uint256 _amount) with:\n               gas gas_remaining - 710 wei\n              args caller, 3250 * call.value\n          require ext_call.success\n          log TokenPurchase(\n                address beneficiary=call.value,\n                uint256 value=3250 * call.value,\n                uint256 amount=caller)\n      else:\n          if block.timestamp < startTime:\n              if call.value:\n                  require call.value\n                  require 3750 * call.value / call.value == 3750\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3750 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3750 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3750 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3750 * call.value,\n                    uint256 amount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require 3500 * call.value / call.value == 3500\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3500 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3500 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3500 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3500 * call.value,\n                    uint256 amount=caller)\n  call walletAddress with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst earlyBirdTokenRate = 3500\nconst secondStageTokenRate = 3250\nconst tokenReserve = 400000000 * 10^18\nconst presaleTokenRate = 3750\nconst tokenCap = 1000000000 * 10^18\nconst thirdStageTokenRate = 3000\n\ndef storage:\n  owner is address at storage 0\n  pendingOwner is address at storage 1\n  startTime is uint256 at storage 2\n  endTime is uint256 at storage 3\n  tokenAddress is address at storage 4\n  walletAddress is address at storage 5\n  stor6 is mapping of uint8 at storage 6\n\ndef endTime(): # not payable\n  return endTime\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef startTime(): # not payable\n  return startTime\n\ndef owner(): # not payable\n  return owner\n\ndef pendingOwner(): # not payable\n  return pendingOwner\n\ndef token(): # not payable\n  return tokenAddress\n\n#\n#  Regular functions\n#\n\ndef destroy(): # not payable\n  require owner == caller\n  require ext_code.size(tokenAddress)\n  call tokenAddress.finishMinting() with:\n       gas gas_remaining - 710 wei\n  require ext_call.success\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transferOwnership(address newOwner) with:\n       gas gas_remaining - 710 wei\n      args caller\n  require ext_call.success\n  selfdestruct(owner)\n\ndef hasEnded(): # not payable\n  return (block.timestamp > endTime)\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  pendingOwner = newOwner\n\ndef claimOwnership(): # not payable\n  require pendingOwner == caller\n  owner = pendingOwner\n  pendingOwner = 0\n\ndef removeWhiteListedAddress(address _address): # not payable\n  require owner == caller\n  stor6[address(_address)] = 0\n\ndef whiteListAddress(address _address): # not payable\n  require owner == caller\n  require _address\n  stor6[address(_address)] = 1\n  log LogUserAddedToWhiteList(address user=_address)\n\ndef addWhiteListedAddressesInBatch(address[] _buyers): # not payable\n  mem[128 len 32 * _buyers.length] = call.data[_buyers + 36 len 32 * _buyers.length]\n  require owner == caller\n  require _buyers.length < 1000\n  idx = 0\n  while idx < _buyers.length:\n      require idx < _buyers.length\n      require owner == caller\n      require mem[(32 * idx) + 140 len 20]\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 6\n      stor6[mem[(32 * idx) + 140 len 20]] = 1\n      log LogUserAddedToWhiteList(address user=mem[(32 * idx) + 140 len 20])\n      idx = idx + 1\n      continue \n\ndef buyTokens() payable: \n  require caller\n  require call.value\n  if not stor6[caller]:\n      require block.timestamp >= startTime\n  require block.timestamp <= endTime\n  if block.timestamp >= startTime + (192 * 24 * 3600):\n      if call.value:\n          require call.value\n          require 3000 * call.value / call.value == 3000\n      require ext_code.size(tokenAddress)\n      call tokenAddress.totalSupply() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require (3000 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n      require (3000 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n      require ext_code.size(tokenAddress)\n      call tokenAddress.mint(address _to, uint256 _amount) with:\n           gas gas_remaining - 710 wei\n          args caller, 3000 * call.value\n      require ext_call.success\n      log TokenPurchase(\n            address beneficiary=call.value,\n            uint256 value=3000 * call.value,\n            uint256 amount=caller)\n  else:\n      if block.timestamp >= startTime + (24 * 3600):\n          if call.value:\n              require call.value\n              require 3250 * call.value / call.value == 3250\n          require ext_code.size(tokenAddress)\n          call tokenAddress.totalSupply() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          require (3250 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n          require (3250 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n          require ext_code.size(tokenAddress)\n          call tokenAddress.mint(address _to, uint256 _amount) with:\n               gas gas_remaining - 710 wei\n              args caller, 3250 * call.value\n          require ext_call.success\n          log TokenPurchase(\n                address beneficiary=call.value,\n                uint256 value=3250 * call.value,\n                uint256 amount=caller)\n      else:\n          if block.timestamp < startTime:\n              if call.value:\n                  require call.value\n                  require 3750 * call.value / call.value == 3750\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3750 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3750 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3750 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3750 * call.value,\n                    uint256 amount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require 3500 * call.value / call.value == 3500\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3500 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3500 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3500 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3500 * call.value,\n                    uint256 amount=caller)\n  call walletAddress with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n\ndef _fallback(?) payable: # default function\n  require caller\n  require call.value\n  if not stor6[caller]:\n      require block.timestamp >= startTime\n  require block.timestamp <= endTime\n  if block.timestamp >= startTime + (192 * 24 * 3600):\n      if call.value:\n          require call.value\n          require 3000 * call.value / call.value == 3000\n      require ext_code.size(tokenAddress)\n      call tokenAddress.totalSupply() with:\n           gas gas_remaining - 710 wei\n      require ext_call.success\n      require (3000 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n      require (3000 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n      require ext_code.size(tokenAddress)\n      call tokenAddress.mint(address _to, uint256 _amount) with:\n           gas gas_remaining - 710 wei\n          args caller, 3000 * call.value\n      require ext_call.success\n      log TokenPurchase(\n            address beneficiary=call.value,\n            uint256 value=3000 * call.value,\n            uint256 amount=caller)\n  else:\n      if block.timestamp >= startTime + (24 * 3600):\n          if call.value:\n              require call.value\n              require 3250 * call.value / call.value == 3250\n          require ext_code.size(tokenAddress)\n          call tokenAddress.totalSupply() with:\n               gas gas_remaining - 710 wei\n          require ext_call.success\n          require (3250 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n          require (3250 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n          require ext_code.size(tokenAddress)\n          call tokenAddress.mint(address _to, uint256 _amount) with:\n               gas gas_remaining - 710 wei\n              args caller, 3250 * call.value\n          require ext_call.success\n          log TokenPurchase(\n                address beneficiary=call.value,\n                uint256 value=3250 * call.value,\n                uint256 amount=caller)\n      else:\n          if block.timestamp < startTime:\n              if call.value:\n                  require call.value\n                  require 3750 * call.value / call.value == 3750\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3750 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3750 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3750 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3750 * call.value,\n                    uint256 amount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require 3500 * call.value / call.value == 3500\n              require ext_code.size(tokenAddress)\n              call tokenAddress.totalSupply() with:\n                   gas gas_remaining - 710 wei\n              require ext_call.success\n              require (3500 * call.value) + ext_call.return_data[0] >= ext_call.return_data[0]\n              require (3500 * call.value) + ext_call.return_data[0] <= 1000000000 * 10^18\n              require ext_code.size(tokenAddress)\n              call tokenAddress.mint(address _to, uint256 _amount) with:\n                   gas gas_remaining - 710 wei\n                  args caller, 3500 * call.value\n              require ext_call.success\n              log TokenPurchase(\n                    address beneficiary=call.value,\n                    uint256 value=3500 * call.value,\n                    uint256 amount=caller)\n  call walletAddress with:\n     value call.value wei\n       gas 2300 * is_zero(value) wei\n\n.",
	"status": "1",
	"time_cost": 43.720024824142456,
	"usage": {
		"completion_tokens": 733,
		"prompt_tokens": 2485,
		"total_tokens": 3218
	}
}