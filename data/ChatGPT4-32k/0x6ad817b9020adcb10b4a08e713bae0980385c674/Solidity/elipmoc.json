{
	"address": "0x6ad817b9020adcb10b4a08e713bae0980385c674",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Based on the decompiled code provided, the corresponding Solidity contract could look like this:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Token {\n    mapping(address => uint256) public _balanceOf;\n    address public _owner;\n    uint256[] public _name;\n    uint256[] public _symbol;\n    uint256 public _tokenReward;\n    uint256 public _totalSupply;\n    uint256[] public _status;\n    uint256 public _start_token_time;\n    uint256 public _stop_token_time;\n    uint256 public _transferLock;\n    uint256 public _decimals;\n    uint256 public stor_3;\n\n    event Deposit(address indexed sender, uint256 amount, uint256[] data);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event change_Owner(string message);\n    event change_Time_Stamp(uint256 start, uint256 stop);\n    event change_Status(uint256[] data);\n    event token_Burn(address indexed burner, uint256 value);\n    event change_Name(uint256[] data);\n    event change_TokenReward(uint256 reward);\n    event token_Add(address indexed sender, uint256 value);\n    event change_Symbol(uint256[] data);\n\n    constructor() public {\n        _owner = msg.sender; \n    }\n\n    // Please note: not all functions are included in this example.\n\n    function admin_transfer(address recipient, uint256 amount) public {\n        require(_owner == msg.sender);\n        require(amount * stor_3 <= _balanceOf[msg.sender]);\n        require(_balanceOf[recipient] + amount * stor_3 >= _balanceOf[recipient]);\n        _balanceOf[msg.sender] -= amount * stor_3;\n        _balanceOf[recipient] += amount * stor_3;\n        emit Transfer(msg.sender, recipient, amount * stor_3);\n    }\n\n    function change_owner(address newOwner) public returns (bool) {\n        require(_owner == msg.sender);\n        _owner = newOwner;\n        emit change_Owner('Owner_change');\n        return true;\n    }\n\n    // Please note: not all functions are included in this example.\n}\n```\nPlease note that this is a simplified version and does not include all the functions from the decompiled code you've provided. Also, this contract does not do anything meaningful and is only intended to demonstrate how the original EVM bytecode could be represented in Solidity.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711535210,
	"id": "chatcmpl-97KmYbyFBRzERnSUyuqDinufL3DqM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 09:25 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _tokenReward; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256[] _status; // STORAGE[0x7]\nuint256 _start_token_time; // STORAGE[0x8]\nuint256 _stop_token_time; // STORAGE[0x9]\nuint256 _transferLock; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nuint256 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint256 _owner; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nDeposit(address, uint256, string);\nchange_Owner(string);\nchange_Time_Stamp(uint256, uint256);\nchange_Status(string);\ntoken_Burn(address, uint256);\nchange_Name(string);\nchange_TokenReward(uint256);\ntoken_Add(address, uint256);\nchange_Symbol(string);\nTransfer(address, address, uint256);\n\nfunction () public payable { \n    require(_start_token_time < block.timestamp);\n    require(block.timestamp < _stop_token_time);\n    v0 = new array[]((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n        if (31 < (_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _status.length >> 8 << 8;\n        }\n    }\n    emit Deposit(msg.sender, msg.value, v0);\n    require(_tokenReward * msg.value <= _balanceOf[_owner]);\n    require(_balanceOf[msg.sender] + _tokenReward * msg.value >= _balanceOf[msg.sender]);\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokenReward * msg.value;\n    _balanceOf[msg.sender] += _tokenReward * msg.value;\n    emit Transfer(_owner, msg.sender, _tokenReward * msg.value);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction admin_transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg1 * stor_3 <= _balanceOf[msg.sender]);\n    require(_balanceOf[varg0] + varg1 * stor_3 >= _balanceOf[varg0]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1 * stor_3;\n    _balanceOf[varg0] += varg1 * stor_3;\n    emit Transfer(msg.sender, varg0, varg1 * stor_3);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction status() public nonPayable { \n    v0 = new bytes[]((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n        if (31 < (_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _status.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction change_owner(address varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _owner = varg0;\n    emit change_Owner('Owner_change');\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction start_token_time() public nonPayable { \n    return _start_token_time;\n}\n\nfunction change_time_stamp_status(uint256 varg0, uint256 varg1, string varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    assert(_owner == msg.sender);\n    _start_token_time = varg0;\n    _stop_token_time = varg1;\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _status.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _status.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _status.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    emit change_Time_Stamp(_start_token_time, _stop_token_time);\n    v6 = new array[]((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _status.length >> 8 << 8;\n        }\n    }\n    emit change_Status(v6);\n    return 1;\n}\n\nfunction stop_token_time() public nonPayable { \n    return _stop_token_time;\n}\n\nfunction admin_token_burn(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg0 * stor_3 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0 * stor_3;\n    _totalSupply = _totalSupply - varg0 * stor_3;\n    emit token_Burn(msg.sender, varg0 * stor_3);\n    return 1;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction change_status(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _status.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _status.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _status.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _status.length >> 8 << 8;\n        }\n    }\n    emit change_Status(v6);\n    return 1;\n}\n\nfunction transferLock() public nonPayable { \n    return _transferLock;\n}\n\nfunction setTransferLock(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _transferLock = varg0;\n    return 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_transferLock);\n    require(varg1 <= _balanceOf[msg.sender]);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction ETH_withdraw(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction change_time_stamp(uint256 varg0, uint256 varg1) public nonPayable { \n    assert(_owner == msg.sender);\n    _start_token_time = varg0;\n    _stop_token_time = varg1;\n    emit change_Time_Stamp(varg0, varg1);\n    return 1;\n}\n\nfunction admin_from_To_transfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg2 * stor_3 <= _balanceOf[varg0]);\n    require(_balanceOf[varg1] + varg2 * stor_3 >= _balanceOf[varg1]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2 * stor_3;\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2 * stor_3;\n    emit Transfer(varg0, varg1, varg2 * stor_3);\n}\n\nfunction change_name(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _name.length >> 8 << 8;\n        }\n    }\n    emit change_Name(v6);\n    return 1;\n}\n\nfunction change_tokenReward(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _tokenReward = varg0;\n    emit change_TokenReward(varg0);\n    return 1;\n}\n\nfunction admin_token_add(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg0 * stor_3 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + varg0 * stor_3;\n    _totalSupply += varg0 * stor_3;\n    emit token_Add(msg.sender, varg0 * stor_3);\n    return 1;\n}\n\nfunction change_symbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _symbol.length >> 8 << 8;\n        }\n    }\n    emit change_Symbol(v6);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x6fdde03) {\n            name();\n        } else if (0xf822b78 == v0) {\n            admin_transfer(address,uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x200d2ed2 == v0) {\n            status();\n        } else if (0x253c8bd4 == v0) {\n            change_owner(address);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x44559f80 == v0) {\n            start_token_time();\n        } else if (0x44708f7d == v0) {\n            change_time_stamp_status(uint256,uint256,string);\n        } else if (0x5f77ace0 == v0) {\n            stop_token_time();\n        } else if (0x6c237c1c == v0) {\n            admin_token_burn(uint256);\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x70c7e230 == v0) {\n            change_status(string);\n        } else if (0x73124ced == v0) {\n            transferLock();\n        } else if (0x7f81f0b9 == v0) {\n            setTransferLock(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xaf862b6a == v0) {\n            ETH_withdraw(uint256);\n        } else if (0xbfcc4ab2 == v0) {\n            change_time_stamp(uint256,uint256);\n        } else if (0xddb792a0 == v0) {\n            admin_from_To_transfer(address,address,uint256);\n        } else if (0xe349cb12 == v0) {\n            change_name(string);\n        } else if (0xe4c82881 == v0) {\n            change_tokenReward(uint256);\n        } else if (0xe8c7df8a == v0) {\n            admin_token_add(uint256);\n        } else if (0xf3200a1c == v0) {\n            change_symbol(string);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 09:25 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _tokenReward; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256[] _status; // STORAGE[0x7]\nuint256 _start_token_time; // STORAGE[0x8]\nuint256 _stop_token_time; // STORAGE[0x9]\nuint256 _transferLock; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nuint256 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint256 _owner; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nDeposit(address, uint256, string);\nchange_Owner(string);\nchange_Time_Stamp(uint256, uint256);\nchange_Status(string);\ntoken_Burn(address, uint256);\nchange_Name(string);\nchange_TokenReward(uint256);\ntoken_Add(address, uint256);\nchange_Symbol(string);\nTransfer(address, address, uint256);\n\nfunction () public payable { \n    require(_start_token_time < block.timestamp);\n    require(block.timestamp < _stop_token_time);\n    v0 = new array[]((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n        if (31 < (_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _status.length >> 8 << 8;\n        }\n    }\n    emit Deposit(msg.sender, msg.value, v0);\n    require(_tokenReward * msg.value <= _balanceOf[_owner]);\n    require(_balanceOf[msg.sender] + _tokenReward * msg.value >= _balanceOf[msg.sender]);\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokenReward * msg.value;\n    _balanceOf[msg.sender] += _tokenReward * msg.value;\n    emit Transfer(_owner, msg.sender, _tokenReward * msg.value);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction admin_transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg1 * stor_3 <= _balanceOf[msg.sender]);\n    require(_balanceOf[varg0] + varg1 * stor_3 >= _balanceOf[varg0]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1 * stor_3;\n    _balanceOf[varg0] += varg1 * stor_3;\n    emit Transfer(msg.sender, varg0, varg1 * stor_3);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction status() public nonPayable { \n    v0 = new bytes[]((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n        if (31 < (_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _status.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction change_owner(address varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _owner = varg0;\n    emit change_Owner('Owner_change');\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction start_token_time() public nonPayable { \n    return _start_token_time;\n}\n\nfunction change_time_stamp_status(uint256 varg0, uint256 varg1, string varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    assert(_owner == msg.sender);\n    _start_token_time = varg0;\n    _stop_token_time = varg1;\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _status.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _status.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _status.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    emit change_Time_Stamp(_start_token_time, _stop_token_time);\n    v6 = new array[]((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _status.length >> 8 << 8;\n        }\n    }\n    emit change_Status(v6);\n    return 1;\n}\n\nfunction stop_token_time() public nonPayable { \n    return _stop_token_time;\n}\n\nfunction admin_token_burn(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg0 * stor_3 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0 * stor_3;\n    _totalSupply = _totalSupply - varg0 * stor_3;\n    emit token_Burn(msg.sender, varg0 * stor_3);\n    return 1;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction change_status(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _status.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _status.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _status.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _status.length >> 8 << 8;\n        }\n    }\n    emit change_Status(v6);\n    return 1;\n}\n\nfunction transferLock() public nonPayable { \n    return _transferLock;\n}\n\nfunction setTransferLock(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _transferLock = varg0;\n    return 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_transferLock);\n    require(varg1 <= _balanceOf[msg.sender]);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction ETH_withdraw(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction change_time_stamp(uint256 varg0, uint256 varg1) public nonPayable { \n    assert(_owner == msg.sender);\n    _start_token_time = varg0;\n    _stop_token_time = varg1;\n    emit change_Time_Stamp(varg0, varg1);\n    return 1;\n}\n\nfunction admin_from_To_transfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg2 * stor_3 <= _balanceOf[varg0]);\n    require(_balanceOf[varg1] + varg2 * stor_3 >= _balanceOf[varg1]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2 * stor_3;\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2 * stor_3;\n    emit Transfer(varg0, varg1, varg2 * stor_3);\n}\n\nfunction change_name(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _name.length >> 8 << 8;\n        }\n    }\n    emit change_Name(v6);\n    return 1;\n}\n\nfunction change_tokenReward(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _tokenReward = varg0;\n    emit change_TokenReward(varg0);\n    return 1;\n}\n\nfunction admin_token_add(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg0 * stor_3 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + varg0 * stor_3;\n    _totalSupply += varg0 * stor_3;\n    emit token_Add(msg.sender, varg0 * stor_3);\n    return 1;\n}\n\nfunction change_symbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _symbol.length >> 8 << 8;\n        }\n    }\n    emit change_Symbol(v6);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x6fdde03) {\n            name();\n        } else if (0xf822b78 == v0) {\n            admin_transfer(address,uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x200d2ed2 == v0) {\n            status();\n        } else if (0x253c8bd4 == v0) {\n            change_owner(address);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x44559f80 == v0) {\n            start_token_time();\n        } else if (0x44708f7d == v0) {\n            change_time_stamp_status(uint256,uint256,string);\n        } else if (0x5f77ace0 == v0) {\n            stop_token_time();\n        } else if (0x6c237c1c == v0) {\n            admin_token_burn(uint256);\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x70c7e230 == v0) {\n            change_status(string);\n        } else if (0x73124ced == v0) {\n            transferLock();\n        } else if (0x7f81f0b9 == v0) {\n            setTransferLock(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xaf862b6a == v0) {\n            ETH_withdraw(uint256);\n        } else if (0xbfcc4ab2 == v0) {\n            change_time_stamp(uint256,uint256);\n        } else if (0xddb792a0 == v0) {\n            admin_from_To_transfer(address,address,uint256);\n        } else if (0xe349cb12 == v0) {\n            change_name(string);\n        } else if (0xe4c82881 == v0) {\n            change_tokenReward(uint256);\n        } else if (0xe8c7df8a == v0) {\n            admin_token_add(uint256);\n        } else if (0xf3200a1c == v0) {\n            change_symbol(string);\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 09:25 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _tokenReward; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256[] _status; // STORAGE[0x7]\nuint256 _start_token_time; // STORAGE[0x8]\nuint256 _stop_token_time; // STORAGE[0x9]\nuint256 _transferLock; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nuint256 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint256 _owner; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nDeposit(address, uint256, string);\nchange_Owner(string);\nchange_Time_Stamp(uint256, uint256);\nchange_Status(string);\ntoken_Burn(address, uint256);\nchange_Name(string);\nchange_TokenReward(uint256);\ntoken_Add(address, uint256);\nchange_Symbol(string);\nTransfer(address, address, uint256);\n\nfunction () public payable { \n    require(_start_token_time < block.timestamp);\n    require(block.timestamp < _stop_token_time);\n    v0 = new array[]((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n        if (31 < (_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _status.length >> 8 << 8;\n        }\n    }\n    emit Deposit(msg.sender, msg.value, v0);\n    require(_tokenReward * msg.value <= _balanceOf[_owner]);\n    require(_balanceOf[msg.sender] + _tokenReward * msg.value >= _balanceOf[msg.sender]);\n    _balanceOf[_owner] = _balanceOf[_owner] - _tokenReward * msg.value;\n    _balanceOf[msg.sender] += _tokenReward * msg.value;\n    emit Transfer(_owner, msg.sender, _tokenReward * msg.value);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction admin_transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg1 * stor_3 <= _balanceOf[msg.sender]);\n    require(_balanceOf[varg0] + varg1 * stor_3 >= _balanceOf[varg0]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1 * stor_3;\n    _balanceOf[varg0] += varg1 * stor_3;\n    emit Transfer(msg.sender, varg0, varg1 * stor_3);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction status() public nonPayable { \n    v0 = new bytes[]((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n        if (31 < (_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_status.length & ~0 + (!(_status.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _status.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction change_owner(address varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _owner = varg0;\n    emit change_Owner('Owner_change');\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction start_token_time() public nonPayable { \n    return _start_token_time;\n}\n\nfunction change_time_stamp_status(uint256 varg0, uint256 varg1, string varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    assert(_owner == msg.sender);\n    _start_token_time = varg0;\n    _stop_token_time = varg1;\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _status.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _status.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _status.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    emit change_Time_Stamp(_start_token_time, _stop_token_time);\n    v6 = new array[]((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _status.length >> 8 << 8;\n        }\n    }\n    emit change_Status(v6);\n    return 1;\n}\n\nfunction stop_token_time() public nonPayable { \n    return _stop_token_time;\n}\n\nfunction admin_token_burn(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg0 * stor_3 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0 * stor_3;\n    _totalSupply = _totalSupply - varg0 * stor_3;\n    emit token_Burn(msg.sender, varg0 * stor_3);\n    return 1;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction change_status(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _status.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _status.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _status.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_status.length & (!(_status.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _status.length >> 8 << 8;\n        }\n    }\n    emit change_Status(v6);\n    return 1;\n}\n\nfunction transferLock() public nonPayable { \n    return _transferLock;\n}\n\nfunction setTransferLock(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _transferLock = varg0;\n    return 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_transferLock);\n    require(varg1 <= _balanceOf[msg.sender]);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction ETH_withdraw(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction change_time_stamp(uint256 varg0, uint256 varg1) public nonPayable { \n    assert(_owner == msg.sender);\n    _start_token_time = varg0;\n    _stop_token_time = varg1;\n    emit change_Time_Stamp(varg0, varg1);\n    return 1;\n}\n\nfunction admin_from_To_transfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg2 * stor_3 <= _balanceOf[varg0]);\n    require(_balanceOf[varg1] + varg2 * stor_3 >= _balanceOf[varg1]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2 * stor_3;\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2 * stor_3;\n    emit Transfer(varg0, varg1, varg2 * stor_3);\n}\n\nfunction change_name(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _name.length >> 8 << 8;\n        }\n    }\n    emit change_Name(v6);\n    return 1;\n}\n\nfunction change_tokenReward(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    _tokenReward = varg0;\n    emit change_TokenReward(varg0);\n    return 1;\n}\n\nfunction admin_token_add(uint256 varg0) public nonPayable { \n    assert(_owner == msg.sender);\n    require(varg0 * stor_3 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + varg0 * stor_3;\n    _totalSupply += varg0 * stor_3;\n    emit token_Add(msg.sender, varg0 * stor_3);\n    return 1;\n}\n\nfunction change_symbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    assert(_owner == msg.sender);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = new array[]((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1);\n    v7 = v8 = v6.data;\n    if ((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) {\n            do {\n                MEM[v7] = STORAGE[v9];\n                v9 += 1;\n                v7 += 32;\n            } while (v8 + ((_symbol.length & (!(0x1 & _symbol.length) << 8) + ~0) >> 1) <= v7);\n        } else {\n            MEM[v8] = _symbol.length >> 8 << 8;\n        }\n    }\n    emit change_Symbol(v6);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x6fdde03) {\n            name();\n        } else if (0xf822b78 == v0) {\n            admin_transfer(address,uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x200d2ed2 == v0) {\n            status();\n        } else if (0x253c8bd4 == v0) {\n            change_owner(address);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x44559f80 == v0) {\n            start_token_time();\n        } else if (0x44708f7d == v0) {\n            change_time_stamp_status(uint256,uint256,string);\n        } else if (0x5f77ace0 == v0) {\n            stop_token_time();\n        } else if (0x6c237c1c == v0) {\n            admin_token_burn(uint256);\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x70c7e230 == v0) {\n            change_status(string);\n        } else if (0x73124ced == v0) {\n            transferLock();\n        } else if (0x7f81f0b9 == v0) {\n            setTransferLock(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xaf862b6a == v0) {\n            ETH_withdraw(uint256);\n        } else if (0xbfcc4ab2 == v0) {\n            change_time_stamp(uint256,uint256);\n        } else if (0xddb792a0 == v0) {\n            admin_from_To_transfer(address,address,uint256);\n        } else if (0xe349cb12 == v0) {\n            change_name(string);\n        } else if (0xe4c82881 == v0) {\n            change_tokenReward(uint256);\n        } else if (0xe8c7df8a == v0) {\n            admin_token_add(uint256);\n        } else if (0xf3200a1c == v0) {\n            change_symbol(string);\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 91.08737349510193,
	"usage": {
		"completion_tokens": 492,
		"prompt_tokens": 5024,
		"total_tokens": 5516
	}
}