{
	"address": "0x7a3822a45dd6e6c91cc87012b3059266106e122d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is your contract code based on the decompiled code:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Contract {\n    uint256 private _rate;\n    uint256 private _weiRaised;\n    uint256 private stor_5;\n    uint256 private stor_6;\n    uint256 private stor_7;\n    uint256 private stor_8;\n    uint256 private stor_9;\n    uint256 private _softCap;\n    uint256 private _hardCap;\n    uint256 private _preICO_1_Start;\n    uint256 private _preICO_2_Start;\n    uint256 private _preICO_3_Start;\n    uint256 private _iCO_Start;\n    uint256 private _iCO_End;\n    mapping (uint256 => uint256) private _whitelist;\n    mapping (uint256 => uint256) private _threeMonthsFreezingAccrual;\n    mapping (uint256 => uint256) private _sixMonthsFreezingAccrual;\n    mapping (uint256 => uint256) private _nineMonthsFreezingAccrual;\n    mapping (uint256 => uint256) private _twelveMonthsFreezingAccrual;\n    mapping (uint256 => uint256) private _ledger;\n    address private _isOwner;\n    address private _token;\n    uint32 private _bonus1;\n    uint32 private _bonus2;\n    address private _wallet;\n    uint32 private _bonus3;\n    uint32 private _whitelistedBonus;\n\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n    event Refunded(address indexed beneficiary, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Released(address indexed beneficiary, uint256 amount);\n    event Accrual(address indexed beneficiary, uint256 tokens, uint256 date, uint256 amount, uint256 weiAmount);\n    \n    // ... please implement the functions according to the decompiled code\n}\n```\n\nPlease note that you need to implement the functions based on the decompiled code. The decompiled code is quite complex and there are some parts that are not clear without additional context. For example, it's unclear what some variables such as `stor_5`, `stor_6`, etc. represent. Also, the code has some private functions with hexadecimal names. It's not clear what the original function names were, and the same goes for the parameters. \n\nIn addition, the decompiled code shows event calls, but does not define the events themselves. You'll need to define the events in your Solidity code. The event definitions provided above are only guesses based on the decompiled code and may not be entirely accurate. \n\nPlease review the code and implement the functions and events according to your contract\u2019s logic.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457926,
	"id": "chatcmpl-8R3DilB0UJq4Dv7b045kT6MTVMlzM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 03:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x3]\nuint256 _weiRaised; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _softCap; // STORAGE[0xc]\nuint256 _hardCap; // STORAGE[0xd]\nuint256 _preICO_1_Start; // STORAGE[0xe]\nuint256 _preICO_2_Start; // STORAGE[0xf]\nuint256 _preICO_3_Start; // STORAGE[0x10]\nuint256 _iCO_Start; // STORAGE[0x11]\nuint256 _iCO_End; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _threeMonthsFreezingAccrual; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _sixMonthsFreezingAccrual; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _nineMonthsFreezingAccrual; // STORAGE[0x17]\nmapping (uint256 => [uint256]) _twelveMonthsFreezingAccrual; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _ledger; // STORAGE[0x19]\naddress _isOwner; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x1] bytes 0 to 19\nuint32 _bonus1; // STORAGE[0x13] bytes 0 to 3\nuint32 _bonus2; // STORAGE[0x13] bytes 4 to 7\naddress _wallet; // STORAGE[0x2] bytes 0 to 19\nuint32 _bonus3; // STORAGE[0x13] bytes 8 to 11\nuint32 _whitelistedBonus; // STORAGE[0x13] bytes 12 to 15\n\n// Events\nTokensPurchased(address, address, uint256, uint256);\nRefunded(address, uint256);\nOwnershipTransferred(address, address);\nReleased(address, uint256);\nAccrual(address, uint256, uint256, uint256, uint256);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x15d9(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(_token.code.size);\n    v1, v2 = _token.transfer(v0, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    return ;\n}\n\nfunction 0x1673(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x553(msg.sender);\n}\n\nfunction nineMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _nineMonthsFreezingAccrual[varg0];\n}\n\nfunction accrueBountyTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _twelveMonthsFreezingAccrual[varg0]);\n    _twelveMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_9, 0, 0);\n}\n\nfunction preICO_3_Start() public nonPayable { \n    return _preICO_3_Start;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction bonus1() public nonPayable { \n    return _bonus1;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction preICO_2_Start() public nonPayable { \n    return _preICO_2_Start;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction accruePartnersTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _nineMonthsFreezingAccrual[varg0]);\n    _nineMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_8, 0, 0);\n}\n\nfunction refund() public nonPayable { \n    require(block.timestamp > _iCO_End);\n    require(_weiRaised < _softCap);\n    require(_ledger[msg.sender] > 0);\n    _ledger[msg.sender] = 0;\n    v0 = msg.sender.call().value(_ledger[msg.sender]).gas(2300 * !_ledger[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n    emit Refunded(msg.sender, _ledger[msg.sender]);\n}\n\nfunction bonus2() public nonPayable { \n    return _bonus2;\n}\n\nfunction accrueAdvisorsTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _sixMonthsFreezingAccrual[varg0]);\n    _sixMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_7, 0, 0);\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner);\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction twelveMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _twelveMonthsFreezingAccrual[varg0];\n}\n\nfunction sixMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _sixMonthsFreezingAccrual[varg0];\n}\n\nfunction release() public nonPayable { \n    v0 = v1 = 0;\n    v2 = _SafeAdd(stor_9, _iCO_End);\n    v3 = v4 = block.timestamp > v2;\n    if (v4) {\n        v3 = _twelveMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v3) {\n        v0 = v5 = _SafeAdd(_twelveMonthsFreezingAccrual[msg.sender], v1);\n        require(_twelveMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _twelveMonthsFreezingAccrual[msg.sender];\n        _twelveMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v6 = _SafeAdd(stor_8, _iCO_End);\n    v7 = v8 = block.timestamp > v6;\n    if (v8) {\n        v7 = _nineMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v7) {\n        v0 = v9 = _SafeAdd(_nineMonthsFreezingAccrual[msg.sender], v0);\n        require(_nineMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _nineMonthsFreezingAccrual[msg.sender];\n        _nineMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v10 = _SafeAdd(stor_7, _iCO_End);\n    v11 = v12 = block.timestamp > v10;\n    if (v12) {\n        v11 = _sixMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v11) {\n        v0 = v13 = _SafeAdd(_sixMonthsFreezingAccrual[msg.sender], v0);\n        require(_sixMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _sixMonthsFreezingAccrual[msg.sender];\n        _sixMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v14 = _SafeAdd(stor_6, _iCO_End);\n    v15 = v16 = block.timestamp > v14;\n    if (v16) {\n        v15 = _threeMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v15) {\n        v0 = v17 = _SafeAdd(_threeMonthsFreezingAccrual[msg.sender], v0);\n        require(_threeMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _threeMonthsFreezingAccrual[msg.sender];\n        _threeMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    if (v0 > 0) {\n        0x15d9(v0, msg.sender);\n        emit Released(msg.sender, v0);\n    }\n}\n\nfunction removeFromWhitelist(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    _whitelist[varg0] = ~0xff & _whitelist[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction softCap() public nonPayable { \n    return _softCap;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return 0xff & _whitelist[varg0];\n}\n\nfunction ICO_Start() public nonPayable { \n    return _iCO_Start;\n}\n\nfunction ICO_End() public nonPayable { \n    return _iCO_End;\n}\n\nfunction bonus3() public nonPayable { \n    return _bonus3;\n}\n\nfunction preICO_1_Start() public nonPayable { \n    return _preICO_1_Start;\n}\n\nfunction whitelistedBonus() public nonPayable { \n    return _whitelistedBonus;\n}\n\nfunction addToWhitelist(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    _whitelist[varg0] = 0x1 | ~0xff & _whitelist[varg0];\n}\n\nfunction threeMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _threeMonthsFreezingAccrual[varg0];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x553(varg0);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(varg0);\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction ledger(address varg0) public nonPayable { \n    return _ledger[varg0];\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x553(uint256 varg0) private { \n    require(address(varg0));\n    require(msg.value);\n    v0 = _SafeAdd(msg.value, _weiRaised);\n    require(v0 <= _hardCap);\n    require(block.timestamp >= _preICO_1_Start);\n    require(block.timestamp <= _iCO_End);\n    v1 = 0x1673(_rate, msg.value);\n    require(0xde0b6b3a7640000 > 0);\n    assert(0xde0b6b3a7640000);\n    v2 = 0;\n    require(_token.code.size);\n    v3, v4 = _token.balanceOf(this).value(v2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = address(varg0);\n    v6 = v7 = 0xff & _whitelist[v5];\n    if (v7) {\n        v6 = block.timestamp < _iCO_Start;\n    }\n    if (v6) {\n        v2 = v8 = _whitelistedBonus + v2;\n    }\n    if (block.timestamp >= _preICO_2_Start) {\n        if (block.timestamp >= _preICO_3_Start) {\n            if (block.timestamp >= _iCO_Start) {\n                v9 = _SafeAdd(v1 / 0xde0b6b3a7640000, stor_5);\n                require(v4 >= v9);\n                v10 = address(varg0);\n                emit Accrual(v10, 0, 0, v1 / 0xde0b6b3a7640000, msg.value);\n            } else {\n                v11 = v12 = 5163;\n                v13 = v14 = 100;\n                v15 = v16 = 0x1673(uint32(v2 + _bonus3), v1 / 0xde0b6b3a7640000);\n            }\n        } else {\n            v11 = v17 = 4900;\n            v13 = v18 = 100;\n            v15 = v19 = 0x1673(uint32(v2 + _bonus2), v1 / 0xde0b6b3a7640000);\n        }\n    } else {\n        v11 = v20 = 4625;\n        v13 = v21 = 100;\n        v15 = v22 = 0x1673(uint32(_bonus1 + v2), v1 / 0xde0b6b3a7640000);\n    }\n    require(v13 > 0);\n    assert(v13);\n    v23 = v15 / v13;\n    goto {'0x1211B0x569', '0x1324B0x569', '0x142bB0x569'};\n    v24 = v25 = 4664;\n    v26 = v27 = _SafeAdd(v23, stor_5);\n    v28 = _SafeAdd(v1 / 0xde0b6b3a7640000, v26);\n    require(v4 >= v28);\n    v29 = _SafeAdd(v23, stor_5);\n    stor_5 = v29;\n    v30 = address(varg0);\n    v31 = _SafeAdd(v23, _nineMonthsFreezingAccrual[v30]);\n    v32 = address(varg0);\n    _nineMonthsFreezingAccrual[v32] = v31;\n    emit Accrual(v32, v23, stor_8, v1 / 0xde0b6b3a7640000, msg.value);\n    require(v4 >= v28);\n    v33 = _SafeAdd(v23, stor_5);\n    stor_5 = v33;\n    v34 = address(varg0);\n    v35 = _SafeAdd(v23, _sixMonthsFreezingAccrual[v34]);\n    v36 = address(varg0);\n    _sixMonthsFreezingAccrual[v36] = v35;\n    emit Accrual(v36, v23, stor_7, v1 / 0xde0b6b3a7640000, msg.value);\n    require(v4 >= v28);\n    v37 = _SafeAdd(v23, stor_5);\n    stor_5 = v37;\n    v38 = address(varg0);\n    v39 = _SafeAdd(v23, _threeMonthsFreezingAccrual[v38]);\n    v40 = address(varg0);\n    _threeMonthsFreezingAccrual[v40] = v39;\n    emit Accrual(v40, v23, stor_6, v1 / 0xde0b6b3a7640000, msg.value);\n    v24 = v41 = 4927;\n    v26 = v42 = _SafeAdd(v23, stor_5);\n    v24 = 5190;\n    v26 = _SafeAdd(v23, stor_5);\n    v43 = _SafeAdd(msg.value, _weiRaised);\n    _weiRaised = v43;\n    0x15d9(v1 / 0xde0b6b3a7640000, varg0);\n    emit TokensPurchased(msg.sender, address(varg0), msg.value, v1 / 0xde0b6b3a7640000);\n    if (_weiRaised >= _softCap) {\n        v44 = _wallet.call().value(this.balance).gas(2300 * !this.balance);\n        require(v44); // checks call status, propagates error data on error\n        goto 0x5f1;\n    }\n    v45 = _SafeAdd(msg.value, _ledger[msg.sender]);\n    _ledger[msg.sender] = v45;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x122eb421) {\n            nineMonthsFreezingAccrual(address);\n        } else if (0x28553325 == function_selector) {\n            accrueBountyTokens(address,uint256);\n        } else if (0x28c0f928 == function_selector) {\n            preICO_3_Start();\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x30818189 == function_selector) {\n            bonus1();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4e3e5d69 == function_selector) {\n            preICO_2_Start();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x5689dfc5 == function_selector) {\n            accruePartnersTokens(address,uint256);\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x67e8d3d2 == function_selector) {\n            bonus2();\n        } else if (0x70cfb159 == function_selector) {\n            accrueAdvisorsTokens(address,uint256);\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x72053124 == function_selector) {\n            twelveMonthsFreezingAccrual(address);\n        } else if (0x867a30d9 == function_selector) {\n            sixMonthsFreezingAccrual(address);\n        } else if (0x86d1a69f == function_selector) {\n            release();\n        } else if (0x8ab1d681 == function_selector) {\n            removeFromWhitelist(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8f32d59b == function_selector) {\n            isOwner();\n        } else if (0x906a26e0 == function_selector) {\n            softCap();\n        } else if (0x9b19251a == function_selector) {\n            whitelist(address);\n        } else if (0x9fe6a6f1 == function_selector) {\n            ICO_Start();\n        } else if (0xa48eaa20 == function_selector) {\n            ICO_End();\n        } else if (0xab86ba3a == function_selector) {\n            bonus3();\n        } else if (0xccf9495d == function_selector) {\n            preICO_1_Start();\n        } else if (0xe33e7ffd == function_selector) {\n            whitelistedBonus();\n        } else if (0xe43252d7 == function_selector) {\n            addToWhitelist(address);\n        } else if (0xe508750b == function_selector) {\n            threeMonthsFreezingAccrual(address);\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        } else if (0xfbfa941f == function_selector) {\n            ledger(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 03:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x3]\nuint256 _weiRaised; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _softCap; // STORAGE[0xc]\nuint256 _hardCap; // STORAGE[0xd]\nuint256 _preICO_1_Start; // STORAGE[0xe]\nuint256 _preICO_2_Start; // STORAGE[0xf]\nuint256 _preICO_3_Start; // STORAGE[0x10]\nuint256 _iCO_Start; // STORAGE[0x11]\nuint256 _iCO_End; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _threeMonthsFreezingAccrual; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _sixMonthsFreezingAccrual; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _nineMonthsFreezingAccrual; // STORAGE[0x17]\nmapping (uint256 => [uint256]) _twelveMonthsFreezingAccrual; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _ledger; // STORAGE[0x19]\naddress _isOwner; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x1] bytes 0 to 19\nuint32 _bonus1; // STORAGE[0x13] bytes 0 to 3\nuint32 _bonus2; // STORAGE[0x13] bytes 4 to 7\naddress _wallet; // STORAGE[0x2] bytes 0 to 19\nuint32 _bonus3; // STORAGE[0x13] bytes 8 to 11\nuint32 _whitelistedBonus; // STORAGE[0x13] bytes 12 to 15\n\n// Events\nTokensPurchased(address, address, uint256, uint256);\nRefunded(address, uint256);\nOwnershipTransferred(address, address);\nReleased(address, uint256);\nAccrual(address, uint256, uint256, uint256, uint256);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x15d9(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(_token.code.size);\n    v1, v2 = _token.transfer(v0, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    return ;\n}\n\nfunction 0x1673(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x553(msg.sender);\n}\n\nfunction nineMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _nineMonthsFreezingAccrual[varg0];\n}\n\nfunction accrueBountyTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _twelveMonthsFreezingAccrual[varg0]);\n    _twelveMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_9, 0, 0);\n}\n\nfunction preICO_3_Start() public nonPayable { \n    return _preICO_3_Start;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction bonus1() public nonPayable { \n    return _bonus1;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction preICO_2_Start() public nonPayable { \n    return _preICO_2_Start;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction accruePartnersTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _nineMonthsFreezingAccrual[varg0]);\n    _nineMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_8, 0, 0);\n}\n\nfunction refund() public nonPayable { \n    require(block.timestamp > _iCO_End);\n    require(_weiRaised < _softCap);\n    require(_ledger[msg.sender] > 0);\n    _ledger[msg.sender] = 0;\n    v0 = msg.sender.call().value(_ledger[msg.sender]).gas(2300 * !_ledger[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n    emit Refunded(msg.sender, _ledger[msg.sender]);\n}\n\nfunction bonus2() public nonPayable { \n    return _bonus2;\n}\n\nfunction accrueAdvisorsTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _sixMonthsFreezingAccrual[varg0]);\n    _sixMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_7, 0, 0);\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner);\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction twelveMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _twelveMonthsFreezingAccrual[varg0];\n}\n\nfunction sixMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _sixMonthsFreezingAccrual[varg0];\n}\n\nfunction release() public nonPayable { \n    v0 = v1 = 0;\n    v2 = _SafeAdd(stor_9, _iCO_End);\n    v3 = v4 = block.timestamp > v2;\n    if (v4) {\n        v3 = _twelveMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v3) {\n        v0 = v5 = _SafeAdd(_twelveMonthsFreezingAccrual[msg.sender], v1);\n        require(_twelveMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _twelveMonthsFreezingAccrual[msg.sender];\n        _twelveMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v6 = _SafeAdd(stor_8, _iCO_End);\n    v7 = v8 = block.timestamp > v6;\n    if (v8) {\n        v7 = _nineMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v7) {\n        v0 = v9 = _SafeAdd(_nineMonthsFreezingAccrual[msg.sender], v0);\n        require(_nineMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _nineMonthsFreezingAccrual[msg.sender];\n        _nineMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v10 = _SafeAdd(stor_7, _iCO_End);\n    v11 = v12 = block.timestamp > v10;\n    if (v12) {\n        v11 = _sixMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v11) {\n        v0 = v13 = _SafeAdd(_sixMonthsFreezingAccrual[msg.sender], v0);\n        require(_sixMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _sixMonthsFreezingAccrual[msg.sender];\n        _sixMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v14 = _SafeAdd(stor_6, _iCO_End);\n    v15 = v16 = block.timestamp > v14;\n    if (v16) {\n        v15 = _threeMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v15) {\n        v0 = v17 = _SafeAdd(_threeMonthsFreezingAccrual[msg.sender], v0);\n        require(_threeMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _threeMonthsFreezingAccrual[msg.sender];\n        _threeMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    if (v0 > 0) {\n        0x15d9(v0, msg.sender);\n        emit Released(msg.sender, v0);\n    }\n}\n\nfunction removeFromWhitelist(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    _whitelist[varg0] = ~0xff & _whitelist[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction softCap() public nonPayable { \n    return _softCap;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return 0xff & _whitelist[varg0];\n}\n\nfunction ICO_Start() public nonPayable { \n    return _iCO_Start;\n}\n\nfunction ICO_End() public nonPayable { \n    return _iCO_End;\n}\n\nfunction bonus3() public nonPayable { \n    return _bonus3;\n}\n\nfunction preICO_1_Start() public nonPayable { \n    return _preICO_1_Start;\n}\n\nfunction whitelistedBonus() public nonPayable { \n    return _whitelistedBonus;\n}\n\nfunction addToWhitelist(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    _whitelist[varg0] = 0x1 | ~0xff & _whitelist[varg0];\n}\n\nfunction threeMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _threeMonthsFreezingAccrual[varg0];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x553(varg0);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(varg0);\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction ledger(address varg0) public nonPayable { \n    return _ledger[varg0];\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x553(uint256 varg0) private { \n    require(address(varg0));\n    require(msg.value);\n    v0 = _SafeAdd(msg.value, _weiRaised);\n    require(v0 <= _hardCap);\n    require(block.timestamp >= _preICO_1_Start);\n    require(block.timestamp <= _iCO_End);\n    v1 = 0x1673(_rate, msg.value);\n    require(0xde0b6b3a7640000 > 0);\n    assert(0xde0b6b3a7640000);\n    v2 = 0;\n    require(_token.code.size);\n    v3, v4 = _token.balanceOf(this).value(v2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = address(varg0);\n    v6 = v7 = 0xff & _whitelist[v5];\n    if (v7) {\n        v6 = block.timestamp < _iCO_Start;\n    }\n    if (v6) {\n        v2 = v8 = _whitelistedBonus + v2;\n    }\n    if (block.timestamp >= _preICO_2_Start) {\n        if (block.timestamp >= _preICO_3_Start) {\n            if (block.timestamp >= _iCO_Start) {\n                v9 = _SafeAdd(v1 / 0xde0b6b3a7640000, stor_5);\n                require(v4 >= v9);\n                v10 = address(varg0);\n                emit Accrual(v10, 0, 0, v1 / 0xde0b6b3a7640000, msg.value);\n            } else {\n                v11 = v12 = 5163;\n                v13 = v14 = 100;\n                v15 = v16 = 0x1673(uint32(v2 + _bonus3), v1 / 0xde0b6b3a7640000);\n            }\n        } else {\n            v11 = v17 = 4900;\n            v13 = v18 = 100;\n            v15 = v19 = 0x1673(uint32(v2 + _bonus2), v1 / 0xde0b6b3a7640000);\n        }\n    } else {\n        v11 = v20 = 4625;\n        v13 = v21 = 100;\n        v15 = v22 = 0x1673(uint32(_bonus1 + v2), v1 / 0xde0b6b3a7640000);\n    }\n    require(v13 > 0);\n    assert(v13);\n    v23 = v15 / v13;\n    goto {'0x1211B0x569', '0x1324B0x569', '0x142bB0x569'};\n    v24 = v25 = 4664;\n    v26 = v27 = _SafeAdd(v23, stor_5);\n    v28 = _SafeAdd(v1 / 0xde0b6b3a7640000, v26);\n    require(v4 >= v28);\n    v29 = _SafeAdd(v23, stor_5);\n    stor_5 = v29;\n    v30 = address(varg0);\n    v31 = _SafeAdd(v23, _nineMonthsFreezingAccrual[v30]);\n    v32 = address(varg0);\n    _nineMonthsFreezingAccrual[v32] = v31;\n    emit Accrual(v32, v23, stor_8, v1 / 0xde0b6b3a7640000, msg.value);\n    require(v4 >= v28);\n    v33 = _SafeAdd(v23, stor_5);\n    stor_5 = v33;\n    v34 = address(varg0);\n    v35 = _SafeAdd(v23, _sixMonthsFreezingAccrual[v34]);\n    v36 = address(varg0);\n    _sixMonthsFreezingAccrual[v36] = v35;\n    emit Accrual(v36, v23, stor_7, v1 / 0xde0b6b3a7640000, msg.value);\n    require(v4 >= v28);\n    v37 = _SafeAdd(v23, stor_5);\n    stor_5 = v37;\n    v38 = address(varg0);\n    v39 = _SafeAdd(v23, _threeMonthsFreezingAccrual[v38]);\n    v40 = address(varg0);\n    _threeMonthsFreezingAccrual[v40] = v39;\n    emit Accrual(v40, v23, stor_6, v1 / 0xde0b6b3a7640000, msg.value);\n    v24 = v41 = 4927;\n    v26 = v42 = _SafeAdd(v23, stor_5);\n    v24 = 5190;\n    v26 = _SafeAdd(v23, stor_5);\n    v43 = _SafeAdd(msg.value, _weiRaised);\n    _weiRaised = v43;\n    0x15d9(v1 / 0xde0b6b3a7640000, varg0);\n    emit TokensPurchased(msg.sender, address(varg0), msg.value, v1 / 0xde0b6b3a7640000);\n    if (_weiRaised >= _softCap) {\n        v44 = _wallet.call().value(this.balance).gas(2300 * !this.balance);\n        require(v44); // checks call status, propagates error data on error\n        goto 0x5f1;\n    }\n    v45 = _SafeAdd(msg.value, _ledger[msg.sender]);\n    _ledger[msg.sender] = v45;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x122eb421) {\n            nineMonthsFreezingAccrual(address);\n        } else if (0x28553325 == function_selector) {\n            accrueBountyTokens(address,uint256);\n        } else if (0x28c0f928 == function_selector) {\n            preICO_3_Start();\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x30818189 == function_selector) {\n            bonus1();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4e3e5d69 == function_selector) {\n            preICO_2_Start();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x5689dfc5 == function_selector) {\n            accruePartnersTokens(address,uint256);\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x67e8d3d2 == function_selector) {\n            bonus2();\n        } else if (0x70cfb159 == function_selector) {\n            accrueAdvisorsTokens(address,uint256);\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x72053124 == function_selector) {\n            twelveMonthsFreezingAccrual(address);\n        } else if (0x867a30d9 == function_selector) {\n            sixMonthsFreezingAccrual(address);\n        } else if (0x86d1a69f == function_selector) {\n            release();\n        } else if (0x8ab1d681 == function_selector) {\n            removeFromWhitelist(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8f32d59b == function_selector) {\n            isOwner();\n        } else if (0x906a26e0 == function_selector) {\n            softCap();\n        } else if (0x9b19251a == function_selector) {\n            whitelist(address);\n        } else if (0x9fe6a6f1 == function_selector) {\n            ICO_Start();\n        } else if (0xa48eaa20 == function_selector) {\n            ICO_End();\n        } else if (0xab86ba3a == function_selector) {\n            bonus3();\n        } else if (0xccf9495d == function_selector) {\n            preICO_1_Start();\n        } else if (0xe33e7ffd == function_selector) {\n            whitelistedBonus();\n        } else if (0xe43252d7 == function_selector) {\n            addToWhitelist(address);\n        } else if (0xe508750b == function_selector) {\n            threeMonthsFreezingAccrual(address);\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        } else if (0xfbfa941f == function_selector) {\n            ledger(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 03:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x3]\nuint256 _weiRaised; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _softCap; // STORAGE[0xc]\nuint256 _hardCap; // STORAGE[0xd]\nuint256 _preICO_1_Start; // STORAGE[0xe]\nuint256 _preICO_2_Start; // STORAGE[0xf]\nuint256 _preICO_3_Start; // STORAGE[0x10]\nuint256 _iCO_Start; // STORAGE[0x11]\nuint256 _iCO_End; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _threeMonthsFreezingAccrual; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _sixMonthsFreezingAccrual; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _nineMonthsFreezingAccrual; // STORAGE[0x17]\nmapping (uint256 => [uint256]) _twelveMonthsFreezingAccrual; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _ledger; // STORAGE[0x19]\naddress _isOwner; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x1] bytes 0 to 19\nuint32 _bonus1; // STORAGE[0x13] bytes 0 to 3\nuint32 _bonus2; // STORAGE[0x13] bytes 4 to 7\naddress _wallet; // STORAGE[0x2] bytes 0 to 19\nuint32 _bonus3; // STORAGE[0x13] bytes 8 to 11\nuint32 _whitelistedBonus; // STORAGE[0x13] bytes 12 to 15\n\n// Events\nTokensPurchased(address, address, uint256, uint256);\nRefunded(address, uint256);\nOwnershipTransferred(address, address);\nReleased(address, uint256);\nAccrual(address, uint256, uint256, uint256, uint256);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x15d9(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(_token.code.size);\n    v1, v2 = _token.transfer(v0, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    return ;\n}\n\nfunction 0x1673(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x553(msg.sender);\n}\n\nfunction nineMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _nineMonthsFreezingAccrual[varg0];\n}\n\nfunction accrueBountyTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _twelveMonthsFreezingAccrual[varg0]);\n    _twelveMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_9, 0, 0);\n}\n\nfunction preICO_3_Start() public nonPayable { \n    return _preICO_3_Start;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction bonus1() public nonPayable { \n    return _bonus1;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction preICO_2_Start() public nonPayable { \n    return _preICO_2_Start;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction accruePartnersTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _nineMonthsFreezingAccrual[varg0]);\n    _nineMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_8, 0, 0);\n}\n\nfunction refund() public nonPayable { \n    require(block.timestamp > _iCO_End);\n    require(_weiRaised < _softCap);\n    require(_ledger[msg.sender] > 0);\n    _ledger[msg.sender] = 0;\n    v0 = msg.sender.call().value(_ledger[msg.sender]).gas(2300 * !_ledger[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n    emit Refunded(msg.sender, _ledger[msg.sender]);\n}\n\nfunction bonus2() public nonPayable { \n    return _bonus2;\n}\n\nfunction accrueAdvisorsTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(block.timestamp > _iCO_End);\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _SafeAdd(varg1, stor_5);\n    require(v1 >= v2);\n    v3 = _SafeAdd(varg1, stor_5);\n    stor_5 = v3;\n    v4 = _SafeAdd(varg1, _sixMonthsFreezingAccrual[varg0]);\n    _sixMonthsFreezingAccrual[varg0] = v4;\n    emit Accrual(varg0, varg1, stor_7, 0, 0);\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner);\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction twelveMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _twelveMonthsFreezingAccrual[varg0];\n}\n\nfunction sixMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _sixMonthsFreezingAccrual[varg0];\n}\n\nfunction release() public nonPayable { \n    v0 = v1 = 0;\n    v2 = _SafeAdd(stor_9, _iCO_End);\n    v3 = v4 = block.timestamp > v2;\n    if (v4) {\n        v3 = _twelveMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v3) {\n        v0 = v5 = _SafeAdd(_twelveMonthsFreezingAccrual[msg.sender], v1);\n        require(_twelveMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _twelveMonthsFreezingAccrual[msg.sender];\n        _twelveMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v6 = _SafeAdd(stor_8, _iCO_End);\n    v7 = v8 = block.timestamp > v6;\n    if (v8) {\n        v7 = _nineMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v7) {\n        v0 = v9 = _SafeAdd(_nineMonthsFreezingAccrual[msg.sender], v0);\n        require(_nineMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _nineMonthsFreezingAccrual[msg.sender];\n        _nineMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v10 = _SafeAdd(stor_7, _iCO_End);\n    v11 = v12 = block.timestamp > v10;\n    if (v12) {\n        v11 = _sixMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v11) {\n        v0 = v13 = _SafeAdd(_sixMonthsFreezingAccrual[msg.sender], v0);\n        require(_sixMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _sixMonthsFreezingAccrual[msg.sender];\n        _sixMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    v14 = _SafeAdd(stor_6, _iCO_End);\n    v15 = v16 = block.timestamp > v14;\n    if (v16) {\n        v15 = _threeMonthsFreezingAccrual[msg.sender] > 0;\n    }\n    if (v15) {\n        v0 = v17 = _SafeAdd(_threeMonthsFreezingAccrual[msg.sender], v0);\n        require(_threeMonthsFreezingAccrual[msg.sender] <= stor_5);\n        stor_5 = stor_5 - _threeMonthsFreezingAccrual[msg.sender];\n        _threeMonthsFreezingAccrual[msg.sender] = 0;\n    }\n    if (v0 > 0) {\n        0x15d9(v0, msg.sender);\n        emit Released(msg.sender, v0);\n    }\n}\n\nfunction removeFromWhitelist(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    _whitelist[varg0] = ~0xff & _whitelist[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction softCap() public nonPayable { \n    return _softCap;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return 0xff & _whitelist[varg0];\n}\n\nfunction ICO_Start() public nonPayable { \n    return _iCO_Start;\n}\n\nfunction ICO_End() public nonPayable { \n    return _iCO_End;\n}\n\nfunction bonus3() public nonPayable { \n    return _bonus3;\n}\n\nfunction preICO_1_Start() public nonPayable { \n    return _preICO_1_Start;\n}\n\nfunction whitelistedBonus() public nonPayable { \n    return _whitelistedBonus;\n}\n\nfunction addToWhitelist(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    _whitelist[varg0] = 0x1 | ~0xff & _whitelist[varg0];\n}\n\nfunction threeMonthsFreezingAccrual(address varg0) public nonPayable { \n    return _threeMonthsFreezingAccrual[varg0];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x553(varg0);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _isOwner);\n    require(varg0);\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction ledger(address varg0) public nonPayable { \n    return _ledger[varg0];\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x553(uint256 varg0) private { \n    require(address(varg0));\n    require(msg.value);\n    v0 = _SafeAdd(msg.value, _weiRaised);\n    require(v0 <= _hardCap);\n    require(block.timestamp >= _preICO_1_Start);\n    require(block.timestamp <= _iCO_End);\n    v1 = 0x1673(_rate, msg.value);\n    require(0xde0b6b3a7640000 > 0);\n    assert(0xde0b6b3a7640000);\n    v2 = 0;\n    require(_token.code.size);\n    v3, v4 = _token.balanceOf(this).value(v2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v5 = address(varg0);\n    v6 = v7 = 0xff & _whitelist[v5];\n    if (v7) {\n        v6 = block.timestamp < _iCO_Start;\n    }\n    if (v6) {\n        v2 = v8 = _whitelistedBonus + v2;\n    }\n    if (block.timestamp >= _preICO_2_Start) {\n        if (block.timestamp >= _preICO_3_Start) {\n            if (block.timestamp >= _iCO_Start) {\n                v9 = _SafeAdd(v1 / 0xde0b6b3a7640000, stor_5);\n                require(v4 >= v9);\n                v10 = address(varg0);\n                emit Accrual(v10, 0, 0, v1 / 0xde0b6b3a7640000, msg.value);\n            } else {\n                v11 = v12 = 5163;\n                v13 = v14 = 100;\n                v15 = v16 = 0x1673(uint32(v2 + _bonus3), v1 / 0xde0b6b3a7640000);\n            }\n        } else {\n            v11 = v17 = 4900;\n            v13 = v18 = 100;\n            v15 = v19 = 0x1673(uint32(v2 + _bonus2), v1 / 0xde0b6b3a7640000);\n        }\n    } else {\n        v11 = v20 = 4625;\n        v13 = v21 = 100;\n        v15 = v22 = 0x1673(uint32(_bonus1 + v2), v1 / 0xde0b6b3a7640000);\n    }\n    require(v13 > 0);\n    assert(v13);\n    v23 = v15 / v13;\n    goto {'0x1211B0x569', '0x1324B0x569', '0x142bB0x569'};\n    v24 = v25 = 4664;\n    v26 = v27 = _SafeAdd(v23, stor_5);\n    v28 = _SafeAdd(v1 / 0xde0b6b3a7640000, v26);\n    require(v4 >= v28);\n    v29 = _SafeAdd(v23, stor_5);\n    stor_5 = v29;\n    v30 = address(varg0);\n    v31 = _SafeAdd(v23, _nineMonthsFreezingAccrual[v30]);\n    v32 = address(varg0);\n    _nineMonthsFreezingAccrual[v32] = v31;\n    emit Accrual(v32, v23, stor_8, v1 / 0xde0b6b3a7640000, msg.value);\n    require(v4 >= v28);\n    v33 = _SafeAdd(v23, stor_5);\n    stor_5 = v33;\n    v34 = address(varg0);\n    v35 = _SafeAdd(v23, _sixMonthsFreezingAccrual[v34]);\n    v36 = address(varg0);\n    _sixMonthsFreezingAccrual[v36] = v35;\n    emit Accrual(v36, v23, stor_7, v1 / 0xde0b6b3a7640000, msg.value);\n    require(v4 >= v28);\n    v37 = _SafeAdd(v23, stor_5);\n    stor_5 = v37;\n    v38 = address(varg0);\n    v39 = _SafeAdd(v23, _threeMonthsFreezingAccrual[v38]);\n    v40 = address(varg0);\n    _threeMonthsFreezingAccrual[v40] = v39;\n    emit Accrual(v40, v23, stor_6, v1 / 0xde0b6b3a7640000, msg.value);\n    v24 = v41 = 4927;\n    v26 = v42 = _SafeAdd(v23, stor_5);\n    v24 = 5190;\n    v26 = _SafeAdd(v23, stor_5);\n    v43 = _SafeAdd(msg.value, _weiRaised);\n    _weiRaised = v43;\n    0x15d9(v1 / 0xde0b6b3a7640000, varg0);\n    emit TokensPurchased(msg.sender, address(varg0), msg.value, v1 / 0xde0b6b3a7640000);\n    if (_weiRaised >= _softCap) {\n        v44 = _wallet.call().value(this.balance).gas(2300 * !this.balance);\n        require(v44); // checks call status, propagates error data on error\n        goto 0x5f1;\n    }\n    v45 = _SafeAdd(msg.value, _ledger[msg.sender]);\n    _ledger[msg.sender] = v45;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x122eb421) {\n            nineMonthsFreezingAccrual(address);\n        } else if (0x28553325 == function_selector) {\n            accrueBountyTokens(address,uint256);\n        } else if (0x28c0f928 == function_selector) {\n            preICO_3_Start();\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x30818189 == function_selector) {\n            bonus1();\n        } else if (0x4042b66f == function_selector) {\n            weiRaised();\n        } else if (0x4e3e5d69 == function_selector) {\n            preICO_2_Start();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x5689dfc5 == function_selector) {\n            accruePartnersTokens(address,uint256);\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x67e8d3d2 == function_selector) {\n            bonus2();\n        } else if (0x70cfb159 == function_selector) {\n            accrueAdvisorsTokens(address,uint256);\n        } else if (0x715018a6 == function_selector) {\n            renounceOwnership();\n        } else if (0x72053124 == function_selector) {\n            twelveMonthsFreezingAccrual(address);\n        } else if (0x867a30d9 == function_selector) {\n            sixMonthsFreezingAccrual(address);\n        } else if (0x86d1a69f == function_selector) {\n            release();\n        } else if (0x8ab1d681 == function_selector) {\n            removeFromWhitelist(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8f32d59b == function_selector) {\n            isOwner();\n        } else if (0x906a26e0 == function_selector) {\n            softCap();\n        } else if (0x9b19251a == function_selector) {\n            whitelist(address);\n        } else if (0x9fe6a6f1 == function_selector) {\n            ICO_Start();\n        } else if (0xa48eaa20 == function_selector) {\n            ICO_End();\n        } else if (0xab86ba3a == function_selector) {\n            bonus3();\n        } else if (0xccf9495d == function_selector) {\n            preICO_1_Start();\n        } else if (0xe33e7ffd == function_selector) {\n            whitelistedBonus();\n        } else if (0xe43252d7 == function_selector) {\n            addToWhitelist(address);\n        } else if (0xe508750b == function_selector) {\n            threeMonthsFreezingAccrual(address);\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        } else if (0xfbfa941f == function_selector) {\n            ledger(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 25.497804164886475,
	"usage": {
		"completion_tokens": 587,
		"prompt_tokens": 4984,
		"total_tokens": 5571
	}
}