{
	"address": "0x94a16fb83a625558709f2609cc4697c8163fe4f9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, here's a Solidity smart contract that may resemble the original contract:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    uint256 private _decimals;\n    bool private _checkBurnStatus;\n    address private _owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        _owner = msg.sender;\n        _totalSupply = 1000000;\n        _decimals = 18;\n        _checkBurnStatus = false;\n        _balances[_owner] = _totalSupply;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function update(uint256 newSupply) public {\n        require(msg.sender == _owner, \"Not the correct Address\");\n        _totalSupply = newSupply;\n    }\n\n    function setBurnStatus(bool newStatus) public {\n        require(msg.sender == _owner, \"Not the correct Address\");\n        _checkBurnStatus = newStatus;\n    }\n\n    function checkBurnStatus() public view returns (bool) {\n        return _checkBurnStatus;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balances[msg.sender] >= amount, \"Not enoough balance in account\");\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_balances[sender] >= amount, \"Not enoough balance in account\");\n        require(_allowances[sender][msg.sender] >= amount, \"Not enoough allowance in account\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // Additional methods related to staking, due transfers, and other operations as provided in the decompiled code can be added here...\n}\n```\nPlease note that the actual contract could have been more complex with additional functionalities, and the decompiled code has limitations that may not capture the original contract's full functionalities.",
				"role": "assistant"
			}
		}
	],
	"created": 1698041446,
	"id": "chatcmpl-8CiRCLLe8K9jqfumnkdFDuwBDbvaE",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.26 15:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _decimals; // STORAGE[0x4]\nuint256 _checkBurnStatus; // STORAGE[0x5]\nuint256[] _stakeOf__value; // STORAGE[0x9]\nuint256[] _dueTransferOf__buyer; // STORAGE[0xa]\nuint256 _transfer; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 _update; // STORAGE[0xd]\nuint256 _setBurnStatus; // STORAGE[0xe]\n\n// Events\nTransfer(address, address, uint256);\nPay(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction update(uint256 varg0) public nonPayable { \n    require(msg.sender == _update, Error(32, 23, 'Not the correct Address'));\n    stor_3 = varg0;\n    return 1;\n}\n\nfunction setBurnStatus(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _setBurnStatus, Error(32, 23, 'Not the correct Address'));\n    _checkBurnStatus = varg0;\n    return 1;\n}\n\nfunction checkBurnStatus() public nonPayable { \n    return _checkBurnStatus;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(7, varg0), varg1)];\n}\n\nfunction stake(uint256 varg0, uint256 varg1) public nonPayable { \n    require(STORAGE[keccak256(6, msg.sender)] >= varg0);\n    STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg1))] = msg.sender;\n    _stakeOf__value[1] = varg0;\n    _stakeOf__value[2] = block.timestamp;\n    require(STORAGE[keccak256(8, msg.sender)] + varg0 >= STORAGE[keccak256(8, msg.sender)]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] + varg0;\n    return 1;\n}\n\nfunction removeStake(uint256 varg0) public nonPayable { \n    require(_stakeOf__value[1] > 0);\n    require(_stakeOf__value[2] + 1800 >= _stakeOf__value[2]);\n    require(_stakeOf__value[2] + 300 >= _stakeOf__value[2]);\n    if (!((block.timestamp > _stakeOf__value[2] + 300) & (block.timestamp < _stakeOf__value[2] + 1800))) {\n        require(_stakeOf__value[2] + 3600 >= _stakeOf__value[2]);\n        require(_stakeOf__value[2] + 1800 >= _stakeOf__value[2]);\n        if (!((block.timestamp > _stakeOf__value[2] + 1800) & (block.timestamp < _stakeOf__value[2] + 3600))) {\n            require(_stakeOf__value[2] + 3600 >= _stakeOf__value[2]);\n            if (block.timestamp <= _stakeOf__value[2] + 3600) {\n                STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n                _stakeOf__value[1] = 0;\n                _stakeOf__value[2] = 0;\n                require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n                STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n                return 1;\n            } else {\n                require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n                require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n                require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n                STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n                emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n                STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n                _stakeOf__value[1] = 0;\n                _stakeOf__value[2] = 0;\n                require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n                STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n                return 1;\n            }\n        } else {\n            require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n            require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n            require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n            emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n            STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n            _stakeOf__value[1] = 0;\n            _stakeOf__value[2] = 0;\n            require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n            STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n            return 1;\n        }\n    } else {\n        require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n        require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n        STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n        require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n        emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n        STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    }\n}\n\nfunction setDueTransfer(uint256 varg0, address varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(6, msg.sender)] >= varg2, Error(32, 29, 'Not enough balance in account'));\n    require(!_dueTransferOf__buyer[2], Error(32, 31, 'Already have data in the workId'));\n    require((0x15180 * varg3 / 0x15180 == varg3) | !0x15180);\n    require(0x15180 * varg3 + block.timestamp >= 0x15180 * varg3);\n    STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))] = varg1;\n    _dueTransferOf__buyer[1] = msg.sender;\n    _dueTransferOf__buyer[2] = varg2;\n    _dueTransferOf__buyer[3] = stor_3;\n    _dueTransferOf__buyer[4] = block.timestamp;\n    _dueTransferOf__buyer[5] = 0x15180 * varg3 + block.timestamp;\n    _dueTransferOf__buyer[6] = 0;\n    require(STORAGE[keccak256(8, msg.sender)] + varg2 >= STORAGE[keccak256(8, msg.sender)]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] + varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(6, msg.sender)] >= varg1);\n    require(STORAGE[keccak256(8, msg.sender)] <= STORAGE[keccak256(6, msg.sender)] - varg1, Error(32, 30, 'Not enoough balance in account'));\n    require(STORAGE[keccak256(6, msg.sender)] >= varg1);\n    STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - varg1;\n    require(STORAGE[keccak256(6, varg0)] + varg1 >= STORAGE[keccak256(6, varg0)]);\n    STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    MEM[576] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= varg1 / 100);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - varg1 / 100;\n        emit Transfer(_transfer, 0, varg1 / 100);\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(6, varg0)] >= varg2);\n    require(STORAGE[keccak256(8, varg0)] <= STORAGE[keccak256(6, varg0)] - varg2);\n    require(STORAGE[keccak256(6, varg0)] >= varg2);\n    STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - varg2;\n    require(STORAGE[keccak256(6, varg1)] + varg2 >= STORAGE[keccak256(6, varg1)]);\n    STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(7, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(7, varg0), msg.sender)] = STORAGE[keccak256(keccak256(7, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= varg2 / 100);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - varg2 / 100;\n        emit Transfer(_transfer, 0, varg2 / 100);\n    }\n}\n\nfunction submitTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))];\n    if (stor_3 <= _dueTransferOf__buyer[3]) {\n        if (stor_3 >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= stor_3);\n            require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n            require(stor_3);\n            require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(msg.sender, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    } else {\n        require(stor_3 >= _dueTransferOf__buyer[3]);\n        require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n        require(stor_3);\n        require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n        STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction declineTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    MEM[384] = STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))];\n    require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(6, _update)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, _update)]);\n    STORAGE[keccak256(6, _update)] = STORAGE[keccak256(6, _update)] + _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(8, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _dueTransferOf__buyer[2];\n    _dueTransferOf__buyer[6] = 1;\n    emit Transfer(msg.sender, _update, _dueTransferOf__buyer[2]);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(7, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction resolve(uint256 varg0, address varg1, bool varg2) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(varg2 < 2);\n    require(msg.sender == _update);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, varg1), varg0))];\n    if (varg2 == 1) {\n        if (stor_3 <= _dueTransferOf__buyer[3]) {\n            if (stor_3 >= _dueTransferOf__buyer[3]) {\n                require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(6, v0)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] - _dueTransferOf__buyer[2];\n                emit Pay(varg1, v0, _dueTransferOf__buyer[2]);\n            } else {\n                require(_dueTransferOf__buyer[3] >= stor_3);\n                require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n                require(stor_3);\n                require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n                STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n                STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n                emit Transfer(varg1, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n            }\n        } else {\n            require(stor_3 >= _dueTransferOf__buyer[3]);\n            require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n            require(stor_3);\n            require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg1, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    }\n    if (!varg2) {\n        require(STORAGE[keccak256(6, stor_c)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, varg1)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, varg1)]);\n        STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + _dueTransferOf__buyer[2];\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction request(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 >= _dueTransferOf__buyer[5]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 <= block.timestamp);\n    require(!_dueTransferOf__buyer[6]);\n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, varg0), varg1))];\n    if (stor_3 <= _dueTransferOf__buyer[3]) {\n        if (stor_3 >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= stor_3);\n            require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n            require(stor_3);\n            require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(varg0, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    } else {\n        require(stor_3 >= _dueTransferOf__buyer[3]);\n        require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n        require(stor_3);\n        require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n        STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(6, varg0)];\n}\n\nfunction holdOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, varg0)];\n}\n\nfunction stakeOf__holder(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(9, varg0), varg1))];\n}\n\nfunction stakeOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[1];\n}\n\nfunction stakeOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[2];\n}\n\nfunction dueTransferOf__seller(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(10, varg0), varg1))];\n}\n\nfunction dueTransferOf__buyer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[1];\n}\n\nfunction dueTransferOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[2];\n}\n\nfunction dueTransferOf__netValue(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[3];\n}\n\nfunction dueTransferOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[4];\n}\n\nfunction dueTransferOf__subDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[5];\n}\n\nfunction dueTransferOf__declined(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0x6a054250) {\n                if (function_selector != 0x97a2d0eb) {\n                    if (function_selector != 0x77884378) {\n                        if (function_selector != 0xdd62ed3e) {\n                            if (function_selector != 0x7b0472f0) {\n                                if (function_selector != 0x939624ab) {\n                                    if (function_selector != 0x49c662b8) {\n                                        if (function_selector != 0xa9059cbb) {\n                                            if (function_selector != 0x23b872dd) {\n                                                if (function_selector != 0xa6f12e85) {\n                                                    if (function_selector != 0x60dded11) {\n                                                        if (function_selector != 0x95ea7b3) {\n                                                            if (function_selector != 0x48e45ca) {\n                                                                if (function_selector != 0xc8c01a55) {\n                                                                    if (function_selector != 0x6fdde03) {\n                                                                        if (function_selector != 0x95d89b41) {\n                                                                            if (function_selector != 0x313ce567) {\n                                                                                if (function_selector != 0x70a08231) {\n                                                                                    if (function_selector != 0x9ddd7c21) {\n                                                                                        if (function_selector != 0x421f8e14) {\n                                                                                            if (function_selector != 0xe9562a6d) {\n                                                                                                if (function_selector != 0xf94be3af) {\n                                                                                                    if (function_selector != 0x8f33367a) {\n                                                                                                        if (function_selector != 0xb53574ab) {\n                                                                                                            if (function_selector != 0xa1bb138e) {\n                                                                                                                if (function_selector != 0x674b392e) {\n                                                                                                                    if (function_selector != 0x410bf99) {\n                                                                                                                        if (function_selector != 0x1952ddbd) {\n                                                                                                                            if (function_selector == 0xb993ed4b) {\n                                                                                                                                dueTransferOf__declined(address,uint256);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            dueTransferOf__subDate(address,uint256);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        dueTransferOf__setDate(address,uint256);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    dueTransferOf__netValue(address,uint256);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                dueTransferOf__value(address,uint256);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            dueTransferOf__buyer(address,uint256);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        dueTransferOf__seller(address,uint256);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    stakeOf__setDate(address,uint256);\n                                                                                                }\n                                                                                            } else {\n                                                                                                stakeOf__value(address,uint256);\n                                                                                            }\n                                                                                        } else {\n                                                                                            stakeOf__holder(address,uint256);\n                                                                                        }\n                                                                                    } else {\n                                                                                        holdOf(address);\n                                                                                    }\n                                                                                } else {\n                                                                                    balanceOf(address);\n                                                                                }\n                                                                            } else {\n                                                                                decimals();\n                                                                            }\n                                                                        } else {\n                                                                            symbol();\n                                                                        }\n                                                                    } else {\n                                                                        name();\n                                                                    }\n                                                                } else {\n                                                                    request(address,uint256);\n                                                                }\n                                                            } else {\n                                                                resolve(uint256,address,bool);\n                                                            }\n                                                        } else {\n                                                            approve(address,uint256);\n                                                        }\n                                                    } else {\n                                                        declineTransfer(uint256);\n                                                    }\n                                                } else {\n                                                    submitTransfer(uint256);\n                                                }\n                                            } else {\n                                                transferFrom(address,address,uint256);\n                                            }\n                                        } else {\n                                            transfer(address,uint256);\n                                        }\n                                    } else {\n                                        setDueTransfer(uint256,address,uint256,uint256);\n                                    }\n                                } else {\n                                    removeStake(uint256);\n                                }\n                            } else {\n                                stake(uint256,uint256);\n                            }\n                        } else {\n                            allowance(address,address);\n                        }\n                    } else {\n                        checkBurnStatus();\n                    }\n                } else {\n                    setBurnStatus(bool);\n                }\n            } else {\n                update(uint256,uint256,uint256);\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.26 15:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _decimals; // STORAGE[0x4]\nuint256 _checkBurnStatus; // STORAGE[0x5]\nuint256[] _stakeOf__value; // STORAGE[0x9]\nuint256[] _dueTransferOf__buyer; // STORAGE[0xa]\nuint256 _transfer; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 _update; // STORAGE[0xd]\nuint256 _setBurnStatus; // STORAGE[0xe]\n\n// Events\nTransfer(address, address, uint256);\nPay(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction update(uint256 varg0) public nonPayable { \n    require(msg.sender == _update, Error(32, 23, 'Not the correct Address'));\n    stor_3 = varg0;\n    return 1;\n}\n\nfunction setBurnStatus(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _setBurnStatus, Error(32, 23, 'Not the correct Address'));\n    _checkBurnStatus = varg0;\n    return 1;\n}\n\nfunction checkBurnStatus() public nonPayable { \n    return _checkBurnStatus;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(7, varg0), varg1)];\n}\n\nfunction stake(uint256 varg0, uint256 varg1) public nonPayable { \n    require(STORAGE[keccak256(6, msg.sender)] >= varg0);\n    STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg1))] = msg.sender;\n    _stakeOf__value[1] = varg0;\n    _stakeOf__value[2] = block.timestamp;\n    require(STORAGE[keccak256(8, msg.sender)] + varg0 >= STORAGE[keccak256(8, msg.sender)]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] + varg0;\n    return 1;\n}\n\nfunction removeStake(uint256 varg0) public nonPayable { \n    require(_stakeOf__value[1] > 0);\n    require(_stakeOf__value[2] + 1800 >= _stakeOf__value[2]);\n    require(_stakeOf__value[2] + 300 >= _stakeOf__value[2]);\n    if (!((block.timestamp > _stakeOf__value[2] + 300) & (block.timestamp < _stakeOf__value[2] + 1800))) {\n        require(_stakeOf__value[2] + 3600 >= _stakeOf__value[2]);\n        require(_stakeOf__value[2] + 1800 >= _stakeOf__value[2]);\n        if (!((block.timestamp > _stakeOf__value[2] + 1800) & (block.timestamp < _stakeOf__value[2] + 3600))) {\n            require(_stakeOf__value[2] + 3600 >= _stakeOf__value[2]);\n            if (block.timestamp <= _stakeOf__value[2] + 3600) {\n                STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n                _stakeOf__value[1] = 0;\n                _stakeOf__value[2] = 0;\n                require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n                STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n                return 1;\n            } else {\n                require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n                require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n                require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n                STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n                emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n                STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n                _stakeOf__value[1] = 0;\n                _stakeOf__value[2] = 0;\n                require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n                STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n                return 1;\n            }\n        } else {\n            require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n            require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n            require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n            emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n            STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n            _stakeOf__value[1] = 0;\n            _stakeOf__value[2] = 0;\n            require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n            STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n            return 1;\n        }\n    } else {\n        require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n        require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n        STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n        require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n        emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n        STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    }\n}\n\nfunction setDueTransfer(uint256 varg0, address varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(6, msg.sender)] >= varg2, Error(32, 29, 'Not enough balance in account'));\n    require(!_dueTransferOf__buyer[2], Error(32, 31, 'Already have data in the workId'));\n    require((0x15180 * varg3 / 0x15180 == varg3) | !0x15180);\n    require(0x15180 * varg3 + block.timestamp >= 0x15180 * varg3);\n    STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))] = varg1;\n    _dueTransferOf__buyer[1] = msg.sender;\n    _dueTransferOf__buyer[2] = varg2;\n    _dueTransferOf__buyer[3] = stor_3;\n    _dueTransferOf__buyer[4] = block.timestamp;\n    _dueTransferOf__buyer[5] = 0x15180 * varg3 + block.timestamp;\n    _dueTransferOf__buyer[6] = 0;\n    require(STORAGE[keccak256(8, msg.sender)] + varg2 >= STORAGE[keccak256(8, msg.sender)]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] + varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(6, msg.sender)] >= varg1);\n    require(STORAGE[keccak256(8, msg.sender)] <= STORAGE[keccak256(6, msg.sender)] - varg1, Error(32, 30, 'Not enoough balance in account'));\n    require(STORAGE[keccak256(6, msg.sender)] >= varg1);\n    STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - varg1;\n    require(STORAGE[keccak256(6, varg0)] + varg1 >= STORAGE[keccak256(6, varg0)]);\n    STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    MEM[576] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= varg1 / 100);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - varg1 / 100;\n        emit Transfer(_transfer, 0, varg1 / 100);\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(6, varg0)] >= varg2);\n    require(STORAGE[keccak256(8, varg0)] <= STORAGE[keccak256(6, varg0)] - varg2);\n    require(STORAGE[keccak256(6, varg0)] >= varg2);\n    STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - varg2;\n    require(STORAGE[keccak256(6, varg1)] + varg2 >= STORAGE[keccak256(6, varg1)]);\n    STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(7, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(7, varg0), msg.sender)] = STORAGE[keccak256(keccak256(7, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= varg2 / 100);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - varg2 / 100;\n        emit Transfer(_transfer, 0, varg2 / 100);\n    }\n}\n\nfunction submitTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))];\n    if (stor_3 <= _dueTransferOf__buyer[3]) {\n        if (stor_3 >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= stor_3);\n            require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n            require(stor_3);\n            require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(msg.sender, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    } else {\n        require(stor_3 >= _dueTransferOf__buyer[3]);\n        require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n        require(stor_3);\n        require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n        STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction declineTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    MEM[384] = STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))];\n    require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(6, _update)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, _update)]);\n    STORAGE[keccak256(6, _update)] = STORAGE[keccak256(6, _update)] + _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(8, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _dueTransferOf__buyer[2];\n    _dueTransferOf__buyer[6] = 1;\n    emit Transfer(msg.sender, _update, _dueTransferOf__buyer[2]);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(7, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction resolve(uint256 varg0, address varg1, bool varg2) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(varg2 < 2);\n    require(msg.sender == _update);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, varg1), varg0))];\n    if (varg2 == 1) {\n        if (stor_3 <= _dueTransferOf__buyer[3]) {\n            if (stor_3 >= _dueTransferOf__buyer[3]) {\n                require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(6, v0)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] - _dueTransferOf__buyer[2];\n                emit Pay(varg1, v0, _dueTransferOf__buyer[2]);\n            } else {\n                require(_dueTransferOf__buyer[3] >= stor_3);\n                require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n                require(stor_3);\n                require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n                STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n                STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n                emit Transfer(varg1, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n            }\n        } else {\n            require(stor_3 >= _dueTransferOf__buyer[3]);\n            require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n            require(stor_3);\n            require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg1, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    }\n    if (!varg2) {\n        require(STORAGE[keccak256(6, stor_c)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, varg1)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, varg1)]);\n        STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + _dueTransferOf__buyer[2];\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction request(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 >= _dueTransferOf__buyer[5]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 <= block.timestamp);\n    require(!_dueTransferOf__buyer[6]);\n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, varg0), varg1))];\n    if (stor_3 <= _dueTransferOf__buyer[3]) {\n        if (stor_3 >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= stor_3);\n            require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n            require(stor_3);\n            require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(varg0, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    } else {\n        require(stor_3 >= _dueTransferOf__buyer[3]);\n        require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n        require(stor_3);\n        require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n        STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(6, varg0)];\n}\n\nfunction holdOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, varg0)];\n}\n\nfunction stakeOf__holder(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(9, varg0), varg1))];\n}\n\nfunction stakeOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[1];\n}\n\nfunction stakeOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[2];\n}\n\nfunction dueTransferOf__seller(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(10, varg0), varg1))];\n}\n\nfunction dueTransferOf__buyer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[1];\n}\n\nfunction dueTransferOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[2];\n}\n\nfunction dueTransferOf__netValue(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[3];\n}\n\nfunction dueTransferOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[4];\n}\n\nfunction dueTransferOf__subDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[5];\n}\n\nfunction dueTransferOf__declined(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0x6a054250) {\n                if (function_selector != 0x97a2d0eb) {\n                    if (function_selector != 0x77884378) {\n                        if (function_selector != 0xdd62ed3e) {\n                            if (function_selector != 0x7b0472f0) {\n                                if (function_selector != 0x939624ab) {\n                                    if (function_selector != 0x49c662b8) {\n                                        if (function_selector != 0xa9059cbb) {\n                                            if (function_selector != 0x23b872dd) {\n                                                if (function_selector != 0xa6f12e85) {\n                                                    if (function_selector != 0x60dded11) {\n                                                        if (function_selector != 0x95ea7b3) {\n                                                            if (function_selector != 0x48e45ca) {\n                                                                if (function_selector != 0xc8c01a55) {\n                                                                    if (function_selector != 0x6fdde03) {\n                                                                        if (function_selector != 0x95d89b41) {\n                                                                            if (function_selector != 0x313ce567) {\n                                                                                if (function_selector != 0x70a08231) {\n                                                                                    if (function_selector != 0x9ddd7c21) {\n                                                                                        if (function_selector != 0x421f8e14) {\n                                                                                            if (function_selector != 0xe9562a6d) {\n                                                                                                if (function_selector != 0xf94be3af) {\n                                                                                                    if (function_selector != 0x8f33367a) {\n                                                                                                        if (function_selector != 0xb53574ab) {\n                                                                                                            if (function_selector != 0xa1bb138e) {\n                                                                                                                if (function_selector != 0x674b392e) {\n                                                                                                                    if (function_selector != 0x410bf99) {\n                                                                                                                        if (function_selector != 0x1952ddbd) {\n                                                                                                                            if (function_selector == 0xb993ed4b) {\n                                                                                                                                dueTransferOf__declined(address,uint256);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            dueTransferOf__subDate(address,uint256);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        dueTransferOf__setDate(address,uint256);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    dueTransferOf__netValue(address,uint256);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                dueTransferOf__value(address,uint256);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            dueTransferOf__buyer(address,uint256);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        dueTransferOf__seller(address,uint256);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    stakeOf__setDate(address,uint256);\n                                                                                                }\n                                                                                            } else {\n                                                                                                stakeOf__value(address,uint256);\n                                                                                            }\n                                                                                        } else {\n                                                                                            stakeOf__holder(address,uint256);\n                                                                                        }\n                                                                                    } else {\n                                                                                        holdOf(address);\n                                                                                    }\n                                                                                } else {\n                                                                                    balanceOf(address);\n                                                                                }\n                                                                            } else {\n                                                                                decimals();\n                                                                            }\n                                                                        } else {\n                                                                            symbol();\n                                                                        }\n                                                                    } else {\n                                                                        name();\n                                                                    }\n                                                                } else {\n                                                                    request(address,uint256);\n                                                                }\n                                                            } else {\n                                                                resolve(uint256,address,bool);\n                                                            }\n                                                        } else {\n                                                            approve(address,uint256);\n                                                        }\n                                                    } else {\n                                                        declineTransfer(uint256);\n                                                    }\n                                                } else {\n                                                    submitTransfer(uint256);\n                                                }\n                                            } else {\n                                                transferFrom(address,address,uint256);\n                                            }\n                                        } else {\n                                            transfer(address,uint256);\n                                        }\n                                    } else {\n                                        setDueTransfer(uint256,address,uint256,uint256);\n                                    }\n                                } else {\n                                    removeStake(uint256);\n                                }\n                            } else {\n                                stake(uint256,uint256);\n                            }\n                        } else {\n                            allowance(address,address);\n                        }\n                    } else {\n                        checkBurnStatus();\n                    }\n                } else {\n                    setBurnStatus(bool);\n                }\n            } else {\n                update(uint256,uint256,uint256);\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.26 15:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _decimals; // STORAGE[0x4]\nuint256 _checkBurnStatus; // STORAGE[0x5]\nuint256[] _stakeOf__value; // STORAGE[0x9]\nuint256[] _dueTransferOf__buyer; // STORAGE[0xa]\nuint256 _transfer; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 _update; // STORAGE[0xd]\nuint256 _setBurnStatus; // STORAGE[0xe]\n\n// Events\nTransfer(address, address, uint256);\nPay(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction update(uint256 varg0) public nonPayable { \n    require(msg.sender == _update, Error(32, 23, 'Not the correct Address'));\n    stor_3 = varg0;\n    return 1;\n}\n\nfunction setBurnStatus(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _setBurnStatus, Error(32, 23, 'Not the correct Address'));\n    _checkBurnStatus = varg0;\n    return 1;\n}\n\nfunction checkBurnStatus() public nonPayable { \n    return _checkBurnStatus;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(7, varg0), varg1)];\n}\n\nfunction stake(uint256 varg0, uint256 varg1) public nonPayable { \n    require(STORAGE[keccak256(6, msg.sender)] >= varg0);\n    STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg1))] = msg.sender;\n    _stakeOf__value[1] = varg0;\n    _stakeOf__value[2] = block.timestamp;\n    require(STORAGE[keccak256(8, msg.sender)] + varg0 >= STORAGE[keccak256(8, msg.sender)]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] + varg0;\n    return 1;\n}\n\nfunction removeStake(uint256 varg0) public nonPayable { \n    require(_stakeOf__value[1] > 0);\n    require(_stakeOf__value[2] + 1800 >= _stakeOf__value[2]);\n    require(_stakeOf__value[2] + 300 >= _stakeOf__value[2]);\n    if (!((block.timestamp > _stakeOf__value[2] + 300) & (block.timestamp < _stakeOf__value[2] + 1800))) {\n        require(_stakeOf__value[2] + 3600 >= _stakeOf__value[2]);\n        require(_stakeOf__value[2] + 1800 >= _stakeOf__value[2]);\n        if (!((block.timestamp > _stakeOf__value[2] + 1800) & (block.timestamp < _stakeOf__value[2] + 3600))) {\n            require(_stakeOf__value[2] + 3600 >= _stakeOf__value[2]);\n            if (block.timestamp <= _stakeOf__value[2] + 3600) {\n                STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n                _stakeOf__value[1] = 0;\n                _stakeOf__value[2] = 0;\n                require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n                STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n                return 1;\n            } else {\n                require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n                require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n                require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n                STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n                emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n                STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n                _stakeOf__value[1] = 0;\n                _stakeOf__value[2] = 0;\n                require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n                STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n                return 1;\n            }\n        } else {\n            require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n            require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n            require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n            emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n            STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n            _stakeOf__value[1] = 0;\n            _stakeOf__value[2] = 0;\n            require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n            STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n            return 1;\n        }\n    } else {\n        require((_stakeOf__value[1] * 0 / _stakeOf__value[1] == 0) | !_stakeOf__value[1]);\n        require(STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0 >= STORAGE[keccak256(6, msg.sender)]);\n        STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] + _stakeOf__value[1] * 0;\n        require(STORAGE[keccak256(6, stor_c)] >= _stakeOf__value[1] * 0);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _stakeOf__value[1] * 0;\n        emit Transfer(stor_c, msg.sender, _stakeOf__value[1] * 0);\n        STORAGE[keccak256(keccak256(keccak256(9, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        require(STORAGE[keccak256(8, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    }\n}\n\nfunction setDueTransfer(uint256 varg0, address varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(6, msg.sender)] >= varg2, Error(32, 29, 'Not enough balance in account'));\n    require(!_dueTransferOf__buyer[2], Error(32, 31, 'Already have data in the workId'));\n    require((0x15180 * varg3 / 0x15180 == varg3) | !0x15180);\n    require(0x15180 * varg3 + block.timestamp >= 0x15180 * varg3);\n    STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))] = varg1;\n    _dueTransferOf__buyer[1] = msg.sender;\n    _dueTransferOf__buyer[2] = varg2;\n    _dueTransferOf__buyer[3] = stor_3;\n    _dueTransferOf__buyer[4] = block.timestamp;\n    _dueTransferOf__buyer[5] = 0x15180 * varg3 + block.timestamp;\n    _dueTransferOf__buyer[6] = 0;\n    require(STORAGE[keccak256(8, msg.sender)] + varg2 >= STORAGE[keccak256(8, msg.sender)]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] + varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(6, msg.sender)] >= varg1);\n    require(STORAGE[keccak256(8, msg.sender)] <= STORAGE[keccak256(6, msg.sender)] - varg1, Error(32, 30, 'Not enoough balance in account'));\n    require(STORAGE[keccak256(6, msg.sender)] >= varg1);\n    STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - varg1;\n    require(STORAGE[keccak256(6, varg0)] + varg1 >= STORAGE[keccak256(6, varg0)]);\n    STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    MEM[576] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= varg1 / 100);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - varg1 / 100;\n        emit Transfer(_transfer, 0, varg1 / 100);\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(6, varg0)] >= varg2);\n    require(STORAGE[keccak256(8, varg0)] <= STORAGE[keccak256(6, varg0)] - varg2);\n    require(STORAGE[keccak256(6, varg0)] >= varg2);\n    STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - varg2;\n    require(STORAGE[keccak256(6, varg1)] + varg2 >= STORAGE[keccak256(6, varg1)]);\n    STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(7, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(7, varg0), msg.sender)] = STORAGE[keccak256(keccak256(7, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= varg2 / 100);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - varg2 / 100;\n        emit Transfer(_transfer, 0, varg2 / 100);\n    }\n}\n\nfunction submitTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))];\n    if (stor_3 <= _dueTransferOf__buyer[3]) {\n        if (stor_3 >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= stor_3);\n            require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n            require(stor_3);\n            require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(msg.sender, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    } else {\n        require(stor_3 >= _dueTransferOf__buyer[3]);\n        require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n        require(stor_3);\n        require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n        STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction declineTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    MEM[384] = STORAGE[keccak256(keccak256(keccak256(10, msg.sender), varg0))];\n    require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(6, _update)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, _update)]);\n    STORAGE[keccak256(6, _update)] = STORAGE[keccak256(6, _update)] + _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(8, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - _dueTransferOf__buyer[2];\n    _dueTransferOf__buyer[6] = 1;\n    emit Transfer(msg.sender, _update, _dueTransferOf__buyer[2]);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(7, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction resolve(uint256 varg0, address varg1, bool varg2) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(varg2 < 2);\n    require(msg.sender == _update);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, varg1), varg0))];\n    if (varg2 == 1) {\n        if (stor_3 <= _dueTransferOf__buyer[3]) {\n            if (stor_3 >= _dueTransferOf__buyer[3]) {\n                require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(6, v0)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] - _dueTransferOf__buyer[2];\n                emit Pay(varg1, v0, _dueTransferOf__buyer[2]);\n            } else {\n                require(_dueTransferOf__buyer[3] >= stor_3);\n                require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n                require(stor_3);\n                require(STORAGE[keccak256(6, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(6, msg.sender)] = STORAGE[keccak256(6, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n                STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n                STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n                emit Transfer(varg1, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n            }\n        } else {\n            require(stor_3 >= _dueTransferOf__buyer[3]);\n            require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n            require(stor_3);\n            require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg1, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    }\n    if (!varg2) {\n        require(STORAGE[keccak256(6, stor_c)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, varg1)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, varg1)]);\n        STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + _dueTransferOf__buyer[2];\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction request(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 >= _dueTransferOf__buyer[5]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 <= block.timestamp);\n    require(!_dueTransferOf__buyer[6]);\n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(10, varg0), varg1))];\n    if (stor_3 <= _dueTransferOf__buyer[3]) {\n        if (stor_3 >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= stor_3);\n            require(((_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - stor_3) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - stor_3));\n            require(stor_3);\n            require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3 >= STORAGE[keccak256(6, stor_c)]);\n            STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] + (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n            STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n            emit Transfer(varg0, stor_c, (_dueTransferOf__buyer[3] - stor_3) * _dueTransferOf__buyer[2] / stor_3);\n        }\n    } else {\n        require(stor_3 >= _dueTransferOf__buyer[3]);\n        require(((stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (stor_3 - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(stor_3 - _dueTransferOf__buyer[3]));\n        require(stor_3);\n        require(STORAGE[keccak256(6, varg0)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, varg0)] = STORAGE[keccak256(6, varg0)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(6, stor_c)] >= (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n        STORAGE[keccak256(6, stor_c)] = STORAGE[keccak256(6, stor_c)] - (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(6, v0)]);\n        STORAGE[keccak256(6, v0)] = STORAGE[keccak256(6, v0)] + _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == stor_3 / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (stor_3 / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_c, v0, (stor_3 - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / stor_3);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    if (_checkBurnStatus == 1) {\n        require(_transfer ^ 0x0);\n        require(STORAGE[keccak256(6, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(6, _transfer)] = STORAGE[keccak256(6, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    }\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(6, varg0)];\n}\n\nfunction holdOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, varg0)];\n}\n\nfunction stakeOf__holder(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(9, varg0), varg1))];\n}\n\nfunction stakeOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[1];\n}\n\nfunction stakeOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[2];\n}\n\nfunction dueTransferOf__seller(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(10, varg0), varg1))];\n}\n\nfunction dueTransferOf__buyer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[1];\n}\n\nfunction dueTransferOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[2];\n}\n\nfunction dueTransferOf__netValue(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[3];\n}\n\nfunction dueTransferOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[4];\n}\n\nfunction dueTransferOf__subDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[5];\n}\n\nfunction dueTransferOf__declined(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0x6a054250) {\n                if (function_selector != 0x97a2d0eb) {\n                    if (function_selector != 0x77884378) {\n                        if (function_selector != 0xdd62ed3e) {\n                            if (function_selector != 0x7b0472f0) {\n                                if (function_selector != 0x939624ab) {\n                                    if (function_selector != 0x49c662b8) {\n                                        if (function_selector != 0xa9059cbb) {\n                                            if (function_selector != 0x23b872dd) {\n                                                if (function_selector != 0xa6f12e85) {\n                                                    if (function_selector != 0x60dded11) {\n                                                        if (function_selector != 0x95ea7b3) {\n                                                            if (function_selector != 0x48e45ca) {\n                                                                if (function_selector != 0xc8c01a55) {\n                                                                    if (function_selector != 0x6fdde03) {\n                                                                        if (function_selector != 0x95d89b41) {\n                                                                            if (function_selector != 0x313ce567) {\n                                                                                if (function_selector != 0x70a08231) {\n                                                                                    if (function_selector != 0x9ddd7c21) {\n                                                                                        if (function_selector != 0x421f8e14) {\n                                                                                            if (function_selector != 0xe9562a6d) {\n                                                                                                if (function_selector != 0xf94be3af) {\n                                                                                                    if (function_selector != 0x8f33367a) {\n                                                                                                        if (function_selector != 0xb53574ab) {\n                                                                                                            if (function_selector != 0xa1bb138e) {\n                                                                                                                if (function_selector != 0x674b392e) {\n                                                                                                                    if (function_selector != 0x410bf99) {\n                                                                                                                        if (function_selector != 0x1952ddbd) {\n                                                                                                                            if (function_selector == 0xb993ed4b) {\n                                                                                                                                dueTransferOf__declined(address,uint256);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            dueTransferOf__subDate(address,uint256);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        dueTransferOf__setDate(address,uint256);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    dueTransferOf__netValue(address,uint256);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                dueTransferOf__value(address,uint256);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            dueTransferOf__buyer(address,uint256);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        dueTransferOf__seller(address,uint256);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    stakeOf__setDate(address,uint256);\n                                                                                                }\n                                                                                            } else {\n                                                                                                stakeOf__value(address,uint256);\n                                                                                            }\n                                                                                        } else {\n                                                                                            stakeOf__holder(address,uint256);\n                                                                                        }\n                                                                                    } else {\n                                                                                        holdOf(address);\n                                                                                    }\n                                                                                } else {\n                                                                                    balanceOf(address);\n                                                                                }\n                                                                            } else {\n                                                                                decimals();\n                                                                            }\n                                                                        } else {\n                                                                            symbol();\n                                                                        }\n                                                                    } else {\n                                                                        name();\n                                                                    }\n                                                                } else {\n                                                                    request(address,uint256);\n                                                                }\n                                                            } else {\n                                                                resolve(uint256,address,bool);\n                                                            }\n                                                        } else {\n                                                            approve(address,uint256);\n                                                        }\n                                                    } else {\n                                                        declineTransfer(uint256);\n                                                    }\n                                                } else {\n                                                    submitTransfer(uint256);\n                                                }\n                                            } else {\n                                                transferFrom(address,address,uint256);\n                                            }\n                                        } else {\n                                            transfer(address,uint256);\n                                        }\n                                    } else {\n                                        setDueTransfer(uint256,address,uint256,uint256);\n                                    }\n                                } else {\n                                    removeStake(uint256);\n                                }\n                            } else {\n                                stake(uint256,uint256);\n                            }\n                        } else {\n                            allowance(address,address);\n                        }\n                    } else {\n                        checkBurnStatus();\n                    }\n                } else {\n                    setBurnStatus(bool);\n                }\n            } else {\n                update(uint256,uint256,uint256);\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 43.42922854423523,
	"usage": {
		"completion_tokens": 601,
		"prompt_tokens": 10047,
		"total_tokens": 10648
	}
}