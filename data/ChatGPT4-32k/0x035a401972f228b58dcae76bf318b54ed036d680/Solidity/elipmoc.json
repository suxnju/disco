{
	"address": "0x035a401972f228b58dcae76bf318b54ed036d680",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, a corresponding Solidity smart contract could look like the following:\n\n```solidity\npragma solidity ^0.7.6;\n\ncontract MyContract {\n    // State variables\n    mapping (uint256 => uint256[]) private _transactions;\n    mapping (uint256 => uint256[]) private _confirmations;\n    mapping (address => bool) private _isOwner;\n    address[] private _owners;\n    uint256 private _required;\n    uint256 private _transactionCount;\n\n    // Events\n    event Deposit(address indexed sender, uint256 value);\n    event OwnerRemoval(address indexed owner);\n    event Revocation(address indexed sender, uint256 transactionId);\n    event OwnerAddition(address indexed owner);\n    event RequirementChange(uint256 required);\n    event Confirmation(address indexed sender, uint256 transactionId);\n    event Execution(uint256 transactionId);\n    event ExecutionFailure(uint256 transactionId);\n    event Submission(uint256 transactionId);\n\n    // Contract code\n    // ...\n    // The implementation of the contract functions would go here.\n    // For the sake of readability, these have been omitted from this example.\n    // ...\n}\n```\n\nPlease note that the contract code is incomplete and serves only as a representation of what the contract might look like based on the provided decompiled code. The functions and their implementations are not included here, but they would follow the signatures provided in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038997,
	"id": "chatcmpl-8Chnhr0lQNNjlt2qv62Nk28BuAojj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 05:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x15d5(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 0;\n    }\n    if (!v0) {\n        v0 = v4 = _owners.length == 0;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x168c(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0][0]) != 0);\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1bc1(varg0);\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1bc1(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][3]));\n    v0 = 0xf8e(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (!_owners.length <= _owners.length - 1) {\n        v2 = v3 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x15d5(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0 != 0);\n    v0 = v1 = _owners.length + 1 > 50;\n    if (_owners.length + 1 <= 50) {\n        v0 = v2 = _required > _owners.length + 1;\n    }\n    if (!v0) {\n        v0 = v3 = _required == 0;\n    }\n    if (!v0) {\n        v0 = _owners.length + 1 == 0;\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length += 1;\n    if (!_owners.length <= 1 + _owners.length) {\n        v4 = v5 = keccak256(3) + (1 + _owners.length);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xf8e(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v0, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v2 += 32;\n            v4 += 1;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = v5.data;\n    v8 = v9 = v1.data;\n    v10 = v11 = v1.length << 5;\n    if (v11 != 0) {\n        while (1) {\n            MEM[v6] = MEM[v8];\n            if (v10 <= 32) {\n                break;\n            }\n            v6 = v6 + 32;\n            v8 = v8 + 32;\n            v10 = v10 - 32;\n        }\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v10][3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 = v8 + 1;\n        }\n        v10 += 1;\n    }\n    v13 = v14 = MEM[64];\n    if (MSIZE() >= v14) {\n        v13 = v15 = new uint256[](varg1 - varg0);\n    }\n    v13 = new uint256[](varg1 - varg0);\n    while (v16 < varg1) {\n        assert(v16 < v5.length);\n        assert(v16 - varg0 < v13.length);\n        v15[v16 - varg0 << 5] = v7[v16];\n        v16 += 1;\n    }\n    v17 = new array[](v13.length);\n    v18 = v19 = v17.data;\n    v20 = v21 = v15.data;\n    v22 = v23 = v13.length << 5;\n    if (v23 != 0) {\n        while (1) {\n            MEM[v18] = MEM[v20];\n            if (v22 <= 32) {\n                break;\n            }\n            v18 = v18 + 32;\n            v20 = v20 + 32;\n            v22 = v22 - 32;\n        }\n    }\n    return v17;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 = v5 + 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v16 = v14.data;\n    v17 = v18 = v11.data;\n    v19 = v20 = v9.length << 5;\n    if (v20 != 0) {\n        while (1) {\n            MEM[v15] = MEM[v17];\n            if (v19 <= 32) {\n                break;\n            }\n            v15 = v15 + 32;\n            v17 = v17 + 32;\n            v19 = v19 - 32;\n        }\n    }\n    return v14;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x15d5(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x168c(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    require(varg0 != 0);\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x168c(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1bc1(varg0);\n}\n\nfunction 0xf8e(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (0x25e7c27 == v0) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 05:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x15d5(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 0;\n    }\n    if (!v0) {\n        v0 = v4 = _owners.length == 0;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x168c(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0][0]) != 0);\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1bc1(varg0);\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1bc1(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][3]));\n    v0 = 0xf8e(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (!_owners.length <= _owners.length - 1) {\n        v2 = v3 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x15d5(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0 != 0);\n    v0 = v1 = _owners.length + 1 > 50;\n    if (_owners.length + 1 <= 50) {\n        v0 = v2 = _required > _owners.length + 1;\n    }\n    if (!v0) {\n        v0 = v3 = _required == 0;\n    }\n    if (!v0) {\n        v0 = _owners.length + 1 == 0;\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length += 1;\n    if (!_owners.length <= 1 + _owners.length) {\n        v4 = v5 = keccak256(3) + (1 + _owners.length);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xf8e(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v0, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v2 += 32;\n            v4 += 1;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = v5.data;\n    v8 = v9 = v1.data;\n    v10 = v11 = v1.length << 5;\n    if (v11 != 0) {\n        while (1) {\n            MEM[v6] = MEM[v8];\n            if (v10 <= 32) {\n                break;\n            }\n            v6 = v6 + 32;\n            v8 = v8 + 32;\n            v10 = v10 - 32;\n        }\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v10][3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 = v8 + 1;\n        }\n        v10 += 1;\n    }\n    v13 = v14 = MEM[64];\n    if (MSIZE() >= v14) {\n        v13 = v15 = new uint256[](varg1 - varg0);\n    }\n    v13 = new uint256[](varg1 - varg0);\n    while (v16 < varg1) {\n        assert(v16 < v5.length);\n        assert(v16 - varg0 < v13.length);\n        v15[v16 - varg0 << 5] = v7[v16];\n        v16 += 1;\n    }\n    v17 = new array[](v13.length);\n    v18 = v19 = v17.data;\n    v20 = v21 = v15.data;\n    v22 = v23 = v13.length << 5;\n    if (v23 != 0) {\n        while (1) {\n            MEM[v18] = MEM[v20];\n            if (v22 <= 32) {\n                break;\n            }\n            v18 = v18 + 32;\n            v20 = v20 + 32;\n            v22 = v22 - 32;\n        }\n    }\n    return v17;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 = v5 + 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v16 = v14.data;\n    v17 = v18 = v11.data;\n    v19 = v20 = v9.length << 5;\n    if (v20 != 0) {\n        while (1) {\n            MEM[v15] = MEM[v17];\n            if (v19 <= 32) {\n                break;\n            }\n            v15 = v15 + 32;\n            v17 = v17 + 32;\n            v19 = v19 - 32;\n        }\n    }\n    return v14;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x15d5(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x168c(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    require(varg0 != 0);\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x168c(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1bc1(varg0);\n}\n\nfunction 0xf8e(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (0x25e7c27 == v0) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 05:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x15d5(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 0;\n    }\n    if (!v0) {\n        v0 = v4 = _owners.length == 0;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x168c(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0][0]) != 0);\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1bc1(varg0);\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1bc1(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][3]));\n    v0 = 0xf8e(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (!_owners.length <= _owners.length - 1) {\n        v2 = v3 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x15d5(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0 != 0);\n    v0 = v1 = _owners.length + 1 > 50;\n    if (_owners.length + 1 <= 50) {\n        v0 = v2 = _required > _owners.length + 1;\n    }\n    if (!v0) {\n        v0 = v3 = _required == 0;\n    }\n    if (!v0) {\n        v0 = _owners.length + 1 == 0;\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length += 1;\n    if (!_owners.length <= 1 + _owners.length) {\n        v4 = v5 = keccak256(3) + (1 + _owners.length);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xf8e(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v0, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v2 += 32;\n            v4 += 1;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = v5.data;\n    v8 = v9 = v1.data;\n    v10 = v11 = v1.length << 5;\n    if (v11 != 0) {\n        while (1) {\n            MEM[v6] = MEM[v8];\n            if (v10 <= 32) {\n                break;\n            }\n            v6 = v6 + 32;\n            v8 = v8 + 32;\n            v10 = v10 - 32;\n        }\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v10][3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 = v8 + 1;\n        }\n        v10 += 1;\n    }\n    v13 = v14 = MEM[64];\n    if (MSIZE() >= v14) {\n        v13 = v15 = new uint256[](varg1 - varg0);\n    }\n    v13 = new uint256[](varg1 - varg0);\n    while (v16 < varg1) {\n        assert(v16 < v5.length);\n        assert(v16 - varg0 < v13.length);\n        v15[v16 - varg0 << 5] = v7[v16];\n        v16 += 1;\n    }\n    v17 = new array[](v13.length);\n    v18 = v19 = v17.data;\n    v20 = v21 = v15.data;\n    v22 = v23 = v13.length << 5;\n    if (v23 != 0) {\n        while (1) {\n            MEM[v18] = MEM[v20];\n            if (v22 <= 32) {\n                break;\n            }\n            v18 = v18 + 32;\n            v20 = v20 + 32;\n            v22 = v22 - 32;\n        }\n    }\n    return v17;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 = v5 + 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v16 = v14.data;\n    v17 = v18 = v11.data;\n    v19 = v20 = v9.length << 5;\n    if (v20 != 0) {\n        while (1) {\n            MEM[v15] = MEM[v17];\n            if (v19 <= 32) {\n                break;\n            }\n            v15 = v15 + 32;\n            v17 = v17 + 32;\n            v19 = v19 - 32;\n        }\n    }\n    return v14;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x15d5(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x168c(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    require(varg0 != 0);\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x168c(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1bc1(varg0);\n}\n\nfunction 0xf8e(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (0x25e7c27 == v0) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
	"status": "1",
	"time_cost": 14.322217464447021,
	"usage": {
		"completion_tokens": 287,
		"prompt_tokens": 4989,
		"total_tokens": 5276
	}
}