{
	"address": "0x1e20b7d24d429b0de705d3ff8b88ec651d28a935",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Here is the Solidity smart contract code based on the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyContract {\n    address private _owner;\n    \n    event Withdrawal(address indexed ercAddress, address indexed to, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n    \n    function withdraw(address ercAddress, address to, uint256 amount) public {\n        require(msg.sender == _owner, \"permission denied\");\n        if (ercAddress != address(0)) {\n            uint256 balance = IERC20(ercAddress).balanceOf(address(this));\n            require(balance >= amount, \"Insufficient funds\");\n            IERC20(ercAddress).transfer(to, amount);\n            emit Withdrawal(ercAddress, to, amount);\n        } else {\n            require(address(this).balance >= amount, \"Insufficient funds\");\n            (bool success, ) = to.call.value(amount)(\"\");\n            require(success, \"Transfer failed\");\n            emit Withdrawal(ercAddress, to, amount);\n        }\n    }\n    \n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner, \"permission denied\");\n        require(newOwner != address(0), \"invalid address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\nPlease note that the original decompiled code includes some low-level operations with gas and direct handling of the EVM memory. These operations are not usual in higher-level Solidity code and may not be directly translatable into Solidity. In this Solidity version of the contract, these operations are replaced with the typical high-level Solidity code.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711531853,
	"id": "chatcmpl-97JuPhbMMd2sBoZuo5KWazdWJ7fHN",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2024.03.22 22:56 UTC\n// Compiled using the solidity compiler version 0.5.16\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\n\n\n// Events\nWithdrawal(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction function_selector() public payable { \n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction withdraw(address ercAddress, address to, uint256 amount) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('permission denied'));\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != ercAddress) {\n        require(bool((address(address(ercAddress))).code.size));\n        v0, /* uint256 */ v1 = ercAddress.balanceOf(address(this)).gas(msg.gas);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(10 ** 18);\n        emit Withdrawal(ercAddress, to, v1 * amount / 10 ** 18);\n        require(bool((address(address(ercAddress))).code.size));\n        v2 = ercAddress.transfer(to, v1 * amount / 10 ** 18).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        if (RETURNDATASIZE() == 0) {\n            v3 = v4 = ~0;\n        } else {\n            require(RETURNDATASIZE() == 32);\n            RETURNDATACOPY(0, 0, 32);\n            v3 = v5 = MEM[0];\n        }\n    } else {\n        emit Withdrawal(ercAddress, to, amount * this.balance / 10 ** 18);\n        v3 = v6, /* uint256 */ v7 = to.call().value(amount * this.balance / 10 ** 18).gas(msg.gas);\n        if (RETURNDATASIZE() != 0) {\n            v8 = new bytes[](RETURNDATASIZE());\n            v7 = v8.data;\n            RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n        }\n    }\n    return bool(v3);\n}\n\nfunction transferOwnership(address newOwner) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('permission denied'));\n    require(newOwner, Error('invalid address'));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector( function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0xd9caed12 == function_selector >> 224) {\n            withdraw(address,address,uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2024.03.22 22:56 UTC\n// Compiled using the solidity compiler version 0.5.16\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\n\n\n// Events\nWithdrawal(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction function_selector() public payable { \n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction withdraw(address ercAddress, address to, uint256 amount) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('permission denied'));\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != ercAddress) {\n        require(bool((address(address(ercAddress))).code.size));\n        v0, /* uint256 */ v1 = ercAddress.balanceOf(address(this)).gas(msg.gas);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(10 ** 18);\n        emit Withdrawal(ercAddress, to, v1 * amount / 10 ** 18);\n        require(bool((address(address(ercAddress))).code.size));\n        v2 = ercAddress.transfer(to, v1 * amount / 10 ** 18).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        if (RETURNDATASIZE() == 0) {\n            v3 = v4 = ~0;\n        } else {\n            require(RETURNDATASIZE() == 32);\n            RETURNDATACOPY(0, 0, 32);\n            v3 = v5 = MEM[0];\n        }\n    } else {\n        emit Withdrawal(ercAddress, to, amount * this.balance / 10 ** 18);\n        v3 = v6, /* uint256 */ v7 = to.call().value(amount * this.balance / 10 ** 18).gas(msg.gas);\n        if (RETURNDATASIZE() != 0) {\n            v8 = new bytes[](RETURNDATASIZE());\n            v7 = v8.data;\n            RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n        }\n    }\n    return bool(v3);\n}\n\nfunction transferOwnership(address newOwner) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('permission denied'));\n    require(newOwner, Error('invalid address'));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector( function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0xd9caed12 == function_selector >> 224) {\n            withdraw(address,address,uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2024.03.22 22:56 UTC\n// Compiled using the solidity compiler version 0.5.16\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\n\n\n// Events\nWithdrawal(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction function_selector() public payable { \n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction withdraw(address ercAddress, address to, uint256 amount) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('permission denied'));\n    if (0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee != ercAddress) {\n        require(bool((address(address(ercAddress))).code.size));\n        v0, /* uint256 */ v1 = ercAddress.balanceOf(address(this)).gas(msg.gas);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(10 ** 18);\n        emit Withdrawal(ercAddress, to, v1 * amount / 10 ** 18);\n        require(bool((address(address(ercAddress))).code.size));\n        v2 = ercAddress.transfer(to, v1 * amount / 10 ** 18).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        if (RETURNDATASIZE() == 0) {\n            v3 = v4 = ~0;\n        } else {\n            require(RETURNDATASIZE() == 32);\n            RETURNDATACOPY(0, 0, 32);\n            v3 = v5 = MEM[0];\n        }\n    } else {\n        emit Withdrawal(ercAddress, to, amount * this.balance / 10 ** 18);\n        v3 = v6, /* uint256 */ v7 = to.call().value(amount * this.balance / 10 ** 18).gas(msg.gas);\n        if (RETURNDATASIZE() != 0) {\n            v8 = new bytes[](RETURNDATASIZE());\n            v7 = v8.data;\n            RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n        }\n    }\n    return bool(v3);\n}\n\nfunction transferOwnership(address newOwner) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('permission denied'));\n    require(newOwner, Error('invalid address'));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector( function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0xd9caed12 == function_selector >> 224) {\n            withdraw(address,address,uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 117.47333407402039,
	"usage": {
		"completion_tokens": 418,
		"prompt_tokens": 812,
		"total_tokens": 1230
	}
}