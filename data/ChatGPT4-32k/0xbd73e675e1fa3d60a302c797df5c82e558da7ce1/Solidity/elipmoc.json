{
	"address": "0xbd73e675e1fa3d60a302c797df5c82e558da7ce1",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the reconstructed Solidity code based on the provided decompiled code:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MyContract {\n    uint256 private _expectedTokens;\n    uint256 private _buyPrice;\n    uint256 private _totalSupply;\n    uint256 private _donate;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _buyPrice = 1 ether;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0), \"Transfer to the zero address\");\n        require(amount <= _balances[msg.sender], \"Transfer amount exceeds balance\");\n\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from], \"Transfer amount exceeds balance\");\n        require(value <= _allowed[from][msg.sender], \"Transfer amount exceeds allowance\");\n        require(to != address(0), \"Transfer to the zero address\");\n\n        _balances[from] -= value;\n        _balances[to] += value;\n        _allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n}\n```\nPlease note that the reconstructed code is not a 1-to-1 copy of the original Solidity code but tries to follow the logic stated in the decompiled code. It's likely that the original Solidity code contains more complex logic. The reconstructed code does not include every detail from the decompiled code, such as low-level calls and dynamic array manipulations, as these are not typically seen in high-level Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040013,
	"id": "chatcmpl-8Ci45Aq0cHq2D8BEomF6dXF8GQOaf",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.14 20:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _expectedTokens; // STORAGE[0x0]\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _totalSupply; // STORAGE[0x9]\nuint256 _donate; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0xb]\n\n// Events\nPurchase(address, uint256, uint256, uint256, uint256);\nWithdrawal(address, uint256, uint256);\nTransfer(address, address, uint256);\nSelling(address, uint256, uint256, uint256, uint256);\nDonation(address, uint256, uint256);\nReinvestment(address, uint256, uint256, uint256, uint256);\nReferralReward(address, address, uint256, uint256, uint256);\n\nfunction 0x12e2(uint256 varg0) private { \n    require(varg0 > 0, Error('Amount of tokens must be greater than zero'));\n    require(varg0 <= _exit[msg.sender][1], Error('You have not enough tokens'));\n    v0, v1 = 0x227e(varg0);\n    require(v1 != 0, Error('Insufficient tokens to do that'));\n    _buyPrice = v0;\n    if (v1 != 0) {\n        v2 = 0x203e(stor_2, v1);\n        assert(stor_3);\n        v3 = v4 = v2 / stor_3;\n        require(v4 <= v1, Error('sub failed'));\n        v3 = v1 - v4;\n    } else {\n        v3 = v5 = 0;\n    }\n    require(v3 != 0, Error('Insufficient tokens to do that'));\n    0x237b(varg0, msg.sender);\n    require(_exit[msg.sender][2] + v3 >= _exit[msg.sender][2], Error('add failed'));\n    _exit[msg.sender][2] = _exit[msg.sender][2] + v3;\n    require(_donate + v3 >= _donate, Error('add failed'));\n    _donate = _donate + v3;\n    emit Selling(msg.sender, varg0, v1, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n    return ;\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    v0 = 0x978(varg0);\n    return v0;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (18) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffff & 'Pantheon Ecosystem';\n    }\n    return v0;\n}\n\nfunction 0x1bf7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg2);\n    if (_exit[v0][1] >= 0x8ac7230489e80000) {\n        if (varg1 != 0) {\n            v1 = 0x203e(stor_6, varg1);\n            assert(stor_7);\n            varg1 = v2 = v1 / stor_7;\n            require(v2 <= varg1, Error('sub failed'));\n            varg1 = v3 = varg1 - v2;\n        } else {\n            varg1 = v4 = 0;\n        }\n        require(_exit[v0][3] + varg1 >= _exit[v0][3], Error('add failed'));\n        _exit[v0][3] = _exit[v0][3] + varg1;\n        emit ReferralReward(address(varg3), address(varg2), varg0, varg1, block.timestamp);\n    }\n    return varg1;\n}\n\nfunction 0x1d35(uint256 varg0) private { \n    v0 = 0x203e(2, _buyPrice);\n    require(0x204fce5e3e25026110000000 <= v0, Error('sub failed'));\n    v1 = 0x203e(8, 0x204fce5e3e25026110000000);\n    v2 = 0x203e(varg0, v1);\n    v3 = 0x203e(0xde0b6b3a7640000, v2);\n    v4 = 0x203e(v0 - 0x204fce5e3e25026110000000, v0 - 0x204fce5e3e25026110000000);\n    v5 = v6 = v4 + v3;\n    require(v6 >= v4, Error('add failed'));\n    v7 = 0x203e(2, 0x204fce5e3e25026110000000);\n    require(v6 / v5 + v5 >= v6 / v5, Error('add failed'));\n    assert(2);\n    v5 = v6 / v5 + v5 >> 1;\n    while (v5 < v5) {\n        if (v5) {\n            break;\n        }\n        assert(v5);\n        require(v6 / v5 + v5 >= v6 / v5, Error('add failed'));\n        assert(2);\n        v5 = v8 >> 1;\n    }\n    require(v0 - 0x204fce5e3e25026110000000 <= v5, Error('sub failed'));\n    v9 = 0x203e(0xde0b6b3a7640000, v5 - (v0 - 0x204fce5e3e25026110000000));\n    assert(v7);\n    v10 = 0x203e(v9 / v7, 0x204fce5e3e25026110000000);\n    assert(0xde0b6b3a7640000);\n    require(_buyPrice + v10 / 0xde0b6b3a7640000 >= _buyPrice, Error('add failed'));\n    return _buyPrice + v10 / 0xde0b6b3a7640000, v9 / v7;\n}\n\nfunction 0x1e9e(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    if (_totalSupply > 0) {\n        v1 = _totalSupply + varg0;\n        require(v1 >= _totalSupply, Error('add failed'));\n        v2 = 0x203e(v1, _donate);\n        assert(_totalSupply);\n        _donate = v2 / _totalSupply;\n    }\n    v3 = _totalSupply + varg0;\n    require(v3 >= _totalSupply, Error('add failed'));\n    _totalSupply = v3;\n    v4 = _exit[v0][1] + varg0;\n    require(v4 >= _exit[v0][1], Error('add failed'));\n    _exit[v0][1] = v4;\n    if (_totalSupply > 0) {\n        v5 = 0x203e(_donate, varg0);\n        assert(_totalSupply);\n        require(_exit[v0][4] + v5 / _totalSupply >= _exit[v0][4], Error('add failed'));\n        _exit[v0][4] = _exit[v0][4] + v5 / _totalSupply;\n    }\n    return ;\n}\n\nfunction 0x203e(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, Error('mul failed'));\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction 0x227e(uint256 varg0) private { \n    require(v0 / 0xde0b6b3a7640000 <= _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000, Error('sub failed'));\n    v0 = 0x203e(varg0, 0x204fce5e3e25026110000000);\n    assert(0xde0b6b3a7640000);\n    require(_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 >= _buyPrice - 0x204fce5e3e25026110000000, Error('add failed'));\n    require(v0 / 0xde0b6b3a7640000 <= _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000, Error('sub failed'));\n    v1 = 0x203e(2, 0xde0b6b3a7640000);\n    require(_buyPrice - 0x204fce5e3e25026110000000 + (_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000) >= _buyPrice - 0x204fce5e3e25026110000000, Error('add failed'));\n    v2 = 0x203e(varg0, _buyPrice - 0x204fce5e3e25026110000000 + (_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000));\n    assert(v1);\n    return _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000, v2 / v1 / 0xde0b6b3a7640000;\n}\n\nfunction 0x237b(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = v2 = 0;\n    if (_totalSupply == varg0) {\n        v3 = 0x203e(_exit[v0][1], _donate);\n        assert(_totalSupply);\n        v1 = v4 = v3 / _totalSupply;\n    }\n    require(varg0 <= _totalSupply, Error('sub failed'));\n    v5 = 0x203e(_totalSupply - varg0, _donate);\n    assert(_totalSupply);\n    _donate = v5 / _totalSupply;\n    require(varg0 <= _totalSupply, Error('sub failed'));\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _exit[v0][1], Error('sub failed'));\n    _exit[v0][1] = _exit[v0][1] - varg0;\n    if (_totalSupply <= 0) {\n        if (v1 != 0) {\n            require(_exit[v0][4] - v1 <= _exit[v0][4], Error('sub failed'));\n            _exit[v0][4] = _exit[v0][4] - v1;\n        }\n    } else {\n        v6 = 0x203e(_donate, varg0);\n        assert(_totalSupply);\n        require(_exit[v0][4] - v6 / _totalSupply <= _exit[v0][4], Error('sub failed'));\n        _exit[v0][4] = _exit[v0][4] - v6 / _totalSupply;\n    }\n    return ;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0xb7a();\n}\n\nfunction sellPrice() public nonPayable { \n    require(0x204fce5e3e25026110000000 <= _buyPrice, Error('sub failed'));\n    assert(0xde0b6b3a7640000);\n    return (_buyPrice - 0x204fce5e3e25026110000000) / 0xde0b6b3a7640000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0][1];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice / 0xde0b6b3a7640000;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x50414e0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0, Error('Amount of tokens must be greater than zero'));\n    require(varg1 <= _exit[msg.sender][1], Error('You have not enough tokens'));\n    require(varg0 != msg.sender, Error('You cannot transfer tokens to yourself'));\n    if (varg1 != 0) {\n        v0 = 0x203e(stor_4, varg1);\n        assert(stor_5);\n        v1 = v2 = v0 / stor_5;\n        require(v2 <= varg1, Error('sub failed'));\n        v1 = varg1 - v2;\n    } else {\n        v1 = v3 = 0;\n    }\n    require(v1 != 0, Error('Insufficient tokens to do that'));\n    v4, v5 = 0x227e(v1);\n    require(v5 != 0, Error('Insufficient tokens to do that'));\n    _buyPrice = v4;\n    0x237b(varg1, msg.sender);\n    0x1e9e(v1, varg0);\n    require(_donate + v5 >= _donate, Error('add failed'));\n    _donate = _donate + v5;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction expectedFunds(uint256 varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = _totalSupply == 0;\n    }\n    if (!v0) {\n        if (varg0 > _totalSupply) {\n            v2 = v3 = _totalSupply;\n        }\n        v4, v5 = v6 = 0x227e(v2);\n        if (varg1) {\n            if (v6 != 0) {\n                v7 = 0x203e(stor_2, v6);\n                assert(stor_3);\n                v5 = v8 = v7 / stor_3;\n                require(v8 <= v6, Error('sub failed'));\n                v5 = v6 - v8;\n            } else {\n                v5 = v9 = 0;\n            }\n        }\n    } else {\n        v5 = v10 = 0;\n    }\n    return v5;\n}\n\nfunction expectedTokens(uint256 varg0, bool varg1) public nonPayable { \n    if (varg0 != 0) {\n        if (varg1) {\n            if (varg0 != 0) {\n                v0 = 0x203e(_expectedTokens, varg0);\n                assert(stor_1);\n                v1 = v2 = v0 / stor_1;\n                require(v2 <= varg0, Error('sub failed'));\n                v1 = varg0 - v2;\n            } else {\n                v1 = v3 = 0;\n            }\n        }\n        v4, v5 = 0x1d35(v1);\n    } else {\n        v5 = v6 = 0;\n    }\n    return v5;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x12e2(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender][1] > 0) {\n        0x12e2(_exit[msg.sender][1]);\n    }\n    0xb7a();\n}\n\nfunction donate() public payable { \n    require(_donate + msg.value >= _donate, Error('add failed'));\n    _donate = _donate + msg.value;\n    emit Donation(msg.sender, msg.value, block.timestamp);\n}\n\nfunction buy(address varg0) public payable { \n    0x578(varg0);\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x978(msg.sender);\n    require(v0 > 0, Error('You have no dividends'));\n    require(_exit[msg.sender][4] + v0 >= _exit[msg.sender][4], Error('add failed'));\n    _exit[msg.sender][4] = _exit[msg.sender][4] + v0;\n    if (v0 != 0) {\n        v1 = 0x203e(_expectedTokens, v0);\n        assert(stor_1);\n        v2 = v3 = v1 / stor_1;\n        require(v3 <= v0, Error('sub failed'));\n        v2 = v0 - v3;\n    } else {\n        v2 = v4 = 0;\n    }\n    require(v5 != 0, Error('Insufficient dividends to do that'));\n    if (address(_exit[address(address(msg.sender))][0]) != 0) {\n        v2 = v6 = 0x1bf7(v0, v5, address(_exit[address(address(msg.sender))][0]), msg.sender);\n        require(v6 != 0, Error('Insufficient dividends to do that'));\n    }\n    v7, v8 = 0x1d35(v2);\n    require(v8 != 0, Error('Insufficient dividends to do that'));\n    _buyPrice = v7;\n    0x1e9e(v8, msg.sender);\n    require(_donate + v2 >= _donate, Error('add failed'));\n    _donate = _donate + v2;\n    emit Reinvestment(msg.sender, v0, v8, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n}\n\nfunction 0x578(uint256 varg0) private { \n    if (msg.value != 0) {\n        v0 = 0x203e(_expectedTokens, msg.value);\n        assert(stor_1);\n        v1 = v2 = v0 / stor_1;\n        require(v2 <= msg.value, Error('sub failed'));\n        v1 = msg.value - v2;\n    } else {\n        v1 = v3 = 0;\n    }\n    require(v4 != 0, Error('Incoming funds is too small'));\n    v5 = v6 = address(varg0) != 0;\n    if (v6) {\n        v5 = v7 = address(varg0) != msg.sender;\n    }\n    if (v5) {\n        v5 = v8 = address(_exit[address(address(msg.sender))][0]) == 0;\n    }\n    if (v5) {\n        _exit[msg.sender][0] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _exit[msg.sender][0x0];\n    }\n    if (address(_exit[address(address(msg.sender))][0]) != 0) {\n        v1 = v9 = 0x1bf7(msg.value, v4, address(_exit[address(address(msg.sender))][0]), msg.sender);\n        require(v9 != 0, Error('Incoming funds is too small'));\n    }\n    v10, v11 = 0x1d35(v1);\n    require(v11 != 0, Error('Incoming funds is too small'));\n    _buyPrice = v10;\n    0x1e9e(v11, msg.sender);\n    require(_donate + v1 >= _donate, Error('add failed'));\n    _donate = _donate + v1;\n    emit Purchase(msg.sender, msg.value, v11, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n    return ;\n}\n\nfunction 0x978(uint256 varg0) private { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    v0 = address(varg0);\n    MEM[MEM[64]] = address(_exit[v0][0]);\n    v1 = _exit[v0][2] + _exit[v0][3];\n    require(v1 >= _exit[v0][2], Error('add failed'));\n    require(v1 >= 0);\n    if (_totalSupply > 0) {\n        v2 = 0x203e(_exit[v0][1], _donate);\n        assert(_totalSupply);\n        v1 = v3 = v1 + v2 / _totalSupply;\n        require(v3 >= v1, Error('add failed'));\n    }\n    if (_exit[v0][4] <= 0) {\n        if (_exit[v0][4] < 0) {\n            v1 = v4 = v1 + (0 - _exit[v0][4]);\n            require(v4 >= v1, Error('add failed'));\n        }\n    } else {\n        v1 = v5 = v1 - _exit[v0][4];\n        require(v5 <= v1, Error('sub failed'));\n    }\n    require(v1 >= 0);\n    return v1;\n}\n\nfunction 0xb7a() private { \n    v0 = 0x978(msg.sender);\n    require(v0 > 0, Error('You have no dividends'));\n    require(_exit[msg.sender][4] + v0 >= _exit[msg.sender][4], Error('add failed'));\n    _exit[msg.sender][4] = _exit[msg.sender][4] + v0;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Withdrawal(msg.sender, v0, block.timestamp);\n    return ;\n}\n\nfunction () public payable { \n    v0 = new bytes[](msg.data.length);\n    CALLDATACOPY(v0.data, 0, msg.data.length);\n    0x578(msg.data.length);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x65318b == uint32(function_selector >> 224)) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x18160ddd == uint32(function_selector >> 224)) {\n            totalSupply();\n        } else if (0x313ce567 == uint32(function_selector >> 224)) {\n            decimals();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x4b750334 == uint32(function_selector >> 224)) {\n            sellPrice();\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0x8620410b == uint32(function_selector >> 224)) {\n            buyPrice();\n        } else if (0x95d89b41 == uint32(function_selector >> 224)) {\n            symbol();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xbe2eaad4 == uint32(function_selector >> 224)) {\n            expectedFunds(uint256,bool);\n        } else if (0xc5f60620 == uint32(function_selector >> 224)) {\n            expectedTokens(uint256,bool);\n        } else if (0xe4849b32 == uint32(function_selector >> 224)) {\n            sell(uint256);\n        } else if (0xe9fad8ee == uint32(function_selector >> 224)) {\n            exit();\n        } else if (0xed88c68e == uint32(function_selector >> 224)) {\n            donate();\n        } else if (0xf088d547 == uint32(function_selector >> 224)) {\n            buy(address);\n        } else if (0xfdb5a03e == uint32(function_selector >> 224)) {\n            reinvest();\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.14 20:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _expectedTokens; // STORAGE[0x0]\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _totalSupply; // STORAGE[0x9]\nuint256 _donate; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0xb]\n\n// Events\nPurchase(address, uint256, uint256, uint256, uint256);\nWithdrawal(address, uint256, uint256);\nTransfer(address, address, uint256);\nSelling(address, uint256, uint256, uint256, uint256);\nDonation(address, uint256, uint256);\nReinvestment(address, uint256, uint256, uint256, uint256);\nReferralReward(address, address, uint256, uint256, uint256);\n\nfunction 0x12e2(uint256 varg0) private { \n    require(varg0 > 0, Error('Amount of tokens must be greater than zero'));\n    require(varg0 <= _exit[msg.sender][1], Error('You have not enough tokens'));\n    v0, v1 = 0x227e(varg0);\n    require(v1 != 0, Error('Insufficient tokens to do that'));\n    _buyPrice = v0;\n    if (v1 != 0) {\n        v2 = 0x203e(stor_2, v1);\n        assert(stor_3);\n        v3 = v4 = v2 / stor_3;\n        require(v4 <= v1, Error('sub failed'));\n        v3 = v1 - v4;\n    } else {\n        v3 = v5 = 0;\n    }\n    require(v3 != 0, Error('Insufficient tokens to do that'));\n    0x237b(varg0, msg.sender);\n    require(_exit[msg.sender][2] + v3 >= _exit[msg.sender][2], Error('add failed'));\n    _exit[msg.sender][2] = _exit[msg.sender][2] + v3;\n    require(_donate + v3 >= _donate, Error('add failed'));\n    _donate = _donate + v3;\n    emit Selling(msg.sender, varg0, v1, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n    return ;\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    v0 = 0x978(varg0);\n    return v0;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (18) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffff & 'Pantheon Ecosystem';\n    }\n    return v0;\n}\n\nfunction 0x1bf7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg2);\n    if (_exit[v0][1] >= 0x8ac7230489e80000) {\n        if (varg1 != 0) {\n            v1 = 0x203e(stor_6, varg1);\n            assert(stor_7);\n            varg1 = v2 = v1 / stor_7;\n            require(v2 <= varg1, Error('sub failed'));\n            varg1 = v3 = varg1 - v2;\n        } else {\n            varg1 = v4 = 0;\n        }\n        require(_exit[v0][3] + varg1 >= _exit[v0][3], Error('add failed'));\n        _exit[v0][3] = _exit[v0][3] + varg1;\n        emit ReferralReward(address(varg3), address(varg2), varg0, varg1, block.timestamp);\n    }\n    return varg1;\n}\n\nfunction 0x1d35(uint256 varg0) private { \n    v0 = 0x203e(2, _buyPrice);\n    require(0x204fce5e3e25026110000000 <= v0, Error('sub failed'));\n    v1 = 0x203e(8, 0x204fce5e3e25026110000000);\n    v2 = 0x203e(varg0, v1);\n    v3 = 0x203e(0xde0b6b3a7640000, v2);\n    v4 = 0x203e(v0 - 0x204fce5e3e25026110000000, v0 - 0x204fce5e3e25026110000000);\n    v5 = v6 = v4 + v3;\n    require(v6 >= v4, Error('add failed'));\n    v7 = 0x203e(2, 0x204fce5e3e25026110000000);\n    require(v6 / v5 + v5 >= v6 / v5, Error('add failed'));\n    assert(2);\n    v5 = v6 / v5 + v5 >> 1;\n    while (v5 < v5) {\n        if (v5) {\n            break;\n        }\n        assert(v5);\n        require(v6 / v5 + v5 >= v6 / v5, Error('add failed'));\n        assert(2);\n        v5 = v8 >> 1;\n    }\n    require(v0 - 0x204fce5e3e25026110000000 <= v5, Error('sub failed'));\n    v9 = 0x203e(0xde0b6b3a7640000, v5 - (v0 - 0x204fce5e3e25026110000000));\n    assert(v7);\n    v10 = 0x203e(v9 / v7, 0x204fce5e3e25026110000000);\n    assert(0xde0b6b3a7640000);\n    require(_buyPrice + v10 / 0xde0b6b3a7640000 >= _buyPrice, Error('add failed'));\n    return _buyPrice + v10 / 0xde0b6b3a7640000, v9 / v7;\n}\n\nfunction 0x1e9e(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    if (_totalSupply > 0) {\n        v1 = _totalSupply + varg0;\n        require(v1 >= _totalSupply, Error('add failed'));\n        v2 = 0x203e(v1, _donate);\n        assert(_totalSupply);\n        _donate = v2 / _totalSupply;\n    }\n    v3 = _totalSupply + varg0;\n    require(v3 >= _totalSupply, Error('add failed'));\n    _totalSupply = v3;\n    v4 = _exit[v0][1] + varg0;\n    require(v4 >= _exit[v0][1], Error('add failed'));\n    _exit[v0][1] = v4;\n    if (_totalSupply > 0) {\n        v5 = 0x203e(_donate, varg0);\n        assert(_totalSupply);\n        require(_exit[v0][4] + v5 / _totalSupply >= _exit[v0][4], Error('add failed'));\n        _exit[v0][4] = _exit[v0][4] + v5 / _totalSupply;\n    }\n    return ;\n}\n\nfunction 0x203e(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, Error('mul failed'));\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction 0x227e(uint256 varg0) private { \n    require(v0 / 0xde0b6b3a7640000 <= _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000, Error('sub failed'));\n    v0 = 0x203e(varg0, 0x204fce5e3e25026110000000);\n    assert(0xde0b6b3a7640000);\n    require(_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 >= _buyPrice - 0x204fce5e3e25026110000000, Error('add failed'));\n    require(v0 / 0xde0b6b3a7640000 <= _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000, Error('sub failed'));\n    v1 = 0x203e(2, 0xde0b6b3a7640000);\n    require(_buyPrice - 0x204fce5e3e25026110000000 + (_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000) >= _buyPrice - 0x204fce5e3e25026110000000, Error('add failed'));\n    v2 = 0x203e(varg0, _buyPrice - 0x204fce5e3e25026110000000 + (_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000));\n    assert(v1);\n    return _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000, v2 / v1 / 0xde0b6b3a7640000;\n}\n\nfunction 0x237b(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = v2 = 0;\n    if (_totalSupply == varg0) {\n        v3 = 0x203e(_exit[v0][1], _donate);\n        assert(_totalSupply);\n        v1 = v4 = v3 / _totalSupply;\n    }\n    require(varg0 <= _totalSupply, Error('sub failed'));\n    v5 = 0x203e(_totalSupply - varg0, _donate);\n    assert(_totalSupply);\n    _donate = v5 / _totalSupply;\n    require(varg0 <= _totalSupply, Error('sub failed'));\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _exit[v0][1], Error('sub failed'));\n    _exit[v0][1] = _exit[v0][1] - varg0;\n    if (_totalSupply <= 0) {\n        if (v1 != 0) {\n            require(_exit[v0][4] - v1 <= _exit[v0][4], Error('sub failed'));\n            _exit[v0][4] = _exit[v0][4] - v1;\n        }\n    } else {\n        v6 = 0x203e(_donate, varg0);\n        assert(_totalSupply);\n        require(_exit[v0][4] - v6 / _totalSupply <= _exit[v0][4], Error('sub failed'));\n        _exit[v0][4] = _exit[v0][4] - v6 / _totalSupply;\n    }\n    return ;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0xb7a();\n}\n\nfunction sellPrice() public nonPayable { \n    require(0x204fce5e3e25026110000000 <= _buyPrice, Error('sub failed'));\n    assert(0xde0b6b3a7640000);\n    return (_buyPrice - 0x204fce5e3e25026110000000) / 0xde0b6b3a7640000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0][1];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice / 0xde0b6b3a7640000;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x50414e0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0, Error('Amount of tokens must be greater than zero'));\n    require(varg1 <= _exit[msg.sender][1], Error('You have not enough tokens'));\n    require(varg0 != msg.sender, Error('You cannot transfer tokens to yourself'));\n    if (varg1 != 0) {\n        v0 = 0x203e(stor_4, varg1);\n        assert(stor_5);\n        v1 = v2 = v0 / stor_5;\n        require(v2 <= varg1, Error('sub failed'));\n        v1 = varg1 - v2;\n    } else {\n        v1 = v3 = 0;\n    }\n    require(v1 != 0, Error('Insufficient tokens to do that'));\n    v4, v5 = 0x227e(v1);\n    require(v5 != 0, Error('Insufficient tokens to do that'));\n    _buyPrice = v4;\n    0x237b(varg1, msg.sender);\n    0x1e9e(v1, varg0);\n    require(_donate + v5 >= _donate, Error('add failed'));\n    _donate = _donate + v5;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction expectedFunds(uint256 varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = _totalSupply == 0;\n    }\n    if (!v0) {\n        if (varg0 > _totalSupply) {\n            v2 = v3 = _totalSupply;\n        }\n        v4, v5 = v6 = 0x227e(v2);\n        if (varg1) {\n            if (v6 != 0) {\n                v7 = 0x203e(stor_2, v6);\n                assert(stor_3);\n                v5 = v8 = v7 / stor_3;\n                require(v8 <= v6, Error('sub failed'));\n                v5 = v6 - v8;\n            } else {\n                v5 = v9 = 0;\n            }\n        }\n    } else {\n        v5 = v10 = 0;\n    }\n    return v5;\n}\n\nfunction expectedTokens(uint256 varg0, bool varg1) public nonPayable { \n    if (varg0 != 0) {\n        if (varg1) {\n            if (varg0 != 0) {\n                v0 = 0x203e(_expectedTokens, varg0);\n                assert(stor_1);\n                v1 = v2 = v0 / stor_1;\n                require(v2 <= varg0, Error('sub failed'));\n                v1 = varg0 - v2;\n            } else {\n                v1 = v3 = 0;\n            }\n        }\n        v4, v5 = 0x1d35(v1);\n    } else {\n        v5 = v6 = 0;\n    }\n    return v5;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x12e2(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender][1] > 0) {\n        0x12e2(_exit[msg.sender][1]);\n    }\n    0xb7a();\n}\n\nfunction donate() public payable { \n    require(_donate + msg.value >= _donate, Error('add failed'));\n    _donate = _donate + msg.value;\n    emit Donation(msg.sender, msg.value, block.timestamp);\n}\n\nfunction buy(address varg0) public payable { \n    0x578(varg0);\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x978(msg.sender);\n    require(v0 > 0, Error('You have no dividends'));\n    require(_exit[msg.sender][4] + v0 >= _exit[msg.sender][4], Error('add failed'));\n    _exit[msg.sender][4] = _exit[msg.sender][4] + v0;\n    if (v0 != 0) {\n        v1 = 0x203e(_expectedTokens, v0);\n        assert(stor_1);\n        v2 = v3 = v1 / stor_1;\n        require(v3 <= v0, Error('sub failed'));\n        v2 = v0 - v3;\n    } else {\n        v2 = v4 = 0;\n    }\n    require(v5 != 0, Error('Insufficient dividends to do that'));\n    if (address(_exit[address(address(msg.sender))][0]) != 0) {\n        v2 = v6 = 0x1bf7(v0, v5, address(_exit[address(address(msg.sender))][0]), msg.sender);\n        require(v6 != 0, Error('Insufficient dividends to do that'));\n    }\n    v7, v8 = 0x1d35(v2);\n    require(v8 != 0, Error('Insufficient dividends to do that'));\n    _buyPrice = v7;\n    0x1e9e(v8, msg.sender);\n    require(_donate + v2 >= _donate, Error('add failed'));\n    _donate = _donate + v2;\n    emit Reinvestment(msg.sender, v0, v8, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n}\n\nfunction 0x578(uint256 varg0) private { \n    if (msg.value != 0) {\n        v0 = 0x203e(_expectedTokens, msg.value);\n        assert(stor_1);\n        v1 = v2 = v0 / stor_1;\n        require(v2 <= msg.value, Error('sub failed'));\n        v1 = msg.value - v2;\n    } else {\n        v1 = v3 = 0;\n    }\n    require(v4 != 0, Error('Incoming funds is too small'));\n    v5 = v6 = address(varg0) != 0;\n    if (v6) {\n        v5 = v7 = address(varg0) != msg.sender;\n    }\n    if (v5) {\n        v5 = v8 = address(_exit[address(address(msg.sender))][0]) == 0;\n    }\n    if (v5) {\n        _exit[msg.sender][0] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _exit[msg.sender][0x0];\n    }\n    if (address(_exit[address(address(msg.sender))][0]) != 0) {\n        v1 = v9 = 0x1bf7(msg.value, v4, address(_exit[address(address(msg.sender))][0]), msg.sender);\n        require(v9 != 0, Error('Incoming funds is too small'));\n    }\n    v10, v11 = 0x1d35(v1);\n    require(v11 != 0, Error('Incoming funds is too small'));\n    _buyPrice = v10;\n    0x1e9e(v11, msg.sender);\n    require(_donate + v1 >= _donate, Error('add failed'));\n    _donate = _donate + v1;\n    emit Purchase(msg.sender, msg.value, v11, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n    return ;\n}\n\nfunction 0x978(uint256 varg0) private { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    v0 = address(varg0);\n    MEM[MEM[64]] = address(_exit[v0][0]);\n    v1 = _exit[v0][2] + _exit[v0][3];\n    require(v1 >= _exit[v0][2], Error('add failed'));\n    require(v1 >= 0);\n    if (_totalSupply > 0) {\n        v2 = 0x203e(_exit[v0][1], _donate);\n        assert(_totalSupply);\n        v1 = v3 = v1 + v2 / _totalSupply;\n        require(v3 >= v1, Error('add failed'));\n    }\n    if (_exit[v0][4] <= 0) {\n        if (_exit[v0][4] < 0) {\n            v1 = v4 = v1 + (0 - _exit[v0][4]);\n            require(v4 >= v1, Error('add failed'));\n        }\n    } else {\n        v1 = v5 = v1 - _exit[v0][4];\n        require(v5 <= v1, Error('sub failed'));\n    }\n    require(v1 >= 0);\n    return v1;\n}\n\nfunction 0xb7a() private { \n    v0 = 0x978(msg.sender);\n    require(v0 > 0, Error('You have no dividends'));\n    require(_exit[msg.sender][4] + v0 >= _exit[msg.sender][4], Error('add failed'));\n    _exit[msg.sender][4] = _exit[msg.sender][4] + v0;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Withdrawal(msg.sender, v0, block.timestamp);\n    return ;\n}\n\nfunction () public payable { \n    v0 = new bytes[](msg.data.length);\n    CALLDATACOPY(v0.data, 0, msg.data.length);\n    0x578(msg.data.length);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x65318b == uint32(function_selector >> 224)) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x18160ddd == uint32(function_selector >> 224)) {\n            totalSupply();\n        } else if (0x313ce567 == uint32(function_selector >> 224)) {\n            decimals();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x4b750334 == uint32(function_selector >> 224)) {\n            sellPrice();\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0x8620410b == uint32(function_selector >> 224)) {\n            buyPrice();\n        } else if (0x95d89b41 == uint32(function_selector >> 224)) {\n            symbol();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xbe2eaad4 == uint32(function_selector >> 224)) {\n            expectedFunds(uint256,bool);\n        } else if (0xc5f60620 == uint32(function_selector >> 224)) {\n            expectedTokens(uint256,bool);\n        } else if (0xe4849b32 == uint32(function_selector >> 224)) {\n            sell(uint256);\n        } else if (0xe9fad8ee == uint32(function_selector >> 224)) {\n            exit();\n        } else if (0xed88c68e == uint32(function_selector >> 224)) {\n            donate();\n        } else if (0xf088d547 == uint32(function_selector >> 224)) {\n            buy(address);\n        } else if (0xfdb5a03e == uint32(function_selector >> 224)) {\n            reinvest();\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.14 20:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _expectedTokens; // STORAGE[0x0]\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _totalSupply; // STORAGE[0x9]\nuint256 _donate; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0xb]\n\n// Events\nPurchase(address, uint256, uint256, uint256, uint256);\nWithdrawal(address, uint256, uint256);\nTransfer(address, address, uint256);\nSelling(address, uint256, uint256, uint256, uint256);\nDonation(address, uint256, uint256);\nReinvestment(address, uint256, uint256, uint256, uint256);\nReferralReward(address, address, uint256, uint256, uint256);\n\nfunction 0x12e2(uint256 varg0) private { \n    require(varg0 > 0, Error('Amount of tokens must be greater than zero'));\n    require(varg0 <= _exit[msg.sender][1], Error('You have not enough tokens'));\n    v0, v1 = 0x227e(varg0);\n    require(v1 != 0, Error('Insufficient tokens to do that'));\n    _buyPrice = v0;\n    if (v1 != 0) {\n        v2 = 0x203e(stor_2, v1);\n        assert(stor_3);\n        v3 = v4 = v2 / stor_3;\n        require(v4 <= v1, Error('sub failed'));\n        v3 = v1 - v4;\n    } else {\n        v3 = v5 = 0;\n    }\n    require(v3 != 0, Error('Insufficient tokens to do that'));\n    0x237b(varg0, msg.sender);\n    require(_exit[msg.sender][2] + v3 >= _exit[msg.sender][2], Error('add failed'));\n    _exit[msg.sender][2] = _exit[msg.sender][2] + v3;\n    require(_donate + v3 >= _donate, Error('add failed'));\n    _donate = _donate + v3;\n    emit Selling(msg.sender, varg0, v1, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n    return ;\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    v0 = 0x978(varg0);\n    return v0;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (18) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffff & 'Pantheon Ecosystem';\n    }\n    return v0;\n}\n\nfunction 0x1bf7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg2);\n    if (_exit[v0][1] >= 0x8ac7230489e80000) {\n        if (varg1 != 0) {\n            v1 = 0x203e(stor_6, varg1);\n            assert(stor_7);\n            varg1 = v2 = v1 / stor_7;\n            require(v2 <= varg1, Error('sub failed'));\n            varg1 = v3 = varg1 - v2;\n        } else {\n            varg1 = v4 = 0;\n        }\n        require(_exit[v0][3] + varg1 >= _exit[v0][3], Error('add failed'));\n        _exit[v0][3] = _exit[v0][3] + varg1;\n        emit ReferralReward(address(varg3), address(varg2), varg0, varg1, block.timestamp);\n    }\n    return varg1;\n}\n\nfunction 0x1d35(uint256 varg0) private { \n    v0 = 0x203e(2, _buyPrice);\n    require(0x204fce5e3e25026110000000 <= v0, Error('sub failed'));\n    v1 = 0x203e(8, 0x204fce5e3e25026110000000);\n    v2 = 0x203e(varg0, v1);\n    v3 = 0x203e(0xde0b6b3a7640000, v2);\n    v4 = 0x203e(v0 - 0x204fce5e3e25026110000000, v0 - 0x204fce5e3e25026110000000);\n    v5 = v6 = v4 + v3;\n    require(v6 >= v4, Error('add failed'));\n    v7 = 0x203e(2, 0x204fce5e3e25026110000000);\n    require(v6 / v5 + v5 >= v6 / v5, Error('add failed'));\n    assert(2);\n    v5 = v6 / v5 + v5 >> 1;\n    while (v5 < v5) {\n        if (v5) {\n            break;\n        }\n        assert(v5);\n        require(v6 / v5 + v5 >= v6 / v5, Error('add failed'));\n        assert(2);\n        v5 = v8 >> 1;\n    }\n    require(v0 - 0x204fce5e3e25026110000000 <= v5, Error('sub failed'));\n    v9 = 0x203e(0xde0b6b3a7640000, v5 - (v0 - 0x204fce5e3e25026110000000));\n    assert(v7);\n    v10 = 0x203e(v9 / v7, 0x204fce5e3e25026110000000);\n    assert(0xde0b6b3a7640000);\n    require(_buyPrice + v10 / 0xde0b6b3a7640000 >= _buyPrice, Error('add failed'));\n    return _buyPrice + v10 / 0xde0b6b3a7640000, v9 / v7;\n}\n\nfunction 0x1e9e(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    if (_totalSupply > 0) {\n        v1 = _totalSupply + varg0;\n        require(v1 >= _totalSupply, Error('add failed'));\n        v2 = 0x203e(v1, _donate);\n        assert(_totalSupply);\n        _donate = v2 / _totalSupply;\n    }\n    v3 = _totalSupply + varg0;\n    require(v3 >= _totalSupply, Error('add failed'));\n    _totalSupply = v3;\n    v4 = _exit[v0][1] + varg0;\n    require(v4 >= _exit[v0][1], Error('add failed'));\n    _exit[v0][1] = v4;\n    if (_totalSupply > 0) {\n        v5 = 0x203e(_donate, varg0);\n        assert(_totalSupply);\n        require(_exit[v0][4] + v5 / _totalSupply >= _exit[v0][4], Error('add failed'));\n        _exit[v0][4] = _exit[v0][4] + v5 / _totalSupply;\n    }\n    return ;\n}\n\nfunction 0x203e(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, Error('mul failed'));\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction 0x227e(uint256 varg0) private { \n    require(v0 / 0xde0b6b3a7640000 <= _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000, Error('sub failed'));\n    v0 = 0x203e(varg0, 0x204fce5e3e25026110000000);\n    assert(0xde0b6b3a7640000);\n    require(_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 >= _buyPrice - 0x204fce5e3e25026110000000, Error('add failed'));\n    require(v0 / 0xde0b6b3a7640000 <= _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000, Error('sub failed'));\n    v1 = 0x203e(2, 0xde0b6b3a7640000);\n    require(_buyPrice - 0x204fce5e3e25026110000000 + (_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000) >= _buyPrice - 0x204fce5e3e25026110000000, Error('add failed'));\n    v2 = 0x203e(varg0, _buyPrice - 0x204fce5e3e25026110000000 + (_buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000));\n    assert(v1);\n    return _buyPrice - 0x204fce5e3e25026110000000 + 0x204fce5e3e25026110000000 - v0 / 0xde0b6b3a7640000, v2 / v1 / 0xde0b6b3a7640000;\n}\n\nfunction 0x237b(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = v2 = 0;\n    if (_totalSupply == varg0) {\n        v3 = 0x203e(_exit[v0][1], _donate);\n        assert(_totalSupply);\n        v1 = v4 = v3 / _totalSupply;\n    }\n    require(varg0 <= _totalSupply, Error('sub failed'));\n    v5 = 0x203e(_totalSupply - varg0, _donate);\n    assert(_totalSupply);\n    _donate = v5 / _totalSupply;\n    require(varg0 <= _totalSupply, Error('sub failed'));\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _exit[v0][1], Error('sub failed'));\n    _exit[v0][1] = _exit[v0][1] - varg0;\n    if (_totalSupply <= 0) {\n        if (v1 != 0) {\n            require(_exit[v0][4] - v1 <= _exit[v0][4], Error('sub failed'));\n            _exit[v0][4] = _exit[v0][4] - v1;\n        }\n    } else {\n        v6 = 0x203e(_donate, varg0);\n        assert(_totalSupply);\n        require(_exit[v0][4] - v6 / _totalSupply <= _exit[v0][4], Error('sub failed'));\n        _exit[v0][4] = _exit[v0][4] - v6 / _totalSupply;\n    }\n    return ;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0xb7a();\n}\n\nfunction sellPrice() public nonPayable { \n    require(0x204fce5e3e25026110000000 <= _buyPrice, Error('sub failed'));\n    assert(0xde0b6b3a7640000);\n    return (_buyPrice - 0x204fce5e3e25026110000000) / 0xde0b6b3a7640000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0][1];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice / 0xde0b6b3a7640000;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x50414e0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0, Error('Amount of tokens must be greater than zero'));\n    require(varg1 <= _exit[msg.sender][1], Error('You have not enough tokens'));\n    require(varg0 != msg.sender, Error('You cannot transfer tokens to yourself'));\n    if (varg1 != 0) {\n        v0 = 0x203e(stor_4, varg1);\n        assert(stor_5);\n        v1 = v2 = v0 / stor_5;\n        require(v2 <= varg1, Error('sub failed'));\n        v1 = varg1 - v2;\n    } else {\n        v1 = v3 = 0;\n    }\n    require(v1 != 0, Error('Insufficient tokens to do that'));\n    v4, v5 = 0x227e(v1);\n    require(v5 != 0, Error('Insufficient tokens to do that'));\n    _buyPrice = v4;\n    0x237b(varg1, msg.sender);\n    0x1e9e(v1, varg0);\n    require(_donate + v5 >= _donate, Error('add failed'));\n    _donate = _donate + v5;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction expectedFunds(uint256 varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = _totalSupply == 0;\n    }\n    if (!v0) {\n        if (varg0 > _totalSupply) {\n            v2 = v3 = _totalSupply;\n        }\n        v4, v5 = v6 = 0x227e(v2);\n        if (varg1) {\n            if (v6 != 0) {\n                v7 = 0x203e(stor_2, v6);\n                assert(stor_3);\n                v5 = v8 = v7 / stor_3;\n                require(v8 <= v6, Error('sub failed'));\n                v5 = v6 - v8;\n            } else {\n                v5 = v9 = 0;\n            }\n        }\n    } else {\n        v5 = v10 = 0;\n    }\n    return v5;\n}\n\nfunction expectedTokens(uint256 varg0, bool varg1) public nonPayable { \n    if (varg0 != 0) {\n        if (varg1) {\n            if (varg0 != 0) {\n                v0 = 0x203e(_expectedTokens, varg0);\n                assert(stor_1);\n                v1 = v2 = v0 / stor_1;\n                require(v2 <= varg0, Error('sub failed'));\n                v1 = varg0 - v2;\n            } else {\n                v1 = v3 = 0;\n            }\n        }\n        v4, v5 = 0x1d35(v1);\n    } else {\n        v5 = v6 = 0;\n    }\n    return v5;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x12e2(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender][1] > 0) {\n        0x12e2(_exit[msg.sender][1]);\n    }\n    0xb7a();\n}\n\nfunction donate() public payable { \n    require(_donate + msg.value >= _donate, Error('add failed'));\n    _donate = _donate + msg.value;\n    emit Donation(msg.sender, msg.value, block.timestamp);\n}\n\nfunction buy(address varg0) public payable { \n    0x578(varg0);\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x978(msg.sender);\n    require(v0 > 0, Error('You have no dividends'));\n    require(_exit[msg.sender][4] + v0 >= _exit[msg.sender][4], Error('add failed'));\n    _exit[msg.sender][4] = _exit[msg.sender][4] + v0;\n    if (v0 != 0) {\n        v1 = 0x203e(_expectedTokens, v0);\n        assert(stor_1);\n        v2 = v3 = v1 / stor_1;\n        require(v3 <= v0, Error('sub failed'));\n        v2 = v0 - v3;\n    } else {\n        v2 = v4 = 0;\n    }\n    require(v5 != 0, Error('Insufficient dividends to do that'));\n    if (address(_exit[address(address(msg.sender))][0]) != 0) {\n        v2 = v6 = 0x1bf7(v0, v5, address(_exit[address(address(msg.sender))][0]), msg.sender);\n        require(v6 != 0, Error('Insufficient dividends to do that'));\n    }\n    v7, v8 = 0x1d35(v2);\n    require(v8 != 0, Error('Insufficient dividends to do that'));\n    _buyPrice = v7;\n    0x1e9e(v8, msg.sender);\n    require(_donate + v2 >= _donate, Error('add failed'));\n    _donate = _donate + v2;\n    emit Reinvestment(msg.sender, v0, v8, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n}\n\nfunction 0x578(uint256 varg0) private { \n    if (msg.value != 0) {\n        v0 = 0x203e(_expectedTokens, msg.value);\n        assert(stor_1);\n        v1 = v2 = v0 / stor_1;\n        require(v2 <= msg.value, Error('sub failed'));\n        v1 = msg.value - v2;\n    } else {\n        v1 = v3 = 0;\n    }\n    require(v4 != 0, Error('Incoming funds is too small'));\n    v5 = v6 = address(varg0) != 0;\n    if (v6) {\n        v5 = v7 = address(varg0) != msg.sender;\n    }\n    if (v5) {\n        v5 = v8 = address(_exit[address(address(msg.sender))][0]) == 0;\n    }\n    if (v5) {\n        _exit[msg.sender][0] = address(varg0) | ~0xffffffffffffffffffffffffffffffffffffffff & _exit[msg.sender][0x0];\n    }\n    if (address(_exit[address(address(msg.sender))][0]) != 0) {\n        v1 = v9 = 0x1bf7(msg.value, v4, address(_exit[address(address(msg.sender))][0]), msg.sender);\n        require(v9 != 0, Error('Incoming funds is too small'));\n    }\n    v10, v11 = 0x1d35(v1);\n    require(v11 != 0, Error('Incoming funds is too small'));\n    _buyPrice = v10;\n    0x1e9e(v11, msg.sender);\n    require(_donate + v1 >= _donate, Error('add failed'));\n    _donate = _donate + v1;\n    emit Purchase(msg.sender, msg.value, v11, _buyPrice / 0xde0b6b3a7640000, block.timestamp);\n    return ;\n}\n\nfunction 0x978(uint256 varg0) private { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    v0 = address(varg0);\n    MEM[MEM[64]] = address(_exit[v0][0]);\n    v1 = _exit[v0][2] + _exit[v0][3];\n    require(v1 >= _exit[v0][2], Error('add failed'));\n    require(v1 >= 0);\n    if (_totalSupply > 0) {\n        v2 = 0x203e(_exit[v0][1], _donate);\n        assert(_totalSupply);\n        v1 = v3 = v1 + v2 / _totalSupply;\n        require(v3 >= v1, Error('add failed'));\n    }\n    if (_exit[v0][4] <= 0) {\n        if (_exit[v0][4] < 0) {\n            v1 = v4 = v1 + (0 - _exit[v0][4]);\n            require(v4 >= v1, Error('add failed'));\n        }\n    } else {\n        v1 = v5 = v1 - _exit[v0][4];\n        require(v5 <= v1, Error('sub failed'));\n    }\n    require(v1 >= 0);\n    return v1;\n}\n\nfunction 0xb7a() private { \n    v0 = 0x978(msg.sender);\n    require(v0 > 0, Error('You have no dividends'));\n    require(_exit[msg.sender][4] + v0 >= _exit[msg.sender][4], Error('add failed'));\n    _exit[msg.sender][4] = _exit[msg.sender][4] + v0;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Withdrawal(msg.sender, v0, block.timestamp);\n    return ;\n}\n\nfunction () public payable { \n    v0 = new bytes[](msg.data.length);\n    CALLDATACOPY(v0.data, 0, msg.data.length);\n    0x578(msg.data.length);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x65318b == uint32(function_selector >> 224)) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == uint32(function_selector >> 224)) {\n            name();\n        } else if (0x18160ddd == uint32(function_selector >> 224)) {\n            totalSupply();\n        } else if (0x313ce567 == uint32(function_selector >> 224)) {\n            decimals();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x4b750334 == uint32(function_selector >> 224)) {\n            sellPrice();\n        } else if (0x70a08231 == uint32(function_selector >> 224)) {\n            balanceOf(address);\n        } else if (0x8620410b == uint32(function_selector >> 224)) {\n            buyPrice();\n        } else if (0x95d89b41 == uint32(function_selector >> 224)) {\n            symbol();\n        } else if (0xa9059cbb == uint32(function_selector >> 224)) {\n            transfer(address,uint256);\n        } else if (0xbe2eaad4 == uint32(function_selector >> 224)) {\n            expectedFunds(uint256,bool);\n        } else if (0xc5f60620 == uint32(function_selector >> 224)) {\n            expectedTokens(uint256,bool);\n        } else if (0xe4849b32 == uint32(function_selector >> 224)) {\n            sell(uint256);\n        } else if (0xe9fad8ee == uint32(function_selector >> 224)) {\n            exit();\n        } else if (0xed88c68e == uint32(function_selector >> 224)) {\n            donate();\n        } else if (0xf088d547 == uint32(function_selector >> 224)) {\n            buy(address);\n        } else if (0xfdb5a03e == uint32(function_selector >> 224)) {\n            reinvest();\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 54.06005024909973,
	"usage": {
		"completion_tokens": 653,
		"prompt_tokens": 5757,
		"total_tokens": 6410
	}
}