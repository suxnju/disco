{
	"address": "0x728781e75735dc0962df3a51d7ef47e798a7107e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity smart contract corresponding to the provided decompiled code could look like this:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract WolkProtocolToken {\n    string public name = \"Wolk Protocol Token\";\n    string public symbol = \"WOLK\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    address public owner;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n```\n\nPlease note that this is a basic implementation and does not cover all the functionalities from the decompiled code provided. For example, the `owner` functionality is not implemented in this contract. Also, the actual implementation might need additional checks and functionalities like safe math operations, access control and may be significantly more complex. \n\nThe Solidity contract provided is a basic ERC20 token contract. It includes functions for transferring tokens, approving spenders and transferring tokens from a spender's allowance. \n\nThe `transfer` function transfers a specified amount of tokens from the function caller to the specified address. \n\nThe `approve` function sets the allowance of a specified spender to a specified amount. \n\nThe `transferFrom` function transfers a specified amount of tokens from a specified address to another specified address, deducting from the allowance of the function caller.\n\nThe actual contract implementation would require additional checks, validations and functionalities to fully match the provided decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471808,
	"id": "chatcmpl-8Mugao63WJcvBh7fhJpDgMW4D1uah",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst name = 'Wolk Protocol Token'\nconst decimals = 18\nconst tokenGenerationMin = 50000000 * 10^18\nconst percentageETHReserve = 15\nconst symbol = 'WOLK'\nconst tokenGenerationMax = 150000000 * 10^18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  allowance is mapping of uint256 at storage 1\n  stor2 is uint32 at storage 2\n  totalTokens is uint256 at storage 2\n  owner is address at storage 3\n  newOwner is address at storage 4\n  reserveBalance is uint256 at storage 5\n  multisigWalletAddress is address at storage 6\n  stor7 is mapping of uint8 at storage 7\n  allSaleCompleted is uint8 at storage 8 offset 160\n  openSaleCompleted is uint8 at storage 8 offset 168\n  wolkSaleAddress is address at storage 8\n  stor9 is uint8 at storage 9 offset 160\n  stor9 is uint128 at storage 9 offset 160\n  burnFormulaAddress is address at storage 9\n  burnBasisPoints is uint256 at storage 10\n  stor11 is mapping of uint8 at storage 11\n  checkServiceFee is mapping of uint256 at storage 12\n  checkFeeSchedule is mapping of address at storage 13\n  stor14 is mapping of uint256 at storage 14\n  participantBalance is mapping of uint256 at storage 15\n  stor16 is mapping of uint8 at storage 16\n  presale_start_block is uint256 at storage 17\n  start_block is uint256 at storage 18\n  end_block is uint256 at storage 19\n  maxPerExchangeBP is uint256 at storage 20\n  exchangeIsRunning is uint8 at storage 21 offset 160\n  stor21 is uint128 at storage 21 offset 160\n  exchangeFormulaAddress is address at storage 21\n\ndef totalSupply(): # not payable\n  return uint256(totalTokens)\n\ndef exchangeFormula(): # not payable\n  return exchangeFormulaAddress\n\ndef exchangeIsRunning(): # not payable\n  return bool(exchangeIsRunning)\n\ndef end_block(): # not payable\n  return end_block\n\ndef checkAuthorization(address _owner, address _serviceProvider): # not payable\n  return bool(stor11[address(_owner)][address(_serviceProvider)])\n\ndef checkServiceFee(address _serviceProvider): # not payable\n  return checkServiceFee[address(_serviceProvider)]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef maxPerExchangeBP(): # not payable\n  return maxPerExchangeBP\n\ndef totalTokens(): # not payable\n  return uint256(totalTokens)\n\ndef burnFormula(): # not payable\n  return burnFormulaAddress\n\ndef participantBalance(address _participant): # not payable\n  return participantBalance[address(_participant)]\n\ndef owner(): # not payable\n  return owner\n\ndef multisigWallet(): # not payable\n  return multisigWalletAddress\n\ndef burnBasisPoints(): # not payable\n  return burnBasisPoints\n\ndef reserveBalance(): # not payable\n  return reserveBalance\n\ndef settlementIsRunning(): # not payable\n  return bool(uint8(stor9.field_160))\n\ndef start_block(): # not payable\n  return start_block\n\ndef openSaleCompleted(): # not payable\n  return bool(openSaleCompleted)\n\ndef presale_start_block(): # not payable\n  return presale_start_block\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\ndef allSaleCompleted(): # not payable\n  return bool(allSaleCompleted)\n\ndef wolkSale(): # not payable\n  return wolkSaleAddress\n\ndef checkFeeSchedule(address _serviceProvider): # not payable\n  return checkFeeSchedule[address(_serviceProvider)]\n\n#\n#  Regular functions\n#\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log 0x34376542: owner, newOwner\n  owner = newOwner\n  newOwner = 0\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require owner != newOwner\n  newOwner = newOwner\n\ndef updateSettlementStatus(bool _isRunning): # not payable\n  require owner == caller\n  Mask(96, 0, stor9.field_160) = Mask(96, 0, _isRunning)\n  return 1\n\ndef setBurnRate(uint256 _burnRate): # not payable\n  require owner == caller\n  require _burnRate > 0\n  require _burnRate <= 1000\n  burnBasisPoints = _burnRate\n  return 1\n\ndef deauthorizeProvider(address _providerToRemove): # not payable\n  stor11[caller][address(_providerToRemove)] = 0\n  log 0x79485d41: _providerToRemove, caller\n  return 1\n\ndef setMaxPerExchange(uint256 _maxPerExchange): # not payable\n  require owner == caller\n  require _maxPerExchange >= 10\n  require _maxPerExchange <= 100\n  maxPerExchangeBP = _maxPerExchange\n  return 1\n\ndef authorizeProvider(address _providerToAdd): # not payable\n  require stor7[address(_providerToAdd)]\n  stor11[caller][address(_providerToAdd)] = 1\n  log 0x8563cf33: _providerToAdd, caller\n  return 1\n\ndef removeService(address _owner, address _providerToRemove): # not payable\n  require owner == caller\n  stor11[address(_owner)][address(_providerToRemove)] = 0\n  log 0x79485d41: _providerToRemove, _owner\n  return 1\n\ndef approve(address spender, uint256 amount): # not payable\n  if amount:\n      require not allowance[caller][address(spender)]\n  allowance[caller][address(spender)] = amount\n  log 0x8c5be1e5: amount, caller, spender\n  return 1\n\ndef setBurnFormula(address _newBurnFormula): # not payable\n  require owner == caller\n  require _newBurnFormula\n  require ext_code.size(_newBurnFormula)\n  call _newBurnFormula.0x926f949e with:\n       gas gas_remaining - 710 wei\n      args 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 5 * 10^13\n  burnFormulaAddress = _newBurnFormula\n  return 1\n\ndef grantService(address _owner, address _providerToAdd): # not payable\n  require owner == caller\n  if not stor11[address(_owner)][caller]:\n      return 0\n  if not stor7[address(_providerToAdd)]:\n      return 0\n  stor11[address(_owner)][address(_providerToAdd)] = 1\n  log 0x8563cf33: _providerToAdd, caller\n  return 1\n\ndef _fallback() payable: # default function\n  require call.value > 0\n  if not openSaleCompleted:\n      require ext_code.size(this.address)\n      call this.address.tokenGenerationEvent(address participant) with:\n         value call.value wei\n           gas gas_remaining - 9710 wei\n          args caller\n  else:\n      require block.number >= end_block\n      require ext_code.size(this.address)\n      call this.address.purchaseWolk(address buyer) with:\n         value call.value wei\n           gas gas_remaining - 9710 wei\n          args caller\n  require ext_call.success\n\ndef setFeeFormula(address _newFeeFormula): # not payable\n  require 1 == bool(stor7[caller])\n  require checkFeeSchedule[address(_newFeeFormula)]\n  require ext_code.size(checkFeeSchedule[address(_newFeeFormula)])\n  call checkFeeSchedule[address(_newFeeFormula)].0x3e81d56e with:\n       gas gas_remaining - 710 wei\n      args 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 5 * 10^13\n  checkFeeSchedule[caller] = _newFeeFormula\n  return 1\n\ndef wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale): # not payable\n  require owner == caller\n  require uint256(totalTokens) < 1\n  require block.number <= _startBlock\n  require _endBlock > _startBlock\n  require _startBlock > _presaleStartBlock\n  presale_start_block = _presaleStartBlock\n  start_block = _startBlock\n  end_block = _endBlock\n  multisigWalletAddress = _wolkWallet\n  wolkSaleAddress = _wolkSale\n  stor7[caller] = 1\n  return 1\n\ndef setServiceFee(address _user, uint256 _fee): # not payable\n  require owner == caller\n  if _fee <= 0:\n      stor7[address(_user)] = 0\n      checkServiceFee[address(_user)] = 0\n      return 0\n  if _fee > 4000:\n      stor7[address(_user)] = 0\n      checkServiceFee[address(_user)] = 0\n      return 0\n  checkServiceFee[address(_user)] = _fee\n  stor7[address(_user)] = 1\n  log 0xe273f117: _fee, _user\n  return 1\n\ndef transfer(address recipient, uint256 amount): # not payable\n  if balanceOf[caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  require amount + balanceOf[recipient] >= amount\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log 0xddf252ad: amount, caller, recipient\n  return 1\n\ndef refund(): # not payable\n  require stor14[caller] > 0\n  require not allSaleCompleted\n  require uint256(totalTokens) < 50000000 * 10^18\n  require block.number > end_block\n  balanceOf[caller] = 0\n  stor14[caller] = 0\n  require balanceOf[caller] <= uint256(totalTokens)\n  uint256(totalTokens) -= balanceOf[caller]\n  log 0xf505eb6e: balanceOf[caller], caller\n  log 0xb6c0eca8: stor14[caller], caller\n  call caller with:\n     value stor14[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef removeParticipant(address[] _presaleParticipants): # not payable\n  mem[128 len 32 * _presaleParticipants.length] = call.data[_presaleParticipants + 36 len 32 * _presaleParticipants.length]\n  require owner == caller\n  idx = 0\n  while idx < _presaleParticipants.length:\n      require idx < _presaleParticipants.length\n      stor16[mem[(32 * idx) + 140 len 20]] = 0\n      require idx < _presaleParticipants.length\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 15\n      participantBalance[mem[(32 * idx) + 140 len 20]] = 0\n      idx = idx + 1\n      continue \n  return 1\n\ndef estLiquidationCap(): # not payable\n  if not openSaleCompleted:\n      return 0\n  if uint256(totalTokens):\n      require uint256(totalTokens)\n      require maxPerExchangeBP * uint256(totalTokens) / uint256(totalTokens) == maxPerExchangeBP\n  require maxPerExchangeBP * uint256(totalTokens) == (10000 * maxPerExchangeBP * uint256(totalTokens) / 10000) + (maxPerExchangeBP * uint256(totalTokens) % 10000)\n  if maxPerExchangeBP * uint256(totalTokens) / 10000 >= 100 * 10^18:\n      return (maxPerExchangeBP * uint256(totalTokens) / 10000)\n  return 100 * 10^18\n\ndef setExchangeFormula(address _newExchangeformula): # not payable\n  require owner == caller\n  require ext_code.size(_newExchangeformula)\n  call _newExchangeformula.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  require ext_code.size(_newExchangeformula)\n  call _newExchangeformula.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  exchangeFormulaAddress = _newExchangeformula\n  exchangeIsRunning = 0\n  return 1\n\ndef updateExchangeStatus(bool _isRunning): # not payable\n  require owner == caller\n  if _isRunning:\n      require ext_code.size(exchangeFormulaAddress)\n      call exchangeFormulaAddress.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n           gas gas_remaining - 710 wei\n          args 0, uint32(stor2), reserveBalance, 15, 10^18\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      require ext_code.size(exchangeFormulaAddress)\n      call exchangeFormulaAddress.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n           gas gas_remaining - 710 wei\n          args 0, uint32(stor2), reserveBalance, 15, 10^18\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n  stor21 = Mask(96, 0, _isRunning)\n  return 1\n\ndef finalizeOpenSale(): # not payable\n  require owner == caller\n  require not openSaleCompleted\n  require uint256(totalTokens) >= 50000000 * 10^18\n  openSaleCompleted = 1\n  end_block = block.number\n  if uint256(totalTokens):\n      require uint256(totalTokens)\n      require 15 * uint256(totalTokens) / uint256(totalTokens) == 15\n  require 15 * uint256(totalTokens) == (100000 * 15 * uint256(totalTokens) / 100000) + (15 * uint256(totalTokens) % 100000)\n  reserveBalance = 15 * uint256(totalTokens) / 100000\n  require 15 * uint256(totalTokens) / 100000 <= eth.balance(this.address)\n  call caller with:\n     value eth.balance(this.address) - (15 * uint256(totalTokens) / 100000) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  if balanceOf[address(sender)] < amount:\n      return 0\n  if allowance[address(sender)][caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount + balanceOf[address(recipient)] >= balanceOf[address(recipient)]\n  require amount + balanceOf[address(recipient)] >= amount\n  balanceOf[address(recipient)] += amount\n  require amount <= balanceOf[sender]\n  balanceOf[address(sender)] = balanceOf[sender] - amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log 0xddf252ad: amount, sender, recipient\n  return 1\n\ndef finalize() payable: \n  require wolkSaleAddress == caller\n  require openSaleCompleted\n  require not allSaleCompleted\n  if call.value:\n      require call.value\n      require 100000 * call.value / call.value == 100000\n  require 100000 * call.value == (15 * 100000 * call.value / 15) + (100000 * call.value % 15)\n  require (100000 * call.value / 15) + uint256(totalTokens) >= uint256(totalTokens)\n  require (100000 * call.value / 15) + uint256(totalTokens) >= 100000 * call.value / 15\n  uint256(totalTokens) += 100000 * call.value / 15\n  require call.value + reserveBalance >= reserveBalance\n  require call.value + reserveBalance >= call.value\n  reserveBalance += call.value\n  log 0xddf252ad: (100000 * call.value / 15), this.address, wolkSaleAddress\n  require (100000 * call.value / 15) + balanceOf[stor8] >= balanceOf[stor8]\n  require (100000 * call.value / 15) + balanceOf[stor8] >= 100000 * call.value / 15\n  balanceOf[stor8] += 100000 * call.value / 15\n  log 0x7ff6ea1c: (100000 * call.value / 15), wolkSaleAddress\n  allSaleCompleted = 1\n\ndef purchaseWolk(address _buyer) payable: \n  require exchangeIsRunning\n  require allSaleCompleted\n  require call.value > 0\n  require ext_code.size(exchangeFormulaAddress)\n  call exchangeFormulaAddress.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, call.value\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  require ext_call.return_data[0] + uint256(totalTokens) >= uint256(totalTokens)\n  require ext_call.return_data[0] + uint256(totalTokens) >= ext_call.return_data[0]\n  uint256(totalTokens) += ext_call.return_data[0]\n  require ext_call.return_data[0] + balanceOf[address(_buyer)] >= balanceOf[address(_buyer)]\n  require ext_call.return_data[0] + balanceOf[address(_buyer)] >= ext_call.return_data[0]\n  balanceOf[address(_buyer)] += ext_call.return_data[0]\n  require call.value + reserveBalance >= reserveBalance\n  require call.value + reserveBalance >= call.value\n  reserveBalance += call.value\n  log 0x7ff6ea1c: ext_call.return_data[0], _buyer\n  log 0xddf252ad: ext_call.return_data[0], this.address, _buyer\n  return ext_call.return_data[0]\n\ndef addParticipant(address[] _presaleParticipants, uint256[] _contributionLimits): # not payable\n  mem[128 len 32 * _presaleParticipants.length] = call.data[_presaleParticipants + 36 len 32 * _presaleParticipants.length]\n  mem[(32 * _presaleParticipants.length) + 128] = _contributionLimits.length\n  mem[(32 * _presaleParticipants.length) + 160 len 32 * _contributionLimits.length] = call.data[_contributionLimits + 36 len 32 * _contributionLimits.length]\n  require owner == caller\n  require _presaleParticipants.length == _contributionLimits.length\n  idx = 0\n  while idx < _presaleParticipants.length:\n      require idx < _presaleParticipants.length\n      stor16[mem[(32 * idx) + 140 len 20]] = 1\n      require idx < _contributionLimits.length\n      if mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]:\n          require mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]\n          require 10^18 * mem[(32 * idx) + (32 * _presaleParticipants.length) + 160] / mem[(32 * idx) + (32 * _presaleParticipants.length) + 160] == 10^18\n      require idx < _presaleParticipants.length\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 15\n      participantBalance[mem[(32 * idx) + 140 len 20]] = 10^18 * mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]\n      idx = idx + 1\n      continue \n  return 1\n\ndef sellWolk(uint256 _wolkAmount): # not payable\n  require exchangeIsRunning\n  require allSaleCompleted\n  if not openSaleCompleted:\n      require balanceOf[caller] >= _wolkAmount\n      require 0 >= _wolkAmount\n  else:\n      if uint256(totalTokens):\n          require uint256(totalTokens)\n          require maxPerExchangeBP * uint256(totalTokens) / uint256(totalTokens) == maxPerExchangeBP\n      require maxPerExchangeBP * uint256(totalTokens) == (10000 * maxPerExchangeBP * uint256(totalTokens) / 10000) + (maxPerExchangeBP * uint256(totalTokens) % 10000)\n      require balanceOf[caller] >= _wolkAmount\n      if maxPerExchangeBP * uint256(totalTokens) / 10000 >= 100 * 10^18:\n          require maxPerExchangeBP * uint256(totalTokens) / 10000 >= _wolkAmount\n      else:\n          require 100 * 10^18 >= _wolkAmount\n  require ext_code.size(exchangeFormulaAddress)\n  call exchangeFormulaAddress.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, _wolkAmount\n  require ext_call.success\n  require eth.balance(this.address) > ext_call.return_data[0]\n  require _wolkAmount <= balanceOf[caller]\n  balanceOf[caller] -= _wolkAmount\n  require _wolkAmount <= uint256(totalTokens)\n  uint256(totalTokens) -= _wolkAmount\n  require ext_call.return_data[0] <= eth.balance(this.address)\n  reserveBalance = eth.balance(this.address) - ext_call.return_data[0]\n  log 0xf505eb6e: _wolkAmount, caller\n  log 0xddf252ad: _wolkAmount, caller, 0\n  call caller with:\n     value ext_call.return_data[0] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  return ext_call.return_data[0]\n\ndef settleSeller(address _seller, uint256 _value): # not payable\n  require 1 == bool(stor7[caller])\n  require uint8(stor9.field_160)\n  require checkServiceFee[caller] > 0\n  require checkServiceFee[caller] <= 4000\n  require _value > 0\n  if not checkFeeSchedule[caller]:\n      if _value:\n          require _value\n          require checkServiceFee[caller] * _value / _value == checkServiceFee[caller]\n      require checkServiceFee[caller] * _value == (10000 * checkServiceFee[caller] * _value / 10000) + (checkServiceFee[caller] * _value % 10000)\n      require checkServiceFee[caller] * _value / 10000 <= _value\n      require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n      require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n      require balanceOf[address(_seller)] >= 0\n      balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n      log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n  else:\n      require ext_code.size(checkFeeSchedule[caller])\n      call checkFeeSchedule[caller].0x3e81d56e with:\n           gas gas_remaining - 710 wei\n          args _value\n      require ext_call.success\n      if _value:\n          require _value\n          require checkServiceFee[caller] * _value / _value == checkServiceFee[caller]\n      require checkServiceFee[caller] * _value == (10000 * checkServiceFee[caller] * _value / 10000) + (checkServiceFee[caller] * _value % 10000)\n      if ext_call.return_data[0] >= 1:\n          if ext_call.return_data[0] <= checkServiceFee[caller] * _value / 10000:\n              require ext_call.return_data[0] <= _value\n              require balanceOf[caller] >= _value - ext_call.return_data[0]\n              require _value - ext_call.return_data[0] + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n              require balanceOf[address(_seller)] >= 0\n              balanceOf[address(_seller)] = _value - ext_call.return_data[0] + balanceOf[address(_seller)]\n              log 0xddf252ad: (_value - ext_call.return_data[0]), caller, _seller\n          else:\n              require checkServiceFee[caller] * _value / 10000 <= _value\n              require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n              require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n              require balanceOf[address(_seller)] >= 0\n              balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n              log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n      else:\n          require checkServiceFee[caller] * _value / 10000 <= _value\n          require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n          require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n          require balanceOf[address(_seller)] >= 0\n          balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n          log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n  return 1\n\ndef settleBuyer(address _buyer, uint256 _value): # not payable\n  require 1 == bool(stor7[caller])\n  require uint8(stor9.field_160)\n  require burnBasisPoints > 0\n  require burnBasisPoints <= 1000\n  require stor11[address(_buyer)][caller]\n  require balanceOf[address(_buyer)] >= _value\n  require _value > 0\n  if not burnFormulaAddress:\n      if _value:\n          require _value\n          require burnBasisPoints * _value / _value == burnBasisPoints\n      require burnBasisPoints * _value == (10000 * burnBasisPoints * _value / 10000) + (burnBasisPoints * _value % 10000)\n      require burnBasisPoints * _value / 10000 <= _value\n      require _value <= balanceOf[address(_buyer)]\n      balanceOf[address(_buyer)] -= _value\n      require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n      require balanceOf[caller] >= 0\n      balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n      require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n      uint256(totalTokens) -= burnBasisPoints * _value / 10000\n      log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n      log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n      log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n  else:\n      require ext_code.size(burnFormulaAddress)\n      call burnFormulaAddress.0x926f949e with:\n           gas gas_remaining - 710 wei\n          args _value\n      require ext_call.success\n      if _value:\n          require _value\n          require burnBasisPoints * _value / _value == burnBasisPoints\n      require burnBasisPoints * _value == (10000 * burnBasisPoints * _value / 10000) + (burnBasisPoints * _value % 10000)\n      if ext_call.return_data[0] >= 1:\n          if ext_call.return_data[0] <= burnBasisPoints * _value / 10000:\n              require ext_call.return_data[0] <= _value\n              require _value <= balanceOf[address(_buyer)]\n              balanceOf[address(_buyer)] -= _value\n              require _value - ext_call.return_data[0] + balanceOf[caller] >= balanceOf[caller]\n              require balanceOf[caller] >= 0\n              balanceOf[caller] = _value - ext_call.return_data[0] + balanceOf[caller]\n              require ext_call.return_data[0] <= uint256(totalTokens)\n              uint256(totalTokens) -= ext_call.return_data[0]\n              log 0xddf252ad: (_value - ext_call.return_data[0]), _buyer, caller\n              log 0xddf252ad: ext_call.return_data[0], _buyer, 0\n              log 0xa02fa7af: ext_call.return_data[0], _buyer, caller\n          else:\n              require burnBasisPoints * _value / 10000 <= _value\n              require _value <= balanceOf[address(_buyer)]\n              balanceOf[address(_buyer)] -= _value\n              require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n              require balanceOf[caller] >= 0\n              balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n              require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n              uint256(totalTokens) -= burnBasisPoints * _value / 10000\n              log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n              log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n              log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n      else:\n          require burnBasisPoints * _value / 10000 <= _value\n          require _value <= balanceOf[address(_buyer)]\n          balanceOf[address(_buyer)] -= _value\n          require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n          require balanceOf[caller] >= 0\n          balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n          require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n          uint256(totalTokens) -= burnBasisPoints * _value / 10000\n          log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n          log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n          log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n  return 1\n\ndef tokenGenerationEvent(address _participant) payable: \n  require stor16[address(_participant)]\n  require not openSaleCompleted\n  require not allSaleCompleted\n  require block.number <= end_block\n  require call.value > 0\n  if block.number < start_block:\n      if block.number < presale_start_block:\n          require block.number >= start_block\n      else:\n          require participantBalance[address(_participant)] >= call.value\n          require call.value <= participantBalance[address(_participant)]\n          participantBalance[address(_participant)] -= call.value\n  if uint256(totalTokens) < 50000000 * 10^18:\n      if call.value:\n          require call.value\n          require 1177 * call.value / call.value == 1177\n      require (1177 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n      require (1177 * call.value) + uint256(totalTokens) >= 1177 * call.value\n      require (1177 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n      uint256(totalTokens) += 1177 * call.value\n      log 0xddf252ad: (1177 * call.value), this.address, _participant\n      require (1177 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n      require (1177 * call.value) + balanceOf[address(_participant)] >= 1177 * call.value\n      balanceOf[address(_participant)] += 1177 * call.value\n      require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n      require call.value + stor14[address(_participant)] >= call.value\n      stor14[address(_participant)] += call.value\n      log 0x7ff6ea1c: (1177 * call.value), _participant\n  else:\n      if uint256(totalTokens) < 60000000 * 10^18:\n          if call.value:\n              require call.value\n              require 1143 * call.value / call.value == 1143\n          require (1143 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n          require (1143 * call.value) + uint256(totalTokens) >= 1143 * call.value\n          require (1143 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n          uint256(totalTokens) += 1143 * call.value\n          log 0xddf252ad: (1143 * call.value), this.address, _participant\n          require (1143 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n          require (1143 * call.value) + balanceOf[address(_participant)] >= 1143 * call.value\n          balanceOf[address(_participant)] += 1143 * call.value\n          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n          require call.value + stor14[address(_participant)] >= call.value\n          stor14[address(_participant)] += call.value\n          log 0x7ff6ea1c: (1143 * call.value), _participant\n      else:\n          if uint256(totalTokens) < 70000000 * 10^18:\n              if call.value:\n                  require call.value\n                  require 1111 * call.value / call.value == 1111\n              require (1111 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n              require (1111 * call.value) + uint256(totalTokens) >= 1111 * call.value\n              require (1111 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n              uint256(totalTokens) += 1111 * call.value\n              log 0xddf252ad: (1111 * call.value), this.address, _participant\n              require (1111 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n              require (1111 * call.value) + balanceOf[address(_participant)] >= 1111 * call.value\n              balanceOf[address(_participant)] += 1111 * call.value\n              require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n              require call.value + stor14[address(_participant)] >= call.value\n              stor14[address(_participant)] += call.value\n              log 0x7ff6ea1c: (1111 * call.value), _participant\n          else:\n              if uint256(totalTokens) < 80000000 * 10^18:\n                  if call.value:\n                      require call.value\n                      require 1081 * call.value / call.value == 1081\n                  require (1081 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                  require (1081 * call.value) + uint256(totalTokens) >= 1081 * call.value\n                  require (1081 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                  uint256(totalTokens) += 1081 * call.value\n                  log 0xddf252ad: (1081 * call.value), this.address, _participant\n                  require (1081 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                  require (1081 * call.value) + balanceOf[address(_participant)] >= 1081 * call.value\n                  balanceOf[address(_participant)] += 1081 * call.value\n                  require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                  require call.value + stor14[address(_participant)] >= call.value\n                  stor14[address(_participant)] += call.value\n                  log 0x7ff6ea1c: (1081 * call.value), _participant\n              else:\n                  if uint256(totalTokens) < 25000 * 10^18 * 3600:\n                      if call.value:\n                          require call.value\n                          require 1053 * call.value / call.value == 1053\n                      require (1053 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                      require (1053 * call.value) + uint256(totalTokens) >= 1053 * call.value\n                      require (1053 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                      uint256(totalTokens) += 1053 * call.value\n                      log 0xddf252ad: (1053 * call.value), this.address, _participant\n                      require (1053 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                      require (1053 * call.value) + balanceOf[address(_participant)] >= 1053 * call.value\n                      balanceOf[address(_participant)] += 1053 * call.value\n                      require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                      require call.value + stor14[address(_participant)] >= call.value\n                      stor14[address(_participant)] += call.value\n                      log 0x7ff6ea1c: (1053 * call.value), _participant\n                  else:\n                      if uint256(totalTokens) >= 100000000 * 10^18:\n                          if call.value:\n                              require call.value\n                              require 1000 * call.value / call.value == 1000\n                          require (1000 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                          require (1000 * call.value) + uint256(totalTokens) >= 1000 * call.value\n                          require (1000 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                          uint256(totalTokens) += 1000 * call.value\n                          log 0xddf252ad: (1000 * call.value), this.address, _participant\n                          require (1000 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                          require (1000 * call.value) + balanceOf[address(_participant)] >= 1000 * call.value\n                          balanceOf[address(_participant)] += 1000 * call.value\n                          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                          require call.value + stor14[address(_participant)] >= call.value\n                          stor14[address(_participant)] += call.value\n                          log 0x7ff6ea1c: (1000 * call.value), _participant\n                      else:\n                          if call.value:\n                              require call.value\n                              require 1026 * call.value / call.value == 1026\n                          require (1026 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                          require (1026 * call.value) + uint256(totalTokens) >= 1026 * call.value\n                          require (1026 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                          uint256(totalTokens) += 1026 * call.value\n                          log 0xddf252ad: (1026 * call.value), this.address, _participant\n                          require (1026 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                          require (1026 * call.value) + balanceOf[address(_participant)] >= 1026 * call.value\n                          balanceOf[address(_participant)] += 1026 * call.value\n                          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                          require call.value + stor14[address(_participant)] >= call.value\n                          stor14[address(_participant)] += call.value\n                          log 0x7ff6ea1c: (1026 * call.value), _participant\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'Wolk Protocol Token'\nconst decimals = 18\nconst tokenGenerationMin = 50000000 * 10^18\nconst percentageETHReserve = 15\nconst symbol = 'WOLK'\nconst tokenGenerationMax = 150000000 * 10^18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  allowance is mapping of uint256 at storage 1\n  stor2 is uint32 at storage 2\n  totalTokens is uint256 at storage 2\n  owner is address at storage 3\n  newOwner is address at storage 4\n  reserveBalance is uint256 at storage 5\n  multisigWalletAddress is address at storage 6\n  stor7 is mapping of uint8 at storage 7\n  allSaleCompleted is uint8 at storage 8 offset 160\n  openSaleCompleted is uint8 at storage 8 offset 168\n  wolkSaleAddress is address at storage 8\n  stor9 is uint8 at storage 9 offset 160\n  stor9 is uint128 at storage 9 offset 160\n  burnFormulaAddress is address at storage 9\n  burnBasisPoints is uint256 at storage 10\n  stor11 is mapping of uint8 at storage 11\n  checkServiceFee is mapping of uint256 at storage 12\n  checkFeeSchedule is mapping of address at storage 13\n  stor14 is mapping of uint256 at storage 14\n  participantBalance is mapping of uint256 at storage 15\n  stor16 is mapping of uint8 at storage 16\n  presale_start_block is uint256 at storage 17\n  start_block is uint256 at storage 18\n  end_block is uint256 at storage 19\n  maxPerExchangeBP is uint256 at storage 20\n  exchangeIsRunning is uint8 at storage 21 offset 160\n  stor21 is uint128 at storage 21 offset 160\n  exchangeFormulaAddress is address at storage 21\n\ndef totalSupply(): # not payable\n  return uint256(totalTokens)\n\ndef exchangeFormula(): # not payable\n  return exchangeFormulaAddress\n\ndef exchangeIsRunning(): # not payable\n  return bool(exchangeIsRunning)\n\ndef end_block(): # not payable\n  return end_block\n\ndef checkAuthorization(address _owner, address _serviceProvider): # not payable\n  return bool(stor11[address(_owner)][address(_serviceProvider)])\n\ndef checkServiceFee(address _serviceProvider): # not payable\n  return checkServiceFee[address(_serviceProvider)]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef maxPerExchangeBP(): # not payable\n  return maxPerExchangeBP\n\ndef totalTokens(): # not payable\n  return uint256(totalTokens)\n\ndef burnFormula(): # not payable\n  return burnFormulaAddress\n\ndef participantBalance(address _participant): # not payable\n  return participantBalance[address(_participant)]\n\ndef owner(): # not payable\n  return owner\n\ndef multisigWallet(): # not payable\n  return multisigWalletAddress\n\ndef burnBasisPoints(): # not payable\n  return burnBasisPoints\n\ndef reserveBalance(): # not payable\n  return reserveBalance\n\ndef settlementIsRunning(): # not payable\n  return bool(uint8(stor9.field_160))\n\ndef start_block(): # not payable\n  return start_block\n\ndef openSaleCompleted(): # not payable\n  return bool(openSaleCompleted)\n\ndef presale_start_block(): # not payable\n  return presale_start_block\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\ndef allSaleCompleted(): # not payable\n  return bool(allSaleCompleted)\n\ndef wolkSale(): # not payable\n  return wolkSaleAddress\n\ndef checkFeeSchedule(address _serviceProvider): # not payable\n  return checkFeeSchedule[address(_serviceProvider)]\n\n#\n#  Regular functions\n#\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log 0x34376542: owner, newOwner\n  owner = newOwner\n  newOwner = 0\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require owner != newOwner\n  newOwner = newOwner\n\ndef updateSettlementStatus(bool _isRunning): # not payable\n  require owner == caller\n  Mask(96, 0, stor9.field_160) = Mask(96, 0, _isRunning)\n  return 1\n\ndef setBurnRate(uint256 _burnRate): # not payable\n  require owner == caller\n  require _burnRate > 0\n  require _burnRate <= 1000\n  burnBasisPoints = _burnRate\n  return 1\n\ndef deauthorizeProvider(address _providerToRemove): # not payable\n  stor11[caller][address(_providerToRemove)] = 0\n  log 0x79485d41: _providerToRemove, caller\n  return 1\n\ndef setMaxPerExchange(uint256 _maxPerExchange): # not payable\n  require owner == caller\n  require _maxPerExchange >= 10\n  require _maxPerExchange <= 100\n  maxPerExchangeBP = _maxPerExchange\n  return 1\n\ndef authorizeProvider(address _providerToAdd): # not payable\n  require stor7[address(_providerToAdd)]\n  stor11[caller][address(_providerToAdd)] = 1\n  log 0x8563cf33: _providerToAdd, caller\n  return 1\n\ndef removeService(address _owner, address _providerToRemove): # not payable\n  require owner == caller\n  stor11[address(_owner)][address(_providerToRemove)] = 0\n  log 0x79485d41: _providerToRemove, _owner\n  return 1\n\ndef approve(address spender, uint256 amount): # not payable\n  if amount:\n      require not allowance[caller][address(spender)]\n  allowance[caller][address(spender)] = amount\n  log 0x8c5be1e5: amount, caller, spender\n  return 1\n\ndef setBurnFormula(address _newBurnFormula): # not payable\n  require owner == caller\n  require _newBurnFormula\n  require ext_code.size(_newBurnFormula)\n  call _newBurnFormula.0x926f949e with:\n       gas gas_remaining - 710 wei\n      args 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 5 * 10^13\n  burnFormulaAddress = _newBurnFormula\n  return 1\n\ndef grantService(address _owner, address _providerToAdd): # not payable\n  require owner == caller\n  if not stor11[address(_owner)][caller]:\n      return 0\n  if not stor7[address(_providerToAdd)]:\n      return 0\n  stor11[address(_owner)][address(_providerToAdd)] = 1\n  log 0x8563cf33: _providerToAdd, caller\n  return 1\n\ndef _fallback() payable: # default function\n  require call.value > 0\n  if not openSaleCompleted:\n      require ext_code.size(this.address)\n      call this.address.tokenGenerationEvent(address participant) with:\n         value call.value wei\n           gas gas_remaining - 9710 wei\n          args caller\n  else:\n      require block.number >= end_block\n      require ext_code.size(this.address)\n      call this.address.purchaseWolk(address buyer) with:\n         value call.value wei\n           gas gas_remaining - 9710 wei\n          args caller\n  require ext_call.success\n\ndef setFeeFormula(address _newFeeFormula): # not payable\n  require 1 == bool(stor7[caller])\n  require checkFeeSchedule[address(_newFeeFormula)]\n  require ext_code.size(checkFeeSchedule[address(_newFeeFormula)])\n  call checkFeeSchedule[address(_newFeeFormula)].0x3e81d56e with:\n       gas gas_remaining - 710 wei\n      args 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 5 * 10^13\n  checkFeeSchedule[caller] = _newFeeFormula\n  return 1\n\ndef wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale): # not payable\n  require owner == caller\n  require uint256(totalTokens) < 1\n  require block.number <= _startBlock\n  require _endBlock > _startBlock\n  require _startBlock > _presaleStartBlock\n  presale_start_block = _presaleStartBlock\n  start_block = _startBlock\n  end_block = _endBlock\n  multisigWalletAddress = _wolkWallet\n  wolkSaleAddress = _wolkSale\n  stor7[caller] = 1\n  return 1\n\ndef setServiceFee(address _user, uint256 _fee): # not payable\n  require owner == caller\n  if _fee <= 0:\n      stor7[address(_user)] = 0\n      checkServiceFee[address(_user)] = 0\n      return 0\n  if _fee > 4000:\n      stor7[address(_user)] = 0\n      checkServiceFee[address(_user)] = 0\n      return 0\n  checkServiceFee[address(_user)] = _fee\n  stor7[address(_user)] = 1\n  log 0xe273f117: _fee, _user\n  return 1\n\ndef transfer(address recipient, uint256 amount): # not payable\n  if balanceOf[caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  require amount + balanceOf[recipient] >= amount\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log 0xddf252ad: amount, caller, recipient\n  return 1\n\ndef refund(): # not payable\n  require stor14[caller] > 0\n  require not allSaleCompleted\n  require uint256(totalTokens) < 50000000 * 10^18\n  require block.number > end_block\n  balanceOf[caller] = 0\n  stor14[caller] = 0\n  require balanceOf[caller] <= uint256(totalTokens)\n  uint256(totalTokens) -= balanceOf[caller]\n  log 0xf505eb6e: balanceOf[caller], caller\n  log 0xb6c0eca8: stor14[caller], caller\n  call caller with:\n     value stor14[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef removeParticipant(address[] _presaleParticipants): # not payable\n  mem[128 len 32 * _presaleParticipants.length] = call.data[_presaleParticipants + 36 len 32 * _presaleParticipants.length]\n  require owner == caller\n  idx = 0\n  while idx < _presaleParticipants.length:\n      require idx < _presaleParticipants.length\n      stor16[mem[(32 * idx) + 140 len 20]] = 0\n      require idx < _presaleParticipants.length\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 15\n      participantBalance[mem[(32 * idx) + 140 len 20]] = 0\n      idx = idx + 1\n      continue \n  return 1\n\ndef estLiquidationCap(): # not payable\n  if not openSaleCompleted:\n      return 0\n  if uint256(totalTokens):\n      require uint256(totalTokens)\n      require maxPerExchangeBP * uint256(totalTokens) / uint256(totalTokens) == maxPerExchangeBP\n  require maxPerExchangeBP * uint256(totalTokens) == (10000 * maxPerExchangeBP * uint256(totalTokens) / 10000) + (maxPerExchangeBP * uint256(totalTokens) % 10000)\n  if maxPerExchangeBP * uint256(totalTokens) / 10000 >= 100 * 10^18:\n      return (maxPerExchangeBP * uint256(totalTokens) / 10000)\n  return 100 * 10^18\n\ndef setExchangeFormula(address _newExchangeformula): # not payable\n  require owner == caller\n  require ext_code.size(_newExchangeformula)\n  call _newExchangeformula.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  require ext_code.size(_newExchangeformula)\n  call _newExchangeformula.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  exchangeFormulaAddress = _newExchangeformula\n  exchangeIsRunning = 0\n  return 1\n\ndef updateExchangeStatus(bool _isRunning): # not payable\n  require owner == caller\n  if _isRunning:\n      require ext_code.size(exchangeFormulaAddress)\n      call exchangeFormulaAddress.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n           gas gas_remaining - 710 wei\n          args 0, uint32(stor2), reserveBalance, 15, 10^18\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      require ext_code.size(exchangeFormulaAddress)\n      call exchangeFormulaAddress.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n           gas gas_remaining - 710 wei\n          args 0, uint32(stor2), reserveBalance, 15, 10^18\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n  stor21 = Mask(96, 0, _isRunning)\n  return 1\n\ndef finalizeOpenSale(): # not payable\n  require owner == caller\n  require not openSaleCompleted\n  require uint256(totalTokens) >= 50000000 * 10^18\n  openSaleCompleted = 1\n  end_block = block.number\n  if uint256(totalTokens):\n      require uint256(totalTokens)\n      require 15 * uint256(totalTokens) / uint256(totalTokens) == 15\n  require 15 * uint256(totalTokens) == (100000 * 15 * uint256(totalTokens) / 100000) + (15 * uint256(totalTokens) % 100000)\n  reserveBalance = 15 * uint256(totalTokens) / 100000\n  require 15 * uint256(totalTokens) / 100000 <= eth.balance(this.address)\n  call caller with:\n     value eth.balance(this.address) - (15 * uint256(totalTokens) / 100000) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  if balanceOf[address(sender)] < amount:\n      return 0\n  if allowance[address(sender)][caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount + balanceOf[address(recipient)] >= balanceOf[address(recipient)]\n  require amount + balanceOf[address(recipient)] >= amount\n  balanceOf[address(recipient)] += amount\n  require amount <= balanceOf[sender]\n  balanceOf[address(sender)] = balanceOf[sender] - amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log 0xddf252ad: amount, sender, recipient\n  return 1\n\ndef finalize() payable: \n  require wolkSaleAddress == caller\n  require openSaleCompleted\n  require not allSaleCompleted\n  if call.value:\n      require call.value\n      require 100000 * call.value / call.value == 100000\n  require 100000 * call.value == (15 * 100000 * call.value / 15) + (100000 * call.value % 15)\n  require (100000 * call.value / 15) + uint256(totalTokens) >= uint256(totalTokens)\n  require (100000 * call.value / 15) + uint256(totalTokens) >= 100000 * call.value / 15\n  uint256(totalTokens) += 100000 * call.value / 15\n  require call.value + reserveBalance >= reserveBalance\n  require call.value + reserveBalance >= call.value\n  reserveBalance += call.value\n  log 0xddf252ad: (100000 * call.value / 15), this.address, wolkSaleAddress\n  require (100000 * call.value / 15) + balanceOf[stor8] >= balanceOf[stor8]\n  require (100000 * call.value / 15) + balanceOf[stor8] >= 100000 * call.value / 15\n  balanceOf[stor8] += 100000 * call.value / 15\n  log 0x7ff6ea1c: (100000 * call.value / 15), wolkSaleAddress\n  allSaleCompleted = 1\n\ndef purchaseWolk(address _buyer) payable: \n  require exchangeIsRunning\n  require allSaleCompleted\n  require call.value > 0\n  require ext_code.size(exchangeFormulaAddress)\n  call exchangeFormulaAddress.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, call.value\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  require ext_call.return_data[0] + uint256(totalTokens) >= uint256(totalTokens)\n  require ext_call.return_data[0] + uint256(totalTokens) >= ext_call.return_data[0]\n  uint256(totalTokens) += ext_call.return_data[0]\n  require ext_call.return_data[0] + balanceOf[address(_buyer)] >= balanceOf[address(_buyer)]\n  require ext_call.return_data[0] + balanceOf[address(_buyer)] >= ext_call.return_data[0]\n  balanceOf[address(_buyer)] += ext_call.return_data[0]\n  require call.value + reserveBalance >= reserveBalance\n  require call.value + reserveBalance >= call.value\n  reserveBalance += call.value\n  log 0x7ff6ea1c: ext_call.return_data[0], _buyer\n  log 0xddf252ad: ext_call.return_data[0], this.address, _buyer\n  return ext_call.return_data[0]\n\ndef addParticipant(address[] _presaleParticipants, uint256[] _contributionLimits): # not payable\n  mem[128 len 32 * _presaleParticipants.length] = call.data[_presaleParticipants + 36 len 32 * _presaleParticipants.length]\n  mem[(32 * _presaleParticipants.length) + 128] = _contributionLimits.length\n  mem[(32 * _presaleParticipants.length) + 160 len 32 * _contributionLimits.length] = call.data[_contributionLimits + 36 len 32 * _contributionLimits.length]\n  require owner == caller\n  require _presaleParticipants.length == _contributionLimits.length\n  idx = 0\n  while idx < _presaleParticipants.length:\n      require idx < _presaleParticipants.length\n      stor16[mem[(32 * idx) + 140 len 20]] = 1\n      require idx < _contributionLimits.length\n      if mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]:\n          require mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]\n          require 10^18 * mem[(32 * idx) + (32 * _presaleParticipants.length) + 160] / mem[(32 * idx) + (32 * _presaleParticipants.length) + 160] == 10^18\n      require idx < _presaleParticipants.length\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 15\n      participantBalance[mem[(32 * idx) + 140 len 20]] = 10^18 * mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]\n      idx = idx + 1\n      continue \n  return 1\n\ndef sellWolk(uint256 _wolkAmount): # not payable\n  require exchangeIsRunning\n  require allSaleCompleted\n  if not openSaleCompleted:\n      require balanceOf[caller] >= _wolkAmount\n      require 0 >= _wolkAmount\n  else:\n      if uint256(totalTokens):\n          require uint256(totalTokens)\n          require maxPerExchangeBP * uint256(totalTokens) / uint256(totalTokens) == maxPerExchangeBP\n      require maxPerExchangeBP * uint256(totalTokens) == (10000 * maxPerExchangeBP * uint256(totalTokens) / 10000) + (maxPerExchangeBP * uint256(totalTokens) % 10000)\n      require balanceOf[caller] >= _wolkAmount\n      if maxPerExchangeBP * uint256(totalTokens) / 10000 >= 100 * 10^18:\n          require maxPerExchangeBP * uint256(totalTokens) / 10000 >= _wolkAmount\n      else:\n          require 100 * 10^18 >= _wolkAmount\n  require ext_code.size(exchangeFormulaAddress)\n  call exchangeFormulaAddress.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, _wolkAmount\n  require ext_call.success\n  require eth.balance(this.address) > ext_call.return_data[0]\n  require _wolkAmount <= balanceOf[caller]\n  balanceOf[caller] -= _wolkAmount\n  require _wolkAmount <= uint256(totalTokens)\n  uint256(totalTokens) -= _wolkAmount\n  require ext_call.return_data[0] <= eth.balance(this.address)\n  reserveBalance = eth.balance(this.address) - ext_call.return_data[0]\n  log 0xf505eb6e: _wolkAmount, caller\n  log 0xddf252ad: _wolkAmount, caller, 0\n  call caller with:\n     value ext_call.return_data[0] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  return ext_call.return_data[0]\n\ndef settleSeller(address _seller, uint256 _value): # not payable\n  require 1 == bool(stor7[caller])\n  require uint8(stor9.field_160)\n  require checkServiceFee[caller] > 0\n  require checkServiceFee[caller] <= 4000\n  require _value > 0\n  if not checkFeeSchedule[caller]:\n      if _value:\n          require _value\n          require checkServiceFee[caller] * _value / _value == checkServiceFee[caller]\n      require checkServiceFee[caller] * _value == (10000 * checkServiceFee[caller] * _value / 10000) + (checkServiceFee[caller] * _value % 10000)\n      require checkServiceFee[caller] * _value / 10000 <= _value\n      require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n      require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n      require balanceOf[address(_seller)] >= 0\n      balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n      log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n  else:\n      require ext_code.size(checkFeeSchedule[caller])\n      call checkFeeSchedule[caller].0x3e81d56e with:\n           gas gas_remaining - 710 wei\n          args _value\n      require ext_call.success\n      if _value:\n          require _value\n          require checkServiceFee[caller] * _value / _value == checkServiceFee[caller]\n      require checkServiceFee[caller] * _value == (10000 * checkServiceFee[caller] * _value / 10000) + (checkServiceFee[caller] * _value % 10000)\n      if ext_call.return_data[0] >= 1:\n          if ext_call.return_data[0] <= checkServiceFee[caller] * _value / 10000:\n              require ext_call.return_data[0] <= _value\n              require balanceOf[caller] >= _value - ext_call.return_data[0]\n              require _value - ext_call.return_data[0] + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n              require balanceOf[address(_seller)] >= 0\n              balanceOf[address(_seller)] = _value - ext_call.return_data[0] + balanceOf[address(_seller)]\n              log 0xddf252ad: (_value - ext_call.return_data[0]), caller, _seller\n          else:\n              require checkServiceFee[caller] * _value / 10000 <= _value\n              require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n              require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n              require balanceOf[address(_seller)] >= 0\n              balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n              log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n      else:\n          require checkServiceFee[caller] * _value / 10000 <= _value\n          require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n          require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n          require balanceOf[address(_seller)] >= 0\n          balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n          log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n  return 1\n\ndef settleBuyer(address _buyer, uint256 _value): # not payable\n  require 1 == bool(stor7[caller])\n  require uint8(stor9.field_160)\n  require burnBasisPoints > 0\n  require burnBasisPoints <= 1000\n  require stor11[address(_buyer)][caller]\n  require balanceOf[address(_buyer)] >= _value\n  require _value > 0\n  if not burnFormulaAddress:\n      if _value:\n          require _value\n          require burnBasisPoints * _value / _value == burnBasisPoints\n      require burnBasisPoints * _value == (10000 * burnBasisPoints * _value / 10000) + (burnBasisPoints * _value % 10000)\n      require burnBasisPoints * _value / 10000 <= _value\n      require _value <= balanceOf[address(_buyer)]\n      balanceOf[address(_buyer)] -= _value\n      require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n      require balanceOf[caller] >= 0\n      balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n      require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n      uint256(totalTokens) -= burnBasisPoints * _value / 10000\n      log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n      log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n      log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n  else:\n      require ext_code.size(burnFormulaAddress)\n      call burnFormulaAddress.0x926f949e with:\n           gas gas_remaining - 710 wei\n          args _value\n      require ext_call.success\n      if _value:\n          require _value\n          require burnBasisPoints * _value / _value == burnBasisPoints\n      require burnBasisPoints * _value == (10000 * burnBasisPoints * _value / 10000) + (burnBasisPoints * _value % 10000)\n      if ext_call.return_data[0] >= 1:\n          if ext_call.return_data[0] <= burnBasisPoints * _value / 10000:\n              require ext_call.return_data[0] <= _value\n              require _value <= balanceOf[address(_buyer)]\n              balanceOf[address(_buyer)] -= _value\n              require _value - ext_call.return_data[0] + balanceOf[caller] >= balanceOf[caller]\n              require balanceOf[caller] >= 0\n              balanceOf[caller] = _value - ext_call.return_data[0] + balanceOf[caller]\n              require ext_call.return_data[0] <= uint256(totalTokens)\n              uint256(totalTokens) -= ext_call.return_data[0]\n              log 0xddf252ad: (_value - ext_call.return_data[0]), _buyer, caller\n              log 0xddf252ad: ext_call.return_data[0], _buyer, 0\n              log 0xa02fa7af: ext_call.return_data[0], _buyer, caller\n          else:\n              require burnBasisPoints * _value / 10000 <= _value\n              require _value <= balanceOf[address(_buyer)]\n              balanceOf[address(_buyer)] -= _value\n              require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n              require balanceOf[caller] >= 0\n              balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n              require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n              uint256(totalTokens) -= burnBasisPoints * _value / 10000\n              log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n              log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n              log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n      else:\n          require burnBasisPoints * _value / 10000 <= _value\n          require _value <= balanceOf[address(_buyer)]\n          balanceOf[address(_buyer)] -= _value\n          require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n          require balanceOf[caller] >= 0\n          balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n          require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n          uint256(totalTokens) -= burnBasisPoints * _value / 10000\n          log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n          log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n          log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n  return 1\n\ndef tokenGenerationEvent(address _participant) payable: \n  require stor16[address(_participant)]\n  require not openSaleCompleted\n  require not allSaleCompleted\n  require block.number <= end_block\n  require call.value > 0\n  if block.number < start_block:\n      if block.number < presale_start_block:\n          require block.number >= start_block\n      else:\n          require participantBalance[address(_participant)] >= call.value\n          require call.value <= participantBalance[address(_participant)]\n          participantBalance[address(_participant)] -= call.value\n  if uint256(totalTokens) < 50000000 * 10^18:\n      if call.value:\n          require call.value\n          require 1177 * call.value / call.value == 1177\n      require (1177 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n      require (1177 * call.value) + uint256(totalTokens) >= 1177 * call.value\n      require (1177 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n      uint256(totalTokens) += 1177 * call.value\n      log 0xddf252ad: (1177 * call.value), this.address, _participant\n      require (1177 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n      require (1177 * call.value) + balanceOf[address(_participant)] >= 1177 * call.value\n      balanceOf[address(_participant)] += 1177 * call.value\n      require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n      require call.value + stor14[address(_participant)] >= call.value\n      stor14[address(_participant)] += call.value\n      log 0x7ff6ea1c: (1177 * call.value), _participant\n  else:\n      if uint256(totalTokens) < 60000000 * 10^18:\n          if call.value:\n              require call.value\n              require 1143 * call.value / call.value == 1143\n          require (1143 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n          require (1143 * call.value) + uint256(totalTokens) >= 1143 * call.value\n          require (1143 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n          uint256(totalTokens) += 1143 * call.value\n          log 0xddf252ad: (1143 * call.value), this.address, _participant\n          require (1143 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n          require (1143 * call.value) + balanceOf[address(_participant)] >= 1143 * call.value\n          balanceOf[address(_participant)] += 1143 * call.value\n          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n          require call.value + stor14[address(_participant)] >= call.value\n          stor14[address(_participant)] += call.value\n          log 0x7ff6ea1c: (1143 * call.value), _participant\n      else:\n          if uint256(totalTokens) < 70000000 * 10^18:\n              if call.value:\n                  require call.value\n                  require 1111 * call.value / call.value == 1111\n              require (1111 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n              require (1111 * call.value) + uint256(totalTokens) >= 1111 * call.value\n              require (1111 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n              uint256(totalTokens) += 1111 * call.value\n              log 0xddf252ad: (1111 * call.value), this.address, _participant\n              require (1111 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n              require (1111 * call.value) + balanceOf[address(_participant)] >= 1111 * call.value\n              balanceOf[address(_participant)] += 1111 * call.value\n              require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n              require call.value + stor14[address(_participant)] >= call.value\n              stor14[address(_participant)] += call.value\n              log 0x7ff6ea1c: (1111 * call.value), _participant\n          else:\n              if uint256(totalTokens) < 80000000 * 10^18:\n                  if call.value:\n                      require call.value\n                      require 1081 * call.value / call.value == 1081\n                  require (1081 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                  require (1081 * call.value) + uint256(totalTokens) >= 1081 * call.value\n                  require (1081 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                  uint256(totalTokens) += 1081 * call.value\n                  log 0xddf252ad: (1081 * call.value), this.address, _participant\n                  require (1081 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                  require (1081 * call.value) + balanceOf[address(_participant)] >= 1081 * call.value\n                  balanceOf[address(_participant)] += 1081 * call.value\n                  require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                  require call.value + stor14[address(_participant)] >= call.value\n                  stor14[address(_participant)] += call.value\n                  log 0x7ff6ea1c: (1081 * call.value), _participant\n              else:\n                  if uint256(totalTokens) < 25000 * 10^18 * 3600:\n                      if call.value:\n                          require call.value\n                          require 1053 * call.value / call.value == 1053\n                      require (1053 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                      require (1053 * call.value) + uint256(totalTokens) >= 1053 * call.value\n                      require (1053 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                      uint256(totalTokens) += 1053 * call.value\n                      log 0xddf252ad: (1053 * call.value), this.address, _participant\n                      require (1053 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                      require (1053 * call.value) + balanceOf[address(_participant)] >= 1053 * call.value\n                      balanceOf[address(_participant)] += 1053 * call.value\n                      require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                      require call.value + stor14[address(_participant)] >= call.value\n                      stor14[address(_participant)] += call.value\n                      log 0x7ff6ea1c: (1053 * call.value), _participant\n                  else:\n                      if uint256(totalTokens) >= 100000000 * 10^18:\n                          if call.value:\n                              require call.value\n                              require 1000 * call.value / call.value == 1000\n                          require (1000 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                          require (1000 * call.value) + uint256(totalTokens) >= 1000 * call.value\n                          require (1000 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                          uint256(totalTokens) += 1000 * call.value\n                          log 0xddf252ad: (1000 * call.value), this.address, _participant\n                          require (1000 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                          require (1000 * call.value) + balanceOf[address(_participant)] >= 1000 * call.value\n                          balanceOf[address(_participant)] += 1000 * call.value\n                          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                          require call.value + stor14[address(_participant)] >= call.value\n                          stor14[address(_participant)] += call.value\n                          log 0x7ff6ea1c: (1000 * call.value), _participant\n                      else:\n                          if call.value:\n                              require call.value\n                              require 1026 * call.value / call.value == 1026\n                          require (1026 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                          require (1026 * call.value) + uint256(totalTokens) >= 1026 * call.value\n                          require (1026 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                          uint256(totalTokens) += 1026 * call.value\n                          log 0xddf252ad: (1026 * call.value), this.address, _participant\n                          require (1026 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                          require (1026 * call.value) + balanceOf[address(_participant)] >= 1026 * call.value\n                          balanceOf[address(_participant)] += 1026 * call.value\n                          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                          require call.value + stor14[address(_participant)] >= call.value\n                          stor14[address(_participant)] += call.value\n                          log 0x7ff6ea1c: (1026 * call.value), _participant\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'Wolk Protocol Token'\nconst decimals = 18\nconst tokenGenerationMin = 50000000 * 10^18\nconst percentageETHReserve = 15\nconst symbol = 'WOLK'\nconst tokenGenerationMax = 150000000 * 10^18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  allowance is mapping of uint256 at storage 1\n  stor2 is uint32 at storage 2\n  totalTokens is uint256 at storage 2\n  owner is address at storage 3\n  newOwner is address at storage 4\n  reserveBalance is uint256 at storage 5\n  multisigWalletAddress is address at storage 6\n  stor7 is mapping of uint8 at storage 7\n  allSaleCompleted is uint8 at storage 8 offset 160\n  openSaleCompleted is uint8 at storage 8 offset 168\n  wolkSaleAddress is address at storage 8\n  stor9 is uint8 at storage 9 offset 160\n  stor9 is uint128 at storage 9 offset 160\n  burnFormulaAddress is address at storage 9\n  burnBasisPoints is uint256 at storage 10\n  stor11 is mapping of uint8 at storage 11\n  checkServiceFee is mapping of uint256 at storage 12\n  checkFeeSchedule is mapping of address at storage 13\n  stor14 is mapping of uint256 at storage 14\n  participantBalance is mapping of uint256 at storage 15\n  stor16 is mapping of uint8 at storage 16\n  presale_start_block is uint256 at storage 17\n  start_block is uint256 at storage 18\n  end_block is uint256 at storage 19\n  maxPerExchangeBP is uint256 at storage 20\n  exchangeIsRunning is uint8 at storage 21 offset 160\n  stor21 is uint128 at storage 21 offset 160\n  exchangeFormulaAddress is address at storage 21\n\ndef totalSupply(): # not payable\n  return uint256(totalTokens)\n\ndef exchangeFormula(): # not payable\n  return exchangeFormulaAddress\n\ndef exchangeIsRunning(): # not payable\n  return bool(exchangeIsRunning)\n\ndef end_block(): # not payable\n  return end_block\n\ndef checkAuthorization(address _owner, address _serviceProvider): # not payable\n  return bool(stor11[address(_owner)][address(_serviceProvider)])\n\ndef checkServiceFee(address _serviceProvider): # not payable\n  return checkServiceFee[address(_serviceProvider)]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef maxPerExchangeBP(): # not payable\n  return maxPerExchangeBP\n\ndef totalTokens(): # not payable\n  return uint256(totalTokens)\n\ndef burnFormula(): # not payable\n  return burnFormulaAddress\n\ndef participantBalance(address _participant): # not payable\n  return participantBalance[address(_participant)]\n\ndef owner(): # not payable\n  return owner\n\ndef multisigWallet(): # not payable\n  return multisigWalletAddress\n\ndef burnBasisPoints(): # not payable\n  return burnBasisPoints\n\ndef reserveBalance(): # not payable\n  return reserveBalance\n\ndef settlementIsRunning(): # not payable\n  return bool(uint8(stor9.field_160))\n\ndef start_block(): # not payable\n  return start_block\n\ndef openSaleCompleted(): # not payable\n  return bool(openSaleCompleted)\n\ndef presale_start_block(): # not payable\n  return presale_start_block\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\ndef allSaleCompleted(): # not payable\n  return bool(allSaleCompleted)\n\ndef wolkSale(): # not payable\n  return wolkSaleAddress\n\ndef checkFeeSchedule(address _serviceProvider): # not payable\n  return checkFeeSchedule[address(_serviceProvider)]\n\n#\n#  Regular functions\n#\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log 0x34376542: owner, newOwner\n  owner = newOwner\n  newOwner = 0\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require owner != newOwner\n  newOwner = newOwner\n\ndef updateSettlementStatus(bool _isRunning): # not payable\n  require owner == caller\n  Mask(96, 0, stor9.field_160) = Mask(96, 0, _isRunning)\n  return 1\n\ndef setBurnRate(uint256 _burnRate): # not payable\n  require owner == caller\n  require _burnRate > 0\n  require _burnRate <= 1000\n  burnBasisPoints = _burnRate\n  return 1\n\ndef deauthorizeProvider(address _providerToRemove): # not payable\n  stor11[caller][address(_providerToRemove)] = 0\n  log 0x79485d41: _providerToRemove, caller\n  return 1\n\ndef setMaxPerExchange(uint256 _maxPerExchange): # not payable\n  require owner == caller\n  require _maxPerExchange >= 10\n  require _maxPerExchange <= 100\n  maxPerExchangeBP = _maxPerExchange\n  return 1\n\ndef authorizeProvider(address _providerToAdd): # not payable\n  require stor7[address(_providerToAdd)]\n  stor11[caller][address(_providerToAdd)] = 1\n  log 0x8563cf33: _providerToAdd, caller\n  return 1\n\ndef removeService(address _owner, address _providerToRemove): # not payable\n  require owner == caller\n  stor11[address(_owner)][address(_providerToRemove)] = 0\n  log 0x79485d41: _providerToRemove, _owner\n  return 1\n\ndef approve(address spender, uint256 amount): # not payable\n  if amount:\n      require not allowance[caller][address(spender)]\n  allowance[caller][address(spender)] = amount\n  log 0x8c5be1e5: amount, caller, spender\n  return 1\n\ndef setBurnFormula(address _newBurnFormula): # not payable\n  require owner == caller\n  require _newBurnFormula\n  require ext_code.size(_newBurnFormula)\n  call _newBurnFormula.0x926f949e with:\n       gas gas_remaining - 710 wei\n      args 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 5 * 10^13\n  burnFormulaAddress = _newBurnFormula\n  return 1\n\ndef grantService(address _owner, address _providerToAdd): # not payable\n  require owner == caller\n  if not stor11[address(_owner)][caller]:\n      return 0\n  if not stor7[address(_providerToAdd)]:\n      return 0\n  stor11[address(_owner)][address(_providerToAdd)] = 1\n  log 0x8563cf33: _providerToAdd, caller\n  return 1\n\ndef _fallback() payable: # default function\n  require call.value > 0\n  if not openSaleCompleted:\n      require ext_code.size(this.address)\n      call this.address.tokenGenerationEvent(address participant) with:\n         value call.value wei\n           gas gas_remaining - 9710 wei\n          args caller\n  else:\n      require block.number >= end_block\n      require ext_code.size(this.address)\n      call this.address.purchaseWolk(address buyer) with:\n         value call.value wei\n           gas gas_remaining - 9710 wei\n          args caller\n  require ext_call.success\n\ndef setFeeFormula(address _newFeeFormula): # not payable\n  require 1 == bool(stor7[caller])\n  require checkFeeSchedule[address(_newFeeFormula)]\n  require ext_code.size(checkFeeSchedule[address(_newFeeFormula)])\n  call checkFeeSchedule[address(_newFeeFormula)].0x3e81d56e with:\n       gas gas_remaining - 710 wei\n      args 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 5 * 10^13\n  checkFeeSchedule[caller] = _newFeeFormula\n  return 1\n\ndef wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale): # not payable\n  require owner == caller\n  require uint256(totalTokens) < 1\n  require block.number <= _startBlock\n  require _endBlock > _startBlock\n  require _startBlock > _presaleStartBlock\n  presale_start_block = _presaleStartBlock\n  start_block = _startBlock\n  end_block = _endBlock\n  multisigWalletAddress = _wolkWallet\n  wolkSaleAddress = _wolkSale\n  stor7[caller] = 1\n  return 1\n\ndef setServiceFee(address _user, uint256 _fee): # not payable\n  require owner == caller\n  if _fee <= 0:\n      stor7[address(_user)] = 0\n      checkServiceFee[address(_user)] = 0\n      return 0\n  if _fee > 4000:\n      stor7[address(_user)] = 0\n      checkServiceFee[address(_user)] = 0\n      return 0\n  checkServiceFee[address(_user)] = _fee\n  stor7[address(_user)] = 1\n  log 0xe273f117: _fee, _user\n  return 1\n\ndef transfer(address recipient, uint256 amount): # not payable\n  if balanceOf[caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  require amount + balanceOf[recipient] >= amount\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log 0xddf252ad: amount, caller, recipient\n  return 1\n\ndef refund(): # not payable\n  require stor14[caller] > 0\n  require not allSaleCompleted\n  require uint256(totalTokens) < 50000000 * 10^18\n  require block.number > end_block\n  balanceOf[caller] = 0\n  stor14[caller] = 0\n  require balanceOf[caller] <= uint256(totalTokens)\n  uint256(totalTokens) -= balanceOf[caller]\n  log 0xf505eb6e: balanceOf[caller], caller\n  log 0xb6c0eca8: stor14[caller], caller\n  call caller with:\n     value stor14[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef removeParticipant(address[] _presaleParticipants): # not payable\n  mem[128 len 32 * _presaleParticipants.length] = call.data[_presaleParticipants + 36 len 32 * _presaleParticipants.length]\n  require owner == caller\n  idx = 0\n  while idx < _presaleParticipants.length:\n      require idx < _presaleParticipants.length\n      stor16[mem[(32 * idx) + 140 len 20]] = 0\n      require idx < _presaleParticipants.length\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 15\n      participantBalance[mem[(32 * idx) + 140 len 20]] = 0\n      idx = idx + 1\n      continue \n  return 1\n\ndef estLiquidationCap(): # not payable\n  if not openSaleCompleted:\n      return 0\n  if uint256(totalTokens):\n      require uint256(totalTokens)\n      require maxPerExchangeBP * uint256(totalTokens) / uint256(totalTokens) == maxPerExchangeBP\n  require maxPerExchangeBP * uint256(totalTokens) == (10000 * maxPerExchangeBP * uint256(totalTokens) / 10000) + (maxPerExchangeBP * uint256(totalTokens) % 10000)\n  if maxPerExchangeBP * uint256(totalTokens) / 10000 >= 100 * 10^18:\n      return (maxPerExchangeBP * uint256(totalTokens) / 10000)\n  return 100 * 10^18\n\ndef setExchangeFormula(address _newExchangeformula): # not payable\n  require owner == caller\n  require ext_code.size(_newExchangeformula)\n  call _newExchangeformula.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  require ext_code.size(_newExchangeformula)\n  call _newExchangeformula.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, 10^18\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  exchangeFormulaAddress = _newExchangeformula\n  exchangeIsRunning = 0\n  return 1\n\ndef updateExchangeStatus(bool _isRunning): # not payable\n  require owner == caller\n  if _isRunning:\n      require ext_code.size(exchangeFormulaAddress)\n      call exchangeFormulaAddress.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n           gas gas_remaining - 710 wei\n          args 0, uint32(stor2), reserveBalance, 15, 10^18\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      require ext_code.size(exchangeFormulaAddress)\n      call exchangeFormulaAddress.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n           gas gas_remaining - 710 wei\n          args 0, uint32(stor2), reserveBalance, 15, 10^18\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n  stor21 = Mask(96, 0, _isRunning)\n  return 1\n\ndef finalizeOpenSale(): # not payable\n  require owner == caller\n  require not openSaleCompleted\n  require uint256(totalTokens) >= 50000000 * 10^18\n  openSaleCompleted = 1\n  end_block = block.number\n  if uint256(totalTokens):\n      require uint256(totalTokens)\n      require 15 * uint256(totalTokens) / uint256(totalTokens) == 15\n  require 15 * uint256(totalTokens) == (100000 * 15 * uint256(totalTokens) / 100000) + (15 * uint256(totalTokens) % 100000)\n  reserveBalance = 15 * uint256(totalTokens) / 100000\n  require 15 * uint256(totalTokens) / 100000 <= eth.balance(this.address)\n  call caller with:\n     value eth.balance(this.address) - (15 * uint256(totalTokens) / 100000) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  if balanceOf[address(sender)] < amount:\n      return 0\n  if allowance[address(sender)][caller] < amount:\n      return 0\n  if amount <= 0:\n      return 0\n  require amount + balanceOf[address(recipient)] >= balanceOf[address(recipient)]\n  require amount + balanceOf[address(recipient)] >= amount\n  balanceOf[address(recipient)] += amount\n  require amount <= balanceOf[sender]\n  balanceOf[address(sender)] = balanceOf[sender] - amount\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log 0xddf252ad: amount, sender, recipient\n  return 1\n\ndef finalize() payable: \n  require wolkSaleAddress == caller\n  require openSaleCompleted\n  require not allSaleCompleted\n  if call.value:\n      require call.value\n      require 100000 * call.value / call.value == 100000\n  require 100000 * call.value == (15 * 100000 * call.value / 15) + (100000 * call.value % 15)\n  require (100000 * call.value / 15) + uint256(totalTokens) >= uint256(totalTokens)\n  require (100000 * call.value / 15) + uint256(totalTokens) >= 100000 * call.value / 15\n  uint256(totalTokens) += 100000 * call.value / 15\n  require call.value + reserveBalance >= reserveBalance\n  require call.value + reserveBalance >= call.value\n  reserveBalance += call.value\n  log 0xddf252ad: (100000 * call.value / 15), this.address, wolkSaleAddress\n  require (100000 * call.value / 15) + balanceOf[stor8] >= balanceOf[stor8]\n  require (100000 * call.value / 15) + balanceOf[stor8] >= 100000 * call.value / 15\n  balanceOf[stor8] += 100000 * call.value / 15\n  log 0x7ff6ea1c: (100000 * call.value / 15), wolkSaleAddress\n  allSaleCompleted = 1\n\ndef purchaseWolk(address _buyer) payable: \n  require exchangeIsRunning\n  require allSaleCompleted\n  require call.value > 0\n  require ext_code.size(exchangeFormulaAddress)\n  call exchangeFormulaAddress.calculatePurchaseReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 depositAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, call.value\n  require ext_call.success\n  require ext_call.return_data[0] > 0\n  require ext_call.return_data[0] + uint256(totalTokens) >= uint256(totalTokens)\n  require ext_call.return_data[0] + uint256(totalTokens) >= ext_call.return_data[0]\n  uint256(totalTokens) += ext_call.return_data[0]\n  require ext_call.return_data[0] + balanceOf[address(_buyer)] >= balanceOf[address(_buyer)]\n  require ext_call.return_data[0] + balanceOf[address(_buyer)] >= ext_call.return_data[0]\n  balanceOf[address(_buyer)] += ext_call.return_data[0]\n  require call.value + reserveBalance >= reserveBalance\n  require call.value + reserveBalance >= call.value\n  reserveBalance += call.value\n  log 0x7ff6ea1c: ext_call.return_data[0], _buyer\n  log 0xddf252ad: ext_call.return_data[0], this.address, _buyer\n  return ext_call.return_data[0]\n\ndef addParticipant(address[] _presaleParticipants, uint256[] _contributionLimits): # not payable\n  mem[128 len 32 * _presaleParticipants.length] = call.data[_presaleParticipants + 36 len 32 * _presaleParticipants.length]\n  mem[(32 * _presaleParticipants.length) + 128] = _contributionLimits.length\n  mem[(32 * _presaleParticipants.length) + 160 len 32 * _contributionLimits.length] = call.data[_contributionLimits + 36 len 32 * _contributionLimits.length]\n  require owner == caller\n  require _presaleParticipants.length == _contributionLimits.length\n  idx = 0\n  while idx < _presaleParticipants.length:\n      require idx < _presaleParticipants.length\n      stor16[mem[(32 * idx) + 140 len 20]] = 1\n      require idx < _contributionLimits.length\n      if mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]:\n          require mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]\n          require 10^18 * mem[(32 * idx) + (32 * _presaleParticipants.length) + 160] / mem[(32 * idx) + (32 * _presaleParticipants.length) + 160] == 10^18\n      require idx < _presaleParticipants.length\n      mem[0] = mem[(32 * idx) + 140 len 20]\n      mem[32] = 15\n      participantBalance[mem[(32 * idx) + 140 len 20]] = 10^18 * mem[(32 * idx) + (32 * _presaleParticipants.length) + 160]\n      idx = idx + 1\n      continue \n  return 1\n\ndef sellWolk(uint256 _wolkAmount): # not payable\n  require exchangeIsRunning\n  require allSaleCompleted\n  if not openSaleCompleted:\n      require balanceOf[caller] >= _wolkAmount\n      require 0 >= _wolkAmount\n  else:\n      if uint256(totalTokens):\n          require uint256(totalTokens)\n          require maxPerExchangeBP * uint256(totalTokens) / uint256(totalTokens) == maxPerExchangeBP\n      require maxPerExchangeBP * uint256(totalTokens) == (10000 * maxPerExchangeBP * uint256(totalTokens) / 10000) + (maxPerExchangeBP * uint256(totalTokens) % 10000)\n      require balanceOf[caller] >= _wolkAmount\n      if maxPerExchangeBP * uint256(totalTokens) / 10000 >= 100 * 10^18:\n          require maxPerExchangeBP * uint256(totalTokens) / 10000 >= _wolkAmount\n      else:\n          require 100 * 10^18 >= _wolkAmount\n  require ext_code.size(exchangeFormulaAddress)\n  call exchangeFormulaAddress.calculateSaleReturn(uint256 supply, uint256 reserveBalance, uint8 reserveRatio, uint256 sellAmount) with:\n       gas gas_remaining - 710 wei\n      args 0, uint32(stor2), reserveBalance, 15, _wolkAmount\n  require ext_call.success\n  require eth.balance(this.address) > ext_call.return_data[0]\n  require _wolkAmount <= balanceOf[caller]\n  balanceOf[caller] -= _wolkAmount\n  require _wolkAmount <= uint256(totalTokens)\n  uint256(totalTokens) -= _wolkAmount\n  require ext_call.return_data[0] <= eth.balance(this.address)\n  reserveBalance = eth.balance(this.address) - ext_call.return_data[0]\n  log 0xf505eb6e: _wolkAmount, caller\n  log 0xddf252ad: _wolkAmount, caller, 0\n  call caller with:\n     value ext_call.return_data[0] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  return ext_call.return_data[0]\n\ndef settleSeller(address _seller, uint256 _value): # not payable\n  require 1 == bool(stor7[caller])\n  require uint8(stor9.field_160)\n  require checkServiceFee[caller] > 0\n  require checkServiceFee[caller] <= 4000\n  require _value > 0\n  if not checkFeeSchedule[caller]:\n      if _value:\n          require _value\n          require checkServiceFee[caller] * _value / _value == checkServiceFee[caller]\n      require checkServiceFee[caller] * _value == (10000 * checkServiceFee[caller] * _value / 10000) + (checkServiceFee[caller] * _value % 10000)\n      require checkServiceFee[caller] * _value / 10000 <= _value\n      require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n      require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n      require balanceOf[address(_seller)] >= 0\n      balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n      log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n  else:\n      require ext_code.size(checkFeeSchedule[caller])\n      call checkFeeSchedule[caller].0x3e81d56e with:\n           gas gas_remaining - 710 wei\n          args _value\n      require ext_call.success\n      if _value:\n          require _value\n          require checkServiceFee[caller] * _value / _value == checkServiceFee[caller]\n      require checkServiceFee[caller] * _value == (10000 * checkServiceFee[caller] * _value / 10000) + (checkServiceFee[caller] * _value % 10000)\n      if ext_call.return_data[0] >= 1:\n          if ext_call.return_data[0] <= checkServiceFee[caller] * _value / 10000:\n              require ext_call.return_data[0] <= _value\n              require balanceOf[caller] >= _value - ext_call.return_data[0]\n              require _value - ext_call.return_data[0] + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n              require balanceOf[address(_seller)] >= 0\n              balanceOf[address(_seller)] = _value - ext_call.return_data[0] + balanceOf[address(_seller)]\n              log 0xddf252ad: (_value - ext_call.return_data[0]), caller, _seller\n          else:\n              require checkServiceFee[caller] * _value / 10000 <= _value\n              require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n              require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n              require balanceOf[address(_seller)] >= 0\n              balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n              log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n      else:\n          require checkServiceFee[caller] * _value / 10000 <= _value\n          require balanceOf[caller] >= _value - (checkServiceFee[caller] * _value / 10000)\n          require _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)] >= balanceOf[address(_seller)]\n          require balanceOf[address(_seller)] >= 0\n          balanceOf[address(_seller)] = _value - (checkServiceFee[caller] * _value / 10000) + balanceOf[address(_seller)]\n          log 0xddf252ad: (_value - (checkServiceFee[caller] * _value / 10000)), caller, _seller\n  return 1\n\ndef settleBuyer(address _buyer, uint256 _value): # not payable\n  require 1 == bool(stor7[caller])\n  require uint8(stor9.field_160)\n  require burnBasisPoints > 0\n  require burnBasisPoints <= 1000\n  require stor11[address(_buyer)][caller]\n  require balanceOf[address(_buyer)] >= _value\n  require _value > 0\n  if not burnFormulaAddress:\n      if _value:\n          require _value\n          require burnBasisPoints * _value / _value == burnBasisPoints\n      require burnBasisPoints * _value == (10000 * burnBasisPoints * _value / 10000) + (burnBasisPoints * _value % 10000)\n      require burnBasisPoints * _value / 10000 <= _value\n      require _value <= balanceOf[address(_buyer)]\n      balanceOf[address(_buyer)] -= _value\n      require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n      require balanceOf[caller] >= 0\n      balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n      require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n      uint256(totalTokens) -= burnBasisPoints * _value / 10000\n      log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n      log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n      log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n  else:\n      require ext_code.size(burnFormulaAddress)\n      call burnFormulaAddress.0x926f949e with:\n           gas gas_remaining - 710 wei\n          args _value\n      require ext_call.success\n      if _value:\n          require _value\n          require burnBasisPoints * _value / _value == burnBasisPoints\n      require burnBasisPoints * _value == (10000 * burnBasisPoints * _value / 10000) + (burnBasisPoints * _value % 10000)\n      if ext_call.return_data[0] >= 1:\n          if ext_call.return_data[0] <= burnBasisPoints * _value / 10000:\n              require ext_call.return_data[0] <= _value\n              require _value <= balanceOf[address(_buyer)]\n              balanceOf[address(_buyer)] -= _value\n              require _value - ext_call.return_data[0] + balanceOf[caller] >= balanceOf[caller]\n              require balanceOf[caller] >= 0\n              balanceOf[caller] = _value - ext_call.return_data[0] + balanceOf[caller]\n              require ext_call.return_data[0] <= uint256(totalTokens)\n              uint256(totalTokens) -= ext_call.return_data[0]\n              log 0xddf252ad: (_value - ext_call.return_data[0]), _buyer, caller\n              log 0xddf252ad: ext_call.return_data[0], _buyer, 0\n              log 0xa02fa7af: ext_call.return_data[0], _buyer, caller\n          else:\n              require burnBasisPoints * _value / 10000 <= _value\n              require _value <= balanceOf[address(_buyer)]\n              balanceOf[address(_buyer)] -= _value\n              require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n              require balanceOf[caller] >= 0\n              balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n              require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n              uint256(totalTokens) -= burnBasisPoints * _value / 10000\n              log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n              log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n              log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n      else:\n          require burnBasisPoints * _value / 10000 <= _value\n          require _value <= balanceOf[address(_buyer)]\n          balanceOf[address(_buyer)] -= _value\n          require _value - (burnBasisPoints * _value / 10000) + balanceOf[caller] >= balanceOf[caller]\n          require balanceOf[caller] >= 0\n          balanceOf[caller] = _value - (burnBasisPoints * _value / 10000) + balanceOf[caller]\n          require burnBasisPoints * _value / 10000 <= uint256(totalTokens)\n          uint256(totalTokens) -= burnBasisPoints * _value / 10000\n          log 0xddf252ad: (_value - (burnBasisPoints * _value / 10000)), _buyer, caller\n          log 0xddf252ad: (burnBasisPoints * _value / 10000), _buyer, 0\n          log 0xa02fa7af: (burnBasisPoints * _value / 10000), _buyer, caller\n  return 1\n\ndef tokenGenerationEvent(address _participant) payable: \n  require stor16[address(_participant)]\n  require not openSaleCompleted\n  require not allSaleCompleted\n  require block.number <= end_block\n  require call.value > 0\n  if block.number < start_block:\n      if block.number < presale_start_block:\n          require block.number >= start_block\n      else:\n          require participantBalance[address(_participant)] >= call.value\n          require call.value <= participantBalance[address(_participant)]\n          participantBalance[address(_participant)] -= call.value\n  if uint256(totalTokens) < 50000000 * 10^18:\n      if call.value:\n          require call.value\n          require 1177 * call.value / call.value == 1177\n      require (1177 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n      require (1177 * call.value) + uint256(totalTokens) >= 1177 * call.value\n      require (1177 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n      uint256(totalTokens) += 1177 * call.value\n      log 0xddf252ad: (1177 * call.value), this.address, _participant\n      require (1177 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n      require (1177 * call.value) + balanceOf[address(_participant)] >= 1177 * call.value\n      balanceOf[address(_participant)] += 1177 * call.value\n      require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n      require call.value + stor14[address(_participant)] >= call.value\n      stor14[address(_participant)] += call.value\n      log 0x7ff6ea1c: (1177 * call.value), _participant\n  else:\n      if uint256(totalTokens) < 60000000 * 10^18:\n          if call.value:\n              require call.value\n              require 1143 * call.value / call.value == 1143\n          require (1143 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n          require (1143 * call.value) + uint256(totalTokens) >= 1143 * call.value\n          require (1143 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n          uint256(totalTokens) += 1143 * call.value\n          log 0xddf252ad: (1143 * call.value), this.address, _participant\n          require (1143 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n          require (1143 * call.value) + balanceOf[address(_participant)] >= 1143 * call.value\n          balanceOf[address(_participant)] += 1143 * call.value\n          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n          require call.value + stor14[address(_participant)] >= call.value\n          stor14[address(_participant)] += call.value\n          log 0x7ff6ea1c: (1143 * call.value), _participant\n      else:\n          if uint256(totalTokens) < 70000000 * 10^18:\n              if call.value:\n                  require call.value\n                  require 1111 * call.value / call.value == 1111\n              require (1111 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n              require (1111 * call.value) + uint256(totalTokens) >= 1111 * call.value\n              require (1111 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n              uint256(totalTokens) += 1111 * call.value\n              log 0xddf252ad: (1111 * call.value), this.address, _participant\n              require (1111 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n              require (1111 * call.value) + balanceOf[address(_participant)] >= 1111 * call.value\n              balanceOf[address(_participant)] += 1111 * call.value\n              require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n              require call.value + stor14[address(_participant)] >= call.value\n              stor14[address(_participant)] += call.value\n              log 0x7ff6ea1c: (1111 * call.value), _participant\n          else:\n              if uint256(totalTokens) < 80000000 * 10^18:\n                  if call.value:\n                      require call.value\n                      require 1081 * call.value / call.value == 1081\n                  require (1081 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                  require (1081 * call.value) + uint256(totalTokens) >= 1081 * call.value\n                  require (1081 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                  uint256(totalTokens) += 1081 * call.value\n                  log 0xddf252ad: (1081 * call.value), this.address, _participant\n                  require (1081 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                  require (1081 * call.value) + balanceOf[address(_participant)] >= 1081 * call.value\n                  balanceOf[address(_participant)] += 1081 * call.value\n                  require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                  require call.value + stor14[address(_participant)] >= call.value\n                  stor14[address(_participant)] += call.value\n                  log 0x7ff6ea1c: (1081 * call.value), _participant\n              else:\n                  if uint256(totalTokens) < 25000 * 10^18 * 3600:\n                      if call.value:\n                          require call.value\n                          require 1053 * call.value / call.value == 1053\n                      require (1053 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                      require (1053 * call.value) + uint256(totalTokens) >= 1053 * call.value\n                      require (1053 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                      uint256(totalTokens) += 1053 * call.value\n                      log 0xddf252ad: (1053 * call.value), this.address, _participant\n                      require (1053 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                      require (1053 * call.value) + balanceOf[address(_participant)] >= 1053 * call.value\n                      balanceOf[address(_participant)] += 1053 * call.value\n                      require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                      require call.value + stor14[address(_participant)] >= call.value\n                      stor14[address(_participant)] += call.value\n                      log 0x7ff6ea1c: (1053 * call.value), _participant\n                  else:\n                      if uint256(totalTokens) >= 100000000 * 10^18:\n                          if call.value:\n                              require call.value\n                              require 1000 * call.value / call.value == 1000\n                          require (1000 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                          require (1000 * call.value) + uint256(totalTokens) >= 1000 * call.value\n                          require (1000 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                          uint256(totalTokens) += 1000 * call.value\n                          log 0xddf252ad: (1000 * call.value), this.address, _participant\n                          require (1000 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                          require (1000 * call.value) + balanceOf[address(_participant)] >= 1000 * call.value\n                          balanceOf[address(_participant)] += 1000 * call.value\n                          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                          require call.value + stor14[address(_participant)] >= call.value\n                          stor14[address(_participant)] += call.value\n                          log 0x7ff6ea1c: (1000 * call.value), _participant\n                      else:\n                          if call.value:\n                              require call.value\n                              require 1026 * call.value / call.value == 1026\n                          require (1026 * call.value) + uint256(totalTokens) >= uint256(totalTokens)\n                          require (1026 * call.value) + uint256(totalTokens) >= 1026 * call.value\n                          require (1026 * call.value) + uint256(totalTokens) <= 150000000 * 10^18\n                          uint256(totalTokens) += 1026 * call.value\n                          log 0xddf252ad: (1026 * call.value), this.address, _participant\n                          require (1026 * call.value) + balanceOf[address(_participant)] >= balanceOf[address(_participant)]\n                          require (1026 * call.value) + balanceOf[address(_participant)] >= 1026 * call.value\n                          balanceOf[address(_participant)] += 1026 * call.value\n                          require call.value + stor14[address(_participant)] >= stor14[address(_participant)]\n                          require call.value + stor14[address(_participant)] >= call.value\n                          stor14[address(_participant)] += call.value\n                          log 0x7ff6ea1c: (1026 * call.value), _participant\n\n.",
	"status": "1",
	"time_cost": 55.57390069961548,
	"usage": {
		"completion_tokens": 549,
		"prompt_tokens": 9393,
		"total_tokens": 9942
	}
}