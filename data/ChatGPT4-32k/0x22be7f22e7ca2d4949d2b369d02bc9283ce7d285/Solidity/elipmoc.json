{
	"address": "0x22be7f22e7ca2d4949d2b369d02bc9283ce7d285",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity version of the given decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping (uint256 => uint256) public map_5;\n    mapping (address => uint256) private _deposits;\n    mapping (address => uint256) private _totalDeposits;\n    address payable public _ethAddr;\n    address public _daiAddr;\n    address public _usdcAddr;\n    address public _registry;\n    address public _comptrollerAddr;\n    address public _adminOne;\n    address public _adminTwo;\n    address public _cEth;\n    address public _cDai;\n    address public _cUsdc;\n    \n    event LogWithdrawToken(address indexed token, address indexed from, uint256 amount);\n    event LogRedeemTknAndTransfer(address indexed token, address indexed from, uint256 amount);\n    event LogPayBorrowBack(address indexed token, address indexed from, uint256 amount);\n    event LogBorrowTknAndTransfer(address indexed token, address indexed from, uint256 amount);\n    event LogDepositCToken(address indexed token, uint256 amount);\n    event LogWithdrawCToken(address indexed token, uint256 amount);\n    event LogDepositToken(address indexed token, address indexed from, uint256 amount);\n    event LogMintTknBack(address indexed token, address indexed from, uint256 amount);\n\n    // The fallback function should be declared as external\n    function() external payable {}\n\n    function withdrawToken(address _token, address _from, uint256 _amount) public {\n        require(_deposits[_token] != 0, 'Nothing to Withdraw');\n        require(_from != address(0));\n        // Additional code goes here\n    }\n\n    function mintTknBack(address _token, address _from, uint256 _amount) public payable {\n        require(_from != address(0));\n        // Additional code goes here\n    }\n\n    function collectCTokens(address _token) public {\n        require(_token != address(0));\n        // Additional code goes here\n    }\n\n    function redeemTknAndTransfer(address _token, address _from, uint256 _amount) public {\n        require(_from != address(0));\n        // Additional code goes here\n    }\n\n    function payBorrowBack(address _token, address _from, uint256 _amount) public payable {\n        require(_from != address(0));\n        // Additional code goes here\n    }\n\n    function adminTwo() public view returns (address) {\n        return _adminTwo;\n    }\n\n    function comptrollerAddr() public view returns (address) {\n        return _comptrollerAddr;\n    }\n\n    function borrowTknAndTransfer(address _token, address _from, uint256 _amount) public {\n        require(_from != address(0));\n        // Additional code goes here\n    }\n\n    function depositCTkn(address _token, uint256 _amount) public payable {\n        require(_token != address(0));\n        // Additional code goes here\n    }\n\n    function setApproval(address _spender, uint256 _amount, address _token) public {\n        require(_spender != address(0));\n        // Additional code goes here\n    }\n\n    function collectTokens(address _token) public {\n        require(_token != address(0));\n        // Additional code goes here\n    }\n\n    function mintCollectedTkns(address _token, address _from, uint256 _amount) public payable {\n        require(_from != address(0));\n        // Additional code goes here\n    }\n\n    function daiAddr() public view returns (address) {\n        return _daiAddr;\n    }\n\n    function registry() public view returns (address) {\n        return _registry;\n    }\n\n    function enterMarket(address[] memory _tokens) public {\n        require(_tokens.length > 0);\n        // Additional code goes here\n    }\n\n    function withdrawCTkn(address _token, uint256 _amount) public {\n        require(_token != address(0));\n        // Additional code goes here\n    }\n\n    function deposits(address _token, address _from) public view returns (uint256) {\n        require(_from != address(0));\n        return _deposits[_token];\n    }\n\n    function usdcAddr() public view returns (address) {\n        return _usdcAddr;\n    }\n\n    function cDai() public view returns (address) {\n        return _cDai;\n    }\n\n    function cEth() public view returns (address) {\n        return _cEth;\n    }\n\n    function ethAddr() public view returns (address) {\n        return _ethAddr;\n    }\n\n    function cUsdc() public view returns (address) {\n        return _cUsdc;\n    }\n\n    function adminOne() public view returns (address) {\n        return _adminOne;\n    }\n\n    function totalDeposits(address _token) public view returns (uint256) {\n        return _totalDeposits[_token];\n    }\n\n    function exitMarket(address _token) public {\n        require(_token != address(0));\n        // Additional code goes here\n    }\n\n    function depositToken(address _token, address _from, uint256 _amount) public payable {\n        require(_token != address(0) && _from != address(0));\n        // Additional code goes here\n    }\n}\n```\n\nPlease note that I've only converted the provided decompiled code to Solidity. Some function bodies say \"Additional code goes here\". Actual code in these functions would depend on the logic of your contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468318,
	"id": "chatcmpl-8R5vKSHwKYytLhGSqSAf3zA4fxX6X",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 16:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) map_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _deposits; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _totalDeposits; // STORAGE[0xc]\nuint160 _ethAddr; // STORAGE[0x0] bytes 0 to 19\nuint160 _daiAddr; // STORAGE[0x1] bytes 0 to 19\nuint160 _usdcAddr; // STORAGE[0x2] bytes 0 to 19\naddress _registry; // STORAGE[0x3] bytes 0 to 19\naddress _comptrollerAddr; // STORAGE[0x4] bytes 0 to 19\naddress _adminOne; // STORAGE[0x6] bytes 0 to 19\naddress _adminTwo; // STORAGE[0x7] bytes 0 to 19\nuint160 _cEth; // STORAGE[0x8] bytes 0 to 19\nuint160 _cDai; // STORAGE[0x9] bytes 0 to 19\nuint160 _cUsdc; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nLogWithdrawToken(address, address, uint256);\nLogRedeemTknAndTransfer(address, address, uint256);\nLogPayBorrowBack(address, address, uint256);\nLogBorrowTknAndTransfer(address, address, uint256);\nLogDepositCToken(address, uint256);\nLogWithdrawCToken(address, uint256);\nLogDepositToken(address, address, uint256);\nLogMintTknBack(address, address, uint256);\n\nfunction fallback() public payable { \n}\n\nfunction withdrawToken(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(_deposits[varg1] != 0, 'Nothing to Withdraw');\n    require(varg1.code.size);\n    v0, v1 = varg1.exchangeRateCurrent().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0x5198(v1, varg2);\n    if (v3 > _deposits[varg1]) {\n        v2 = v4 = _deposits[varg1] - 1;\n        v5 = v6 = 0x51d0(v1, v4);\n    }\n    if (varg0 == _ethAddr) {\n        require(varg1.code.size);\n        v7, v8 = varg1.redeemUnderlying(v5).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v8 == 0, 'something went wrong');\n        assert((address(this)).balance != (address(this)).balance);\n        v9 = msg.sender.call().value(v5).gas(!v5 * 2300);\n        require(v9); // checks call status, propagates error data on error\n    } else {\n        require(varg0.code.size);\n        v10, v11 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg1.code.size);\n        v12, v13 = varg1.redeemUnderlying(v5).gas(msg.gas);\n        require(v12); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v13 == 0, 'something went wrong');\n        require(varg0.code.size);\n        v14, v15 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v14); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v11 != v15);\n        require(varg0.code.size);\n        v16, v17 = varg0.transfer(msg.sender, v5).gas(msg.gas);\n        require(v16); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v17, 'not enough tkn to Transfer');\n    }\n    _deposits[varg1] = _deposits[varg1] - v2;\n    _totalDeposits[varg1] = _totalDeposits[varg1] - v2;\n    emit LogWithdrawToken(varg0, varg1, v5);\n}\n\nfunction mintTknBack(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    0x5210(varg2, varg1, varg0);\n}\n\nfunction collectCTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(varg0.code.size);\n    v3, v4 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_totalDeposits[varg0] <= v4, 'SafeMath: subtraction overflow');\n    require(varg0.code.size);\n    v5, v6 = varg0.transfer(msg.sender, v4 - _totalDeposits[varg0]).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'CToken Transfer failed');\n}\n\nfunction redeemTknAndTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.redeemUnderlying(varg2).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v5 == 0);\n            assert((address(this)).balance != (address(this)).balance);\n            v6 = msg.sender.call().value(varg2).gas(!varg2 * 2300);\n            require(v6); // checks call status, propagates error data on error\n        } else {\n            require(varg0.code.size);\n            v7, v8 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v9, v10 = varg1.redeemUnderlying(varg2).gas(msg.gas);\n            require(v9); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v10 == 0);\n            require(varg0.code.size);\n            v11, v12 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v8 != v12);\n            require(varg0.code.size);\n            v13, v14 = varg0.transfer(msg.sender, varg2).gas(msg.gas);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v14);\n        }\n        emit LogRedeemTknAndTransfer(varg0, varg1, varg2);\n    }\n}\n\nfunction payBorrowBack(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.borrowBalanceCurrent(address(this)).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert((address(this)).balance != (address(this)).balance);\n            emit LogPayBorrowBack(varg0, varg1, v5);\n        } else {\n            require(varg1.code.size);\n            v6, v7 = varg1.borrowBalanceCurrent(address(this)).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg0.code.size);\n            v8, v9 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v10, v11 = varg1.repayBorrow(v7).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v11 == 0);\n            require(varg0.code.size);\n            v12, v13 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v12); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v9 != v13);\n            emit LogPayBorrowBack(varg0, varg1, v7);\n        }\n    }\n}\n\nfunction adminTwo() public nonPayable { \n    return _adminTwo;\n}\n\nfunction comptrollerAddr() public nonPayable { \n    return _comptrollerAddr;\n}\n\nfunction borrowTknAndTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.borrow(varg2).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v5 == 0);\n            assert((address(this)).balance != (address(this)).balance);\n            v6 = msg.sender.call().value(varg2).gas(!varg2 * 2300);\n            require(v6); // checks call status, propagates error data on error\n        } else {\n            require(varg0.code.size);\n            v7, v8 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v9, v10 = varg1.borrow(varg2).gas(msg.gas);\n            require(v9); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v10 == 0);\n            require(varg0.code.size);\n            v11, v12 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v8 != v12);\n            require(varg0.code.size);\n            v13, v14 = varg0.transfer(msg.sender, varg2).gas(msg.gas);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v14);\n        }\n        emit LogBorrowTknAndTransfer(varg0, varg1, varg2);\n    }\n}\n\nfunction depositCTkn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'Nothing to deposit');\n    _deposits[varg0] = _deposits[varg0] + varg1;\n    _totalDeposits[varg0] = _totalDeposits[varg0] + varg1;\n    emit LogDepositCToken(varg0, varg1);\n}\n\nfunction 0x5198(uint256 varg0, uint256 varg1) private { \n    v0 = 0x5720(0xde0b6b3a7640000, varg1);\n    v1 = v0 + (varg0 >> 1);\n    require(v1 >= v0, 'math-not-safe');\n    assert(varg0);\n    return v1 / varg0;\n}\n\nfunction 0x51d0(uint256 varg0, uint256 varg1) private { \n    v0 = 0x5720(varg0, varg1);\n    require(v0 + (0xde0b6b3a7640000 >> 1) >= v0, 'math-not-safe');\n    assert(0xde0b6b3a7640000);\n    return (v0 + (0xde0b6b3a7640000 >> 1)) / 0xde0b6b3a7640000;\n}\n\nfunction 0x5210(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 > 0) {\n        if (address(varg2) == _ethAddr) {\n            assert((address(this)).balance >= varg0);\n            v0 = address(varg1);\n            require(v0.code.size);\n            v1 = v0.mint().value((address(this)).balance).gas(msg.gas);\n            require(v1); // checks call status, propagates error data on error\n            assert((address(this)).balance != (address(this)).balance);\n            v2 = address(varg2);\n            v3 = address(varg1);\n            emit LogMintTknBack(v2, v3, (address(this)).balance);\n        } else {\n            v4 = address(varg2);\n            require(v4.code.size);\n            v5, v6 = v4.balanceOf(address(this)).gas(msg.gas);\n            require(v5); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v6 >= varg0);\n            v7 = address(varg1);\n            require(v7.code.size);\n            v8, v9 = v7.mint(v6).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v9 == 0);\n            v10 = address(varg2);\n            require(v10.code.size);\n            v11, v12 = v10.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v6 != v12);\n            v13 = address(varg2);\n            v14 = address(varg1);\n            emit LogMintTknBack(v13, v14, v6);\n        }\n    }\n    return ;\n}\n\nfunction setApproval(address varg0, uint256 varg1, address varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(varg0.code.size);\n    v3, v4 = varg0.allowance(address(this), varg2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (varg1 > v4) {\n        require(varg0.code.size);\n        v5 = varg0.approve(varg2, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff).gas(msg.gas);\n        require(v5); // checks call status, propagates error data on error\n    }\n}\n\nfunction 0x5720(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0 == v1;\n    if (varg0 != v1) {\n        v0 = v4 = varg1 * varg0;\n        assert(varg0);\n        v2 = v5 = v4 / varg0 == varg1;\n    }\n    require(v2, 'math-not-safe');\n    return v0;\n}\n\nfunction collectTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    assert(0xff & map_5[varg0] == 0);\n    if (varg0 != _ethAddr) {\n        require(varg0.code.size);\n        v3, v4 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v3); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg0.code.size);\n        v5, v6 = varg0.transfer(msg.sender, v4).gas(msg.gas);\n        require(v5); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v6, 'Transfer failed');\n    } else {\n        v7 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v7); // checks call status, propagates error data on error\n    }\n}\n\nfunction mintCollectedTkns(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    0x5210(varg2, varg1, varg0);\n}\n\nfunction daiAddr() public nonPayable { \n    return _daiAddr;\n}\n\nfunction registry() public nonPayable { \n    return _registry;\n}\n\nfunction enterMarket(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length << 5);\n    v0[(?).length] = 0;\n    v1 = v2 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v1 = v3 = msg.sender == _adminTwo;\n    }\n    require(v1, 'Not admin address');\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length << 5) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    require(_comptrollerAddr.code.size);\n    v7, v8 = _comptrollerAddr.enterMarkets(v4).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    RETURNDATACOPY(v8, 0, RETURNDATASIZE());\n    MEM[64] = v8 + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v8] <= 0x100000000);\n    require(MEM[v8] + v8 + 32 <= v8 + RETURNDATASIZE());\n    require(!((MEM[MEM[v8] + v8] > 0x100000000) | (MEM[v8] + v8 + 32 + (MEM[MEM[v8] + v8] << 5) > v8 + RETURNDATASIZE())));\n}\n\nfunction withdrawCTkn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_deposits[varg0] != 0, 'Nothing to Withdraw');\n    if (varg1 >= _deposits[varg0]) {\n        v0 = v1 = _deposits[varg0];\n    }\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(msg.sender, v0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(v3);\n    _deposits[varg0] = _deposits[varg0] - v0;\n    _totalDeposits[varg0] = _totalDeposits[varg0] - v0;\n    emit LogWithdrawCToken(varg0, v0);\n}\n\nfunction deposits(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _deposits[varg1];\n}\n\nfunction usdcAddr() public nonPayable { \n    return _usdcAddr;\n}\n\nfunction cDai() public nonPayable { \n    return _cDai;\n}\n\nfunction cEth() public nonPayable { \n    return _cEth;\n}\n\nfunction ethAddr() public nonPayable { \n    return _ethAddr;\n}\n\nfunction cUsdc() public nonPayable { \n    return _cUsdc;\n}\n\nfunction adminOne() public nonPayable { \n    return _adminOne;\n}\n\nfunction totalDeposits(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _totalDeposits[varg0];\n}\n\nfunction exitMarket(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(_comptrollerAddr.code.size);\n    v3, v4 = _comptrollerAddr.exitMarket(varg0).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction depositToken(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    if (varg0 == _ethAddr) {\n        require(varg1.code.size);\n        v0 = varg1.mint().value(msg.value).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        assert((address(this)).balance != (address(this)).balance);\n        require(varg1.code.size);\n        v1, v2 = varg1.exchangeRateCurrent().gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4 = 0x5198(v2, msg.value);\n        v5 = 0x51d0(v2, v4);\n        if (v5 > msg.value) {\n            v3 = v6 = v4 - 1;\n        }\n        _deposits[varg1] = _deposits[varg1] + v3;\n        _totalDeposits[varg1] = _totalDeposits[varg1] + v3;\n        emit LogDepositToken(varg0, varg1, msg.value);\n    } else {\n        require(varg0.code.size);\n        v7, v8 = varg0.transferFrom(msg.sender, address(this), varg2).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v8, 'Not enough tkn to deposit');\n        require(varg0.code.size);\n        v9, v10 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg1.code.size);\n        v11, v12 = varg1.mint(varg2).gas(msg.gas);\n        require(v11); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v12 == 0);\n        require(varg0.code.size);\n        v13, v14 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v10 != v14);\n        require(varg1.code.size);\n        v15, v16 = varg1.exchangeRateCurrent().gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v17 = v18 = 0x5198(v16, varg2);\n        v19 = 0x51d0(v16, v18);\n        if (v19 > varg2) {\n            v17 = v20 = v18 - 1;\n        }\n        _deposits[varg1] = _deposits[varg1] + v17;\n        _totalDeposits[varg1] = _totalDeposits[varg1] + v17;\n        emit LogDepositToken(varg0, varg1, varg2);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x7b103999 > v0) {\n            if (0x365ceb39 > v0) {\n                if (0x1e33667 == v0) {\n                    withdrawToken(address,address,uint256);\n                } else if (0x5e9d9f2 == v0) {\n                    mintTknBack(address,address,uint256);\n                } else if (0xa165869 == v0) {\n                    collectCTokens(address);\n                } else if (0xb066dbb == v0) {\n                    redeemTknAndTransfer(address,address,uint256);\n                } else if (0x12320591 == v0) {\n                    payBorrowBack(address,address,uint256);\n                } else if (0x159b523b == v0) {\n                    adminTwo();\n                }\n            } else if (0x5811f0bf > v0) {\n                if (0x365ceb39 == v0) {\n                    comptrollerAddr();\n                } else if (0x4aa9fc1a == v0) {\n                    borrowTknAndTransfer(address,address,uint256);\n                } else if (0x558c3b2f == v0) {\n                    depositCTkn(address,uint256);\n                }\n            } else if (0x5811f0bf == v0) {\n                setApproval(address,uint256,address);\n            } else if (0x59999b41 == v0) {\n                collectTokens(address);\n            } else if (0x74f28997 == v0) {\n                mintCollectedTkns(address,address,uint256);\n            } else if (0x74fa0a63 == v0) {\n                daiAddr();\n            }\n        } else if (0xa44026a3 > v0) {\n            if (0x7b103999 == v0) {\n                registry();\n            } else if (0x7cc4fc05 == v0) {\n                enterMarket(address[]);\n            } else if (0x8e77b641 == v0) {\n                withdrawCTkn(address,uint256);\n            } else if (0x8f601f66 == v0) {\n                deposits(address,address);\n            } else if (0x903e4fc3 == v0) {\n                usdcAddr();\n            } else if (0x9b089d55 == v0) {\n                cDai();\n            }\n        } else if (0xd5d3b309 > v0) {\n            if (0xa44026a3 == v0) {\n                cEth();\n            } else if (0xbbf646c2 == v0) {\n                ethAddr();\n            } else if (0xd08c96fc == v0) {\n                cUsdc();\n            }\n        } else if (0xd5d3b309 == v0) {\n            adminOne();\n        } else if (0xe9403256 == v0) {\n            totalDeposits(address);\n        } else if (0xede4edd0 == v0) {\n            exitMarket(address);\n        } else if (0xfb0f97a8 == v0) {\n            depositToken(address,address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 16:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) map_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _deposits; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _totalDeposits; // STORAGE[0xc]\nuint160 _ethAddr; // STORAGE[0x0] bytes 0 to 19\nuint160 _daiAddr; // STORAGE[0x1] bytes 0 to 19\nuint160 _usdcAddr; // STORAGE[0x2] bytes 0 to 19\naddress _registry; // STORAGE[0x3] bytes 0 to 19\naddress _comptrollerAddr; // STORAGE[0x4] bytes 0 to 19\naddress _adminOne; // STORAGE[0x6] bytes 0 to 19\naddress _adminTwo; // STORAGE[0x7] bytes 0 to 19\nuint160 _cEth; // STORAGE[0x8] bytes 0 to 19\nuint160 _cDai; // STORAGE[0x9] bytes 0 to 19\nuint160 _cUsdc; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nLogWithdrawToken(address, address, uint256);\nLogRedeemTknAndTransfer(address, address, uint256);\nLogPayBorrowBack(address, address, uint256);\nLogBorrowTknAndTransfer(address, address, uint256);\nLogDepositCToken(address, uint256);\nLogWithdrawCToken(address, uint256);\nLogDepositToken(address, address, uint256);\nLogMintTknBack(address, address, uint256);\n\nfunction fallback() public payable { \n}\n\nfunction withdrawToken(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(_deposits[varg1] != 0, 'Nothing to Withdraw');\n    require(varg1.code.size);\n    v0, v1 = varg1.exchangeRateCurrent().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0x5198(v1, varg2);\n    if (v3 > _deposits[varg1]) {\n        v2 = v4 = _deposits[varg1] - 1;\n        v5 = v6 = 0x51d0(v1, v4);\n    }\n    if (varg0 == _ethAddr) {\n        require(varg1.code.size);\n        v7, v8 = varg1.redeemUnderlying(v5).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v8 == 0, 'something went wrong');\n        assert((address(this)).balance != (address(this)).balance);\n        v9 = msg.sender.call().value(v5).gas(!v5 * 2300);\n        require(v9); // checks call status, propagates error data on error\n    } else {\n        require(varg0.code.size);\n        v10, v11 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg1.code.size);\n        v12, v13 = varg1.redeemUnderlying(v5).gas(msg.gas);\n        require(v12); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v13 == 0, 'something went wrong');\n        require(varg0.code.size);\n        v14, v15 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v14); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v11 != v15);\n        require(varg0.code.size);\n        v16, v17 = varg0.transfer(msg.sender, v5).gas(msg.gas);\n        require(v16); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v17, 'not enough tkn to Transfer');\n    }\n    _deposits[varg1] = _deposits[varg1] - v2;\n    _totalDeposits[varg1] = _totalDeposits[varg1] - v2;\n    emit LogWithdrawToken(varg0, varg1, v5);\n}\n\nfunction mintTknBack(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    0x5210(varg2, varg1, varg0);\n}\n\nfunction collectCTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(varg0.code.size);\n    v3, v4 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_totalDeposits[varg0] <= v4, 'SafeMath: subtraction overflow');\n    require(varg0.code.size);\n    v5, v6 = varg0.transfer(msg.sender, v4 - _totalDeposits[varg0]).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'CToken Transfer failed');\n}\n\nfunction redeemTknAndTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.redeemUnderlying(varg2).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v5 == 0);\n            assert((address(this)).balance != (address(this)).balance);\n            v6 = msg.sender.call().value(varg2).gas(!varg2 * 2300);\n            require(v6); // checks call status, propagates error data on error\n        } else {\n            require(varg0.code.size);\n            v7, v8 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v9, v10 = varg1.redeemUnderlying(varg2).gas(msg.gas);\n            require(v9); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v10 == 0);\n            require(varg0.code.size);\n            v11, v12 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v8 != v12);\n            require(varg0.code.size);\n            v13, v14 = varg0.transfer(msg.sender, varg2).gas(msg.gas);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v14);\n        }\n        emit LogRedeemTknAndTransfer(varg0, varg1, varg2);\n    }\n}\n\nfunction payBorrowBack(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.borrowBalanceCurrent(address(this)).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert((address(this)).balance != (address(this)).balance);\n            emit LogPayBorrowBack(varg0, varg1, v5);\n        } else {\n            require(varg1.code.size);\n            v6, v7 = varg1.borrowBalanceCurrent(address(this)).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg0.code.size);\n            v8, v9 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v10, v11 = varg1.repayBorrow(v7).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v11 == 0);\n            require(varg0.code.size);\n            v12, v13 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v12); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v9 != v13);\n            emit LogPayBorrowBack(varg0, varg1, v7);\n        }\n    }\n}\n\nfunction adminTwo() public nonPayable { \n    return _adminTwo;\n}\n\nfunction comptrollerAddr() public nonPayable { \n    return _comptrollerAddr;\n}\n\nfunction borrowTknAndTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.borrow(varg2).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v5 == 0);\n            assert((address(this)).balance != (address(this)).balance);\n            v6 = msg.sender.call().value(varg2).gas(!varg2 * 2300);\n            require(v6); // checks call status, propagates error data on error\n        } else {\n            require(varg0.code.size);\n            v7, v8 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v9, v10 = varg1.borrow(varg2).gas(msg.gas);\n            require(v9); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v10 == 0);\n            require(varg0.code.size);\n            v11, v12 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v8 != v12);\n            require(varg0.code.size);\n            v13, v14 = varg0.transfer(msg.sender, varg2).gas(msg.gas);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v14);\n        }\n        emit LogBorrowTknAndTransfer(varg0, varg1, varg2);\n    }\n}\n\nfunction depositCTkn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'Nothing to deposit');\n    _deposits[varg0] = _deposits[varg0] + varg1;\n    _totalDeposits[varg0] = _totalDeposits[varg0] + varg1;\n    emit LogDepositCToken(varg0, varg1);\n}\n\nfunction 0x5198(uint256 varg0, uint256 varg1) private { \n    v0 = 0x5720(0xde0b6b3a7640000, varg1);\n    v1 = v0 + (varg0 >> 1);\n    require(v1 >= v0, 'math-not-safe');\n    assert(varg0);\n    return v1 / varg0;\n}\n\nfunction 0x51d0(uint256 varg0, uint256 varg1) private { \n    v0 = 0x5720(varg0, varg1);\n    require(v0 + (0xde0b6b3a7640000 >> 1) >= v0, 'math-not-safe');\n    assert(0xde0b6b3a7640000);\n    return (v0 + (0xde0b6b3a7640000 >> 1)) / 0xde0b6b3a7640000;\n}\n\nfunction 0x5210(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 > 0) {\n        if (address(varg2) == _ethAddr) {\n            assert((address(this)).balance >= varg0);\n            v0 = address(varg1);\n            require(v0.code.size);\n            v1 = v0.mint().value((address(this)).balance).gas(msg.gas);\n            require(v1); // checks call status, propagates error data on error\n            assert((address(this)).balance != (address(this)).balance);\n            v2 = address(varg2);\n            v3 = address(varg1);\n            emit LogMintTknBack(v2, v3, (address(this)).balance);\n        } else {\n            v4 = address(varg2);\n            require(v4.code.size);\n            v5, v6 = v4.balanceOf(address(this)).gas(msg.gas);\n            require(v5); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v6 >= varg0);\n            v7 = address(varg1);\n            require(v7.code.size);\n            v8, v9 = v7.mint(v6).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v9 == 0);\n            v10 = address(varg2);\n            require(v10.code.size);\n            v11, v12 = v10.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v6 != v12);\n            v13 = address(varg2);\n            v14 = address(varg1);\n            emit LogMintTknBack(v13, v14, v6);\n        }\n    }\n    return ;\n}\n\nfunction setApproval(address varg0, uint256 varg1, address varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(varg0.code.size);\n    v3, v4 = varg0.allowance(address(this), varg2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (varg1 > v4) {\n        require(varg0.code.size);\n        v5 = varg0.approve(varg2, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff).gas(msg.gas);\n        require(v5); // checks call status, propagates error data on error\n    }\n}\n\nfunction 0x5720(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0 == v1;\n    if (varg0 != v1) {\n        v0 = v4 = varg1 * varg0;\n        assert(varg0);\n        v2 = v5 = v4 / varg0 == varg1;\n    }\n    require(v2, 'math-not-safe');\n    return v0;\n}\n\nfunction collectTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    assert(0xff & map_5[varg0] == 0);\n    if (varg0 != _ethAddr) {\n        require(varg0.code.size);\n        v3, v4 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v3); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg0.code.size);\n        v5, v6 = varg0.transfer(msg.sender, v4).gas(msg.gas);\n        require(v5); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v6, 'Transfer failed');\n    } else {\n        v7 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v7); // checks call status, propagates error data on error\n    }\n}\n\nfunction mintCollectedTkns(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    0x5210(varg2, varg1, varg0);\n}\n\nfunction daiAddr() public nonPayable { \n    return _daiAddr;\n}\n\nfunction registry() public nonPayable { \n    return _registry;\n}\n\nfunction enterMarket(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length << 5);\n    v0[(?).length] = 0;\n    v1 = v2 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v1 = v3 = msg.sender == _adminTwo;\n    }\n    require(v1, 'Not admin address');\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length << 5) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    require(_comptrollerAddr.code.size);\n    v7, v8 = _comptrollerAddr.enterMarkets(v4).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    RETURNDATACOPY(v8, 0, RETURNDATASIZE());\n    MEM[64] = v8 + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v8] <= 0x100000000);\n    require(MEM[v8] + v8 + 32 <= v8 + RETURNDATASIZE());\n    require(!((MEM[MEM[v8] + v8] > 0x100000000) | (MEM[v8] + v8 + 32 + (MEM[MEM[v8] + v8] << 5) > v8 + RETURNDATASIZE())));\n}\n\nfunction withdrawCTkn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_deposits[varg0] != 0, 'Nothing to Withdraw');\n    if (varg1 >= _deposits[varg0]) {\n        v0 = v1 = _deposits[varg0];\n    }\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(msg.sender, v0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(v3);\n    _deposits[varg0] = _deposits[varg0] - v0;\n    _totalDeposits[varg0] = _totalDeposits[varg0] - v0;\n    emit LogWithdrawCToken(varg0, v0);\n}\n\nfunction deposits(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _deposits[varg1];\n}\n\nfunction usdcAddr() public nonPayable { \n    return _usdcAddr;\n}\n\nfunction cDai() public nonPayable { \n    return _cDai;\n}\n\nfunction cEth() public nonPayable { \n    return _cEth;\n}\n\nfunction ethAddr() public nonPayable { \n    return _ethAddr;\n}\n\nfunction cUsdc() public nonPayable { \n    return _cUsdc;\n}\n\nfunction adminOne() public nonPayable { \n    return _adminOne;\n}\n\nfunction totalDeposits(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _totalDeposits[varg0];\n}\n\nfunction exitMarket(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(_comptrollerAddr.code.size);\n    v3, v4 = _comptrollerAddr.exitMarket(varg0).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction depositToken(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    if (varg0 == _ethAddr) {\n        require(varg1.code.size);\n        v0 = varg1.mint().value(msg.value).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        assert((address(this)).balance != (address(this)).balance);\n        require(varg1.code.size);\n        v1, v2 = varg1.exchangeRateCurrent().gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4 = 0x5198(v2, msg.value);\n        v5 = 0x51d0(v2, v4);\n        if (v5 > msg.value) {\n            v3 = v6 = v4 - 1;\n        }\n        _deposits[varg1] = _deposits[varg1] + v3;\n        _totalDeposits[varg1] = _totalDeposits[varg1] + v3;\n        emit LogDepositToken(varg0, varg1, msg.value);\n    } else {\n        require(varg0.code.size);\n        v7, v8 = varg0.transferFrom(msg.sender, address(this), varg2).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v8, 'Not enough tkn to deposit');\n        require(varg0.code.size);\n        v9, v10 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg1.code.size);\n        v11, v12 = varg1.mint(varg2).gas(msg.gas);\n        require(v11); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v12 == 0);\n        require(varg0.code.size);\n        v13, v14 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v10 != v14);\n        require(varg1.code.size);\n        v15, v16 = varg1.exchangeRateCurrent().gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v17 = v18 = 0x5198(v16, varg2);\n        v19 = 0x51d0(v16, v18);\n        if (v19 > varg2) {\n            v17 = v20 = v18 - 1;\n        }\n        _deposits[varg1] = _deposits[varg1] + v17;\n        _totalDeposits[varg1] = _totalDeposits[varg1] + v17;\n        emit LogDepositToken(varg0, varg1, varg2);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x7b103999 > v0) {\n            if (0x365ceb39 > v0) {\n                if (0x1e33667 == v0) {\n                    withdrawToken(address,address,uint256);\n                } else if (0x5e9d9f2 == v0) {\n                    mintTknBack(address,address,uint256);\n                } else if (0xa165869 == v0) {\n                    collectCTokens(address);\n                } else if (0xb066dbb == v0) {\n                    redeemTknAndTransfer(address,address,uint256);\n                } else if (0x12320591 == v0) {\n                    payBorrowBack(address,address,uint256);\n                } else if (0x159b523b == v0) {\n                    adminTwo();\n                }\n            } else if (0x5811f0bf > v0) {\n                if (0x365ceb39 == v0) {\n                    comptrollerAddr();\n                } else if (0x4aa9fc1a == v0) {\n                    borrowTknAndTransfer(address,address,uint256);\n                } else if (0x558c3b2f == v0) {\n                    depositCTkn(address,uint256);\n                }\n            } else if (0x5811f0bf == v0) {\n                setApproval(address,uint256,address);\n            } else if (0x59999b41 == v0) {\n                collectTokens(address);\n            } else if (0x74f28997 == v0) {\n                mintCollectedTkns(address,address,uint256);\n            } else if (0x74fa0a63 == v0) {\n                daiAddr();\n            }\n        } else if (0xa44026a3 > v0) {\n            if (0x7b103999 == v0) {\n                registry();\n            } else if (0x7cc4fc05 == v0) {\n                enterMarket(address[]);\n            } else if (0x8e77b641 == v0) {\n                withdrawCTkn(address,uint256);\n            } else if (0x8f601f66 == v0) {\n                deposits(address,address);\n            } else if (0x903e4fc3 == v0) {\n                usdcAddr();\n            } else if (0x9b089d55 == v0) {\n                cDai();\n            }\n        } else if (0xd5d3b309 > v0) {\n            if (0xa44026a3 == v0) {\n                cEth();\n            } else if (0xbbf646c2 == v0) {\n                ethAddr();\n            } else if (0xd08c96fc == v0) {\n                cUsdc();\n            }\n        } else if (0xd5d3b309 == v0) {\n            adminOne();\n        } else if (0xe9403256 == v0) {\n            totalDeposits(address);\n        } else if (0xede4edd0 == v0) {\n            exitMarket(address);\n        } else if (0xfb0f97a8 == v0) {\n            depositToken(address,address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 16:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) map_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _deposits; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _totalDeposits; // STORAGE[0xc]\nuint160 _ethAddr; // STORAGE[0x0] bytes 0 to 19\nuint160 _daiAddr; // STORAGE[0x1] bytes 0 to 19\nuint160 _usdcAddr; // STORAGE[0x2] bytes 0 to 19\naddress _registry; // STORAGE[0x3] bytes 0 to 19\naddress _comptrollerAddr; // STORAGE[0x4] bytes 0 to 19\naddress _adminOne; // STORAGE[0x6] bytes 0 to 19\naddress _adminTwo; // STORAGE[0x7] bytes 0 to 19\nuint160 _cEth; // STORAGE[0x8] bytes 0 to 19\nuint160 _cDai; // STORAGE[0x9] bytes 0 to 19\nuint160 _cUsdc; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nLogWithdrawToken(address, address, uint256);\nLogRedeemTknAndTransfer(address, address, uint256);\nLogPayBorrowBack(address, address, uint256);\nLogBorrowTknAndTransfer(address, address, uint256);\nLogDepositCToken(address, uint256);\nLogWithdrawCToken(address, uint256);\nLogDepositToken(address, address, uint256);\nLogMintTknBack(address, address, uint256);\n\nfunction fallback() public payable { \n}\n\nfunction withdrawToken(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(_deposits[varg1] != 0, 'Nothing to Withdraw');\n    require(varg1.code.size);\n    v0, v1 = varg1.exchangeRateCurrent().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0x5198(v1, varg2);\n    if (v3 > _deposits[varg1]) {\n        v2 = v4 = _deposits[varg1] - 1;\n        v5 = v6 = 0x51d0(v1, v4);\n    }\n    if (varg0 == _ethAddr) {\n        require(varg1.code.size);\n        v7, v8 = varg1.redeemUnderlying(v5).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v8 == 0, 'something went wrong');\n        assert((address(this)).balance != (address(this)).balance);\n        v9 = msg.sender.call().value(v5).gas(!v5 * 2300);\n        require(v9); // checks call status, propagates error data on error\n    } else {\n        require(varg0.code.size);\n        v10, v11 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg1.code.size);\n        v12, v13 = varg1.redeemUnderlying(v5).gas(msg.gas);\n        require(v12); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v13 == 0, 'something went wrong');\n        require(varg0.code.size);\n        v14, v15 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v14); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v11 != v15);\n        require(varg0.code.size);\n        v16, v17 = varg0.transfer(msg.sender, v5).gas(msg.gas);\n        require(v16); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v17, 'not enough tkn to Transfer');\n    }\n    _deposits[varg1] = _deposits[varg1] - v2;\n    _totalDeposits[varg1] = _totalDeposits[varg1] - v2;\n    emit LogWithdrawToken(varg0, varg1, v5);\n}\n\nfunction mintTknBack(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    0x5210(varg2, varg1, varg0);\n}\n\nfunction collectCTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(varg0.code.size);\n    v3, v4 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_totalDeposits[varg0] <= v4, 'SafeMath: subtraction overflow');\n    require(varg0.code.size);\n    v5, v6 = varg0.transfer(msg.sender, v4 - _totalDeposits[varg0]).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'CToken Transfer failed');\n}\n\nfunction redeemTknAndTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.redeemUnderlying(varg2).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v5 == 0);\n            assert((address(this)).balance != (address(this)).balance);\n            v6 = msg.sender.call().value(varg2).gas(!varg2 * 2300);\n            require(v6); // checks call status, propagates error data on error\n        } else {\n            require(varg0.code.size);\n            v7, v8 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v9, v10 = varg1.redeemUnderlying(varg2).gas(msg.gas);\n            require(v9); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v10 == 0);\n            require(varg0.code.size);\n            v11, v12 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v8 != v12);\n            require(varg0.code.size);\n            v13, v14 = varg0.transfer(msg.sender, varg2).gas(msg.gas);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v14);\n        }\n        emit LogRedeemTknAndTransfer(varg0, varg1, varg2);\n    }\n}\n\nfunction payBorrowBack(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.borrowBalanceCurrent(address(this)).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert((address(this)).balance != (address(this)).balance);\n            emit LogPayBorrowBack(varg0, varg1, v5);\n        } else {\n            require(varg1.code.size);\n            v6, v7 = varg1.borrowBalanceCurrent(address(this)).gas(msg.gas);\n            require(v6); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg0.code.size);\n            v8, v9 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v10, v11 = varg1.repayBorrow(v7).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v11 == 0);\n            require(varg0.code.size);\n            v12, v13 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v12); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v9 != v13);\n            emit LogPayBorrowBack(varg0, varg1, v7);\n        }\n    }\n}\n\nfunction adminTwo() public nonPayable { \n    return _adminTwo;\n}\n\nfunction comptrollerAddr() public nonPayable { \n    return _comptrollerAddr;\n}\n\nfunction borrowTknAndTransfer(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender.code.size);\n    v0, v1 = msg.sender.owner().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_registry.code.size);\n    v2, v3 = _registry.proxies(address(v1)).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(address(v3) != 0, 'not-user-wallet');\n    require(address(v3) == msg.sender, 'not-wallet-owner');\n    if (varg2 > 0) {\n        if (varg0 == _ethAddr) {\n            require(varg1.code.size);\n            v4, v5 = varg1.borrow(varg2).gas(msg.gas);\n            require(v4); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v5 == 0);\n            assert((address(this)).balance != (address(this)).balance);\n            v6 = msg.sender.call().value(varg2).gas(!varg2 * 2300);\n            require(v6); // checks call status, propagates error data on error\n        } else {\n            require(varg0.code.size);\n            v7, v8 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(varg1.code.size);\n            v9, v10 = varg1.borrow(varg2).gas(msg.gas);\n            require(v9); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v10 == 0);\n            require(varg0.code.size);\n            v11, v12 = varg0.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v8 != v12);\n            require(varg0.code.size);\n            v13, v14 = varg0.transfer(msg.sender, varg2).gas(msg.gas);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v14);\n        }\n        emit LogBorrowTknAndTransfer(varg0, varg1, varg2);\n    }\n}\n\nfunction depositCTkn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'Nothing to deposit');\n    _deposits[varg0] = _deposits[varg0] + varg1;\n    _totalDeposits[varg0] = _totalDeposits[varg0] + varg1;\n    emit LogDepositCToken(varg0, varg1);\n}\n\nfunction 0x5198(uint256 varg0, uint256 varg1) private { \n    v0 = 0x5720(0xde0b6b3a7640000, varg1);\n    v1 = v0 + (varg0 >> 1);\n    require(v1 >= v0, 'math-not-safe');\n    assert(varg0);\n    return v1 / varg0;\n}\n\nfunction 0x51d0(uint256 varg0, uint256 varg1) private { \n    v0 = 0x5720(varg0, varg1);\n    require(v0 + (0xde0b6b3a7640000 >> 1) >= v0, 'math-not-safe');\n    assert(0xde0b6b3a7640000);\n    return (v0 + (0xde0b6b3a7640000 >> 1)) / 0xde0b6b3a7640000;\n}\n\nfunction 0x5210(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 > 0) {\n        if (address(varg2) == _ethAddr) {\n            assert((address(this)).balance >= varg0);\n            v0 = address(varg1);\n            require(v0.code.size);\n            v1 = v0.mint().value((address(this)).balance).gas(msg.gas);\n            require(v1); // checks call status, propagates error data on error\n            assert((address(this)).balance != (address(this)).balance);\n            v2 = address(varg2);\n            v3 = address(varg1);\n            emit LogMintTknBack(v2, v3, (address(this)).balance);\n        } else {\n            v4 = address(varg2);\n            require(v4.code.size);\n            v5, v6 = v4.balanceOf(address(this)).gas(msg.gas);\n            require(v5); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v6 >= varg0);\n            v7 = address(varg1);\n            require(v7.code.size);\n            v8, v9 = v7.mint(v6).gas(msg.gas);\n            require(v8); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v9 == 0);\n            v10 = address(varg2);\n            require(v10.code.size);\n            v11, v12 = v10.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v6 != v12);\n            v13 = address(varg2);\n            v14 = address(varg1);\n            emit LogMintTknBack(v13, v14, v6);\n        }\n    }\n    return ;\n}\n\nfunction setApproval(address varg0, uint256 varg1, address varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(varg0.code.size);\n    v3, v4 = varg0.allowance(address(this), varg2).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (varg1 > v4) {\n        require(varg0.code.size);\n        v5 = varg0.approve(varg2, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff).gas(msg.gas);\n        require(v5); // checks call status, propagates error data on error\n    }\n}\n\nfunction 0x5720(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0 == v1;\n    if (varg0 != v1) {\n        v0 = v4 = varg1 * varg0;\n        assert(varg0);\n        v2 = v5 = v4 / varg0 == varg1;\n    }\n    require(v2, 'math-not-safe');\n    return v0;\n}\n\nfunction collectTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    assert(0xff & map_5[varg0] == 0);\n    if (varg0 != _ethAddr) {\n        require(varg0.code.size);\n        v3, v4 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v3); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg0.code.size);\n        v5, v6 = varg0.transfer(msg.sender, v4).gas(msg.gas);\n        require(v5); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v6, 'Transfer failed');\n    } else {\n        v7 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v7); // checks call status, propagates error data on error\n    }\n}\n\nfunction mintCollectedTkns(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    0x5210(varg2, varg1, varg0);\n}\n\nfunction daiAddr() public nonPayable { \n    return _daiAddr;\n}\n\nfunction registry() public nonPayable { \n    return _registry;\n}\n\nfunction enterMarket(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg0 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length << 5);\n    v0[(?).length] = 0;\n    v1 = v2 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v1 = v3 = msg.sender == _adminTwo;\n    }\n    require(v1, 'Not admin address');\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length << 5) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    require(_comptrollerAddr.code.size);\n    v7, v8 = _comptrollerAddr.enterMarkets(v4).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    RETURNDATACOPY(v8, 0, RETURNDATASIZE());\n    MEM[64] = v8 + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v8] <= 0x100000000);\n    require(MEM[v8] + v8 + 32 <= v8 + RETURNDATASIZE());\n    require(!((MEM[MEM[v8] + v8] > 0x100000000) | (MEM[v8] + v8 + 32 + (MEM[MEM[v8] + v8] << 5) > v8 + RETURNDATASIZE())));\n}\n\nfunction withdrawCTkn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_deposits[varg0] != 0, 'Nothing to Withdraw');\n    if (varg1 >= _deposits[varg0]) {\n        v0 = v1 = _deposits[varg0];\n    }\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(msg.sender, v0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(v3);\n    _deposits[varg0] = _deposits[varg0] - v0;\n    _totalDeposits[varg0] = _totalDeposits[varg0] - v0;\n    emit LogWithdrawCToken(varg0, v0);\n}\n\nfunction deposits(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _deposits[varg1];\n}\n\nfunction usdcAddr() public nonPayable { \n    return _usdcAddr;\n}\n\nfunction cDai() public nonPayable { \n    return _cDai;\n}\n\nfunction cEth() public nonPayable { \n    return _cEth;\n}\n\nfunction ethAddr() public nonPayable { \n    return _ethAddr;\n}\n\nfunction cUsdc() public nonPayable { \n    return _cUsdc;\n}\n\nfunction adminOne() public nonPayable { \n    return _adminOne;\n}\n\nfunction totalDeposits(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _totalDeposits[varg0];\n}\n\nfunction exitMarket(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = msg.sender == _adminOne;\n    if (msg.sender != _adminOne) {\n        v0 = v2 = msg.sender == _adminTwo;\n    }\n    require(v0, 'Not admin address');\n    require(_comptrollerAddr.code.size);\n    v3, v4 = _comptrollerAddr.exitMarket(varg0).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction depositToken(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    if (varg0 == _ethAddr) {\n        require(varg1.code.size);\n        v0 = varg1.mint().value(msg.value).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        assert((address(this)).balance != (address(this)).balance);\n        require(varg1.code.size);\n        v1, v2 = varg1.exchangeRateCurrent().gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v4 = 0x5198(v2, msg.value);\n        v5 = 0x51d0(v2, v4);\n        if (v5 > msg.value) {\n            v3 = v6 = v4 - 1;\n        }\n        _deposits[varg1] = _deposits[varg1] + v3;\n        _totalDeposits[varg1] = _totalDeposits[varg1] + v3;\n        emit LogDepositToken(varg0, varg1, msg.value);\n    } else {\n        require(varg0.code.size);\n        v7, v8 = varg0.transferFrom(msg.sender, address(this), varg2).gas(msg.gas);\n        require(v7); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v8, 'Not enough tkn to deposit');\n        require(varg0.code.size);\n        v9, v10 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(varg1.code.size);\n        v11, v12 = varg1.mint(varg2).gas(msg.gas);\n        require(v11); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v12 == 0);\n        require(varg0.code.size);\n        v13, v14 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v10 != v14);\n        require(varg1.code.size);\n        v15, v16 = varg1.exchangeRateCurrent().gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v17 = v18 = 0x5198(v16, varg2);\n        v19 = 0x51d0(v16, v18);\n        if (v19 > varg2) {\n            v17 = v20 = v18 - 1;\n        }\n        _deposits[varg1] = _deposits[varg1] + v17;\n        _totalDeposits[varg1] = _totalDeposits[varg1] + v17;\n        emit LogDepositToken(varg0, varg1, varg2);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x7b103999 > v0) {\n            if (0x365ceb39 > v0) {\n                if (0x1e33667 == v0) {\n                    withdrawToken(address,address,uint256);\n                } else if (0x5e9d9f2 == v0) {\n                    mintTknBack(address,address,uint256);\n                } else if (0xa165869 == v0) {\n                    collectCTokens(address);\n                } else if (0xb066dbb == v0) {\n                    redeemTknAndTransfer(address,address,uint256);\n                } else if (0x12320591 == v0) {\n                    payBorrowBack(address,address,uint256);\n                } else if (0x159b523b == v0) {\n                    adminTwo();\n                }\n            } else if (0x5811f0bf > v0) {\n                if (0x365ceb39 == v0) {\n                    comptrollerAddr();\n                } else if (0x4aa9fc1a == v0) {\n                    borrowTknAndTransfer(address,address,uint256);\n                } else if (0x558c3b2f == v0) {\n                    depositCTkn(address,uint256);\n                }\n            } else if (0x5811f0bf == v0) {\n                setApproval(address,uint256,address);\n            } else if (0x59999b41 == v0) {\n                collectTokens(address);\n            } else if (0x74f28997 == v0) {\n                mintCollectedTkns(address,address,uint256);\n            } else if (0x74fa0a63 == v0) {\n                daiAddr();\n            }\n        } else if (0xa44026a3 > v0) {\n            if (0x7b103999 == v0) {\n                registry();\n            } else if (0x7cc4fc05 == v0) {\n                enterMarket(address[]);\n            } else if (0x8e77b641 == v0) {\n                withdrawCTkn(address,uint256);\n            } else if (0x8f601f66 == v0) {\n                deposits(address,address);\n            } else if (0x903e4fc3 == v0) {\n                usdcAddr();\n            } else if (0x9b089d55 == v0) {\n                cDai();\n            }\n        } else if (0xd5d3b309 > v0) {\n            if (0xa44026a3 == v0) {\n                cEth();\n            } else if (0xbbf646c2 == v0) {\n                ethAddr();\n            } else if (0xd08c96fc == v0) {\n                cUsdc();\n            }\n        } else if (0xd5d3b309 == v0) {\n            adminOne();\n        } else if (0xe9403256 == v0) {\n            totalDeposits(address);\n        } else if (0xede4edd0 == v0) {\n            exitMarket(address);\n        } else if (0xfb0f97a8 == v0) {\n            depositToken(address,address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 54.15532994270325,
	"usage": {
		"completion_tokens": 1154,
		"prompt_tokens": 7526,
		"total_tokens": 8680
	}
}