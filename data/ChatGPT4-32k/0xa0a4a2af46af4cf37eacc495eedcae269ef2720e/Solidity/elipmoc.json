{
	"address": "0xa0a4a2af46af4cf37eacc495eedcae269ef2720e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the size and complexity of the decompiled code, reproducing the exact Solidity code is challenging. However, the decompiled code provides a lot of information about the original contract: it seems to be some sort of ERC721 token contract (due to the presence of Transfer and Approval events, and the 0x23b872dd function selector which corresponds to safeTransferFrom function in ERC721). \n\nUnfortunately, this decompiled code seems incomplete and a bit unstructured, which makes it difficult to derive a full Solidity smart contract from it. Additionally, it appears to contain a number of low-level operations which are typically handled by the EVM and aren't typically written explicitly in Solidity.\n\nThis is a simplified Solidity code that covers some of the aspects of the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MyToken is ERC721 {\n    address private _owner;\n    mapping (uint => address) private _owners;\n    mapping (address => uint) private _balances;\n    \n    constructor() ERC721(\"MyToken\", \"MTK\") {\n        _owner = msg.sender;\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n    \n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n    \n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        _beforeTokenTransfer(from, to, tokenId);\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n```\n\nPlease note that this is a very simplified example and it does not cover all the functionality of the original contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701485964,
	"id": "chatcmpl-8RAVw0xxcp8GCyBCD0F9082TePgYf",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 16:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_0; // STORAGE[0x0]\nuint256[] array_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 owner; // STORAGE[0x3]\nuint256[] ___function_selector__; // STORAGE[0x4]\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nApprovalForAll(address, address, bool);\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1, uint512 varg2, uint256 varg3) public payable { \n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xc87b56dd) {\n        if (function_selector != 0xe5e01c11) {\n            if (function_selector != 0x1c02708d) {\n                if (function_selector != 0x4f6ccce7) {\n                    if (function_selector != 0x2f745c59) {\n                        if (function_selector != 0x23b872dd) {\n                            if (function_selector != 0x42842e0e) {\n                                if (function_selector != 0xb88d4fde) {\n                                    if (function_selector != 0x95ea7b3) {\n                                        if (function_selector != 0xa22cb465) {\n                                            if (function_selector != 0x6a627842) {\n                                                if (function_selector != 0x2c4d4d18) {\n                                                    if (function_selector != 0x6fdde03) {\n                                                        if (function_selector != 0x95d89b41) {\n                                                            if (function_selector != 0x18160ddd) {\n                                                                if (function_selector != 0x7546172) {\n                                                                    if (function_selector != 0x4e73a241) {\n                                                                        if (function_selector != 0x6352211e) {\n                                                                            if (function_selector != 0x70a08231) {\n                                                                                if (function_selector != 0x81812fc) {\n                                                                                    if (function_selector != 0xe985e9c5) {\n                                                                                        require(function_selector == 0xf1753550);\n                                                                                        CALLDATACOPY(320, 4, 32);\n                                                                                        require(!msg.value);\n                                                                                        return STORAGE[keccak256(9, MEM[320])];\n                                                                                    } else {\n                                                                                        CALLDATACOPY(320, 4, 64);\n                                                                                        require(!msg.value);\n                                                                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                                        require(varg2 < 0x10000000000000000000000000000000000000000);\n                                                                                        return STORAGE[keccak256(keccak256(8, MEM[320]), MEM[352])];\n                                                                                    }\n                                                                                } else {\n                                                                                    CALLDATACOPY(320, 4, 32);\n                                                                                    require(!msg.value);\n                                                                                    return STORAGE[keccak256(7, MEM[320])];\n                                                                                }\n                                                                            } else {\n                                                                                CALLDATACOPY(320, 4, 32);\n                                                                                require(!msg.value);\n                                                                                require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                                return STORAGE[keccak256(6, MEM[320])];\n                                                                            }\n                                                                        } else {\n                                                                            CALLDATACOPY(320, 4, 32);\n                                                                            require(!msg.value);\n                                                                            return STORAGE[keccak256(5, MEM[320])];\n                                                                        }\n                                                                    } else {\n                                                                        require(!msg.value);\n                                                                        while (0 > STORAGE[keccak256(4)] + 32) {\n                                                                            MEM[384] = ___function_selector__[0];\n                                                                            MEM[288] = 1;\n                                                                            if (5 != 1) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                                            MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                                            if (128 + MEM[384] != 1 + MEM[384]) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        return 32, v0, v0, v0, v0, v0, v0, 1 + MEM[384];\n                                                                    }\n                                                                } else {\n                                                                    require(!msg.value);\n                                                                    return owner;\n                                                                }\n                                                            } else {\n                                                                require(!msg.value);\n                                                                return stor_2;\n                                                            }\n                                                        } else {\n                                                            require(!msg.value);\n                                                            while (0 > STORAGE[keccak256(1)] + 32) {\n                                                                MEM[384] = array_1[0];\n                                                                MEM[288] = 1;\n                                                                if (2 != 1) {\n                                                                    break;\n                                                                }\n                                                            }\n                                                            while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                                MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                                if (32 + MEM[384] != 1 + MEM[384]) {\n                                                                    break;\n                                                                }\n                                                            }\n                                                            return 32, v0, v0, v0, 1 + MEM[384];\n                                                        }\n                                                    } else {\n                                                        require(!msg.value);\n                                                        while (0 > STORAGE[keccak256(0)] + 32) {\n                                                            MEM[384] = array_0[0];\n                                                            MEM[288] = 1;\n                                                            if (2 != 1) {\n                                                                break;\n                                                            }\n                                                        }\n                                                        while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                            MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                            if (32 + MEM[384] != 1 + MEM[384]) {\n                                                                break;\n                                                            }\n                                                        }\n                                                        return 32, v0, v0, v0, 1 + MEM[384];\n                                                    }\n                                                } else {\n                                                    CALLDATACOPY(320, 4, 32);\n                                                    require(!msg.value);\n                                                    require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                    require(msg.sender == owner);\n                                                    owner = MEM[320];\n                                                    exit;\n                                                }\n                                            } else {\n                                                CALLDATACOPY(320, 4, 32);\n                                                require(!msg.value);\n                                                require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                require((msg.sender == owner) & (MEM[320] != 0));\n                                                STORAGE[keccak256(5, stor_2)] = MEM[320];\n                                                require(STORAGE[keccak256(6, MEM[320])] + 1 >= STORAGE[keccak256(6, MEM[320])]);\n                                                STORAGE[keccak256(6, MEM[320])] = STORAGE[keccak256(6, MEM[320])] + 1;\n                                                STORAGE[keccak256(keccak256(10, MEM[320]), STORAGE[keccak256(6, MEM[320])])] = stor_2;\n                                                STORAGE[keccak256(11, stor_2)] = STORAGE[keccak256(6, MEM[320])];\n                                                require(stor_2 + 1 >= stor_2);\n                                                stor_2 = stor_2 + 1;\n                                                emit Transfer(0, MEM[320], stor_2);\n                                                return 1;\n                                            }\n                                        } else {\n                                            CALLDATACOPY(320, 4, 64);\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 2);\n                                            require(MEM[320] != msg.sender);\n                                            STORAGE[keccak256(keccak256(8, msg.sender), MEM[320])] = MEM[352];\n                                            emit ApprovalForAll(msg.sender, MEM[320], MEM[352]);\n                                            exit;\n                                        }\n                                    } else {\n                                        CALLDATACOPY(320, 4, 64);\n                                        require(!msg.value);\n                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                        require((msg.sender == STORAGE[keccak256(5, MEM[352])]) | STORAGE[keccak256(keccak256(0x8, STORAGE[keccak256(5, MEM[352])]), msg.sender)]);\n                                        STORAGE[keccak256(7, MEM[352])] = MEM[320];\n                                        emit Approval(STORAGE[keccak256(5, MEM[352])], MEM[320], MEM[352]);\n                                        exit;\n                                    }\n                                } else {\n                                    CALLDATACOPY(448, 4 + varg3, 1056);\n                                    require(varg3.length <= 1024);\n                                    CALLDATACOPY(448, 4 + varg3, 1088);\n                                }\n                            } else {\n                                v1 = dataCopy();\n                                require(v1);\n                            }\n                            CALLDATACOPY(320, 4, 96);\n                            require(!msg.value);\n                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                            MEM[1600] = 0x92863fe;\n                            v2 = v3 = 2037;\n                        } else {\n                            CALLDATACOPY(320, 4, 96);\n                            require(!msg.value);\n                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                            MEM[416] = 0x92863fe;\n                            v2 = v4 = 1603;\n                        }\n                        require((STORAGE[keccak256(5, v5)] == v6) & (v7 != 0));\n                        require(STORAGE[keccak256(keccak256(0x8, STORAGE[keccak256(5, v5)]), v8)] | ((v8 == STORAGE[keccak256(5, v5)]) | (v8 == STORAGE[keccak256(7, v5)])));\n                        require(STORAGE[keccak256(6, v6)] >= 1);\n                        if (STORAGE[keccak256(6, v6)] - 1 != STORAGE[keccak256(11, v5)]) {\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(11, v5)])] = STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)];\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)] = 0;\n                        } else {\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)] = 0;\n                        }\n                        STORAGE[keccak256(keccak256(10, v7), STORAGE[keccak256(6, v7)])] = v5;\n                        STORAGE[keccak256(11, v5)] = STORAGE[keccak256(6, v7)];\n                        STORAGE[keccak256(5, v5)] = v7;\n                        require(STORAGE[keccak256(6, v6)] >= 1);\n                        STORAGE[keccak256(6, v6)] = STORAGE[keccak256(6, v6)] - 1;\n                        require(STORAGE[keccak256(6, v7)] + 1 >= STORAGE[keccak256(6, v7)]);\n                        STORAGE[keccak256(6, v7)] = STORAGE[keccak256(6, v7)] + 1;\n                        if (STORAGE[keccak256(7, v5)] != 0) {\n                            STORAGE[keccak256(7, v5)] = 0;\n                        }\n                        emit Transfer(v6, v7, v5);\n                    } else {\n                        CALLDATACOPY(320, 4, 64);\n                        require(!msg.value);\n                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                        require(MEM[352] < STORAGE[keccak256(6, MEM[320])]);\n                        return STORAGE[keccak256(keccak256(10, MEM[320]), MEM[352])];\n                    }\n                } else {\n                    CALLDATACOPY(320, 4, 32);\n                    require(!msg.value);\n                    require(MEM[320] < stor_2);\n                    return MEM[320];\n                }\n            } else {\n                require(!msg.value);\n                selfdestruct(msg.sender);\n            }\n        } else {\n            CALLDATACOPY(320, 4, 32);\n            require(!msg.value);\n            CALLDATACOPY(352, 4 + varg1, 160);\n            require(varg1.length <= 128);\n            while (0 > MEM[352] + 32) {\n                ___function_selector__[0] = MEM[352];\n                MEM[288] = 1;\n                if (5 != 1) {\n                    break;\n                }\n            }\n            exit;\n        }\n    } else {\n        CALLDATACOPY(320, 4, 32);\n        require(!msg.value);\n        while (0 > STORAGE[keccak256(4)] + 32) {\n            MEM[416] = ___function_selector__[0];\n            MEM[288] = 1;\n            if (5 != 1) {\n                break;\n            }\n        }\n        while (MEM[416] > MEM[416] + 31 - (MEM[416] - 1) % 32) {\n            MEM8[448 + MEM[416]] = 0x0 & 0xFF;\n            if (128 + MEM[416] != 1 + MEM[416]) {\n                break;\n            }\n        }\n        return 32, v0, v0, v0, v0, v0, v0, 1 + MEM[416];\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 16:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_0; // STORAGE[0x0]\nuint256[] array_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 owner; // STORAGE[0x3]\nuint256[] ___function_selector__; // STORAGE[0x4]\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nApprovalForAll(address, address, bool);\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1, uint512 varg2, uint256 varg3) public payable { \n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xc87b56dd) {\n        if (function_selector != 0xe5e01c11) {\n            if (function_selector != 0x1c02708d) {\n                if (function_selector != 0x4f6ccce7) {\n                    if (function_selector != 0x2f745c59) {\n                        if (function_selector != 0x23b872dd) {\n                            if (function_selector != 0x42842e0e) {\n                                if (function_selector != 0xb88d4fde) {\n                                    if (function_selector != 0x95ea7b3) {\n                                        if (function_selector != 0xa22cb465) {\n                                            if (function_selector != 0x6a627842) {\n                                                if (function_selector != 0x2c4d4d18) {\n                                                    if (function_selector != 0x6fdde03) {\n                                                        if (function_selector != 0x95d89b41) {\n                                                            if (function_selector != 0x18160ddd) {\n                                                                if (function_selector != 0x7546172) {\n                                                                    if (function_selector != 0x4e73a241) {\n                                                                        if (function_selector != 0x6352211e) {\n                                                                            if (function_selector != 0x70a08231) {\n                                                                                if (function_selector != 0x81812fc) {\n                                                                                    if (function_selector != 0xe985e9c5) {\n                                                                                        require(function_selector == 0xf1753550);\n                                                                                        CALLDATACOPY(320, 4, 32);\n                                                                                        require(!msg.value);\n                                                                                        return STORAGE[keccak256(9, MEM[320])];\n                                                                                    } else {\n                                                                                        CALLDATACOPY(320, 4, 64);\n                                                                                        require(!msg.value);\n                                                                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                                        require(varg2 < 0x10000000000000000000000000000000000000000);\n                                                                                        return STORAGE[keccak256(keccak256(8, MEM[320]), MEM[352])];\n                                                                                    }\n                                                                                } else {\n                                                                                    CALLDATACOPY(320, 4, 32);\n                                                                                    require(!msg.value);\n                                                                                    return STORAGE[keccak256(7, MEM[320])];\n                                                                                }\n                                                                            } else {\n                                                                                CALLDATACOPY(320, 4, 32);\n                                                                                require(!msg.value);\n                                                                                require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                                return STORAGE[keccak256(6, MEM[320])];\n                                                                            }\n                                                                        } else {\n                                                                            CALLDATACOPY(320, 4, 32);\n                                                                            require(!msg.value);\n                                                                            return STORAGE[keccak256(5, MEM[320])];\n                                                                        }\n                                                                    } else {\n                                                                        require(!msg.value);\n                                                                        while (0 > STORAGE[keccak256(4)] + 32) {\n                                                                            MEM[384] = ___function_selector__[0];\n                                                                            MEM[288] = 1;\n                                                                            if (5 != 1) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                                            MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                                            if (128 + MEM[384] != 1 + MEM[384]) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        return 32, v0, v0, v0, v0, v0, v0, 1 + MEM[384];\n                                                                    }\n                                                                } else {\n                                                                    require(!msg.value);\n                                                                    return owner;\n                                                                }\n                                                            } else {\n                                                                require(!msg.value);\n                                                                return stor_2;\n                                                            }\n                                                        } else {\n                                                            require(!msg.value);\n                                                            while (0 > STORAGE[keccak256(1)] + 32) {\n                                                                MEM[384] = array_1[0];\n                                                                MEM[288] = 1;\n                                                                if (2 != 1) {\n                                                                    break;\n                                                                }\n                                                            }\n                                                            while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                                MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                                if (32 + MEM[384] != 1 + MEM[384]) {\n                                                                    break;\n                                                                }\n                                                            }\n                                                            return 32, v0, v0, v0, 1 + MEM[384];\n                                                        }\n                                                    } else {\n                                                        require(!msg.value);\n                                                        while (0 > STORAGE[keccak256(0)] + 32) {\n                                                            MEM[384] = array_0[0];\n                                                            MEM[288] = 1;\n                                                            if (2 != 1) {\n                                                                break;\n                                                            }\n                                                        }\n                                                        while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                            MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                            if (32 + MEM[384] != 1 + MEM[384]) {\n                                                                break;\n                                                            }\n                                                        }\n                                                        return 32, v0, v0, v0, 1 + MEM[384];\n                                                    }\n                                                } else {\n                                                    CALLDATACOPY(320, 4, 32);\n                                                    require(!msg.value);\n                                                    require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                    require(msg.sender == owner);\n                                                    owner = MEM[320];\n                                                    exit;\n                                                }\n                                            } else {\n                                                CALLDATACOPY(320, 4, 32);\n                                                require(!msg.value);\n                                                require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                require((msg.sender == owner) & (MEM[320] != 0));\n                                                STORAGE[keccak256(5, stor_2)] = MEM[320];\n                                                require(STORAGE[keccak256(6, MEM[320])] + 1 >= STORAGE[keccak256(6, MEM[320])]);\n                                                STORAGE[keccak256(6, MEM[320])] = STORAGE[keccak256(6, MEM[320])] + 1;\n                                                STORAGE[keccak256(keccak256(10, MEM[320]), STORAGE[keccak256(6, MEM[320])])] = stor_2;\n                                                STORAGE[keccak256(11, stor_2)] = STORAGE[keccak256(6, MEM[320])];\n                                                require(stor_2 + 1 >= stor_2);\n                                                stor_2 = stor_2 + 1;\n                                                emit Transfer(0, MEM[320], stor_2);\n                                                return 1;\n                                            }\n                                        } else {\n                                            CALLDATACOPY(320, 4, 64);\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 2);\n                                            require(MEM[320] != msg.sender);\n                                            STORAGE[keccak256(keccak256(8, msg.sender), MEM[320])] = MEM[352];\n                                            emit ApprovalForAll(msg.sender, MEM[320], MEM[352]);\n                                            exit;\n                                        }\n                                    } else {\n                                        CALLDATACOPY(320, 4, 64);\n                                        require(!msg.value);\n                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                        require((msg.sender == STORAGE[keccak256(5, MEM[352])]) | STORAGE[keccak256(keccak256(0x8, STORAGE[keccak256(5, MEM[352])]), msg.sender)]);\n                                        STORAGE[keccak256(7, MEM[352])] = MEM[320];\n                                        emit Approval(STORAGE[keccak256(5, MEM[352])], MEM[320], MEM[352]);\n                                        exit;\n                                    }\n                                } else {\n                                    CALLDATACOPY(448, 4 + varg3, 1056);\n                                    require(varg3.length <= 1024);\n                                    CALLDATACOPY(448, 4 + varg3, 1088);\n                                }\n                            } else {\n                                v1 = dataCopy();\n                                require(v1);\n                            }\n                            CALLDATACOPY(320, 4, 96);\n                            require(!msg.value);\n                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                            MEM[1600] = 0x92863fe;\n                            v2 = v3 = 2037;\n                        } else {\n                            CALLDATACOPY(320, 4, 96);\n                            require(!msg.value);\n                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                            MEM[416] = 0x92863fe;\n                            v2 = v4 = 1603;\n                        }\n                        require((STORAGE[keccak256(5, v5)] == v6) & (v7 != 0));\n                        require(STORAGE[keccak256(keccak256(0x8, STORAGE[keccak256(5, v5)]), v8)] | ((v8 == STORAGE[keccak256(5, v5)]) | (v8 == STORAGE[keccak256(7, v5)])));\n                        require(STORAGE[keccak256(6, v6)] >= 1);\n                        if (STORAGE[keccak256(6, v6)] - 1 != STORAGE[keccak256(11, v5)]) {\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(11, v5)])] = STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)];\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)] = 0;\n                        } else {\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)] = 0;\n                        }\n                        STORAGE[keccak256(keccak256(10, v7), STORAGE[keccak256(6, v7)])] = v5;\n                        STORAGE[keccak256(11, v5)] = STORAGE[keccak256(6, v7)];\n                        STORAGE[keccak256(5, v5)] = v7;\n                        require(STORAGE[keccak256(6, v6)] >= 1);\n                        STORAGE[keccak256(6, v6)] = STORAGE[keccak256(6, v6)] - 1;\n                        require(STORAGE[keccak256(6, v7)] + 1 >= STORAGE[keccak256(6, v7)]);\n                        STORAGE[keccak256(6, v7)] = STORAGE[keccak256(6, v7)] + 1;\n                        if (STORAGE[keccak256(7, v5)] != 0) {\n                            STORAGE[keccak256(7, v5)] = 0;\n                        }\n                        emit Transfer(v6, v7, v5);\n                    } else {\n                        CALLDATACOPY(320, 4, 64);\n                        require(!msg.value);\n                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                        require(MEM[352] < STORAGE[keccak256(6, MEM[320])]);\n                        return STORAGE[keccak256(keccak256(10, MEM[320]), MEM[352])];\n                    }\n                } else {\n                    CALLDATACOPY(320, 4, 32);\n                    require(!msg.value);\n                    require(MEM[320] < stor_2);\n                    return MEM[320];\n                }\n            } else {\n                require(!msg.value);\n                selfdestruct(msg.sender);\n            }\n        } else {\n            CALLDATACOPY(320, 4, 32);\n            require(!msg.value);\n            CALLDATACOPY(352, 4 + varg1, 160);\n            require(varg1.length <= 128);\n            while (0 > MEM[352] + 32) {\n                ___function_selector__[0] = MEM[352];\n                MEM[288] = 1;\n                if (5 != 1) {\n                    break;\n                }\n            }\n            exit;\n        }\n    } else {\n        CALLDATACOPY(320, 4, 32);\n        require(!msg.value);\n        while (0 > STORAGE[keccak256(4)] + 32) {\n            MEM[416] = ___function_selector__[0];\n            MEM[288] = 1;\n            if (5 != 1) {\n                break;\n            }\n        }\n        while (MEM[416] > MEM[416] + 31 - (MEM[416] - 1) % 32) {\n            MEM8[448 + MEM[416]] = 0x0 & 0xFF;\n            if (128 + MEM[416] != 1 + MEM[416]) {\n                break;\n            }\n        }\n        return 32, v0, v0, v0, v0, v0, v0, 1 + MEM[416];\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 16:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] array_0; // STORAGE[0x0]\nuint256[] array_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 owner; // STORAGE[0x3]\nuint256[] ___function_selector__; // STORAGE[0x4]\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nApprovalForAll(address, address, bool);\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1, uint512 varg2, uint256 varg3) public payable { \n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xc87b56dd) {\n        if (function_selector != 0xe5e01c11) {\n            if (function_selector != 0x1c02708d) {\n                if (function_selector != 0x4f6ccce7) {\n                    if (function_selector != 0x2f745c59) {\n                        if (function_selector != 0x23b872dd) {\n                            if (function_selector != 0x42842e0e) {\n                                if (function_selector != 0xb88d4fde) {\n                                    if (function_selector != 0x95ea7b3) {\n                                        if (function_selector != 0xa22cb465) {\n                                            if (function_selector != 0x6a627842) {\n                                                if (function_selector != 0x2c4d4d18) {\n                                                    if (function_selector != 0x6fdde03) {\n                                                        if (function_selector != 0x95d89b41) {\n                                                            if (function_selector != 0x18160ddd) {\n                                                                if (function_selector != 0x7546172) {\n                                                                    if (function_selector != 0x4e73a241) {\n                                                                        if (function_selector != 0x6352211e) {\n                                                                            if (function_selector != 0x70a08231) {\n                                                                                if (function_selector != 0x81812fc) {\n                                                                                    if (function_selector != 0xe985e9c5) {\n                                                                                        require(function_selector == 0xf1753550);\n                                                                                        CALLDATACOPY(320, 4, 32);\n                                                                                        require(!msg.value);\n                                                                                        return STORAGE[keccak256(9, MEM[320])];\n                                                                                    } else {\n                                                                                        CALLDATACOPY(320, 4, 64);\n                                                                                        require(!msg.value);\n                                                                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                                        require(varg2 < 0x10000000000000000000000000000000000000000);\n                                                                                        return STORAGE[keccak256(keccak256(8, MEM[320]), MEM[352])];\n                                                                                    }\n                                                                                } else {\n                                                                                    CALLDATACOPY(320, 4, 32);\n                                                                                    require(!msg.value);\n                                                                                    return STORAGE[keccak256(7, MEM[320])];\n                                                                                }\n                                                                            } else {\n                                                                                CALLDATACOPY(320, 4, 32);\n                                                                                require(!msg.value);\n                                                                                require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                                return STORAGE[keccak256(6, MEM[320])];\n                                                                            }\n                                                                        } else {\n                                                                            CALLDATACOPY(320, 4, 32);\n                                                                            require(!msg.value);\n                                                                            return STORAGE[keccak256(5, MEM[320])];\n                                                                        }\n                                                                    } else {\n                                                                        require(!msg.value);\n                                                                        while (0 > STORAGE[keccak256(4)] + 32) {\n                                                                            MEM[384] = ___function_selector__[0];\n                                                                            MEM[288] = 1;\n                                                                            if (5 != 1) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                                            MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                                            if (128 + MEM[384] != 1 + MEM[384]) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        return 32, v0, v0, v0, v0, v0, v0, 1 + MEM[384];\n                                                                    }\n                                                                } else {\n                                                                    require(!msg.value);\n                                                                    return owner;\n                                                                }\n                                                            } else {\n                                                                require(!msg.value);\n                                                                return stor_2;\n                                                            }\n                                                        } else {\n                                                            require(!msg.value);\n                                                            while (0 > STORAGE[keccak256(1)] + 32) {\n                                                                MEM[384] = array_1[0];\n                                                                MEM[288] = 1;\n                                                                if (2 != 1) {\n                                                                    break;\n                                                                }\n                                                            }\n                                                            while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                                MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                                if (32 + MEM[384] != 1 + MEM[384]) {\n                                                                    break;\n                                                                }\n                                                            }\n                                                            return 32, v0, v0, v0, 1 + MEM[384];\n                                                        }\n                                                    } else {\n                                                        require(!msg.value);\n                                                        while (0 > STORAGE[keccak256(0)] + 32) {\n                                                            MEM[384] = array_0[0];\n                                                            MEM[288] = 1;\n                                                            if (2 != 1) {\n                                                                break;\n                                                            }\n                                                        }\n                                                        while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n                                                            MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n                                                            if (32 + MEM[384] != 1 + MEM[384]) {\n                                                                break;\n                                                            }\n                                                        }\n                                                        return 32, v0, v0, v0, 1 + MEM[384];\n                                                    }\n                                                } else {\n                                                    CALLDATACOPY(320, 4, 32);\n                                                    require(!msg.value);\n                                                    require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                    require(msg.sender == owner);\n                                                    owner = MEM[320];\n                                                    exit;\n                                                }\n                                            } else {\n                                                CALLDATACOPY(320, 4, 32);\n                                                require(!msg.value);\n                                                require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                require((msg.sender == owner) & (MEM[320] != 0));\n                                                STORAGE[keccak256(5, stor_2)] = MEM[320];\n                                                require(STORAGE[keccak256(6, MEM[320])] + 1 >= STORAGE[keccak256(6, MEM[320])]);\n                                                STORAGE[keccak256(6, MEM[320])] = STORAGE[keccak256(6, MEM[320])] + 1;\n                                                STORAGE[keccak256(keccak256(10, MEM[320]), STORAGE[keccak256(6, MEM[320])])] = stor_2;\n                                                STORAGE[keccak256(11, stor_2)] = STORAGE[keccak256(6, MEM[320])];\n                                                require(stor_2 + 1 >= stor_2);\n                                                stor_2 = stor_2 + 1;\n                                                emit Transfer(0, MEM[320], stor_2);\n                                                return 1;\n                                            }\n                                        } else {\n                                            CALLDATACOPY(320, 4, 64);\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 2);\n                                            require(MEM[320] != msg.sender);\n                                            STORAGE[keccak256(keccak256(8, msg.sender), MEM[320])] = MEM[352];\n                                            emit ApprovalForAll(msg.sender, MEM[320], MEM[352]);\n                                            exit;\n                                        }\n                                    } else {\n                                        CALLDATACOPY(320, 4, 64);\n                                        require(!msg.value);\n                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                        require((msg.sender == STORAGE[keccak256(5, MEM[352])]) | STORAGE[keccak256(keccak256(0x8, STORAGE[keccak256(5, MEM[352])]), msg.sender)]);\n                                        STORAGE[keccak256(7, MEM[352])] = MEM[320];\n                                        emit Approval(STORAGE[keccak256(5, MEM[352])], MEM[320], MEM[352]);\n                                        exit;\n                                    }\n                                } else {\n                                    CALLDATACOPY(448, 4 + varg3, 1056);\n                                    require(varg3.length <= 1024);\n                                    CALLDATACOPY(448, 4 + varg3, 1088);\n                                }\n                            } else {\n                                v1 = dataCopy();\n                                require(v1);\n                            }\n                            CALLDATACOPY(320, 4, 96);\n                            require(!msg.value);\n                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                            MEM[1600] = 0x92863fe;\n                            v2 = v3 = 2037;\n                        } else {\n                            CALLDATACOPY(320, 4, 96);\n                            require(!msg.value);\n                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                            MEM[416] = 0x92863fe;\n                            v2 = v4 = 1603;\n                        }\n                        require((STORAGE[keccak256(5, v5)] == v6) & (v7 != 0));\n                        require(STORAGE[keccak256(keccak256(0x8, STORAGE[keccak256(5, v5)]), v8)] | ((v8 == STORAGE[keccak256(5, v5)]) | (v8 == STORAGE[keccak256(7, v5)])));\n                        require(STORAGE[keccak256(6, v6)] >= 1);\n                        if (STORAGE[keccak256(6, v6)] - 1 != STORAGE[keccak256(11, v5)]) {\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(11, v5)])] = STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)];\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)] = 0;\n                        } else {\n                            STORAGE[keccak256(keccak256(10, v6), STORAGE[keccak256(6, v6)] - 1)] = 0;\n                        }\n                        STORAGE[keccak256(keccak256(10, v7), STORAGE[keccak256(6, v7)])] = v5;\n                        STORAGE[keccak256(11, v5)] = STORAGE[keccak256(6, v7)];\n                        STORAGE[keccak256(5, v5)] = v7;\n                        require(STORAGE[keccak256(6, v6)] >= 1);\n                        STORAGE[keccak256(6, v6)] = STORAGE[keccak256(6, v6)] - 1;\n                        require(STORAGE[keccak256(6, v7)] + 1 >= STORAGE[keccak256(6, v7)]);\n                        STORAGE[keccak256(6, v7)] = STORAGE[keccak256(6, v7)] + 1;\n                        if (STORAGE[keccak256(7, v5)] != 0) {\n                            STORAGE[keccak256(7, v5)] = 0;\n                        }\n                        emit Transfer(v6, v7, v5);\n                    } else {\n                        CALLDATACOPY(320, 4, 64);\n                        require(!msg.value);\n                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                        require(MEM[352] < STORAGE[keccak256(6, MEM[320])]);\n                        return STORAGE[keccak256(keccak256(10, MEM[320]), MEM[352])];\n                    }\n                } else {\n                    CALLDATACOPY(320, 4, 32);\n                    require(!msg.value);\n                    require(MEM[320] < stor_2);\n                    return MEM[320];\n                }\n            } else {\n                require(!msg.value);\n                selfdestruct(msg.sender);\n            }\n        } else {\n            CALLDATACOPY(320, 4, 32);\n            require(!msg.value);\n            CALLDATACOPY(352, 4 + varg1, 160);\n            require(varg1.length <= 128);\n            while (0 > MEM[352] + 32) {\n                ___function_selector__[0] = MEM[352];\n                MEM[288] = 1;\n                if (5 != 1) {\n                    break;\n                }\n            }\n            exit;\n        }\n    } else {\n        CALLDATACOPY(320, 4, 32);\n        require(!msg.value);\n        while (0 > STORAGE[keccak256(4)] + 32) {\n            MEM[416] = ___function_selector__[0];\n            MEM[288] = 1;\n            if (5 != 1) {\n                break;\n            }\n        }\n        while (MEM[416] > MEM[416] + 31 - (MEM[416] - 1) % 32) {\n            MEM8[448 + MEM[416]] = 0x0 & 0xFF;\n            if (128 + MEM[416] != 1 + MEM[416]) {\n                break;\n            }\n        }\n        return 32, v0, v0, v0, v0, v0, v0, 1 + MEM[416];\n    }\n}\n.",
	"status": "1",
	"time_cost": 24.31328320503235,
	"usage": {
		"completion_tokens": 513,
		"prompt_tokens": 3266,
		"total_tokens": 3779
	}
}