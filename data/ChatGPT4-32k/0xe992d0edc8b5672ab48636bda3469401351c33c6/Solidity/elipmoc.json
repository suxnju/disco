{
	"address": "0xe992d0edc8b5672ab48636bda3469401351c33c6",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is a solidity version of the decompiled code. Note that the original code may have used different variable names as the decompiled version only shows inferred storage locations and variables.\n\n```solidity\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MyContract {\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balanceOf;\n    string private _standard;\n    string private _name;\n    string private _symbol;\n    address private _owner;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() public view returns (string memory) { \n        return _name;\n    }\n\n    function totalSupply() public view returns (uint256) { \n        return _totalSupply;\n    }\n\n    function decimals() public view returns (uint8) { \n        return _decimals;\n    }\n\n    function standard() public view returns (string memory) { \n        return _standard;\n    }\n\n    function balanceOf(address account) public view returns (uint256) { \n        return _balanceOf[account];\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function symbol() public view returns (string memory) { \n        return _symbol;\n    }\n\n    function changeOwner(address newOwner) public { \n        require(_owner == msg.sender, \"Only current owner can change owner\");\n        _owner = newOwner;\n    }\n\n    function transfer(address recipient, uint256 amount) public { \n        require(_balanceOf[msg.sender] >= amount, \"Insufficient balance\");\n        _balanceOf[msg.sender] -= amount;\n        _balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n    }\n\n    // Handle fallback function and incoming transactions\n    fallback() external payable {\n        require(_balanceOf[address(this)] > 0, \"Contract balance is zero\");\n        uint256 amount = 3000 * msg.value / 0xde0b6b3a7640000;\n        if (amount > _balanceOf[address(this)]) {\n            amount = _balanceOf[address(this)];\n            require(msg.sender.send(msg.value - amount * 0xde0b6b3a7640000 / 3000), \"Failed to send Ether\");\n        }\n        require(amount > 0, \"Amount must be greater than zero\");\n        _balanceOf[msg.sender] += amount;\n        _balanceOf[address(this)] -= amount;\n        emit Transfer(address(this), msg.sender, amount);\n    }\n}\n```\n\nPlease note that this is a simplified version of the decompiled code and does not cover every detail of the original contract. The original contract might have additional checks, events, or functions. The fallback function implementation here is also simplified and may not fully represent the original fallback behavior. Additionally, please note that using the `send` function to send Ether as done in the fallback function can be risky due to the gas limit. Consider using a pattern like the Withdrawal Pattern to prevent re-entrancy attacks.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461599,
	"id": "chatcmpl-8R4AxS9qtvQE2yVcI0Jxq6ZGrFySr",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 23:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _standard; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    if (msg.data.length) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        }\n    }\n    require(_balanceOf[address(this)] > 0);\n    v0 = v1 = 3000 * msg.value / 0xde0b6b3a7640000;\n    if (v1 > _balanceOf[address(this)]) {\n        v0 = v2 = _balanceOf[address(this)];\n        assert(3000);\n        v3 = msg.sender.call().value(msg.value - v2 * 0xde0b6b3a7640000 / 3000).gas(2300 * !(msg.value - v2 * 0xde0b6b3a7640000 / 3000));\n        assert(v3);\n    }\n    require(v0 > 0);\n    _balanceOf[msg.sender] += v0;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    emit Transfer(address(this), msg.sender, v0);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 23:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _standard; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    if (msg.data.length) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        }\n    }\n    require(_balanceOf[address(this)] > 0);\n    v0 = v1 = 3000 * msg.value / 0xde0b6b3a7640000;\n    if (v1 > _balanceOf[address(this)]) {\n        v0 = v2 = _balanceOf[address(this)];\n        assert(3000);\n        v3 = msg.sender.call().value(msg.value - v2 * 0xde0b6b3a7640000 / 3000).gas(2300 * !(msg.value - v2 * 0xde0b6b3a7640000 / 3000));\n        assert(v3);\n    }\n    require(v0 > 0);\n    _balanceOf[msg.sender] += v0;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    emit Transfer(address(this), msg.sender, v0);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 23:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _standard; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    if (msg.data.length) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        }\n    }\n    require(_balanceOf[address(this)] > 0);\n    v0 = v1 = 3000 * msg.value / 0xde0b6b3a7640000;\n    if (v1 > _balanceOf[address(this)]) {\n        v0 = v2 = _balanceOf[address(this)];\n        assert(3000);\n        v3 = msg.sender.call().value(msg.value - v2 * 0xde0b6b3a7640000 / 3000).gas(2300 * !(msg.value - v2 * 0xde0b6b3a7640000 / 3000));\n        assert(v3);\n    }\n    require(v0 > 0);\n    _balanceOf[msg.sender] += v0;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    emit Transfer(address(this), msg.sender, v0);\n}\n.",
	"status": "1",
	"time_cost": 42.78424048423767,
	"usage": {
		"completion_tokens": 643,
		"prompt_tokens": 2016,
		"total_tokens": 2659
	}
}