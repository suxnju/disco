{
	"address": "0xf24fdeab9e15d0386a96dcd215699ed4a9b187c2",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled EVM Bytecode provided, here is a Solidity smart contract:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract ContractFromBytecode {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _approve;\n    mapping (address => address) private _referrerOf;\n    mapping (address => uint256) private _prevOf;\n    mapping (address => uint256) private _summOf;\n    uint256 private _totalSupply;\n    uint256 private _price;\n    address private _owner;\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    function _SafeDiv(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function name() public pure returns (string memory) {\n        return \"OnUp TOKEN\";\n    }\n\n    function approve(address spender, uint256 value) public {\n        _approve[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[from]);\n        require(value <= _approve[from][msg.sender]);\n\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _approve[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 6;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"OnUp\";\n    }\n\n    function price() public view returns (uint256) {\n        return _price;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[msg.sender]);\n\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    function referrerOf(address owner) public view returns (address) {\n        return _referrerOf[owner];\n    }\n\n    function summOf(address owner) public view returns (uint256) {\n        return _summOf[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _approve[owner][spender];\n    }\n\n    function prevOf(address owner) public view returns (uint256) {\n        return _prevOf[owner];\n    }\n}\n```\n\nPlease note that this is a simplified version of the contract. The decompiled code has some complex operations and checks, which were omitted for simplicity. For example, some functions like `fallback()` and `_SafeMul()`, have more extensive functionality in the decompiled code. The `fallback()` function in particular has extensive logic that is not typically included in a fallback function. It's recommended to analyze each function's logic properly to have a more accurate representation.",
				"role": "assistant"
			}
		}
	],
	"created": 1701458303,
	"id": "chatcmpl-8R3JnmCiGztMEWYjnvuVGdWihJu3u",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 21:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 _price; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _referrerOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _prevOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _summOf; // STORAGE[0xd]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\naddress _owner; // STORAGE[0xa] bytes 0 to 19\nuint256 stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3; // STORAGE[0x9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'OnUp TOKEN';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != varg0);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg2 < 0x989681);\n        }\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4f6e557000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg1 < 0x989681);\n        }\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction referrerOf(address varg0) public nonPayable { \n    return address(_referrerOf[varg0]);\n}\n\nfunction summOf(address varg0) public nonPayable { \n    return _summOf[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction prevOf(address varg0) public nonPayable { \n    return _prevOf[varg0];\n}\n\nfunction 0x8fd() private { \n    v0 = _SafeDiv(70, 100 * _price);\n    v1 = _SafeDiv(v0, msg.value);\n    require(v1 > 0);\n    require(_balanceOf[msg.sender] + v1 > _balanceOf[msg.sender]);\n    v2 = v3 = _SafeDiv(100, msg.value);\n    v4 = v5 = _SafeMul(10, v3);\n    v2 = v6 = 0;\n    v7 = v8 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n    if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n        v7 = v9 = msg.sender != _owner;\n    }\n    if (v7) {\n        v7 = v10 = 0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender;\n    }\n    if (v7) {\n        if (stor_5_0_19) {\n            _summOf[stor_5_0_19] += msg.value;\n            if (1 >= _prevOf[stor_5_0_19]) {\n                if (_prevOf[stor_5_0_19] > 0) {\n                    v4 = v11 = v5 - v3;\n                    v2 = v12 = 1;\n                }\n            } else {\n                v13 = _SafeMul(2, v3);\n                v4 = v14 = v5 - v13;\n                v2 = v15 = _SafeMul(2, v3);\n                v2 = v16 = 2;\n                goto 0xaa6;\n            }\n            if (stor_6_0_19) {\n                if (2 >= _prevOf[stor_6_0_19]) {\n                    if (_prevOf[stor_6_0_19] > 0) {\n                        v4 = v17 = v4 - v3;\n                        v2 = v18 = v2 + 1;\n                    }\n                } else {\n                    v19 = _SafeMul(2, v3);\n                    v4 = v20 = v4 - v19;\n                    v2 = v21 = _SafeMul(2, v3);\n                    v2 = v22 = v2 + 2;\n                    goto 0xb3d;\n                }\n                if (stor_7_0_19) {\n                    if (3 >= _prevOf[stor_7_0_19]) {\n                        if (_prevOf[stor_7_0_19] > 0) {\n                            v4 = v23 = v4 - v3;\n                            v2 = v24 = v2 + 1;\n                        }\n                    } else {\n                        v25 = _SafeMul(2, v3);\n                        v4 = v26 = v4 - v25;\n                        v2 = v27 = _SafeMul(2, v3);\n                        v2 = v28 = v2 + 2;\n                        goto 0xbd4;\n                    }\n                    if (stor_8_0_19) {\n                        if (4 >= _prevOf[stor_8_0_19]) {\n                            if (_prevOf[stor_8_0_19] > 0) {\n                                v4 = v29 = v4 - v3;\n                                v2 = v30 = v2 + 1;\n                            }\n                        } else {\n                            v31 = _SafeMul(2, v3);\n                            v4 = v32 = v4 - v31;\n                            v2 = v33 = _SafeMul(2, v3);\n                            v2 = v34 = v2 + 2;\n                            goto 0xc6b;\n                        }\n                        if (stor_9_0_19) {\n                            if (5 >= _prevOf[stor_9_0_19]) {\n                                if (_prevOf[stor_9_0_19] > 0) {\n                                    v4 = v35 = v4 - v3;\n                                    v2 = v36 = v2 + 1;\n                                }\n                            } else {\n                                v37 = _SafeMul(2, v3);\n                                v4 = v38 = v4 - v37;\n                                v2 = v39 = _SafeMul(2, v3);\n                                v2 = v40 = v2 + 2;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (v4 > 0) {\n        v41 = _SafeDiv(70, 100 * _price);\n        v2 = v42 = _SafeDiv(v41, v4);\n        require(v42 > 0);\n        v2 = v43 = _SafeDiv(100, v4);\n        MEM[32] = 4;\n        stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3 += v42;\n        emit Transfer(this, 0x516e0debb3db8c2c087786ccf7653fa0991784b3, v42);\n    }\n    v44 = _SafeMul(85 - v2, v2 + v3);\n    stor_0 += v44;\n    _totalSupply += v2 + v1;\n    v45 = _SafeDiv(v2 + v1 + _totalSupply, v44 + stor_0);\n    _price = v45;\n    _balanceOf[msg.sender] += v1;\n    emit Transfer(this, msg.sender, v1);\n    v46 = _SafeMul(5, v3);\n    v47 = _owner.call().value(v46).gas(2300 * !v46);\n    require(v47); // checks call status, propagates error data on error\n    v48 = _SafeMul(5, v3);\n    v49 = 0x28ff20d2d413a346f123198385ccf16e15295351.call().value(v48).gas(2300 * !v48);\n    require(v49); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v50 = stor_5_0_19.call().value(v2).gas(2300 * !v2);\n        require(v50); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v51 = stor_6_0_19.call().value(v2).gas(2300 * !v2);\n        require(v51); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v52 = stor_7_0_19.call().value(v2).gas(2300 * !v2);\n        require(v52); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v53 = stor_8_0_19.call().value(v2).gas(2300 * !v2);\n        require(v53); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v54 = stor_9_0_19.call().value(v2).gas(2300 * !v2);\n        require(v54); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x1a055690d9db80000);\n    require(msg.sender.code.size <= 0);\n    if (0xab85cb1087ce716e11dc37c69eaabc09d674575d == msg.sender) {\n        v0 = _SafeDiv(100, msg.value);\n        v1 = _SafeMul(90, v0);\n        stor_0 += v1;\n        v2 = _SafeDiv(_totalSupply, v1 + stor_0);\n        _price = v2;\n    } else {\n        stor_5_0_19 = 0;\n        stor_6_0_19 = 0;\n        stor_7_0_19 = 0;\n        stor_8_0_19 = 0;\n        stor_9_0_19 = 0;\n        v3 = v4 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n        if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n            v3 = v5 = msg.sender != _owner;\n        }\n        if (!v3) {\n            0x8fd();\n        } else {\n            v6 = v7 = msg.value >= 0x15af1d78b58c40000;\n            if (v7) {\n                v6 = 6 > _prevOf[msg.sender];\n            }\n            if (v6) {\n                _prevOf[msg.sender] = 6;\n            }\n            v8 = v9 = msg.value >= 0x1158e460913d00000;\n            if (v9) {\n                v8 = 5 > _prevOf[msg.sender];\n            }\n            if (v8) {\n                _prevOf[msg.sender] = 5;\n            }\n            v10 = v11 = msg.value >= 0xd02ab486cedc0000;\n            if (v11) {\n                v10 = 4 > _prevOf[msg.sender];\n            }\n            if (v10) {\n                _prevOf[msg.sender] = 4;\n            }\n            v12 = v13 = msg.value >= 0x8ac7230489e80000;\n            if (v13) {\n                v12 = 3 > _prevOf[msg.sender];\n            }\n            if (v12) {\n                _prevOf[msg.sender] = 3;\n            }\n            v14 = v15 = msg.value >= 0x4563918244f40000;\n            if (v15) {\n                v14 = 2 > _prevOf[msg.sender];\n            }\n            if (v14) {\n                _prevOf[msg.sender] = 2;\n            }\n            v16 = v17 = msg.value >= 0x16345785d8a0000;\n            if (v17) {\n                v16 = 1 > _prevOf[msg.sender];\n            }\n            if (v16) {\n                _prevOf[msg.sender] = 1;\n            }\n            v18 = v19 = 0xd8d726b7177a80000 <= _summOf[msg.sender];\n            if (0xd8d726b7177a80000 <= _summOf[msg.sender]) {\n                v18 = 6 > _prevOf[msg.sender];\n            }\n            if (v18) {\n                _prevOf[msg.sender] = 6;\n            }\n            v20 = v21 = 0xad78ebc5ac6200000 <= _summOf[msg.sender];\n            if (0xad78ebc5ac6200000 <= _summOf[msg.sender]) {\n                v20 = 5 > _prevOf[msg.sender];\n            }\n            if (v20) {\n                _prevOf[msg.sender] = 5;\n            }\n            v22 = v23 = 0x821ab0d4414980000 <= _summOf[msg.sender];\n            if (0x821ab0d4414980000 <= _summOf[msg.sender]) {\n                v22 = 4 > _prevOf[msg.sender];\n            }\n            if (v22) {\n                _prevOf[msg.sender] = 4;\n            }\n            v24 = v25 = 0x56bc75e2d63100000 <= _summOf[msg.sender];\n            if (0x56bc75e2d63100000 <= _summOf[msg.sender]) {\n                v24 = 3 > _prevOf[msg.sender];\n            }\n            if (v24) {\n                _prevOf[msg.sender] = 3;\n            }\n            v26 = v27 = 0x2b5e3af16b1880000 <= _summOf[msg.sender];\n            if (0x2b5e3af16b1880000 <= _summOf[msg.sender]) {\n                v26 = 2 > _prevOf[msg.sender];\n            }\n            if (v26) {\n                _prevOf[msg.sender] = 2;\n            }\n            stor_5_0_19 = _referrerOf[msg.sender];\n            if (!stor_5_0_0) {\n                v28 = new bytes[](msg.data.length);\n                CALLDATACOPY(v28.data, 0, msg.data.length);\n                stor_5_0_19 = MEM[20 + v28];\n                require(stor_5_0_19.code.size <= 0);\n                require(_balanceOf[stor_5_0_19] > 0);\n                require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != stor_5_0_19);\n                require(0xab85cb1087ce716e11dc37c69eaabc09d674575d != stor_5_0_19);\n                _referrerOf[msg.sender] = stor_5_0_19 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrerOf[msg.sender];\n            }\n            0x8fd();\n            goto 0x1b1;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd21cacdf == function_selector) {\n            referrerOf(address);\n        } else if (0xd929bf26 == function_selector) {\n            summOf(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf32ca660 == function_selector) {\n            prevOf(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 21:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 _price; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _referrerOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _prevOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _summOf; // STORAGE[0xd]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\naddress _owner; // STORAGE[0xa] bytes 0 to 19\nuint256 stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3; // STORAGE[0x9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'OnUp TOKEN';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != varg0);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg2 < 0x989681);\n        }\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4f6e557000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg1 < 0x989681);\n        }\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction referrerOf(address varg0) public nonPayable { \n    return address(_referrerOf[varg0]);\n}\n\nfunction summOf(address varg0) public nonPayable { \n    return _summOf[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction prevOf(address varg0) public nonPayable { \n    return _prevOf[varg0];\n}\n\nfunction 0x8fd() private { \n    v0 = _SafeDiv(70, 100 * _price);\n    v1 = _SafeDiv(v0, msg.value);\n    require(v1 > 0);\n    require(_balanceOf[msg.sender] + v1 > _balanceOf[msg.sender]);\n    v2 = v3 = _SafeDiv(100, msg.value);\n    v4 = v5 = _SafeMul(10, v3);\n    v2 = v6 = 0;\n    v7 = v8 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n    if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n        v7 = v9 = msg.sender != _owner;\n    }\n    if (v7) {\n        v7 = v10 = 0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender;\n    }\n    if (v7) {\n        if (stor_5_0_19) {\n            _summOf[stor_5_0_19] += msg.value;\n            if (1 >= _prevOf[stor_5_0_19]) {\n                if (_prevOf[stor_5_0_19] > 0) {\n                    v4 = v11 = v5 - v3;\n                    v2 = v12 = 1;\n                }\n            } else {\n                v13 = _SafeMul(2, v3);\n                v4 = v14 = v5 - v13;\n                v2 = v15 = _SafeMul(2, v3);\n                v2 = v16 = 2;\n                goto 0xaa6;\n            }\n            if (stor_6_0_19) {\n                if (2 >= _prevOf[stor_6_0_19]) {\n                    if (_prevOf[stor_6_0_19] > 0) {\n                        v4 = v17 = v4 - v3;\n                        v2 = v18 = v2 + 1;\n                    }\n                } else {\n                    v19 = _SafeMul(2, v3);\n                    v4 = v20 = v4 - v19;\n                    v2 = v21 = _SafeMul(2, v3);\n                    v2 = v22 = v2 + 2;\n                    goto 0xb3d;\n                }\n                if (stor_7_0_19) {\n                    if (3 >= _prevOf[stor_7_0_19]) {\n                        if (_prevOf[stor_7_0_19] > 0) {\n                            v4 = v23 = v4 - v3;\n                            v2 = v24 = v2 + 1;\n                        }\n                    } else {\n                        v25 = _SafeMul(2, v3);\n                        v4 = v26 = v4 - v25;\n                        v2 = v27 = _SafeMul(2, v3);\n                        v2 = v28 = v2 + 2;\n                        goto 0xbd4;\n                    }\n                    if (stor_8_0_19) {\n                        if (4 >= _prevOf[stor_8_0_19]) {\n                            if (_prevOf[stor_8_0_19] > 0) {\n                                v4 = v29 = v4 - v3;\n                                v2 = v30 = v2 + 1;\n                            }\n                        } else {\n                            v31 = _SafeMul(2, v3);\n                            v4 = v32 = v4 - v31;\n                            v2 = v33 = _SafeMul(2, v3);\n                            v2 = v34 = v2 + 2;\n                            goto 0xc6b;\n                        }\n                        if (stor_9_0_19) {\n                            if (5 >= _prevOf[stor_9_0_19]) {\n                                if (_prevOf[stor_9_0_19] > 0) {\n                                    v4 = v35 = v4 - v3;\n                                    v2 = v36 = v2 + 1;\n                                }\n                            } else {\n                                v37 = _SafeMul(2, v3);\n                                v4 = v38 = v4 - v37;\n                                v2 = v39 = _SafeMul(2, v3);\n                                v2 = v40 = v2 + 2;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (v4 > 0) {\n        v41 = _SafeDiv(70, 100 * _price);\n        v2 = v42 = _SafeDiv(v41, v4);\n        require(v42 > 0);\n        v2 = v43 = _SafeDiv(100, v4);\n        MEM[32] = 4;\n        stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3 += v42;\n        emit Transfer(this, 0x516e0debb3db8c2c087786ccf7653fa0991784b3, v42);\n    }\n    v44 = _SafeMul(85 - v2, v2 + v3);\n    stor_0 += v44;\n    _totalSupply += v2 + v1;\n    v45 = _SafeDiv(v2 + v1 + _totalSupply, v44 + stor_0);\n    _price = v45;\n    _balanceOf[msg.sender] += v1;\n    emit Transfer(this, msg.sender, v1);\n    v46 = _SafeMul(5, v3);\n    v47 = _owner.call().value(v46).gas(2300 * !v46);\n    require(v47); // checks call status, propagates error data on error\n    v48 = _SafeMul(5, v3);\n    v49 = 0x28ff20d2d413a346f123198385ccf16e15295351.call().value(v48).gas(2300 * !v48);\n    require(v49); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v50 = stor_5_0_19.call().value(v2).gas(2300 * !v2);\n        require(v50); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v51 = stor_6_0_19.call().value(v2).gas(2300 * !v2);\n        require(v51); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v52 = stor_7_0_19.call().value(v2).gas(2300 * !v2);\n        require(v52); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v53 = stor_8_0_19.call().value(v2).gas(2300 * !v2);\n        require(v53); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v54 = stor_9_0_19.call().value(v2).gas(2300 * !v2);\n        require(v54); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x1a055690d9db80000);\n    require(msg.sender.code.size <= 0);\n    if (0xab85cb1087ce716e11dc37c69eaabc09d674575d == msg.sender) {\n        v0 = _SafeDiv(100, msg.value);\n        v1 = _SafeMul(90, v0);\n        stor_0 += v1;\n        v2 = _SafeDiv(_totalSupply, v1 + stor_0);\n        _price = v2;\n    } else {\n        stor_5_0_19 = 0;\n        stor_6_0_19 = 0;\n        stor_7_0_19 = 0;\n        stor_8_0_19 = 0;\n        stor_9_0_19 = 0;\n        v3 = v4 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n        if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n            v3 = v5 = msg.sender != _owner;\n        }\n        if (!v3) {\n            0x8fd();\n        } else {\n            v6 = v7 = msg.value >= 0x15af1d78b58c40000;\n            if (v7) {\n                v6 = 6 > _prevOf[msg.sender];\n            }\n            if (v6) {\n                _prevOf[msg.sender] = 6;\n            }\n            v8 = v9 = msg.value >= 0x1158e460913d00000;\n            if (v9) {\n                v8 = 5 > _prevOf[msg.sender];\n            }\n            if (v8) {\n                _prevOf[msg.sender] = 5;\n            }\n            v10 = v11 = msg.value >= 0xd02ab486cedc0000;\n            if (v11) {\n                v10 = 4 > _prevOf[msg.sender];\n            }\n            if (v10) {\n                _prevOf[msg.sender] = 4;\n            }\n            v12 = v13 = msg.value >= 0x8ac7230489e80000;\n            if (v13) {\n                v12 = 3 > _prevOf[msg.sender];\n            }\n            if (v12) {\n                _prevOf[msg.sender] = 3;\n            }\n            v14 = v15 = msg.value >= 0x4563918244f40000;\n            if (v15) {\n                v14 = 2 > _prevOf[msg.sender];\n            }\n            if (v14) {\n                _prevOf[msg.sender] = 2;\n            }\n            v16 = v17 = msg.value >= 0x16345785d8a0000;\n            if (v17) {\n                v16 = 1 > _prevOf[msg.sender];\n            }\n            if (v16) {\n                _prevOf[msg.sender] = 1;\n            }\n            v18 = v19 = 0xd8d726b7177a80000 <= _summOf[msg.sender];\n            if (0xd8d726b7177a80000 <= _summOf[msg.sender]) {\n                v18 = 6 > _prevOf[msg.sender];\n            }\n            if (v18) {\n                _prevOf[msg.sender] = 6;\n            }\n            v20 = v21 = 0xad78ebc5ac6200000 <= _summOf[msg.sender];\n            if (0xad78ebc5ac6200000 <= _summOf[msg.sender]) {\n                v20 = 5 > _prevOf[msg.sender];\n            }\n            if (v20) {\n                _prevOf[msg.sender] = 5;\n            }\n            v22 = v23 = 0x821ab0d4414980000 <= _summOf[msg.sender];\n            if (0x821ab0d4414980000 <= _summOf[msg.sender]) {\n                v22 = 4 > _prevOf[msg.sender];\n            }\n            if (v22) {\n                _prevOf[msg.sender] = 4;\n            }\n            v24 = v25 = 0x56bc75e2d63100000 <= _summOf[msg.sender];\n            if (0x56bc75e2d63100000 <= _summOf[msg.sender]) {\n                v24 = 3 > _prevOf[msg.sender];\n            }\n            if (v24) {\n                _prevOf[msg.sender] = 3;\n            }\n            v26 = v27 = 0x2b5e3af16b1880000 <= _summOf[msg.sender];\n            if (0x2b5e3af16b1880000 <= _summOf[msg.sender]) {\n                v26 = 2 > _prevOf[msg.sender];\n            }\n            if (v26) {\n                _prevOf[msg.sender] = 2;\n            }\n            stor_5_0_19 = _referrerOf[msg.sender];\n            if (!stor_5_0_0) {\n                v28 = new bytes[](msg.data.length);\n                CALLDATACOPY(v28.data, 0, msg.data.length);\n                stor_5_0_19 = MEM[20 + v28];\n                require(stor_5_0_19.code.size <= 0);\n                require(_balanceOf[stor_5_0_19] > 0);\n                require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != stor_5_0_19);\n                require(0xab85cb1087ce716e11dc37c69eaabc09d674575d != stor_5_0_19);\n                _referrerOf[msg.sender] = stor_5_0_19 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrerOf[msg.sender];\n            }\n            0x8fd();\n            goto 0x1b1;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd21cacdf == function_selector) {\n            referrerOf(address);\n        } else if (0xd929bf26 == function_selector) {\n            summOf(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf32ca660 == function_selector) {\n            prevOf(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 21:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 _price; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _referrerOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _prevOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _summOf; // STORAGE[0xd]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\naddress _owner; // STORAGE[0xa] bytes 0 to 19\nuint256 stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3; // STORAGE[0x9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3]\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'OnUp TOKEN';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != varg0);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg2 < 0x989681);\n        }\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4f6e557000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_0);\n            stor_0 = stor_0 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_0 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_0);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            v4 = _SafeDiv(_totalSupply, this.balance);\n            _price = v4;\n            v5 = _SafeMul(101, v4);\n            v6 = _SafeDiv(100, v5);\n            _price = v6;\n            _totalSupply = 0;\n            stor_0 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v7 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v7); // checks call status, propagates error data on error\n        }\n        v8 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v8); // checks call status, propagates error data on error\n    } else {\n        if (0x516e0debb3db8c2c087786ccf7653fa0991784b3 == msg.sender) {\n            require(varg1 < 0x989681);\n        }\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction referrerOf(address varg0) public nonPayable { \n    return address(_referrerOf[varg0]);\n}\n\nfunction summOf(address varg0) public nonPayable { \n    return _summOf[varg0];\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction prevOf(address varg0) public nonPayable { \n    return _prevOf[varg0];\n}\n\nfunction 0x8fd() private { \n    v0 = _SafeDiv(70, 100 * _price);\n    v1 = _SafeDiv(v0, msg.value);\n    require(v1 > 0);\n    require(_balanceOf[msg.sender] + v1 > _balanceOf[msg.sender]);\n    v2 = v3 = _SafeDiv(100, msg.value);\n    v4 = v5 = _SafeMul(10, v3);\n    v2 = v6 = 0;\n    v7 = v8 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n    if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n        v7 = v9 = msg.sender != _owner;\n    }\n    if (v7) {\n        v7 = v10 = 0x516e0debb3db8c2c087786ccf7653fa0991784b3 != msg.sender;\n    }\n    if (v7) {\n        if (stor_5_0_19) {\n            _summOf[stor_5_0_19] += msg.value;\n            if (1 >= _prevOf[stor_5_0_19]) {\n                if (_prevOf[stor_5_0_19] > 0) {\n                    v4 = v11 = v5 - v3;\n                    v2 = v12 = 1;\n                }\n            } else {\n                v13 = _SafeMul(2, v3);\n                v4 = v14 = v5 - v13;\n                v2 = v15 = _SafeMul(2, v3);\n                v2 = v16 = 2;\n                goto 0xaa6;\n            }\n            if (stor_6_0_19) {\n                if (2 >= _prevOf[stor_6_0_19]) {\n                    if (_prevOf[stor_6_0_19] > 0) {\n                        v4 = v17 = v4 - v3;\n                        v2 = v18 = v2 + 1;\n                    }\n                } else {\n                    v19 = _SafeMul(2, v3);\n                    v4 = v20 = v4 - v19;\n                    v2 = v21 = _SafeMul(2, v3);\n                    v2 = v22 = v2 + 2;\n                    goto 0xb3d;\n                }\n                if (stor_7_0_19) {\n                    if (3 >= _prevOf[stor_7_0_19]) {\n                        if (_prevOf[stor_7_0_19] > 0) {\n                            v4 = v23 = v4 - v3;\n                            v2 = v24 = v2 + 1;\n                        }\n                    } else {\n                        v25 = _SafeMul(2, v3);\n                        v4 = v26 = v4 - v25;\n                        v2 = v27 = _SafeMul(2, v3);\n                        v2 = v28 = v2 + 2;\n                        goto 0xbd4;\n                    }\n                    if (stor_8_0_19) {\n                        if (4 >= _prevOf[stor_8_0_19]) {\n                            if (_prevOf[stor_8_0_19] > 0) {\n                                v4 = v29 = v4 - v3;\n                                v2 = v30 = v2 + 1;\n                            }\n                        } else {\n                            v31 = _SafeMul(2, v3);\n                            v4 = v32 = v4 - v31;\n                            v2 = v33 = _SafeMul(2, v3);\n                            v2 = v34 = v2 + 2;\n                            goto 0xc6b;\n                        }\n                        if (stor_9_0_19) {\n                            if (5 >= _prevOf[stor_9_0_19]) {\n                                if (_prevOf[stor_9_0_19] > 0) {\n                                    v4 = v35 = v4 - v3;\n                                    v2 = v36 = v2 + 1;\n                                }\n                            } else {\n                                v37 = _SafeMul(2, v3);\n                                v4 = v38 = v4 - v37;\n                                v2 = v39 = _SafeMul(2, v3);\n                                v2 = v40 = v2 + 2;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (v4 > 0) {\n        v41 = _SafeDiv(70, 100 * _price);\n        v2 = v42 = _SafeDiv(v41, v4);\n        require(v42 > 0);\n        v2 = v43 = _SafeDiv(100, v4);\n        MEM[32] = 4;\n        stor_9cab67b1fd49a9fd5659c983036f04080887eda312c1db99701d26815f3f37b3 += v42;\n        emit Transfer(this, 0x516e0debb3db8c2c087786ccf7653fa0991784b3, v42);\n    }\n    v44 = _SafeMul(85 - v2, v2 + v3);\n    stor_0 += v44;\n    _totalSupply += v2 + v1;\n    v45 = _SafeDiv(v2 + v1 + _totalSupply, v44 + stor_0);\n    _price = v45;\n    _balanceOf[msg.sender] += v1;\n    emit Transfer(this, msg.sender, v1);\n    v46 = _SafeMul(5, v3);\n    v47 = _owner.call().value(v46).gas(2300 * !v46);\n    require(v47); // checks call status, propagates error data on error\n    v48 = _SafeMul(5, v3);\n    v49 = 0x28ff20d2d413a346f123198385ccf16e15295351.call().value(v48).gas(2300 * !v48);\n    require(v49); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v50 = stor_5_0_19.call().value(v2).gas(2300 * !v2);\n        require(v50); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v51 = stor_6_0_19.call().value(v2).gas(2300 * !v2);\n        require(v51); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v52 = stor_7_0_19.call().value(v2).gas(2300 * !v2);\n        require(v52); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v53 = stor_8_0_19.call().value(v2).gas(2300 * !v2);\n        require(v53); // checks call status, propagates error data on error\n    }\n    if (v2 > 0) {\n        v54 = stor_9_0_19.call().value(v2).gas(2300 * !v2);\n        require(v54); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x1a055690d9db80000);\n    require(msg.sender.code.size <= 0);\n    if (0xab85cb1087ce716e11dc37c69eaabc09d674575d == msg.sender) {\n        v0 = _SafeDiv(100, msg.value);\n        v1 = _SafeMul(90, v0);\n        stor_0 += v1;\n        v2 = _SafeDiv(_totalSupply, v1 + stor_0);\n        _price = v2;\n    } else {\n        stor_5_0_19 = 0;\n        stor_6_0_19 = 0;\n        stor_7_0_19 = 0;\n        stor_8_0_19 = 0;\n        stor_9_0_19 = 0;\n        v3 = v4 = 0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender;\n        if (0x28ff20d2d413a346f123198385ccf16e15295351 != msg.sender) {\n            v3 = v5 = msg.sender != _owner;\n        }\n        if (!v3) {\n            0x8fd();\n        } else {\n            v6 = v7 = msg.value >= 0x15af1d78b58c40000;\n            if (v7) {\n                v6 = 6 > _prevOf[msg.sender];\n            }\n            if (v6) {\n                _prevOf[msg.sender] = 6;\n            }\n            v8 = v9 = msg.value >= 0x1158e460913d00000;\n            if (v9) {\n                v8 = 5 > _prevOf[msg.sender];\n            }\n            if (v8) {\n                _prevOf[msg.sender] = 5;\n            }\n            v10 = v11 = msg.value >= 0xd02ab486cedc0000;\n            if (v11) {\n                v10 = 4 > _prevOf[msg.sender];\n            }\n            if (v10) {\n                _prevOf[msg.sender] = 4;\n            }\n            v12 = v13 = msg.value >= 0x8ac7230489e80000;\n            if (v13) {\n                v12 = 3 > _prevOf[msg.sender];\n            }\n            if (v12) {\n                _prevOf[msg.sender] = 3;\n            }\n            v14 = v15 = msg.value >= 0x4563918244f40000;\n            if (v15) {\n                v14 = 2 > _prevOf[msg.sender];\n            }\n            if (v14) {\n                _prevOf[msg.sender] = 2;\n            }\n            v16 = v17 = msg.value >= 0x16345785d8a0000;\n            if (v17) {\n                v16 = 1 > _prevOf[msg.sender];\n            }\n            if (v16) {\n                _prevOf[msg.sender] = 1;\n            }\n            v18 = v19 = 0xd8d726b7177a80000 <= _summOf[msg.sender];\n            if (0xd8d726b7177a80000 <= _summOf[msg.sender]) {\n                v18 = 6 > _prevOf[msg.sender];\n            }\n            if (v18) {\n                _prevOf[msg.sender] = 6;\n            }\n            v20 = v21 = 0xad78ebc5ac6200000 <= _summOf[msg.sender];\n            if (0xad78ebc5ac6200000 <= _summOf[msg.sender]) {\n                v20 = 5 > _prevOf[msg.sender];\n            }\n            if (v20) {\n                _prevOf[msg.sender] = 5;\n            }\n            v22 = v23 = 0x821ab0d4414980000 <= _summOf[msg.sender];\n            if (0x821ab0d4414980000 <= _summOf[msg.sender]) {\n                v22 = 4 > _prevOf[msg.sender];\n            }\n            if (v22) {\n                _prevOf[msg.sender] = 4;\n            }\n            v24 = v25 = 0x56bc75e2d63100000 <= _summOf[msg.sender];\n            if (0x56bc75e2d63100000 <= _summOf[msg.sender]) {\n                v24 = 3 > _prevOf[msg.sender];\n            }\n            if (v24) {\n                _prevOf[msg.sender] = 3;\n            }\n            v26 = v27 = 0x2b5e3af16b1880000 <= _summOf[msg.sender];\n            if (0x2b5e3af16b1880000 <= _summOf[msg.sender]) {\n                v26 = 2 > _prevOf[msg.sender];\n            }\n            if (v26) {\n                _prevOf[msg.sender] = 2;\n            }\n            stor_5_0_19 = _referrerOf[msg.sender];\n            if (!stor_5_0_0) {\n                v28 = new bytes[](msg.data.length);\n                CALLDATACOPY(v28.data, 0, msg.data.length);\n                stor_5_0_19 = MEM[20 + v28];\n                require(stor_5_0_19.code.size <= 0);\n                require(_balanceOf[stor_5_0_19] > 0);\n                require(0x516e0debb3db8c2c087786ccf7653fa0991784b3 != stor_5_0_19);\n                require(0xab85cb1087ce716e11dc37c69eaabc09d674575d != stor_5_0_19);\n                _referrerOf[msg.sender] = stor_5_0_19 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrerOf[msg.sender];\n            }\n            0x8fd();\n            goto 0x1b1;\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd21cacdf == function_selector) {\n            referrerOf(address);\n        } else if (0xd929bf26 == function_selector) {\n            summOf(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf32ca660 == function_selector) {\n            prevOf(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.084280729293823,
	"usage": {
		"completion_tokens": 785,
		"prompt_tokens": 5528,
		"total_tokens": 6313
	}
}