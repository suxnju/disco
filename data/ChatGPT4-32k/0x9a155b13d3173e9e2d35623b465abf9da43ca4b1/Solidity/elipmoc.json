{
	"address": "0x9a155b13d3173e9e2d35623b465abf9da43ca4b1",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code for the above decompiled code:\n\n```solidity\npragma solidity >=0.7.0;\n\ncontract MyToken {\n    uint256 private _totalSupply;\n    string private _symbol;\n    string private _name;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 private _rate;\n    address private _changeOwner;\n    uint8 private _decimals;\n    uint8 private _fee;\n    address private _acceptOwnership;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[from]);\n        require(value <= _allowance[from][msg.sender]);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function rate() public view returns (uint256) {\n        return _rate;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function acceptOwnership() public {\n        if (msg.sender == _acceptOwnership) {\n            _changeOwner = _acceptOwnership;\n        }\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == _changeOwner);\n        _acceptOwnership = newOwner;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function fee() public view returns (uint8) {\n        return _fee;\n    }\n\n    function sell(uint256 amount) public payable {\n        require(amount > 0 && amount <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= amount;\n        msg.sender.transfer(_rate * amount);\n    }\n\n    fallback() external payable {\n        _totalSupply += msg.value;\n        _balanceOf[msg.sender] += msg.value;\n        _rate += msg.value / 1000000000;\n    }\n}\n```\n\nPlease note that this code might not compile or work as expected if the decompiled code wasn't accurate or complete. Some parts of the decompiled code were not clear, hence some assumptions were made. Always test your contract on a test network before deploying it on the main network.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463753,
	"id": "chatcmpl-8R4jhaOXJbJyQJCIculIOuPCMaAOb",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 04:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint256 _rate; // STORAGE[0x8]\naddress _changeOwner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _fee; // STORAGE[0x9] bytes 0 to 0\naddress _acceptOwnership; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg2 <= _balanceOf[varg0];\n    if (varg2 <= _balanceOf[varg0]) {\n        v0 = v2 = varg2 <= _allowance[msg.sender];\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = v4 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    require(v0);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    if (msg.sender == _acceptOwnership) {\n        _changeOwner = _acceptOwnership;\n    }\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _changeOwner);\n    _acceptOwnership = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = v2 = varg1 > 0;\n    }\n    if (v0) {\n        v0 = v3 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n    }\n    require(v0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction fee() public nonPayable { \n    return _fee;\n}\n\nfunction sell(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = v2 = varg0 <= _balanceOf[msg.sender];\n    }\n    if (v0) {\n        v0 = v3 = varg0 * _rate <= this.balance;\n    }\n    require(v0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v4 = msg.sender.call().value(_rate * varg0 - _rate * varg0 * _fee / 100).gas(2300 * !(_rate * varg0 - _rate * varg0 * _fee / 100));\n    require(v4); // checks call status, propagates error data on error\n    v5 = _changeOwner.call().value(_rate * varg0 * _fee / 100).gas(2300 * !(_rate * varg0 * _fee / 100));\n    require(v5); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction fallback() public payable { \n    if (msg.value) {\n        assert(_rate);\n        _totalSupply += 0x5f5e100 * (msg.value / _rate);\n        _balanceOf[msg.sender] += 0x5f5e100 * (msg.value / _rate);\n        _rate = _rate + 0x5f5e100 * (msg.value / _rate) / 0x3b9aca00 * block.number;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x79ba5097 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x2c4e722e == function_selector >> 224) {\n                rate();\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x79ba5097 == function_selector >> 224) {\n                acceptOwnership();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa6f9dae1 == function_selector >> 224) {\n                changeOwner(address);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xddca3f43 == function_selector >> 224) {\n            fee();\n        } else if (0xe4849b32 == function_selector >> 224) {\n            sell(uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 04:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint256 _rate; // STORAGE[0x8]\naddress _changeOwner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _fee; // STORAGE[0x9] bytes 0 to 0\naddress _acceptOwnership; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg2 <= _balanceOf[varg0];\n    if (varg2 <= _balanceOf[varg0]) {\n        v0 = v2 = varg2 <= _allowance[msg.sender];\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = v4 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    require(v0);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    if (msg.sender == _acceptOwnership) {\n        _changeOwner = _acceptOwnership;\n    }\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _changeOwner);\n    _acceptOwnership = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = v2 = varg1 > 0;\n    }\n    if (v0) {\n        v0 = v3 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n    }\n    require(v0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction fee() public nonPayable { \n    return _fee;\n}\n\nfunction sell(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = v2 = varg0 <= _balanceOf[msg.sender];\n    }\n    if (v0) {\n        v0 = v3 = varg0 * _rate <= this.balance;\n    }\n    require(v0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v4 = msg.sender.call().value(_rate * varg0 - _rate * varg0 * _fee / 100).gas(2300 * !(_rate * varg0 - _rate * varg0 * _fee / 100));\n    require(v4); // checks call status, propagates error data on error\n    v5 = _changeOwner.call().value(_rate * varg0 * _fee / 100).gas(2300 * !(_rate * varg0 * _fee / 100));\n    require(v5); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction fallback() public payable { \n    if (msg.value) {\n        assert(_rate);\n        _totalSupply += 0x5f5e100 * (msg.value / _rate);\n        _balanceOf[msg.sender] += 0x5f5e100 * (msg.value / _rate);\n        _rate = _rate + 0x5f5e100 * (msg.value / _rate) / 0x3b9aca00 * block.number;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x79ba5097 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x2c4e722e == function_selector >> 224) {\n                rate();\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x79ba5097 == function_selector >> 224) {\n                acceptOwnership();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa6f9dae1 == function_selector >> 224) {\n                changeOwner(address);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xddca3f43 == function_selector >> 224) {\n            fee();\n        } else if (0xe4849b32 == function_selector >> 224) {\n            sell(uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 04:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint256 _rate; // STORAGE[0x8]\naddress _changeOwner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _fee; // STORAGE[0x9] bytes 0 to 0\naddress _acceptOwnership; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg2 <= _balanceOf[varg0];\n    if (varg2 <= _balanceOf[varg0]) {\n        v0 = v2 = varg2 <= _allowance[msg.sender];\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = v4 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    require(v0);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n    _balanceOf[varg1] += varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    if (msg.sender == _acceptOwnership) {\n        _changeOwner = _acceptOwnership;\n    }\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _changeOwner);\n    _acceptOwnership = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = v2 = varg1 > 0;\n    }\n    if (v0) {\n        v0 = v3 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n    }\n    require(v0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction fee() public nonPayable { \n    return _fee;\n}\n\nfunction sell(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = v2 = varg0 <= _balanceOf[msg.sender];\n    }\n    if (v0) {\n        v0 = v3 = varg0 * _rate <= this.balance;\n    }\n    require(v0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v4 = msg.sender.call().value(_rate * varg0 - _rate * varg0 * _fee / 100).gas(2300 * !(_rate * varg0 - _rate * varg0 * _fee / 100));\n    require(v4); // checks call status, propagates error data on error\n    v5 = _changeOwner.call().value(_rate * varg0 * _fee / 100).gas(2300 * !(_rate * varg0 * _fee / 100));\n    require(v5); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction fallback() public payable { \n    if (msg.value) {\n        assert(_rate);\n        _totalSupply += 0x5f5e100 * (msg.value / _rate);\n        _balanceOf[msg.sender] += 0x5f5e100 * (msg.value / _rate);\n        _rate = _rate + 0x5f5e100 * (msg.value / _rate) / 0x3b9aca00 * block.number;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x79ba5097 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x2c4e722e == function_selector >> 224) {\n                rate();\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x79ba5097 == function_selector >> 224) {\n                acceptOwnership();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa6f9dae1 == function_selector >> 224) {\n                changeOwner(address);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xddca3f43 == function_selector >> 224) {\n            fee();\n        } else if (0xe4849b32 == function_selector >> 224) {\n            sell(uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 49.548441886901855,
	"usage": {
		"completion_tokens": 714,
		"prompt_tokens": 2451,
		"total_tokens": 3165
	}
}