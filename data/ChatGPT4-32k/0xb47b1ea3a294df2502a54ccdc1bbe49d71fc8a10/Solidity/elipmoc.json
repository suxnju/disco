{
	"address": "0xb47b1ea3a294df2502a54ccdc1bbe49d71fc8a10",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a representation of the decompiled code as a Solidity smart contract:\n\n```solidity\npragma solidity ^0.7.0;\n\ncontract NameRegistry {\n    mapping (address => string) private _hasName;\n    mapping (string => address) private _addresses;\n    mapping (address => string) private _pendingNameTransfers;\n    mapping (string => address) private owner_6;\n    address private _authority;\n    address private _owner;\n    uint256 private _namePrice;\n\n    event LogSetOwner(address indexed newOwner);\n    event NameTransferRequested(address indexed from, address indexed to, string name);\n    event LogSetAuthority(address indexed newAuthority);\n    event NameTransferAccepted(address indexed to, string name);\n    event NameSet(address indexed to, string name);\n    event NameUnset(address indexed from);\n\n    constructor(address owner, uint256 namePrice) {\n        _owner = owner;\n        _namePrice = namePrice;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function setOwner(address newOwner) public onlyOwner {\n        _owner = newOwner;\n        emit LogSetOwner(newOwner);\n    }\n\n    function setAuthority(address newAuthority) public onlyOwner {\n        _authority = newAuthority;\n        emit LogSetAuthority(newAuthority);\n    }\n\n    function setNamePrice(uint256 newNamePrice) public onlyOwner {\n        _namePrice = newNamePrice;\n    }\n\n    function namePrice() public view returns (uint256) {\n        return _namePrice;\n    }\n\n    function transferMyName(address to) public payable {\n        require(msg.value >= _namePrice, \"Not enough ether sent.\");\n        require(bytes(_hasName[msg.sender]).length != 0, \"You don't have a name to transfer.\");\n        _pendingNameTransfers[to] = _hasName[msg.sender];\n        _hasName[msg.sender] = \"\";\n        emit NameTransferRequested(msg.sender, to, _pendingNameTransfers[to]);\n    }\n\n    function acceptNameTransfer() public {\n        require(bytes(_pendingNameTransfers[msg.sender]).length != 0, \"No pending name transfer found.\");\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n        _pendingNameTransfers[msg.sender] = \"\";\n        emit NameTransferAccepted(msg.sender, _hasName[msg.sender]);\n    }\n\n    function setMyName(string memory name) public payable {\n        require(msg.value >= _namePrice, \"Not enough ether sent.\");\n        require(bytes(name).length <= 32, \"Name is too long.\");\n        require(bytes(name).length >= 1, \"Name is too short.\");\n        require(_addresses[name] == address(0), \"Name is already taken.\");\n        _addresses[name] = msg.sender;\n        _hasName[msg.sender] = name;\n        emit NameSet(msg.sender, name);\n    }\n\n    function unsetMyName() public {\n        require(bytes(_hasName[msg.sender]).length != 0, \"You don't have a name to unset.\");\n        delete _addresses[_hasName[msg.sender]];\n        delete _hasName[msg.sender];\n        emit NameUnset(msg.sender);\n    }\n\n    function hasName(address addr) public view returns (bool) {\n        return bytes(_hasName[addr]).length != 0;\n    }\n\n    function nameTaken(string memory name) public view returns (bool) {\n        return _addresses[name] != address(0);\n    }\n\n    function addresses(string memory name) public view returns (address) {\n        return _addresses[name];\n    }\n\n    function names(address addr) public view returns (string memory) {\n        return _hasName[addr];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function authority() public view returns (address) {\n        return _authority;\n    }\n}\n```\n\nPlease note that the provided decompiled code is complex and might not represent the exact original Solidity code. As decompiling is a reverse engineering process, there might be some loss of data or nuances in the code translation. The provided Solidity code is an approximation of the original contract's functionalities based on the given decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459429,
	"id": "chatcmpl-8R3bxmViulwkwlNRqzGsRWzFLvIUS",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 20:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _namePrice; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _hasName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addresses; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pendingNameTransfers; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\naddress _authority; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nLogSetOwner(address);\nNameTransferRequested(address, address, string);\nLogSetAuthority(address);\nNameTransferAccepted(address, string);\nNameSet(address, string);\nNameUnset(address);\n\nfunction pendingNameTransfers(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[varg0] & (!(_pendingNameTransfers[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (this != address(varg1)) {\n        if (_owner != address(varg1)) {\n            if (stor_0_0_0) {\n                v0 = address(varg1);\n                v1 = varg0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                require(_authority.code.size);\n                v2, v3 = _authority.canCall(v0, this, v1).gas(msg.gas);\n                require(v2); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                return v3;\n            } else {\n                v4 = v5 = 0;\n            }\n        } else {\n            v4 = v6 = 1;\n        }\n    } else {\n        v4 = v7 = 1;\n    }\n    return v4;\n}\n\nfunction 0x123b(uint256 varg0) private { \n    if (varg0.length) {\n        v0 = MEM[varg0.data];\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction transferMyName(address varg0) public payable { \n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    require((_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1 > 0, \"You don't have a name to transfer!\");\n    if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[varg0] = 1 + (((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v0 + (31 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v1) {\n                STORAGE[v2] = STORAGE[v1];\n                v1 += 1;\n                v2 += 1;\n            }\n        }\n    } else {\n        _hasName[varg0] = _hasName[msg.sender];\n    }\n    while (v3 + (31 + (((!(0x1 & _hasName[varg0]) << 8) - 1 & _hasName[varg0]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    v4 = new bytes[](v5);\n    v5 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v6 = v7 = v4.data;\n    if (v5) {\n        if (31 < v5) {\n            do {\n                MEM[v6] = STORAGE[v8];\n                v8 += 1;\n                v6 += 32;\n            } while (v7 + v5 <= v6);\n        }\n    }\n    if (v4.length) {\n        v9 = v4.data;\n        v10 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v10 = v11 = 0;\n    }\n    owner_6[v10] = 0x1 | ~0xff & owner_6[v10];\n    v12 = (_hasName[v10] & (!(_hasName[v10] & 0x1) << 8) + ~0) >> 1;\n    v13 = new array[](v12);\n    v14 = v15 = v13.data;\n    if (v12) {\n        if (31 < v12) {\n            do {\n                MEM[v14] = STORAGE[v16];\n                v16 += 1;\n                v14 += 32;\n            } while (v15 + v12 <= v14);\n        } else {\n            MEM[v15] = _hasName[v10] >> 8 << 8;\n        }\n    }\n    emit NameTransferRequested(msg.sender, varg0, v13);\n    v17 = v18 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[msg.sender] = 1;\n        if (0) {\n            while (v18 + 0 > v17) {\n                STORAGE[v19] = MEM[v17];\n                v17 += 32;\n                v19 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = 0x0 | ~0xff & varg0;\n    }\n    while (v20 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v19) {\n        STORAGE[v19] = 0;\n        v19 += 1;\n    }\n}\n\nfunction names(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[varg0] & (!(_hasName[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _hasName[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction setAuthority(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _authority = varg1;\n    emit LogSetAuthority(_authority);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction nameTaken(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x8c2(v0);\n    return v2;\n}\n\nfunction getMoney( function_selector) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    v1 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction acceptNameTranfer() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n        }\n    }\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    if (31 < (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[msg.sender] = 1 + (((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v5 + (31 + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v6) {\n                STORAGE[v7] = STORAGE[v6];\n                v6 += 1;\n                v7 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n    }\n    while (v8 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v7) {\n        STORAGE[v7] = 0;\n        v7 += 1;\n    }\n    v9 = v10 = msg.sender;\n    v9 = v11 = 0;\n    v12 = v13 = new bytes[](v14);\n    v15 = v14 = (_pendingNameTransfers[v10] & (!(_pendingNameTransfers[v10] & 0x1) << 8) + ~0) >> 1;\n    v16 = v17 = 4;\n    v18 = v19 = 2931;\n    v20 = v21 = v13.data;\n    if (v14) {\n        if (31 >= v14) {\n            MEM[v21] = _pendingNameTransfers[v10] >> 8 << 8;\n        }\n    }\n    while (1) {\n        if (MEM[v12]) {\n            v22 = MEM[v12 + 32];\n        } else {\n            v22 = v23 = 0;\n        }\n        goto {'0xc1b', '0xb73'};\n        MEM[v9] = v22;\n        MEM[v9 + 32] = v16;\n        v9 = v24 = 0;\n        STORAGE[keccak256(MEM[v24 len (64 + v9)])] = address(v9) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(MEM[v24 len (64 + v9)])];\n        v12 = v25 = new bytes[](v26);\n        v15 = v26 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n        v16 = v27 = 6;\n        v18 = v28 = 3099;\n        v20 = v29 = v25.data;\n        if (v26) {\n            if (31 >= v26) {\n                MEM[v29] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n            }\n        }\n    }\n    MEM[v9] = v22;\n    MEM[v9 + 32] = v16;\n    STORAGE[keccak256(MEM[0 len (64 + v9)])] = v9 | ~0xff & STORAGE[keccak256(MEM[0 len (64 + v9)])];\n    v30 = v31 = 32 + MEM[64];\n    if (31 < 0) {\n        _pendingNameTransfers[msg.sender] = 1;\n        if (0) {\n            while (v31 + 0 > v30) {\n                STORAGE[v32] = MEM[v30];\n                v30 += 32;\n                v32 += 1;\n            }\n        }\n    } else {\n        _pendingNameTransfers[msg.sender] = 0x0 | ~0xff & MEM[v31];\n    }\n    while (v33 + (31 + (((!(0x1 & _pendingNameTransfers[msg.sender]) << 8) - 1 & _pendingNameTransfers[msg.sender]) >> 1) >> 5) > v32) {\n        STORAGE[v32] = 0;\n        v32 += 1;\n    }\n    v34 = new array[]((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1);\n    v35 = v36 = v34.data;\n    if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v35] = STORAGE[v37];\n                v37 += 1;\n                v35 += 32;\n            } while (v36 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) <= v35);\n        } else {\n            MEM[v36] = _hasName[msg.sender] >> 8 << 8;\n        }\n    }\n    emit NameTransferAccepted(msg.sender, v34);\n    exit;\n    do {\n        MEM[v20] = STORAGE[v38];\n        v38 += 1;\n        v20 += 32;\n    } while (v20 + v15 <= v20);\n}\n\nfunction hasName(address varg0) public nonPayable { \n    return (_hasName[varg0] & ~0 + (!(_hasName[varg0] & 0x1) << 8)) >> 1 > 0;\n}\n\nfunction namePrice() public nonPayable { \n    return _namePrice;\n}\n\nfunction addresses(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x123b(v0);\n    return address(_addresses[v2]);\n}\n\nfunction authority() public nonPayable { \n    return _authority;\n}\n\nfunction setMyName(string varg0) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x8c2(v0);\n    require(!v2, 'Name taken!');\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _hasName[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = 0x123b(v0);\n    _addresses[~0x0 & (~0x0 & v7)] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[~0x0 & (~0x0 & v7)];\n    v8 = new array[](v0.length);\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v9 + v8.data] = MEM[v9 + v0.data];\n        v9 += 32;\n    }\n    v11 = v12 = v0.length + v8.data;\n    if (0x1f & v0.length) {\n        MEM[v12 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v12 - (0x1f & v0.length)];\n    }\n    emit NameSet(msg.sender, v8);\n}\n\nfunction unsetMyName() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        }\n    }\n    if (v0.length) {\n        v5 = v0.data;\n        v6 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v6 = v7 = 0;\n    }\n    _addresses[v6] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[v6];\n    v8 = v9 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[v6] = 1;\n        if (0) {\n            while (v9 + 0 > v8) {\n                STORAGE[v10] = MEM[v8];\n                v8 += 32;\n                v10 += 1;\n            }\n        }\n    } else {\n        _hasName[v6] = 0x0 | ~0xff & MEM[v9];\n    }\n    while (v11 + (31 + (((!(0x1 & _hasName[v6]) << 8) - 1 & _hasName[v6]) >> 1) >> 5) > v10) {\n        STORAGE[v10] = 0;\n        v10 += 1;\n    }\n    emit NameUnset(msg.sender);\n}\n\nfunction 0x8c2(uint256 varg0) private { \n    v0 = 0x123b(varg0);\n    v1 = v2 = address(_addresses[v0]) != 0;\n    if (address(_addresses[v0]) == 0) {\n        v3 = 0x123b(varg0);\n        v1 = v4 = 0xff & owner_6[v3];\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction setOwner(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _owner = varg1;\n    emit LogSetOwner(_owner);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x13af4035) {\n            setOwner(address);\n        } else if (0x40a73fb4 == function_selector) {\n            pendingNameTransfers(address);\n        } else if (0x562bde28 == function_selector) {\n            transferMyName(address);\n        } else if (0x5cf3d346 == function_selector) {\n            names(address);\n        } else if (0x7a9e5e4b == function_selector) {\n            setAuthority(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91fc437e == function_selector) {\n            nameTaken(string);\n        } else if (0x98e1b410 == function_selector) {\n            getMoney();\n        } else if (0xacdfa0ac == function_selector) {\n            acceptNameTranfer();\n        } else if (0xaeda352b == function_selector) {\n            hasName(address);\n        } else if (0xb22073b6 == function_selector) {\n            namePrice();\n        } else if (0xbdfe7d47 == function_selector) {\n            addresses(string);\n        } else if (0xbf7e214f == function_selector) {\n            authority();\n        } else if (0xc7857d27 == function_selector) {\n            setMyName(string);\n        } else if (0xfdb473b1 == function_selector) {\n            unsetMyName();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 20:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _namePrice; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _hasName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addresses; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pendingNameTransfers; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\naddress _authority; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nLogSetOwner(address);\nNameTransferRequested(address, address, string);\nLogSetAuthority(address);\nNameTransferAccepted(address, string);\nNameSet(address, string);\nNameUnset(address);\n\nfunction pendingNameTransfers(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[varg0] & (!(_pendingNameTransfers[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (this != address(varg1)) {\n        if (_owner != address(varg1)) {\n            if (stor_0_0_0) {\n                v0 = address(varg1);\n                v1 = varg0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                require(_authority.code.size);\n                v2, v3 = _authority.canCall(v0, this, v1).gas(msg.gas);\n                require(v2); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                return v3;\n            } else {\n                v4 = v5 = 0;\n            }\n        } else {\n            v4 = v6 = 1;\n        }\n    } else {\n        v4 = v7 = 1;\n    }\n    return v4;\n}\n\nfunction 0x123b(uint256 varg0) private { \n    if (varg0.length) {\n        v0 = MEM[varg0.data];\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction transferMyName(address varg0) public payable { \n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    require((_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1 > 0, \"You don't have a name to transfer!\");\n    if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[varg0] = 1 + (((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v0 + (31 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v1) {\n                STORAGE[v2] = STORAGE[v1];\n                v1 += 1;\n                v2 += 1;\n            }\n        }\n    } else {\n        _hasName[varg0] = _hasName[msg.sender];\n    }\n    while (v3 + (31 + (((!(0x1 & _hasName[varg0]) << 8) - 1 & _hasName[varg0]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    v4 = new bytes[](v5);\n    v5 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v6 = v7 = v4.data;\n    if (v5) {\n        if (31 < v5) {\n            do {\n                MEM[v6] = STORAGE[v8];\n                v8 += 1;\n                v6 += 32;\n            } while (v7 + v5 <= v6);\n        }\n    }\n    if (v4.length) {\n        v9 = v4.data;\n        v10 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v10 = v11 = 0;\n    }\n    owner_6[v10] = 0x1 | ~0xff & owner_6[v10];\n    v12 = (_hasName[v10] & (!(_hasName[v10] & 0x1) << 8) + ~0) >> 1;\n    v13 = new array[](v12);\n    v14 = v15 = v13.data;\n    if (v12) {\n        if (31 < v12) {\n            do {\n                MEM[v14] = STORAGE[v16];\n                v16 += 1;\n                v14 += 32;\n            } while (v15 + v12 <= v14);\n        } else {\n            MEM[v15] = _hasName[v10] >> 8 << 8;\n        }\n    }\n    emit NameTransferRequested(msg.sender, varg0, v13);\n    v17 = v18 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[msg.sender] = 1;\n        if (0) {\n            while (v18 + 0 > v17) {\n                STORAGE[v19] = MEM[v17];\n                v17 += 32;\n                v19 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = 0x0 | ~0xff & varg0;\n    }\n    while (v20 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v19) {\n        STORAGE[v19] = 0;\n        v19 += 1;\n    }\n}\n\nfunction names(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[varg0] & (!(_hasName[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _hasName[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction setAuthority(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _authority = varg1;\n    emit LogSetAuthority(_authority);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction nameTaken(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x8c2(v0);\n    return v2;\n}\n\nfunction getMoney( function_selector) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    v1 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction acceptNameTranfer() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n        }\n    }\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    if (31 < (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[msg.sender] = 1 + (((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v5 + (31 + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v6) {\n                STORAGE[v7] = STORAGE[v6];\n                v6 += 1;\n                v7 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n    }\n    while (v8 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v7) {\n        STORAGE[v7] = 0;\n        v7 += 1;\n    }\n    v9 = v10 = msg.sender;\n    v9 = v11 = 0;\n    v12 = v13 = new bytes[](v14);\n    v15 = v14 = (_pendingNameTransfers[v10] & (!(_pendingNameTransfers[v10] & 0x1) << 8) + ~0) >> 1;\n    v16 = v17 = 4;\n    v18 = v19 = 2931;\n    v20 = v21 = v13.data;\n    if (v14) {\n        if (31 >= v14) {\n            MEM[v21] = _pendingNameTransfers[v10] >> 8 << 8;\n        }\n    }\n    while (1) {\n        if (MEM[v12]) {\n            v22 = MEM[v12 + 32];\n        } else {\n            v22 = v23 = 0;\n        }\n        goto {'0xc1b', '0xb73'};\n        MEM[v9] = v22;\n        MEM[v9 + 32] = v16;\n        v9 = v24 = 0;\n        STORAGE[keccak256(MEM[v24 len (64 + v9)])] = address(v9) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(MEM[v24 len (64 + v9)])];\n        v12 = v25 = new bytes[](v26);\n        v15 = v26 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n        v16 = v27 = 6;\n        v18 = v28 = 3099;\n        v20 = v29 = v25.data;\n        if (v26) {\n            if (31 >= v26) {\n                MEM[v29] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n            }\n        }\n    }\n    MEM[v9] = v22;\n    MEM[v9 + 32] = v16;\n    STORAGE[keccak256(MEM[0 len (64 + v9)])] = v9 | ~0xff & STORAGE[keccak256(MEM[0 len (64 + v9)])];\n    v30 = v31 = 32 + MEM[64];\n    if (31 < 0) {\n        _pendingNameTransfers[msg.sender] = 1;\n        if (0) {\n            while (v31 + 0 > v30) {\n                STORAGE[v32] = MEM[v30];\n                v30 += 32;\n                v32 += 1;\n            }\n        }\n    } else {\n        _pendingNameTransfers[msg.sender] = 0x0 | ~0xff & MEM[v31];\n    }\n    while (v33 + (31 + (((!(0x1 & _pendingNameTransfers[msg.sender]) << 8) - 1 & _pendingNameTransfers[msg.sender]) >> 1) >> 5) > v32) {\n        STORAGE[v32] = 0;\n        v32 += 1;\n    }\n    v34 = new array[]((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1);\n    v35 = v36 = v34.data;\n    if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v35] = STORAGE[v37];\n                v37 += 1;\n                v35 += 32;\n            } while (v36 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) <= v35);\n        } else {\n            MEM[v36] = _hasName[msg.sender] >> 8 << 8;\n        }\n    }\n    emit NameTransferAccepted(msg.sender, v34);\n    exit;\n    do {\n        MEM[v20] = STORAGE[v38];\n        v38 += 1;\n        v20 += 32;\n    } while (v20 + v15 <= v20);\n}\n\nfunction hasName(address varg0) public nonPayable { \n    return (_hasName[varg0] & ~0 + (!(_hasName[varg0] & 0x1) << 8)) >> 1 > 0;\n}\n\nfunction namePrice() public nonPayable { \n    return _namePrice;\n}\n\nfunction addresses(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x123b(v0);\n    return address(_addresses[v2]);\n}\n\nfunction authority() public nonPayable { \n    return _authority;\n}\n\nfunction setMyName(string varg0) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x8c2(v0);\n    require(!v2, 'Name taken!');\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _hasName[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = 0x123b(v0);\n    _addresses[~0x0 & (~0x0 & v7)] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[~0x0 & (~0x0 & v7)];\n    v8 = new array[](v0.length);\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v9 + v8.data] = MEM[v9 + v0.data];\n        v9 += 32;\n    }\n    v11 = v12 = v0.length + v8.data;\n    if (0x1f & v0.length) {\n        MEM[v12 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v12 - (0x1f & v0.length)];\n    }\n    emit NameSet(msg.sender, v8);\n}\n\nfunction unsetMyName() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        }\n    }\n    if (v0.length) {\n        v5 = v0.data;\n        v6 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v6 = v7 = 0;\n    }\n    _addresses[v6] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[v6];\n    v8 = v9 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[v6] = 1;\n        if (0) {\n            while (v9 + 0 > v8) {\n                STORAGE[v10] = MEM[v8];\n                v8 += 32;\n                v10 += 1;\n            }\n        }\n    } else {\n        _hasName[v6] = 0x0 | ~0xff & MEM[v9];\n    }\n    while (v11 + (31 + (((!(0x1 & _hasName[v6]) << 8) - 1 & _hasName[v6]) >> 1) >> 5) > v10) {\n        STORAGE[v10] = 0;\n        v10 += 1;\n    }\n    emit NameUnset(msg.sender);\n}\n\nfunction 0x8c2(uint256 varg0) private { \n    v0 = 0x123b(varg0);\n    v1 = v2 = address(_addresses[v0]) != 0;\n    if (address(_addresses[v0]) == 0) {\n        v3 = 0x123b(varg0);\n        v1 = v4 = 0xff & owner_6[v3];\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction setOwner(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _owner = varg1;\n    emit LogSetOwner(_owner);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x13af4035) {\n            setOwner(address);\n        } else if (0x40a73fb4 == function_selector) {\n            pendingNameTransfers(address);\n        } else if (0x562bde28 == function_selector) {\n            transferMyName(address);\n        } else if (0x5cf3d346 == function_selector) {\n            names(address);\n        } else if (0x7a9e5e4b == function_selector) {\n            setAuthority(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91fc437e == function_selector) {\n            nameTaken(string);\n        } else if (0x98e1b410 == function_selector) {\n            getMoney();\n        } else if (0xacdfa0ac == function_selector) {\n            acceptNameTranfer();\n        } else if (0xaeda352b == function_selector) {\n            hasName(address);\n        } else if (0xb22073b6 == function_selector) {\n            namePrice();\n        } else if (0xbdfe7d47 == function_selector) {\n            addresses(string);\n        } else if (0xbf7e214f == function_selector) {\n            authority();\n        } else if (0xc7857d27 == function_selector) {\n            setMyName(string);\n        } else if (0xfdb473b1 == function_selector) {\n            unsetMyName();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 20:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _namePrice; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _hasName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addresses; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pendingNameTransfers; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\naddress _authority; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nLogSetOwner(address);\nNameTransferRequested(address, address, string);\nLogSetAuthority(address);\nNameTransferAccepted(address, string);\nNameSet(address, string);\nNameUnset(address);\n\nfunction pendingNameTransfers(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[varg0] & (!(_pendingNameTransfers[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (this != address(varg1)) {\n        if (_owner != address(varg1)) {\n            if (stor_0_0_0) {\n                v0 = address(varg1);\n                v1 = varg0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                require(_authority.code.size);\n                v2, v3 = _authority.canCall(v0, this, v1).gas(msg.gas);\n                require(v2); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                return v3;\n            } else {\n                v4 = v5 = 0;\n            }\n        } else {\n            v4 = v6 = 1;\n        }\n    } else {\n        v4 = v7 = 1;\n    }\n    return v4;\n}\n\nfunction 0x123b(uint256 varg0) private { \n    if (varg0.length) {\n        v0 = MEM[varg0.data];\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction transferMyName(address varg0) public payable { \n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    require((_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1 > 0, \"You don't have a name to transfer!\");\n    if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[varg0] = 1 + (((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v0 + (31 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v1) {\n                STORAGE[v2] = STORAGE[v1];\n                v1 += 1;\n                v2 += 1;\n            }\n        }\n    } else {\n        _hasName[varg0] = _hasName[msg.sender];\n    }\n    while (v3 + (31 + (((!(0x1 & _hasName[varg0]) << 8) - 1 & _hasName[varg0]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    v4 = new bytes[](v5);\n    v5 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v6 = v7 = v4.data;\n    if (v5) {\n        if (31 < v5) {\n            do {\n                MEM[v6] = STORAGE[v8];\n                v8 += 1;\n                v6 += 32;\n            } while (v7 + v5 <= v6);\n        }\n    }\n    if (v4.length) {\n        v9 = v4.data;\n        v10 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v10 = v11 = 0;\n    }\n    owner_6[v10] = 0x1 | ~0xff & owner_6[v10];\n    v12 = (_hasName[v10] & (!(_hasName[v10] & 0x1) << 8) + ~0) >> 1;\n    v13 = new array[](v12);\n    v14 = v15 = v13.data;\n    if (v12) {\n        if (31 < v12) {\n            do {\n                MEM[v14] = STORAGE[v16];\n                v16 += 1;\n                v14 += 32;\n            } while (v15 + v12 <= v14);\n        } else {\n            MEM[v15] = _hasName[v10] >> 8 << 8;\n        }\n    }\n    emit NameTransferRequested(msg.sender, varg0, v13);\n    v17 = v18 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[msg.sender] = 1;\n        if (0) {\n            while (v18 + 0 > v17) {\n                STORAGE[v19] = MEM[v17];\n                v17 += 32;\n                v19 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = 0x0 | ~0xff & varg0;\n    }\n    while (v20 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v19) {\n        STORAGE[v19] = 0;\n        v19 += 1;\n    }\n}\n\nfunction names(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[varg0] & (!(_hasName[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _hasName[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction setAuthority(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _authority = varg1;\n    emit LogSetAuthority(_authority);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction nameTaken(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x8c2(v0);\n    return v2;\n}\n\nfunction getMoney( function_selector) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    v1 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction acceptNameTranfer() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n        }\n    }\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    if (31 < (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[msg.sender] = 1 + (((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v5 + (31 + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v6) {\n                STORAGE[v7] = STORAGE[v6];\n                v6 += 1;\n                v7 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n    }\n    while (v8 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v7) {\n        STORAGE[v7] = 0;\n        v7 += 1;\n    }\n    v9 = v10 = msg.sender;\n    v9 = v11 = 0;\n    v12 = v13 = new bytes[](v14);\n    v15 = v14 = (_pendingNameTransfers[v10] & (!(_pendingNameTransfers[v10] & 0x1) << 8) + ~0) >> 1;\n    v16 = v17 = 4;\n    v18 = v19 = 2931;\n    v20 = v21 = v13.data;\n    if (v14) {\n        if (31 >= v14) {\n            MEM[v21] = _pendingNameTransfers[v10] >> 8 << 8;\n        }\n    }\n    while (1) {\n        if (MEM[v12]) {\n            v22 = MEM[v12 + 32];\n        } else {\n            v22 = v23 = 0;\n        }\n        goto {'0xc1b', '0xb73'};\n        MEM[v9] = v22;\n        MEM[v9 + 32] = v16;\n        v9 = v24 = 0;\n        STORAGE[keccak256(MEM[v24 len (64 + v9)])] = address(v9) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(MEM[v24 len (64 + v9)])];\n        v12 = v25 = new bytes[](v26);\n        v15 = v26 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n        v16 = v27 = 6;\n        v18 = v28 = 3099;\n        v20 = v29 = v25.data;\n        if (v26) {\n            if (31 >= v26) {\n                MEM[v29] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n            }\n        }\n    }\n    MEM[v9] = v22;\n    MEM[v9 + 32] = v16;\n    STORAGE[keccak256(MEM[0 len (64 + v9)])] = v9 | ~0xff & STORAGE[keccak256(MEM[0 len (64 + v9)])];\n    v30 = v31 = 32 + MEM[64];\n    if (31 < 0) {\n        _pendingNameTransfers[msg.sender] = 1;\n        if (0) {\n            while (v31 + 0 > v30) {\n                STORAGE[v32] = MEM[v30];\n                v30 += 32;\n                v32 += 1;\n            }\n        }\n    } else {\n        _pendingNameTransfers[msg.sender] = 0x0 | ~0xff & MEM[v31];\n    }\n    while (v33 + (31 + (((!(0x1 & _pendingNameTransfers[msg.sender]) << 8) - 1 & _pendingNameTransfers[msg.sender]) >> 1) >> 5) > v32) {\n        STORAGE[v32] = 0;\n        v32 += 1;\n    }\n    v34 = new array[]((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1);\n    v35 = v36 = v34.data;\n    if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v35] = STORAGE[v37];\n                v37 += 1;\n                v35 += 32;\n            } while (v36 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) <= v35);\n        } else {\n            MEM[v36] = _hasName[msg.sender] >> 8 << 8;\n        }\n    }\n    emit NameTransferAccepted(msg.sender, v34);\n    exit;\n    do {\n        MEM[v20] = STORAGE[v38];\n        v38 += 1;\n        v20 += 32;\n    } while (v20 + v15 <= v20);\n}\n\nfunction hasName(address varg0) public nonPayable { \n    return (_hasName[varg0] & ~0 + (!(_hasName[varg0] & 0x1) << 8)) >> 1 > 0;\n}\n\nfunction namePrice() public nonPayable { \n    return _namePrice;\n}\n\nfunction addresses(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x123b(v0);\n    return address(_addresses[v2]);\n}\n\nfunction authority() public nonPayable { \n    return _authority;\n}\n\nfunction setMyName(string varg0) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = 0x8c2(v0);\n    require(!v2, 'Name taken!');\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _hasName[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = 0x123b(v0);\n    _addresses[~0x0 & (~0x0 & v7)] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[~0x0 & (~0x0 & v7)];\n    v8 = new array[](v0.length);\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v9 + v8.data] = MEM[v9 + v0.data];\n        v9 += 32;\n    }\n    v11 = v12 = v0.length + v8.data;\n    if (0x1f & v0.length) {\n        MEM[v12 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v12 - (0x1f & v0.length)];\n    }\n    emit NameSet(msg.sender, v8);\n}\n\nfunction unsetMyName() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        }\n    }\n    if (v0.length) {\n        v5 = v0.data;\n        v6 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v6 = v7 = 0;\n    }\n    _addresses[v6] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[v6];\n    v8 = v9 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[v6] = 1;\n        if (0) {\n            while (v9 + 0 > v8) {\n                STORAGE[v10] = MEM[v8];\n                v8 += 32;\n                v10 += 1;\n            }\n        }\n    } else {\n        _hasName[v6] = 0x0 | ~0xff & MEM[v9];\n    }\n    while (v11 + (31 + (((!(0x1 & _hasName[v6]) << 8) - 1 & _hasName[v6]) >> 1) >> 5) > v10) {\n        STORAGE[v10] = 0;\n        v10 += 1;\n    }\n    emit NameUnset(msg.sender);\n}\n\nfunction 0x8c2(uint256 varg0) private { \n    v0 = 0x123b(varg0);\n    v1 = v2 = address(_addresses[v0]) != 0;\n    if (address(_addresses[v0]) == 0) {\n        v3 = 0x123b(varg0);\n        v1 = v4 = 0xff & owner_6[v3];\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction setOwner(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _owner = varg1;\n    emit LogSetOwner(_owner);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x13af4035) {\n            setOwner(address);\n        } else if (0x40a73fb4 == function_selector) {\n            pendingNameTransfers(address);\n        } else if (0x562bde28 == function_selector) {\n            transferMyName(address);\n        } else if (0x5cf3d346 == function_selector) {\n            names(address);\n        } else if (0x7a9e5e4b == function_selector) {\n            setAuthority(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91fc437e == function_selector) {\n            nameTaken(string);\n        } else if (0x98e1b410 == function_selector) {\n            getMoney();\n        } else if (0xacdfa0ac == function_selector) {\n            acceptNameTranfer();\n        } else if (0xaeda352b == function_selector) {\n            hasName(address);\n        } else if (0xb22073b6 == function_selector) {\n            namePrice();\n        } else if (0xbdfe7d47 == function_selector) {\n            addresses(string);\n        } else if (0xbf7e214f == function_selector) {\n            authority();\n        } else if (0xc7857d27 == function_selector) {\n            setMyName(string);\n        } else if (0xfdb473b1 == function_selector) {\n            unsetMyName();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 52.88316202163696,
	"usage": {
		"completion_tokens": 869,
		"prompt_tokens": 5382,
		"total_tokens": 6251
	}
}