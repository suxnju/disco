{
	"address": "0xa77cf14e0bda66f94873498ed15e1eaf183d2fd0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, a corresponding Solidity contract may look like this:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ShrimpGame {\n    //State variables\n    uint256 private _eGGS_TO_HATCH_1SHRIMP; \n    uint8 private stor_0_0_0;\n    uint256 private _sTARTING_SHRIMP; \n    uint256 private stor_2; \n    uint256 private stor_3; \n    mapping (address => uint256) private _getMyShrimp; \n    mapping (address => uint256) private _claimedEggs; \n    mapping (address => uint256) private _lastHatch; \n    mapping (address => address) private _referrals; \n    uint256 private _marketEggs; \n    mapping (address => uint256) private _hasDoubler; \n    uint256 private _currentIcePrice; \n    uint256 private _currentIceDelta; \n    uint256 private _currentGoldPrice; \n    uint256 private _currentGoldPercentIncrease; \n    uint256 private _currentDevFee; \n    bool private _initialized; \n    address payable private _ceoAddress; \n    address private _goldOwner; \n\n    // constructor\n    constructor() {\n        _ceoAddress = payable(msg.sender);\n        _initialized = false;\n        _eGGS_TO_HATCH_1SHRIMP = 86400; \n        _sTARTING_SHRIMP = 300; \n    }\n\n    // Fallback function\n    fallback() external payable { \n        revert();\n    }\n\n    // Other functions\n    //... \n\n    function seedMarket(uint256 eggs) public payable { \n        require(_marketEggs == 0);\n        _initialized = true;\n        _marketEggs = eggs;\n    }\n\n    function buyEggs() public payable { \n        require(_initialized);\n        require(msg.value <= address(this).balance);\n        uint256 eggsBought = calculateTrade(_marketEggs, address(this).balance - msg.value);\n        uint256 fee = devFee(eggsBought);\n        _claimedEggs[msg.sender] += eggsBought - fee;\n        _ceoAddress.transfer(fee);\n    }\n\n    function sellEggs() public { \n        require(_initialized);\n        uint256 hasEggs = getMyEggs();\n        uint256 eggValue = calculateTrade(hasEggs, _marketEggs);\n        uint256 fee = devFee(eggValue);\n        _claimedEggs[msg.sender] = 0;\n        _marketEggs += hasEggs;\n        _ceoAddress.transfer(fee);\n        payable(msg.sender).transfer(eggValue - fee);\n    }\n\n    // Helper functions\n    //...\n\n    function calculateTrade(uint256 rt, uint256 rs) private pure returns(uint256) { \n        return rs * (3 * rt) / (2 * rs + rt);\n    }\n\n    function devFee(uint256 amount) private pure returns(uint256) { \n        return amount / 20; // 5% dev fee\n    }\n\n    function getMyEggs() public view returns(uint256) { \n        return _claimedEggs[msg.sender] + getEggsSinceLastHatch(msg.sender);\n    }\n\n    function getEggsSinceLastHatch(address user) public view returns(uint256) { \n        uint256 secondsPassed = min(_eGGS_TO_HATCH_1SHRIMP, block.timestamp - _lastHatch[user]);\n        return _getMyShrimp[user] * secondsPassed;\n    }\n\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n```\n\nPlease note that the provided decompiled code seems incomplete and not well-structured, and hence the reconstructed contract might not represent the full functionality of the original contract. Moreover, some functions from the decompiled code are not represented here due to their unclear purpose and implementation. The provided contract should give a general idea of how the original contract might have looked.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469910,
	"id": "chatcmpl-8R6L0buMMgX8xze18FtoAodtOZzsS",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 07:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eGGS_TO_HATCH_1SHRIMP; // STORAGE[0x0]\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _sTARTING_SHRIMP; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _getMyShrimp; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _claimedEggs; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _lastHatch; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _referrals; // STORAGE[0x8]\nuint256 _marketEggs; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _hasDoubler; // STORAGE[0xa]\nuint256 _currentIcePrice; // STORAGE[0xb]\nuint256 _currentIceDelta; // STORAGE[0xc]\nuint256 _currentGoldPrice; // STORAGE[0xd]\nuint256 _currentGoldPercentIncrease; // STORAGE[0xe]\nuint256 _currentDevFee; // STORAGE[0xf]\nuint8 _initialized; // STORAGE[0x4] bytes 0 to 0\naddress _ceoAddress; // STORAGE[0x4] bytes 1 to 20\naddress _goldOwner; // STORAGE[0x10] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction hasDoubler(address varg0) public nonPayable { \n    return 0xff & _hasDoubler[varg0];\n}\n\nfunction ceoAddress() public nonPayable { \n    return _ceoAddress;\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction initialized() public nonPayable { \n    return _initialized;\n}\n\nfunction CurrentDevFee() public nonPayable { \n    return _currentDevFee;\n}\n\nfunction calculateTrade(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0, v1, v2 = 0x522(varg2, varg1);\n    return v0;\n}\n\nfunction getFreeShrimp() public nonPayable { \n    require(_initialized);\n    require(!_getMyShrimp[msg.sender]);\n    _lastHatch[msg.sender] = block.timestamp;\n    _lastHatch[msg.sender] = _sTARTING_SHRIMP;\n}\n\nfunction calculateEggBuy(uint256 varg0, uint256 varg1) public nonPayable { \n    v0, v1, v2 = 0x522(_marketEggs, varg1);\n    return v0;\n}\n\nfunction marketEggs() public nonPayable { \n    return _marketEggs;\n}\n\nfunction sellEggs() public nonPayable { \n    require(_initialized);\n    v0 = 0xa60();\n    v1, v2, v3 = 0x522((address(this)).balance, _marketEggs);\n    v4 = 0x713(v1);\n    _claimedEggs[msg.sender] = 0;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v5 = _SafeAdd(1540, _marketEggs);\n    _marketEggs = v5;\n    v6 = 0xe38(3, _getMyShrimp[msg.sender]);\n    assert(4);\n    _getMyShrimp[msg.sender] = v6 >> 2;\n    v7 = _ceoAddress.call().value(v4).gas(2300 * !v4);\n    require(v7); // checks call status, propagates error data on error\n    assert(v4 <= v1);\n    v8 = msg.sender.call().value(v1 - v4).gas(2300 * !(v1 - v4));\n    require(v8); // checks call status, propagates error data on error\n}\n\nfunction seedMarket(uint256 varg0) public payable { \n    require(!_marketEggs);\n    _initialized = 1;\n    _marketEggs = varg0;\n}\n\nfunction devFee(uint256 varg0) public nonPayable { \n    v0 = 0x713(varg0);\n    return v0;\n}\n\nfunction hatchEggs(address varg0) public nonPayable { \n    require(_initialized);\n    v0 = v1 = !address(_referrals[msg.sender]);\n    if (v1) {\n        v0 = v2 = address(_referrals[msg.sender]) != msg.sender;\n    }\n    if (v0) {\n        _referrals[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrals[msg.sender];\n    }\n    v3 = 0xa60();\n    assert(stor_0_0_0);\n    v4 = _SafeAdd(v3 / _eGGS_TO_HATCH_1SHRIMP, _getMyShrimp[msg.sender]);\n    _getMyShrimp[msg.sender] = v4;\n    _claimedEggs[msg.sender] = 0;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v5 = v6 = _claimedEggs[address(_claimedEggs[msg.sender])];\n    v7 = v8 = 2117;\n    assert(5);\n    v9 = v10 = v3 / 5;\n    while (1) {\n        v11 = _SafeAdd(v9, v5);\n        _claimedEggs[address(_referrals[msg.sender])] = v11;\n        v5 = v12 = _marketEggs;\n        v7 = v13 = 2173;\n        assert(10);\n        v9 = v3 / 10;\n        goto 0x5570x2f9;\n    }\n    _marketEggs = v11;\n}\n\nfunction BuyGold() public payable { \n    require(_initialized);\n    require(msg.value >= _currentGoldPrice);\n    require(msg.sender != _goldOwner);\n    v0 = v1 = 0;\n    if (msg.value <= _currentGoldPrice) {\n        v2 = v3 = msg.value;\n    } else {\n        v0 = v4 = msg.value - _currentGoldPrice;\n        v2 = v5 = _currentGoldPrice;\n    }\n    v6 = 0x713(v2);\n    assert(v6 <= v2);\n    v7 = 0xa60();\n    v8 = _SafeAdd(v7, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v8;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v9 = 0xdb7(_goldOwner);\n    v10 = _SafeAdd(v9, _claimedEggs[_goldOwner]);\n    _claimedEggs[_goldOwner] = v10;\n    _claimedEggs[_goldOwner] = block.timestamp;\n    v11 = 0xe38(_currentGoldPercentIncrease, _currentGoldPrice);\n    assert(100);\n    _currentGoldPrice = v11 / 100;\n    _goldOwner = msg.sender;\n    v12 = _goldOwner.call().value(v2 - v6).gas(2300 * !(v2 - v6));\n    require(v12); // checks call status, propagates error data on error\n    if (v0 > 0) {\n        v13 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v13); // checks call status, propagates error data on error\n        goto 0x28f0x31a;\n    }\n}\n\nfunction getMyEggs() public nonPayable { \n    v0 = 0xa60();\n    return v0;\n}\n\nfunction lastHatch(address varg0) public nonPayable { \n    return _lastHatch[varg0];\n}\n\nfunction buyEggs() public payable { \n    require(_initialized);\n    assert(msg.value <= this.balance);\n    v0, v1, v2 = 0x522(_marketEggs, this.balance - msg.value);\n    v3 = 0x713(v0);\n    assert(v3 <= v0);\n    v4 = 0x713(msg.value);\n    v5 = _ceoAddress.call().value(v4).gas(2300 * !v4);\n    require(v5); // checks call status, propagates error data on error\n    v6 = _SafeAdd(v0 - v3, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v6;\n}\n\nfunction CurrentIceDelta() public nonPayable { \n    return _currentIceDelta;\n}\n\nfunction CurrentGoldPrice() public nonPayable { \n    return _currentGoldPrice;\n}\n\nfunction claimedEggs(address varg0) public nonPayable { \n    return _claimedEggs[varg0];\n}\n\nfunction EGGS_TO_HATCH_1SHRIMP() public nonPayable { \n    return _eGGS_TO_HATCH_1SHRIMP;\n}\n\nfunction hatcheryShrimp(address varg0) public nonPayable { \n    return _getMyShrimp[varg0];\n}\n\nfunction calculateEggBuySimple(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x522(_marketEggs, this.balance);\n    return v0;\n}\n\nfunction calculateEggSell(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x522((address(this)).balance, _marketEggs);\n    return v0;\n}\n\nfunction referrals(address varg0) public nonPayable { \n    return address(_referrals[varg0]);\n}\n\nfunction BuyDoubler() public payable { \n    require(_initialized);\n    require(msg.value >= _currentIcePrice);\n    v0 = v1 = 0;\n    if (msg.value <= _currentIcePrice) {\n        v2 = v3 = msg.value;\n    } else {\n        v0 = v4 = msg.value - _currentIcePrice;\n        v2 = v5 = _currentIcePrice;\n    }\n    v6 = 0xa60();\n    v7 = _SafeAdd(v6, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v7;\n    _claimedEggs[msg.sender] = block.timestamp;\n    _claimedEggs[msg.sender] = 0x1 | ~0xff & _claimedEggs[msg.sender];\n    _currentIcePrice += _currentIceDelta;\n    v8 = 0x713(v2);\n    v9 = _ceoAddress.call().value(v8).gas(2300 * !v8);\n    require(v9); // checks call status, propagates error data on error\n    if (v0 <= 0) {\n        goto 0x28f0x432;\n    } else {\n        v10 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v10); // checks call status, propagates error data on error\n    }\n}\n\nfunction getMyShrimp() public nonPayable { \n    return _getMyShrimp[msg.sender];\n}\n\nfunction CurrentIcePrice() public nonPayable { \n    return _currentIcePrice;\n}\n\nfunction getEggsSinceLastHatch(address varg0) public nonPayable { \n    v0 = 0xd4b(varg0);\n    return v0;\n}\n\nfunction GoldOwner() public nonPayable { \n    return _goldOwner;\n}\n\nfunction CurrentGoldPercentIncrease() public nonPayable { \n    return _currentGoldPercentIncrease;\n}\n\nfunction getEggsOff(address varg0) public nonPayable { \n    v0 = 0xdb7(varg0);\n    return v0;\n}\n\nfunction STARTING_SHRIMP() public nonPayable { \n    return _sTARTING_SHRIMP;\n}\n\nfunction 0x522(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    varg1 = v2 = 1383;\n    varg0 = v3 = 0xe38(varg0, stor_2);\n    v0 = v4 = 1378;\n    varg1 = v5 = stor_3;\n    varg0 = v6 = 1367;\n    v0 = v7 = 1372;\n    varg1 = v8 = 0xe38(varg1, stor_2);\n    v9 = v10 = 0xe38(v0, stor_3);\n    while (1) {\n        v11 = _SafeAdd(v9, varg1);\n        assert(v0);\n        v9 = v11 / v0;\n        goto 0x5570x522;\n    }\n    assert(v11);\n    return varg0 / v11, varg1, v0;\n}\n\nfunction 0x713(uint256 varg0) private { \n    v0 = 0xe38(_currentDevFee, varg0);\n    assert(100);\n    return v0 / 100;\n}\n\nfunction 0xa60() private { \n    v0 = 0xd4b(msg.sender);\n    v1 = v2 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    if (0xff & _hasDoubler[msg.sender]) {\n        v1 = v3 = 0xe38(2, v2);\n    }\n    if (msg.sender == _goldOwner) {\n        v1 = v4 = 0xe38(4, v1);\n    }\n    return v1;\n}\n\nfunction 0xd4b(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastHatch[v0] <= block.timestamp);\n    v1 = 0xea6(block.timestamp - _lastHatch[v0], _eGGS_TO_HATCH_1SHRIMP);\n    v2 = address(varg0);\n    v3 = 0xe38(_getMyShrimp[v2], v1);\n    return v3;\n}\n\nfunction 0xdb7(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = 0xd4b(varg0);\n    v2 = v3 = _SafeAdd(v1, _claimedEggs[v0]);\n    v4 = address(varg0);\n    if (0xff & _hasDoubler[v4]) {\n        v2 = v5 = 0xe38(2, v3);\n    }\n    if (_goldOwner != address(varg0)) {\n        return v2;\n    } else {\n        v6 = 0xe38(4, v2);\n        return v6;\n    }\n}\n\nfunction 0xe38(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xea6(uint256 varg0, uint256 varg1) private { \n    if (varg1 < varg0) {\n        return varg1;\n    } else {\n        return varg0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x329ab23) {\n            hasDoubler(address);\n        } else if (0xa0f8168 == function_selector) {\n            ceoAddress();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x158ef93e == function_selector) {\n            initialized();\n        } else if (0x1ab12b10 == function_selector) {\n            CurrentDevFee();\n        } else if (0x229824c4 == function_selector) {\n            calculateTrade(uint256,uint256,uint256);\n        } else if (0x23b3c771 == function_selector) {\n            getFreeShrimp();\n        } else if (0x26fd8422 == function_selector) {\n            calculateEggBuy(uint256,uint256);\n        } else if (0x2e9392bb == function_selector) {\n            marketEggs();\n        } else if (0x3955f0fe == function_selector) {\n            sellEggs();\n        } else if (0x3b653755 == function_selector) {\n            seedMarket(uint256);\n        } else if (0x3bc0461a == function_selector) {\n            devFee(uint256);\n        } else if (0x3ec862a8 == function_selector) {\n            hatchEggs(address);\n        } else if (0x400ff9a4 == function_selector) {\n            BuyGold();\n        } else if (0x43ce7422 == function_selector) {\n            getMyEggs();\n        } else if (0x467ece79 == function_selector) {\n            lastHatch(address);\n        } else if (0x4f74acfe == function_selector) {\n            buyEggs();\n        } else if (0x5c796720 == function_selector) {\n            CurrentIceDelta();\n        } else if (0x6f253319 == function_selector) {\n            CurrentGoldPrice();\n        } else if (0x72670361 == function_selector) {\n            claimedEggs(address);\n        } else if (0x732e77d0 == function_selector) {\n            EGGS_TO_HATCH_1SHRIMP();\n        } else if (0x7e2cb974 == function_selector) {\n            hatcheryShrimp(address);\n        } else if (0x7e56fde5 == function_selector) {\n            calculateEggBuySimple(uint256);\n        } else if (0x8e316327 == function_selector) {\n            calculateEggSell(uint256);\n        } else if (0x9ca423b3 == function_selector) {\n            referrals(address);\n        } else if (0xa82cb091 == function_selector) {\n            BuyDoubler();\n        } else if (0xc2127e03 == function_selector) {\n            getMyShrimp();\n        } else if (0xca60f409 == function_selector) {\n            CurrentIcePrice();\n        } else if (0xd7c8843b == function_selector) {\n            getEggsSinceLastHatch(address);\n        } else if (0xdda13903 == function_selector) {\n            GoldOwner();\n        } else if (0xea9c2859 == function_selector) {\n            CurrentGoldPercentIncrease();\n        } else if (0xec2c8fec == function_selector) {\n            getEggsOff(address);\n        } else if (0xfb05594f == function_selector) {\n            STARTING_SHRIMP();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 07:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eGGS_TO_HATCH_1SHRIMP; // STORAGE[0x0]\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _sTARTING_SHRIMP; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _getMyShrimp; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _claimedEggs; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _lastHatch; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _referrals; // STORAGE[0x8]\nuint256 _marketEggs; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _hasDoubler; // STORAGE[0xa]\nuint256 _currentIcePrice; // STORAGE[0xb]\nuint256 _currentIceDelta; // STORAGE[0xc]\nuint256 _currentGoldPrice; // STORAGE[0xd]\nuint256 _currentGoldPercentIncrease; // STORAGE[0xe]\nuint256 _currentDevFee; // STORAGE[0xf]\nuint8 _initialized; // STORAGE[0x4] bytes 0 to 0\naddress _ceoAddress; // STORAGE[0x4] bytes 1 to 20\naddress _goldOwner; // STORAGE[0x10] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction hasDoubler(address varg0) public nonPayable { \n    return 0xff & _hasDoubler[varg0];\n}\n\nfunction ceoAddress() public nonPayable { \n    return _ceoAddress;\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction initialized() public nonPayable { \n    return _initialized;\n}\n\nfunction CurrentDevFee() public nonPayable { \n    return _currentDevFee;\n}\n\nfunction calculateTrade(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0, v1, v2 = 0x522(varg2, varg1);\n    return v0;\n}\n\nfunction getFreeShrimp() public nonPayable { \n    require(_initialized);\n    require(!_getMyShrimp[msg.sender]);\n    _lastHatch[msg.sender] = block.timestamp;\n    _lastHatch[msg.sender] = _sTARTING_SHRIMP;\n}\n\nfunction calculateEggBuy(uint256 varg0, uint256 varg1) public nonPayable { \n    v0, v1, v2 = 0x522(_marketEggs, varg1);\n    return v0;\n}\n\nfunction marketEggs() public nonPayable { \n    return _marketEggs;\n}\n\nfunction sellEggs() public nonPayable { \n    require(_initialized);\n    v0 = 0xa60();\n    v1, v2, v3 = 0x522((address(this)).balance, _marketEggs);\n    v4 = 0x713(v1);\n    _claimedEggs[msg.sender] = 0;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v5 = _SafeAdd(1540, _marketEggs);\n    _marketEggs = v5;\n    v6 = 0xe38(3, _getMyShrimp[msg.sender]);\n    assert(4);\n    _getMyShrimp[msg.sender] = v6 >> 2;\n    v7 = _ceoAddress.call().value(v4).gas(2300 * !v4);\n    require(v7); // checks call status, propagates error data on error\n    assert(v4 <= v1);\n    v8 = msg.sender.call().value(v1 - v4).gas(2300 * !(v1 - v4));\n    require(v8); // checks call status, propagates error data on error\n}\n\nfunction seedMarket(uint256 varg0) public payable { \n    require(!_marketEggs);\n    _initialized = 1;\n    _marketEggs = varg0;\n}\n\nfunction devFee(uint256 varg0) public nonPayable { \n    v0 = 0x713(varg0);\n    return v0;\n}\n\nfunction hatchEggs(address varg0) public nonPayable { \n    require(_initialized);\n    v0 = v1 = !address(_referrals[msg.sender]);\n    if (v1) {\n        v0 = v2 = address(_referrals[msg.sender]) != msg.sender;\n    }\n    if (v0) {\n        _referrals[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrals[msg.sender];\n    }\n    v3 = 0xa60();\n    assert(stor_0_0_0);\n    v4 = _SafeAdd(v3 / _eGGS_TO_HATCH_1SHRIMP, _getMyShrimp[msg.sender]);\n    _getMyShrimp[msg.sender] = v4;\n    _claimedEggs[msg.sender] = 0;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v5 = v6 = _claimedEggs[address(_claimedEggs[msg.sender])];\n    v7 = v8 = 2117;\n    assert(5);\n    v9 = v10 = v3 / 5;\n    while (1) {\n        v11 = _SafeAdd(v9, v5);\n        _claimedEggs[address(_referrals[msg.sender])] = v11;\n        v5 = v12 = _marketEggs;\n        v7 = v13 = 2173;\n        assert(10);\n        v9 = v3 / 10;\n        goto 0x5570x2f9;\n    }\n    _marketEggs = v11;\n}\n\nfunction BuyGold() public payable { \n    require(_initialized);\n    require(msg.value >= _currentGoldPrice);\n    require(msg.sender != _goldOwner);\n    v0 = v1 = 0;\n    if (msg.value <= _currentGoldPrice) {\n        v2 = v3 = msg.value;\n    } else {\n        v0 = v4 = msg.value - _currentGoldPrice;\n        v2 = v5 = _currentGoldPrice;\n    }\n    v6 = 0x713(v2);\n    assert(v6 <= v2);\n    v7 = 0xa60();\n    v8 = _SafeAdd(v7, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v8;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v9 = 0xdb7(_goldOwner);\n    v10 = _SafeAdd(v9, _claimedEggs[_goldOwner]);\n    _claimedEggs[_goldOwner] = v10;\n    _claimedEggs[_goldOwner] = block.timestamp;\n    v11 = 0xe38(_currentGoldPercentIncrease, _currentGoldPrice);\n    assert(100);\n    _currentGoldPrice = v11 / 100;\n    _goldOwner = msg.sender;\n    v12 = _goldOwner.call().value(v2 - v6).gas(2300 * !(v2 - v6));\n    require(v12); // checks call status, propagates error data on error\n    if (v0 > 0) {\n        v13 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v13); // checks call status, propagates error data on error\n        goto 0x28f0x31a;\n    }\n}\n\nfunction getMyEggs() public nonPayable { \n    v0 = 0xa60();\n    return v0;\n}\n\nfunction lastHatch(address varg0) public nonPayable { \n    return _lastHatch[varg0];\n}\n\nfunction buyEggs() public payable { \n    require(_initialized);\n    assert(msg.value <= this.balance);\n    v0, v1, v2 = 0x522(_marketEggs, this.balance - msg.value);\n    v3 = 0x713(v0);\n    assert(v3 <= v0);\n    v4 = 0x713(msg.value);\n    v5 = _ceoAddress.call().value(v4).gas(2300 * !v4);\n    require(v5); // checks call status, propagates error data on error\n    v6 = _SafeAdd(v0 - v3, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v6;\n}\n\nfunction CurrentIceDelta() public nonPayable { \n    return _currentIceDelta;\n}\n\nfunction CurrentGoldPrice() public nonPayable { \n    return _currentGoldPrice;\n}\n\nfunction claimedEggs(address varg0) public nonPayable { \n    return _claimedEggs[varg0];\n}\n\nfunction EGGS_TO_HATCH_1SHRIMP() public nonPayable { \n    return _eGGS_TO_HATCH_1SHRIMP;\n}\n\nfunction hatcheryShrimp(address varg0) public nonPayable { \n    return _getMyShrimp[varg0];\n}\n\nfunction calculateEggBuySimple(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x522(_marketEggs, this.balance);\n    return v0;\n}\n\nfunction calculateEggSell(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x522((address(this)).balance, _marketEggs);\n    return v0;\n}\n\nfunction referrals(address varg0) public nonPayable { \n    return address(_referrals[varg0]);\n}\n\nfunction BuyDoubler() public payable { \n    require(_initialized);\n    require(msg.value >= _currentIcePrice);\n    v0 = v1 = 0;\n    if (msg.value <= _currentIcePrice) {\n        v2 = v3 = msg.value;\n    } else {\n        v0 = v4 = msg.value - _currentIcePrice;\n        v2 = v5 = _currentIcePrice;\n    }\n    v6 = 0xa60();\n    v7 = _SafeAdd(v6, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v7;\n    _claimedEggs[msg.sender] = block.timestamp;\n    _claimedEggs[msg.sender] = 0x1 | ~0xff & _claimedEggs[msg.sender];\n    _currentIcePrice += _currentIceDelta;\n    v8 = 0x713(v2);\n    v9 = _ceoAddress.call().value(v8).gas(2300 * !v8);\n    require(v9); // checks call status, propagates error data on error\n    if (v0 <= 0) {\n        goto 0x28f0x432;\n    } else {\n        v10 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v10); // checks call status, propagates error data on error\n    }\n}\n\nfunction getMyShrimp() public nonPayable { \n    return _getMyShrimp[msg.sender];\n}\n\nfunction CurrentIcePrice() public nonPayable { \n    return _currentIcePrice;\n}\n\nfunction getEggsSinceLastHatch(address varg0) public nonPayable { \n    v0 = 0xd4b(varg0);\n    return v0;\n}\n\nfunction GoldOwner() public nonPayable { \n    return _goldOwner;\n}\n\nfunction CurrentGoldPercentIncrease() public nonPayable { \n    return _currentGoldPercentIncrease;\n}\n\nfunction getEggsOff(address varg0) public nonPayable { \n    v0 = 0xdb7(varg0);\n    return v0;\n}\n\nfunction STARTING_SHRIMP() public nonPayable { \n    return _sTARTING_SHRIMP;\n}\n\nfunction 0x522(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    varg1 = v2 = 1383;\n    varg0 = v3 = 0xe38(varg0, stor_2);\n    v0 = v4 = 1378;\n    varg1 = v5 = stor_3;\n    varg0 = v6 = 1367;\n    v0 = v7 = 1372;\n    varg1 = v8 = 0xe38(varg1, stor_2);\n    v9 = v10 = 0xe38(v0, stor_3);\n    while (1) {\n        v11 = _SafeAdd(v9, varg1);\n        assert(v0);\n        v9 = v11 / v0;\n        goto 0x5570x522;\n    }\n    assert(v11);\n    return varg0 / v11, varg1, v0;\n}\n\nfunction 0x713(uint256 varg0) private { \n    v0 = 0xe38(_currentDevFee, varg0);\n    assert(100);\n    return v0 / 100;\n}\n\nfunction 0xa60() private { \n    v0 = 0xd4b(msg.sender);\n    v1 = v2 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    if (0xff & _hasDoubler[msg.sender]) {\n        v1 = v3 = 0xe38(2, v2);\n    }\n    if (msg.sender == _goldOwner) {\n        v1 = v4 = 0xe38(4, v1);\n    }\n    return v1;\n}\n\nfunction 0xd4b(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastHatch[v0] <= block.timestamp);\n    v1 = 0xea6(block.timestamp - _lastHatch[v0], _eGGS_TO_HATCH_1SHRIMP);\n    v2 = address(varg0);\n    v3 = 0xe38(_getMyShrimp[v2], v1);\n    return v3;\n}\n\nfunction 0xdb7(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = 0xd4b(varg0);\n    v2 = v3 = _SafeAdd(v1, _claimedEggs[v0]);\n    v4 = address(varg0);\n    if (0xff & _hasDoubler[v4]) {\n        v2 = v5 = 0xe38(2, v3);\n    }\n    if (_goldOwner != address(varg0)) {\n        return v2;\n    } else {\n        v6 = 0xe38(4, v2);\n        return v6;\n    }\n}\n\nfunction 0xe38(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xea6(uint256 varg0, uint256 varg1) private { \n    if (varg1 < varg0) {\n        return varg1;\n    } else {\n        return varg0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x329ab23) {\n            hasDoubler(address);\n        } else if (0xa0f8168 == function_selector) {\n            ceoAddress();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x158ef93e == function_selector) {\n            initialized();\n        } else if (0x1ab12b10 == function_selector) {\n            CurrentDevFee();\n        } else if (0x229824c4 == function_selector) {\n            calculateTrade(uint256,uint256,uint256);\n        } else if (0x23b3c771 == function_selector) {\n            getFreeShrimp();\n        } else if (0x26fd8422 == function_selector) {\n            calculateEggBuy(uint256,uint256);\n        } else if (0x2e9392bb == function_selector) {\n            marketEggs();\n        } else if (0x3955f0fe == function_selector) {\n            sellEggs();\n        } else if (0x3b653755 == function_selector) {\n            seedMarket(uint256);\n        } else if (0x3bc0461a == function_selector) {\n            devFee(uint256);\n        } else if (0x3ec862a8 == function_selector) {\n            hatchEggs(address);\n        } else if (0x400ff9a4 == function_selector) {\n            BuyGold();\n        } else if (0x43ce7422 == function_selector) {\n            getMyEggs();\n        } else if (0x467ece79 == function_selector) {\n            lastHatch(address);\n        } else if (0x4f74acfe == function_selector) {\n            buyEggs();\n        } else if (0x5c796720 == function_selector) {\n            CurrentIceDelta();\n        } else if (0x6f253319 == function_selector) {\n            CurrentGoldPrice();\n        } else if (0x72670361 == function_selector) {\n            claimedEggs(address);\n        } else if (0x732e77d0 == function_selector) {\n            EGGS_TO_HATCH_1SHRIMP();\n        } else if (0x7e2cb974 == function_selector) {\n            hatcheryShrimp(address);\n        } else if (0x7e56fde5 == function_selector) {\n            calculateEggBuySimple(uint256);\n        } else if (0x8e316327 == function_selector) {\n            calculateEggSell(uint256);\n        } else if (0x9ca423b3 == function_selector) {\n            referrals(address);\n        } else if (0xa82cb091 == function_selector) {\n            BuyDoubler();\n        } else if (0xc2127e03 == function_selector) {\n            getMyShrimp();\n        } else if (0xca60f409 == function_selector) {\n            CurrentIcePrice();\n        } else if (0xd7c8843b == function_selector) {\n            getEggsSinceLastHatch(address);\n        } else if (0xdda13903 == function_selector) {\n            GoldOwner();\n        } else if (0xea9c2859 == function_selector) {\n            CurrentGoldPercentIncrease();\n        } else if (0xec2c8fec == function_selector) {\n            getEggsOff(address);\n        } else if (0xfb05594f == function_selector) {\n            STARTING_SHRIMP();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 07:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eGGS_TO_HATCH_1SHRIMP; // STORAGE[0x0]\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _sTARTING_SHRIMP; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _getMyShrimp; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _claimedEggs; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _lastHatch; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _referrals; // STORAGE[0x8]\nuint256 _marketEggs; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _hasDoubler; // STORAGE[0xa]\nuint256 _currentIcePrice; // STORAGE[0xb]\nuint256 _currentIceDelta; // STORAGE[0xc]\nuint256 _currentGoldPrice; // STORAGE[0xd]\nuint256 _currentGoldPercentIncrease; // STORAGE[0xe]\nuint256 _currentDevFee; // STORAGE[0xf]\nuint8 _initialized; // STORAGE[0x4] bytes 0 to 0\naddress _ceoAddress; // STORAGE[0x4] bytes 1 to 20\naddress _goldOwner; // STORAGE[0x10] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction hasDoubler(address varg0) public nonPayable { \n    return 0xff & _hasDoubler[varg0];\n}\n\nfunction ceoAddress() public nonPayable { \n    return _ceoAddress;\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction initialized() public nonPayable { \n    return _initialized;\n}\n\nfunction CurrentDevFee() public nonPayable { \n    return _currentDevFee;\n}\n\nfunction calculateTrade(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0, v1, v2 = 0x522(varg2, varg1);\n    return v0;\n}\n\nfunction getFreeShrimp() public nonPayable { \n    require(_initialized);\n    require(!_getMyShrimp[msg.sender]);\n    _lastHatch[msg.sender] = block.timestamp;\n    _lastHatch[msg.sender] = _sTARTING_SHRIMP;\n}\n\nfunction calculateEggBuy(uint256 varg0, uint256 varg1) public nonPayable { \n    v0, v1, v2 = 0x522(_marketEggs, varg1);\n    return v0;\n}\n\nfunction marketEggs() public nonPayable { \n    return _marketEggs;\n}\n\nfunction sellEggs() public nonPayable { \n    require(_initialized);\n    v0 = 0xa60();\n    v1, v2, v3 = 0x522((address(this)).balance, _marketEggs);\n    v4 = 0x713(v1);\n    _claimedEggs[msg.sender] = 0;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v5 = _SafeAdd(1540, _marketEggs);\n    _marketEggs = v5;\n    v6 = 0xe38(3, _getMyShrimp[msg.sender]);\n    assert(4);\n    _getMyShrimp[msg.sender] = v6 >> 2;\n    v7 = _ceoAddress.call().value(v4).gas(2300 * !v4);\n    require(v7); // checks call status, propagates error data on error\n    assert(v4 <= v1);\n    v8 = msg.sender.call().value(v1 - v4).gas(2300 * !(v1 - v4));\n    require(v8); // checks call status, propagates error data on error\n}\n\nfunction seedMarket(uint256 varg0) public payable { \n    require(!_marketEggs);\n    _initialized = 1;\n    _marketEggs = varg0;\n}\n\nfunction devFee(uint256 varg0) public nonPayable { \n    v0 = 0x713(varg0);\n    return v0;\n}\n\nfunction hatchEggs(address varg0) public nonPayable { \n    require(_initialized);\n    v0 = v1 = !address(_referrals[msg.sender]);\n    if (v1) {\n        v0 = v2 = address(_referrals[msg.sender]) != msg.sender;\n    }\n    if (v0) {\n        _referrals[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _referrals[msg.sender];\n    }\n    v3 = 0xa60();\n    assert(stor_0_0_0);\n    v4 = _SafeAdd(v3 / _eGGS_TO_HATCH_1SHRIMP, _getMyShrimp[msg.sender]);\n    _getMyShrimp[msg.sender] = v4;\n    _claimedEggs[msg.sender] = 0;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v5 = v6 = _claimedEggs[address(_claimedEggs[msg.sender])];\n    v7 = v8 = 2117;\n    assert(5);\n    v9 = v10 = v3 / 5;\n    while (1) {\n        v11 = _SafeAdd(v9, v5);\n        _claimedEggs[address(_referrals[msg.sender])] = v11;\n        v5 = v12 = _marketEggs;\n        v7 = v13 = 2173;\n        assert(10);\n        v9 = v3 / 10;\n        goto 0x5570x2f9;\n    }\n    _marketEggs = v11;\n}\n\nfunction BuyGold() public payable { \n    require(_initialized);\n    require(msg.value >= _currentGoldPrice);\n    require(msg.sender != _goldOwner);\n    v0 = v1 = 0;\n    if (msg.value <= _currentGoldPrice) {\n        v2 = v3 = msg.value;\n    } else {\n        v0 = v4 = msg.value - _currentGoldPrice;\n        v2 = v5 = _currentGoldPrice;\n    }\n    v6 = 0x713(v2);\n    assert(v6 <= v2);\n    v7 = 0xa60();\n    v8 = _SafeAdd(v7, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v8;\n    _claimedEggs[msg.sender] = block.timestamp;\n    v9 = 0xdb7(_goldOwner);\n    v10 = _SafeAdd(v9, _claimedEggs[_goldOwner]);\n    _claimedEggs[_goldOwner] = v10;\n    _claimedEggs[_goldOwner] = block.timestamp;\n    v11 = 0xe38(_currentGoldPercentIncrease, _currentGoldPrice);\n    assert(100);\n    _currentGoldPrice = v11 / 100;\n    _goldOwner = msg.sender;\n    v12 = _goldOwner.call().value(v2 - v6).gas(2300 * !(v2 - v6));\n    require(v12); // checks call status, propagates error data on error\n    if (v0 > 0) {\n        v13 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v13); // checks call status, propagates error data on error\n        goto 0x28f0x31a;\n    }\n}\n\nfunction getMyEggs() public nonPayable { \n    v0 = 0xa60();\n    return v0;\n}\n\nfunction lastHatch(address varg0) public nonPayable { \n    return _lastHatch[varg0];\n}\n\nfunction buyEggs() public payable { \n    require(_initialized);\n    assert(msg.value <= this.balance);\n    v0, v1, v2 = 0x522(_marketEggs, this.balance - msg.value);\n    v3 = 0x713(v0);\n    assert(v3 <= v0);\n    v4 = 0x713(msg.value);\n    v5 = _ceoAddress.call().value(v4).gas(2300 * !v4);\n    require(v5); // checks call status, propagates error data on error\n    v6 = _SafeAdd(v0 - v3, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v6;\n}\n\nfunction CurrentIceDelta() public nonPayable { \n    return _currentIceDelta;\n}\n\nfunction CurrentGoldPrice() public nonPayable { \n    return _currentGoldPrice;\n}\n\nfunction claimedEggs(address varg0) public nonPayable { \n    return _claimedEggs[varg0];\n}\n\nfunction EGGS_TO_HATCH_1SHRIMP() public nonPayable { \n    return _eGGS_TO_HATCH_1SHRIMP;\n}\n\nfunction hatcheryShrimp(address varg0) public nonPayable { \n    return _getMyShrimp[varg0];\n}\n\nfunction calculateEggBuySimple(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x522(_marketEggs, this.balance);\n    return v0;\n}\n\nfunction calculateEggSell(uint256 varg0) public nonPayable { \n    v0, v1, v2 = 0x522((address(this)).balance, _marketEggs);\n    return v0;\n}\n\nfunction referrals(address varg0) public nonPayable { \n    return address(_referrals[varg0]);\n}\n\nfunction BuyDoubler() public payable { \n    require(_initialized);\n    require(msg.value >= _currentIcePrice);\n    v0 = v1 = 0;\n    if (msg.value <= _currentIcePrice) {\n        v2 = v3 = msg.value;\n    } else {\n        v0 = v4 = msg.value - _currentIcePrice;\n        v2 = v5 = _currentIcePrice;\n    }\n    v6 = 0xa60();\n    v7 = _SafeAdd(v6, _claimedEggs[msg.sender]);\n    _claimedEggs[msg.sender] = v7;\n    _claimedEggs[msg.sender] = block.timestamp;\n    _claimedEggs[msg.sender] = 0x1 | ~0xff & _claimedEggs[msg.sender];\n    _currentIcePrice += _currentIceDelta;\n    v8 = 0x713(v2);\n    v9 = _ceoAddress.call().value(v8).gas(2300 * !v8);\n    require(v9); // checks call status, propagates error data on error\n    if (v0 <= 0) {\n        goto 0x28f0x432;\n    } else {\n        v10 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v10); // checks call status, propagates error data on error\n    }\n}\n\nfunction getMyShrimp() public nonPayable { \n    return _getMyShrimp[msg.sender];\n}\n\nfunction CurrentIcePrice() public nonPayable { \n    return _currentIcePrice;\n}\n\nfunction getEggsSinceLastHatch(address varg0) public nonPayable { \n    v0 = 0xd4b(varg0);\n    return v0;\n}\n\nfunction GoldOwner() public nonPayable { \n    return _goldOwner;\n}\n\nfunction CurrentGoldPercentIncrease() public nonPayable { \n    return _currentGoldPercentIncrease;\n}\n\nfunction getEggsOff(address varg0) public nonPayable { \n    v0 = 0xdb7(varg0);\n    return v0;\n}\n\nfunction STARTING_SHRIMP() public nonPayable { \n    return _sTARTING_SHRIMP;\n}\n\nfunction 0x522(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    varg1 = v2 = 1383;\n    varg0 = v3 = 0xe38(varg0, stor_2);\n    v0 = v4 = 1378;\n    varg1 = v5 = stor_3;\n    varg0 = v6 = 1367;\n    v0 = v7 = 1372;\n    varg1 = v8 = 0xe38(varg1, stor_2);\n    v9 = v10 = 0xe38(v0, stor_3);\n    while (1) {\n        v11 = _SafeAdd(v9, varg1);\n        assert(v0);\n        v9 = v11 / v0;\n        goto 0x5570x522;\n    }\n    assert(v11);\n    return varg0 / v11, varg1, v0;\n}\n\nfunction 0x713(uint256 varg0) private { \n    v0 = 0xe38(_currentDevFee, varg0);\n    assert(100);\n    return v0 / 100;\n}\n\nfunction 0xa60() private { \n    v0 = 0xd4b(msg.sender);\n    v1 = v2 = _SafeAdd(v0, _claimedEggs[msg.sender]);\n    if (0xff & _hasDoubler[msg.sender]) {\n        v1 = v3 = 0xe38(2, v2);\n    }\n    if (msg.sender == _goldOwner) {\n        v1 = v4 = 0xe38(4, v1);\n    }\n    return v1;\n}\n\nfunction 0xd4b(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastHatch[v0] <= block.timestamp);\n    v1 = 0xea6(block.timestamp - _lastHatch[v0], _eGGS_TO_HATCH_1SHRIMP);\n    v2 = address(varg0);\n    v3 = 0xe38(_getMyShrimp[v2], v1);\n    return v3;\n}\n\nfunction 0xdb7(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = 0xd4b(varg0);\n    v2 = v3 = _SafeAdd(v1, _claimedEggs[v0]);\n    v4 = address(varg0);\n    if (0xff & _hasDoubler[v4]) {\n        v2 = v5 = 0xe38(2, v3);\n    }\n    if (_goldOwner != address(varg0)) {\n        return v2;\n    } else {\n        v6 = 0xe38(4, v2);\n        return v6;\n    }\n}\n\nfunction 0xe38(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0xea6(uint256 varg0, uint256 varg1) private { \n    if (varg1 < varg0) {\n        return varg1;\n    } else {\n        return varg0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x329ab23) {\n            hasDoubler(address);\n        } else if (0xa0f8168 == function_selector) {\n            ceoAddress();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x158ef93e == function_selector) {\n            initialized();\n        } else if (0x1ab12b10 == function_selector) {\n            CurrentDevFee();\n        } else if (0x229824c4 == function_selector) {\n            calculateTrade(uint256,uint256,uint256);\n        } else if (0x23b3c771 == function_selector) {\n            getFreeShrimp();\n        } else if (0x26fd8422 == function_selector) {\n            calculateEggBuy(uint256,uint256);\n        } else if (0x2e9392bb == function_selector) {\n            marketEggs();\n        } else if (0x3955f0fe == function_selector) {\n            sellEggs();\n        } else if (0x3b653755 == function_selector) {\n            seedMarket(uint256);\n        } else if (0x3bc0461a == function_selector) {\n            devFee(uint256);\n        } else if (0x3ec862a8 == function_selector) {\n            hatchEggs(address);\n        } else if (0x400ff9a4 == function_selector) {\n            BuyGold();\n        } else if (0x43ce7422 == function_selector) {\n            getMyEggs();\n        } else if (0x467ece79 == function_selector) {\n            lastHatch(address);\n        } else if (0x4f74acfe == function_selector) {\n            buyEggs();\n        } else if (0x5c796720 == function_selector) {\n            CurrentIceDelta();\n        } else if (0x6f253319 == function_selector) {\n            CurrentGoldPrice();\n        } else if (0x72670361 == function_selector) {\n            claimedEggs(address);\n        } else if (0x732e77d0 == function_selector) {\n            EGGS_TO_HATCH_1SHRIMP();\n        } else if (0x7e2cb974 == function_selector) {\n            hatcheryShrimp(address);\n        } else if (0x7e56fde5 == function_selector) {\n            calculateEggBuySimple(uint256);\n        } else if (0x8e316327 == function_selector) {\n            calculateEggSell(uint256);\n        } else if (0x9ca423b3 == function_selector) {\n            referrals(address);\n        } else if (0xa82cb091 == function_selector) {\n            BuyDoubler();\n        } else if (0xc2127e03 == function_selector) {\n            getMyShrimp();\n        } else if (0xca60f409 == function_selector) {\n            CurrentIcePrice();\n        } else if (0xd7c8843b == function_selector) {\n            getEggsSinceLastHatch(address);\n        } else if (0xdda13903 == function_selector) {\n            GoldOwner();\n        } else if (0xea9c2859 == function_selector) {\n            CurrentGoldPercentIncrease();\n        } else if (0xec2c8fec == function_selector) {\n            getEggsOff(address);\n        } else if (0xfb05594f == function_selector) {\n            STARTING_SHRIMP();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 41.97144174575806,
	"usage": {
		"completion_tokens": 875,
		"prompt_tokens": 4314,
		"total_tokens": 5189
	}
}