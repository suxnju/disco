{
	"address": "0xe5374b3840f0782608f86e270ae389b8ee2024c4",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code seems to be that of an ERC20 token contract with additional features such as owner functionality, dividend payments, and functions to interact with other contracts. \n\nDue to the complexity, the code is not an exact representation of the original Solidity code, but it can be a basis for writing an equivalent contract. Here's a simplified version of how parts of it may look:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract Token {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    address private _owner;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\n\n    constructor () public {\n        _owner = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == _owner, \"Only the current owner can change the owner\");\n        _owner = newOwner;\n        emit OwnerChanged(msg.sender, newOwner);\n    }\n}\n```\n\nPlease note that the above code is simplified and doesn't contain all the functionality from the decompiled code, for example, dividend payments and interactions with other contracts are not implemented, and the `name`, `symbol`, and `decimals` properties are not included. Some of the operations in the decompiled code are low-level and don't have direct high-level Solidity equivalents.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463492,
	"id": "chatcmpl-8R4fUFwiLIFAlBkOSCK9PsReHGggw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 22:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x6] bytes 0 to 19\naddress _changeOwnerAccept; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nDividendsPaid(address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nDataSentToAnotherContract(address, address, bytes);\nChangeOwnerStarted(address, address);\nOwnerChanged(address, address);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x680(varg1, varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x6fd(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = 0x8b0(v0, varg1, varg0);\n    return v2;\n}\n\nfunction changeOwnerStart(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _changeOwnerAccept = varg0;\n    emit ChangeOwnerStarted(msg.sender, varg0);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction approveAllAndCall(address varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v2 = 0xcf5(v0, _balanceOf[msg.sender], varg0);\n    return v2;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeOwnerAccept() public nonPayable { \n    require(msg.sender == _changeOwnerAccept);\n    emit OwnerChanged(_owner, _changeOwnerAccept);\n    _owner = _changeOwnerAccept;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    if (this != varg0) {\n        v0 = v1 = 0x6fd(varg1, varg0, msg.sender);\n    } else {\n        v0 = v2 = 0x4f0(varg1);\n    }\n    return v0;\n}\n\nfunction withdrawAllByOwner() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_totalSupply);\n    v0 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    emit 0xa7d8b68ed2550cc41edc50024becab0ac2e170e6ee37a6e1a2b855386ba4273e(_owner, this.balance);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = 0xcf5(v0, varg1, varg0);\n    return v2;\n}\n\nfunction transferAllAndCall(address varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v2 = 0x8b0(v0, _balanceOf[msg.sender], varg0);\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction 0x4f0(uint256 varg0) private { \n    require(0 < this.balance);\n    require(0 < _totalSupply);\n    assert(_totalSupply);\n    if ((address(this)).balance / _totalSupply) {\n        v0 = v1 = varg0 * ((address(this)).balance / _totalSupply);\n        assert((address(this)).balance / _totalSupply);\n        require(v1 / ((address(this)).balance / _totalSupply) == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v3 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v3); // checks call status, propagates error data on error\n    emit DividendsPaid(msg.sender, varg0, v0);\n    return 1;\n}\n\nfunction 0x680(uint256 varg0, uint256 varg1) private { \n    require(varg0 >= 0);\n    v0 = address(varg1);\n    _allowance[v0] = varg0;\n    emit Approval(msg.sender, v0, varg0);\n    return 1;\n}\n\nfunction 0x6fd(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0 >= 0);\n    v0 = v1 = address(varg2) == msg.sender;\n    if (address(varg2) != msg.sender) {\n        v2 = address(varg2);\n        v0 = v3 = varg0 <= _allowance[msg.sender];\n    }\n    require(v0);\n    v4 = address(varg2);\n    require(varg0 <= _balanceOf[v4]);\n    v5 = address(varg2);\n    require(varg0 <= _balanceOf[v5]);\n    v6 = address(varg2);\n    _balanceOf[v6] = _balanceOf[v5] - varg0;\n    v7 = address(varg1);\n    v8 = varg0 + _balanceOf[v7];\n    require(v8 >= _balanceOf[v7]);\n    v9 = address(varg1);\n    _balanceOf[v9] = v8;\n    if (msg.sender != address(varg2)) {\n        v10 = address(varg2);\n        require(varg0 <= _allowance[msg.sender]);\n        v11 = address(varg2);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    }\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction 0x8b0(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x6fd(varg1, varg2, msg.sender);\n    v1 = new array[](varg0.length);\n    v2 = address(varg2);\n    v3 = v4 = 0;\n    while (v3 < varg0.length) {\n        MEM[v3 + v1.data] = MEM[v3 + varg0.data];\n        v3 += 32;\n    }\n    v5 = v6 = varg0.length + v1.data;\n    if (0x1f & varg0.length) {\n        MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n    }\n    require(v2.code.size);\n    v7, v8 = v2.tokenFallback(msg.sender, varg1, v1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!MEM[MEM[64]]) {\n        v9 = v10 = 0;\n    } else {\n        v11 = new array[](varg0.length);\n        v12 = v13 = 0;\n        while (v12 < varg0.length) {\n            MEM[v12 + v11.data] = MEM[v12 + varg0.data];\n            v12 += 32;\n        }\n        v14 = v15 = varg0.length + v11.data;\n        if (0x1f & varg0.length) {\n            MEM[v15 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v15 - (0x1f & varg0.length)];\n        }\n        emit DataSentToAnotherContract(msg.sender, address(varg2), v11, varg1, 96);\n        v9 = v16 = 1;\n        goto 0xa810x8b0;\n    }\n    return v9;\n}\n\nfunction 0xcf5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x680(varg1, varg2);\n    v1 = new array[](varg0.length);\n    v2 = address(varg2);\n    v3 = v4 = 0;\n    while (v3 < varg0.length) {\n        MEM[v3 + v1.data] = MEM[v3 + varg0.data];\n        v3 += 32;\n    }\n    v5 = v6 = varg0.length + v1.data;\n    if (0x1f & varg0.length) {\n        MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n    }\n    require(v2.code.size);\n    v7, v8 = v2.receiveApproval(msg.sender, varg1, this, v1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!MEM[MEM[64]]) {\n        v9 = v10 = 0;\n    } else {\n        v11 = new array[](varg0.length);\n        v12 = v13 = 0;\n        while (v12 < varg0.length) {\n            MEM[v12 + v11.data] = MEM[v12 + varg0.data];\n            v12 += 32;\n        }\n        v14 = v15 = varg0.length + v11.data;\n        if (0x1f & varg0.length) {\n            MEM[v15 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v15 - (0x1f & varg0.length)];\n        }\n        emit DataSentToAnotherContract(msg.sender, address(varg2), v11, varg1, this);\n        v9 = v16 = 1;\n        goto 0xa810xcf5;\n    }\n    return v9;\n}\n\nfunction fallback() public payable { \n}\n\nfunction takeDividends(uint256 varg0) public nonPayable { \n    v0 = 0x4f0(varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x110da10) {\n            takeDividends(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x546e1959 == function_selector) {\n            changeOwnerStart(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x816c7da4 == function_selector) {\n            approveAllAndCall(address,bytes);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9538833c == function_selector) {\n            changeOwnerAccept();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbc4e84a4 == function_selector) {\n            withdrawAllByOwner();\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd87692d9 == function_selector) {\n            transferAllAndCall(address,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 22:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x6] bytes 0 to 19\naddress _changeOwnerAccept; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nDividendsPaid(address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nDataSentToAnotherContract(address, address, bytes);\nChangeOwnerStarted(address, address);\nOwnerChanged(address, address);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x680(varg1, varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x6fd(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = 0x8b0(v0, varg1, varg0);\n    return v2;\n}\n\nfunction changeOwnerStart(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _changeOwnerAccept = varg0;\n    emit ChangeOwnerStarted(msg.sender, varg0);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction approveAllAndCall(address varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v2 = 0xcf5(v0, _balanceOf[msg.sender], varg0);\n    return v2;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeOwnerAccept() public nonPayable { \n    require(msg.sender == _changeOwnerAccept);\n    emit OwnerChanged(_owner, _changeOwnerAccept);\n    _owner = _changeOwnerAccept;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    if (this != varg0) {\n        v0 = v1 = 0x6fd(varg1, varg0, msg.sender);\n    } else {\n        v0 = v2 = 0x4f0(varg1);\n    }\n    return v0;\n}\n\nfunction withdrawAllByOwner() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_totalSupply);\n    v0 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    emit 0xa7d8b68ed2550cc41edc50024becab0ac2e170e6ee37a6e1a2b855386ba4273e(_owner, this.balance);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = 0xcf5(v0, varg1, varg0);\n    return v2;\n}\n\nfunction transferAllAndCall(address varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v2 = 0x8b0(v0, _balanceOf[msg.sender], varg0);\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction 0x4f0(uint256 varg0) private { \n    require(0 < this.balance);\n    require(0 < _totalSupply);\n    assert(_totalSupply);\n    if ((address(this)).balance / _totalSupply) {\n        v0 = v1 = varg0 * ((address(this)).balance / _totalSupply);\n        assert((address(this)).balance / _totalSupply);\n        require(v1 / ((address(this)).balance / _totalSupply) == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v3 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v3); // checks call status, propagates error data on error\n    emit DividendsPaid(msg.sender, varg0, v0);\n    return 1;\n}\n\nfunction 0x680(uint256 varg0, uint256 varg1) private { \n    require(varg0 >= 0);\n    v0 = address(varg1);\n    _allowance[v0] = varg0;\n    emit Approval(msg.sender, v0, varg0);\n    return 1;\n}\n\nfunction 0x6fd(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0 >= 0);\n    v0 = v1 = address(varg2) == msg.sender;\n    if (address(varg2) != msg.sender) {\n        v2 = address(varg2);\n        v0 = v3 = varg0 <= _allowance[msg.sender];\n    }\n    require(v0);\n    v4 = address(varg2);\n    require(varg0 <= _balanceOf[v4]);\n    v5 = address(varg2);\n    require(varg0 <= _balanceOf[v5]);\n    v6 = address(varg2);\n    _balanceOf[v6] = _balanceOf[v5] - varg0;\n    v7 = address(varg1);\n    v8 = varg0 + _balanceOf[v7];\n    require(v8 >= _balanceOf[v7]);\n    v9 = address(varg1);\n    _balanceOf[v9] = v8;\n    if (msg.sender != address(varg2)) {\n        v10 = address(varg2);\n        require(varg0 <= _allowance[msg.sender]);\n        v11 = address(varg2);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    }\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction 0x8b0(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x6fd(varg1, varg2, msg.sender);\n    v1 = new array[](varg0.length);\n    v2 = address(varg2);\n    v3 = v4 = 0;\n    while (v3 < varg0.length) {\n        MEM[v3 + v1.data] = MEM[v3 + varg0.data];\n        v3 += 32;\n    }\n    v5 = v6 = varg0.length + v1.data;\n    if (0x1f & varg0.length) {\n        MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n    }\n    require(v2.code.size);\n    v7, v8 = v2.tokenFallback(msg.sender, varg1, v1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!MEM[MEM[64]]) {\n        v9 = v10 = 0;\n    } else {\n        v11 = new array[](varg0.length);\n        v12 = v13 = 0;\n        while (v12 < varg0.length) {\n            MEM[v12 + v11.data] = MEM[v12 + varg0.data];\n            v12 += 32;\n        }\n        v14 = v15 = varg0.length + v11.data;\n        if (0x1f & varg0.length) {\n            MEM[v15 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v15 - (0x1f & varg0.length)];\n        }\n        emit DataSentToAnotherContract(msg.sender, address(varg2), v11, varg1, 96);\n        v9 = v16 = 1;\n        goto 0xa810x8b0;\n    }\n    return v9;\n}\n\nfunction 0xcf5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x680(varg1, varg2);\n    v1 = new array[](varg0.length);\n    v2 = address(varg2);\n    v3 = v4 = 0;\n    while (v3 < varg0.length) {\n        MEM[v3 + v1.data] = MEM[v3 + varg0.data];\n        v3 += 32;\n    }\n    v5 = v6 = varg0.length + v1.data;\n    if (0x1f & varg0.length) {\n        MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n    }\n    require(v2.code.size);\n    v7, v8 = v2.receiveApproval(msg.sender, varg1, this, v1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!MEM[MEM[64]]) {\n        v9 = v10 = 0;\n    } else {\n        v11 = new array[](varg0.length);\n        v12 = v13 = 0;\n        while (v12 < varg0.length) {\n            MEM[v12 + v11.data] = MEM[v12 + varg0.data];\n            v12 += 32;\n        }\n        v14 = v15 = varg0.length + v11.data;\n        if (0x1f & varg0.length) {\n            MEM[v15 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v15 - (0x1f & varg0.length)];\n        }\n        emit DataSentToAnotherContract(msg.sender, address(varg2), v11, varg1, this);\n        v9 = v16 = 1;\n        goto 0xa810xcf5;\n    }\n    return v9;\n}\n\nfunction fallback() public payable { \n}\n\nfunction takeDividends(uint256 varg0) public nonPayable { \n    v0 = 0x4f0(varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x110da10) {\n            takeDividends(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x546e1959 == function_selector) {\n            changeOwnerStart(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x816c7da4 == function_selector) {\n            approveAllAndCall(address,bytes);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9538833c == function_selector) {\n            changeOwnerAccept();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbc4e84a4 == function_selector) {\n            withdrawAllByOwner();\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd87692d9 == function_selector) {\n            transferAllAndCall(address,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 22:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x6] bytes 0 to 19\naddress _changeOwnerAccept; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nDividendsPaid(address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nDataSentToAnotherContract(address, address, bytes);\nChangeOwnerStarted(address, address);\nOwnerChanged(address, address);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x680(varg1, varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x6fd(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = 0x8b0(v0, varg1, varg0);\n    return v2;\n}\n\nfunction changeOwnerStart(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _changeOwnerAccept = varg0;\n    emit ChangeOwnerStarted(msg.sender, varg0);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction approveAllAndCall(address varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v2 = 0xcf5(v0, _balanceOf[msg.sender], varg0);\n    return v2;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeOwnerAccept() public nonPayable { \n    require(msg.sender == _changeOwnerAccept);\n    emit OwnerChanged(_owner, _changeOwnerAccept);\n    _owner = _changeOwnerAccept;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    if (this != varg0) {\n        v0 = v1 = 0x6fd(varg1, varg0, msg.sender);\n    } else {\n        v0 = v2 = 0x4f0(varg1);\n    }\n    return v0;\n}\n\nfunction withdrawAllByOwner() public nonPayable { \n    require(msg.sender == _owner);\n    require(!_totalSupply);\n    v0 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    emit 0xa7d8b68ed2550cc41edc50024becab0ac2e170e6ee37a6e1a2b855386ba4273e(_owner, this.balance);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = 0xcf5(v0, varg1, varg0);\n    return v2;\n}\n\nfunction transferAllAndCall(address varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    v2 = 0x8b0(v0, _balanceOf[msg.sender], varg0);\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction 0x4f0(uint256 varg0) private { \n    require(0 < this.balance);\n    require(0 < _totalSupply);\n    assert(_totalSupply);\n    if ((address(this)).balance / _totalSupply) {\n        v0 = v1 = varg0 * ((address(this)).balance / _totalSupply);\n        assert((address(this)).balance / _totalSupply);\n        require(v1 / ((address(this)).balance / _totalSupply) == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v3 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v3); // checks call status, propagates error data on error\n    emit DividendsPaid(msg.sender, varg0, v0);\n    return 1;\n}\n\nfunction 0x680(uint256 varg0, uint256 varg1) private { \n    require(varg0 >= 0);\n    v0 = address(varg1);\n    _allowance[v0] = varg0;\n    emit Approval(msg.sender, v0, varg0);\n    return 1;\n}\n\nfunction 0x6fd(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0 >= 0);\n    v0 = v1 = address(varg2) == msg.sender;\n    if (address(varg2) != msg.sender) {\n        v2 = address(varg2);\n        v0 = v3 = varg0 <= _allowance[msg.sender];\n    }\n    require(v0);\n    v4 = address(varg2);\n    require(varg0 <= _balanceOf[v4]);\n    v5 = address(varg2);\n    require(varg0 <= _balanceOf[v5]);\n    v6 = address(varg2);\n    _balanceOf[v6] = _balanceOf[v5] - varg0;\n    v7 = address(varg1);\n    v8 = varg0 + _balanceOf[v7];\n    require(v8 >= _balanceOf[v7]);\n    v9 = address(varg1);\n    _balanceOf[v9] = v8;\n    if (msg.sender != address(varg2)) {\n        v10 = address(varg2);\n        require(varg0 <= _allowance[msg.sender]);\n        v11 = address(varg2);\n        _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    }\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction 0x8b0(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x6fd(varg1, varg2, msg.sender);\n    v1 = new array[](varg0.length);\n    v2 = address(varg2);\n    v3 = v4 = 0;\n    while (v3 < varg0.length) {\n        MEM[v3 + v1.data] = MEM[v3 + varg0.data];\n        v3 += 32;\n    }\n    v5 = v6 = varg0.length + v1.data;\n    if (0x1f & varg0.length) {\n        MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n    }\n    require(v2.code.size);\n    v7, v8 = v2.tokenFallback(msg.sender, varg1, v1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!MEM[MEM[64]]) {\n        v9 = v10 = 0;\n    } else {\n        v11 = new array[](varg0.length);\n        v12 = v13 = 0;\n        while (v12 < varg0.length) {\n            MEM[v12 + v11.data] = MEM[v12 + varg0.data];\n            v12 += 32;\n        }\n        v14 = v15 = varg0.length + v11.data;\n        if (0x1f & varg0.length) {\n            MEM[v15 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v15 - (0x1f & varg0.length)];\n        }\n        emit DataSentToAnotherContract(msg.sender, address(varg2), v11, varg1, 96);\n        v9 = v16 = 1;\n        goto 0xa810x8b0;\n    }\n    return v9;\n}\n\nfunction 0xcf5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x680(varg1, varg2);\n    v1 = new array[](varg0.length);\n    v2 = address(varg2);\n    v3 = v4 = 0;\n    while (v3 < varg0.length) {\n        MEM[v3 + v1.data] = MEM[v3 + varg0.data];\n        v3 += 32;\n    }\n    v5 = v6 = varg0.length + v1.data;\n    if (0x1f & varg0.length) {\n        MEM[v6 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v6 - (0x1f & varg0.length)];\n    }\n    require(v2.code.size);\n    v7, v8 = v2.receiveApproval(msg.sender, varg1, this, v1).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (!MEM[MEM[64]]) {\n        v9 = v10 = 0;\n    } else {\n        v11 = new array[](varg0.length);\n        v12 = v13 = 0;\n        while (v12 < varg0.length) {\n            MEM[v12 + v11.data] = MEM[v12 + varg0.data];\n            v12 += 32;\n        }\n        v14 = v15 = varg0.length + v11.data;\n        if (0x1f & varg0.length) {\n            MEM[v15 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v15 - (0x1f & varg0.length)];\n        }\n        emit DataSentToAnotherContract(msg.sender, address(varg2), v11, varg1, this);\n        v9 = v16 = 1;\n        goto 0xa810xcf5;\n    }\n    return v9;\n}\n\nfunction fallback() public payable { \n}\n\nfunction takeDividends(uint256 varg0) public nonPayable { \n    v0 = 0x4f0(varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x110da10) {\n            takeDividends(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x546e1959 == function_selector) {\n            changeOwnerStart(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x816c7da4 == function_selector) {\n            approveAllAndCall(address,bytes);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9538833c == function_selector) {\n            changeOwnerAccept();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbc4e84a4 == function_selector) {\n            withdrawAllByOwner();\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd87692d9 == function_selector) {\n            transferAllAndCall(address,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 40.24772882461548,
	"usage": {
		"completion_tokens": 684,
		"prompt_tokens": 3916,
		"total_tokens": 4600
	}
}