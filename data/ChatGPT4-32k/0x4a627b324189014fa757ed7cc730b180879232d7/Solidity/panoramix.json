{
	"address": "0x4a627b324189014fa757ed7cc730b180879232d7",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the equivalent Solidity code for the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n\n    address public owner;\n    mapping(uint8 => bool) stor1;\n    bool public paused;\n    uint256 public stor3;\n    address public landSectorAssetAddress;\n    mapping(uint16 => uint256) totalEthBackAmountPerLandType;\n    mapping(uint256 => uint256) landSectorWithdrawnAmount;\n    mapping(uint8 => bool) stor7;\n\n    event Unpaused(address account);\n    event Paused(address account);\n    event PauserRemoved(address account);\n    event OwnershipTransferred(address previousOwner, address newOwner);\n    event PauserAdded(address account);\n    event AllowedAddressSet(address allowedAddress, bool allowedStatus);\n    event EthAddedToPool(uint16 landType, address txSender, address purchaseBy, uint256 value, uint256 at);\n    event WithdrawEther(uint256 landSector, address lord, uint256 value, uint256 at);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    modifier onlyPauser() {\n        require(stor1[msg.sender] == true, \"Caller is not the pauser\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return stor1[account];\n    }\n\n    function getLandSectorWithdrawnAmount(uint256 _landSector) public view returns (uint256) {\n        return landSectorWithdrawnAmount[_landSector];\n    }\n\n    function getAllowedAddress(address _address) public view returns (bool) {\n        return stor7[_address];\n    }\n\n    function getTotalEthBackAmountPerLandType(uint16 _landType) public view returns (uint256) {\n        return totalEthBackAmountPerLandType[_landType];\n    }\n\n    function landSectorAsset() public view returns (address) {\n        return landSectorAssetAddress;\n    }\n\n    function isOwner() public view returns (bool) {\n        return (msg.sender == owner);\n    }\n\n    function unpause() public onlyPauser {\n        require(paused == true, \"Already unpaused\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    function pause() public onlyPauser {\n        require(paused == false, \"Already paused\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function renouncePauser() public onlyPauser {\n        stor1[msg.sender] = false;\n        emit PauserRemoved(msg.sender);\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n\n    function setLandSectorAssetAddress(address _landSectorAssetAddress) public onlyOwner {\n        landSectorAssetAddress = _landSectorAssetAddress;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function addPauser(address account) public onlyPauser {\n        require(account != address(0), \"Account is the zero address\");\n        require(!stor1[account], \"Account is already a pauser\");\n        stor1[account] = true;\n        emit PauserAdded(account);\n    }\n\n    function setAllowedAddress(address _address, bool desired) public onlyOwner {\n        stor7[_address] = desired;\n        emit AllowedAddressSet(_address, desired);\n    }\n\n    // Other functions omitted for brevity\n}\n```\n\nPlease note that the above Solidity code is a simplified version and doesn't include all the functions given in the decompiled code, especially those making external calls to `landSectorAssetAddress`. You might have to replace these external calls with function calls to an interface that represents the `landSectorAssetAddress` contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472386,
	"id": "chatcmpl-8Mupuabm0w08CwJ8SJpDjxwQGwVGB",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is mapping of uint8 at storage 1\n  paused is uint8 at storage 2\n  stor3 is uint256 at storage 3\n  landSectorAssetAddress is address at storage 4\n  totalEthBackAmountPerLandType is mapping of uint256 at storage 5\n  landSectorWithdrawnAmount is mapping of uint256 at storage 6\n  stor7 is mapping of uint8 at storage 7\n\ndef isPauser(address account): # not payable\n  require calldata.size - 4 >= 32\n  require account\n  return bool(stor1[address(account)])\n\ndef paused(): # not payable\n  return bool(paused)\n\ndef getLandSectorWithdrawnAmount(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  return landSectorWithdrawnAmount[_landSector]\n\ndef owner(): # not payable\n  return owner\n\ndef getAllowedAddress(address _address): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor7[address(_address)])\n\ndef getTotalEthBackAmountPerLandType(uint16 _landType): # not payable\n  require calldata.size - 4 >= 32\n  return totalEthBackAmountPerLandType[_landType << 240]\n\ndef landSectorAsset(): # not payable\n  return landSectorAssetAddress\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef isOwner(): # not payable\n  return (caller == owner)\n\ndef unpause(): # not payable\n  require caller\n  require stor1[caller]\n  require paused\n  paused = 0\n  log Unpaused(address account=caller)\n\ndef pause(): # not payable\n  require caller\n  require stor1[caller]\n  require not paused\n  paused = 1\n  log Paused(address account=caller)\n\ndef renouncePauser(): # not payable\n  require caller\n  require stor1[caller]\n  stor1[caller] = 0\n  log PauserRemoved(address account=caller)\n\ndef renounceOwnership(): # not payable\n  require caller == owner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef setLandSectorAssetAddress(address _landSectorAssetAddress): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  landSectorAssetAddress = _landSectorAssetAddress\n\ndef transferOwnership(address newOwner): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef addPauser(address account): # not payable\n  require calldata.size - 4 >= 32\n  require caller\n  require stor1[caller]\n  require account\n  require not stor1[address(account)]\n  stor1[address(account)] = 1\n  log PauserAdded(address account=account)\n\ndef setAllowedAddress(address _address, bool desired): # not payable\n  require calldata.size - 4 >= 64\n  require caller == owner\n  stor7[address(_address)] = uint8(desired)\n  log AllowedAddressSet(\n        address allowedAddress=address(_address),\n        bool allowedStatus=desired)\n\ndef addEthToLandPool(uint16 _landType, address _purchaseBy) payable: \n  require calldata.size - 4 >= 64\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getTotalVolume(uint16 _landType) with:\n          gas gas_remaining wei\n         args _landType\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0] > 0\n  require stor7[caller]\n  totalEthBackAmountPerLandType[_landType << 240] += call.value\n  log EthAddedToPool(\n        uint16 landType=caller,\n        address txSender=call.value,\n        address purchaseBy=block.timestamp,\n        uint256 value=_landType,\n        uint256 at=_purchaseBy)\n  require stor3 == stor3\n\ndef getLandSectorWithdrawableBalance(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 64\n  if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= 0 / ext_call.return_data[32]\n      return ((0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector])\n  require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n  require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n  require ext_call.return_data[32] > 0\n  require ext_call.return_data[32]\n  require landSectorWithdrawnAmount[_landSector] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n  return ((totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector])\n\ndef getWithdrawableBalance(address user): # not payable\n  require calldata.size - 4 >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args user\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args address(user), idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      mem[96 len 64] = ext_call.return_data[0 len 64]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  return s\n\ndef withdrawMyReward(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.ownerOf(uint256 tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[12 len 20] == caller\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 64\n  if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= 0 / ext_call.return_data[32]\n      require (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] > 0\n      landSectorWithdrawnAmount[_landSector] = 0 / ext_call.return_data[32]\n      call caller with:\n         value (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log WithdrawEther(\n            uint256 landSector=(0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector],\n            address lord=block.timestamp,\n            uint256 value=_landSector,\n            uint256 at=caller)\n  else:\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      require (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] > 0\n      landSectorWithdrawnAmount[_landSector] = totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      call caller with:\n         value (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log WithdrawEther(\n            uint256 landSector=(totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector],\n            address lord=block.timestamp,\n            uint256 value=_landSector,\n            uint256 at=caller)\n  require stor3 == stor3\n\ndef withdrawMyAllRewards(): # not payable\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args caller, idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      mem[96 len 64] = ext_call.return_data[0 len 64]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  require s > 0\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args caller, idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          landSectorWithdrawnAmount[ext_call.return_data[0]] = 0 / ext_call.return_data[32]\n          mem[96] = (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          mem[128] = block.timestamp\n          log WithdrawEther(\n                uint256 landSector=(0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]],\n                address lord=block.timestamp,\n                uint256 value=ext_call.return_data[0],\n                uint256 at=caller)\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      landSectorWithdrawnAmount[ext_call.return_data[0]] = totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      mem[96] = (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      mem[128] = block.timestamp\n      log WithdrawEther(\n            uint256 landSector=(totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]],\n            address lord=block.timestamp,\n            uint256 value=ext_call.return_data[0],\n            uint256 at=caller)\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  call caller with:\n     value s wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require stor3 == stor3\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is mapping of uint8 at storage 1\n  paused is uint8 at storage 2\n  stor3 is uint256 at storage 3\n  landSectorAssetAddress is address at storage 4\n  totalEthBackAmountPerLandType is mapping of uint256 at storage 5\n  landSectorWithdrawnAmount is mapping of uint256 at storage 6\n  stor7 is mapping of uint8 at storage 7\n\ndef isPauser(address account): # not payable\n  require calldata.size - 4 >= 32\n  require account\n  return bool(stor1[address(account)])\n\ndef paused(): # not payable\n  return bool(paused)\n\ndef getLandSectorWithdrawnAmount(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  return landSectorWithdrawnAmount[_landSector]\n\ndef owner(): # not payable\n  return owner\n\ndef getAllowedAddress(address _address): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor7[address(_address)])\n\ndef getTotalEthBackAmountPerLandType(uint16 _landType): # not payable\n  require calldata.size - 4 >= 32\n  return totalEthBackAmountPerLandType[_landType << 240]\n\ndef landSectorAsset(): # not payable\n  return landSectorAssetAddress\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef isOwner(): # not payable\n  return (caller == owner)\n\ndef unpause(): # not payable\n  require caller\n  require stor1[caller]\n  require paused\n  paused = 0\n  log Unpaused(address account=caller)\n\ndef pause(): # not payable\n  require caller\n  require stor1[caller]\n  require not paused\n  paused = 1\n  log Paused(address account=caller)\n\ndef renouncePauser(): # not payable\n  require caller\n  require stor1[caller]\n  stor1[caller] = 0\n  log PauserRemoved(address account=caller)\n\ndef renounceOwnership(): # not payable\n  require caller == owner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef setLandSectorAssetAddress(address _landSectorAssetAddress): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  landSectorAssetAddress = _landSectorAssetAddress\n\ndef transferOwnership(address newOwner): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef addPauser(address account): # not payable\n  require calldata.size - 4 >= 32\n  require caller\n  require stor1[caller]\n  require account\n  require not stor1[address(account)]\n  stor1[address(account)] = 1\n  log PauserAdded(address account=account)\n\ndef setAllowedAddress(address _address, bool desired): # not payable\n  require calldata.size - 4 >= 64\n  require caller == owner\n  stor7[address(_address)] = uint8(desired)\n  log AllowedAddressSet(\n        address allowedAddress=address(_address),\n        bool allowedStatus=desired)\n\ndef addEthToLandPool(uint16 _landType, address _purchaseBy) payable: \n  require calldata.size - 4 >= 64\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getTotalVolume(uint16 _landType) with:\n          gas gas_remaining wei\n         args _landType\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0] > 0\n  require stor7[caller]\n  totalEthBackAmountPerLandType[_landType << 240] += call.value\n  log EthAddedToPool(\n        uint16 landType=caller,\n        address txSender=call.value,\n        address purchaseBy=block.timestamp,\n        uint256 value=_landType,\n        uint256 at=_purchaseBy)\n  require stor3 == stor3\n\ndef getLandSectorWithdrawableBalance(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 64\n  if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= 0 / ext_call.return_data[32]\n      return ((0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector])\n  require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n  require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n  require ext_call.return_data[32] > 0\n  require ext_call.return_data[32]\n  require landSectorWithdrawnAmount[_landSector] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n  return ((totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector])\n\ndef getWithdrawableBalance(address user): # not payable\n  require calldata.size - 4 >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args user\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args address(user), idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      mem[96 len 64] = ext_call.return_data[0 len 64]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  return s\n\ndef withdrawMyReward(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.ownerOf(uint256 tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[12 len 20] == caller\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 64\n  if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= 0 / ext_call.return_data[32]\n      require (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] > 0\n      landSectorWithdrawnAmount[_landSector] = 0 / ext_call.return_data[32]\n      call caller with:\n         value (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log WithdrawEther(\n            uint256 landSector=(0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector],\n            address lord=block.timestamp,\n            uint256 value=_landSector,\n            uint256 at=caller)\n  else:\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      require (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] > 0\n      landSectorWithdrawnAmount[_landSector] = totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      call caller with:\n         value (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log WithdrawEther(\n            uint256 landSector=(totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector],\n            address lord=block.timestamp,\n            uint256 value=_landSector,\n            uint256 at=caller)\n  require stor3 == stor3\n\ndef withdrawMyAllRewards(): # not payable\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args caller, idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      mem[96 len 64] = ext_call.return_data[0 len 64]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  require s > 0\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args caller, idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          landSectorWithdrawnAmount[ext_call.return_data[0]] = 0 / ext_call.return_data[32]\n          mem[96] = (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          mem[128] = block.timestamp\n          log WithdrawEther(\n                uint256 landSector=(0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]],\n                address lord=block.timestamp,\n                uint256 value=ext_call.return_data[0],\n                uint256 at=caller)\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      landSectorWithdrawnAmount[ext_call.return_data[0]] = totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      mem[96] = (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      mem[128] = block.timestamp\n      log WithdrawEther(\n            uint256 landSector=(totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]],\n            address lord=block.timestamp,\n            uint256 value=ext_call.return_data[0],\n            uint256 at=caller)\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  call caller with:\n     value s wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require stor3 == stor3\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  stor1 is mapping of uint8 at storage 1\n  paused is uint8 at storage 2\n  stor3 is uint256 at storage 3\n  landSectorAssetAddress is address at storage 4\n  totalEthBackAmountPerLandType is mapping of uint256 at storage 5\n  landSectorWithdrawnAmount is mapping of uint256 at storage 6\n  stor7 is mapping of uint8 at storage 7\n\ndef isPauser(address account): # not payable\n  require calldata.size - 4 >= 32\n  require account\n  return bool(stor1[address(account)])\n\ndef paused(): # not payable\n  return bool(paused)\n\ndef getLandSectorWithdrawnAmount(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  return landSectorWithdrawnAmount[_landSector]\n\ndef owner(): # not payable\n  return owner\n\ndef getAllowedAddress(address _address): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor7[address(_address)])\n\ndef getTotalEthBackAmountPerLandType(uint16 _landType): # not payable\n  require calldata.size - 4 >= 32\n  return totalEthBackAmountPerLandType[_landType << 240]\n\ndef landSectorAsset(): # not payable\n  return landSectorAssetAddress\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef isOwner(): # not payable\n  return (caller == owner)\n\ndef unpause(): # not payable\n  require caller\n  require stor1[caller]\n  require paused\n  paused = 0\n  log Unpaused(address account=caller)\n\ndef pause(): # not payable\n  require caller\n  require stor1[caller]\n  require not paused\n  paused = 1\n  log Paused(address account=caller)\n\ndef renouncePauser(): # not payable\n  require caller\n  require stor1[caller]\n  stor1[caller] = 0\n  log PauserRemoved(address account=caller)\n\ndef renounceOwnership(): # not payable\n  require caller == owner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef setLandSectorAssetAddress(address _landSectorAssetAddress): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  landSectorAssetAddress = _landSectorAssetAddress\n\ndef transferOwnership(address newOwner): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef addPauser(address account): # not payable\n  require calldata.size - 4 >= 32\n  require caller\n  require stor1[caller]\n  require account\n  require not stor1[address(account)]\n  stor1[address(account)] = 1\n  log PauserAdded(address account=account)\n\ndef setAllowedAddress(address _address, bool desired): # not payable\n  require calldata.size - 4 >= 64\n  require caller == owner\n  stor7[address(_address)] = uint8(desired)\n  log AllowedAddressSet(\n        address allowedAddress=address(_address),\n        bool allowedStatus=desired)\n\ndef addEthToLandPool(uint16 _landType, address _purchaseBy) payable: \n  require calldata.size - 4 >= 64\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getTotalVolume(uint16 _landType) with:\n          gas gas_remaining wei\n         args _landType\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0] > 0\n  require stor7[caller]\n  totalEthBackAmountPerLandType[_landType << 240] += call.value\n  log EthAddedToPool(\n        uint16 landType=caller,\n        address txSender=call.value,\n        address purchaseBy=block.timestamp,\n        uint256 value=_landType,\n        uint256 at=_purchaseBy)\n  require stor3 == stor3\n\ndef getLandSectorWithdrawableBalance(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 64\n  if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= 0 / ext_call.return_data[32]\n      return ((0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector])\n  require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n  require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n  require ext_call.return_data[32] > 0\n  require ext_call.return_data[32]\n  require landSectorWithdrawnAmount[_landSector] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n  return ((totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector])\n\ndef getWithdrawableBalance(address user): # not payable\n  require calldata.size - 4 >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args user\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args address(user), idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      mem[96 len 64] = ext_call.return_data[0 len 64]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  return s\n\ndef withdrawMyReward(uint256 _landSector): # not payable\n  require calldata.size - 4 >= 32\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.ownerOf(uint256 tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[12 len 20] == caller\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n          gas gas_remaining wei\n         args _landSector\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 64\n  if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= 0 / ext_call.return_data[32]\n      require (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] > 0\n      landSectorWithdrawnAmount[_landSector] = 0 / ext_call.return_data[32]\n      call caller with:\n         value (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log WithdrawEther(\n            uint256 landSector=(0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector],\n            address lord=block.timestamp,\n            uint256 value=_landSector,\n            uint256 at=caller)\n  else:\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[_landSector] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      require (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] > 0\n      landSectorWithdrawnAmount[_landSector] = totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      call caller with:\n         value (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log WithdrawEther(\n            uint256 landSector=(totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[_landSector],\n            address lord=block.timestamp,\n            uint256 value=_landSector,\n            uint256 at=caller)\n  require stor3 == stor3\n\ndef withdrawMyAllRewards(): # not payable\n  require not paused\n  stor3++\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args caller, idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      mem[96 len 64] = ext_call.return_data[0 len 64]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  require s > 0\n  require ext_code.size(landSectorAssetAddress)\n  static call landSectorAssetAddress.balanceOf(address account) with:\n          gas gas_remaining wei\n         args caller\n  mem[96] = ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  idx = mem[96]\n  s = 0\n  while idx > 0:\n      mem[132] = idx - 1\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.tokenOfOwnerByIndex(address owner, uint256 index) with:\n              gas gas_remaining wei\n             args caller, idx - 1\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.isValidLandSector(uint256 _tokenId) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_call.return_data[0]\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getLandType(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require ext_code.size(landSectorAssetAddress)\n      static call landSectorAssetAddress.getShareRateWithDecimal(uint256 _landSector) with:\n              gas gas_remaining wei\n             args ext_call.return_data[0]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 64\n      if not totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]:\n          require ext_call.return_data[32] > 0\n          require ext_call.return_data[32]\n          require landSectorWithdrawnAmount[ext_call.return_data[0]] <= 0 / ext_call.return_data[32]\n          mem[0] = ext_call.return_data[0]\n          mem[32] = 6\n          landSectorWithdrawnAmount[ext_call.return_data[0]] = 0 / ext_call.return_data[32]\n          mem[96] = (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          mem[128] = block.timestamp\n          log WithdrawEther(\n                uint256 landSector=(0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]],\n                address lord=block.timestamp,\n                uint256 value=ext_call.return_data[0],\n                uint256 at=caller)\n          idx = idx - 1\n          s = s + (0 / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n          continue \n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240]\n      require totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] == ext_call.return_data[0]\n      require ext_call.return_data[32] > 0\n      require ext_call.return_data[32]\n      require landSectorWithdrawnAmount[ext_call.return_data[0]] <= totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      mem[0] = ext_call.return_data[0]\n      mem[32] = 6\n      landSectorWithdrawnAmount[ext_call.return_data[0]] = totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]\n      mem[96] = (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      mem[128] = block.timestamp\n      log WithdrawEther(\n            uint256 landSector=(totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]],\n            address lord=block.timestamp,\n            uint256 value=ext_call.return_data[0],\n            uint256 at=caller)\n      idx = idx - 1\n      s = s + (totalEthBackAmountPerLandType[ext_call.return_data[0] << 240] * ext_call.return_data[0] / ext_call.return_data[32]) - landSectorWithdrawnAmount[ext_call.return_data[0]]\n      continue \n  call caller with:\n     value s wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require stor3 == stor3\n\n.",
	"status": "1",
	"time_cost": 48.37595772743225,
	"usage": {
		"completion_tokens": 817,
		"prompt_tokens": 5371,
		"total_tokens": 6188
	}
}