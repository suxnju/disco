{
	"address": "0x5eee354e36ac51e9d3f7283005cab0c55f423b23",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a Solidity version of the contract code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Contract {\n    mapping(address => uint256) private _balances;\n    address private _owner;\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function renounceOwnership() public {\n        require(msg.sender == _owner, \"Only owner can renounce ownership.\");\n        _owner = address(0);\n    }\n\n    function ethBalanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function withdrawAll() public {\n        uint256 amount = _balances[msg.sender];\n        require(amount > 0, \"User holds nothing.\");\n        _balances[msg.sender] = 0;\n        msg.sender.transfer(amount);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner, \"Only owner can transfer ownership.\");\n        require(newOwner != address(0), \"New owner cannot be zero address.\");\n        _owner = newOwner;\n    }\n\n    function buy() public payable {\n        require(msg.value > 0, \"Should be more than 0.0001 ether sent.\");\n        _balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"User can't withdraw more than he holds.\");\n        _balances[msg.sender] -= amount;\n        msg.sender.transfer(amount);\n    }\n}\n```\n\nThis is a simplified version of the decompiled code, however, it captures the primary functionality. The original decompiled code seems to be more complex and likely contains additional features or checks. If you need a more accurate version, please provide more context or the original EVM bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471495,
	"id": "chatcmpl-8MubX91ojdaekZywYh6F8H4CLrbBf",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length < 0x04) {\n        label_008D:\n            var var0 = 0x0095;\n            var var1 = msg.sender;\n            var var2 = 0x00;\n            var var3 = var2;\n            var var4 = var3;\n        \n            if (msg.value >= storage[0x03]) {\n                var var5 = 0x0213;\n                var var6 = msg.value;\n                var var7 = 0x0207;\n                var7 = getBalance();\n            \n            label_0207:\n                var temp0 = var6;\n                var6 = var7;\n                var7 = temp0;\n                var var8 = 0x00;\n            \n                if (var7 > var6) { assert(); }\n            \n                var8 = var6 - var7;\n                var5 = var8;\n                // Error: Could not resolve jump destination!\n            } else {\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = 0x20;\n                memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = 0x24;\n                memory[temp1 + 0x44:temp1 + 0x44 + 0x20] = 0x73686f756c64206265206d6f72652074686520302e3030303120657468657220;\n                memory[temp1 + 0x64:temp1 + 0x64 + 0x20] = 0x73656e7400000000000000000000000000000000000000000000000000000000;\n                var temp2 = memory[0x40:0x60];\n                revert(memory[temp2:temp2 + temp1 - temp2 + 0x84]);\n            }\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x12065fe0) {\n                // Dispatch table entry for getBalance()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00ac;\n                var1 = getBalance();\n            \n            label_00AC:\n                var temp3 = memory[0x40:0x60];\n                memory[temp3:temp3 + 0x20] = var1;\n                var temp4 = memory[0x40:0x60];\n                return memory[temp4:temp4 + temp3 - temp4 + 0x20];\n            } else if (var0 == 0x2e1a7d4d) {\n                // Dispatch table entry for withdraw(uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                var2 = msg.data[0x04:0x24];\n                var3 = msg.sender;\n            \n                if (var2 > 0x00) {\n                    var4 = 0x03d5;\n                    var5 = var3;\n                    var4 = ethBalanceOf(var5);\n                \n                    if (var2 <= var4) {\n                        var temp5 = memory[0x40:0x60];\n                        var temp6 = var2;\n                        var temp7;\n                        temp7, memory[temp5:temp5 + 0x00] = address(var3 & 0x02 ** 0xa0 - 0x01).call.gas(!temp6 * 0x08fc).value(temp6)(memory[temp5:temp5 + 0x00]);\n                        var4 = !temp7;\n                    \n                        if (!var4) {\n                            var4 = 0x0496;\n                            var5 = var2;\n                            var6 = 0x0207;\n                            var7 = var3;\n                            var6 = ethBalanceOf(var7);\n                            goto label_0207;\n                        } else {\n                            var temp8 = returndata.length;\n                            memory[0x00:0x00 + temp8] = returndata[0x00:0x00 + temp8];\n                            revert(memory[0x00:0x00 + returndata.length]);\n                        }\n                    } else {\n                        var temp9 = memory[0x40:0x60];\n                        memory[temp9:temp9 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                        memory[temp9 + 0x04:temp9 + 0x04 + 0x20] = 0x20;\n                        memory[temp9 + 0x24:temp9 + 0x24 + 0x20] = 0x26;\n                        memory[temp9 + 0x44:temp9 + 0x44 + 0x20] = 0x757365722063616e74207769746864726177206d6f7265207468656e20686520;\n                        memory[temp9 + 0x64:temp9 + 0x64 + 0x20] = 0x686f6c6473200000000000000000000000000000000000000000000000000000;\n                        var temp10 = memory[0x40:0x60];\n                        revert(memory[temp10:temp10 + temp9 - temp10 + 0x84]);\n                    }\n                } else {\n                    var temp11 = memory[0x40:0x60];\n                    memory[temp11:temp11 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                    memory[temp11 + 0x04:temp11 + 0x04 + 0x20] = 0x20;\n                    memory[temp11 + 0x24:temp11 + 0x24 + 0x20] = 0x28;\n                    memory[temp11 + 0x44:temp11 + 0x44 + 0x20] = 0x757365722063616e74207370616d207472616e73616374696f6e732077697468;\n                    memory[temp11 + 0x64:temp11 + 0x64 + 0x20] = 0x20302076616c7565000000000000000000000000000000000000000000000000;\n                    var temp12 = memory[0x40:0x60];\n                    revert(memory[temp12:temp12 + temp11 - temp12 + 0x84]);\n                }\n            } else if (var0 == 0x715018a6) {\n                // Dispatch table entry for renounceOwnership()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                renounceOwnership();\n                stop();\n            } else if (var0 == 0x7252bbf2) {\n                // Dispatch table entry for ethBalanceOf(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00ac;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = ethBalanceOf(var2);\n                goto label_00AC;\n            } else if (var0 == 0x853828b6) {\n                // Dispatch table entry for withdrawAll()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                withdrawAll();\n                stop();\n            } else if (var0 == 0x8da5cb5b) {\n                // Dispatch table entry for owner()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0136;\n                var2 = owner();\n                var temp13 = memory[0x40:0x60];\n                memory[temp13:temp13 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp14 = memory[0x40:0x60];\n                return memory[temp14:temp14 + temp13 - temp14 + 0x20];\n            } else if (var0 == 0xa6f2ae3a) { goto label_008D; }\n                // Dispatch table entry for buy()\n            else if (var0 == 0xf2fde38b) {\n                // Dispatch table entry for transferOwnership(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                transferOwnership(var2);\n                stop();\n            } else { goto label_008D; }\n        }\n    }\n    \n    function getBalance() returns (var r0) { return address(this).balance; }\n    \n    function renounceOwnership() {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        log(memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x00], [0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820, storage[0x00] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff;\n    }\n    \n    function ethBalanceOf(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var temp0 = storage[keccak256(memory[0x00:0x40])];\n        memory[0x20:0x40] = 0x02;\n        var var0 = 0x00;\n        var var3 = storage[0x05];\n        var var1 = 0x047bf19673df52e37f2410011d100000000000;\n        var var2 = 0x0604;\n        var var4 = 0x05f8;\n        var var5 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var6 = temp0;\n        var4 = func_07A2(var5, var6);\n        var2 = func_05F8(var3, var4);\n    \n        if (var1) { return var2 / var1; }\n        else { assert(); }\n    }\n    \n    function func_05F8(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = arg1;\n        arg1 = temp0;\n        r0 = func_07A2(arg0, arg1);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function withdrawAll() {\n        var var0 = msg.sender;\n        var var1 = 0x00;\n        var var2 = 0x0620;\n        var var3 = var0;\n        var2 = ethBalanceOf(var3);\n        var1 = var2;\n    \n        if (var1 > 0x00) {\n            var temp0 = memory[0x40:0x60];\n            var temp1 = var1;\n            var temp2;\n            temp2, memory[temp0:temp0 + 0x00] = address(var0 & 0x02 ** 0xa0 - 0x01).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);\n            var2 = !temp2;\n        \n            if (!var2) {\n                memory[0x00:0x20] = var0 & 0x02 ** 0xa0 - 0x01;\n                memory[0x20:0x40] = 0x02;\n                storage[keccak256(memory[0x00:0x40])] = 0x00;\n                var2 = storage[0x05];\n                var3 = 0x047bf19673df52e37f2410011d100000000000;\n            \n                if (!var2) { assert(); }\n            \n                memory[0x00:0x20] = var0 & 0x02 ** 0xa0 - 0x01;\n                memory[0x20:0x40] = 0x01;\n                var temp3 = var3 / var2;\n                var2 = var0 & 0x02 ** 0xa0 - 0x01;\n                storage[keccak256(memory[0x00:0x40])] = temp3;\n                var3 = 0x90ebb005d68efee044927e1e77e1fd0cecc508368aa72c39250a787eed5f0a70;\n                var var4 = var1;\n                var var5 = 0x0518;\n                var5 = getBalance();\n                var temp4 = memory[0x40:0x60];\n                memory[temp4:temp4 + 0x20] = var4;\n                memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var5;\n                memory[temp4 + 0x40:temp4 + 0x40 + 0x20] = block.timestamp;\n                var temp5 = memory[0x40:0x60];\n                log(memory[temp5:temp5 + temp4 - temp5 + 0x60], [stack[-3], stack[-4]]);\n                return;\n            } else {\n                var temp6 = returndata.length;\n                memory[0x00:0x00 + temp6] = returndata[0x00:0x00 + temp6];\n                revert(memory[0x00:0x00 + returndata.length]);\n            }\n        } else {\n            var temp7 = memory[0x40:0x60];\n            memory[temp7:temp7 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n            memory[temp7 + 0x04:temp7 + 0x04 + 0x20] = 0x20;\n            memory[temp7 + 0x24:temp7 + 0x24 + 0x20] = 0x2b;\n            memory[temp7 + 0x44:temp7 + 0x44 + 0x20] = 0x757365722063616e742063616c6c2077697468647261772c207768656e20686f;\n            memory[temp7 + 0x64:temp7 + 0x64 + 0x20] = 0x6c6473206e6f7468696e67000000000000000000000000000000000000000000;\n            var temp8 = memory[0x40:0x60];\n            revert(memory[temp8:temp8 + temp7 - temp8 + 0x84]);\n        }\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function transferOwnership(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x0788;\n        var var1 = arg0;\n        func_07ED(var1);\n    }\n    \n    function func_07A2(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (arg0) {\n            var temp0 = arg0;\n            var0 = arg1 * temp0;\n            var var1 = arg1;\n            var var2 = temp0;\n            var var3 = var0;\n        \n            if (!var2) { assert(); }\n        \n            if (var3 / var2 != var1) { assert(); }\n        \n        label_079C:\n            return var0;\n        } else {\n            var0 = 0x00;\n            goto label_079C;\n        }\n    }\n    \n    function func_07ED(var arg0) {\n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var temp1 = arg0;\n        log(memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x00], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, stack[-1] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = (temp1 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length < 0x04) {\n        label_008D:\n            var var0 = 0x0095;\n            var var1 = msg.sender;\n            var var2 = 0x00;\n            var var3 = var2;\n            var var4 = var3;\n        \n            if (msg.value >= storage[0x03]) {\n                var var5 = 0x0213;\n                var var6 = msg.value;\n                var var7 = 0x0207;\n                var7 = getBalance();\n            \n            label_0207:\n                var temp0 = var6;\n                var6 = var7;\n                var7 = temp0;\n                var var8 = 0x00;\n            \n                if (var7 > var6) { assert(); }\n            \n                var8 = var6 - var7;\n                var5 = var8;\n                // Error: Could not resolve jump destination!\n            } else {\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = 0x20;\n                memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = 0x24;\n                memory[temp1 + 0x44:temp1 + 0x44 + 0x20] = 0x73686f756c64206265206d6f72652074686520302e3030303120657468657220;\n                memory[temp1 + 0x64:temp1 + 0x64 + 0x20] = 0x73656e7400000000000000000000000000000000000000000000000000000000;\n                var temp2 = memory[0x40:0x60];\n                revert(memory[temp2:temp2 + temp1 - temp2 + 0x84]);\n            }\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x12065fe0) {\n                // Dispatch table entry for getBalance()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00ac;\n                var1 = getBalance();\n            \n            label_00AC:\n                var temp3 = memory[0x40:0x60];\n                memory[temp3:temp3 + 0x20] = var1;\n                var temp4 = memory[0x40:0x60];\n                return memory[temp4:temp4 + temp3 - temp4 + 0x20];\n            } else if (var0 == 0x2e1a7d4d) {\n                // Dispatch table entry for withdraw(uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                var2 = msg.data[0x04:0x24];\n                var3 = msg.sender;\n            \n                if (var2 > 0x00) {\n                    var4 = 0x03d5;\n                    var5 = var3;\n                    var4 = ethBalanceOf(var5);\n                \n                    if (var2 <= var4) {\n                        var temp5 = memory[0x40:0x60];\n                        var temp6 = var2;\n                        var temp7;\n                        temp7, memory[temp5:temp5 + 0x00] = address(var3 & 0x02 ** 0xa0 - 0x01).call.gas(!temp6 * 0x08fc).value(temp6)(memory[temp5:temp5 + 0x00]);\n                        var4 = !temp7;\n                    \n                        if (!var4) {\n                            var4 = 0x0496;\n                            var5 = var2;\n                            var6 = 0x0207;\n                            var7 = var3;\n                            var6 = ethBalanceOf(var7);\n                            goto label_0207;\n                        } else {\n                            var temp8 = returndata.length;\n                            memory[0x00:0x00 + temp8] = returndata[0x00:0x00 + temp8];\n                            revert(memory[0x00:0x00 + returndata.length]);\n                        }\n                    } else {\n                        var temp9 = memory[0x40:0x60];\n                        memory[temp9:temp9 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                        memory[temp9 + 0x04:temp9 + 0x04 + 0x20] = 0x20;\n                        memory[temp9 + 0x24:temp9 + 0x24 + 0x20] = 0x26;\n                        memory[temp9 + 0x44:temp9 + 0x44 + 0x20] = 0x757365722063616e74207769746864726177206d6f7265207468656e20686520;\n                        memory[temp9 + 0x64:temp9 + 0x64 + 0x20] = 0x686f6c6473200000000000000000000000000000000000000000000000000000;\n                        var temp10 = memory[0x40:0x60];\n                        revert(memory[temp10:temp10 + temp9 - temp10 + 0x84]);\n                    }\n                } else {\n                    var temp11 = memory[0x40:0x60];\n                    memory[temp11:temp11 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                    memory[temp11 + 0x04:temp11 + 0x04 + 0x20] = 0x20;\n                    memory[temp11 + 0x24:temp11 + 0x24 + 0x20] = 0x28;\n                    memory[temp11 + 0x44:temp11 + 0x44 + 0x20] = 0x757365722063616e74207370616d207472616e73616374696f6e732077697468;\n                    memory[temp11 + 0x64:temp11 + 0x64 + 0x20] = 0x20302076616c7565000000000000000000000000000000000000000000000000;\n                    var temp12 = memory[0x40:0x60];\n                    revert(memory[temp12:temp12 + temp11 - temp12 + 0x84]);\n                }\n            } else if (var0 == 0x715018a6) {\n                // Dispatch table entry for renounceOwnership()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                renounceOwnership();\n                stop();\n            } else if (var0 == 0x7252bbf2) {\n                // Dispatch table entry for ethBalanceOf(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00ac;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = ethBalanceOf(var2);\n                goto label_00AC;\n            } else if (var0 == 0x853828b6) {\n                // Dispatch table entry for withdrawAll()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                withdrawAll();\n                stop();\n            } else if (var0 == 0x8da5cb5b) {\n                // Dispatch table entry for owner()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0136;\n                var2 = owner();\n                var temp13 = memory[0x40:0x60];\n                memory[temp13:temp13 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp14 = memory[0x40:0x60];\n                return memory[temp14:temp14 + temp13 - temp14 + 0x20];\n            } else if (var0 == 0xa6f2ae3a) { goto label_008D; }\n                // Dispatch table entry for buy()\n            else if (var0 == 0xf2fde38b) {\n                // Dispatch table entry for transferOwnership(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                transferOwnership(var2);\n                stop();\n            } else { goto label_008D; }\n        }\n    }\n    \n    function getBalance() returns (var r0) { return address(this).balance; }\n    \n    function renounceOwnership() {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        log(memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x00], [0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820, storage[0x00] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff;\n    }\n    \n    function ethBalanceOf(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var temp0 = storage[keccak256(memory[0x00:0x40])];\n        memory[0x20:0x40] = 0x02;\n        var var0 = 0x00;\n        var var3 = storage[0x05];\n        var var1 = 0x047bf19673df52e37f2410011d100000000000;\n        var var2 = 0x0604;\n        var var4 = 0x05f8;\n        var var5 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var6 = temp0;\n        var4 = func_07A2(var5, var6);\n        var2 = func_05F8(var3, var4);\n    \n        if (var1) { return var2 / var1; }\n        else { assert(); }\n    }\n    \n    function func_05F8(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = arg1;\n        arg1 = temp0;\n        r0 = func_07A2(arg0, arg1);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function withdrawAll() {\n        var var0 = msg.sender;\n        var var1 = 0x00;\n        var var2 = 0x0620;\n        var var3 = var0;\n        var2 = ethBalanceOf(var3);\n        var1 = var2;\n    \n        if (var1 > 0x00) {\n            var temp0 = memory[0x40:0x60];\n            var temp1 = var1;\n            var temp2;\n            temp2, memory[temp0:temp0 + 0x00] = address(var0 & 0x02 ** 0xa0 - 0x01).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);\n            var2 = !temp2;\n        \n            if (!var2) {\n                memory[0x00:0x20] = var0 & 0x02 ** 0xa0 - 0x01;\n                memory[0x20:0x40] = 0x02;\n                storage[keccak256(memory[0x00:0x40])] = 0x00;\n                var2 = storage[0x05];\n                var3 = 0x047bf19673df52e37f2410011d100000000000;\n            \n                if (!var2) { assert(); }\n            \n                memory[0x00:0x20] = var0 & 0x02 ** 0xa0 - 0x01;\n                memory[0x20:0x40] = 0x01;\n                var temp3 = var3 / var2;\n                var2 = var0 & 0x02 ** 0xa0 - 0x01;\n                storage[keccak256(memory[0x00:0x40])] = temp3;\n                var3 = 0x90ebb005d68efee044927e1e77e1fd0cecc508368aa72c39250a787eed5f0a70;\n                var var4 = var1;\n                var var5 = 0x0518;\n                var5 = getBalance();\n                var temp4 = memory[0x40:0x60];\n                memory[temp4:temp4 + 0x20] = var4;\n                memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var5;\n                memory[temp4 + 0x40:temp4 + 0x40 + 0x20] = block.timestamp;\n                var temp5 = memory[0x40:0x60];\n                log(memory[temp5:temp5 + temp4 - temp5 + 0x60], [stack[-3], stack[-4]]);\n                return;\n            } else {\n                var temp6 = returndata.length;\n                memory[0x00:0x00 + temp6] = returndata[0x00:0x00 + temp6];\n                revert(memory[0x00:0x00 + returndata.length]);\n            }\n        } else {\n            var temp7 = memory[0x40:0x60];\n            memory[temp7:temp7 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n            memory[temp7 + 0x04:temp7 + 0x04 + 0x20] = 0x20;\n            memory[temp7 + 0x24:temp7 + 0x24 + 0x20] = 0x2b;\n            memory[temp7 + 0x44:temp7 + 0x44 + 0x20] = 0x757365722063616e742063616c6c2077697468647261772c207768656e20686f;\n            memory[temp7 + 0x64:temp7 + 0x64 + 0x20] = 0x6c6473206e6f7468696e67000000000000000000000000000000000000000000;\n            var temp8 = memory[0x40:0x60];\n            revert(memory[temp8:temp8 + temp7 - temp8 + 0x84]);\n        }\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function transferOwnership(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x0788;\n        var var1 = arg0;\n        func_07ED(var1);\n    }\n    \n    function func_07A2(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (arg0) {\n            var temp0 = arg0;\n            var0 = arg1 * temp0;\n            var var1 = arg1;\n            var var2 = temp0;\n            var var3 = var0;\n        \n            if (!var2) { assert(); }\n        \n            if (var3 / var2 != var1) { assert(); }\n        \n        label_079C:\n            return var0;\n        } else {\n            var0 = 0x00;\n            goto label_079C;\n        }\n    }\n    \n    function func_07ED(var arg0) {\n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var temp1 = arg0;\n        log(memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x00], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, stack[-1] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = (temp1 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length < 0x04) {\n        label_008D:\n            var var0 = 0x0095;\n            var var1 = msg.sender;\n            var var2 = 0x00;\n            var var3 = var2;\n            var var4 = var3;\n        \n            if (msg.value >= storage[0x03]) {\n                var var5 = 0x0213;\n                var var6 = msg.value;\n                var var7 = 0x0207;\n                var7 = getBalance();\n            \n            label_0207:\n                var temp0 = var6;\n                var6 = var7;\n                var7 = temp0;\n                var var8 = 0x00;\n            \n                if (var7 > var6) { assert(); }\n            \n                var8 = var6 - var7;\n                var5 = var8;\n                // Error: Could not resolve jump destination!\n            } else {\n                var temp1 = memory[0x40:0x60];\n                memory[temp1:temp1 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = 0x20;\n                memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = 0x24;\n                memory[temp1 + 0x44:temp1 + 0x44 + 0x20] = 0x73686f756c64206265206d6f72652074686520302e3030303120657468657220;\n                memory[temp1 + 0x64:temp1 + 0x64 + 0x20] = 0x73656e7400000000000000000000000000000000000000000000000000000000;\n                var temp2 = memory[0x40:0x60];\n                revert(memory[temp2:temp2 + temp1 - temp2 + 0x84]);\n            }\n        } else {\n            var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x12065fe0) {\n                // Dispatch table entry for getBalance()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00ac;\n                var1 = getBalance();\n            \n            label_00AC:\n                var temp3 = memory[0x40:0x60];\n                memory[temp3:temp3 + 0x20] = var1;\n                var temp4 = memory[0x40:0x60];\n                return memory[temp4:temp4 + temp3 - temp4 + 0x20];\n            } else if (var0 == 0x2e1a7d4d) {\n                // Dispatch table entry for withdraw(uint256)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                var2 = msg.data[0x04:0x24];\n                var3 = msg.sender;\n            \n                if (var2 > 0x00) {\n                    var4 = 0x03d5;\n                    var5 = var3;\n                    var4 = ethBalanceOf(var5);\n                \n                    if (var2 <= var4) {\n                        var temp5 = memory[0x40:0x60];\n                        var temp6 = var2;\n                        var temp7;\n                        temp7, memory[temp5:temp5 + 0x00] = address(var3 & 0x02 ** 0xa0 - 0x01).call.gas(!temp6 * 0x08fc).value(temp6)(memory[temp5:temp5 + 0x00]);\n                        var4 = !temp7;\n                    \n                        if (!var4) {\n                            var4 = 0x0496;\n                            var5 = var2;\n                            var6 = 0x0207;\n                            var7 = var3;\n                            var6 = ethBalanceOf(var7);\n                            goto label_0207;\n                        } else {\n                            var temp8 = returndata.length;\n                            memory[0x00:0x00 + temp8] = returndata[0x00:0x00 + temp8];\n                            revert(memory[0x00:0x00 + returndata.length]);\n                        }\n                    } else {\n                        var temp9 = memory[0x40:0x60];\n                        memory[temp9:temp9 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                        memory[temp9 + 0x04:temp9 + 0x04 + 0x20] = 0x20;\n                        memory[temp9 + 0x24:temp9 + 0x24 + 0x20] = 0x26;\n                        memory[temp9 + 0x44:temp9 + 0x44 + 0x20] = 0x757365722063616e74207769746864726177206d6f7265207468656e20686520;\n                        memory[temp9 + 0x64:temp9 + 0x64 + 0x20] = 0x686f6c6473200000000000000000000000000000000000000000000000000000;\n                        var temp10 = memory[0x40:0x60];\n                        revert(memory[temp10:temp10 + temp9 - temp10 + 0x84]);\n                    }\n                } else {\n                    var temp11 = memory[0x40:0x60];\n                    memory[temp11:temp11 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n                    memory[temp11 + 0x04:temp11 + 0x04 + 0x20] = 0x20;\n                    memory[temp11 + 0x24:temp11 + 0x24 + 0x20] = 0x28;\n                    memory[temp11 + 0x44:temp11 + 0x44 + 0x20] = 0x757365722063616e74207370616d207472616e73616374696f6e732077697468;\n                    memory[temp11 + 0x64:temp11 + 0x64 + 0x20] = 0x20302076616c7565000000000000000000000000000000000000000000000000;\n                    var temp12 = memory[0x40:0x60];\n                    revert(memory[temp12:temp12 + temp11 - temp12 + 0x84]);\n                }\n            } else if (var0 == 0x715018a6) {\n                // Dispatch table entry for renounceOwnership()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                renounceOwnership();\n                stop();\n            } else if (var0 == 0x7252bbf2) {\n                // Dispatch table entry for ethBalanceOf(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x00ac;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                var1 = ethBalanceOf(var2);\n                goto label_00AC;\n            } else if (var0 == 0x853828b6) {\n                // Dispatch table entry for withdrawAll()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                withdrawAll();\n                stop();\n            } else if (var0 == 0x8da5cb5b) {\n                // Dispatch table entry for owner()\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0136;\n                var2 = owner();\n                var temp13 = memory[0x40:0x60];\n                memory[temp13:temp13 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n                var temp14 = memory[0x40:0x60];\n                return memory[temp14:temp14 + temp13 - temp14 + 0x20];\n            } else if (var0 == 0xa6f2ae3a) { goto label_008D; }\n                // Dispatch table entry for buy()\n            else if (var0 == 0xf2fde38b) {\n                // Dispatch table entry for transferOwnership(address)\n                var1 = msg.value;\n            \n                if (var1) { revert(memory[0x00:0x00]); }\n            \n                var1 = 0x0095;\n                var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n                transferOwnership(var2);\n                stop();\n            } else { goto label_008D; }\n        }\n    }\n    \n    function getBalance() returns (var r0) { return address(this).balance; }\n    \n    function renounceOwnership() {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        log(memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x00], [0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820, storage[0x00] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff;\n    }\n    \n    function ethBalanceOf(var arg0) returns (var r0) {\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var temp0 = storage[keccak256(memory[0x00:0x40])];\n        memory[0x20:0x40] = 0x02;\n        var var0 = 0x00;\n        var var3 = storage[0x05];\n        var var1 = 0x047bf19673df52e37f2410011d100000000000;\n        var var2 = 0x0604;\n        var var4 = 0x05f8;\n        var var5 = storage[keccak256(memory[var0:var0 + 0x40])];\n        var var6 = temp0;\n        var4 = func_07A2(var5, var6);\n        var2 = func_05F8(var3, var4);\n    \n        if (var1) { return var2 / var1; }\n        else { assert(); }\n    }\n    \n    function func_05F8(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = arg1;\n        arg1 = temp0;\n        r0 = func_07A2(arg0, arg1);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function withdrawAll() {\n        var var0 = msg.sender;\n        var var1 = 0x00;\n        var var2 = 0x0620;\n        var var3 = var0;\n        var2 = ethBalanceOf(var3);\n        var1 = var2;\n    \n        if (var1 > 0x00) {\n            var temp0 = memory[0x40:0x60];\n            var temp1 = var1;\n            var temp2;\n            temp2, memory[temp0:temp0 + 0x00] = address(var0 & 0x02 ** 0xa0 - 0x01).call.gas(!temp1 * 0x08fc).value(temp1)(memory[temp0:temp0 + 0x00]);\n            var2 = !temp2;\n        \n            if (!var2) {\n                memory[0x00:0x20] = var0 & 0x02 ** 0xa0 - 0x01;\n                memory[0x20:0x40] = 0x02;\n                storage[keccak256(memory[0x00:0x40])] = 0x00;\n                var2 = storage[0x05];\n                var3 = 0x047bf19673df52e37f2410011d100000000000;\n            \n                if (!var2) { assert(); }\n            \n                memory[0x00:0x20] = var0 & 0x02 ** 0xa0 - 0x01;\n                memory[0x20:0x40] = 0x01;\n                var temp3 = var3 / var2;\n                var2 = var0 & 0x02 ** 0xa0 - 0x01;\n                storage[keccak256(memory[0x00:0x40])] = temp3;\n                var3 = 0x90ebb005d68efee044927e1e77e1fd0cecc508368aa72c39250a787eed5f0a70;\n                var var4 = var1;\n                var var5 = 0x0518;\n                var5 = getBalance();\n                var temp4 = memory[0x40:0x60];\n                memory[temp4:temp4 + 0x20] = var4;\n                memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var5;\n                memory[temp4 + 0x40:temp4 + 0x40 + 0x20] = block.timestamp;\n                var temp5 = memory[0x40:0x60];\n                log(memory[temp5:temp5 + temp4 - temp5 + 0x60], [stack[-3], stack[-4]]);\n                return;\n            } else {\n                var temp6 = returndata.length;\n                memory[0x00:0x00 + temp6] = returndata[0x00:0x00 + temp6];\n                revert(memory[0x00:0x00 + returndata.length]);\n            }\n        } else {\n            var temp7 = memory[0x40:0x60];\n            memory[temp7:temp7 + 0x20] = 0x461bcd * 0x02 ** 0xe5;\n            memory[temp7 + 0x04:temp7 + 0x04 + 0x20] = 0x20;\n            memory[temp7 + 0x24:temp7 + 0x24 + 0x20] = 0x2b;\n            memory[temp7 + 0x44:temp7 + 0x44 + 0x20] = 0x757365722063616e742063616c6c2077697468647261772c207768656e20686f;\n            memory[temp7 + 0x64:temp7 + 0x64 + 0x20] = 0x6c6473206e6f7468696e67000000000000000000000000000000000000000000;\n            var temp8 = memory[0x40:0x60];\n            revert(memory[temp8:temp8 + temp7 - temp8 + 0x84]);\n        }\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function transferOwnership(var arg0) {\n        if (msg.sender != storage[0x00] & 0x02 ** 0xa0 - 0x01) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x0788;\n        var var1 = arg0;\n        func_07ED(var1);\n    }\n    \n    function func_07A2(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (arg0) {\n            var temp0 = arg0;\n            var0 = arg1 * temp0;\n            var var1 = arg1;\n            var var2 = temp0;\n            var var3 = var0;\n        \n            if (!var2) { assert(); }\n        \n            if (var3 / var2 != var1) { assert(); }\n        \n        label_079C:\n            return var0;\n        } else {\n            var0 = 0x00;\n            goto label_079C;\n        }\n    }\n    \n    function func_07ED(var arg0) {\n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = 0x02 ** 0xa0 - 0x01;\n        var temp1 = arg0;\n        log(memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x00], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0x02 ** 0xa0 - 0x01, stack[-1] & 0x02 ** 0xa0 - 0x01]);\n        storage[0x00] = (temp1 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 17.89101266860962,
	"usage": {
		"completion_tokens": 401,
		"prompt_tokens": 4090,
		"total_tokens": 4491
	}
}