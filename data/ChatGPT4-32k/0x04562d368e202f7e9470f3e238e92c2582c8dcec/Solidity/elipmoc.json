{
	"address": "0x04562d368e202f7e9470f3e238e92c2582c8dcec",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, the corresponding Solidity code could be:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _getInvested;\n    mapping (address => uint256) private _lastInvest;\n    mapping (address => uint256) private _getAffiliateCommision;\n    address private _investETH;\n    address private stor_4_0_19;\n\n    function withdraw() public {\n        uint256 v0 = 0x556(msg.sender);\n        require(v0 > 0);\n        _lastInvest[msg.sender] = block.timestamp;\n        (bool v1,) = msg.sender.call{value: v0, gas: 2300 * !v0}(\"\");\n        require(v1);\n    }\n\n    function getAffiliateCommision() public view returns (uint256) {\n        return _getAffiliateCommision[msg.sender];\n    }\n\n    function affiliateCommision(address varg0) public view returns (uint256) {\n        return _getAffiliateCommision[varg0];\n    }   \n\n    function getProfitFromSender() public view returns (uint256) {\n        return 0x556(msg.sender);\n    }\n\n    // ... other functions ...\n    \n    function _0x556(address varg0) private view returns (uint256) {\n        require(_lastInvest[varg0] <= block.timestamp);\n        uint256 v2 = _SafeMul(_getInvested[varg0], block.timestamp - _lastInvest[varg0]);\n        uint256 v3 = _SafeDiv(0x278d00, v2);\n        return v3;\n    }\n\n    function _SafeDiv(uint256 varg0, uint256 varg1) private pure returns (uint256) {\n        require(varg0 != 0);\n        return varg1 / varg0;\n    }\n\n    function _SafeMul(uint256 varg0, uint256 varg1) private pure returns (uint256) {\n        if (varg1 == 0) return 0;\n        uint256 v0 = varg0 * varg1;\n        require(v0 / varg1 == varg0);\n        return v0;\n    }\n    \n    // ... other functions ...\n}\n```\n\nThis is a simplified version of the contract and doesn't include all the functions. The specific implementation depends on the original contract's logic and the business requirements. The `_0x556`, `_SafeDiv`, `_SafeMul` functions are made `private` and `pure` or `view` since they don't modify state. The `view` keyword indicates that the function will not alter the storage state in any way, while `pure` indicates that it won't even read the storage state.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469492,
	"id": "chatcmpl-8R6EGj8KPIgGOoXQVSlR1StE7PpAd",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 18:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction withdraw() public nonPayable { \n    v0 = 0x556(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1);\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x556(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x2386f26fc10000);\n    v0 = 0x556(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x556(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2);\n    }\n    v3 = _SafeDiv(10, msg.value);\n    v4 = v5 = varg0 != msg.sender;\n    if (v5) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    v9 = _SafeDiv(40, msg.value);\n    _getAffiliateCommision[_investETH] = v9;\n    v10 = _SafeDiv(40, msg.value);\n    _getAffiliateCommision[stor_4_0_19] = v10;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x556(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x556(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(_getAffiliateCommision[msg.sender] > 0);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0);\n}\n\nfunction 0x556(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = _SafeDiv(0x278d00, v2);\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction divestETH() public nonPayable { \n    v0 = 0x556(msg.sender);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = _SafeDiv(2, _lastInvest[msg.sender]);\n    assert(v1 <= _lastInvest[msg.sender]);\n    assert(v0 + (_lastInvest[msg.sender] - v1) >= _lastInvest[msg.sender] - v1);\n    require(v0 + (_lastInvest[msg.sender] - v1) > 0);\n    _getInvested[msg.sender] = 0;\n    v2 = msg.sender.call().value(v0 + (_lastInvest[msg.sender] - v1)).gas(2300 * !(v0 + (_lastInvest[msg.sender] - v1)));\n    require(v2);\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1054d657) {\n            divestETH();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 18:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction withdraw() public nonPayable { \n    v0 = 0x556(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1);\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x556(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x2386f26fc10000);\n    v0 = 0x556(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x556(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2);\n    }\n    v3 = _SafeDiv(10, msg.value);\n    v4 = v5 = varg0 != msg.sender;\n    if (v5) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    v9 = _SafeDiv(40, msg.value);\n    _getAffiliateCommision[_investETH] = v9;\n    v10 = _SafeDiv(40, msg.value);\n    _getAffiliateCommision[stor_4_0_19] = v10;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x556(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x556(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(_getAffiliateCommision[msg.sender] > 0);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0);\n}\n\nfunction 0x556(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = _SafeDiv(0x278d00, v2);\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction divestETH() public nonPayable { \n    v0 = 0x556(msg.sender);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = _SafeDiv(2, _lastInvest[msg.sender]);\n    assert(v1 <= _lastInvest[msg.sender]);\n    assert(v0 + (_lastInvest[msg.sender] - v1) >= _lastInvest[msg.sender] - v1);\n    require(v0 + (_lastInvest[msg.sender] - v1) > 0);\n    _getInvested[msg.sender] = 0;\n    v2 = msg.sender.call().value(v0 + (_lastInvest[msg.sender] - v1)).gas(2300 * !(v0 + (_lastInvest[msg.sender] - v1)));\n    require(v2);\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1054d657) {\n            divestETH();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 18:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction withdraw() public nonPayable { \n    v0 = 0x556(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1);\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x556(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x2386f26fc10000);\n    v0 = 0x556(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x556(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2);\n    }\n    v3 = _SafeDiv(10, msg.value);\n    v4 = v5 = varg0 != msg.sender;\n    if (v5) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    v9 = _SafeDiv(40, msg.value);\n    _getAffiliateCommision[_investETH] = v9;\n    v10 = _SafeDiv(40, msg.value);\n    _getAffiliateCommision[stor_4_0_19] = v10;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x556(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x556(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(_getAffiliateCommision[msg.sender] > 0);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0);\n}\n\nfunction 0x556(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = _SafeDiv(0x278d00, v2);\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction divestETH() public nonPayable { \n    v0 = 0x556(msg.sender);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = _SafeDiv(2, _lastInvest[msg.sender]);\n    assert(v1 <= _lastInvest[msg.sender]);\n    assert(v0 + (_lastInvest[msg.sender] - v1) >= _lastInvest[msg.sender] - v1);\n    require(v0 + (_lastInvest[msg.sender] - v1) > 0);\n    _getInvested[msg.sender] = 0;\n    v2 = msg.sender.call().value(v0 + (_lastInvest[msg.sender] - v1)).gas(2300 * !(v0 + (_lastInvest[msg.sender] - v1)));\n    require(v2);\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1054d657) {\n            divestETH();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 25.474714994430542,
	"usage": {
		"completion_tokens": 580,
		"prompt_tokens": 1724,
		"total_tokens": 2304
	}
}