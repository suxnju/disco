{
	"address": "0x9e78c6e0410cc33a0864d0ac6c9ff7dabaf709cb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code represents a complex smart contract that contains functions related to token transfers, staking, approval, burning, and more. However, the decompiled code is quite low-level and includes a lot of raw byte manipulation, which is specific to the EVM. \n\nHere is a rough translation of the contract into Solidity:\n\n```solidity\npragma solidity ^0.8.3;\n\ncontract TokenContract {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => mapping (uint256 => Stake)) private _stakes;\n    mapping (address => mapping (uint256 => DueTransfer)) private _dueTransfers;\n    uint256 private _totalSupply;\n    address private _owner;\n\n    struct Stake {\n        uint256 value;\n        uint256 setDate;\n        uint256 dueDate;\n    }\n\n    struct DueTransfer {\n        address buyer;\n        uint256 value;\n        uint256 netValue;\n        uint256 setDate;\n        uint256 subDate;\n        bool declined;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event StakeCreated(address indexed staker, uint256 value, uint256 setDate, uint256 dueDate);\n    event StakeRemoved(address indexed staker, uint256 value);\n    event DueTransferCreated(address indexed seller, address indexed buyer, uint256 value, uint256 netValue);\n    event DueTransferSubmitted(address indexed seller, address indexed buyer, uint256 value);\n    event DueTransferDeclined(address indexed seller, address indexed buyer, uint256 value);\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    constructor(uint256 totalSupply_) {\n        _totalSupply = totalSupply_;\n        _balances[msg.sender] = totalSupply_;\n        _owner = msg.sender;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function stake(uint256 amount, uint256 dueDate) public {\n        _balances[msg.sender] -= amount;\n        _stakes[msg.sender][dueDate] = Stake(amount, block.timestamp, dueDate);\n        emit StakeCreated(msg.sender, amount, block.timestamp, dueDate);\n    }\n\n    function removeStake(uint256 dueDate) public {\n        Stake memory stake = _stakes[msg.sender][dueDate];\n        _balances[msg.sender] += stake.value;\n        delete _stakes[msg.sender][dueDate];\n        emit StakeRemoved(msg.sender, stake.value);\n    }\n\n    function createDueTransfer(uint256 amount, uint256 netValue, address buyer, uint256 dueDate) public {\n        _balances[msg.sender] -= amount;\n        _dueTransfers[msg.sender][dueDate] = DueTransfer(buyer, amount, netValue, block.timestamp, dueDate, false);\n        emit DueTransferCreated(msg.sender, buyer, amount, netValue);\n    }\n\n    function submitDueTransfer(uint256 dueDate) public {\n        DueTransfer memory dueTransfer = _dueTransfers[msg.sender][dueDate];\n        _balances[dueTransfer.buyer] += dueTransfer.value;\n        delete _dueTransfers[msg.sender][dueDate];\n        emit DueTransferSubmitted(msg.sender, dueTransfer.buyer, dueTransfer.value);\n    }\n\n    function declineDueTransfer(uint256 dueDate) public {\n        DueTransfer storage dueTransfer = _dueTransfers[msg.sender][dueDate];\n        _balances[msg.sender] += dueTransfer.value;\n        dueTransfer.declined = true;\n        emit DueTransferDeclined(msg.sender, dueTransfer.buyer, dueTransfer.value);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"Cannot transfer from the zero address\");\n        require(recipient != address(0), \"Cannot transfer to the zero address\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"Cannot approve from the zero address\");\n        require(spender != address(0), \"Cannot approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\nPlease note that this translation is not perfect and may not behave exactly like the original contract. The original contract contains some more complex logic (especially in the `fromToken` and `toToken` functions) that would require more context to accurately translate.\nAlso, this translation assumes that the original contract is a standard ERC20 token with some additional functions for staking and due transfers. The `struct` types `Stake` and `DueTransfer` have been added based on the original code's structure.",
				"role": "assistant"
			}
		}
	],
	"created": 1698041077,
	"id": "chatcmpl-8CiLFDOFVmv9OjUQ0vVRzqYdzi9w4",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.28 10:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 _fromToken; // STORAGE[0x3]\nuint256 _toToken; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _decimals; // STORAGE[0x8]\nuint256 _checkBurnStatus; // STORAGE[0x9]\nuint256[] _stakeOf__value; // STORAGE[0xf]\nuint256[] _dueTransferOf__buyer; // STORAGE[0x10]\nuint256 _transfer; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 _update; // STORAGE[0x13]\nuint256 _setBurnStatus; // STORAGE[0x14]\nuint256 stor_15; // STORAGE[0x15]\nuint256 stor_16; // STORAGE[0x16]\n\n// Events\nTransfer(address, address, uint256);\nPay(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction update(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _update);\n    _fromToken = varg0;\n    _toToken = varg1;\n    stor_5 = varg2;\n    return 1;\n}\n\nfunction fromToken(string varg0, uint256 varg1) public nonPayable { \n    CALLDATACOPY(320, 4 + varg0, 36);\n    require(varg0.length <= 4);\n    require(STORAGE[keccak256(10, msg.sender)] >= STORAGE[keccak256(14, msg.sender)]);\n    require(STORAGE[keccak256(10, msg.sender)] - STORAGE[keccak256(14, msg.sender)] >= varg1, Error(32, 24, 'Not enough token balance'));\n    MEM[1312] = 0x6574680000000000000000000000000000000000000000000000000000000000;\n    if (keccak256(MEM[352 len (MEM[320])]) != keccak256(MEM[1312 len 3])) {\n        MEM[672] = 4;\n        if (MEM[352] != 0x7573647400000000000000000000000000000000000000000000000000000000) {\n            return 0;\n        } else {\n            require((varg1 * _fromToken / varg1 == _fromToken) | !varg1);\n            require(stor_5);\n            require(stor_7 >= varg1 * _fromToken / stor_5, Error(32, 48, 'There is not enough USDT in the ', 'contract to swap'));\n            require(stor_16.code.size);\n            require(this ^ stor_16);\n            v0 = stor_16.transfer(msg.sender, varg1 * _fromToken / stor_5).gas(msg.gas);\n            require(v0);\n            require(stor_7 >= varg1 * _fromToken / stor_5);\n            stor_7 = stor_7 - varg1 * _fromToken / stor_5;\n            require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n            require(STORAGE[keccak256(10, stor_15)] + varg1 >= STORAGE[keccak256(10, stor_15)]);\n            STORAGE[keccak256(10, stor_15)] = STORAGE[keccak256(10, stor_15)] + varg1;\n            return 1;\n        }\n    } else {\n        require((varg1 * _fromToken / varg1 == _fromToken) | !varg1);\n        require(_toToken);\n        require(stor_6 >= varg1 * _fromToken / _toToken, Error(32, 47, 'There is not enough eth in the c', 'ontract to swap'));\n        v1 = msg.sender.call().value(varg1 * _fromToken / _toToken);\n        require(v1);\n        require(stor_6 >= varg1 * _fromToken / _toToken);\n        stor_6 = stor_6 - varg1 * _fromToken / _toToken;\n        require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n        require(STORAGE[keccak256(10, stor_15)] + varg1 >= STORAGE[keccak256(10, stor_15)]);\n        STORAGE[keccak256(10, stor_15)] = STORAGE[keccak256(10, stor_15)] + varg1;\n        return 1;\n    }\n}\n\nfunction toToken(string varg0, uint256 varg1) public payable { \n    CALLDATACOPY(320, 4 + varg0, 36);\n    require(varg0.length <= 4);\n    MEM[1312] = 0x6574680000000000000000000000000000000000000000000000000000000000;\n    if (keccak256(MEM[352 len (MEM[320])]) != keccak256(MEM[1312 len 3])) {\n        MEM[512] = 4;\n        if (MEM[352] != 0x7573647400000000000000000000000000000000000000000000000000000000) {\n            return 0;\n        } else {\n            require((stor_5 * varg1 / stor_5 == varg1) | !stor_5);\n            require(_fromToken);\n            require(STORAGE[keccak256(10, stor_15)] >= stor_5 * varg1 / _fromToken, Error(32, 32, 'No enough tokens in the contract'));\n            require(stor_7 + varg1 >= stor_7);\n            require(stor_6 == stor_7 + varg1, Error(32, 16, 'No USDT received'));\n            require(stor_15.code.size);\n            require(this ^ stor_15);\n            v0 = stor_15.transfer(msg.sender, stor_5 * varg1 / _fromToken).gas(msg.gas);\n            require(v0);\n            return 1;\n        }\n    } else {\n        require((_toToken * varg1 / _toToken == varg1) | !_toToken);\n        require(_fromToken);\n        require(STORAGE[keccak256(10, stor_15)] >= _toToken * varg1 / _fromToken, Error(32, 32, 'No enough tokens in the contract'));\n        require(stor_6 + varg1 >= stor_6);\n        require(stor_6 == stor_6 + varg1, Error(32, 15, 'No eth received'));\n        require(stor_15.code.size);\n        require(this ^ stor_15);\n        v1 = stor_15.transfer(msg.sender, _toToken * varg1 / _fromToken).gas(msg.gas);\n        require(v1);\n        return 1;\n    }\n}\n\nfunction setBurnStatus(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _setBurnStatus);\n    _checkBurnStatus = varg0;\n    return 1;\n}\n\nfunction checkBurnStatus() public nonPayable { \n    return _checkBurnStatus;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(13, varg0), varg1)];\n}\n\nfunction stake(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(STORAGE[keccak256(10, msg.sender)] >= varg0);\n    STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg2))] = msg.sender;\n    _stakeOf__value[1] = varg0;\n    _stakeOf__value[2] = block.timestamp;\n    _stakeOf__value[3] = varg1;\n    require(STORAGE[keccak256(14, msg.sender)] + varg0 >= STORAGE[keccak256(14, msg.sender)]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] + varg0;\n    return 1;\n}\n\nfunction removeStake(uint256 varg0) public nonPayable { \n    require(_stakeOf__value[1] > 0);\n    if (block.timestamp < _stakeOf__value[3]) {\n        STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        _stakeOf__value[3] = 0;\n        require(STORAGE[keccak256(14, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    } else {\n        require(STORAGE[keccak256(10, msg.sender)] + _stakeOf__value[1] / 1000 >= STORAGE[keccak256(10, msg.sender)]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] + _stakeOf__value[1] / 1000;\n        require(STORAGE[keccak256(10, stor_12)] >= _stakeOf__value[1] / 1000);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - _stakeOf__value[1] / 1000;\n        require(_totalSupply >= _stakeOf__value[1] / 1000);\n        _totalSupply = _totalSupply - _stakeOf__value[1] / 1000;\n        emit Transfer(stor_12, msg.sender, _stakeOf__value[1] / 1000);\n        STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        _stakeOf__value[3] = 0;\n        require(STORAGE[keccak256(14, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    }\n}\n\nfunction setDueTransfer(uint256 varg0, address varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg2);\n    require(!_dueTransferOf__buyer[2]);\n    require((0x15180 * varg3 / 0x15180 == varg3) | !0x15180);\n    require(0x15180 * varg3 + block.timestamp >= 0x15180 * varg3);\n    STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))] = varg1;\n    _dueTransferOf__buyer[1] = msg.sender;\n    _dueTransferOf__buyer[2] = varg2;\n    _dueTransferOf__buyer[3] = _fromToken;\n    _dueTransferOf__buyer[4] = block.timestamp;\n    _dueTransferOf__buyer[5] = 0x15180 * varg3 + block.timestamp;\n    _dueTransferOf__buyer[6] = 0;\n    require(STORAGE[keccak256(14, msg.sender)] + varg2 >= STORAGE[keccak256(14, msg.sender)]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] + varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n    require(STORAGE[keccak256(14, msg.sender)] <= STORAGE[keccak256(10, msg.sender)] - varg1);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n    STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n    require(STORAGE[keccak256(10, varg0)] + varg1 >= STORAGE[keccak256(10, varg0)]);\n    STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= varg1 / 100);\n    _totalSupply = _totalSupply - varg1 / 100;\n    require(STORAGE[keccak256(10, _transfer)] >= varg1 / 100);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - varg1 / 100;\n    emit Transfer(_transfer, 0, varg1 / 100);\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(10, varg0)] >= varg2);\n    require(STORAGE[keccak256(14, varg0)] <= STORAGE[keccak256(10, varg0)] - varg2);\n    require(STORAGE[keccak256(10, varg0)] >= varg2);\n    STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - varg2;\n    require(STORAGE[keccak256(10, varg1)] + varg2 >= STORAGE[keccak256(10, varg1)]);\n    STORAGE[keccak256(10, varg1)] = STORAGE[keccak256(10, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(13, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(13, varg0), msg.sender)] = STORAGE[keccak256(keccak256(13, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= varg2 / 100);\n    _totalSupply = _totalSupply - varg2 / 100;\n    require(STORAGE[keccak256(10, _transfer)] >= varg2 / 100);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - varg2 / 100;\n    emit Transfer(_transfer, 0, varg2 / 100);\n}\n\nfunction submitTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))];\n    if (_fromToken <= _dueTransferOf__buyer[3]) {\n        if (_fromToken >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= _fromToken);\n            require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(msg.sender, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n    } else {\n        require(_fromToken >= _dueTransferOf__buyer[3]);\n        require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n        require(_fromToken);\n        require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n        STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= _dueTransferOf__buyer[2]);\n    _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n    emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n}\n\nfunction declineTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    MEM[384] = STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))];\n    require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _update)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, _update)]);\n    STORAGE[keccak256(10, _update)] = STORAGE[keccak256(10, _update)] + _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(14, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _dueTransferOf__buyer[2];\n    _dueTransferOf__buyer[6] = 1;\n    emit Transfer(msg.sender, _update, _dueTransferOf__buyer[2]);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(13, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction resolve(uint256 varg0, address varg1, bool varg2) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(varg2 < 2);\n    require(msg.sender == _update);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, varg1), varg0))];\n    if (!varg2) {\n        if (_fromToken <= _dueTransferOf__buyer[3]) {\n            if (_fromToken >= _dueTransferOf__buyer[3]) {\n                require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(10, v0)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] - _dueTransferOf__buyer[2];\n                emit Pay(varg1, v0, _dueTransferOf__buyer[2]);\n            } else {\n                require(_dueTransferOf__buyer[3] >= _fromToken);\n                require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n                require(_fromToken);\n                require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n                STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n                STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n                emit Transfer(varg1, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n            }\n        } else {\n            require(_fromToken >= _dueTransferOf__buyer[3]);\n            require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg1, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n        MEM[704] = 0x42966c68;\n        MEM[416] = 0x9b1f9e74;\n        require(_checkBurnStatus);\n        require(_transfer ^ 0x0);\n        require(_totalSupply >= _dueTransferOf__buyer[2]);\n        _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    } else {\n        require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n        emit Transfer(msg.sender, varg1, _dueTransferOf__buyer[2]);\n        return 1;\n    }\n}\n\nfunction request(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 >= _dueTransferOf__buyer[5]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 <= block.timestamp);\n    require(!_dueTransferOf__buyer[6]);\n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, varg0), varg1))];\n    if (_fromToken <= _dueTransferOf__buyer[3]) {\n        if (_fromToken >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= _fromToken);\n            require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(varg0, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n    } else {\n        require(_fromToken >= _dueTransferOf__buyer[3]);\n        require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n        require(_fromToken);\n        require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n        STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= _dueTransferOf__buyer[2]);\n    _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n    emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(10, varg0)];\n}\n\nfunction etherbalanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(11, varg0)];\n}\n\nfunction usdbalanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(12, varg0)];\n}\n\nfunction stakeOf__holder(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(15, varg0), varg1))];\n}\n\nfunction stakeOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[1];\n}\n\nfunction stakeOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[2];\n}\n\nfunction stakeOf__dueDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[3];\n}\n\nfunction dueTransferOf__seller(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(16, varg0), varg1))];\n}\n\nfunction dueTransferOf__buyer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[1];\n}\n\nfunction dueTransferOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[2];\n}\n\nfunction dueTransferOf__netValue(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[3];\n}\n\nfunction dueTransferOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[4];\n}\n\nfunction dueTransferOf__subDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[5];\n}\n\nfunction dueTransferOf__declined(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0x6a054250) {\n                if (function_selector != 0x3714709) {\n                    if (function_selector != 0x587566ef) {\n                        if (function_selector != 0x97a2d0eb) {\n                            if (function_selector != 0x77884378) {\n                                if (function_selector != 0xdd62ed3e) {\n                                    if (function_selector != 0xa638f2e2) {\n                                        if (function_selector != 0x939624ab) {\n                                            if (function_selector != 0x49c662b8) {\n                                                if (function_selector != 0xa9059cbb) {\n                                                    if (function_selector != 0x23b872dd) {\n                                                        if (function_selector != 0xa6f12e85) {\n                                                            if (function_selector != 0x60dded11) {\n                                                                if (function_selector != 0x95ea7b3) {\n                                                                    if (function_selector != 0x48e45ca) {\n                                                                        if (function_selector != 0xc8c01a55) {\n                                                                            if (function_selector != 0x6fdde03) {\n                                                                                if (function_selector != 0x95d89b41) {\n                                                                                    if (function_selector != 0x313ce567) {\n                                                                                        if (function_selector != 0x70a08231) {\n                                                                                            if (function_selector != 0xfe92aff1) {\n                                                                                                if (function_selector != 0xbe6bf389) {\n                                                                                                    if (function_selector != 0x421f8e14) {\n                                                                                                        if (function_selector != 0xe9562a6d) {\n                                                                                                            if (function_selector != 0xf94be3af) {\n                                                                                                                if (function_selector != 0xbb3cb31b) {\n                                                                                                                    if (function_selector != 0x8f33367a) {\n                                                                                                                        if (function_selector != 0xb53574ab) {\n                                                                                                                            if (function_selector != 0xa1bb138e) {\n                                                                                                                                if (function_selector != 0x674b392e) {\n                                                                                                                                    if (function_selector != 0x410bf99) {\n                                                                                                                                        if (function_selector != 0x1952ddbd) {\n                                                                                                                                            if (function_selector == 0xb993ed4b) {\n                                                                                                                                                dueTransferOf__declined(address,uint256);\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            dueTransferOf__subDate(address,uint256);\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        dueTransferOf__setDate(address,uint256);\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    dueTransferOf__netValue(address,uint256);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                dueTransferOf__value(address,uint256);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            dueTransferOf__buyer(address,uint256);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        dueTransferOf__seller(address,uint256);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    stakeOf__dueDate(address,uint256);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                stakeOf__setDate(address,uint256);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            stakeOf__value(address,uint256);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        stakeOf__holder(address,uint256);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    usdbalanceOf(address);\n                                                                                                }\n                                                                                            } else {\n                                                                                                etherbalanceOf(address);\n                                                                                            }\n                                                                                        } else {\n                                                                                            balanceOf(address);\n                                                                                        }\n                                                                                    } else {\n                                                                                        decimals();\n                                                                                    }\n                                                                                } else {\n                                                                                    symbol();\n                                                                                }\n                                                                            } else {\n                                                                                name();\n                                                                            }\n                                                                        } else {\n                                                                            request(address,uint256);\n                                                                        }\n                                                                    } else {\n                                                                        resolve(uint256,address,bool);\n                                                                    }\n                                                                } else {\n                                                                    approve(address,uint256);\n                                                                }\n                                                            } else {\n                                                                declineTransfer(uint256);\n                                                            }\n                                                        } else {\n                                                            submitTransfer(uint256);\n                                                        }\n                                                    } else {\n                                                        transferFrom(address,address,uint256);\n                                                    }\n                                                } else {\n                                                    transfer(address,uint256);\n                                                }\n                                            } else {\n                                                setDueTransfer(uint256,address,uint256,uint256);\n                                            }\n                                        } else {\n                                            removeStake(uint256);\n                                        }\n                                    } else {\n                                        stake(uint256,uint256,uint256);\n                                    }\n                                } else {\n                                    allowance(address,address);\n                                }\n                            } else {\n                                checkBurnStatus();\n                            }\n                        } else {\n                            setBurnStatus(bool);\n                        }\n                    } else {\n                        toToken(string,uint256);\n                    }\n                } else {\n                    fromToken(string,uint256);\n                }\n            } else {\n                update(uint256,uint256,uint256);\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.28 10:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 _fromToken; // STORAGE[0x3]\nuint256 _toToken; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _decimals; // STORAGE[0x8]\nuint256 _checkBurnStatus; // STORAGE[0x9]\nuint256[] _stakeOf__value; // STORAGE[0xf]\nuint256[] _dueTransferOf__buyer; // STORAGE[0x10]\nuint256 _transfer; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 _update; // STORAGE[0x13]\nuint256 _setBurnStatus; // STORAGE[0x14]\nuint256 stor_15; // STORAGE[0x15]\nuint256 stor_16; // STORAGE[0x16]\n\n// Events\nTransfer(address, address, uint256);\nPay(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction update(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _update);\n    _fromToken = varg0;\n    _toToken = varg1;\n    stor_5 = varg2;\n    return 1;\n}\n\nfunction fromToken(string varg0, uint256 varg1) public nonPayable { \n    CALLDATACOPY(320, 4 + varg0, 36);\n    require(varg0.length <= 4);\n    require(STORAGE[keccak256(10, msg.sender)] >= STORAGE[keccak256(14, msg.sender)]);\n    require(STORAGE[keccak256(10, msg.sender)] - STORAGE[keccak256(14, msg.sender)] >= varg1, Error(32, 24, 'Not enough token balance'));\n    MEM[1312] = 0x6574680000000000000000000000000000000000000000000000000000000000;\n    if (keccak256(MEM[352 len (MEM[320])]) != keccak256(MEM[1312 len 3])) {\n        MEM[672] = 4;\n        if (MEM[352] != 0x7573647400000000000000000000000000000000000000000000000000000000) {\n            return 0;\n        } else {\n            require((varg1 * _fromToken / varg1 == _fromToken) | !varg1);\n            require(stor_5);\n            require(stor_7 >= varg1 * _fromToken / stor_5, Error(32, 48, 'There is not enough USDT in the ', 'contract to swap'));\n            require(stor_16.code.size);\n            require(this ^ stor_16);\n            v0 = stor_16.transfer(msg.sender, varg1 * _fromToken / stor_5).gas(msg.gas);\n            require(v0);\n            require(stor_7 >= varg1 * _fromToken / stor_5);\n            stor_7 = stor_7 - varg1 * _fromToken / stor_5;\n            require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n            require(STORAGE[keccak256(10, stor_15)] + varg1 >= STORAGE[keccak256(10, stor_15)]);\n            STORAGE[keccak256(10, stor_15)] = STORAGE[keccak256(10, stor_15)] + varg1;\n            return 1;\n        }\n    } else {\n        require((varg1 * _fromToken / varg1 == _fromToken) | !varg1);\n        require(_toToken);\n        require(stor_6 >= varg1 * _fromToken / _toToken, Error(32, 47, 'There is not enough eth in the c', 'ontract to swap'));\n        v1 = msg.sender.call().value(varg1 * _fromToken / _toToken);\n        require(v1);\n        require(stor_6 >= varg1 * _fromToken / _toToken);\n        stor_6 = stor_6 - varg1 * _fromToken / _toToken;\n        require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n        require(STORAGE[keccak256(10, stor_15)] + varg1 >= STORAGE[keccak256(10, stor_15)]);\n        STORAGE[keccak256(10, stor_15)] = STORAGE[keccak256(10, stor_15)] + varg1;\n        return 1;\n    }\n}\n\nfunction toToken(string varg0, uint256 varg1) public payable { \n    CALLDATACOPY(320, 4 + varg0, 36);\n    require(varg0.length <= 4);\n    MEM[1312] = 0x6574680000000000000000000000000000000000000000000000000000000000;\n    if (keccak256(MEM[352 len (MEM[320])]) != keccak256(MEM[1312 len 3])) {\n        MEM[512] = 4;\n        if (MEM[352] != 0x7573647400000000000000000000000000000000000000000000000000000000) {\n            return 0;\n        } else {\n            require((stor_5 * varg1 / stor_5 == varg1) | !stor_5);\n            require(_fromToken);\n            require(STORAGE[keccak256(10, stor_15)] >= stor_5 * varg1 / _fromToken, Error(32, 32, 'No enough tokens in the contract'));\n            require(stor_7 + varg1 >= stor_7);\n            require(stor_6 == stor_7 + varg1, Error(32, 16, 'No USDT received'));\n            require(stor_15.code.size);\n            require(this ^ stor_15);\n            v0 = stor_15.transfer(msg.sender, stor_5 * varg1 / _fromToken).gas(msg.gas);\n            require(v0);\n            return 1;\n        }\n    } else {\n        require((_toToken * varg1 / _toToken == varg1) | !_toToken);\n        require(_fromToken);\n        require(STORAGE[keccak256(10, stor_15)] >= _toToken * varg1 / _fromToken, Error(32, 32, 'No enough tokens in the contract'));\n        require(stor_6 + varg1 >= stor_6);\n        require(stor_6 == stor_6 + varg1, Error(32, 15, 'No eth received'));\n        require(stor_15.code.size);\n        require(this ^ stor_15);\n        v1 = stor_15.transfer(msg.sender, _toToken * varg1 / _fromToken).gas(msg.gas);\n        require(v1);\n        return 1;\n    }\n}\n\nfunction setBurnStatus(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _setBurnStatus);\n    _checkBurnStatus = varg0;\n    return 1;\n}\n\nfunction checkBurnStatus() public nonPayable { \n    return _checkBurnStatus;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(13, varg0), varg1)];\n}\n\nfunction stake(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(STORAGE[keccak256(10, msg.sender)] >= varg0);\n    STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg2))] = msg.sender;\n    _stakeOf__value[1] = varg0;\n    _stakeOf__value[2] = block.timestamp;\n    _stakeOf__value[3] = varg1;\n    require(STORAGE[keccak256(14, msg.sender)] + varg0 >= STORAGE[keccak256(14, msg.sender)]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] + varg0;\n    return 1;\n}\n\nfunction removeStake(uint256 varg0) public nonPayable { \n    require(_stakeOf__value[1] > 0);\n    if (block.timestamp < _stakeOf__value[3]) {\n        STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        _stakeOf__value[3] = 0;\n        require(STORAGE[keccak256(14, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    } else {\n        require(STORAGE[keccak256(10, msg.sender)] + _stakeOf__value[1] / 1000 >= STORAGE[keccak256(10, msg.sender)]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] + _stakeOf__value[1] / 1000;\n        require(STORAGE[keccak256(10, stor_12)] >= _stakeOf__value[1] / 1000);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - _stakeOf__value[1] / 1000;\n        require(_totalSupply >= _stakeOf__value[1] / 1000);\n        _totalSupply = _totalSupply - _stakeOf__value[1] / 1000;\n        emit Transfer(stor_12, msg.sender, _stakeOf__value[1] / 1000);\n        STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        _stakeOf__value[3] = 0;\n        require(STORAGE[keccak256(14, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    }\n}\n\nfunction setDueTransfer(uint256 varg0, address varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg2);\n    require(!_dueTransferOf__buyer[2]);\n    require((0x15180 * varg3 / 0x15180 == varg3) | !0x15180);\n    require(0x15180 * varg3 + block.timestamp >= 0x15180 * varg3);\n    STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))] = varg1;\n    _dueTransferOf__buyer[1] = msg.sender;\n    _dueTransferOf__buyer[2] = varg2;\n    _dueTransferOf__buyer[3] = _fromToken;\n    _dueTransferOf__buyer[4] = block.timestamp;\n    _dueTransferOf__buyer[5] = 0x15180 * varg3 + block.timestamp;\n    _dueTransferOf__buyer[6] = 0;\n    require(STORAGE[keccak256(14, msg.sender)] + varg2 >= STORAGE[keccak256(14, msg.sender)]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] + varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n    require(STORAGE[keccak256(14, msg.sender)] <= STORAGE[keccak256(10, msg.sender)] - varg1);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n    STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n    require(STORAGE[keccak256(10, varg0)] + varg1 >= STORAGE[keccak256(10, varg0)]);\n    STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= varg1 / 100);\n    _totalSupply = _totalSupply - varg1 / 100;\n    require(STORAGE[keccak256(10, _transfer)] >= varg1 / 100);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - varg1 / 100;\n    emit Transfer(_transfer, 0, varg1 / 100);\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(10, varg0)] >= varg2);\n    require(STORAGE[keccak256(14, varg0)] <= STORAGE[keccak256(10, varg0)] - varg2);\n    require(STORAGE[keccak256(10, varg0)] >= varg2);\n    STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - varg2;\n    require(STORAGE[keccak256(10, varg1)] + varg2 >= STORAGE[keccak256(10, varg1)]);\n    STORAGE[keccak256(10, varg1)] = STORAGE[keccak256(10, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(13, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(13, varg0), msg.sender)] = STORAGE[keccak256(keccak256(13, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= varg2 / 100);\n    _totalSupply = _totalSupply - varg2 / 100;\n    require(STORAGE[keccak256(10, _transfer)] >= varg2 / 100);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - varg2 / 100;\n    emit Transfer(_transfer, 0, varg2 / 100);\n}\n\nfunction submitTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))];\n    if (_fromToken <= _dueTransferOf__buyer[3]) {\n        if (_fromToken >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= _fromToken);\n            require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(msg.sender, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n    } else {\n        require(_fromToken >= _dueTransferOf__buyer[3]);\n        require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n        require(_fromToken);\n        require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n        STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= _dueTransferOf__buyer[2]);\n    _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n    emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n}\n\nfunction declineTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    MEM[384] = STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))];\n    require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _update)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, _update)]);\n    STORAGE[keccak256(10, _update)] = STORAGE[keccak256(10, _update)] + _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(14, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _dueTransferOf__buyer[2];\n    _dueTransferOf__buyer[6] = 1;\n    emit Transfer(msg.sender, _update, _dueTransferOf__buyer[2]);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(13, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction resolve(uint256 varg0, address varg1, bool varg2) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(varg2 < 2);\n    require(msg.sender == _update);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, varg1), varg0))];\n    if (!varg2) {\n        if (_fromToken <= _dueTransferOf__buyer[3]) {\n            if (_fromToken >= _dueTransferOf__buyer[3]) {\n                require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(10, v0)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] - _dueTransferOf__buyer[2];\n                emit Pay(varg1, v0, _dueTransferOf__buyer[2]);\n            } else {\n                require(_dueTransferOf__buyer[3] >= _fromToken);\n                require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n                require(_fromToken);\n                require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n                STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n                STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n                emit Transfer(varg1, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n            }\n        } else {\n            require(_fromToken >= _dueTransferOf__buyer[3]);\n            require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg1, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n        MEM[704] = 0x42966c68;\n        MEM[416] = 0x9b1f9e74;\n        require(_checkBurnStatus);\n        require(_transfer ^ 0x0);\n        require(_totalSupply >= _dueTransferOf__buyer[2]);\n        _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    } else {\n        require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n        emit Transfer(msg.sender, varg1, _dueTransferOf__buyer[2]);\n        return 1;\n    }\n}\n\nfunction request(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 >= _dueTransferOf__buyer[5]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 <= block.timestamp);\n    require(!_dueTransferOf__buyer[6]);\n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, varg0), varg1))];\n    if (_fromToken <= _dueTransferOf__buyer[3]) {\n        if (_fromToken >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= _fromToken);\n            require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(varg0, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n    } else {\n        require(_fromToken >= _dueTransferOf__buyer[3]);\n        require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n        require(_fromToken);\n        require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n        STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= _dueTransferOf__buyer[2]);\n    _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n    emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(10, varg0)];\n}\n\nfunction etherbalanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(11, varg0)];\n}\n\nfunction usdbalanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(12, varg0)];\n}\n\nfunction stakeOf__holder(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(15, varg0), varg1))];\n}\n\nfunction stakeOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[1];\n}\n\nfunction stakeOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[2];\n}\n\nfunction stakeOf__dueDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[3];\n}\n\nfunction dueTransferOf__seller(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(16, varg0), varg1))];\n}\n\nfunction dueTransferOf__buyer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[1];\n}\n\nfunction dueTransferOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[2];\n}\n\nfunction dueTransferOf__netValue(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[3];\n}\n\nfunction dueTransferOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[4];\n}\n\nfunction dueTransferOf__subDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[5];\n}\n\nfunction dueTransferOf__declined(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0x6a054250) {\n                if (function_selector != 0x3714709) {\n                    if (function_selector != 0x587566ef) {\n                        if (function_selector != 0x97a2d0eb) {\n                            if (function_selector != 0x77884378) {\n                                if (function_selector != 0xdd62ed3e) {\n                                    if (function_selector != 0xa638f2e2) {\n                                        if (function_selector != 0x939624ab) {\n                                            if (function_selector != 0x49c662b8) {\n                                                if (function_selector != 0xa9059cbb) {\n                                                    if (function_selector != 0x23b872dd) {\n                                                        if (function_selector != 0xa6f12e85) {\n                                                            if (function_selector != 0x60dded11) {\n                                                                if (function_selector != 0x95ea7b3) {\n                                                                    if (function_selector != 0x48e45ca) {\n                                                                        if (function_selector != 0xc8c01a55) {\n                                                                            if (function_selector != 0x6fdde03) {\n                                                                                if (function_selector != 0x95d89b41) {\n                                                                                    if (function_selector != 0x313ce567) {\n                                                                                        if (function_selector != 0x70a08231) {\n                                                                                            if (function_selector != 0xfe92aff1) {\n                                                                                                if (function_selector != 0xbe6bf389) {\n                                                                                                    if (function_selector != 0x421f8e14) {\n                                                                                                        if (function_selector != 0xe9562a6d) {\n                                                                                                            if (function_selector != 0xf94be3af) {\n                                                                                                                if (function_selector != 0xbb3cb31b) {\n                                                                                                                    if (function_selector != 0x8f33367a) {\n                                                                                                                        if (function_selector != 0xb53574ab) {\n                                                                                                                            if (function_selector != 0xa1bb138e) {\n                                                                                                                                if (function_selector != 0x674b392e) {\n                                                                                                                                    if (function_selector != 0x410bf99) {\n                                                                                                                                        if (function_selector != 0x1952ddbd) {\n                                                                                                                                            if (function_selector == 0xb993ed4b) {\n                                                                                                                                                dueTransferOf__declined(address,uint256);\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            dueTransferOf__subDate(address,uint256);\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        dueTransferOf__setDate(address,uint256);\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    dueTransferOf__netValue(address,uint256);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                dueTransferOf__value(address,uint256);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            dueTransferOf__buyer(address,uint256);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        dueTransferOf__seller(address,uint256);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    stakeOf__dueDate(address,uint256);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                stakeOf__setDate(address,uint256);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            stakeOf__value(address,uint256);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        stakeOf__holder(address,uint256);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    usdbalanceOf(address);\n                                                                                                }\n                                                                                            } else {\n                                                                                                etherbalanceOf(address);\n                                                                                            }\n                                                                                        } else {\n                                                                                            balanceOf(address);\n                                                                                        }\n                                                                                    } else {\n                                                                                        decimals();\n                                                                                    }\n                                                                                } else {\n                                                                                    symbol();\n                                                                                }\n                                                                            } else {\n                                                                                name();\n                                                                            }\n                                                                        } else {\n                                                                            request(address,uint256);\n                                                                        }\n                                                                    } else {\n                                                                        resolve(uint256,address,bool);\n                                                                    }\n                                                                } else {\n                                                                    approve(address,uint256);\n                                                                }\n                                                            } else {\n                                                                declineTransfer(uint256);\n                                                            }\n                                                        } else {\n                                                            submitTransfer(uint256);\n                                                        }\n                                                    } else {\n                                                        transferFrom(address,address,uint256);\n                                                    }\n                                                } else {\n                                                    transfer(address,uint256);\n                                                }\n                                            } else {\n                                                setDueTransfer(uint256,address,uint256,uint256);\n                                            }\n                                        } else {\n                                            removeStake(uint256);\n                                        }\n                                    } else {\n                                        stake(uint256,uint256,uint256);\n                                    }\n                                } else {\n                                    allowance(address,address);\n                                }\n                            } else {\n                                checkBurnStatus();\n                            }\n                        } else {\n                            setBurnStatus(bool);\n                        }\n                    } else {\n                        toToken(string,uint256);\n                    }\n                } else {\n                    fromToken(string,uint256);\n                }\n            } else {\n                update(uint256,uint256,uint256);\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.28 10:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 _fromToken; // STORAGE[0x3]\nuint256 _toToken; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _decimals; // STORAGE[0x8]\nuint256 _checkBurnStatus; // STORAGE[0x9]\nuint256[] _stakeOf__value; // STORAGE[0xf]\nuint256[] _dueTransferOf__buyer; // STORAGE[0x10]\nuint256 _transfer; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 _update; // STORAGE[0x13]\nuint256 _setBurnStatus; // STORAGE[0x14]\nuint256 stor_15; // STORAGE[0x15]\nuint256 stor_16; // STORAGE[0x16]\n\n// Events\nTransfer(address, address, uint256);\nPay(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction update(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _update);\n    _fromToken = varg0;\n    _toToken = varg1;\n    stor_5 = varg2;\n    return 1;\n}\n\nfunction fromToken(string varg0, uint256 varg1) public nonPayable { \n    CALLDATACOPY(320, 4 + varg0, 36);\n    require(varg0.length <= 4);\n    require(STORAGE[keccak256(10, msg.sender)] >= STORAGE[keccak256(14, msg.sender)]);\n    require(STORAGE[keccak256(10, msg.sender)] - STORAGE[keccak256(14, msg.sender)] >= varg1, Error(32, 24, 'Not enough token balance'));\n    MEM[1312] = 0x6574680000000000000000000000000000000000000000000000000000000000;\n    if (keccak256(MEM[352 len (MEM[320])]) != keccak256(MEM[1312 len 3])) {\n        MEM[672] = 4;\n        if (MEM[352] != 0x7573647400000000000000000000000000000000000000000000000000000000) {\n            return 0;\n        } else {\n            require((varg1 * _fromToken / varg1 == _fromToken) | !varg1);\n            require(stor_5);\n            require(stor_7 >= varg1 * _fromToken / stor_5, Error(32, 48, 'There is not enough USDT in the ', 'contract to swap'));\n            require(stor_16.code.size);\n            require(this ^ stor_16);\n            v0 = stor_16.transfer(msg.sender, varg1 * _fromToken / stor_5).gas(msg.gas);\n            require(v0);\n            require(stor_7 >= varg1 * _fromToken / stor_5);\n            stor_7 = stor_7 - varg1 * _fromToken / stor_5;\n            require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n            require(STORAGE[keccak256(10, stor_15)] + varg1 >= STORAGE[keccak256(10, stor_15)]);\n            STORAGE[keccak256(10, stor_15)] = STORAGE[keccak256(10, stor_15)] + varg1;\n            return 1;\n        }\n    } else {\n        require((varg1 * _fromToken / varg1 == _fromToken) | !varg1);\n        require(_toToken);\n        require(stor_6 >= varg1 * _fromToken / _toToken, Error(32, 47, 'There is not enough eth in the c', 'ontract to swap'));\n        v1 = msg.sender.call().value(varg1 * _fromToken / _toToken);\n        require(v1);\n        require(stor_6 >= varg1 * _fromToken / _toToken);\n        stor_6 = stor_6 - varg1 * _fromToken / _toToken;\n        require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n        require(STORAGE[keccak256(10, stor_15)] + varg1 >= STORAGE[keccak256(10, stor_15)]);\n        STORAGE[keccak256(10, stor_15)] = STORAGE[keccak256(10, stor_15)] + varg1;\n        return 1;\n    }\n}\n\nfunction toToken(string varg0, uint256 varg1) public payable { \n    CALLDATACOPY(320, 4 + varg0, 36);\n    require(varg0.length <= 4);\n    MEM[1312] = 0x6574680000000000000000000000000000000000000000000000000000000000;\n    if (keccak256(MEM[352 len (MEM[320])]) != keccak256(MEM[1312 len 3])) {\n        MEM[512] = 4;\n        if (MEM[352] != 0x7573647400000000000000000000000000000000000000000000000000000000) {\n            return 0;\n        } else {\n            require((stor_5 * varg1 / stor_5 == varg1) | !stor_5);\n            require(_fromToken);\n            require(STORAGE[keccak256(10, stor_15)] >= stor_5 * varg1 / _fromToken, Error(32, 32, 'No enough tokens in the contract'));\n            require(stor_7 + varg1 >= stor_7);\n            require(stor_6 == stor_7 + varg1, Error(32, 16, 'No USDT received'));\n            require(stor_15.code.size);\n            require(this ^ stor_15);\n            v0 = stor_15.transfer(msg.sender, stor_5 * varg1 / _fromToken).gas(msg.gas);\n            require(v0);\n            return 1;\n        }\n    } else {\n        require((_toToken * varg1 / _toToken == varg1) | !_toToken);\n        require(_fromToken);\n        require(STORAGE[keccak256(10, stor_15)] >= _toToken * varg1 / _fromToken, Error(32, 32, 'No enough tokens in the contract'));\n        require(stor_6 + varg1 >= stor_6);\n        require(stor_6 == stor_6 + varg1, Error(32, 15, 'No eth received'));\n        require(stor_15.code.size);\n        require(this ^ stor_15);\n        v1 = stor_15.transfer(msg.sender, _toToken * varg1 / _fromToken).gas(msg.gas);\n        require(v1);\n        return 1;\n    }\n}\n\nfunction setBurnStatus(bool varg0) public nonPayable { \n    require(varg0 < 2);\n    require(msg.sender == _setBurnStatus);\n    _checkBurnStatus = varg0;\n    return 1;\n}\n\nfunction checkBurnStatus() public nonPayable { \n    return _checkBurnStatus;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(13, varg0), varg1)];\n}\n\nfunction stake(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(STORAGE[keccak256(10, msg.sender)] >= varg0);\n    STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg2))] = msg.sender;\n    _stakeOf__value[1] = varg0;\n    _stakeOf__value[2] = block.timestamp;\n    _stakeOf__value[3] = varg1;\n    require(STORAGE[keccak256(14, msg.sender)] + varg0 >= STORAGE[keccak256(14, msg.sender)]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] + varg0;\n    return 1;\n}\n\nfunction removeStake(uint256 varg0) public nonPayable { \n    require(_stakeOf__value[1] > 0);\n    if (block.timestamp < _stakeOf__value[3]) {\n        STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        _stakeOf__value[3] = 0;\n        require(STORAGE[keccak256(14, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    } else {\n        require(STORAGE[keccak256(10, msg.sender)] + _stakeOf__value[1] / 1000 >= STORAGE[keccak256(10, msg.sender)]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] + _stakeOf__value[1] / 1000;\n        require(STORAGE[keccak256(10, stor_12)] >= _stakeOf__value[1] / 1000);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - _stakeOf__value[1] / 1000;\n        require(_totalSupply >= _stakeOf__value[1] / 1000);\n        _totalSupply = _totalSupply - _stakeOf__value[1] / 1000;\n        emit Transfer(stor_12, msg.sender, _stakeOf__value[1] / 1000);\n        STORAGE[keccak256(keccak256(keccak256(15, msg.sender), varg0))] = msg.sender;\n        _stakeOf__value[1] = 0;\n        _stakeOf__value[2] = 0;\n        _stakeOf__value[3] = 0;\n        require(STORAGE[keccak256(14, msg.sender)] >= _stakeOf__value[1]);\n        STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _stakeOf__value[1];\n        return 1;\n    }\n}\n\nfunction setDueTransfer(uint256 varg0, address varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg2);\n    require(!_dueTransferOf__buyer[2]);\n    require((0x15180 * varg3 / 0x15180 == varg3) | !0x15180);\n    require(0x15180 * varg3 + block.timestamp >= 0x15180 * varg3);\n    STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))] = varg1;\n    _dueTransferOf__buyer[1] = msg.sender;\n    _dueTransferOf__buyer[2] = varg2;\n    _dueTransferOf__buyer[3] = _fromToken;\n    _dueTransferOf__buyer[4] = block.timestamp;\n    _dueTransferOf__buyer[5] = 0x15180 * varg3 + block.timestamp;\n    _dueTransferOf__buyer[6] = 0;\n    require(STORAGE[keccak256(14, msg.sender)] + varg2 >= STORAGE[keccak256(14, msg.sender)]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] + varg2;\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n    require(STORAGE[keccak256(14, msg.sender)] <= STORAGE[keccak256(10, msg.sender)] - varg1);\n    require(STORAGE[keccak256(10, msg.sender)] >= varg1);\n    STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - varg1;\n    require(STORAGE[keccak256(10, varg0)] + varg1 >= STORAGE[keccak256(10, varg0)]);\n    STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= varg1 / 100);\n    _totalSupply = _totalSupply - varg1 / 100;\n    require(STORAGE[keccak256(10, _transfer)] >= varg1 / 100);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - varg1 / 100;\n    emit Transfer(_transfer, 0, varg1 / 100);\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(10, varg0)] >= varg2);\n    require(STORAGE[keccak256(14, varg0)] <= STORAGE[keccak256(10, varg0)] - varg2);\n    require(STORAGE[keccak256(10, varg0)] >= varg2);\n    STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - varg2;\n    require(STORAGE[keccak256(10, varg1)] + varg2 >= STORAGE[keccak256(10, varg1)]);\n    STORAGE[keccak256(10, varg1)] = STORAGE[keccak256(10, varg1)] + varg2;\n    require(STORAGE[keccak256(keccak256(13, varg0), msg.sender)] >= varg2);\n    STORAGE[keccak256(keccak256(13, varg0), msg.sender)] = STORAGE[keccak256(keccak256(13, varg0), msg.sender)] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    MEM[416] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= varg2 / 100);\n    _totalSupply = _totalSupply - varg2 / 100;\n    require(STORAGE[keccak256(10, _transfer)] >= varg2 / 100);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - varg2 / 100;\n    emit Transfer(_transfer, 0, varg2 / 100);\n}\n\nfunction submitTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))];\n    if (_fromToken <= _dueTransferOf__buyer[3]) {\n        if (_fromToken >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= _fromToken);\n            require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(msg.sender, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n    } else {\n        require(_fromToken >= _dueTransferOf__buyer[3]);\n        require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n        require(_fromToken);\n        require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n        STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= _dueTransferOf__buyer[2]);\n    _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n    emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n}\n\nfunction declineTransfer(uint256 varg0) public nonPayable { \n    require(_dueTransferOf__buyer[2] > 0);\n    MEM[384] = STORAGE[keccak256(keccak256(keccak256(16, msg.sender), varg0))];\n    require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _update)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, _update)]);\n    STORAGE[keccak256(10, _update)] = STORAGE[keccak256(10, _update)] + _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(14, msg.sender)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(14, msg.sender)] = STORAGE[keccak256(14, msg.sender)] - _dueTransferOf__buyer[2];\n    _dueTransferOf__buyer[6] = 1;\n    emit Transfer(msg.sender, _update, _dueTransferOf__buyer[2]);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(13, msg.sender), varg0)] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction resolve(uint256 varg0, address varg1, bool varg2) public nonPayable { \n    require(varg1 < MEM[32]);\n    require(varg2 < 2);\n    require(msg.sender == _update);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, varg1), varg0))];\n    if (!varg2) {\n        if (_fromToken <= _dueTransferOf__buyer[3]) {\n            if (_fromToken >= _dueTransferOf__buyer[3]) {\n                require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(10, v0)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] - _dueTransferOf__buyer[2];\n                emit Pay(varg1, v0, _dueTransferOf__buyer[2]);\n            } else {\n                require(_dueTransferOf__buyer[3] >= _fromToken);\n                require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n                require(_fromToken);\n                require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n                STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n                require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n                STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n                STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n                require(_dueTransferOf__buyer[3]);\n                require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n                emit Pay(msg.sender, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n                emit Transfer(varg1, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n            }\n        } else {\n            require(_fromToken >= _dueTransferOf__buyer[3]);\n            require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg1, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n        MEM[704] = 0x42966c68;\n        MEM[416] = 0x9b1f9e74;\n        require(_checkBurnStatus);\n        require(_transfer ^ 0x0);\n        require(_totalSupply >= _dueTransferOf__buyer[2]);\n        _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n        emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n    } else {\n        require(STORAGE[keccak256(10, msg.sender)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, msg.sender)] = STORAGE[keccak256(10, msg.sender)] - _dueTransferOf__buyer[2];\n        emit Transfer(msg.sender, varg1, _dueTransferOf__buyer[2]);\n        return 1;\n    }\n}\n\nfunction request(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 >= _dueTransferOf__buyer[5]);\n    require(_dueTransferOf__buyer[5] + 0x3f480 <= block.timestamp);\n    require(!_dueTransferOf__buyer[6]);\n    require(_dueTransferOf__buyer[2] > 0);\n    v0 = STORAGE[keccak256(keccak256(keccak256(16, varg0), varg1))];\n    if (_fromToken <= _dueTransferOf__buyer[3]) {\n        if (_fromToken >= _dueTransferOf__buyer[3]) {\n            require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2];\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2]);\n        } else {\n            require(_dueTransferOf__buyer[3] >= _fromToken);\n            require(((_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / (_dueTransferOf__buyer[3] - _fromToken) == _dueTransferOf__buyer[2]) | !(_dueTransferOf__buyer[3] - _fromToken));\n            require(_fromToken);\n            require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n            STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n            require(STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken >= STORAGE[keccak256(10, stor_12)]);\n            STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] + (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken;\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n            STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n            require(_dueTransferOf__buyer[3]);\n            require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n            emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n            emit Transfer(varg0, stor_12, (_dueTransferOf__buyer[3] - _fromToken) * _dueTransferOf__buyer[2] / _fromToken);\n        }\n    } else {\n        require(_fromToken >= _dueTransferOf__buyer[3]);\n        require(((_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / (_fromToken - _dueTransferOf__buyer[3]) == _dueTransferOf__buyer[2]) | !(_fromToken - _dueTransferOf__buyer[3]));\n        require(_fromToken);\n        require(STORAGE[keccak256(10, varg0)] >= _dueTransferOf__buyer[2]);\n        STORAGE[keccak256(10, varg0)] = STORAGE[keccak256(10, varg0)] - _dueTransferOf__buyer[2];\n        require(STORAGE[keccak256(10, stor_12)] >= (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n        STORAGE[keccak256(10, stor_12)] = STORAGE[keccak256(10, stor_12)] - (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken;\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        require(STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) >= STORAGE[keccak256(10, v0)]);\n        STORAGE[keccak256(10, v0)] = STORAGE[keccak256(10, v0)] + _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]);\n        require(_dueTransferOf__buyer[3]);\n        require((_dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]) / _dueTransferOf__buyer[2] == _fromToken / _dueTransferOf__buyer[3]) | !_dueTransferOf__buyer[2]);\n        emit Pay(varg0, v0, _dueTransferOf__buyer[2] * (_fromToken / _dueTransferOf__buyer[3]));\n        emit Transfer(stor_12, v0, (_fromToken - _dueTransferOf__buyer[3]) * _dueTransferOf__buyer[2] / _fromToken);\n    }\n    MEM[704] = 0x42966c68;\n    MEM[416] = 0x9b1f9e74;\n    require(_checkBurnStatus);\n    require(_transfer ^ 0x0);\n    require(_totalSupply >= _dueTransferOf__buyer[2]);\n    _totalSupply = _totalSupply - _dueTransferOf__buyer[2];\n    require(STORAGE[keccak256(10, _transfer)] >= _dueTransferOf__buyer[2]);\n    STORAGE[keccak256(10, _transfer)] = STORAGE[keccak256(10, _transfer)] - _dueTransferOf__buyer[2];\n    emit Transfer(_transfer, 0, _dueTransferOf__buyer[2]);\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (3 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(1)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    CALLDATACOPY(416 + MEM[384], msg.data.length, MEM[384] + 31 - (MEM[384] - 1) % 32 - MEM[384]);\n    return 32;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(10, varg0)];\n}\n\nfunction etherbalanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(11, varg0)];\n}\n\nfunction usdbalanceOf(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(12, varg0)];\n}\n\nfunction stakeOf__holder(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(15, varg0), varg1))];\n}\n\nfunction stakeOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[1];\n}\n\nfunction stakeOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[2];\n}\n\nfunction stakeOf__dueDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _stakeOf__value[3];\n}\n\nfunction dueTransferOf__seller(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(keccak256(keccak256(16, varg0), varg1))];\n}\n\nfunction dueTransferOf__buyer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[1];\n}\n\nfunction dueTransferOf__value(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[2];\n}\n\nfunction dueTransferOf__netValue(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[3];\n}\n\nfunction dueTransferOf__setDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[4];\n}\n\nfunction dueTransferOf__subDate(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[5];\n}\n\nfunction dueTransferOf__declined(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 < MEM[32]);\n    return _dueTransferOf__buyer[6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0x18160ddd) {\n            if (function_selector != 0x6a054250) {\n                if (function_selector != 0x3714709) {\n                    if (function_selector != 0x587566ef) {\n                        if (function_selector != 0x97a2d0eb) {\n                            if (function_selector != 0x77884378) {\n                                if (function_selector != 0xdd62ed3e) {\n                                    if (function_selector != 0xa638f2e2) {\n                                        if (function_selector != 0x939624ab) {\n                                            if (function_selector != 0x49c662b8) {\n                                                if (function_selector != 0xa9059cbb) {\n                                                    if (function_selector != 0x23b872dd) {\n                                                        if (function_selector != 0xa6f12e85) {\n                                                            if (function_selector != 0x60dded11) {\n                                                                if (function_selector != 0x95ea7b3) {\n                                                                    if (function_selector != 0x48e45ca) {\n                                                                        if (function_selector != 0xc8c01a55) {\n                                                                            if (function_selector != 0x6fdde03) {\n                                                                                if (function_selector != 0x95d89b41) {\n                                                                                    if (function_selector != 0x313ce567) {\n                                                                                        if (function_selector != 0x70a08231) {\n                                                                                            if (function_selector != 0xfe92aff1) {\n                                                                                                if (function_selector != 0xbe6bf389) {\n                                                                                                    if (function_selector != 0x421f8e14) {\n                                                                                                        if (function_selector != 0xe9562a6d) {\n                                                                                                            if (function_selector != 0xf94be3af) {\n                                                                                                                if (function_selector != 0xbb3cb31b) {\n                                                                                                                    if (function_selector != 0x8f33367a) {\n                                                                                                                        if (function_selector != 0xb53574ab) {\n                                                                                                                            if (function_selector != 0xa1bb138e) {\n                                                                                                                                if (function_selector != 0x674b392e) {\n                                                                                                                                    if (function_selector != 0x410bf99) {\n                                                                                                                                        if (function_selector != 0x1952ddbd) {\n                                                                                                                                            if (function_selector == 0xb993ed4b) {\n                                                                                                                                                dueTransferOf__declined(address,uint256);\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            dueTransferOf__subDate(address,uint256);\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        dueTransferOf__setDate(address,uint256);\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    dueTransferOf__netValue(address,uint256);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                dueTransferOf__value(address,uint256);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            dueTransferOf__buyer(address,uint256);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        dueTransferOf__seller(address,uint256);\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    stakeOf__dueDate(address,uint256);\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                stakeOf__setDate(address,uint256);\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            stakeOf__value(address,uint256);\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        stakeOf__holder(address,uint256);\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    usdbalanceOf(address);\n                                                                                                }\n                                                                                            } else {\n                                                                                                etherbalanceOf(address);\n                                                                                            }\n                                                                                        } else {\n                                                                                            balanceOf(address);\n                                                                                        }\n                                                                                    } else {\n                                                                                        decimals();\n                                                                                    }\n                                                                                } else {\n                                                                                    symbol();\n                                                                                }\n                                                                            } else {\n                                                                                name();\n                                                                            }\n                                                                        } else {\n                                                                            request(address,uint256);\n                                                                        }\n                                                                    } else {\n                                                                        resolve(uint256,address,bool);\n                                                                    }\n                                                                } else {\n                                                                    approve(address,uint256);\n                                                                }\n                                                            } else {\n                                                                declineTransfer(uint256);\n                                                            }\n                                                        } else {\n                                                            submitTransfer(uint256);\n                                                        }\n                                                    } else {\n                                                        transferFrom(address,address,uint256);\n                                                    }\n                                                } else {\n                                                    transfer(address,uint256);\n                                                }\n                                            } else {\n                                                setDueTransfer(uint256,address,uint256,uint256);\n                                            }\n                                        } else {\n                                            removeStake(uint256);\n                                        }\n                                    } else {\n                                        stake(uint256,uint256,uint256);\n                                    }\n                                } else {\n                                    allowance(address,address);\n                                }\n                            } else {\n                                checkBurnStatus();\n                            }\n                        } else {\n                            setBurnStatus(bool);\n                        }\n                    } else {\n                        toToken(string,uint256);\n                    }\n                } else {\n                    fromToken(string,uint256);\n                }\n            } else {\n                update(uint256,uint256,uint256);\n            }\n        } else {\n            totalSupply();\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 112.28433012962341,
	"usage": {
		"completion_tokens": 1192,
		"prompt_tokens": 10887,
		"total_tokens": 12079
	}
}