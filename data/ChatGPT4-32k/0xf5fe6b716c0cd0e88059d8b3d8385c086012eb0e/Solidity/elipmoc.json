{
	"address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 09:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_1; // STORAGE[0x1]\nuint256 _getTimeLeft; // STORAGE[0x2]\nuint256 _airDropPot_; // STORAGE[0x3]\nuint256 _airDropTracker_; // STORAGE[0x4]\nuint256 _rID_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyr_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xe]\nuint160 _setOtherFomo; // STORAGE[0x0] bytes 0 to 19\nuint8 _activated_; // STORAGE[0xf] bytes 0 to 0\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1]\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3]\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonPotSwapDeposit(uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonAffiliatePayout(uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256, uint256);\n\nfunction 0x14b8() private { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v0 = v1 = block.timestamp > _round_[msg.sender][2];\n    if (v1) {\n        v0 = v2 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v0) {\n        v0 = v3 = _round_[_rID_];\n    }\n    if (!v0) {\n        v4 = 0x3d0e(_pIDxAddr_[msg.sender]);\n        if (v4 > 0) {\n            v5 = address(_plyr_[_pIDxAddr_[msg.sender]]).call().value(v4).gas(2300 * !v4);\n            require(v5); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(_pIDxAddr_[msg.sender], msg.sender, _plyr_[_pIDxAddr_[msg.sender]][1], v4, block.timestamp);\n        return ;\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v6 = v7 = MEM[64];\n        MEM[v7] = 0;\n        MEM[32 + v7] = 0;\n        MEM[64 + v7] = 0;\n        MEM[96 + v7] = 0;\n        MEM[128 + v7] = 0;\n        MEM[160 + v7] = 0;\n        MEM[192 + v7] = 0;\n        MEM[224 + v7] = 0;\n        MEM[256 + v7] = 0;\n        v6 = v8 = _rID_;\n        v6 = v9 = 0;\n        v6 = v10 = _round_[v8];\n        v6 = v11 = _round_[v8][1];\n        v6 = v12 = _round_[v8][7];\n        if (v12) {\n            v13 = 48 * v12;\n            assert(v12);\n            require(v13 / v12 == 48, 'SafeMath mul failed');\n        } else {\n            v13 = v14 = 0;\n        }\n        assert(100);\n        v6 = v15 = v13 / 100;\n        v6 = v16 = v12 / 25;\n        if (v12) {\n            v17 = _potSplit_[v11] * v12;\n            assert(v12);\n            require(v17 / v12 == _potSplit_[v11], 'SafeMath mul failed');\n        } else {\n            v17 = v18 = 0;\n        }\n        assert(100);\n        v6 = v19 = v17 / 100;\n        if (v12) {\n            v20 = _potSplit_[v11][1] * v12;\n            assert(v12);\n            require(v20 / v12 == _potSplit_[v11][1], 'SafeMath mul failed');\n        } else {\n            v20 = v21 = 0;\n        }\n        assert(100);\n        v6 = v22 = v20 / 100;\n        v6 = v23 = 13866;\n        v6 = v24 = 7583;\n        require(v15 <= v12, 'SafeMath sub failed');\n        v25 = v26 = v12 - v15;\n        while (v6 > v25) {\n            require(v6 <= v25, 'SafeMath sub failed');\n            if (v6) {\n                v27 = 0xde0b6b3a7640000 * v6;\n                assert(v6);\n                require(v27 / v6 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(_round_[v6][5]);\n            if (v27 / _round_[v6][5]) {\n                v29 = _round_[v6][5] * (v27 / _round_[v6][5]);\n                assert(v27 / _round_[v6][5]);\n                require(v29 / (v27 / _round_[v6][5]) == _round_[v6][5], 'SafeMath mul failed');\n            } else {\n                v29 = v30 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            require(v29 / 0xde0b6b3a7640000 <= v6, 'SafeMath sub failed');\n            if (v6 - v29 / 0xde0b6b3a7640000 > 0) {\n                require(v6 - v29 / 0xde0b6b3a7640000 <= v6, 'SafeMath sub failed');\n                v6 = v31 = v6 - (v6 - v29 / 0xde0b6b3a7640000);\n                v25 = v32 = v6 - v29 / 0xde0b6b3a7640000 + v25;\n                require(v32 >= v25, 'SafeMath add failed');\n            }\n            v33 = v34 = 14055;\n            v33 = v35 = _rID_;\n            v33 = v36 = 0;\n            v6 = v37 = _round_[v35][22];\n            while (v33 < v37) {\n                assert(v33 < 10);\n                v33 = v33 + 1;\n                v33 += _plyr_[STORAGE[v33 + (12 + keccak256(v35, 11))]][7];\n            }\n            v6 = v38 = 0;\n            while (v6 < v6) {\n                if (v6 < 10) {\n                    break;\n                }\n                assert(v6 < 10);\n                v33 = v39 = STORAGE[v6 + (12 + keccak256(v33, 11))];\n                v33 = v40 = _plyr_[v39][2];\n                v6 = v41 = 21514;\n                v6 = v42 = 14825;\n                if (v33) {\n                    break;\n                }\n                assert(v33);\n                if (v6) {\n                    v43 = _plyr_[v39][7] / v33 * v6;\n                    assert(v6);\n                    require(v43 / v6 == _plyr_[v39][7] / v33, 'SafeMath mul failed');\n                } else {\n                    v43 = v44 = 0;\n                }\n                while (1) {\n                    goto {'0x540aB0x36deB0x15da', '0x39e90x5341B0x36deB0x15da'};\n                    v43 += v33;\n                    if (v43 >= v43) {\n                        break;\n                    }\n                    require(v43 >= v43, 'SafeMath add failed');\n                }\n                _plyr_[v33][2] = v43;\n                v6 = v6 + 1;\n            }\n            require(_round_[v6][8] + v27 / _round_[v6][5] >= v27 / _round_[v6][5], 'SafeMath add failed');\n            _round_[v6][8] = _round_[v6][8] + v27 / _round_[v6][5];\n            if (v6 > 0) {\n                if (v6) {\n                    v45 = 20 * v6;\n                    assert(v6);\n                    require(v45 / v6 == 20, 'SafeMath mul failed');\n                } else {\n                    v45 = v46 = 0;\n                }\n                assert(100);\n                v47 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v45 / 100).gas(!(v45 / 100) * 2300);\n                require(v47); // checks call status, propagates error data on error\n                if (v6) {\n                    v48 = 20 * v6;\n                    assert(v6);\n                    require(v48 / v6 == 20, 'SafeMath mul failed');\n                } else {\n                    v48 = v49 = 0;\n                }\n                assert(100);\n                v50 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v48 / 100).gas(!(v48 / 100) * 2300);\n                require(v50); // checks call status, propagates error data on error\n                if (v6) {\n                    v51 = 50 * v6;\n                    assert(v6);\n                    require(v51 / v6 == 50, 'SafeMath mul failed');\n                } else {\n                    v51 = v52 = 0;\n                }\n                assert(100);\n                v53 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v51 / 100).gas(!(v51 / 100) * 2300);\n                require(v53); // checks call status, propagates error data on error\n                if (v6) {\n                    v54 = 10 * v6;\n                    assert(v6);\n                    require(v54 / v6 == 10, 'SafeMath mul failed');\n                } else {\n                    v54 = v55 = 0;\n                }\n                assert(100);\n                v56 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v54 / 100).gas(!(v54 / 100) * 2300);\n                require(v56); // checks call status, propagates error data on error\n            }\n            MEM[0 + v6] = MEM[0 + v6] + 0xf4240 * _round_[v6][2];\n            MEM[32 + v6] = MEM[32 + v6] + 0x52b7d2dcc80cd2e4000000 * v6 + 0x16345785d8a0000 * v6;\n            MEM[64 + v6] = address(_round_[v6][0]);\n            MEM[96 + v6] = ~0x0 & (~0x0 & _round_[v6][0x1]);\n            MEM[128 + v6] = v6;\n            MEM[224 + v6] = v6;\n            MEM[192 + v6] = v6;\n            MEM[160 + v6] = v25;\n            _rID_ += 1;\n            _round_[v6][4] = block.timestamp;\n            require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n            require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n            _round_[1 + v6][2] = _getTimeLeft + (0x15180 + block.timestamp);\n            _round_[1 + v6][7] = v25;\n            v57 = 0x3d0e(msg.sender.code.size);\n            if (v57 > 0) {\n                v58 = address(_plyr_[msg.sender.code.size]).call().value(v57).gas(2300 * !v57);\n                require(v58); // checks call status, propagates error data on error\n            }\n            MEM[0 + v6] = MEM[0 + v6] + 0xde0b6b3a7640000 * msg.sender;\n            MEM[32 + v6] = MEM[32 + v6] + msg.sender.code.size;\n            emit 0xbd0dba8ab932212fa78150cdb7b0275da72e255875967b5cad11464cf71bedc(msg.sender, ~0x0 & (~0x0 & _plyr_[msg.sender.code.size][0x1]), v57, MEM[0 + v6], MEM[32 + v6], address(MEM[64 + v6]), ~0x0 & (~0x0 & MEM[96 + v6]), MEM[128 + v6], MEM[160 + v6], MEM[192 + v6], MEM[224 + v6]);\n            return _pIDxAddr_[msg.sender], block.timestamp, _rID_;\n            v25 = v25 - v6;\n            goto {'0x362aB0x15da', '0x1d9f0x355aB0x15da'};\n        }\n    }\n}\n\nfunction fallback() public payable { \n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x16345785d8a0000, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v0, v1 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v2, v3 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] = 1;\n    }\n    v8 = _pIDxAddr_[_pIDxAddr_[msg.sender]][6];\n    v9 = _rID_;\n    v10 = v11 = block.timestamp > _getTimeLeft + _round_[v9][4];\n    if (v11) {\n        v10 = v12 = block.timestamp <= _round_[v9][2];\n        if (block.timestamp > _round_[v9][2]) {\n            v10 = v13 = block.timestamp > _round_[v9][2];\n            if (v13) {\n                v10 = !_round_[v9];\n            }\n        }\n    }\n    if (!v10) {\n        v14 = v15 = block.timestamp > _round_[v9][2];\n        if (v15) {\n            v14 = !(0xff & _round_[v9][0x3]);\n        }\n        if (v14) {\n            _round_[v9][3] = 0x1 | ~0xff & _round_[v9][0x3];\n            v16 = v17 = MEM[64];\n            MEM[v17] = 0;\n            MEM[32 + v17] = 0;\n            MEM[64 + v17] = 0;\n            MEM[96 + v17] = 0;\n            MEM[128 + v17] = 0;\n            MEM[160 + v17] = 0;\n            MEM[192 + v17] = 0;\n            MEM[224 + v17] = 0;\n            MEM[256 + v17] = 0;\n            v16 = v18 = _rID_;\n            v16 = v19 = 0;\n            v16 = v20 = _round_[v18];\n            v16 = v21 = _round_[v18][1];\n            v16 = v22 = _round_[v18][7];\n            if (v22) {\n                v23 = 48 * v22;\n                assert(v22);\n                require(v23 / v22 == 48, 'SafeMath mul failed');\n            } else {\n                v23 = v24 = 0;\n            }\n            assert(100);\n            v16 = v25 = v23 / 100;\n            v16 = v26 = v22 / 25;\n            if (v22) {\n                v27 = _potSplit_[v21] * v22;\n                assert(v22);\n                require(v27 / v22 == _potSplit_[v21], 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(100);\n            v16 = v29 = v27 / 100;\n            if (v22) {\n                v30 = _potSplit_[v21][1] * v22;\n                assert(v22);\n                require(v30 / v22 == _potSplit_[v21][1], 'SafeMath mul failed');\n            } else {\n                v30 = v31 = 0;\n            }\n            assert(100);\n            v16 = v32 = v30 / 100;\n            v16 = v33 = 13866;\n            v16 = v34 = 7583;\n            require(v25 <= v22, 'SafeMath sub failed');\n            v35 = v36 = v22 - v25;\n            while (v16 > v35) {\n                require(v16 <= v35, 'SafeMath sub failed');\n                if (v16) {\n                    v37 = 0xde0b6b3a7640000 * v16;\n                    assert(v16);\n                    require(v37 / v16 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v37 = v38 = 0;\n                }\n                assert(_round_[v16][5]);\n                if (v37 / _round_[v16][5]) {\n                    v39 = _round_[v16][5] * (v37 / _round_[v16][5]);\n                    assert(v37 / _round_[v16][5]);\n                    require(v39 / (v37 / _round_[v16][5]) == _round_[v16][5], 'SafeMath mul failed');\n                } else {\n                    v39 = v40 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v39 / 0xde0b6b3a7640000 <= v16, 'SafeMath sub failed');\n                if (v16 - v39 / 0xde0b6b3a7640000 > 0) {\n                    require(v16 - v39 / 0xde0b6b3a7640000 <= v16, 'SafeMath sub failed');\n                    v16 = v41 = v16 - (v16 - v39 / 0xde0b6b3a7640000);\n                    v35 = v42 = v16 - v39 / 0xde0b6b3a7640000 + v35;\n                    require(v42 >= v35, 'SafeMath add failed');\n                }\n                v43 = v44 = 14055;\n                v43 = v45 = _rID_;\n                v43 = v46 = 0;\n                v16 = v47 = _round_[v45][22];\n                while (v43 < v47) {\n                    assert(v43 < 10);\n                    v43 = v43 + 1;\n                    v43 += _plyr_[STORAGE[v43 + (12 + keccak256(v45, 11))]][7];\n                }\n                v16 = v48 = 0;\n                while (v16 < v16) {\n                    if (v16 < 10) {\n                        break;\n                    }\n                    assert(v16 < 10);\n                    v43 = v49 = STORAGE[v16 + (12 + keccak256(v43, 11))];\n                    v43 = v50 = _plyr_[v49][2];\n                    v16 = v51 = 21514;\n                    v16 = v52 = 14825;\n                    if (v43) {\n                        break;\n                    }\n                    assert(v43);\n                    if (v16) {\n                        v53 = _plyr_[v49][7] / v43 * v16;\n                        assert(v16);\n                        require(v53 / v16 == _plyr_[v49][7] / v43, 'SafeMath mul failed');\n                    } else {\n                        v53 = v54 = 0;\n                    }\n                    while (1) {\n                        goto {'0x39e90x5341B0x36deB0xd89B0x334', '0x540aB0x36deB0xd89B0x334'};\n                        v53 += v43;\n                        if (v53 >= v53) {\n                            break;\n                        }\n                        require(v53 >= v53, 'SafeMath add failed');\n                    }\n                    _plyr_[v43][2] = v53;\n                    v16 = v16 + 1;\n                }\n                require(_round_[v16][8] + v37 / _round_[v16][5] >= v37 / _round_[v16][5], 'SafeMath add failed');\n                _round_[v16][8] = _round_[v16][8] + v37 / _round_[v16][5];\n                if (v16 > 0) {\n                    if (v16) {\n                        v55 = 20 * v16;\n                        assert(v16);\n                        require(v55 / v16 == 20, 'SafeMath mul failed');\n                    } else {\n                        v55 = v56 = 0;\n                    }\n                    assert(100);\n                    v57 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v55 / 100).gas(!(v55 / 100) * 2300);\n                    require(v57); // checks call status, propagates error data on error\n                    if (v16) {\n                        v58 = 20 * v16;\n                        assert(v16);\n                        require(v58 / v16 == 20, 'SafeMath mul failed');\n                    } else {\n                        v58 = v59 = 0;\n                    }\n                    assert(100);\n                    v60 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v58 / 100).gas(!(v58 / 100) * 2300);\n                    require(v60); // checks call status, propagates error data on error\n                    if (v16) {\n                        v61 = 50 * v16;\n                        assert(v16);\n                        require(v61 / v16 == 50, 'SafeMath mul failed');\n                    } else {\n                        v61 = v62 = 0;\n                    }\n                    assert(100);\n                    v63 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v61 / 100).gas(!(v61 / 100) * 2300);\n                    require(v63); // checks call status, propagates error data on error\n                    if (v16) {\n                        v64 = 10 * v16;\n                        assert(v16);\n                        require(v64 / v16 == 10, 'SafeMath mul failed');\n                    } else {\n                        v64 = v65 = 0;\n                    }\n                    assert(100);\n                    v66 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v64 / 100).gas(!(v64 / 100) * 2300);\n                    require(v66); // checks call status, propagates error data on error\n                }\n                MEM[0 + v16] = MEM[0 + v16] + 0xf4240 * _round_[v16][2];\n                MEM[32 + v16] = MEM[32 + v16] + 0x52b7d2dcc80cd2e4000000 * v16 + 0x16345785d8a0000 * v16;\n                MEM[64 + v16] = address(_round_[v16][0]);\n                MEM[96 + v16] = ~0x0 & (~0x0 & _round_[v16][0x1]);\n                MEM[128 + v16] = v16;\n                MEM[224 + v16] = v16;\n                MEM[192 + v16] = v16;\n                MEM[160 + v16] = v35;\n                _rID_ += 1;\n                _round_[v16][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v16][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v16][7] = v35;\n                MEM[0 + v16] = MEM[0 + v16] + 0xde0b6b3a7640000 * v18;\n                MEM[32 + v16] = MEM[32 + v16] + v9;\n                emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v9][0x1]), msg.value, MEM[0 + v16], MEM[32 + v16], address(MEM[64 + v16]), ~0x0 & (~0x0 & MEM[96 + v16]), MEM[128 + v16], MEM[160 + v16], MEM[192 + v16], MEM[224 + v16]);\n                v35 = v35 - v16;\n                goto {'0x1d9f0x355aB0xd89B0x334', '0x362aB0xd89B0x334'};\n            }\n        }\n        require(msg.value + _plyr_[v9][3] >= _plyr_[v9][3], 'SafeMath add failed');\n        _plyr_[v9][3] += msg.value;\n    } else {\n        0x2fb5(v67);\n        0x3280(MEM[64], v67, v67, msg.value, v67);\n    }\n}\n\nfunction 0x2fb5(uint256 varg0) private { \n    v0 = _rID_;\n    if (_round_[v0][22]) {\n        if (10 <= _round_[v0][22]) {\n            assert(~0 + _round_[_rID_][22] < 10);\n            if (STORAGE[~0 + _round_[_rID_][22] + (12 + keccak256(_rID_, 11))] != varg0) {\n                v1 = v2 = 0;\n                _round_[v0][22] = 10;\n                while (v1 < ~0 + _round_[v0][22]) {\n                    assert(v1 + 1 < 10);\n                    assert(v1 < 10);\n                    STORAGE[v1 + (12 + keccak256(_rID_, 11))] = STORAGE[v1 + 1 + (12 + keccak256(_rID_, 11))];\n                    v1 += 1;\n                }\n                assert(~0 + _round_[_rID_][22] < 10);\n                STORAGE[~0 + _round_[_rID_][22] + (12 + keccak256(_rID_, 11))] = varg0;\n                return ;\n            }\n        } else {\n            assert(~0 + _round_[_rID_][22] < 10);\n            if (STORAGE[~0 + _round_[_rID_][22] + (12 + keccak256(_rID_, 11))] != varg0) {\n                v3 = v4 = 0;\n                while (v3 < _round_[v0][22]) {\n                    assert(v3 < 10);\n                    if (varg0 != STORAGE[v3 + (12 + keccak256(_rID_, 11))]) {\n                        v3 += 1;\n                    } else {\n                        v3 = v5 = 1;\n                        break;\n                    }\n                }\n                if (v3) {\n                    while (v3 < ~0 + _round_[v0][22]) {\n                        assert(v3 + 1 < 10);\n                        assert(v3 < 10);\n                        STORAGE[v3 + (12 + keccak256(_rID_, 11))] = STORAGE[v3 + 1 + (12 + keccak256(_rID_, 11))];\n                        v3 += 1;\n                    }\n                    assert(~0 + _round_[_rID_][22] < 10);\n                    STORAGE[~0 + _round_[_rID_][22] + (12 + keccak256(_rID_, 11))] = varg0;\n                } else {\n                    assert(_round_[_rID_][22] < 10);\n                    STORAGE[_round_[_rID_][22] + (12 + keccak256(_rID_, 11))] = varg0;\n                    _round_[v0][22] += 1;\n                }\n            }\n        }\n    } else {\n        _round_[v0][12] = varg0;\n        _round_[v0][22] += 1;\n    }\n    return ;\n}\n\nfunction 0x3280(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg1 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        MEM[MEM[64]] = 0;\n        MEM[32 + MEM[64]] = 0;\n        MEM[64 + MEM[64]] = 0;\n        MEM[96 + MEM[64]] = 0;\n        MEM[128 + MEM[64]] = 0;\n        MEM[160 + MEM[64]] = 0;\n        MEM[192 + MEM[64]] = 0;\n        MEM[224 + MEM[64]] = 0;\n        MEM[256 + MEM[64]] = 0;\n        if (_plyr_[varg4][5]) {\n            0x5427(_plyr_[varg4][5], varg4);\n        }\n        _plyr_[varg4][5] = _rID_;\n        MEM[varg0] += 10;\n    }\n    if (varg3 > 0x3b9aca00) {\n        v2 = v3 = 0x4779(_round_[v1][5], varg3, _round_[v1][6]);\n        if (v3 >= 0xde0b6b3a7640000) {\n            v4 = v5 = block.timestamp;\n            v6 = v7 = v5 > _round_[v1][2];\n            if (v7) {\n                v6 = !_round_[v1];\n            }\n            if (!v6) {\n                v4 = v8 = _round_[v1][2];\n                v9 = v10 = 18764;\n                if (v3 / 0xde0b6b3a7640000) {\n                    v11 = 30 * (v3 / 0xde0b6b3a7640000);\n                    assert(v3 / 0xde0b6b3a7640000);\n                    require(v11 / (v3 / 0xde0b6b3a7640000) == 30, 'SafeMath mul failed');\n                } else {\n                    v11 = v12 = 0;\n                }\n                goto 0x39e90x48cdB0x32fa;\n            } else {\n                v9 = v13 = 18715;\n                if (v3 / 0xde0b6b3a7640000) {\n                    v11 = v14 = 0x15180 * (v3 / 0xde0b6b3a7640000);\n                    assert(v3 / 0xde0b6b3a7640000);\n                    require(v14 / (v3 / 0xde0b6b3a7640000) == 0x15180, 'SafeMath mul failed');\n                } else {\n                    v11 = v15 = 0;\n                }\n            }\n            require(v4 + v11 >= v11, 'SafeMath add failed');\n            goto {'0x494cB0x32fa', '0x491bB0x32fa'};\n            require(v5 + 0x15180 >= 0x15180, 'SafeMath add failed');\n            if (v4 + v11 >= v5 + 0x15180) {\n                require(v5 + 0x15180 >= 0x15180, 'SafeMath add failed');\n                _round_[v1][2] = v5 + 0x15180;\n                goto 0x3303;\n            } else {\n                _round_[v1][2] = v4 + v11;\n            }\n            if (varg4 != _round_[v1]) {\n                _round_[v1] = varg4;\n            }\n            if (varg1 != _round_[v1][1]) {\n                _round_[v1][1] = varg1;\n            }\n            MEM[varg0] += 100;\n        }\n        varg1 = v16 = 0;\n        varg1 = v17 = 0x5a204f;\n        MEM[v17 len 160] = this.code[this.code.size len 160];\n        varg1 = v18 = 0;\n        if (varg1) {\n            if (1 != varg1) {\n                if (2 != varg1) {\n                    if (3 == varg1) {\n                        varg1 = v19 = 2;\n                    }\n                } else {\n                    varg1 = v20 = 3;\n                }\n            } else {\n                varg1 = v21 = 4;\n            }\n        } else {\n            MEM[v17 + 128] = 96;\n            varg1 = v22 = 5;\n        }\n        varg1 = v23 = 19400;\n        varg1 = v24 = block.number;\n        varg1 = v25 = 14825;\n        v26 = v27 = v27.data;\n        v28 = v29 = 20;\n        v30 = v31 = 32 + MEM[64];\n        while (v28 >= 32) {\n            MEM[v26] = MEM[v30];\n            v28 = v28 + ~31;\n            v26 += 32;\n            v30 += 32;\n        }\n        MEM[v26] = MEM[v26] & ~0 + 256 ** (32 - v28) | MEM[v30] & ~(~0 + 256 ** (32 - v28));\n        assert(block.timestamp);\n        varg1 = v32 = keccak256(msg.sender) / block.timestamp;\n        varg1 = v33 = 14825;\n        varg1 = v34 = block.gaslimit;\n        varg1 = v35 = 14825;\n        v36 = v37 = v37.data;\n        v38 = v39 = 20;\n        v40 = v41 = 32 + MEM[64];\n        while (v38 >= 32) {\n            MEM[v36] = MEM[v40];\n            v38 = v38 + ~31;\n            v36 += 32;\n            v40 += 32;\n        }\n        MEM[v36] = MEM[v36] & ~0 + 256 ** (32 - v38) | MEM[v40] & ~(~0 + 256 ** (32 - v38));\n        assert(block.timestamp);\n        varg1 = v42 = keccak256(address(block.coinbase)) / block.timestamp;\n        v43 = block.difficulty + block.timestamp;\n        require(v43 >= block.timestamp, 'SafeMath add failed');\n        while (1) {\n            v43 += varg1;\n            if (v43 >= v43) {\n                break;\n            }\n            require(v43 >= v43, 'SafeMath add failed');\n            v44 = v45 = v45.data;\n            v46 = v47 = 32;\n            v48 = v49 = 32 + MEM[64];\n            while (v46 >= 32) {\n                MEM[v44] = MEM[v48];\n                v46 = v46 + ~31;\n                v44 += 32;\n                v48 += 32;\n            }\n            MEM[v44] = MEM[v44] & ~0 + 256 ** (32 - v46) | MEM[v48] & ~(~0 + 256 ** (32 - v46));\n            v50 = v51 = 0;\n            while (v50 < 0xff & varg1) {\n                assert(v50 < 5);\n                if (0xff & MEM[(v50 << 5) + varg1] != keccak256(v43) - 100 * (keccak256(v43) / 100)) {\n                    v50 += 1;\n                } else {\n                    v52 = v53 = 1;\n                    break;\n                }\n            }\n            v52 = v54 = 0;\n            if (1 == v52) {\n                if (_airDropPot_) {\n                    v55 = 50 * _airDropPot_;\n                    assert(_airDropPot_);\n                    require(v55 / _airDropPot_ == 50, 'SafeMath mul failed');\n                } else {\n                    v55 = v56 = 0;\n                }\n                assert(100);\n                require(v55 / 100 + _plyr_[v0][2] >= _plyr_[v0][2], 'SafeMath add failed');\n                _plyr_[v0][2] += v55 / 100;\n                require(v55 / 100 <= _airDropPot_, 'SafeMath sub failed');\n                _airDropPot_ = _airDropPot_ - v55 / 100;\n                MEM[varg1] += 0xeca8847c4129106ce8300000000;\n            }\n            MEM[varg1] += _airDropTracker_ * 1000;\n            require(_plyrRnds_[v3][1] + v57 >= v57, 'SafeMath add failed');\n            _plyrRnds_[v3][1] = _plyrRnds_[v3][1] + v57;\n            _plyrRnds_[v3][7] = v57;\n            MEM[0] = v3;\n            MEM[32] = keccak256(v0, 9);\n            require(_plyrRnds_[v3] + 13160 >= 13160, 'SafeMath add failed');\n            _plyrRnds_[v3] = _plyrRnds_[v3] + 13160;\n            require(_plyrRnds_[v3][5] + v57 >= v57, 'SafeMath add failed');\n            _round_[v3][5] = _plyrRnds_[v3][5] + v57;\n            require(_round_[v3][6] + 13160 >= 13160, 'SafeMath add failed');\n            _round_[v3][6] = _round_[v3][6] + 13160;\n            require(_rndTmEth_[v16] + 13160 >= 13160, 'SafeMath add failed');\n            _rndTmEth_[v16] = _rndTmEth_[v16] + 13160;\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            MEM[64 + MEM[64]] = 0;\n            MEM[96 + MEM[64]] = 0;\n            MEM[128 + MEM[64]] = 0;\n            MEM[160 + MEM[64]] = 0;\n            MEM[192 + MEM[64]] = 0;\n            MEM[224 + MEM[64]] = 0;\n            MEM[256 + MEM[64]] = 0;\n            if (13160) {\n                v58 = 0x20210;\n                assert(13160);\n                require(10 == 10, 'SafeMath mul failed');\n            } else {\n                v58 = v59 = 0;\n            }\n            assert(100);\n            v60 = v58 / 100;\n            v61 = v62 = varg1 != v0;\n            if (v62) {\n                v61 = _plyr_[varg1][1];\n            }\n            if (!v61) {\n                if (v60) {\n                    v63 = 40 * v60;\n                    assert(v60);\n                    require(v63 / v60 == 40, 'SafeMath mul failed');\n                } else {\n                    v63 = v64 = 0;\n                }\n                assert(100);\n                v65 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v63 / 100).gas(!(v63 / 100) * 2300);\n                require(v65); // checks call status, propagates error data on error\n                if (v60) {\n                    v66 = 40 * v60;\n                    assert(v60);\n                    require(v66 / v60 == 40, 'SafeMath mul failed');\n                } else {\n                    v66 = v67 = 0;\n                }\n                assert(100);\n                v68 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v66 / 100).gas(!(v66 / 100) * 2300);\n                require(v68); // checks call status, propagates error data on error\n                if (v60) {\n                    v69 = 20 * v60;\n                    assert(v60);\n                    require(v69 / v60 == 20, 'SafeMath mul failed');\n                } else {\n                    v69 = v70 = 0;\n                }\n                assert(100);\n                v71 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v69 / 100).gas(!(v69 / 100) * 2300);\n                require(v71); // checks call status, propagates error data on error\n            } else {\n                require(_plyr_[varg1][4] + v60 >= v60, 'SafeMath add failed');\n                _plyr_[varg1][4] = _plyr_[varg1][4] + v60;\n                v72 = _plyr_[varg1][1];\n                v73 = address(_plyr_[varg1]);\n                emit onAffiliatePayout(varg1, v3, v0, v73, v72, v60, block.timestamp);\n            }\n            if (2632 > 0) {\n                if (2632) {\n                    v74 = 52640;\n                    assert(2632);\n                    require(20 == 20, 'SafeMath mul failed');\n                } else {\n                    v74 = v75 = 0;\n                }\n                assert(100);\n                v76 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v74 / 100).gas(!(v74 / 100) * 2300);\n                require(v76); // checks call status, propagates error data on error\n                if (2632) {\n                    v77 = 52640;\n                    assert(2632);\n                    require(20 == 20, 'SafeMath mul failed');\n                } else {\n                    v77 = v78 = 0;\n                }\n                assert(100);\n                v79 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v77 / 100).gas(!(v77 / 100) * 2300);\n                require(v79); // checks call status, propagates error data on error\n                if (2632) {\n                    v80 = 0x20210;\n                    assert(2632);\n                    require(50 == 50, 'SafeMath mul failed');\n                } else {\n                    v80 = v81 = 0;\n                }\n                assert(100);\n                v82 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v80 / 100).gas(!(v80 / 100) * 2300);\n                require(v82); // checks call status, propagates error data on error\n                if (2632) {\n                    v83 = 26320;\n                    assert(2632);\n                    require(10 == 10, 'SafeMath mul failed');\n                } else {\n                    v83 = v84 = 0;\n                }\n                assert(100);\n                v85 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v83 / 100).gas(!(v83 / 100) * 2300);\n                require(v85); // checks call status, propagates error data on error\n                require(MEM[varg1 + 192] + 2632 >= 2632, 'SafeMath add failed');\n                MEM[varg1 + 192] = MEM[varg1 + 192] + 2632;\n            }\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            MEM[64 + MEM[64]] = 0;\n            MEM[96 + MEM[64]] = 0;\n            MEM[128 + MEM[64]] = 0;\n            MEM[160 + MEM[64]] = 0;\n            MEM[192 + MEM[64]] = 0;\n            MEM[224 + MEM[64]] = 0;\n            MEM[256 + MEM[64]] = 0;\n            if (13160) {\n                v86 = _fees_[v16] * 13160;\n                assert(13160);\n                require(v86 / 13160 == _fees_[v16], 'SafeMath mul failed');\n            } else {\n                v86 = v87 = 0;\n            }\n            assert(100);\n            v2 = v88 = v86 / 100;\n            if (13160) {\n                v89 = 26320;\n                assert(13160);\n                require(2 == 2, 'SafeMath mul failed');\n            } else {\n                v89 = v90 = 0;\n            }\n            assert(100);\n            require(v89 / 100 + _airDropPot_ >= _airDropPot_, 'SafeMath add failed');\n            _airDropPot_ += v89 / 100;\n            if (13160) {\n                v91 = 0x268e0;\n                assert(13160);\n                require(12 == 12, 'SafeMath mul failed');\n            } else {\n                v91 = v92 = 0;\n            }\n            assert(100);\n            if (13160) {\n                v93 = 0x40420;\n                assert(13160);\n                require(20 == 20, 'SafeMath mul failed');\n            } else {\n                v93 = v94 = 0;\n            }\n            assert(100);\n            require(v91 / 100 + v93 / 100 >= v93 / 100, 'SafeMath add failed');\n            require(v91 / 100 + v93 / 100 <= 13160, 'SafeMath sub failed');\n            require(v88 <= 13160 - (v91 / 100 + v93 / 100), 'SafeMath sub failed');\n            v95 = 13160 - (v91 / 100 + v93 / 100) - v88;\n            v2 = v96 = 0;\n            if (v88) {\n                v97 = 0xde0b6b3a7640000 * v88;\n                assert(v88);\n                require(v97 / v88 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n            } else {\n                v97 = v98 = 0;\n            }\n            assert(_round_[v3][5]);\n            varg1 = v99 = v97 / _round_[v3][5];\n            require(_round_[v3][8] + v99 >= v99, 'SafeMath add failed');\n            _round_[v3][8] = _round_[v3][8] + v99;\n            if (v99) {\n                v100 = v57 * v99;\n                assert(v99);\n                require(v100 / v99 == v57, 'SafeMath mul failed');\n            } else {\n                v100 = v101 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            v2 = v102 = _plyrRnds_[v3][2];\n            v2 = v103 = v100 / 0xde0b6b3a7640000;\n            varg1 = v104 = 21924;\n            v105 = v106 = 14825;\n            if (_plyrRnds_[v3][8]) {\n                v107 = v57 * _plyrRnds_[v3][8];\n                assert(_plyrRnds_[v3][8]);\n                require(v107 / _plyrRnds_[v3][8] == v57, 'SafeMath mul failed');\n            } else {\n                v107 = v108 = 0;\n            }\n            assert(0xde0b6b3a7640000);\n            v2 = v109 = v107 / 0xde0b6b3a7640000;\n            while (v2 > v2) {\n                goto {'0x39e90x54beB0x5140', '0x55ecB0x5140'};\n                if (v2 + (v2 - v2) >= v2 - v2) {\n                    break;\n                }\n                require(v2 + (v2 - v2) >= v2 - v2, 'SafeMath add failed');\n                _plyrRnds_[v3][2] = v2 + (v2 - v2);\n                v105 = v110 = 21996;\n                if (varg1) {\n                    v111 = _plyrRnds_[v3][5] * varg1;\n                    assert(varg1);\n                    require(v111 / varg1 == _plyrRnds_[v3][5], 'SafeMath mul failed');\n                } else {\n                    v111 = v112 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                v2 = v113 = v111 / 0xde0b6b3a7640000;\n            }\n            revert('SafeMath sub failed');\n            if (v2 - v2 > 0) {\n                require(v2 - v2 <= v95, 'SafeMath sub failed');\n                v95 = v114 = v95 - (v2 - v2);\n            }\n            require(v2 - v2 + 20814 >= 20814, 'SafeMath add failed');\n            require(_round_[13160 - (v91 / 100 + v93 / 100)][7] + (v2 - v2 + 20814) >= v2 - v2 + 20814, 'SafeMath add failed');\n            _round_[13160 - (v91 / 100 + v93 / 100)][7] = _round_[13160 - (v91 / 100 + v93 / 100)][7] + (v2 - v2 + 20814);\n            require(MEM[v88 + 224] + v95 >= v95, 'SafeMath add failed');\n            MEM[v88 + 224] = MEM[v88 + 224] + v95;\n            MEM[v88 + 256] = 20814;\n            MEM[0 + v88] = MEM[0 + v88] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * v57;\n            MEM[32 + v88] = MEM[32 + v88] + varg1 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n            v115 = ~0x0 & (~0x0 & _plyr_[varg1][0x1]);\n            emit onEndTx(MEM[0 + v88], MEM[32 + v88], v115, msg.sender, v16, 13643, address(MEM[64 + v88]), ~0x0 & (~0x0 & MEM[96 + v88]), MEM[128 + v88], MEM[160 + v88], MEM[192 + v88], MEM[224 + v88], MEM[256 + v88], _airDropPot_);\n            goto {'0x4bc8B0x335f', '0x39e90x49adB0x335f'};\n        }\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x38d7ea4c68000;\n    } else {\n        require(0xde0b6b3a7640000 + _round_[_rID_][5] >= _round_[_rID_][5], 'SafeMath add failed');\n        v4 = v6 = 0x3a85(0xde0b6b3a7640000, 0xde0b6b3a7640000 + _round_[_rID_][5]);\n    }\n    return v4;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (26) {\n        MEM[v0.data] = ~0xffffffffffff & 'Gold medal winner Official';\n    }\n    return v0;\n}\n\nfunction 0x3a85(uint256 varg0, uint256 varg1) private { \n    if (varg1 <= 0) {\n        varg1 = v0 = 0xde0b6b3a7640000;\n    }\n    v1 = 0x4836(varg1);\n    if (v1) {\n        v2 = varg0 * v1;\n        assert(v1);\n        require(v2 / v1 == varg0, 'SafeMath mul failed');\n    } else {\n        v2 = v3 = 0;\n    }\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0x3d0e(uint256 varg0) private { \n    0x5427(_plyr_[varg0][5], varg0);\n    v0 = _plyr_[varg0][2];\n    require(_plyr_[varg0][3] + v0 >= v0, 'SafeMath add failed');\n    require(_plyr_[varg0][4] + (_plyr_[varg0][3] + v0) >= _plyr_[varg0][3] + v0, 'SafeMath add failed');\n    if (_plyr_[varg0][4] + (_plyr_[varg0][3] + v0) <= 0) {\n        return _plyr_[varg0][4] + (_plyr_[varg0][3] + v0);\n    } else {\n        _plyr_[varg0][2] = 0;\n        _plyr_[varg0][3] = 0;\n        _plyr_[varg0][4] = 0;\n        return _plyr_[varg0][4] + (_plyr_[varg0][3] + v0);\n    }\n}\n\nfunction 0x3d90(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, 'string must be between 1 and 32 characters');\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (varg0.length - 1)] >> 248 << 248;\n    }\n    require(v5, 'string cannot start or end with space');\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0x');\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0X');\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, 'string contains invalid characters');\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (1 + v8)] >> 248 << 248, 'string cannot contain consecutive spaces');\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (MEM[varg0.data + v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, 'string cannot be only numbers');\n    return MEM[varg0.data];\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v0 = v1 = !varg0;\n    if (varg0) {\n        v0 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v0) {\n        v2 = v3 = _pIDxName_[varg0];\n        if (v3 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v3;\n        }\n    } else {\n        v2 = v4 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = v6 = varg1 < 0;\n    if (varg1 >= 0) {\n        v5 = varg1 > 3;\n    }\n    if (v5) {\n        v7 = 2;\n    }\n    v8 = v9 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v9) {\n        v8 = v10 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v8 = v11 = block.timestamp > _round_[_rID_][2];\n            if (v11) {\n                v8 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v8) {\n        v12 = v13 = block.timestamp > _round_[_rID_][2];\n        if (v13) {\n            v12 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v12) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v14 = v15 = MEM[64];\n            MEM[v15] = 0;\n            MEM[32 + v15] = 0;\n            MEM[64 + v15] = 0;\n            MEM[96 + v15] = 0;\n            MEM[128 + v15] = 0;\n            MEM[160 + v15] = 0;\n            MEM[192 + v15] = 0;\n            MEM[224 + v15] = 0;\n            MEM[256 + v15] = 0;\n            v14 = v16 = _rID_;\n            v14 = v17 = 0;\n            v14 = v18 = _round_[v16];\n            v14 = v19 = _round_[v16][1];\n            v14 = v20 = _round_[v16][7];\n            if (v20) {\n                v21 = 48 * v20;\n                assert(v20);\n                require(v21 / v20 == 48, 'SafeMath mul failed');\n            } else {\n                v21 = v22 = 0;\n            }\n            assert(100);\n            v14 = v23 = v21 / 100;\n            v14 = v24 = v20 / 25;\n            if (v20) {\n                v25 = _potSplit_[v19] * v20;\n                assert(v20);\n                require(v25 / v20 == _potSplit_[v19], 'SafeMath mul failed');\n            } else {\n                v25 = v26 = 0;\n            }\n            assert(100);\n            v14 = v27 = v25 / 100;\n            if (v20) {\n                v28 = _potSplit_[v19][1] * v20;\n                assert(v20);\n                require(v28 / v20 == _potSplit_[v19][1], 'SafeMath mul failed');\n            } else {\n                v28 = v29 = 0;\n            }\n            assert(100);\n            v14 = v30 = v28 / 100;\n            v14 = v31 = 13866;\n            v14 = v32 = 7583;\n            require(v23 <= v20, 'SafeMath sub failed');\n            v33 = v34 = v20 - v23;\n            while (v14 > v33) {\n                require(v14 <= v33, 'SafeMath sub failed');\n                if (v14) {\n                    v35 = 0xde0b6b3a7640000 * v14;\n                    assert(v14);\n                    require(v35 / v14 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v35 = v36 = 0;\n                }\n                assert(_round_[v14][5]);\n                if (v35 / _round_[v14][5]) {\n                    v37 = _round_[v14][5] * (v35 / _round_[v14][5]);\n                    assert(v35 / _round_[v14][5]);\n                    require(v37 / (v35 / _round_[v14][5]) == _round_[v14][5], 'SafeMath mul failed');\n                } else {\n                    v37 = v38 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v37 / 0xde0b6b3a7640000 <= v14, 'SafeMath sub failed');\n                if (v14 - v37 / 0xde0b6b3a7640000 > 0) {\n                    require(v14 - v37 / 0xde0b6b3a7640000 <= v14, 'SafeMath sub failed');\n                    v14 = v39 = v14 - (v14 - v37 / 0xde0b6b3a7640000);\n                    v33 = v40 = v14 - v37 / 0xde0b6b3a7640000 + v33;\n                    require(v40 >= v33, 'SafeMath add failed');\n                }\n                v41 = v42 = 14055;\n                v41 = v43 = _rID_;\n                v41 = v44 = 0;\n                v14 = v45 = _round_[v43][22];\n                while (v41 < v45) {\n                    assert(v41 < 10);\n                    v41 = v41 + 1;\n                    v41 += _plyr_[STORAGE[v41 + (12 + keccak256(v43, 11))]][7];\n                }\n                v14 = v46 = 0;\n                while (v14 < v14) {\n                    if (v14 < 10) {\n                        break;\n                    }\n                    assert(v14 < 10);\n                    v41 = v47 = STORAGE[v14 + (12 + keccak256(v41, 11))];\n                    v41 = v48 = _plyr_[v47][2];\n                    v14 = v49 = 21514;\n                    v14 = v50 = 14825;\n                    if (v41) {\n                        break;\n                    }\n                    assert(v41);\n                    if (v14) {\n                        v51 = _plyr_[v47][7] / v41 * v14;\n                        assert(v14);\n                        require(v51 / v14 == _plyr_[v47][7] / v41, 'SafeMath mul failed');\n                    } else {\n                        v51 = v52 = 0;\n                    }\n                    while (1) {\n                        goto {'0x39e90x5341B0x36deB0x3bccB0x114f0x1005B0x42a', '0x540aB0x36deB0x3bccB0x114f0x1005B0x42a'};\n                        v51 += v41;\n                        if (v51 >= v51) {\n                            break;\n                        }\n                        require(v51 >= v51, 'SafeMath add failed');\n                    }\n                    _plyr_[v41][2] = v51;\n                    v14 = v14 + 1;\n                }\n                require(_round_[v14][8] + v35 / _round_[v14][5] >= v35 / _round_[v14][5], 'SafeMath add failed');\n                _round_[v14][8] = _round_[v14][8] + v35 / _round_[v14][5];\n                if (v14 > 0) {\n                    if (v14) {\n                        v53 = 20 * v14;\n                        assert(v14);\n                        require(v53 / v14 == 20, 'SafeMath mul failed');\n                    } else {\n                        v53 = v54 = 0;\n                    }\n                    assert(100);\n                    v55 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v53 / 100).gas(!(v53 / 100) * 2300);\n                    require(v55); // checks call status, propagates error data on error\n                    if (v14) {\n                        v56 = 20 * v14;\n                        assert(v14);\n                        require(v56 / v14 == 20, 'SafeMath mul failed');\n                    } else {\n                        v56 = v57 = 0;\n                    }\n                    assert(100);\n                    v58 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v56 / 100).gas(!(v56 / 100) * 2300);\n                    require(v58); // checks call status, propagates error data on error\n                    if (v14) {\n                        v59 = 50 * v14;\n                        assert(v14);\n                        require(v59 / v14 == 50, 'SafeMath mul failed');\n                    } else {\n                        v59 = v60 = 0;\n                    }\n                    assert(100);\n                    v61 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v59 / 100).gas(!(v59 / 100) * 2300);\n                    require(v61); // checks call status, propagates error data on error\n                    if (v14) {\n                        v62 = 10 * v14;\n                        assert(v14);\n                        require(v62 / v14 == 10, 'SafeMath mul failed');\n                    } else {\n                        v62 = v63 = 0;\n                    }\n                    assert(100);\n                    v64 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v62 / 100).gas(!(v62 / 100) * 2300);\n                    require(v64); // checks call status, propagates error data on error\n                }\n                MEM[0 + v14] = MEM[0 + v14] + 0xf4240 * _round_[v14][2];\n                MEM[32 + v14] = MEM[32 + v14] + 0x52b7d2dcc80cd2e4000000 * v14 + 0x16345785d8a0000 * v14;\n                MEM[64 + v14] = address(_round_[v14][0]);\n                MEM[96 + v14] = ~0x0 & (~0x0 & _round_[v14][0x1]);\n                MEM[128 + v14] = v14;\n                MEM[224 + v14] = v14;\n                MEM[192 + v14] = v14;\n                MEM[160 + v14] = v33;\n                _rID_ += 1;\n                _round_[v14][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v14][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v14][7] = v33;\n                MEM[0 + v14] = MEM[0 + v14] + 0xde0b6b3a7640000 * v16;\n                MEM[32 + v14] = MEM[32 + v14] + MEM[64];\n                emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[MEM[64]][0x1]), MEM[0 + v14], MEM[32 + v14], address(MEM[64 + v14]), ~0x0 & (~0x0 & MEM[96 + v14]), MEM[128 + v14], MEM[160 + v14], MEM[192 + v14], MEM[224 + v14]);\n                goto 0x115e0x1005B0x42a;\n                v33 = v33 - v14;\n                goto {'0x1d9f0x355aB0x3bccB0x114f0x1005B0x42a', '0x362aB0x3bccB0x114f0x1005B0x42a'};\n            }\n        }\n    } else {\n        v65 = 0x3d0e(_pIDxAddr_[msg.sender]);\n        require(varg2 <= v65, 'SafeMath sub failed');\n        _plyr_[_pIDxAddr_[msg.sender]][3] = v65 - varg2;\n        0x3280(MEM[64], v7, v2, varg2, _pIDxAddr_[msg.sender]);\n    }\n}\n\nfunction activate() public nonPayable { \n    require(msg.sender == 0x100d5695a0b35bbb8c044aefef7c7b278e5843e1, 'only team just can activate');\n    require(!_activated_, 'fomo3d already activated');\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 11;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3 = stor_1 + block.timestamp - _getTimeLeft;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1 = 0x15180 + (stor_1 + block.timestamp);\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction 0x461a(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[v0][1];\n    varg0 = v3 = _plyrRnds_[v0][5];\n    v4 = _plyrRnds_[v0][1];\n    v5 = _plyrRnds_[v0];\n    MEM[v1] = varg0;\n    MEM[32] = 11;\n    v6 = _plyrRnds_[v0][7];\n    varg0 = v7 = 0xde0b6b3a7640000;\n    v0 = v8 = 15036;\n    v0 = v9 = 15024;\n    v0 = v10 = 18060;\n    if (v11) {\n        v12 = v5 * v6;\n        assert(v6);\n        require(v12 / v6 == v5, 'SafeMath mul failed');\n    } else {\n        v12 = v13 = 0;\n    }\n    assert(100);\n    v11 = v12 / 100;\n    while (1) {\n        v11 = v14 = 0;\n        while (1) {\n            goto {'0x3ab00x461a', '0x3abc0x461a', '0x468c'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v15 = _round_[varg0][8];\n            v11 = v11 / varg0 + v15;\n            require(v11 >= v15, 'SafeMath add failed');\n        }\n        continue;\n        v11 *= varg0;\n        assert(v11);\n        require(v11 / v11 == varg0, 'SafeMath mul failed');\n    }\n    assert(varg0);\n    return v11 / varg0, v0, varg0, v0;\n}\n\nfunction 0x4715(uint256 varg0, uint256 varg1) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = _plyrRnds_[varg0][1];\n    v2 = _plyrRnds_[varg0][8];\n    if (v2) {\n        v3 = v1 * v2;\n        assert(v2);\n        require(v3 / v2 == v1, 'SafeMath mul failed');\n    } else {\n        v3 = v4 = 0;\n    }\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v3 / 0xde0b6b3a7640000, 'SafeMath sub failed');\n    return v3 / 0xde0b6b3a7640000 - v0;\n}\n\nfunction airDropTracker_() public nonPayable { \n    return _airDropTracker_;\n}\n\nfunction 0x4779(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg0 <= 0) {\n        varg0 = v0 = 0xde0b6b3a7640000;\n    }\n    v1 = 0x47a0(varg0, varg1);\n    return v1;\n}\n\nfunction 0x47a0(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= 0) {\n        varg0 = v0 = 0xde0b6b3a7640000;\n    }\n    require(0xde0b6b3a7640000 <= varg0, 'SafeMath sub failed');\n    if (0x77359400) {\n        v1 = (varg0 - 0xde0b6b3a7640000) * 0x77359400;\n        assert(0x77359400);\n        require(v1 / 0x77359400 == varg0 - 0xde0b6b3a7640000, 'SafeMath mul failed');\n    } else {\n        v1 = v2 = 0;\n    }\n    assert(0xde0b6b3a7640000);\n    require(v1 / 0xde0b6b3a7640000 + 0x38d7ea4c68000 >= 0x38d7ea4c68000, 'SafeMath add failed');\n    if (varg1) {\n        v3 = 0xde0b6b3a7640000 * varg1;\n        assert(varg1);\n        require(v3 / varg1 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n    } else {\n        v3 = v4 = 0;\n    }\n    assert(v1 / 0xde0b6b3a7640000 + 0x38d7ea4c68000);\n    return v3 / (v1 / 0xde0b6b3a7640000 + 0x38d7ea4c68000);\n}\n\nfunction 0x4836(uint256 varg0) private { \n    require(0xde0b6b3a7640000 <= varg0, 'SafeMath sub failed');\n    v0 = varg0 - 0xde0b6b3a7640000;\n    if (0x77359400) {\n        v1 = v0 * 0x77359400;\n        assert(0x77359400);\n        require(v1 / 0x77359400 == v0, 'SafeMath mul failed');\n    } else {\n        v1 = v2 = 0;\n    }\n    assert(0xde0b6b3a7640000);\n    require(v1 / 0xde0b6b3a7640000 + 0x38d7ea4c68000 >= 0x38d7ea4c68000, 'SafeMath add failed');\n    return v1 / 0xde0b6b3a7640000 + 0x38d7ea4c68000;\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    return _round_[varg0][0], _round_[varg0][1], _round_[varg0][2], 0xff & _round_[varg0][3], _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10], _round_[varg0][11], _round_[varg0][22];\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction 0x5427(uint256 varg0, uint256 varg1) private { \n    v0 = 0x4715(varg0, varg1);\n    if (v0 > 0) {\n        require(_plyr_[varg1][3] + v0 >= v0, 'SafeMath add failed');\n        _plyr_[varg1][3] = _plyr_[varg1][3] + v0;\n        require(_plyrRnds_[varg1][2] + v0 >= v0, 'SafeMath add failed');\n        _plyrRnds_[varg1][2] = _plyrRnds_[varg1][2] + v0;\n    }\n    return ;\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction reLoadXid(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v0 = v1 = !varg0;\n    if (varg0) {\n        v0 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v0) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v2 = v3 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v4 = v5 = varg1 < 0;\n    if (varg1 >= 0) {\n        v4 = varg1 > 3;\n    }\n    if (v4) {\n        v6 = 2;\n    }\n    v7 = v8 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v8) {\n        v7 = v9 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v7 = v10 = block.timestamp > _round_[_rID_][2];\n            if (v10) {\n                v7 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v7) {\n        v11 = v12 = block.timestamp > _round_[_rID_][2];\n        if (v12) {\n            v11 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v11) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v13 = v14 = MEM[64];\n            MEM[v14] = 0;\n            MEM[32 + v14] = 0;\n            MEM[64 + v14] = 0;\n            MEM[96 + v14] = 0;\n            MEM[128 + v14] = 0;\n            MEM[160 + v14] = 0;\n            MEM[192 + v14] = 0;\n            MEM[224 + v14] = 0;\n            MEM[256 + v14] = 0;\n            v13 = v15 = _rID_;\n            v13 = v16 = 0;\n            v13 = v17 = _round_[v15];\n            v13 = v18 = _round_[v15][1];\n            v13 = v19 = _round_[v15][7];\n            if (v19) {\n                v20 = 48 * v19;\n                assert(v19);\n                require(v20 / v19 == 48, 'SafeMath mul failed');\n            } else {\n                v20 = v21 = 0;\n            }\n            assert(100);\n            v13 = v22 = v20 / 100;\n            v13 = v23 = v19 / 25;\n            if (v19) {\n                v24 = _potSplit_[v18] * v19;\n                assert(v19);\n                require(v24 / v19 == _potSplit_[v18], 'SafeMath mul failed');\n            } else {\n                v24 = v25 = 0;\n            }\n            assert(100);\n            v13 = v26 = v24 / 100;\n            if (v19) {\n                v27 = _potSplit_[v18][1] * v19;\n                assert(v19);\n                require(v27 / v19 == _potSplit_[v18][1], 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(100);\n            v13 = v29 = v27 / 100;\n            v13 = v30 = 13866;\n            v13 = v31 = 7583;\n            require(v22 <= v19, 'SafeMath sub failed');\n            v32 = v33 = v19 - v22;\n            while (v13 > v32) {\n                require(v13 <= v32, 'SafeMath sub failed');\n                if (v13) {\n                    v34 = 0xde0b6b3a7640000 * v13;\n                    assert(v13);\n                    require(v34 / v13 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v34 = v35 = 0;\n                }\n                assert(_round_[v13][5]);\n                if (v34 / _round_[v13][5]) {\n                    v36 = _round_[v13][5] * (v34 / _round_[v13][5]);\n                    assert(v34 / _round_[v13][5]);\n                    require(v36 / (v34 / _round_[v13][5]) == _round_[v13][5], 'SafeMath mul failed');\n                } else {\n                    v36 = v37 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v36 / 0xde0b6b3a7640000 <= v13, 'SafeMath sub failed');\n                if (v13 - v36 / 0xde0b6b3a7640000 > 0) {\n                    require(v13 - v36 / 0xde0b6b3a7640000 <= v13, 'SafeMath sub failed');\n                    v13 = v38 = v13 - (v13 - v36 / 0xde0b6b3a7640000);\n                    v32 = v39 = v13 - v36 / 0xde0b6b3a7640000 + v32;\n                    require(v39 >= v32, 'SafeMath add failed');\n                }\n                v40 = v41 = 14055;\n                v40 = v42 = _rID_;\n                v40 = v43 = 0;\n                v13 = v44 = _round_[v42][22];\n                while (v40 < v44) {\n                    assert(v40 < 10);\n                    v40 = v40 + 1;\n                    v40 += _plyr_[STORAGE[v40 + (12 + keccak256(v42, 11))]][7];\n                }\n                v13 = v45 = 0;\n                while (v13 < v13) {\n                    if (v13 < 10) {\n                        break;\n                    }\n                    assert(v13 < 10);\n                    v40 = v46 = STORAGE[v13 + (12 + keccak256(v40, 11))];\n                    v40 = v47 = _plyr_[v46][2];\n                    v13 = v48 = 21514;\n                    v13 = v49 = 14825;\n                    if (v40) {\n                        break;\n                    }\n                    assert(v40);\n                    if (v13) {\n                        v50 = _plyr_[v46][7] / v40 * v13;\n                        assert(v13);\n                        require(v50 / v13 == _plyr_[v46][7] / v40, 'SafeMath mul failed');\n                    } else {\n                        v50 = v51 = 0;\n                    }\n                    while (1) {\n                        goto {'0x39e90x5341B0x36deB0x3bccB0x14a0B0x58a', '0x540aB0x36deB0x3bccB0x14a0B0x58a'};\n                        v50 += v40;\n                        if (v50 >= v50) {\n                            break;\n                        }\n                        require(v50 >= v50, 'SafeMath add failed');\n                    }\n                    _plyr_[v40][2] = v50;\n                    v13 = v13 + 1;\n                }\n                require(_round_[v13][8] + v34 / _round_[v13][5] >= v34 / _round_[v13][5], 'SafeMath add failed');\n                _round_[v13][8] = _round_[v13][8] + v34 / _round_[v13][5];\n                if (v13 > 0) {\n                    if (v13) {\n                        v52 = 20 * v13;\n                        assert(v13);\n                        require(v52 / v13 == 20, 'SafeMath mul failed');\n                    } else {\n                        v52 = v53 = 0;\n                    }\n                    assert(100);\n                    v54 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v52 / 100).gas(!(v52 / 100) * 2300);\n                    require(v54); // checks call status, propagates error data on error\n                    if (v13) {\n                        v55 = 20 * v13;\n                        assert(v13);\n                        require(v55 / v13 == 20, 'SafeMath mul failed');\n                    } else {\n                        v55 = v56 = 0;\n                    }\n                    assert(100);\n                    v57 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v55 / 100).gas(!(v55 / 100) * 2300);\n                    require(v57); // checks call status, propagates error data on error\n                    if (v13) {\n                        v58 = 50 * v13;\n                        assert(v13);\n                        require(v58 / v13 == 50, 'SafeMath mul failed');\n                    } else {\n                        v58 = v59 = 0;\n                    }\n                    assert(100);\n                    v60 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v58 / 100).gas(!(v58 / 100) * 2300);\n                    require(v60); // checks call status, propagates error data on error\n                    if (v13) {\n                        v61 = 10 * v13;\n                        assert(v13);\n                        require(v61 / v13 == 10, 'SafeMath mul failed');\n                    } else {\n                        v61 = v62 = 0;\n                    }\n                    assert(100);\n                    v63 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v61 / 100).gas(!(v61 / 100) * 2300);\n                    require(v63); // checks call status, propagates error data on error\n                }\n                MEM[0 + v13] = MEM[0 + v13] + 0xf4240 * _round_[v13][2];\n                MEM[32 + v13] = MEM[32 + v13] + 0x52b7d2dcc80cd2e4000000 * v13 + 0x16345785d8a0000 * v13;\n                MEM[64 + v13] = address(_round_[v13][0]);\n                MEM[96 + v13] = ~0x0 & (~0x0 & _round_[v13][0x1]);\n                MEM[128 + v13] = v13;\n                MEM[224 + v13] = v13;\n                MEM[192 + v13] = v13;\n                MEM[160 + v13] = v32;\n                _rID_ += 1;\n                _round_[v13][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v13][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v13][7] = v32;\n                MEM[0 + v13] = MEM[0 + v13] + 0xde0b6b3a7640000 * v15;\n                MEM[32 + v13] = MEM[32 + v13] + MEM[64];\n                emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[MEM[64]][0x1]), MEM[0 + v13], MEM[32 + v13], address(MEM[64 + v13]), ~0x0 & (~0x0 & MEM[96 + v13]), MEM[128 + v13], MEM[160 + v13], MEM[192 + v13], MEM[224 + v13]);\n                goto 0x14af0x137bB0x58a;\n                v32 = v32 - v13;\n                goto {'0x362aB0x3bccB0x14a0B0x58a', '0x1d9f0x355aB0x3bccB0x14a0B0x58a'};\n            }\n        }\n    } else {\n        v64 = 0x3d0e(_pIDxAddr_[msg.sender]);\n        require(varg2 <= v64, 'SafeMath sub failed');\n        _plyr_[_pIDxAddr_[msg.sender]][3] = v64 - varg2;\n        0x3280(MEM[64], v6, v2, varg2, _pIDxAddr_[msg.sender]);\n    }\n}\n\nfunction withdraw() public nonPayable { \n    v0, v1, v2 = 0x14b8();\n}\n\nfunction registerNameXaddr(string varg0, address varg1, bool varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(!msg.sender.code.size, 'sorry humans only');\n    v2 = 0x3d90(v0);\n    require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n    v3, v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.registerNameXaddrFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction receivePlayerInfo(uint256 varg0, address varg1, bytes32 varg2, uint256 varg3) public nonPayable { \n    require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef == msg.sender, 'your not playerNames contract... hmmm..');\n    if (varg0 != _pIDxAddr_[varg1]) {\n        _pIDxAddr_[varg1] = varg0;\n    }\n    if (varg0 != _pIDxName_[varg2]) {\n        _pIDxName_[varg2] = varg0;\n    }\n    if (address(_plyr_[varg0]) != varg1) {\n        _plyr_[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _plyr_[varg0];\n    }\n    if (varg2 != _plyr_[varg0][1]) {\n        _plyr_[varg0][1] = varg2;\n    }\n    if (varg3 != _plyr_[varg0][6]) {\n        _plyr_[varg0][6] = varg3;\n    }\n    if (!(0xff & _plyrNames_[varg2])) {\n        _plyrNames_[varg2] = 0x1 | ~0xff & _plyrNames_[varg2];\n    }\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 varg0) public nonPayable { \n    v0 = v1 = _rID_;\n    v2 = v3 = block.timestamp > _round_[v1][2];\n    if (v3) {\n        v2 = v4 = !(0xff & _round_[v1][0x3]);\n    }\n    if (v2) {\n        v2 = _round_[v1];\n    }\n    if (!v2) {\n        v5 = v6 = _plyr_[varg0][2];\n        v7 = v8 = 7625;\n        v9 = v10 = 0x4715(_plyr_[varg0][5], varg0);\n    } else {\n        if (varg0 != _round_[v1]) {\n            v11 = _plyr_[varg0][2];\n            v12 = _plyrRnds_[v1][2];\n            v5 = v13 = 7583;\n            v14 = v15, v16 = v17, v18 = v19, v7 = v20 = 0x461a(v1);\n        } else {\n            v21 = v22 = 0;\n            while (v21 < _round_[v1][22]) {\n                assert(v21 < 10);\n                v21 += _plyr_[STORAGE[v21 + (12 + keccak256(v1, 11))]][7];\n                v21 = v21 + 1;\n            }\n            if (_round_[v1][7]) {\n                v23 = 48 * _round_[v1][7];\n                assert(_round_[v1][7]);\n                require(v23 / _round_[v1][7] == 48, 'SafeMath mul failed');\n            } else {\n                v23 = v24 = 0;\n            }\n            assert(100);\n            if (v23 / 100) {\n                v25 = v26 = _plyr_[varg0][7] * (v23 / 100);\n                assert(v23 / 100);\n                require(v26 / (v23 / 100) == _plyr_[varg0][7], 'SafeMath mul failed');\n            } else {\n                v25 = 0;\n            }\n            assert(v21);\n            require(v25 / v21 + _plyr_[varg0][2] >= _plyr_[varg0][2], 'SafeMath add failed');\n            v27 = _plyrRnds_[v1][2];\n            v5 = v28 = 7583;\n            v14 = v29, v16 = v30, v18 = v31, v7 = v32 = 0x461a(v1);\n        }\n        require(v16 <= v14, 'SafeMath sub failed');\n        v9 = v14 - v16;\n        goto 0x1dabB0x673;\n    }\n    require(v9 + _plyr_[v0][3] >= _plyr_[v0][3], 'SafeMath add failed');\n    return v5, v9 + _plyr_[v0][3], _plyr_[v0][4];\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1, bool varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(!msg.sender.code.size, 'sorry humans only');\n    v2 = 0x3d90(v0);\n    require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n    v3, v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.registerNameXnameFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    v0 = _rID_;\n    return _round_[v0][9], v0, _round_[v0][5], _round_[v0][2], _round_[v0][4], _round_[v0][7], _round_[v0][1] + 10 * _round_[v0][0], address(_round_[_round_[v0][0]][0]), _round_[_round_[_round_[v0][0]][0]][1], _rndTmEth_[0], _rndTmEth_[1], _rndTmEth_[2], _rndTmEth_[3], _airDropTracker_ + 1000 * _airDropPot_;\n}\n\nfunction reLoadXaddr(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v0 = v1 = !varg0;\n    if (varg0) {\n        v0 = msg.sender == varg0;\n    }\n    if (!v0) {\n        v2 = v3 = _pIDxAddr_[varg0];\n        if (v3 != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v3;\n            v4 = v5 = varg1 < 0;\n            if (varg1 >= 0) {\n                v4 = varg1 > 3;\n            }\n            if (v4) {\n                v6 = v7 = 2;\n            }\n            goto 0x114f0x2136B0x787;\n        }\n    } else {\n        v2 = v8 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v9 = v10 = varg1 < 0;\n    if (varg1 >= 0) {\n        v9 = varg1 > 3;\n    }\n    if (v9) {\n        v6 = 2;\n    }\n    v11 = v12 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v12) {\n        v11 = v13 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v11 = v14 = block.timestamp > _round_[_rID_][2];\n            if (v14) {\n                v11 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v11) {\n        v15 = v16 = block.timestamp > _round_[_rID_][2];\n        if (v16) {\n            v15 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v15) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v17 = v18 = MEM[64];\n            MEM[v18] = 0;\n            MEM[32 + v18] = 0;\n            MEM[64 + v18] = 0;\n            MEM[96 + v18] = 0;\n            MEM[128 + v18] = 0;\n            MEM[160 + v18] = 0;\n            MEM[192 + v18] = 0;\n            MEM[224 + v18] = 0;\n            MEM[256 + v18] = 0;\n            v17 = v19 = _rID_;\n            v17 = v20 = 0;\n            v17 = v21 = _round_[v19];\n            v17 = v22 = _round_[v19][1];\n            v17 = v23 = _round_[v19][7];\n            if (v23) {\n                v24 = 48 * v23;\n                assert(v23);\n                require(v24 / v23 == 48, 'SafeMath mul failed');\n            } else {\n                v24 = v25 = 0;\n            }\n            assert(100);\n            v17 = v26 = v24 / 100;\n            v17 = v27 = v23 / 25;\n            if (v23) {\n                v28 = _potSplit_[v22] * v23;\n                assert(v23);\n                require(v28 / v23 == _potSplit_[v22], 'SafeMath mul failed');\n            } else {\n                v28 = v29 = 0;\n            }\n            assert(100);\n            v17 = v30 = v28 / 100;\n            if (v23) {\n                v31 = _potSplit_[v22][1] * v23;\n                assert(v23);\n                require(v31 / v23 == _potSplit_[v22][1], 'SafeMath mul failed');\n            } else {\n                v31 = v32 = 0;\n            }\n            assert(100);\n            v17 = v33 = v31 / 100;\n            v17 = v34 = 13866;\n            v17 = v35 = 7583;\n            require(v26 <= v23, 'SafeMath sub failed');\n            v36 = v37 = v23 - v26;\n            while (v17 > v36) {\n                require(v17 <= v36, 'SafeMath sub failed');\n                if (v17) {\n                    v38 = 0xde0b6b3a7640000 * v17;\n                    assert(v17);\n                    require(v38 / v17 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v38 = v39 = 0;\n                }\n                assert(_round_[v17][5]);\n                if (v38 / _round_[v17][5]) {\n                    v40 = _round_[v17][5] * (v38 / _round_[v17][5]);\n                    assert(v38 / _round_[v17][5]);\n                    require(v40 / (v38 / _round_[v17][5]) == _round_[v17][5], 'SafeMath mul failed');\n                } else {\n                    v40 = v41 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v40 / 0xde0b6b3a7640000 <= v17, 'SafeMath sub failed');\n                if (v17 - v40 / 0xde0b6b3a7640000 > 0) {\n                    require(v17 - v40 / 0xde0b6b3a7640000 <= v17, 'SafeMath sub failed');\n                    v17 = v42 = v17 - (v17 - v40 / 0xde0b6b3a7640000);\n                    v36 = v43 = v17 - v40 / 0xde0b6b3a7640000 + v36;\n                    require(v43 >= v36, 'SafeMath add failed');\n                }\n                v44 = v45 = 14055;\n                v44 = v46 = _rID_;\n                v44 = v47 = 0;\n                v17 = v48 = _round_[v46][22];\n                while (v44 < v48) {\n                    assert(v44 < 10);\n                    v44 = v44 + 1;\n                    v44 += _plyr_[STORAGE[v44 + (12 + keccak256(v46, 11))]][7];\n                }\n                v17 = v49 = 0;\n                while (v17 < v17) {\n                    if (v17 < 10) {\n                        break;\n                    }\n                    assert(v17 < 10);\n                    v44 = v50 = STORAGE[v17 + (12 + keccak256(v44, 11))];\n                    v44 = v51 = _plyr_[v50][2];\n                    v17 = v52 = 21514;\n                    v17 = v53 = 14825;\n                    if (v44) {\n                        break;\n                    }\n                    assert(v44);\n                    if (v17) {\n                        v54 = _plyr_[v50][7] / v44 * v17;\n                        assert(v17);\n                        require(v54 / v17 == _plyr_[v50][7] / v44, 'SafeMath mul failed');\n                    } else {\n                        v54 = v55 = 0;\n                    }\n                    while (1) {\n                        goto {'0x39e90x5341B0x36deB0x3bccB0x114f0x2136B0x787', '0x540aB0x36deB0x3bccB0x114f0x2136B0x787'};\n                        v54 += v44;\n                        if (v54 >= v54) {\n                            break;\n                        }\n                        require(v54 >= v54, 'SafeMath add failed');\n                    }\n                    _plyr_[v44][2] = v54;\n                    v17 = v17 + 1;\n                }\n                require(_round_[v17][8] + v38 / _round_[v17][5] >= v38 / _round_[v17][5], 'SafeMath add failed');\n                _round_[v17][8] = _round_[v17][8] + v38 / _round_[v17][5];\n                if (v17 > 0) {\n                    if (v17) {\n                        v56 = 20 * v17;\n                        assert(v17);\n                        require(v56 / v17 == 20, 'SafeMath mul failed');\n                    } else {\n                        v56 = v57 = 0;\n                    }\n                    assert(100);\n                    v58 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v56 / 100).gas(!(v56 / 100) * 2300);\n                    require(v58); // checks call status, propagates error data on error\n                    if (v17) {\n                        v59 = 20 * v17;\n                        assert(v17);\n                        require(v59 / v17 == 20, 'SafeMath mul failed');\n                    } else {\n                        v59 = v60 = 0;\n                    }\n                    assert(100);\n                    v61 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v59 / 100).gas(!(v59 / 100) * 2300);\n                    require(v61); // checks call status, propagates error data on error\n                    if (v17) {\n                        v62 = 50 * v17;\n                        assert(v17);\n                        require(v62 / v17 == 50, 'SafeMath mul failed');\n                    } else {\n                        v62 = v63 = 0;\n                    }\n                    assert(100);\n                    v64 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v62 / 100).gas(!(v62 / 100) * 2300);\n                    require(v64); // checks call status, propagates error data on error\n                    if (v17) {\n                        v65 = 10 * v17;\n                        assert(v17);\n                        require(v65 / v17 == 10, 'SafeMath mul failed');\n                    } else {\n                        v65 = v66 = 0;\n                    }\n                    assert(100);\n                    v67 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v65 / 100).gas(!(v65 / 100) * 2300);\n                    require(v67); // checks call status, propagates error data on error\n                }\n                MEM[0 + v17] = MEM[0 + v17] + 0xf4240 * _round_[v17][2];\n                MEM[32 + v17] = MEM[32 + v17] + 0x52b7d2dcc80cd2e4000000 * v17 + 0x16345785d8a0000 * v17;\n                MEM[64 + v17] = address(_round_[v17][0]);\n                MEM[96 + v17] = ~0x0 & (~0x0 & _round_[v17][0x1]);\n                MEM[128 + v17] = v17;\n                MEM[224 + v17] = v17;\n                MEM[192 + v17] = v17;\n                MEM[160 + v17] = v36;\n                _rID_ += 1;\n                _round_[v17][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v17][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v17][7] = v36;\n                MEM[0 + v17] = MEM[0 + v17] + 0xde0b6b3a7640000 * v19;\n                MEM[32 + v17] = MEM[32 + v17] + MEM[64];\n                emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[MEM[64]][0x1]), MEM[0 + v17], MEM[32 + v17], address(MEM[64 + v17]), ~0x0 & (~0x0 & MEM[96 + v17]), MEM[128 + v17], MEM[160 + v17], MEM[192 + v17], MEM[224 + v17]);\n                goto 0x115e0x2136B0x787;\n                v36 = v36 - v17;\n                goto {'0x1d9f0x355aB0x3bccB0x114f0x2136B0x787', '0x362aB0x3bccB0x114f0x2136B0x787'};\n            }\n        }\n    } else {\n        v68 = 0x3d0e(_pIDxAddr_[msg.sender]);\n        require(varg2 <= v68, 'SafeMath sub failed');\n        _plyr_[_pIDxAddr_[msg.sender]][3] = v68 - varg2;\n        0x3280(MEM[64], v6, v2, varg2, _pIDxAddr_[msg.sender]);\n    }\n}\n\nfunction buyXid(uint256 varg0, uint256 varg1) public payable { \n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x16345785d8a0000, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v0, v1 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v2, v3 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] = 1;\n    }\n    v8 = v9 = !varg0;\n    if (varg0) {\n        v8 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v8) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v10 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v11 = v12 = varg1 < 0;\n    if (varg1 >= 0) {\n        v11 = varg1 > 3;\n    }\n    if (v11) {\n    }\n    v13 = _rID_;\n    v14 = v15 = block.timestamp > _getTimeLeft + _round_[v13][4];\n    if (v15) {\n        v14 = v16 = block.timestamp <= _round_[v13][2];\n        if (block.timestamp > _round_[v13][2]) {\n            v14 = v17 = block.timestamp > _round_[v13][2];\n            if (v17) {\n                v14 = !_round_[v13];\n            }\n        }\n    }\n    if (!v14) {\n        v18 = v19 = block.timestamp > _round_[v13][2];\n        if (v19) {\n            v18 = !(0xff & _round_[v13][0x3]);\n        }\n        if (v18) {\n            _round_[v13][3] = 0x1 | ~0xff & _round_[v13][0x3];\n            v20 = v21 = MEM[64];\n            MEM[v21] = 0;\n            MEM[32 + v21] = 0;\n            MEM[64 + v21] = 0;\n            MEM[96 + v21] = 0;\n            MEM[128 + v21] = 0;\n            MEM[160 + v21] = 0;\n            MEM[192 + v21] = 0;\n            MEM[224 + v21] = 0;\n            MEM[256 + v21] = 0;\n            v20 = v22 = _rID_;\n            v20 = v23 = 0;\n            v20 = v24 = _round_[v22];\n            v20 = v25 = _round_[v22][1];\n            v20 = v26 = _round_[v22][7];\n            if (v26) {\n                v27 = 48 * v26;\n                assert(v26);\n                require(v27 / v26 == 48, 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(100);\n            v20 = v29 = v27 / 100;\n            v20 = v30 = v26 / 25;\n            if (v26) {\n                v31 = _potSplit_[v25] * v26;\n                assert(v26);\n                require(v31 / v26 == _potSplit_[v25], 'SafeMath mul failed');\n            } else {\n                v31 = v32 = 0;\n            }\n            assert(100);\n            v20 = v33 = v31 / 100;\n            if (v26) {\n                v34 = _potSplit_[v25][1] * v26;\n                assert(v26);\n                require(v34 / v26 == _potSplit_[v25][1], 'SafeMath mul failed');\n            } else {\n                v34 = v35 = 0;\n            }\n            assert(100);\n            v20 = v36 = v34 / 100;\n            v20 = v37 = 13866;\n            v20 = v38 = 7583;\n            require(v29 <= v26, 'SafeMath sub failed');\n            v39 = v40 = v26 - v29;\n            while (v20 > v39) {\n                require(v20 <= v39, 'SafeMath sub failed');\n                if (v20) {\n                    v41 = 0xde0b6b3a7640000 * v20;\n                    assert(v20);\n                    require(v41 / v20 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v41 = v42 = 0;\n                }\n                assert(_round_[v20][5]);\n                if (v41 / _round_[v20][5]) {\n                    v43 = _round_[v20][5] * (v41 / _round_[v20][5]);\n                    assert(v41 / _round_[v20][5]);\n                    require(v43 / (v41 / _round_[v20][5]) == _round_[v20][5], 'SafeMath mul failed');\n                } else {\n                    v43 = v44 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v43 / 0xde0b6b3a7640000 <= v20, 'SafeMath sub failed');\n                if (v20 - v43 / 0xde0b6b3a7640000 > 0) {\n                    require(v20 - v43 / 0xde0b6b3a7640000 <= v20, 'SafeMath sub failed');\n                    v20 = v45 = v20 - (v20 - v43 / 0xde0b6b3a7640000);\n                    v39 = v46 = v20 - v43 / 0xde0b6b3a7640000 + v39;\n                    require(v46 >= v39, 'SafeMath add failed');\n                }\n                v47 = v48 = 14055;\n                v47 = v49 = _rID_;\n                v47 = v50 = 0;\n                v20 = v51 = _round_[v49][22];\n                while (v47 < v51) {\n                    assert(v47 < 10);\n                    v47 = v47 + 1;\n                    v47 += _plyr_[STORAGE[v47 + (12 + keccak256(v49, 11))]][7];\n                }\n                v20 = v52 = 0;\n                while (v20 < v20) {\n                    if (v20 < 10) {\n                        break;\n                    }\n                    assert(v20 < 10);\n                    v47 = v53 = STORAGE[v20 + (12 + keccak256(v47, 11))];\n                    v47 = v54 = _plyr_[v53][2];\n                    v20 = v55 = 21514;\n                    v20 = v56 = 14825;\n                    if (v47) {\n                        break;\n                    }\n                    assert(v47);\n                    if (v20) {\n                        v57 = _plyr_[v53][7] / v47 * v20;\n                        assert(v20);\n                        require(v57 / v20 == _plyr_[v53][7] / v47, 'SafeMath mul failed');\n                    } else {\n                        v57 = v58 = 0;\n                    }\n                    while (1) {\n                        goto {'0x540aB0x36deB0xd89B0x2465B0x7a2', '0x39e90x5341B0x36deB0xd89B0x2465B0x7a2'};\n                        v57 += v47;\n                        if (v57 >= v57) {\n                            break;\n                        }\n                        require(v57 >= v57, 'SafeMath add failed');\n                    }\n                    _plyr_[v47][2] = v57;\n                    v20 = v20 + 1;\n                }\n                require(_round_[v20][8] + v41 / _round_[v20][5] >= v41 / _round_[v20][5], 'SafeMath add failed');\n                _round_[v20][8] = _round_[v20][8] + v41 / _round_[v20][5];\n                if (v20 > 0) {\n                    if (v20) {\n                        v59 = 20 * v20;\n                        assert(v20);\n                        require(v59 / v20 == 20, 'SafeMath mul failed');\n                    } else {\n                        v59 = v60 = 0;\n                    }\n                    assert(100);\n                    v61 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v59 / 100).gas(!(v59 / 100) * 2300);\n                    require(v61); // checks call status, propagates error data on error\n                    if (v20) {\n                        v62 = 20 * v20;\n                        assert(v20);\n                        require(v62 / v20 == 20, 'SafeMath mul failed');\n                    } else {\n                        v62 = v63 = 0;\n                    }\n                    assert(100);\n                    v64 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v62 / 100).gas(!(v62 / 100) * 2300);\n                    require(v64); // checks call status, propagates error data on error\n                    if (v20) {\n                        v65 = 50 * v20;\n                        assert(v20);\n                        require(v65 / v20 == 50, 'SafeMath mul failed');\n                    } else {\n                        v65 = v66 = 0;\n                    }\n                    assert(100);\n                    v67 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v65 / 100).gas(!(v65 / 100) * 2300);\n                    require(v67); // checks call status, propagates error data on error\n                    if (v20) {\n                        v68 = 10 * v20;\n                        assert(v20);\n                        require(v68 / v20 == 10, 'SafeMath mul failed');\n                    } else {\n                        v68 = v69 = 0;\n                    }\n                    assert(100);\n                    v70 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v68 / 100).gas(!(v68 / 100) * 2300);\n                    require(v70); // checks call status, propagates error data on error\n                }\n                MEM[0 + v20] = MEM[0 + v20] + 0xf4240 * _round_[v20][2];\n                MEM[32 + v20] = MEM[32 + v20] + 0x52b7d2dcc80cd2e4000000 * v20 + 0x16345785d8a0000 * v20;\n                MEM[64 + v20] = address(_round_[v20][0]);\n                MEM[96 + v20] = ~0x0 & (~0x0 & _round_[v20][0x1]);\n                MEM[128 + v20] = v20;\n                MEM[224 + v20] = v20;\n                MEM[192 + v20] = v20;\n                MEM[160 + v20] = v39;\n                _rID_ += 1;\n                _round_[v20][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v20][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v20][7] = v39;\n                MEM[0 + v20] = MEM[0 + v20] + 0xde0b6b3a7640000 * v22;\n                MEM[32 + v20] = MEM[32 + v20] + v13;\n                emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v13][0x1]), msg.value, MEM[0 + v20], MEM[32 + v20], address(MEM[64 + v20]), ~0x0 & (~0x0 & MEM[96 + v20]), MEM[128 + v20], MEM[160 + v20], MEM[192 + v20], MEM[224 + v20]);\n                v39 = v39 - v20;\n                goto {'0x1d9f0x355aB0xd89B0x2465B0x7a2', '0x362aB0xd89B0x2465B0x7a2'};\n            }\n        }\n        require(msg.value + _plyr_[v13][3] >= _plyr_[v13][3], 'SafeMath add failed');\n        _plyr_[v13][3] += msg.value;\n    } else {\n        0x2fb5(v71);\n        0x3280(MEM[64], v71, v71, msg.value, v71);\n    }\n}\n\nfunction receivePlayerNameList(uint256 varg0, bytes32 varg1) public nonPayable { \n    require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef == msg.sender, 'your not playerNames contract... hmmm..');\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n}\n\nfunction registerNameXID(string varg0, uint256 varg1, bool varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(!msg.sender.code.size, 'sorry humans only');\n    v2 = 0x3d90(v0);\n    require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n    v3, v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.registerNameXIDFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x476f6c6400000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction buyXaddr(address varg0, uint256 varg1) public payable { \n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x16345785d8a0000, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v0, v1 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v2, v3 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] = 1;\n    }\n    v8 = v9 = !varg0;\n    if (varg0) {\n        v8 = msg.sender == varg0;\n    }\n    if (!v8) {\n        if (_pIDxAddr_[varg0] != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxAddr_[varg0];\n        }\n    } else {\n        v10 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v11 = v12 = varg1 < 0;\n    if (varg1 >= 0) {\n        v11 = varg1 > 3;\n    }\n    if (v11) {\n    }\n    v13 = _rID_;\n    v14 = v15 = block.timestamp > _getTimeLeft + _round_[v13][4];\n    if (v15) {\n        v14 = v16 = block.timestamp <= _round_[v13][2];\n        if (block.timestamp > _round_[v13][2]) {\n            v14 = v17 = block.timestamp > _round_[v13][2];\n            if (v17) {\n                v14 = !_round_[v13];\n            }\n        }\n    }\n    if (!v14) {\n        v18 = v19 = block.timestamp > _round_[v13][2];\n        if (v19) {\n            v18 = !(0xff & _round_[v13][0x3]);\n        }\n        if (v18) {\n            _round_[v13][3] = 0x1 | ~0xff & _round_[v13][0x3];\n            v20 = v21 = MEM[64];\n            MEM[v21] = 0;\n            MEM[32 + v21] = 0;\n            MEM[64 + v21] = 0;\n            MEM[96 + v21] = 0;\n            MEM[128 + v21] = 0;\n            MEM[160 + v21] = 0;\n            MEM[192 + v21] = 0;\n            MEM[224 + v21] = 0;\n            MEM[256 + v21] = 0;\n            v20 = v22 = _rID_;\n            v20 = v23 = 0;\n            v20 = v24 = _round_[v22];\n            v20 = v25 = _round_[v22][1];\n            v20 = v26 = _round_[v22][7];\n            if (v26) {\n                v27 = 48 * v26;\n                assert(v26);\n                require(v27 / v26 == 48, 'SafeMath mul failed');\n            } else {\n                v27 = v28 = 0;\n            }\n            assert(100);\n            v20 = v29 = v27 / 100;\n            v20 = v30 = v26 / 25;\n            if (v26) {\n                v31 = _potSplit_[v25] * v26;\n                assert(v26);\n                require(v31 / v26 == _potSplit_[v25], 'SafeMath mul failed');\n            } else {\n                v31 = v32 = 0;\n            }\n            assert(100);\n            v20 = v33 = v31 / 100;\n            if (v26) {\n                v34 = _potSplit_[v25][1] * v26;\n                assert(v26);\n                require(v34 / v26 == _potSplit_[v25][1], 'SafeMath mul failed');\n            } else {\n                v34 = v35 = 0;\n            }\n            assert(100);\n            v20 = v36 = v34 / 100;\n            v20 = v37 = 13866;\n            v20 = v38 = 7583;\n            require(v29 <= v26, 'SafeMath sub failed');\n            v39 = v40 = v26 - v29;\n            while (v20 > v39) {\n                require(v20 <= v39, 'SafeMath sub failed');\n                if (v20) {\n                    v41 = 0xde0b6b3a7640000 * v20;\n                    assert(v20);\n                    require(v41 / v20 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v41 = v42 = 0;\n                }\n                assert(_round_[v20][5]);\n                if (v41 / _round_[v20][5]) {\n                    v43 = _round_[v20][5] * (v41 / _round_[v20][5]);\n                    assert(v41 / _round_[v20][5]);\n                    require(v43 / (v41 / _round_[v20][5]) == _round_[v20][5], 'SafeMath mul failed');\n                } else {\n                    v43 = v44 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v43 / 0xde0b6b3a7640000 <= v20, 'SafeMath sub failed');\n                if (v20 - v43 / 0xde0b6b3a7640000 > 0) {\n                    require(v20 - v43 / 0xde0b6b3a7640000 <= v20, 'SafeMath sub failed');\n                    v20 = v45 = v20 - (v20 - v43 / 0xde0b6b3a7640000);\n                    v39 = v46 = v20 - v43 / 0xde0b6b3a7640000 + v39;\n                    require(v46 >= v39, 'SafeMath add failed');\n                }\n                v47 = v48 = 14055;\n                v47 = v49 = _rID_;\n                v47 = v50 = 0;\n                v20 = v51 = _round_[v49][22];\n                while (v47 < v51) {\n                    assert(v47 < 10);\n                    v47 = v47 + 1;\n                    v47 += _plyr_[STORAGE[v47 + (12 + keccak256(v49, 11))]][7];\n                }\n                v20 = v52 = 0;\n                while (v20 < v20) {\n                    if (v20 < 10) {\n                        break;\n                    }\n                    assert(v20 < 10);\n                    v47 = v53 = STORAGE[v20 + (12 + keccak256(v47, 11))];\n                    v47 = v54 = _plyr_[v53][2];\n                    v20 = v55 = 21514;\n                    v20 = v56 = 14825;\n                    if (v47) {\n                        break;\n                    }\n                    assert(v47);\n                    if (v20) {\n                        v57 = _plyr_[v53][7] / v47 * v20;\n                        assert(v20);\n                        require(v57 / v20 == _plyr_[v53][7] / v47, 'SafeMath mul failed');\n                    } else {\n                        v57 = v58 = 0;\n                    }\n                    while (1) {\n                        goto {'0x540aB0x36deB0xd89B0x28720x2667B0x833', '0x39e90x5341B0x36deB0xd89B0x28720x2667B0x833'};\n                        v57 += v47;\n                        if (v57 >= v57) {\n                            break;\n                        }\n                        require(v57 >= v57, 'SafeMath add failed');\n                    }\n                    _plyr_[v47][2] = v57;\n                    v20 = v20 + 1;\n                }\n                require(_round_[v20][8] + v41 / _round_[v20][5] >= v41 / _round_[v20][5], 'SafeMath add failed');\n                _round_[v20][8] = _round_[v20][8] + v41 / _round_[v20][5];\n                if (v20 > 0) {\n                    if (v20) {\n                        v59 = 20 * v20;\n                        assert(v20);\n                        require(v59 / v20 == 20, 'SafeMath mul failed');\n                    } else {\n                        v59 = v60 = 0;\n                    }\n                    assert(100);\n                    v61 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v59 / 100).gas(!(v59 / 100) * 2300);\n                    require(v61); // checks call status, propagates error data on error\n                    if (v20) {\n                        v62 = 20 * v20;\n                        assert(v20);\n                        require(v62 / v20 == 20, 'SafeMath mul failed');\n                    } else {\n                        v62 = v63 = 0;\n                    }\n                    assert(100);\n                    v64 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v62 / 100).gas(!(v62 / 100) * 2300);\n                    require(v64); // checks call status, propagates error data on error\n                    if (v20) {\n                        v65 = 50 * v20;\n                        assert(v20);\n                        require(v65 / v20 == 50, 'SafeMath mul failed');\n                    } else {\n                        v65 = v66 = 0;\n                    }\n                    assert(100);\n                    v67 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v65 / 100).gas(!(v65 / 100) * 2300);\n                    require(v67); // checks call status, propagates error data on error\n                    if (v20) {\n                        v68 = 10 * v20;\n                        assert(v20);\n                        require(v68 / v20 == 10, 'SafeMath mul failed');\n                    } else {\n                        v68 = v69 = 0;\n                    }\n                    assert(100);\n                    v70 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v68 / 100).gas(!(v68 / 100) * 2300);\n                    require(v70); // checks call status, propagates error data on error\n                }\n                MEM[0 + v20] = MEM[0 + v20] + 0xf4240 * _round_[v20][2];\n                MEM[32 + v20] = MEM[32 + v20] + 0x52b7d2dcc80cd2e4000000 * v20 + 0x16345785d8a0000 * v20;\n                MEM[64 + v20] = address(_round_[v20][0]);\n                MEM[96 + v20] = ~0x0 & (~0x0 & _round_[v20][0x1]);\n                MEM[128 + v20] = v20;\n                MEM[224 + v20] = v20;\n                MEM[192 + v20] = v20;\n                MEM[160 + v20] = v39;\n                _rID_ += 1;\n                _round_[v20][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v20][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v20][7] = v39;\n                MEM[0 + v20] = MEM[0 + v20] + 0xde0b6b3a7640000 * v22;\n                MEM[32 + v20] = MEM[32 + v20] + v13;\n                emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v13][0x1]), msg.value, MEM[0 + v20], MEM[32 + v20], address(MEM[64 + v20]), ~0x0 & (~0x0 & MEM[96 + v20]), MEM[128 + v20], MEM[160 + v20], MEM[192 + v20], MEM[224 + v20]);\n                v39 = v39 - v20;\n                goto {'0x362aB0xd89B0x28720x2667B0x833', '0x1d9f0x355aB0xd89B0x28720x2667B0x833'};\n            }\n        }\n        require(msg.value + _plyr_[v13][3] >= _plyr_[v13][3], 'SafeMath add failed');\n        _plyr_[v13][3] += msg.value;\n    } else {\n        0x2fb5(v71);\n        0x3280(MEM[64], v71, v71, msg.value, v71);\n    }\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1], _plyrRnds_[varg1][2], _plyrRnds_[varg1][3];\n}\n\nfunction buyXname(bytes32 varg0, uint256 varg1) public payable { \n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x16345785d8a0000, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    MEM[256 + MEM[64]] = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v0, v1 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerID(msg.sender).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v2, v3 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerName(v1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.code.size);\n        v4, v5 = 0xed8c249b7eb8d5b3cf7e0d6ccfa270249f7c0cef.getPlayerLAff(v1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v1;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v3) {\n            _pIDxName_[v3] = v1;\n            _plyr_[v3][1] = v3;\n            _plyrNames_[v3] = 0x1 | ~0xff & _plyrNames_[v3];\n        }\n        v6 = v7 = v5;\n        if (v5) {\n            v6 = v5 != v1;\n        }\n        if (v6) {\n            _plyr_[v1][6] = v5;\n        }\n        MEM[MEM[64]] = 1;\n    }\n    v8 = v9 = !varg0;\n    if (varg0) {\n        v8 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v8) {\n        if (_pIDxName_[varg0] != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxName_[varg0];\n            v10 = v11 = varg1 < 0;\n            if (varg1 >= 0) {\n                v10 = varg1 > 3;\n            }\n            if (v10) {\n            }\n            goto 0x28720x28b2B0x88b;\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = v14 = varg1 < 0;\n    if (varg1 >= 0) {\n        v13 = varg1 > 3;\n    }\n    if (v13) {\n    }\n    v15 = _rID_;\n    v16 = v17 = block.timestamp > _getTimeLeft + _round_[v15][4];\n    if (v17) {\n        v16 = v18 = block.timestamp <= _round_[v15][2];\n        if (block.timestamp > _round_[v15][2]) {\n            v16 = v19 = block.timestamp > _round_[v15][2];\n            if (v19) {\n                v16 = !_round_[v15];\n            }\n        }\n    }\n    if (!v16) {\n        v20 = v21 = block.timestamp > _round_[v15][2];\n        if (v21) {\n            v20 = !(0xff & _round_[v15][0x3]);\n        }\n        if (v20) {\n            _round_[v15][3] = 0x1 | ~0xff & _round_[v15][0x3];\n            v22 = v23 = MEM[64];\n            MEM[v23] = 0;\n            MEM[32 + v23] = 0;\n            MEM[64 + v23] = 0;\n            MEM[96 + v23] = 0;\n            MEM[128 + v23] = 0;\n            MEM[160 + v23] = 0;\n            MEM[192 + v23] = 0;\n            MEM[224 + v23] = 0;\n            MEM[256 + v23] = 0;\n            v22 = v24 = _rID_;\n            v22 = v25 = 0;\n            v22 = v26 = _round_[v24];\n            v22 = v27 = _round_[v24][1];\n            v22 = v28 = _round_[v24][7];\n            if (v28) {\n                v29 = 48 * v28;\n                assert(v28);\n                require(v29 / v28 == 48, 'SafeMath mul failed');\n            } else {\n                v29 = v30 = 0;\n            }\n            assert(100);\n            v22 = v31 = v29 / 100;\n            v22 = v32 = v28 / 25;\n            if (v28) {\n                v33 = _potSplit_[v27] * v28;\n                assert(v28);\n                require(v33 / v28 == _potSplit_[v27], 'SafeMath mul failed');\n            } else {\n                v33 = v34 = 0;\n            }\n            assert(100);\n            v22 = v35 = v33 / 100;\n            if (v28) {\n                v36 = _potSplit_[v27][1] * v28;\n                assert(v28);\n                require(v36 / v28 == _potSplit_[v27][1], 'SafeMath mul failed');\n            } else {\n                v36 = v37 = 0;\n            }\n            assert(100);\n            v22 = v38 = v36 / 100;\n            v22 = v39 = 13866;\n            v22 = v40 = 7583;\n            require(v31 <= v28, 'SafeMath sub failed');\n            v41 = v42 = v28 - v31;\n            while (v22 > v41) {\n                require(v22 <= v41, 'SafeMath sub failed');\n                if (v22) {\n                    v43 = 0xde0b6b3a7640000 * v22;\n                    assert(v22);\n                    require(v43 / v22 == 0xde0b6b3a7640000, 'SafeMath mul failed');\n                } else {\n                    v43 = v44 = 0;\n                }\n                assert(_round_[v22][5]);\n                if (v43 / _round_[v22][5]) {\n                    v45 = _round_[v22][5] * (v43 / _round_[v22][5]);\n                    assert(v43 / _round_[v22][5]);\n                    require(v45 / (v43 / _round_[v22][5]) == _round_[v22][5], 'SafeMath mul failed');\n                } else {\n                    v45 = v46 = 0;\n                }\n                assert(0xde0b6b3a7640000);\n                require(v45 / 0xde0b6b3a7640000 <= v22, 'SafeMath sub failed');\n                if (v22 - v45 / 0xde0b6b3a7640000 > 0) {\n                    require(v22 - v45 / 0xde0b6b3a7640000 <= v22, 'SafeMath sub failed');\n                    v22 = v47 = v22 - (v22 - v45 / 0xde0b6b3a7640000);\n                    v41 = v48 = v22 - v45 / 0xde0b6b3a7640000 + v41;\n                    require(v48 >= v41, 'SafeMath add failed');\n                }\n                v49 = v50 = 14055;\n                v49 = v51 = _rID_;\n                v49 = v52 = 0;\n                v22 = v53 = _round_[v51][22];\n                while (v49 < v53) {\n                    assert(v49 < 10);\n                    v49 = v49 + 1;\n                    v49 += _plyr_[STORAGE[v49 + (12 + keccak256(v51, 11))]][7];\n                }\n                v22 = v54 = 0;\n                while (v22 < v22) {\n                    if (v22 < 10) {\n                        break;\n                    }\n                    assert(v22 < 10);\n                    v49 = v55 = STORAGE[v22 + (12 + keccak256(v49, 11))];\n                    v49 = v56 = _plyr_[v55][2];\n                    v22 = v57 = 21514;\n                    v22 = v58 = 14825;\n                    if (v49) {\n                        break;\n                    }\n                    assert(v49);\n                    if (v22) {\n                        v59 = _plyr_[v55][7] / v49 * v22;\n                        assert(v22);\n                        require(v59 / v22 == _plyr_[v55][7] / v49, 'SafeMath mul failed');\n                    } else {\n                        v59 = v60 = 0;\n                    }\n                    while (1) {\n                        goto {'0x540aB0x36deB0xd89B0x28720x28b2B0x88b', '0x39e90x5341B0x36deB0xd89B0x28720x28b2B0x88b'};\n                        v59 += v49;\n                        if (v59 >= v59) {\n                            break;\n                        }\n                        require(v59 >= v59, 'SafeMath add failed');\n                    }\n                    _plyr_[v49][2] = v59;\n                    v22 = v22 + 1;\n                }\n                require(_round_[v22][8] + v43 / _round_[v22][5] >= v43 / _round_[v22][5], 'SafeMath add failed');\n                _round_[v22][8] = _round_[v22][8] + v43 / _round_[v22][5];\n                if (v22 > 0) {\n                    if (v22) {\n                        v61 = 20 * v22;\n                        assert(v22);\n                        require(v61 / v22 == 20, 'SafeMath mul failed');\n                    } else {\n                        v61 = v62 = 0;\n                    }\n                    assert(100);\n                    v63 = 0x918b8dc988e3702da4625d69e3d043e8aa9358e6.call().value(v61 / 100).gas(!(v61 / 100) * 2300);\n                    require(v63); // checks call status, propagates error data on error\n                    if (v22) {\n                        v64 = 20 * v22;\n                        assert(v22);\n                        require(v64 / v22 == 20, 'SafeMath mul failed');\n                    } else {\n                        v64 = v65 = 0;\n                    }\n                    assert(100);\n                    v66 = 0xcc221d6154a5091919240b36d476c2bdeaf246bd.call().value(v64 / 100).gas(!(v64 / 100) * 2300);\n                    require(v66); // checks call status, propagates error data on error\n                    if (v22) {\n                        v67 = 50 * v22;\n                        assert(v22);\n                        require(v67 / v22 == 50, 'SafeMath mul failed');\n                    } else {\n                        v67 = v68 = 0;\n                    }\n                    assert(100);\n                    v69 = 0x139aac9edd31015327394160516c26e8f3ee06ab.call().value(v67 / 100).gas(!(v67 / 100) * 2300);\n                    require(v69); // checks call status, propagates error data on error\n                    if (v22) {\n                        v70 = 10 * v22;\n                        assert(v22);\n                        require(v70 / v22 == 10, 'SafeMath mul failed');\n                    } else {\n                        v70 = v71 = 0;\n                    }\n                    assert(100);\n                    v72 = 0xde0015b72d1dc1f32768dc1983788f4c32f70f05.call().value(v70 / 100).gas(!(v70 / 100) * 2300);\n                    require(v72); // checks call status, propagates error data on error\n                }\n                MEM[0 + v22] = MEM[0 + v22] + 0xf4240 * _round_[v22][2];\n                MEM[32 + v22] = MEM[32 + v22] + 0x52b7d2dcc80cd2e4000000 * v22 + 0x16345785d8a0000 * v22;\n                MEM[64 + v22] = address(_round_[v22][0]);\n                MEM[96 + v22] = ~0x0 & (~0x0 & _round_[v22][0x1]);\n                MEM[128 + v22] = v22;\n                MEM[224 + v22] = v22;\n                MEM[192 + v22] = v22;\n                MEM[160 + v22] = v41;\n                _rID_ += 1;\n                _round_[v22][4] = block.timestamp;\n                require(0x15180 + block.timestamp >= block.timestamp, 'SafeMath add failed');\n                require(_getTimeLeft + (0x15180 + block.timestamp) >= 0x15180 + block.timestamp, 'SafeMath add failed');\n                _round_[1 + v22][2] = _getTimeLeft + (0x15180 + block.timestamp);\n                _round_[1 + v22][7] = v41;\n                MEM[0 + v22] = MEM[0 + v22] + 0xde0b6b3a7640000 * v24;\n                MEM[32 + v22] = MEM[32 + v22] + v15;\n                emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v15][0x1]), msg.value, MEM[0 + v22], MEM[32 + v22], address(MEM[64 + v22]), ~0x0 & (~0x0 & MEM[96 + v22]), MEM[128 + v22], MEM[160 + v22], MEM[192 + v22], MEM[224 + v22]);\n                v41 = v41 - v22;\n                goto {'0x362aB0xd89B0x28720x28b2B0x88b', '0x1d9f0x355aB0xd89B0x28720x28b2B0x88b'};\n            }\n        }\n        require(msg.value + _plyr_[v15][3] >= _plyr_[v15][3], 'SafeMath add failed');\n        _plyr_[v15][3] += msg.value;\n    } else {\n        0x2fb5(v73);\n        0x3280(MEM[64], v73, v73, msg.value, v73);\n    }\n}\n\nfunction setOtherFomo(address varg0) public nonPayable { \n    require(msg.sender == 0x100d5695a0b35bbb8c044aefef7c7b278e5843e1, 'only team just can activate');\n    require(!_setOtherFomo, 'silly dev, you already did that');\n    _setOtherFomo = varg0;\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + _getTimeLeft) {\n            require(block.timestamp <= _getTimeLeft + _round_[_rID_][4], 'SafeMath sub failed');\n            v0 = _getTimeLeft + _round_[_rID_][4] - block.timestamp;\n            goto 0xfb70x2bc7B0x8de;\n        } else {\n            require(block.timestamp <= _round_[_rID_][2], 'SafeMath sub failed');\n            v0 = v2 = _round_[_rID_][2] - block.timestamp;\n        }\n        goto 0xfc90x2bc7B0x8de;\n    }\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[varg0][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[varg0][2];\n        if (block.timestamp > _round_[varg0][2]) {\n            v0 = v3 = block.timestamp > _round_[varg0][2];\n            if (v3) {\n                v0 = !_round_[varg0];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x47a0(_round_[varg0][5], varg1);\n    } else {\n        v4 = v6 = 0x4779(_round_[varg0][5], varg1, _round_[varg0][6]);\n    }\n    return v4;\n}\n\nfunction iWantXKeys(uint256 varg0) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x4836(varg0);\n    } else {\n        require(varg0 + _round_[_rID_][5] >= _round_[_rID_][5], 'SafeMath add failed');\n        v4 = 0x3a85(varg0, varg0 + _round_[_rID_][5]);\n    }\n    return v4;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction airDropPot_() public nonPayable { \n    return _airDropPot_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    return address(_plyr_[varg0]), _plyr_[varg0][1], _plyr_[varg0][2], _plyr_[varg0][3], _plyr_[varg0][4], _plyr_[varg0][5], _plyr_[varg0][6], _plyr_[varg0][7];\n}\n\nfunction potSwap() public payable { \n    require(msg.value + _round_[1 + _rID_][7] >= _round_[1 + _rID_][7], 'SafeMath add failed');\n    _round_[1 + _rID_][7] += msg.value;\n    emit onPotSwapDeposit(1 + _rID_, msg.value);\n}\n\nfunction getPlayerInfoByAddress(address varg0) public nonPayable { \n    v0 = _pIDxAddr_[varg0];\n    MEM[0] = v0;\n    MEM[32] = 8;\n    v1 = 0x4715(_pIDxAddr_[v0][5], v0);\n    require(v1 + _plyr_[v0][3] >= _plyr_[v0][3], 'SafeMath add failed');\n    return v0, _pIDxAddr_[v0][1], _plyrRnds_[v0][1], _pIDxAddr_[v0][2], v1 + _plyr_[v0][3], _plyr_[v0][4], _plyrRnds_[v0][0], _plyrRnds_[v0][6];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x79ce327 == function_selector) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xf15f4c0 == function_selector) {\n            activate();\n        } else if (0x10f01eba == function_selector) {\n            pIDxAddr_(address);\n        } else if (0x11a09ae7 == function_selector) {\n            airDropTracker_();\n        } else if (0x24c33d33 == function_selector) {\n            round_(uint256);\n        } else if (0x2660316e == function_selector) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x2ce21999 == function_selector) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == function_selector) {\n            pIDxName_(bytes32);\n        } else if (0x349cdcac == function_selector) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x3ddd4698 == function_selector) {\n            registerNameXaddr(string,address,bool);\n        } else if (0x49cc635d == function_selector) {\n            receivePlayerInfo(uint256,address,bytes32,uint256);\n        } else if (0x5893d481 == function_selector) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == function_selector) {\n            rID_();\n        } else if (0x63066434 == function_selector) {\n            getPlayerVaults(uint256);\n        } else if (0x685ffd83 == function_selector) {\n            registerNameXname(string,bytes32,bool);\n        } else if (0x747dff42 == function_selector) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == function_selector) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x8f38f309 == function_selector) {\n            buyXid(uint256,uint256);\n        } else if (0x8f7140ea == function_selector) {\n            receivePlayerNameList(uint256,bytes32);\n        } else if (0x921dec21 == function_selector) {\n            registerNameXID(string,uint256,bool);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x98a0871d == function_selector) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == function_selector) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa65b37a1 == function_selector) {\n            buyXname(bytes32,uint256);\n        } else if (0xb483c054 == function_selector) {\n            setOtherFomo(address);\n        } else if (0xc519500e == function_selector) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == function_selector) {\n            getTimeLeft();\n        } else if (0xce89c80c == function_selector) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == function_selector) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == function_selector) {\n            activated_();\n        } else if (0xd87574e0 == function_selector) {\n            airDropPot_();\n        } else if (0xde7874f3 == function_selector) {\n            plyr_(uint256);\n        } else if (0xed78cf4a == function_selector) {\n            potSwap();\n        } else if (0xee0b5d8b == function_selector) {\n            getPlayerInfoByAddress(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 42391 tokens. Please reduce the length of the messages."
}