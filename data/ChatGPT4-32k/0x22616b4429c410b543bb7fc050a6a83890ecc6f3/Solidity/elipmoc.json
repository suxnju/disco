{
	"address": "0x22616b4429c410b543bb7fc050a6a83890ecc6f3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is an interpretation of the decompiled code into Solidity code. The exact structure and code may vary, but the general structure and functionality is preserved:\n\n```Solidity\npragma solidity ^0.8.18;\n\ncontract ERC20 {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(string memory name_, string memory symbol_, uint256 totalSupply_) {\n        _name = name_;\n        _symbol = symbol_;\n        _totalSupply = totalSupply_;\n        _balanceOf[msg.sender] = totalSupply_;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(_balanceOf[msg.sender] >= value, \"ERC20: insufficient balance\");\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(_allowance[from][msg.sender] >= value, \"ERC20: insufficient allowance\");\n        _allowance[from][msg.sender] -= value;\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _allowance[msg.sender][spender] += addedValue;\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(_allowance[msg.sender][spender] >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _allowance[msg.sender][spender] -= subtractedValue;\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n        return true;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n}\n```\n\nThis contract implements the ERC20 interface. It allows users to approve, transfer and transfer from accounts, as well as increase and decrease allowances. It also allows users to view the balance of a given account, the allowance of a given account to another, the total supply of tokens, the name and symbol of the token and the number of decimals the token uses.",
				"role": "assistant"
			}
		}
	],
	"created": 1701486371,
	"id": "chatcmpl-8RAcVm6ysOh31Z16Al3pG0NbVwpR1",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.21 02:52 UTC\n// Compiled using the solidity compiler version 0.8.18\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_172; // STORAGE[0x3]\nuint256[] _@symbol_182; // STORAGE[0x4]\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg2 == varg2);\n    if (_allowance[varg0][msg.sender] != uint256.max) {\n        require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: insufficient allowance'));\n        @_approve_638(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n    }\n    @_transfer_464(varg2, varg1, varg0);\n    return bool(1);\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(_allowance[msg.sender][varg0] <= _allowance[msg.sender][varg0] + varg1, Panic(17)); // arithmetic overflow or underflow\n    @_approve_638(_allowance[msg.sender][varg0] + varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction symbol() public payable { \n    v0 = @symbol_182();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(_allowance[msg.sender][varg0] >= varg1, Error('ERC20: decreased allowance below zero'));\n    @_approve_638(_allowance[msg.sender][varg0] - varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_464(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @name_172() private { \n    v0 = v1 = _@name_172.length >> 1;\n    if (!(_@name_172.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_172.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_172.length >> 1;\n    if (!(_@name_172.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_172.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@name_172.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_172.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @symbol_182() private { \n    v0 = v1 = _@symbol_182.length >> 1;\n    if (!(_@symbol_182.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_182.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_182.length >> 1;\n    if (!(_@symbol_182.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_182.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@symbol_182.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_182.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_638(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_464(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[address(varg2)] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    _balanceOf[address(varg2)] = _balanceOf[address(varg2)] - varg0;\n    _balanceOf[address(varg1)] = _balanceOf[address(varg1)] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public payable { \n    v0 = @name_172();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_approve_638(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x39509351 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0x39509351 == function_selector >> 224) {\n        increaseAllowance(address,uint256);\n    } else if (0x70a08231 == function_selector >> 224) {\n        balanceOf(address);\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.21 02:52 UTC\n// Compiled using the solidity compiler version 0.8.18\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_172; // STORAGE[0x3]\nuint256[] _@symbol_182; // STORAGE[0x4]\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg2 == varg2);\n    if (_allowance[varg0][msg.sender] != uint256.max) {\n        require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: insufficient allowance'));\n        @_approve_638(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n    }\n    @_transfer_464(varg2, varg1, varg0);\n    return bool(1);\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(_allowance[msg.sender][varg0] <= _allowance[msg.sender][varg0] + varg1, Panic(17)); // arithmetic overflow or underflow\n    @_approve_638(_allowance[msg.sender][varg0] + varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction symbol() public payable { \n    v0 = @symbol_182();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(_allowance[msg.sender][varg0] >= varg1, Error('ERC20: decreased allowance below zero'));\n    @_approve_638(_allowance[msg.sender][varg0] - varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_464(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @name_172() private { \n    v0 = v1 = _@name_172.length >> 1;\n    if (!(_@name_172.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_172.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_172.length >> 1;\n    if (!(_@name_172.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_172.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@name_172.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_172.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @symbol_182() private { \n    v0 = v1 = _@symbol_182.length >> 1;\n    if (!(_@symbol_182.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_182.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_182.length >> 1;\n    if (!(_@symbol_182.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_182.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@symbol_182.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_182.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_638(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_464(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[address(varg2)] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    _balanceOf[address(varg2)] = _balanceOf[address(varg2)] - varg0;\n    _balanceOf[address(varg1)] = _balanceOf[address(varg1)] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public payable { \n    v0 = @name_172();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_approve_638(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x39509351 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0x39509351 == function_selector >> 224) {\n        increaseAllowance(address,uint256);\n    } else if (0x70a08231 == function_selector >> 224) {\n        balanceOf(address);\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.21 02:52 UTC\n// Compiled using the solidity compiler version 0.8.18\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_172; // STORAGE[0x3]\nuint256[] _@symbol_182; // STORAGE[0x4]\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg2 == varg2);\n    if (_allowance[varg0][msg.sender] != uint256.max) {\n        require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: insufficient allowance'));\n        @_approve_638(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n    }\n    @_transfer_464(varg2, varg1, varg0);\n    return bool(1);\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(_allowance[msg.sender][varg0] <= _allowance[msg.sender][varg0] + varg1, Panic(17)); // arithmetic overflow or underflow\n    @_approve_638(_allowance[msg.sender][varg0] + varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction symbol() public payable { \n    v0 = @symbol_182();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(_allowance[msg.sender][varg0] >= varg1, Error('ERC20: decreased allowance below zero'));\n    @_approve_638(_allowance[msg.sender][varg0] - varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_464(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @name_172() private { \n    v0 = v1 = _@name_172.length >> 1;\n    if (!(_@name_172.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_172.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_172.length >> 1;\n    if (!(_@name_172.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_172.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@name_172.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_172.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @symbol_182() private { \n    v0 = v1 = _@symbol_182.length >> 1;\n    if (!(_@symbol_182.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_182.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_182.length >> 1;\n    if (!(_@symbol_182.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_182.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = v10 = _@symbol_182.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_182.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_638(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 - address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 - address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_464(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) - address(0x0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1) - address(0x0), Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[address(varg2)] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    _balanceOf[address(varg2)] = _balanceOf[address(varg2)] - varg0;\n    _balanceOf[address(varg1)] = _balanceOf[address(varg1)] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public payable { \n    v0 = @name_172();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_approve_638(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x39509351 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0x39509351 == function_selector >> 224) {\n        increaseAllowance(address,uint256);\n    } else if (0x70a08231 == function_selector >> 224) {\n        balanceOf(address);\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 25.04136633872986,
	"usage": {
		"completion_tokens": 716,
		"prompt_tokens": 2401,
		"total_tokens": 3117
	}
}