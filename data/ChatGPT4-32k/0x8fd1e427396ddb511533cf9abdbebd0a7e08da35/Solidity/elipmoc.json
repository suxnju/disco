{
	"address": "0x8fd1e427396ddb511533cf9abdbebd0a7e08da35",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the converted Solidity code from the given decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenContract {\n    uint256 private _minDeposit;\n    mapping (address => uint256) private _fallback;\n    address private _confirmOwner;\n    address private _changeOwner;\n    address private _initTokenBank;\n\n    function changeOwner(address newOwner) external {\n        require(_changeOwner == msg.sender, \"Not authorized\");\n        _confirmOwner = newOwner;\n    }\n\n    function confirmOwner() external {\n        require(msg.sender == _confirmOwner, \"Not authorized\");\n        _changeOwner = _confirmOwner;\n    }\n\n    function getBalance() external view returns(uint256) { \n        return address(this).balance;\n    }\n\n    function withdrawToken(address to, uint256 amount) external { \n        require(_changeOwner == msg.sender, \"Not authorized\");\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function deposit() external payable { \n        require(msg.value >= _minDeposit, \"Deposit amount is not enough\");\n        _fallback[msg.sender] += msg.value;\n    }\n\n    function getHoldersBalance(address holder) external view returns(uint256) { \n        return _fallback[holder];\n    }\n\n    function withdrawToHolder(address holder, uint256 amount) external payable { \n        require(_changeOwner == msg.sender, \"Not authorized\");\n        require(_fallback[msg.sender] > 0, \"Insufficient balance\");\n        require(_fallback[holder] >= amount, \"Withdrawal amount is too high\");\n        _fallback[holder] -= amount;\n    }\n\n    function fallback() external payable { \n        require(msg.value >= _minDeposit, \"Deposit amount is not enough\");\n        _fallback[msg.sender] += msg.value;\n    }\n\n    function getMinDeposit() external view returns(uint256) { \n        return _minDeposit;\n    }\n\n    function initTokenBank() external { \n        _initTokenBank = msg.sender;\n        _minDeposit = 0.1 ether;\n    }\n\n    function withdrawTokenToHolder(address holder, address to, uint256 amount) external {\n        require(_changeOwner == msg.sender, \"Not authorized\");\n        require(_fallback[holder] > 0, \"Insufficient balance\");\n        _fallback[holder] = 0;\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\nPlease note that this Solidity code is not exactly as the given decompiled code. It may need to modify according to your exact requirements. The given decompiled code consists some low-level operations that can be replaced by higher-level Solidity code. Also, the decompiled code includes some operations that are not safe to use in a Solidity smart contract, so I replaced them with equivalent safe operations.",
				"role": "assistant"
			}
		}
	],
	"created": 1701458388,
	"id": "chatcmpl-8R3LA8t7cX9ERwUBBmlM5sS70Ejz5",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 01:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minDeposit; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x4]\naddress _confirmOwner; // STORAGE[0x0] bytes 0 to 19\naddress _changeOwner; // STORAGE[0x1] bytes 0 to 19\naddress _initTokenBank; // STORAGE[0x2] bytes 0 to 19\n\n\nfunction changeOwner(address varg0) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        _confirmOwner = varg0;\n    }\n}\n\nfunction confirmOwner() public nonPayable { \n    if (msg.sender == _confirmOwner) {\n        _changeOwner = _confirmOwner;\n    }\n}\n\nfunction Bal() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction WithdrawToken(address varg0, uint256 varg1, address varg2) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        v0 = varg0.transfer(varg2, varg1).gas(msg.gas - 25710);\n    }\n}\n\nfunction Deposit() public payable { \n    if (msg.value >= _minDeposit) {\n        _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n    }\n}\n\nfunction Holders(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction WithdrawToHolder(address varg0, uint256 varg1) public payable { \n    if (_changeOwner == msg.sender) {\n        if (_fallback[msg.sender] > 0) {\n            if (_fallback[varg0] >= varg1) {\n                _fallback[varg0] = _fallback[varg0] - varg1;\n            }\n        }\n    }\n}\n\nfunction fallback() public payable { \n    if (msg.value >= _minDeposit) {\n        _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n    }\n}\n\nfunction MinDeposit() public nonPayable { \n    return _minDeposit;\n}\n\nfunction initTokenBank() public nonPayable { \n    _initTokenBank = msg.sender;\n    _minDeposit = 0xde0b6b3a7640000;\n}\n\nfunction WitdrawTokenToHolder(address varg0, address varg1, uint256 varg2) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        if (_fallback[varg0] > 0) {\n            _fallback[varg0] = 0;\n            if (_changeOwner == msg.sender) {\n                v0 = varg1.transfer(varg0, varg2).gas(msg.gas - 25710);\n            }\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x11bcd830 == function_selector) {\n            MinDeposit();\n        } else if (0x290b1e5f == function_selector) {\n            initTokenBank();\n        } else if (0x2e2a51bd == function_selector) {\n            WitdrawTokenToHolder(address,address,uint256);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xbd9b6d86 == function_selector) {\n            confirmOwner();\n        } else if (0xbea69bb9 == function_selector) {\n            Bal();\n        } else if (0xc7de2d13 == function_selector) {\n            WithdrawToken(address,uint256,address);\n        } else if (0xed21248c == function_selector) {\n            Deposit();\n        } else if (0xeec0ddd7 == function_selector) {\n            Holders(address);\n        } else if (0xf8ff612e == function_selector) {\n            WithdrawToHolder(address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 01:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minDeposit; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x4]\naddress _confirmOwner; // STORAGE[0x0] bytes 0 to 19\naddress _changeOwner; // STORAGE[0x1] bytes 0 to 19\naddress _initTokenBank; // STORAGE[0x2] bytes 0 to 19\n\n\nfunction changeOwner(address varg0) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        _confirmOwner = varg0;\n    }\n}\n\nfunction confirmOwner() public nonPayable { \n    if (msg.sender == _confirmOwner) {\n        _changeOwner = _confirmOwner;\n    }\n}\n\nfunction Bal() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction WithdrawToken(address varg0, uint256 varg1, address varg2) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        v0 = varg0.transfer(varg2, varg1).gas(msg.gas - 25710);\n    }\n}\n\nfunction Deposit() public payable { \n    if (msg.value >= _minDeposit) {\n        _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n    }\n}\n\nfunction Holders(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction WithdrawToHolder(address varg0, uint256 varg1) public payable { \n    if (_changeOwner == msg.sender) {\n        if (_fallback[msg.sender] > 0) {\n            if (_fallback[varg0] >= varg1) {\n                _fallback[varg0] = _fallback[varg0] - varg1;\n            }\n        }\n    }\n}\n\nfunction fallback() public payable { \n    if (msg.value >= _minDeposit) {\n        _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n    }\n}\n\nfunction MinDeposit() public nonPayable { \n    return _minDeposit;\n}\n\nfunction initTokenBank() public nonPayable { \n    _initTokenBank = msg.sender;\n    _minDeposit = 0xde0b6b3a7640000;\n}\n\nfunction WitdrawTokenToHolder(address varg0, address varg1, uint256 varg2) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        if (_fallback[varg0] > 0) {\n            _fallback[varg0] = 0;\n            if (_changeOwner == msg.sender) {\n                v0 = varg1.transfer(varg0, varg2).gas(msg.gas - 25710);\n            }\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x11bcd830 == function_selector) {\n            MinDeposit();\n        } else if (0x290b1e5f == function_selector) {\n            initTokenBank();\n        } else if (0x2e2a51bd == function_selector) {\n            WitdrawTokenToHolder(address,address,uint256);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xbd9b6d86 == function_selector) {\n            confirmOwner();\n        } else if (0xbea69bb9 == function_selector) {\n            Bal();\n        } else if (0xc7de2d13 == function_selector) {\n            WithdrawToken(address,uint256,address);\n        } else if (0xed21248c == function_selector) {\n            Deposit();\n        } else if (0xeec0ddd7 == function_selector) {\n            Holders(address);\n        } else if (0xf8ff612e == function_selector) {\n            WithdrawToHolder(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 01:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minDeposit; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x4]\naddress _confirmOwner; // STORAGE[0x0] bytes 0 to 19\naddress _changeOwner; // STORAGE[0x1] bytes 0 to 19\naddress _initTokenBank; // STORAGE[0x2] bytes 0 to 19\n\n\nfunction changeOwner(address varg0) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        _confirmOwner = varg0;\n    }\n}\n\nfunction confirmOwner() public nonPayable { \n    if (msg.sender == _confirmOwner) {\n        _changeOwner = _confirmOwner;\n    }\n}\n\nfunction Bal() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction WithdrawToken(address varg0, uint256 varg1, address varg2) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        v0 = varg0.transfer(varg2, varg1).gas(msg.gas - 25710);\n    }\n}\n\nfunction Deposit() public payable { \n    if (msg.value >= _minDeposit) {\n        _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n    }\n}\n\nfunction Holders(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction WithdrawToHolder(address varg0, uint256 varg1) public payable { \n    if (_changeOwner == msg.sender) {\n        if (_fallback[msg.sender] > 0) {\n            if (_fallback[varg0] >= varg1) {\n                _fallback[varg0] = _fallback[varg0] - varg1;\n            }\n        }\n    }\n}\n\nfunction fallback() public payable { \n    if (msg.value >= _minDeposit) {\n        _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n    }\n}\n\nfunction MinDeposit() public nonPayable { \n    return _minDeposit;\n}\n\nfunction initTokenBank() public nonPayable { \n    _initTokenBank = msg.sender;\n    _minDeposit = 0xde0b6b3a7640000;\n}\n\nfunction WitdrawTokenToHolder(address varg0, address varg1, uint256 varg2) public nonPayable { \n    if (_changeOwner == msg.sender) {\n        if (_fallback[varg0] > 0) {\n            _fallback[varg0] = 0;\n            if (_changeOwner == msg.sender) {\n                v0 = varg1.transfer(varg0, varg2).gas(msg.gas - 25710);\n            }\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x11bcd830 == function_selector) {\n            MinDeposit();\n        } else if (0x290b1e5f == function_selector) {\n            initTokenBank();\n        } else if (0x2e2a51bd == function_selector) {\n            WitdrawTokenToHolder(address,address,uint256);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xbd9b6d86 == function_selector) {\n            confirmOwner();\n        } else if (0xbea69bb9 == function_selector) {\n            Bal();\n        } else if (0xc7de2d13 == function_selector) {\n            WithdrawToken(address,uint256,address);\n        } else if (0xed21248c == function_selector) {\n            Deposit();\n        } else if (0xeec0ddd7 == function_selector) {\n            Holders(address);\n        } else if (0xf8ff612e == function_selector) {\n            WithdrawToHolder(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 45.31697463989258,
	"usage": {
		"completion_tokens": 604,
		"prompt_tokens": 955,
		"total_tokens": 1559
	}
}