{
	"address": "0x25a06d4e1f804ce62cf11b091180a5c84980d93a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Solidity is a static typed language, meaning the data type of each variable must be specified. The decompiled code provided doesn't give explicit types for the variables used, which makes directly translating this into Solidity difficult. However, I can provide an example of what a Solidity contract might look like, using similar function and variable names from the bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private balances;\n    mapping (address => uint256) private dividends;\n\n    event Withdraw(address indexed user, uint256 amount);\n\n    function myBalance(address user) public view returns (uint256) {\n        return balances[user];\n    }\n\n    function myDividends(address user) public view returns (uint256) {\n        return dividends[user];\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient balance\");\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        dividends[msg.sender] += amount;\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n```\nIn this example:\n\n- There are mappings that keep track of the balance and dividends for each address.\n- The `myBalance` and `myDividends` functions return the balance and dividends of a given address.\n- The `withdraw` function allows an address to withdraw their balance and move it to their dividends. It emits a `Withdraw` event when this happens.\n\nPlease note that this is a simple and generic example. The actual Solidity code that corresponds to your bytecode would likely be more complex and have additional features.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039312,
	"id": "chatcmpl-8Chsm717TmXQy9oxeZVSWRkrSbHAn",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 04:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _stakingRequirement; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _selingWithdrawBalance; // STORAGE[0x6]\nuint256[] array_8; // STORAGE[0x8]\nuint256 _totalSupply; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 _soldTokens; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_10; // STORAGE[0x10]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0x14]\nuint8 _onlyAmbassadors; // STORAGE[0x15] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonSellingWithdraw(address, uint256);\nonTokenSell(address, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x102b(uint256 varg0) private { \n    require(_exit[msg.sender] > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v0 = 0x1589(varg0);\n    v1 = 0x129a(18, 100, 10, v0);\n    v2 = 0x129a(18, 100, 90, v0);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    assert(varg0 <= _soldTokens);\n    _soldTokens = _soldTokens - varg0;\n    _selingWithdrawBalance[msg.sender] += v2;\n    0x1386(v1);\n    emit onTokenSell(msg.sender, varg0);\n    return ;\n}\n\nfunction 0x129a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg1);\n    assert(10);\n    return (5 + varg2 * 10 ** (1 + varg0) / varg1) / 10 * varg3 / 0xde0b6b3a7640000;\n}\n\nfunction 0x12df(uint256 varg0) private { \n    v0 = v1 = 0xa70c3c40a64e6c51999090b65f67d9240000000000000 + (_totalSupply * 0x1812f9cf7920e2b66973e2000000000 + (0xde0b6b3a7640000 * _totalSupply ** 2 + varg0 * 0x59aedfc10d7279c5eed1401645400000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x33b2e3c9fd0803ce8000000 <= v0);\n    assert(0x3b9aca00);\n    return (v0 - 0x33b2e3c9fd0803ce8000000) / 0x3b9aca00 - _totalSupply;\n}\n\nfunction 0x1386(uint256 varg0) private { \n    stor_11 = varg0;\n    v0 = v1 = 0;\n    while (v0 < array_8.length) {\n        assert(v0 < array_8.length);\n        v0 += _exit[address(array_8[v0])];\n        v0 += 1;\n    }\n    v2 = v3 = 0;\n    while (v2 < array_8.length) {\n        v4 = v5 = v0 > 0;\n        if (v5) {\n            assert(v2 < array_8.length);\n            v4 = v6 = _exit[address(array_8[v2])];\n        }\n        if (!v4) {\n            v7 = v8 = !v0;\n            if (v8) {\n                assert(v2 < array_8.length);\n                v7 = v9 = !_exit[address(array_8[v2])];\n            }\n            if (v7) {\n                stor_10 = 2;\n                stor_f = stor_a;\n                assert(v2 < array_8.length);\n                _dividendsOf[address(array_8[v2])] += varg0;\n            }\n        } else {\n            assert(v2 < array_8.length);\n            assert(v0);\n            assert(10);\n            v10 = (5 + _exit[address(array_8[v2])] * 0x8ac7230489e80000 / v0) / 10 * varg0 / 0xde0b6b3a7640000;\n            stor_a = v10;\n            stor_f = v10;\n            assert(v2 < array_8.length);\n            _dividendsOf[address(array_8[v2])] += v10;\n            stor_10 = 1;\n        }\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x1589(uint256 varg0) private { \n    v0 = 0x3b9aca00 * (varg0 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000));\n    v1 = 0x3b9aca00 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    v0 = 0x53b(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x129a(18, 100, 15, varg0);\n    assert(v0 <= varg0);\n    v1 = 0x12df(varg0 - v0);\n    return v1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x1589(varg0);\n    v1 = 0x129a(18, 100, 10, v0);\n    assert(v1 <= v0);\n    return v0 - v1;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0x938();\n}\n\nfunction sellPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x1589(0xde0b6b3a7640000);\n        v1 = 0x129a(18, 100, 15, v0);\n        v2 = v3 = v0 - v1;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xafe(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = v1 = 0x1589(0xde0b6b3a7640000);\n        goto 0xaee0xbc1B0x3a5;\n    } else {\n        v0 = v2 = 0x3b9aca00;\n    }\n    return v0;\n}\n\nfunction setAdministrator(bytes32 varg0, bool varg1) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _administrators[varg0] = varg1 | ~0xff & _administrators[varg0];\n}\n\nfunction myTokens() public nonPayable { \n    return _exit[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_exit[msg.sender] > 0);\n    v0 = v1 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v0 = v2 = varg1 <= _exit[msg.sender];\n    }\n    require(v0);\n    v3 = 0x129a(18, 100, 5, varg1);\n    v4 = 0x129a(18, 100, 95, varg1);\n    assert(v3 <= _totalSupply);\n    _totalSupply = _totalSupply - v3;\n    assert(v3 <= _soldTokens);\n    _soldTokens = _soldTokens - v3;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(v4 + _exit[varg0] >= _exit[varg0]);\n    _exit[varg0] += v4;\n    v5 = 0x1589(v3);\n    0x1386(v5);\n    emit Transfer(msg.sender, varg0, v4);\n    return 1;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sellingWithdraw() public nonPayable { \n    require(_selingWithdrawBalance[msg.sender] > 0);\n    _selingWithdrawBalance[msg.sender] = 0;\n    v0 = msg.sender.call().value(_selingWithdrawBalance[msg.sender]).gas(!_selingWithdrawBalance[msg.sender] * 2300);\n    require(v0);\n    emit onSellingWithdraw(msg.sender, _selingWithdrawBalance[msg.sender]);\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x102b(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x102b(_exit[msg.sender]);\n    }\n    0x938();\n}\n\nfunction selingWithdrawBalance() public nonPayable { \n    return _selingWithdrawBalance[msg.sender];\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x53b(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xafe(1);\n    require(v0 > 0);\n    v1 = 0xafe(1);\n    v2 = 0x129a(18, 100, 10, v1);\n    v3 = 0x129a(18, 100, 90, v1);\n    v4 = 0x53b(0, v3);\n    _dividendsOf[msg.sender] = 0;\n    owner_4[msg.sender] = 0;\n    0x1386(v2);\n    emit onReinvestment(msg.sender, v1, v4);\n}\n\nfunction 0x53b(uint256 varg0, uint256 varg1) private { \n    stor_d = varg1;\n    v0 = v1 = 0;\n    while (v0 < array_8.length) {\n        assert(v0 < array_8.length);\n        if (address(array_8[v0]) != msg.sender) {\n            v0 = v0 + 1;\n        } else {\n            v0 = v2 = 1;\n            break;\n        }\n    }\n    if (!v0) {\n        stor_c += 1;\n        array_8.length = array_8.length + 1;\n        if (!array_8.length <= array_8.length + 1) {\n            v3 = v4 = array_8.length + 1 + keccak256(8);\n            while (keccak256(8) + array_8.length > v3) {\n                STORAGE[v3] = 0;\n                v3 += 1;\n            }\n            goto 0xf0f0x1621B0x5a1;\n        }\n        array_8[array_8.length] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & array_8[array_8.length];\n    }\n    v5 = 0x129a(18, 100, 85, varg1);\n    stor_e = v5;\n    v6 = 0x129a(18, 100, 85, varg1);\n    v7 = 0x12df(v6);\n    if (_totalSupply <= 0) {\n        _totalSupply = v7;\n    } else {\n        assert(v7 + _totalSupply >= _totalSupply);\n        _totalSupply += v7;\n    }\n    assert(v7 + _exit[msg.sender] >= _exit[msg.sender]);\n    _exit[msg.sender] += v7;\n    v8 = v9 = v7 > 0;\n    if (v9) {\n        assert(_totalSupply + v7 >= v7);\n        v8 = v10 = _totalSupply + v7 > _totalSupply;\n    }\n    require(v8);\n    v11 = !address(varg0);\n    v12 = v13 = address(varg0);\n    if (address(varg0)) {\n        v12 = v14 = address(varg0) != msg.sender;\n    }\n    if (v12) {\n        v15 = address(varg0);\n        v12 = v16 = _exit[v15] >= _stakingRequirement;\n    }\n    if (!v12) {\n        if (stor_c > 0) {\n            v17 = v18 = 1923;\n            v19 = v20 = 0x129a(18, 100, 15, varg1);\n        }\n    } else {\n        v21 = 0x129a(18, 100, 5, varg1);\n        v22 = address(varg0);\n        owner_4[v22] += v21;\n        v23 = 0x129a(18, 100, 5, varg1);\n        stor_12 += v23;\n        if (stor_c > 0) {\n            v17 = v24 = 1889;\n            v19 = v25 = 0x129a(18, 100, 10, varg1);\n        }\n    }\n    goto 0x783;\n    0x1386(v19);\n    emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v7);\n    _soldTokens += v7;\n    return v7;\n}\n\nfunction 0x938() private { \n    v0 = 0xafe(1);\n    require(v0 > 0);\n    v1 = 0xafe(1);\n    v2 = 0x129a(18, 100, 10, v1);\n    v3 = 0x129a(18, 100, 10, v1);\n    _dividendsOf[msg.sender] = 0;\n    owner_4[msg.sender] = 0;\n    v4 = 0x9e4f01bf4d6aa5c583bcb84462e32e8a5ce6195f.call().value(v3).gas(2300 * !v3);\n    require(v4);\n    v5 = 0xb0e9ff0c19b7147bfdeb81f0e1d3089efec4fbcd.call().value(v2).gas(2300 * !v2);\n    require(v5);\n    v6 = 0x129a(18, 100, 80, v1);\n    v7 = msg.sender.call().value(v6).gas(2300 * !v6);\n    require(v7);\n    emit onWithdraw(msg.sender, v1);\n    return ;\n}\n\nfunction 0xafe(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = _dividendsOf[msg.sender] + owner_4[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender];\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x5ed9ebfc == function_selector) {\n            soldTokens();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x89135ae9 == function_selector) {\n            setAdministrator(bytes32,bool);\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xcb4f6758 == function_selector) {\n            sellingWithdraw();\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xeba9f92d == function_selector) {\n            selingWithdrawBalance();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 04:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _stakingRequirement; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _selingWithdrawBalance; // STORAGE[0x6]\nuint256[] array_8; // STORAGE[0x8]\nuint256 _totalSupply; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 _soldTokens; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_10; // STORAGE[0x10]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0x14]\nuint8 _onlyAmbassadors; // STORAGE[0x15] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonSellingWithdraw(address, uint256);\nonTokenSell(address, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x102b(uint256 varg0) private { \n    require(_exit[msg.sender] > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v0 = 0x1589(varg0);\n    v1 = 0x129a(18, 100, 10, v0);\n    v2 = 0x129a(18, 100, 90, v0);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    assert(varg0 <= _soldTokens);\n    _soldTokens = _soldTokens - varg0;\n    _selingWithdrawBalance[msg.sender] += v2;\n    0x1386(v1);\n    emit onTokenSell(msg.sender, varg0);\n    return ;\n}\n\nfunction 0x129a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg1);\n    assert(10);\n    return (5 + varg2 * 10 ** (1 + varg0) / varg1) / 10 * varg3 / 0xde0b6b3a7640000;\n}\n\nfunction 0x12df(uint256 varg0) private { \n    v0 = v1 = 0xa70c3c40a64e6c51999090b65f67d9240000000000000 + (_totalSupply * 0x1812f9cf7920e2b66973e2000000000 + (0xde0b6b3a7640000 * _totalSupply ** 2 + varg0 * 0x59aedfc10d7279c5eed1401645400000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x33b2e3c9fd0803ce8000000 <= v0);\n    assert(0x3b9aca00);\n    return (v0 - 0x33b2e3c9fd0803ce8000000) / 0x3b9aca00 - _totalSupply;\n}\n\nfunction 0x1386(uint256 varg0) private { \n    stor_11 = varg0;\n    v0 = v1 = 0;\n    while (v0 < array_8.length) {\n        assert(v0 < array_8.length);\n        v0 += _exit[address(array_8[v0])];\n        v0 += 1;\n    }\n    v2 = v3 = 0;\n    while (v2 < array_8.length) {\n        v4 = v5 = v0 > 0;\n        if (v5) {\n            assert(v2 < array_8.length);\n            v4 = v6 = _exit[address(array_8[v2])];\n        }\n        if (!v4) {\n            v7 = v8 = !v0;\n            if (v8) {\n                assert(v2 < array_8.length);\n                v7 = v9 = !_exit[address(array_8[v2])];\n            }\n            if (v7) {\n                stor_10 = 2;\n                stor_f = stor_a;\n                assert(v2 < array_8.length);\n                _dividendsOf[address(array_8[v2])] += varg0;\n            }\n        } else {\n            assert(v2 < array_8.length);\n            assert(v0);\n            assert(10);\n            v10 = (5 + _exit[address(array_8[v2])] * 0x8ac7230489e80000 / v0) / 10 * varg0 / 0xde0b6b3a7640000;\n            stor_a = v10;\n            stor_f = v10;\n            assert(v2 < array_8.length);\n            _dividendsOf[address(array_8[v2])] += v10;\n            stor_10 = 1;\n        }\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x1589(uint256 varg0) private { \n    v0 = 0x3b9aca00 * (varg0 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000));\n    v1 = 0x3b9aca00 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    v0 = 0x53b(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x129a(18, 100, 15, varg0);\n    assert(v0 <= varg0);\n    v1 = 0x12df(varg0 - v0);\n    return v1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x1589(varg0);\n    v1 = 0x129a(18, 100, 10, v0);\n    assert(v1 <= v0);\n    return v0 - v1;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0x938();\n}\n\nfunction sellPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x1589(0xde0b6b3a7640000);\n        v1 = 0x129a(18, 100, 15, v0);\n        v2 = v3 = v0 - v1;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xafe(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = v1 = 0x1589(0xde0b6b3a7640000);\n        goto 0xaee0xbc1B0x3a5;\n    } else {\n        v0 = v2 = 0x3b9aca00;\n    }\n    return v0;\n}\n\nfunction setAdministrator(bytes32 varg0, bool varg1) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _administrators[varg0] = varg1 | ~0xff & _administrators[varg0];\n}\n\nfunction myTokens() public nonPayable { \n    return _exit[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_exit[msg.sender] > 0);\n    v0 = v1 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v0 = v2 = varg1 <= _exit[msg.sender];\n    }\n    require(v0);\n    v3 = 0x129a(18, 100, 5, varg1);\n    v4 = 0x129a(18, 100, 95, varg1);\n    assert(v3 <= _totalSupply);\n    _totalSupply = _totalSupply - v3;\n    assert(v3 <= _soldTokens);\n    _soldTokens = _soldTokens - v3;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(v4 + _exit[varg0] >= _exit[varg0]);\n    _exit[varg0] += v4;\n    v5 = 0x1589(v3);\n    0x1386(v5);\n    emit Transfer(msg.sender, varg0, v4);\n    return 1;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sellingWithdraw() public nonPayable { \n    require(_selingWithdrawBalance[msg.sender] > 0);\n    _selingWithdrawBalance[msg.sender] = 0;\n    v0 = msg.sender.call().value(_selingWithdrawBalance[msg.sender]).gas(!_selingWithdrawBalance[msg.sender] * 2300);\n    require(v0);\n    emit onSellingWithdraw(msg.sender, _selingWithdrawBalance[msg.sender]);\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x102b(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x102b(_exit[msg.sender]);\n    }\n    0x938();\n}\n\nfunction selingWithdrawBalance() public nonPayable { \n    return _selingWithdrawBalance[msg.sender];\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x53b(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xafe(1);\n    require(v0 > 0);\n    v1 = 0xafe(1);\n    v2 = 0x129a(18, 100, 10, v1);\n    v3 = 0x129a(18, 100, 90, v1);\n    v4 = 0x53b(0, v3);\n    _dividendsOf[msg.sender] = 0;\n    owner_4[msg.sender] = 0;\n    0x1386(v2);\n    emit onReinvestment(msg.sender, v1, v4);\n}\n\nfunction 0x53b(uint256 varg0, uint256 varg1) private { \n    stor_d = varg1;\n    v0 = v1 = 0;\n    while (v0 < array_8.length) {\n        assert(v0 < array_8.length);\n        if (address(array_8[v0]) != msg.sender) {\n            v0 = v0 + 1;\n        } else {\n            v0 = v2 = 1;\n            break;\n        }\n    }\n    if (!v0) {\n        stor_c += 1;\n        array_8.length = array_8.length + 1;\n        if (!array_8.length <= array_8.length + 1) {\n            v3 = v4 = array_8.length + 1 + keccak256(8);\n            while (keccak256(8) + array_8.length > v3) {\n                STORAGE[v3] = 0;\n                v3 += 1;\n            }\n            goto 0xf0f0x1621B0x5a1;\n        }\n        array_8[array_8.length] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & array_8[array_8.length];\n    }\n    v5 = 0x129a(18, 100, 85, varg1);\n    stor_e = v5;\n    v6 = 0x129a(18, 100, 85, varg1);\n    v7 = 0x12df(v6);\n    if (_totalSupply <= 0) {\n        _totalSupply = v7;\n    } else {\n        assert(v7 + _totalSupply >= _totalSupply);\n        _totalSupply += v7;\n    }\n    assert(v7 + _exit[msg.sender] >= _exit[msg.sender]);\n    _exit[msg.sender] += v7;\n    v8 = v9 = v7 > 0;\n    if (v9) {\n        assert(_totalSupply + v7 >= v7);\n        v8 = v10 = _totalSupply + v7 > _totalSupply;\n    }\n    require(v8);\n    v11 = !address(varg0);\n    v12 = v13 = address(varg0);\n    if (address(varg0)) {\n        v12 = v14 = address(varg0) != msg.sender;\n    }\n    if (v12) {\n        v15 = address(varg0);\n        v12 = v16 = _exit[v15] >= _stakingRequirement;\n    }\n    if (!v12) {\n        if (stor_c > 0) {\n            v17 = v18 = 1923;\n            v19 = v20 = 0x129a(18, 100, 15, varg1);\n        }\n    } else {\n        v21 = 0x129a(18, 100, 5, varg1);\n        v22 = address(varg0);\n        owner_4[v22] += v21;\n        v23 = 0x129a(18, 100, 5, varg1);\n        stor_12 += v23;\n        if (stor_c > 0) {\n            v17 = v24 = 1889;\n            v19 = v25 = 0x129a(18, 100, 10, varg1);\n        }\n    }\n    goto 0x783;\n    0x1386(v19);\n    emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v7);\n    _soldTokens += v7;\n    return v7;\n}\n\nfunction 0x938() private { \n    v0 = 0xafe(1);\n    require(v0 > 0);\n    v1 = 0xafe(1);\n    v2 = 0x129a(18, 100, 10, v1);\n    v3 = 0x129a(18, 100, 10, v1);\n    _dividendsOf[msg.sender] = 0;\n    owner_4[msg.sender] = 0;\n    v4 = 0x9e4f01bf4d6aa5c583bcb84462e32e8a5ce6195f.call().value(v3).gas(2300 * !v3);\n    require(v4);\n    v5 = 0xb0e9ff0c19b7147bfdeb81f0e1d3089efec4fbcd.call().value(v2).gas(2300 * !v2);\n    require(v5);\n    v6 = 0x129a(18, 100, 80, v1);\n    v7 = msg.sender.call().value(v6).gas(2300 * !v6);\n    require(v7);\n    emit onWithdraw(msg.sender, v1);\n    return ;\n}\n\nfunction 0xafe(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = _dividendsOf[msg.sender] + owner_4[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender];\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x5ed9ebfc == function_selector) {\n            soldTokens();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x89135ae9 == function_selector) {\n            setAdministrator(bytes32,bool);\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xcb4f6758 == function_selector) {\n            sellingWithdraw();\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xeba9f92d == function_selector) {\n            selingWithdrawBalance();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 04:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _stakingRequirement; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _selingWithdrawBalance; // STORAGE[0x6]\nuint256[] array_8; // STORAGE[0x8]\nuint256 _totalSupply; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 _soldTokens; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_10; // STORAGE[0x10]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0x14]\nuint8 _onlyAmbassadors; // STORAGE[0x15] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonSellingWithdraw(address, uint256);\nonTokenSell(address, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x102b(uint256 varg0) private { \n    require(_exit[msg.sender] > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v0 = 0x1589(varg0);\n    v1 = 0x129a(18, 100, 10, v0);\n    v2 = 0x129a(18, 100, 90, v0);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    assert(varg0 <= _soldTokens);\n    _soldTokens = _soldTokens - varg0;\n    _selingWithdrawBalance[msg.sender] += v2;\n    0x1386(v1);\n    emit onTokenSell(msg.sender, varg0);\n    return ;\n}\n\nfunction 0x129a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg1);\n    assert(10);\n    return (5 + varg2 * 10 ** (1 + varg0) / varg1) / 10 * varg3 / 0xde0b6b3a7640000;\n}\n\nfunction 0x12df(uint256 varg0) private { \n    v0 = v1 = 0xa70c3c40a64e6c51999090b65f67d9240000000000000 + (_totalSupply * 0x1812f9cf7920e2b66973e2000000000 + (0xde0b6b3a7640000 * _totalSupply ** 2 + varg0 * 0x59aedfc10d7279c5eed1401645400000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x33b2e3c9fd0803ce8000000 <= v0);\n    assert(0x3b9aca00);\n    return (v0 - 0x33b2e3c9fd0803ce8000000) / 0x3b9aca00 - _totalSupply;\n}\n\nfunction 0x1386(uint256 varg0) private { \n    stor_11 = varg0;\n    v0 = v1 = 0;\n    while (v0 < array_8.length) {\n        assert(v0 < array_8.length);\n        v0 += _exit[address(array_8[v0])];\n        v0 += 1;\n    }\n    v2 = v3 = 0;\n    while (v2 < array_8.length) {\n        v4 = v5 = v0 > 0;\n        if (v5) {\n            assert(v2 < array_8.length);\n            v4 = v6 = _exit[address(array_8[v2])];\n        }\n        if (!v4) {\n            v7 = v8 = !v0;\n            if (v8) {\n                assert(v2 < array_8.length);\n                v7 = v9 = !_exit[address(array_8[v2])];\n            }\n            if (v7) {\n                stor_10 = 2;\n                stor_f = stor_a;\n                assert(v2 < array_8.length);\n                _dividendsOf[address(array_8[v2])] += varg0;\n            }\n        } else {\n            assert(v2 < array_8.length);\n            assert(v0);\n            assert(10);\n            v10 = (5 + _exit[address(array_8[v2])] * 0x8ac7230489e80000 / v0) / 10 * varg0 / 0xde0b6b3a7640000;\n            stor_a = v10;\n            stor_f = v10;\n            assert(v2 < array_8.length);\n            _dividendsOf[address(array_8[v2])] += v10;\n            stor_10 = 1;\n        }\n        v2 += 1;\n    }\n    return ;\n}\n\nfunction 0x1589(uint256 varg0) private { \n    v0 = 0x3b9aca00 * (varg0 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000));\n    v1 = 0x3b9aca00 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    v0 = 0x53b(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x129a(18, 100, 15, varg0);\n    assert(v0 <= varg0);\n    v1 = 0x12df(varg0 - v0);\n    return v1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x1589(varg0);\n    v1 = 0x129a(18, 100, 10, v0);\n    assert(v1 <= v0);\n    return v0 - v1;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0x938();\n}\n\nfunction sellPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x1589(0xde0b6b3a7640000);\n        v1 = 0x129a(18, 100, 15, v0);\n        v2 = v3 = v0 - v1;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction soldTokens() public nonPayable { \n    return _soldTokens;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xafe(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = v1 = 0x1589(0xde0b6b3a7640000);\n        goto 0xaee0xbc1B0x3a5;\n    } else {\n        v0 = v2 = 0x3b9aca00;\n    }\n    return v0;\n}\n\nfunction setAdministrator(bytes32 varg0, bool varg1) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _administrators[varg0] = varg1 | ~0xff & _administrators[varg0];\n}\n\nfunction myTokens() public nonPayable { \n    return _exit[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_exit[msg.sender] > 0);\n    v0 = v1 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v0 = v2 = varg1 <= _exit[msg.sender];\n    }\n    require(v0);\n    v3 = 0x129a(18, 100, 5, varg1);\n    v4 = 0x129a(18, 100, 95, varg1);\n    assert(v3 <= _totalSupply);\n    _totalSupply = _totalSupply - v3;\n    assert(v3 <= _soldTokens);\n    _soldTokens = _soldTokens - v3;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(v4 + _exit[varg0] >= _exit[varg0]);\n    _exit[varg0] += v4;\n    v5 = 0x1589(v3);\n    0x1386(v5);\n    emit Transfer(msg.sender, varg0, v4);\n    return 1;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sellingWithdraw() public nonPayable { \n    require(_selingWithdrawBalance[msg.sender] > 0);\n    _selingWithdrawBalance[msg.sender] = 0;\n    v0 = msg.sender.call().value(_selingWithdrawBalance[msg.sender]).gas(!_selingWithdrawBalance[msg.sender] * 2300);\n    require(v0);\n    emit onSellingWithdraw(msg.sender, _selingWithdrawBalance[msg.sender]);\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x102b(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x102b(_exit[msg.sender]);\n    }\n    0x938();\n}\n\nfunction selingWithdrawBalance() public nonPayable { \n    return _selingWithdrawBalance[msg.sender];\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x53b(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xafe(1);\n    require(v0 > 0);\n    v1 = 0xafe(1);\n    v2 = 0x129a(18, 100, 10, v1);\n    v3 = 0x129a(18, 100, 90, v1);\n    v4 = 0x53b(0, v3);\n    _dividendsOf[msg.sender] = 0;\n    owner_4[msg.sender] = 0;\n    0x1386(v2);\n    emit onReinvestment(msg.sender, v1, v4);\n}\n\nfunction 0x53b(uint256 varg0, uint256 varg1) private { \n    stor_d = varg1;\n    v0 = v1 = 0;\n    while (v0 < array_8.length) {\n        assert(v0 < array_8.length);\n        if (address(array_8[v0]) != msg.sender) {\n            v0 = v0 + 1;\n        } else {\n            v0 = v2 = 1;\n            break;\n        }\n    }\n    if (!v0) {\n        stor_c += 1;\n        array_8.length = array_8.length + 1;\n        if (!array_8.length <= array_8.length + 1) {\n            v3 = v4 = array_8.length + 1 + keccak256(8);\n            while (keccak256(8) + array_8.length > v3) {\n                STORAGE[v3] = 0;\n                v3 += 1;\n            }\n            goto 0xf0f0x1621B0x5a1;\n        }\n        array_8[array_8.length] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & array_8[array_8.length];\n    }\n    v5 = 0x129a(18, 100, 85, varg1);\n    stor_e = v5;\n    v6 = 0x129a(18, 100, 85, varg1);\n    v7 = 0x12df(v6);\n    if (_totalSupply <= 0) {\n        _totalSupply = v7;\n    } else {\n        assert(v7 + _totalSupply >= _totalSupply);\n        _totalSupply += v7;\n    }\n    assert(v7 + _exit[msg.sender] >= _exit[msg.sender]);\n    _exit[msg.sender] += v7;\n    v8 = v9 = v7 > 0;\n    if (v9) {\n        assert(_totalSupply + v7 >= v7);\n        v8 = v10 = _totalSupply + v7 > _totalSupply;\n    }\n    require(v8);\n    v11 = !address(varg0);\n    v12 = v13 = address(varg0);\n    if (address(varg0)) {\n        v12 = v14 = address(varg0) != msg.sender;\n    }\n    if (v12) {\n        v15 = address(varg0);\n        v12 = v16 = _exit[v15] >= _stakingRequirement;\n    }\n    if (!v12) {\n        if (stor_c > 0) {\n            v17 = v18 = 1923;\n            v19 = v20 = 0x129a(18, 100, 15, varg1);\n        }\n    } else {\n        v21 = 0x129a(18, 100, 5, varg1);\n        v22 = address(varg0);\n        owner_4[v22] += v21;\n        v23 = 0x129a(18, 100, 5, varg1);\n        stor_12 += v23;\n        if (stor_c > 0) {\n            v17 = v24 = 1889;\n            v19 = v25 = 0x129a(18, 100, 10, varg1);\n        }\n    }\n    goto 0x783;\n    0x1386(v19);\n    emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v7);\n    _soldTokens += v7;\n    return v7;\n}\n\nfunction 0x938() private { \n    v0 = 0xafe(1);\n    require(v0 > 0);\n    v1 = 0xafe(1);\n    v2 = 0x129a(18, 100, 10, v1);\n    v3 = 0x129a(18, 100, 10, v1);\n    _dividendsOf[msg.sender] = 0;\n    owner_4[msg.sender] = 0;\n    v4 = 0x9e4f01bf4d6aa5c583bcb84462e32e8a5ce6195f.call().value(v3).gas(2300 * !v3);\n    require(v4);\n    v5 = 0xb0e9ff0c19b7147bfdeb81f0e1d3089efec4fbcd.call().value(v2).gas(2300 * !v2);\n    require(v5);\n    v6 = 0x129a(18, 100, 80, v1);\n    v7 = msg.sender.call().value(v6).gas(2300 * !v6);\n    require(v7);\n    emit onWithdraw(msg.sender, v1);\n    return ;\n}\n\nfunction 0xafe(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = _dividendsOf[msg.sender] + owner_4[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender];\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x5ed9ebfc == function_selector) {\n            soldTokens();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x89135ae9 == function_selector) {\n            setAdministrator(bytes32,bool);\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xcb4f6758 == function_selector) {\n            sellingWithdraw();\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xeba9f92d == function_selector) {\n            selingWithdrawBalance();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 24.251349687576294,
	"usage": {
		"completion_tokens": 335,
		"prompt_tokens": 5719,
		"total_tokens": 6054
	}
}