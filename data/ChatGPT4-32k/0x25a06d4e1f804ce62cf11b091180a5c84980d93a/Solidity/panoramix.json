{
	"address": "0x25a06d4e1f804ce62cf11b091180a5c84980d93a",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  name is array of uint256 at storage 0\n  symbol is array of uint256 at storage 1\n  stakingRequirement is uint256 at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint256 at storage 4\n  dividendsOf is mapping of uint256 at storage 5\n  selingWithdrawBalance is mapping of uint256 at storage 6\n  stor8 is array of address at storage 8\n  totalSupply is uint256 at storage 9\n  stor10 is uint256 at storage 10\n  soldTokens is uint256 at storage 11\n  stor12 is uint256 at storage 12\n  stor13 is uint256 at storage 13\n  stor14 is uint256 at storage 14\n  stor15 is uint256 at storage 15\n  stor16 is uint256 at storage 16\n  stor17 is uint256 at storage 17\n  stor18 is uint256 at storage 18\n  stor20 is mapping of uint8 at storage 20\n  onlyAmbassadors is uint8 at storage 21\n\ndef dividendsOf(address _customerAddress): # not payable\n  return dividendsOf[address(_customerAddress)]\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef onlyAmbassadors(): # not payable\n  return bool(onlyAmbassadors)\n\ndef administrators(bytes32 _param1): # not payable\n  return bool(stor20[_param1])\n\ndef stakingRequirement(): # not payable\n  return stakingRequirement\n\ndef soldTokens(): # not payable\n  return soldTokens\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef myTokens(): # not payable\n  return balanceOf[caller]\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef selingWithdrawBalance(): # not payable\n  return selingWithdrawBalance[caller]\n\n#\n#  Regular functions\n#\n\ndef disableInitialStage(): # not payable\n  require stor20[caller]\n  onlyAmbassadors = 0\n\ndef setStakingRequirement(uint256 _amountOfTokens): # not payable\n  require stor20[caller]\n  stakingRequirement = _amountOfTokens\n\ndef setName(string _name): # not payable\n  require stor20[caller]\n  name[] = Array(len=_name.length, data=_name[all])\n\ndef setAdministrator(bytes32 _identifier, bool _status): # not payable\n  require stor20[caller]\n  stor20[_identifier] = uint8(_status)\n\ndef setSymbol(string _symbol): # not payable\n  require stor20[caller]\n  symbol[] = Array(len=_symbol.length, data=_symbol[all])\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return (dividendsOf[caller] + stor4[caller])\n  return dividendsOf[caller]\n\ndef buyPrice(): # not payable\n  if not totalSupply:\n      return 10^9\n  require 1999999999999999999 * 10^9 <= 1000000000 * 10^18 * totalSupply + 10^18 / 10^18\n  return ((1000000000 * 10^18 * totalSupply + 10^18 / 10^18) - 1999999999999999999 * 10^9 / 10^18)\n\ndef sellPrice(): # not payable\n  if not totalSupply:\n      return 0\n  require 1999999999999999999 * 10^9 <= 1000000000 * 10^18 * totalSupply + 10^18 / 10^18\n  return (((1000000000 * 10^18 * totalSupply + 10^18 / 10^18) - 1999999999999999999 * 10^9 / 10^18) - (15 * 10^16 * (1000000000 * 10^18 * totalSupply + 10^18 / 10^18) - 1999999999999999999 * 10^9 / 10^18 / 10^18))\n\ndef sellingWithdraw(): # not payable\n  require selingWithdrawBalance[caller] > 0\n  selingWithdrawBalance[caller] = 0\n  call caller with:\n     value selingWithdrawBalance[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log onSellingWithdraw(\n        address customerAddress=selingWithdrawBalance[caller],\n        uint256 ethereumWithdrawn=caller)\n\ndef withdraw(): # not payable\n  require dividendsOf[caller] + stor4[caller] > 0\n  dividendsOf[caller] = 0\n  stor4[caller] = 0\n  call 0x9e4f01bf4d6aa5c583bcb84462e32e8a5ce6195f with:\n     value (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  call 0xb0e9ff0c19b7147bfdeb81f0e1d3089efec4fbcd with:\n     value (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  call caller with:\n     value (8 * 10^17 * dividendsOf[caller]) + (8 * 10^17 * stor4[caller]) / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log onWithdraw(\n        address customerAddress=(dividendsOf[caller] + stor4[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= totalSupply\n  require 10^9 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2 <= 10^9 * _tokensToSell * totalSupply + 10^18 / 10^18\n  require 10^17 * (10^9 * _tokensToSell * totalSupply + 10^18 / 10^18) - (10^9 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10^18 <= (10^9 * _tokensToSell * totalSupply + 10^18 / 10^18) - (10^9 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18\n  return (((10^9 * _tokensToSell * totalSupply + 10^18 / 10^18) - (10^9 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18) - (10^17 * (10^9 * _tokensToSell * totalSupply + 10^18 / 10^18) - (10^9 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10^18))\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  require 15 * 10^16 * _ethereumToSpend / 10^18 <= _ethereumToSpend\n  s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * _ethereumToSpend) + (-2000000000000000000000000000 * 10^18 * 15 * 10^16 * _ethereumToSpend / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n  t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * _ethereumToSpend) + (-2000000000000000000000000000 * 10^18 * 15 * 10^16 * _ethereumToSpend / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n  while s < t:\n      require s\n      s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * _ethereumToSpend) + (-2000000000000000000000000000 * 10^18 * 15 * 10^16 * _ethereumToSpend / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n      t = s\n      continue \n  if 1000000000 * 10^18 <= t:\n      return ((t - 1000000000 * 10^18 / 10^9) - totalSupply)\n  revert\n\ndef sell(uint256 amount): # not payable\n  require balanceOf[caller] > 0\n  require amount <= balanceOf[caller]\n  require 10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2 <= 10^9 * amount * totalSupply + 10^18 / 10^18\n  require amount <= totalSupply\n  totalSupply -= amount\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount <= soldTokens\n  soldTokens -= amount\n  selingWithdrawBalance[caller] += 25 * 10^13 * 3600 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18\n  stor17 = 10^17 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18\n  idx = 0\n  s = 0\n  while idx < stor8.length:\n      mem[0] = address(stor8[idx])\n      mem[32] = 3\n      idx = idx + 1\n      s = balanceOf[address(stor8[idx])] + s\n      continue \n  idx = 0\n  while idx < stor8.length:\n      if stor[_11] * stor8.length <= 0:\n          if not stor[_11] * stor8.length:\n              require idx < stor8.length\n              mem[0] = address(stor8[idx])\n              mem[32] = 3\n              if not balanceOf[address(stor8[idx])]:\n                  stor16 = 2\n                  stor15 = stor10\n                  require idx < stor8.length\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 5\n                  dividendsOf[address(stor8[idx])] += 10^17 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18\n      else:\n          require idx < stor8.length\n          mem[0] = address(stor8[idx])\n          mem[32] = 3\n          if balanceOf[address(stor8[idx])]:\n              require idx < stor8.length\n              require stor[_11] * stor8.length\n              stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_11] * stor8.length) + 5 / 10 * 10^17 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18 / 10^18\n              stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_11] * stor8.length) + 5 / 10 * 10^17 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18 / 10^18\n              require idx < stor8.length\n              mem[0] = address(stor8[idx])\n              mem[32] = 5\n              dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_11] * stor8.length) + 5 / 10 * 10^17 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18 / 10^18\n              stor16 = 1\n          else:\n              if not stor[_11] * stor8.length:\n                  require idx < stor8.length\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  if not balanceOf[address(stor8[idx])]:\n                      stor16 = 2\n                      stor15 = stor10\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 5\n                      dividendsOf[address(stor8[idx])] += 10^17 * (10^9 * amount * totalSupply + 10^18 / 10^18) - (10^9 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10^18\n      idx = idx + 1\n      continue \n  log onTokenSell(\n        address customerAddress=amount,\n        uint256 tokensBurned=caller)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require balanceOf[caller] > 0\n  require not onlyAmbassadors\n  require amount <= balanceOf[caller]\n  require 5 * 10^16 * amount / 10^18 <= totalSupply\n  totalSupply -= 5 * 10^16 * amount / 10^18\n  require 5 * 10^16 * amount / 10^18 <= soldTokens\n  soldTokens -= 5 * 10^16 * amount / 10^18\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require (95 * 10^16 * amount / 10^18) + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = (95 * 10^16 * amount / 10^18) + balanceOf[recipient]\n  require 10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2 <= 10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18\n  stor17 = (10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18) - (10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2) / 10^18\n  idx = 0\n  s = 0\n  while idx < stor8.length:\n      mem[0] = address(stor8[idx])\n      mem[32] = 3\n      idx = idx + 1\n      s = balanceOf[address(stor8[idx])] + s\n      continue \n  idx = 0\n  while idx < stor8.length:\n      if stor[_14] * stor8.length <= 0:\n          if not stor[_14] * stor8.length:\n              require idx < stor8.length\n              mem[0] = address(stor8[idx])\n              mem[32] = 3\n              if not balanceOf[address(stor8[idx])]:\n                  stor16 = 2\n                  stor15 = stor10\n                  require idx < stor8.length\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 5\n                  dividendsOf[address(stor8[idx])] += (10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18) - (10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2) / 10^18\n      else:\n          require idx < stor8.length\n          mem[0] = address(stor8[idx])\n          mem[32] = 3\n          if balanceOf[address(stor8[idx])]:\n              require idx < stor8.length\n              require stor[_14] * stor8.length\n              stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_14] * stor8.length) + 5 / 10 * (10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18) - (10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2) / 10^18 / 10^18\n              stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_14] * stor8.length) + 5 / 10 * (10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18) - (10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2) / 10^18 / 10^18\n              require idx < stor8.length\n              mem[0] = address(stor8[idx])\n              mem[32] = 5\n              dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_14] * stor8.length) + 5 / 10 * (10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18) - (10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2) / 10^18 / 10^18\n              stor16 = 1\n          else:\n              if not stor[_14] * stor8.length:\n                  require idx < stor8.length\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  if not balanceOf[address(stor8[idx])]:\n                      stor16 = 2\n                      stor15 = stor10\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 5\n                      dividendsOf[address(stor8[idx])] += (10^9 * 5 * 10^16 * amount / 10^18 * totalSupply + 10^18 / 10^18) - (10^9 * ((5 * 10^16 * amount / 10^18) + 10^18)^2 + -(5 * 10^16 * amount / 10^18) - 10^18 / 10^18 / 2) / 10^18\n      idx = idx + 1\n      continue \n  log Transfer(\n        address from=(95 * 10^16 * amount / 10^18),\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef exit(): # not payable\n  if balanceOf[caller] > 0:\n      require balanceOf[caller] > 0\n      require balanceOf[caller] <= balanceOf[caller]\n      require 10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2 <= 10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18\n      require balanceOf[caller] <= totalSupply\n      totalSupply -= balanceOf[caller]\n      require balanceOf[caller] <= balanceOf[caller]\n      balanceOf[caller] = 0\n      require balanceOf[caller] <= soldTokens\n      soldTokens -= balanceOf[caller]\n      selingWithdrawBalance[caller] += 25 * 10^13 * 3600 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18\n      stor17 = 10^17 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18\n      idx = 0\n      s = 0\n      while idx < stor8.length:\n          mem[0] = address(stor8[idx])\n          mem[32] = 3\n          idx = idx + 1\n          s = balanceOf[address(stor8[idx])] + s\n          continue \n      idx = 0\n      while idx < stor8.length:\n          if stor[_40] * stor8.length <= 0:\n              if not stor[_40] * stor8.length:\n                  require idx < stor8.length\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  if not balanceOf[address(stor8[idx])]:\n                      stor16 = 2\n                      stor15 = stor10\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 5\n                      dividendsOf[address(stor8[idx])] += 10^17 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18\n          else:\n              require idx < stor8.length\n              mem[0] = address(stor8[idx])\n              mem[32] = 3\n              if balanceOf[address(stor8[idx])]:\n                  require idx < stor8.length\n                  require stor[_40] * stor8.length\n                  stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_40] * stor8.length) + 5 / 10 * 10^17 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18 / 10^18\n                  stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_40] * stor8.length) + 5 / 10 * 10^17 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18 / 10^18\n                  require idx < stor8.length\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 5\n                  dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_40] * stor8.length) + 5 / 10 * 10^17 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18 / 10^18\n                  stor16 = 1\n              else:\n                  if not stor[_40] * stor8.length:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if not balanceOf[address(stor8[idx])]:\n                          stor16 = 2\n                          stor15 = stor10\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += 10^17 * (10^9 * balanceOf[caller] * totalSupply + 10^18 / 10^18) - (10^9 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 / 10^18\n          idx = idx + 1\n          continue \n      log onTokenSell(\n            address customerAddress=balanceOf[caller],\n            uint256 tokensBurned=caller)\n  require dividendsOf[caller] + stor4[caller] > 0\n  dividendsOf[caller] = 0\n  stor4[caller] = 0\n  call 0x9e4f01bf4d6aa5c583bcb84462e32e8a5ce6195f with:\n     value (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  call 0xb0e9ff0c19b7147bfdeb81f0e1d3089efec4fbcd with:\n     value (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  call caller with:\n     value (8 * 10^17 * dividendsOf[caller]) + (8 * 10^17 * stor4[caller]) / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log onWithdraw(\n        address customerAddress=(dividendsOf[caller] + stor4[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef _fallback(?) payable: # default function\n  stor13 = call.value\n  idx = 0\n  while idx < stor8.length:\n      mem[0] = 8\n      if address(stor8[idx]) != caller:\n          idx = idx + 1\n          continue \n      stor14 = 85 * 10^16 * call.value / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_159] * stor8.length <= 0:\n                      if not stor[_159] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_159] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_159] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_159] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_159] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_159] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  idx = idx + 1\n                  continue \n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_161] * stor8.length <= 0:\n                      if not stor[_161] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_161] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_161] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_161] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_161] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_161] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  idx = idx + 1\n                  continue \n      log onTokenPurchase(\n            address customerAddress=call.value,\n            uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n            uint256 tokensMinted=caller,\n            address referredBy=0)\n      soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n      stop\n  stor12++\n  stor8.length++\n  if not stor8.length > stor8.length + 1:\n      address(stor8[stor8.length]) = caller\n      stor14 = 85 * 10^16 * call.value / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_155] * stor8.length <= 0:\n                      if not stor[_155] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_155] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_155] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_155] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_155] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_155] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  idx = idx + 1\n                  continue \n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_157] * stor8.length <= 0:\n                      if not stor[_157] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_157] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_157] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_157] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_157] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_157] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  idx = idx + 1\n                  continue \n  else:\n      idx = stor8.length + 1\n      while stor8.length > idx:\n          uint256(stor8[idx]) = 0\n          idx = idx + 1\n          continue \n      address(stor8[stor8.length]) = caller\n      stor14 = 85 * 10^16 * call.value / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _247 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_247] * stor8.length <= 0:\n                      if not stor[_247] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_247] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_247] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_247] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_247] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_247] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  idx = idx + 1\n                  continue \n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _249 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_249] * stor8.length <= 0:\n                      if not stor[_249] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_249] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_249] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_249] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_249] * stor8.length) + 5 / 10 * 15 * 10^16 * call.value / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_249] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  idx = idx + 1\n                  continue \n  log onTokenPurchase(\n        address customerAddress=call.value,\n        uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n\ndef buy(address _referredBy) payable: \n  stor13 = call.value\n  idx = 0\n  while idx < stor8.length:\n      mem[0] = 8\n      if address(stor8[idx]) != caller:\n          idx = idx + 1\n          continue \n      stor14 = 85 * 10^16 * call.value / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if not _referredBy:\n              if stor12 > 0:\n                  stor17 = 15 * 10^16 * call.value / 10^18\n                  idx = 0\n                  s = 0\n                  while idx < stor8.length:\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      idx = idx + 1\n                      s = balanceOf[address(stor8[idx])] + s\n                      continue \n                  idx = 0\n                  while idx < stor8.length:\n                      if stor[_819] * stor8.length > 0:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              require idx < stor8.length\n                              require stor[_819] * stor8.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if stor[_819] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                      else:\n                          if stor[_819] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              idx = idx + 1\n                              continue \n                          stor16 = 2\n                          stor15 = stor10\n                          require idx < stor8.length\n                          dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if _referredBy == caller:\n                  if stor12 > 0:\n                      stor17 = 15 * 10^16 * call.value / 10^18\n                      idx = 0\n                      s = 0\n                      while idx < stor8.length:\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          idx = idx + 1\n                          s = balanceOf[address(stor8[idx])] + s\n                          continue \n                      idx = 0\n                      while idx < stor8.length:\n                          if stor[_821] * stor8.length > 0:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  require idx < stor8.length\n                                  require stor[_821] * stor8.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor[_821] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                          else:\n                              if stor[_821] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  idx = idx + 1\n                                  continue \n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if balanceOf[address(_referredBy)] < stakingRequirement:\n                      if stor12 > 0:\n                          stor17 = 15 * 10^16 * call.value / 10^18\n                          idx = 0\n                          s = 0\n                          while idx < stor8.length:\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              idx = idx + 1\n                              s = balanceOf[address(stor8[idx])] + s\n                              continue \n                          idx = 0\n                          while idx < stor8.length:\n                              if stor[_823] * stor8.length > 0:\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      require idx < stor8.length\n                                      require stor[_823] * stor8.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if stor[_823] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                              else:\n                                  if stor[_823] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      idx = idx + 1\n                                      continue \n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      stor4[address(_referredBy)] += 5 * 10^16 * call.value / 10^18\n                      stor18 += 5 * 10^16 * call.value / 10^18\n                      if stor12 > 0:\n                          stor17 = 10^17 * call.value / 10^18\n                          idx = 0\n                          s = 0\n                          while idx < stor8.length:\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              idx = idx + 1\n                              s = balanceOf[address(stor8[idx])] + s\n                              continue \n                          idx = 0\n                          while idx < stor8.length:\n                              if stor[_825] * stor8.length > 0:\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      require idx < stor8.length\n                                      require stor[_825] * stor8.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if stor[_825] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                              else:\n                                  if stor[_825] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      idx = idx + 1\n                                      continue \n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  dividendsOf[address(stor8[idx])] += 10^17 * call.value / 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if not _referredBy:\n              if stor12 > 0:\n                  stor17 = 15 * 10^16 * call.value / 10^18\n                  idx = 0\n                  s = 0\n                  while idx < stor8.length:\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      idx = idx + 1\n                      s = balanceOf[address(stor8[idx])] + s\n                      continue \n                  idx = 0\n                  while idx < stor8.length:\n                      if stor[_827] * stor8.length > 0:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              require idx < stor8.length\n                              require stor[_827] * stor8.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if stor[_827] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                      else:\n                          if stor[_827] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              idx = idx + 1\n                              continue \n                          stor16 = 2\n                          stor15 = stor10\n                          require idx < stor8.length\n                          dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if _referredBy == caller:\n                  if stor12 > 0:\n                      stor17 = 15 * 10^16 * call.value / 10^18\n                      idx = 0\n                      s = 0\n                      while idx < stor8.length:\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          idx = idx + 1\n                          s = balanceOf[address(stor8[idx])] + s\n                          continue \n                      idx = 0\n                      while idx < stor8.length:\n                          if stor[_829] * stor8.length > 0:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  require idx < stor8.length\n                                  require stor[_829] * stor8.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor[_829] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                          else:\n                              if stor[_829] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  idx = idx + 1\n                                  continue \n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if balanceOf[address(_referredBy)] < stakingRequirement:\n                      if stor12 > 0:\n                          stor17 = 15 * 10^16 * call.value / 10^18\n                          idx = 0\n                          s = 0\n                          while idx < stor8.length:\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              idx = idx + 1\n                              s = balanceOf[address(stor8[idx])] + s\n                              continue \n                          idx = 0\n                          while idx < stor8.length:\n                              if stor[_831] * stor8.length > 0:\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      require idx < stor8.length\n                                      require stor[_831] * stor8.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if stor[_831] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                              else:\n                                  if stor[_831] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      idx = idx + 1\n                                      continue \n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      stor4[address(_referredBy)] += 5 * 10^16 * call.value / 10^18\n                      stor18 += 5 * 10^16 * call.value / 10^18\n                      if stor12 > 0:\n                          stor17 = 10^17 * call.value / 10^18\n                          idx = 0\n                          s = 0\n                          while idx < stor8.length:\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              idx = idx + 1\n                              s = balanceOf[address(stor8[idx])] + s\n                              continue \n                          idx = 0\n                          while idx < stor8.length:\n                              if stor[_833] * stor8.length > 0:\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      require idx < stor8.length\n                                      require stor[_833] * stor8.length\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if stor[_833] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                              else:\n                                  if stor[_833] * stor8.length:\n                                      idx = idx + 1\n                                      continue \n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 3\n                                  if balanceOf[address(stor8[idx])]:\n                                      idx = idx + 1\n                                      continue \n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  dividendsOf[address(stor8[idx])] += 10^17 * call.value / 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      log onTokenPurchase(\n            address customerAddress=call.value,\n            uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n            uint256 tokensMinted=caller,\n            address referredBy=_referredBy)\n      soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n      return 0\n  stor12++\n  stor8.length++\n  if not stor8.length <= stor8.length + 1:\n      idx = stor8.length + 1\n      while stor8.length > idx:\n          uint256(stor8[idx]) = 0\n          idx = idx + 1\n          continue \n      address(stor8[stor8.length]) = caller\n      stor14 = 85 * 10^16 * call.value / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n      require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n      balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n      require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n      require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n      require t - 1000000000 * 10^18 / 10^9 > totalSupply\n      if not _referredBy:\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=call.value,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=_referredBy)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              return 0\n          stor17 = 15 * 10^16 * call.value / 10^18\n          idx = 0\n          s = 0\n          while idx < stor8.length:\n              mem[0] = address(stor8[idx])\n              mem[32] = 3\n              idx = idx + 1\n              s = balanceOf[address(stor8[idx])] + s\n              continue \n      else:\n          if _referredBy == caller:\n              if stor12 <= 0:\n                  log onTokenPurchase(\n                        address customerAddress=call.value,\n                        uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                        uint256 tokensMinted=caller,\n                        address referredBy=_referredBy)\n                  soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n                  return 0\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n          else:\n              if balanceOf[address(_referredBy)] < stakingRequirement:\n                  if stor12 <= 0:\n                      log onTokenPurchase(\n                            address customerAddress=call.value,\n                            uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                            uint256 tokensMinted=caller,\n                            address referredBy=_referredBy)\n                      soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n                      return 0\n                  stor17 = 15 * 10^16 * call.value / 10^18\n                  idx = 0\n                  s = 0\n                  while idx < stor8.length:\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      idx = idx + 1\n                      s = balanceOf[address(stor8[idx])] + s\n                      continue \n              else:\n                  stor4[address(_referredBy)] += 5 * 10^16 * call.value / 10^18\n                  stor18 += 5 * 10^16 * call.value / 10^18\n                  if stor12 <= 0:\n                      log onTokenPurchase(\n                            address customerAddress=call.value,\n                            uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                            uint256 tokensMinted=caller,\n                            address referredBy=_referredBy)\n                      soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n                      return 0\n                  stor17 = 10^17 * call.value / 10^18\n                  idx = 0\n                  s = 0\n                  while idx < stor8.length:\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      idx = idx + 1\n                      s = balanceOf[address(stor8[idx])] + s\n                      continue \n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  address(stor8[stor8.length]) = caller\n  stor14 = 85 * 10^16 * call.value / 10^18\n  s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n  t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n  while s < t:\n      require s\n      s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * call.value / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n      t = s\n      continue \n  require 1000000000 * 10^18 <= t\n  if totalSupply <= 0:\n      totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n      require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n      balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n      require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n      require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n      require t - 1000000000 * 10^18 / 10^9 > totalSupply\n      if not _referredBy:\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_803] * stor8.length > 0:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_803] * stor8.length\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor[_803] * stor8.length:\n                          idx = idx + 1\n                          continue \n                      require idx < stor8.length\n                  else:\n                      if stor[_803] * stor8.length:\n                          idx = idx + 1\n                          continue \n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          idx = idx + 1\n                          continue \n                      stor16 = 2\n                      stor15 = stor10\n                      require idx < stor8.length\n                      dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if _referredBy == caller:\n              if stor12 > 0:\n                  stor17 = 15 * 10^16 * call.value / 10^18\n                  idx = 0\n                  s = 0\n                  while idx < stor8.length:\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      idx = idx + 1\n                      s = balanceOf[address(stor8[idx])] + s\n                      continue \n                  idx = 0\n                  while idx < stor8.length:\n                      if stor[_805] * stor8.length > 0:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              require idx < stor8.length\n                              require stor[_805] * stor8.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if stor[_805] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                      else:\n                          if stor[_805] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              idx = idx + 1\n                              continue \n                          stor16 = 2\n                          stor15 = stor10\n                          require idx < stor8.length\n                          dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if balanceOf[address(_referredBy)] < stakingRequirement:\n                  if stor12 > 0:\n                      stor17 = 15 * 10^16 * call.value / 10^18\n                      idx = 0\n                      s = 0\n                      while idx < stor8.length:\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          idx = idx + 1\n                          s = balanceOf[address(stor8[idx])] + s\n                          continue \n                      idx = 0\n                      while idx < stor8.length:\n                          if stor[_807] * stor8.length > 0:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  require idx < stor8.length\n                                  require stor[_807] * stor8.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor[_807] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                          else:\n                              if stor[_807] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  idx = idx + 1\n                                  continue \n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  stor4[address(_referredBy)] += 5 * 10^16 * call.value / 10^18\n                  stor18 += 5 * 10^16 * call.value / 10^18\n                  if stor12 > 0:\n                      stor17 = 10^17 * call.value / 10^18\n                      idx = 0\n                      s = 0\n                      while idx < stor8.length:\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          idx = idx + 1\n                          s = balanceOf[address(stor8[idx])] + s\n                          continue \n                      idx = 0\n                      while idx < stor8.length:\n                          if stor[_809] * stor8.length > 0:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  require idx < stor8.length\n                                  require stor[_809] * stor8.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor[_809] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                          else:\n                              if stor[_809] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  idx = idx + 1\n                                  continue \n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              dividendsOf[address(stor8[idx])] += 10^17 * call.value / 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n      totalSupply = t - 1000000000 * 10^18 / 10^9\n      require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n      balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n      require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n      require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n      require t - 1000000000 * 10^18 / 10^9 > totalSupply\n      if not _referredBy:\n          if stor12 > 0:\n              stor17 = 15 * 10^16 * call.value / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_811] * stor8.length > 0:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_811] * stor8.length\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor[_811] * stor8.length:\n                          idx = idx + 1\n                          continue \n                      require idx < stor8.length\n                  else:\n                      if stor[_811] * stor8.length:\n                          idx = idx + 1\n                          continue \n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          idx = idx + 1\n                          continue \n                      stor16 = 2\n                      stor15 = stor10\n                      require idx < stor8.length\n                      dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if _referredBy == caller:\n              if stor12 > 0:\n                  stor17 = 15 * 10^16 * call.value / 10^18\n                  idx = 0\n                  s = 0\n                  while idx < stor8.length:\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      idx = idx + 1\n                      s = balanceOf[address(stor8[idx])] + s\n                      continue \n                  idx = 0\n                  while idx < stor8.length:\n                      if stor[_813] * stor8.length > 0:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              require idx < stor8.length\n                              require stor[_813] * stor8.length\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if stor[_813] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                      else:\n                          if stor[_813] * stor8.length:\n                              idx = idx + 1\n                              continue \n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if balanceOf[address(stor8[idx])]:\n                              idx = idx + 1\n                              continue \n                          stor16 = 2\n                          stor15 = stor10\n                          require idx < stor8.length\n                          dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if balanceOf[address(_referredBy)] < stakingRequirement:\n                  if stor12 > 0:\n                      stor17 = 15 * 10^16 * call.value / 10^18\n                      idx = 0\n                      s = 0\n                      while idx < stor8.length:\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          idx = idx + 1\n                          s = balanceOf[address(stor8[idx])] + s\n                          continue \n                      idx = 0\n                      while idx < stor8.length:\n                          if stor[_815] * stor8.length > 0:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  require idx < stor8.length\n                                  require stor[_815] * stor8.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor[_815] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                          else:\n                              if stor[_815] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  idx = idx + 1\n                                  continue \n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * call.value / 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  stor4[address(_referredBy)] += 5 * 10^16 * call.value / 10^18\n                  stor18 += 5 * 10^16 * call.value / 10^18\n                  if stor12 > 0:\n                      stor17 = 10^17 * call.value / 10^18\n                      idx = 0\n                      s = 0\n                      while idx < stor8.length:\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          idx = idx + 1\n                          s = balanceOf[address(stor8[idx])] + s\n                          continue \n                      idx = 0\n                      while idx < stor8.length:\n                          if stor[_817] * stor8.length > 0:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  require idx < stor8.length\n                                  require stor[_817] * stor8.length\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if stor[_817] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                          else:\n                              if stor[_817] * stor8.length:\n                                  idx = idx + 1\n                                  continue \n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if balanceOf[address(stor8[idx])]:\n                                  idx = idx + 1\n                                  continue \n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              dividendsOf[address(stor8[idx])] += 10^17 * call.value / 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  log onTokenPurchase(\n        address customerAddress=call.value,\n        uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n        uint256 tokensMinted=caller,\n        address referredBy=_referredBy)\n  soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n  return 0\n\ndef reinvest(): # not payable\n  require dividendsOf[caller] + stor4[caller] > 0\n  stor13 = (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18\n  idx = 0\n  while idx < stor8.length:\n      mem[0] = 8\n      if address(stor8[idx]) != caller:\n          idx = idx + 1\n          continue \n      stor14 = 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_347] * stor8.length <= 0:\n                      if not stor[_347] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_347] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_347] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_347] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_347] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_347] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n          else:\n              stor17 = 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_349] * stor8.length <= 0:\n                      if not stor[_349] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_349] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_349] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_349] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_349] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_349] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  idx = idx + 1\n                  continue \n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _779 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_779] * stor8.length <= 0:\n                      if not stor[_779] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_779] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_779] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_779] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_779] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_779] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_351] * stor8.length <= 0:\n                      if not stor[_351] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_351] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_351] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_351] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_351] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_351] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n          else:\n              stor17 = 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_353] * stor8.length <= 0:\n                      if not stor[_353] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_353] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_353] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_353] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_353] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_353] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  idx = idx + 1\n                  continue \n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _781 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_781] * stor8.length <= 0:\n                      if not stor[_781] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_781] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_781] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_781] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_781] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_781] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n      log onReinvestment(\n            address customerAddress=dividendsOf[caller] + stor4[caller],\n            uint256 ethereumReinvested=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n            uint256 tokensMinted=caller)\n      stop\n  stor12++\n  stor8.length++\n  if not stor8.length > stor8.length + 1:\n      address(stor8[stor8.length]) = caller\n      stor14 = 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_339] * stor8.length <= 0:\n                      if not stor[_339] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_339] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_339] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_339] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_339] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_339] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n          else:\n              stor17 = 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_341] * stor8.length <= 0:\n                      if not stor[_341] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_341] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_341] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_341] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_341] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_341] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  idx = idx + 1\n                  continue \n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _767 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_767] * stor8.length <= 0:\n                      if not stor[_767] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_767] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_767] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_767] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_767] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_767] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_343] * stor8.length <= 0:\n                      if not stor[_343] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_343] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_343] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_343] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_343] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_343] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n          else:\n              stor17 = 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_345] * stor8.length <= 0:\n                      if not stor[_345] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_345] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_345] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_345] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_345] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_345] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  idx = idx + 1\n                  continue \n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _769 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_769] * stor8.length <= 0:\n                      if not stor[_769] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_769] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_769] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_769] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_769] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_769] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n  else:\n      idx = stor8.length + 1\n      while stor8.length > idx:\n          uint256(stor8[idx]) = 0\n          idx = idx + 1\n          continue \n      address(stor8[stor8.length]) = caller\n      stor14 = 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n      s = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000001 / 2\n      t = (2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000 * 10^18 * totalSupply) + (10^18 * totalSupply^2) + (0x59aedfc10d7279c5eed1401645400000000000 * 85 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18) + 0xa70c3c40a64e6c51999090b65f67d9240000000000000 / s) + s / 2\n          t = s\n          continue \n      require 1000000000 * 10^18 <= t\n      if totalSupply <= 0:\n          totalSupply = (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _543 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_543] * stor8.length <= 0:\n                      if not stor[_543] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_543] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_543] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_543] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_543] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_543] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n          else:\n              stor17 = 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _545 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_545] * stor8.length <= 0:\n                      if not stor[_545] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_545] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_545] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_545] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_545] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_545] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  idx = idx + 1\n                  continue \n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _919 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_919] * stor8.length <= 0:\n                      if not stor[_919] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_919] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_919] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_919] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_919] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_919] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n      else:\n          require t - 1000000000 * 10^18 / 10^9 >= totalSupply\n          totalSupply = t - 1000000000 * 10^18 / 10^9\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 1000000000 * 10^18 / 10^9) - totalSupply + balanceOf[caller]\n          require (t - 1000000000 * 10^18 / 10^9) - totalSupply > 0\n          require t - 1000000000 * 10^18 / 10^9 >= (t - 1000000000 * 10^18 / 10^9) - totalSupply\n          require t - 1000000000 * 10^18 / 10^9 > totalSupply\n          if stor12 <= 0:\n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _547 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_547] * stor8.length <= 0:\n                      if not stor[_547] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_547] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_547] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_547] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_547] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_547] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n          else:\n              stor17 = 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _549 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_549] * stor8.length <= 0:\n                      if not stor[_549] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_549] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_549] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_549] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_549] * stor8.length) + 5 / 10 * 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_549] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += 15 * 10^16 * (25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18 / 10^18\n                  idx = idx + 1\n                  continue \n              log onTokenPurchase(\n                    address customerAddress=(25 * 10^13 * 3600 * dividendsOf[caller]) + (25 * 10^13 * 3600 * stor4[caller]) / 10^18,\n                    uint256 incomingEthereum=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n                    uint256 tokensMinted=caller,\n                    address referredBy=0)\n              soldTokens = (t - 1000000000 * 10^18 / 10^9) - totalSupply + soldTokens\n              dividendsOf[caller] = 0\n              stor4[caller] = 0\n              stor17 = (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n              idx = 0\n              s = 0\n              while idx < stor8.length:\n                  mem[0] = address(stor8[idx])\n                  mem[32] = 3\n                  _921 = sha3(address(stor8[idx]), 3)\n                  idx = idx + 1\n                  s = balanceOf[address(stor8[idx])] + s\n                  continue \n              idx = 0\n              while idx < stor8.length:\n                  if stor[_921] * stor8.length <= 0:\n                      if not stor[_921] * stor8.length:\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 3\n                          if not balanceOf[address(stor8[idx])]:\n                              stor16 = 2\n                              stor15 = stor10\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 5\n                              dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  else:\n                      require idx < stor8.length\n                      mem[0] = address(stor8[idx])\n                      mem[32] = 3\n                      if balanceOf[address(stor8[idx])]:\n                          require idx < stor8.length\n                          require stor[_921] * stor8.length\n                          stor10 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_921] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor15 = (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_921] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          require idx < stor8.length\n                          mem[0] = address(stor8[idx])\n                          mem[32] = 5\n                          dividendsOf[address(stor8[idx])] += (10 * 10^18 * balanceOf[address(stor8[idx])] / stor[_921] * stor8.length) + 5 / 10 * (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18 / 10^18\n                          stor16 = 1\n                      else:\n                          if not stor[_921] * stor8.length:\n                              require idx < stor8.length\n                              mem[0] = address(stor8[idx])\n                              mem[32] = 3\n                              if not balanceOf[address(stor8[idx])]:\n                                  stor16 = 2\n                                  stor15 = stor10\n                                  require idx < stor8.length\n                                  mem[0] = address(stor8[idx])\n                                  mem[32] = 5\n                                  dividendsOf[address(stor8[idx])] += (10^17 * dividendsOf[caller]) + (10^17 * stor4[caller]) / 10^18\n                  idx = idx + 1\n                  continue \n  log onReinvestment(\n        address customerAddress=dividendsOf[caller] + stor4[caller],\n        uint256 ethereumReinvested=(t - 1000000000 * 10^18 / 10^9) - totalSupply,\n        uint256 tokensMinted=caller)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 42110 tokens. Please reduce the length of the messages."
}