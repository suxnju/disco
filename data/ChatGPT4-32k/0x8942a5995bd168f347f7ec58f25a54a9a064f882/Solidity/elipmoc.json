{
	"address": "0x8942a5995bd168f347f7ec58f25a54a9a064f882",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sorry, but it seems there is a misunderstanding. The provided \"decompiled code\" is actually an assembly code, and it is not feasible to convert it directly back to Solidity. Decompiled code is typically used for understanding the logic of a compiled contract but it is not typically converted back into the high-level language. It's also important to note that the decompilation process is not perfect and may not fully or correctly represent the original code. \n\nAdditionally, the code you've provided also seems to be incomplete, as it contains some placeholders and unexplained variables (like `(?).length` and `varg0`). If you have an original Solidity code or more detailed information about the contract's functionality, I could help you write or modify a Solidity contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701455950,
	"id": "chatcmpl-8R2hqFeO3GY13bkFqULzCJTijrZsn",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 10:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256[] _name; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalContractBalance; // STORAGE[0x6]\nuint256 _buyingPrice; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _checkGameListed; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _getSuperReferrerRate; // STORAGE[0x9]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nonSellEvent(address, uint256);\nonAccountMovedIn(address, address, uint256, uint256);\nHDXcontractChanged(address, address, uint256);\nOwnershipTransferred(address, address);\nonBuyEvent(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1562(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x158e(uint256 varg0, uint256 varg1) private { \n    v0 = 0x1562(0xde0b6b3a7640000, varg1);\n    assert(_buyingPrice);\n    v1 = address(varg0);\n    require(v0 / _buyingPrice + _balanceOf[v1] >= _balanceOf[v1]);\n    v2 = address(varg0);\n    _balanceOf[v2] = v0 / _buyingPrice + _balanceOf[v1];\n    require(v0 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v0 / _buyingPrice;\n    v3 = address(varg0);\n    emit onBuyEvent(v3, v0 / _buyingPrice);\n    return v0 / _buyingPrice;\n}\n\nfunction fallback() public payable { \n    v0 = 0x638(0);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction sellingPrice(bool varg0) public nonPayable { \n    v0 = 0x849(varg0);\n    return v0;\n}\n\nfunction appreciateTokenPrice() public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v0 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v0 / _totalSupply;\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction sellToken(uint256 varg0) public nonPayable { \n    v0 = 0xfc5();\n    require(v0 > 0);\n    require(varg0 <= _balanceOf[msg.sender]);\n    v1 = 0x1562(_buyingPrice, varg0);\n    assert(0xde0b6b3a7640000);\n    v2 = 0x1562(3, v1 / 0xde0b6b3a7640000);\n    assert(100);\n    v3 = 0x1562(1, v1 / 0xde0b6b3a7640000);\n    assert(100);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v4 = 0x1562(97, v3 / 100);\n    assert(100);\n    v5 = 0x1562(0xde0b6b3a7640000, v4 / 100);\n    assert(_buyingPrice);\n    require(v5 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n    _balanceOf[_owner] += v5 / _buyingPrice;\n    require(v5 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v5 / _buyingPrice;\n    emit onBuyEvent(_owner, v5 / _buyingPrice);\n    require(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - (v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100);\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v6 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v6 / _totalSupply;\n    }\n    emit onSellEvent(msg.sender, varg0);\n    v7 = msg.sender.call().value(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100).gas(2300 * !(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100));\n    require(v7); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction moveAccountOut() public nonPayable { \n    v0 = 0xfc5();\n    require(v0 > 0);\n    v1 = 0xfa6(msg.sender);\n    v2 = v3 = v1 > 0;\n    if (v3) {\n        v2 = stor_0_0_0;\n    }\n    require(v2);\n    v4 = 0x1562(_buyingPrice, _balanceOf[msg.sender]);\n    assert(0xde0b6b3a7640000);\n    require(_balanceOf[msg.sender] <= _totalSupply);\n    _totalSupply = _totalSupply - _balanceOf[msg.sender];\n    _balanceOf[msg.sender] = 0;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    emit 0x613f3007a01cf0dc9b10750d673c7e934a1c83f14715bc21a835824408f0555(msg.sender, stor_0_0_19, _balanceOf[msg.sender], v4 / 0xde0b6b3a7640000);\n    require(stor_0_0_19.code.size);\n    v6 = stor_0_0_19.moveAccountIn(msg.sender).value(v4 / 0xde0b6b3a7640000).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n}\n\nfunction payWithToken(uint256 varg0, address varg1) public nonPayable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = 0xfa6(varg1);\n        v0 = varg0 <= v2;\n    }\n    require(v0);\n    v3 = 0x1562(0xde0b6b3a7640000, varg0);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice <= _balanceOf[varg1]);\n    v4 = 0x1562(_buyingPrice, v3 / _buyingPrice);\n    assert(0xde0b6b3a7640000);\n    require(v3 / _buyingPrice <= _balanceOf[varg1]);\n    require(v3 / _buyingPrice <= _totalSupply);\n    _totalSupply = _totalSupply - v3 / _buyingPrice;\n    _balanceOf[varg1] = _balanceOf[varg1] - v3 / _buyingPrice;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    v6 = msg.sender.call().value(v4 / 0xde0b6b3a7640000).gas(2300 * !(v4 / 0xde0b6b3a7640000));\n    require(v6); // checks call status, propagates error data on error\n    return v4 / 0xde0b6b3a7640000;\n}\n\nfunction changeName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(msg.sender == _owner);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ethBalanceOf(address varg0) public nonPayable { \n    v0 = 0xee7(varg0);\n    return v0;\n}\n\nfunction buyToken(address varg0) public payable { \n    v0 = 0x638(varg0);\n    return v0;\n}\n\nfunction getSuperReferrerRate(address varg0) public nonPayable { \n    return 50 + (0xff & _getSuperReferrerRate[varg0]) & 0xff;\n}\n\nfunction addSuperReferrer(address varg0, uint8 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _getSuperReferrerRate[varg0] = varg1 & 0xff & 0xff | ~0xff & _getSuperReferrerRate[varg0];\n}\n\nfunction ethBalanceOfNoFee(address varg0) public nonPayable { \n    v0 = 0xfa6(varg0);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xfc5();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction moveAccountIn(address varg0) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = 0x158e(varg0, msg.value);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v1 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v1 / _totalSupply;\n    }\n    emit onAccountMovedIn(msg.sender, varg0, v0, msg.value);\n}\n\nfunction changeSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(msg.sender == _owner);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction changeNewHDX20Contract(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(stor_0_0_19 != varg0);\n    require(varg0);\n    emit HDXcontractChanged(stor_0_0_19, varg0, block.timestamp);\n    stor_0_0_19 = varg0;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_owner != varg0);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[msg.sender]);\n    if (varg1 > 0) {\n        v0 = 0x1562(2, varg1);\n        assert(100);\n        require(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        require(varg1 - (v0 / 100 >> 1 << 1) + _balanceOf[varg0] >= _balanceOf[varg0]);\n        _balanceOf[varg0] += varg1 - (v0 / 100 >> 1 << 1);\n        _balanceOf[_owner] += v0 / 100 >> 1;\n        require(v0 / 100 >> 1 <= _totalSupply);\n        _totalSupply = _totalSupply - (v0 / 100 >> 1);\n        if (0xde0b6b3a7640000 < _totalSupply - (v0 / 100 >> 1)) {\n            v1 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v1 / _totalSupply;\n        }\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalContractBalance() public nonPayable { \n    return _totalContractBalance;\n}\n\nfunction removeGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOf() public nonPayable { \n    v0 = 0xee7(msg.sender);\n    return v0;\n}\n\nfunction buyTokenFromGame(address varg0, address varg1) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    if (msg.value) {\n        v0 = 0x1562(1, msg.value);\n        assert(100);\n        v1 = 0x1562(3, msg.value);\n        assert(100);\n        v2 = v3 = v1 / 100;\n        v4 = v5 = varg1;\n        if (varg1) {\n            v4 = varg1 != varg0;\n        }\n        if (v4) {\n            v6 = 0x1562((0xff & _getSuperReferrerRate[varg1]) + 50 & 0xff, v3);\n            assert(100);\n            v7 = 0x158e(varg1, v6 / 100);\n            require(v6 / 100 <= v3);\n            v2 = v3 - v6 / 100;\n        }\n        v8 = 0x1562(97, v0 / 100);\n        assert(100);\n        v9 = 0x1562(0xde0b6b3a7640000, v8 / 100);\n        assert(_buyingPrice);\n        require(v9 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n        _balanceOf[_owner] += v9 / _buyingPrice;\n        require(v9 / _buyingPrice + _totalSupply >= _totalSupply);\n        _totalSupply += v9 / _buyingPrice;\n        emit onBuyEvent(_owner, v9 / _buyingPrice);\n        v10 = v11 = 0x158e(varg0, msg.value - v2 - v0 / 100);\n        require(msg.value + _totalContractBalance >= _totalContractBalance);\n        _totalContractBalance += msg.value;\n        if (0xde0b6b3a7640000 < _totalSupply) {\n            v12 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v12 / _totalSupply;\n        }\n    } else {\n        v10 = v13 = 0;\n    }\n    return v10;\n}\n\nfunction buyingPrice(bool varg0) public nonPayable { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x1562(3, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x1562(1, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return v0 + _buyingPrice + v0;\n}\n\nfunction addGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = 0x1 | ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOfNoFee() public nonPayable { \n    v0 = 0xfa6(msg.sender);\n    return v0;\n}\n\nfunction checkGameListed(address varg0) public nonPayable { \n    return 0xff & _checkGameListed[varg0];\n}\n\nfunction 0x638(uint256 varg0) private { \n    require(msg.value > 0);\n    v0 = 0x1562(1, msg.value);\n    assert(100);\n    v1 = 0x1562(3, msg.value);\n    assert(100);\n    v2 = v3 = v1 / 100;\n    v4 = !address(varg0);\n    v5 = v6 = address(varg0);\n    if (address(varg0)) {\n        v5 = v7 = address(varg0) != msg.sender;\n    }\n    if (v5) {\n        v8 = address(varg0);\n        v9 = 0x1562((0xff & _getSuperReferrerRate[v8]) + 50 & 0xff, v3);\n        assert(100);\n        v10 = 0x158e(varg0, v9 / 100);\n        require(v9 / 100 <= v3);\n        v2 = v3 - v9 / 100;\n    }\n    v11 = 0x1562(97, v0 / 100);\n    assert(100);\n    v12 = 0x1562(0xde0b6b3a7640000, v11 / 100);\n    assert(_buyingPrice);\n    require(v12 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n    _balanceOf[_owner] += v12 / _buyingPrice;\n    require(v12 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v12 / _buyingPrice;\n    emit onBuyEvent(_owner, v12 / _buyingPrice);\n    v13 = 0x158e(msg.sender, msg.value - v2 - v0 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v14 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v14 / _totalSupply;\n    }\n    return v13;\n}\n\nfunction 0x849(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x1562(3, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x1562(1, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return _buyingPrice - v0 - v0;\n}\n\nfunction 0xee7(uint256 varg0) private { \n    v0 = 0x849(1);\n    v1 = address(varg0);\n    v2 = 0x1562(v0, _balanceOf[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xfa6(uint256 varg0) private { \n    v0 = 0x849(0);\n    v1 = address(varg0);\n    v2 = 0x1562(v0, _balanceOf[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xfc5() private { \n    return _balanceOf[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x1097b9ee == function_selector) {\n            sellingPrice(bool);\n        } else if (0x16ff1c76 == function_selector) {\n            appreciateTokenPrice();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2397e4d7 == function_selector) {\n            sellToken(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3a9d8be8 == function_selector) {\n            moveAccountOut();\n        } else if (0x52dde1c3 == function_selector) {\n            payWithToken(uint256,address);\n        } else if (0x5353a2d8 == function_selector) {\n            changeName(string);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7252bbf2 == function_selector) {\n            ethBalanceOf(address);\n        } else if (0x7e72fb52 == function_selector) {\n            buyToken(address);\n        } else if (0x7f630259 == function_selector) {\n            getSuperReferrerRate(address);\n        } else if (0x814487c4 == function_selector) {\n            addSuperReferrer(address,uint8);\n        } else if (0x87f5c846 == function_selector) {\n            ethBalanceOfNoFee(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9a74adda == function_selector) {\n            moveAccountIn(address);\n        } else if (0xa3895fff == function_selector) {\n            changeSymbol(string);\n        } else if (0xa546f2e7 == function_selector) {\n            changeNewHDX20Contract(address);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbac03cd7 == function_selector) {\n            totalContractBalance();\n        } else if (0xbce24669 == function_selector) {\n            removeGame(address);\n        } else if (0xc53b12f9 == function_selector) {\n            myEthBalanceOf();\n        } else if (0xc671b934 == function_selector) {\n            buyTokenFromGame(address,address);\n        } else if (0xc9a7623a == function_selector) {\n            buyingPrice(bool);\n        } else if (0xd72d04db == function_selector) {\n            addGame(address);\n        } else if (0xd784601a == function_selector) {\n            myEthBalanceOfNoFee();\n        } else if (0xdc62da61 == function_selector) {\n            checkGameListed(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 10:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256[] _name; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalContractBalance; // STORAGE[0x6]\nuint256 _buyingPrice; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _checkGameListed; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _getSuperReferrerRate; // STORAGE[0x9]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nonSellEvent(address, uint256);\nonAccountMovedIn(address, address, uint256, uint256);\nHDXcontractChanged(address, address, uint256);\nOwnershipTransferred(address, address);\nonBuyEvent(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1562(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x158e(uint256 varg0, uint256 varg1) private { \n    v0 = 0x1562(0xde0b6b3a7640000, varg1);\n    assert(_buyingPrice);\n    v1 = address(varg0);\n    require(v0 / _buyingPrice + _balanceOf[v1] >= _balanceOf[v1]);\n    v2 = address(varg0);\n    _balanceOf[v2] = v0 / _buyingPrice + _balanceOf[v1];\n    require(v0 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v0 / _buyingPrice;\n    v3 = address(varg0);\n    emit onBuyEvent(v3, v0 / _buyingPrice);\n    return v0 / _buyingPrice;\n}\n\nfunction fallback() public payable { \n    v0 = 0x638(0);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction sellingPrice(bool varg0) public nonPayable { \n    v0 = 0x849(varg0);\n    return v0;\n}\n\nfunction appreciateTokenPrice() public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v0 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v0 / _totalSupply;\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction sellToken(uint256 varg0) public nonPayable { \n    v0 = 0xfc5();\n    require(v0 > 0);\n    require(varg0 <= _balanceOf[msg.sender]);\n    v1 = 0x1562(_buyingPrice, varg0);\n    assert(0xde0b6b3a7640000);\n    v2 = 0x1562(3, v1 / 0xde0b6b3a7640000);\n    assert(100);\n    v3 = 0x1562(1, v1 / 0xde0b6b3a7640000);\n    assert(100);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v4 = 0x1562(97, v3 / 100);\n    assert(100);\n    v5 = 0x1562(0xde0b6b3a7640000, v4 / 100);\n    assert(_buyingPrice);\n    require(v5 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n    _balanceOf[_owner] += v5 / _buyingPrice;\n    require(v5 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v5 / _buyingPrice;\n    emit onBuyEvent(_owner, v5 / _buyingPrice);\n    require(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - (v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100);\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v6 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v6 / _totalSupply;\n    }\n    emit onSellEvent(msg.sender, varg0);\n    v7 = msg.sender.call().value(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100).gas(2300 * !(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100));\n    require(v7); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction moveAccountOut() public nonPayable { \n    v0 = 0xfc5();\n    require(v0 > 0);\n    v1 = 0xfa6(msg.sender);\n    v2 = v3 = v1 > 0;\n    if (v3) {\n        v2 = stor_0_0_0;\n    }\n    require(v2);\n    v4 = 0x1562(_buyingPrice, _balanceOf[msg.sender]);\n    assert(0xde0b6b3a7640000);\n    require(_balanceOf[msg.sender] <= _totalSupply);\n    _totalSupply = _totalSupply - _balanceOf[msg.sender];\n    _balanceOf[msg.sender] = 0;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    emit 0x613f3007a01cf0dc9b10750d673c7e934a1c83f14715bc21a835824408f0555(msg.sender, stor_0_0_19, _balanceOf[msg.sender], v4 / 0xde0b6b3a7640000);\n    require(stor_0_0_19.code.size);\n    v6 = stor_0_0_19.moveAccountIn(msg.sender).value(v4 / 0xde0b6b3a7640000).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n}\n\nfunction payWithToken(uint256 varg0, address varg1) public nonPayable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = 0xfa6(varg1);\n        v0 = varg0 <= v2;\n    }\n    require(v0);\n    v3 = 0x1562(0xde0b6b3a7640000, varg0);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice <= _balanceOf[varg1]);\n    v4 = 0x1562(_buyingPrice, v3 / _buyingPrice);\n    assert(0xde0b6b3a7640000);\n    require(v3 / _buyingPrice <= _balanceOf[varg1]);\n    require(v3 / _buyingPrice <= _totalSupply);\n    _totalSupply = _totalSupply - v3 / _buyingPrice;\n    _balanceOf[varg1] = _balanceOf[varg1] - v3 / _buyingPrice;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    v6 = msg.sender.call().value(v4 / 0xde0b6b3a7640000).gas(2300 * !(v4 / 0xde0b6b3a7640000));\n    require(v6); // checks call status, propagates error data on error\n    return v4 / 0xde0b6b3a7640000;\n}\n\nfunction changeName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(msg.sender == _owner);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ethBalanceOf(address varg0) public nonPayable { \n    v0 = 0xee7(varg0);\n    return v0;\n}\n\nfunction buyToken(address varg0) public payable { \n    v0 = 0x638(varg0);\n    return v0;\n}\n\nfunction getSuperReferrerRate(address varg0) public nonPayable { \n    return 50 + (0xff & _getSuperReferrerRate[varg0]) & 0xff;\n}\n\nfunction addSuperReferrer(address varg0, uint8 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _getSuperReferrerRate[varg0] = varg1 & 0xff & 0xff | ~0xff & _getSuperReferrerRate[varg0];\n}\n\nfunction ethBalanceOfNoFee(address varg0) public nonPayable { \n    v0 = 0xfa6(varg0);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xfc5();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction moveAccountIn(address varg0) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = 0x158e(varg0, msg.value);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v1 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v1 / _totalSupply;\n    }\n    emit onAccountMovedIn(msg.sender, varg0, v0, msg.value);\n}\n\nfunction changeSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(msg.sender == _owner);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction changeNewHDX20Contract(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(stor_0_0_19 != varg0);\n    require(varg0);\n    emit HDXcontractChanged(stor_0_0_19, varg0, block.timestamp);\n    stor_0_0_19 = varg0;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_owner != varg0);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[msg.sender]);\n    if (varg1 > 0) {\n        v0 = 0x1562(2, varg1);\n        assert(100);\n        require(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        require(varg1 - (v0 / 100 >> 1 << 1) + _balanceOf[varg0] >= _balanceOf[varg0]);\n        _balanceOf[varg0] += varg1 - (v0 / 100 >> 1 << 1);\n        _balanceOf[_owner] += v0 / 100 >> 1;\n        require(v0 / 100 >> 1 <= _totalSupply);\n        _totalSupply = _totalSupply - (v0 / 100 >> 1);\n        if (0xde0b6b3a7640000 < _totalSupply - (v0 / 100 >> 1)) {\n            v1 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v1 / _totalSupply;\n        }\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalContractBalance() public nonPayable { \n    return _totalContractBalance;\n}\n\nfunction removeGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOf() public nonPayable { \n    v0 = 0xee7(msg.sender);\n    return v0;\n}\n\nfunction buyTokenFromGame(address varg0, address varg1) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    if (msg.value) {\n        v0 = 0x1562(1, msg.value);\n        assert(100);\n        v1 = 0x1562(3, msg.value);\n        assert(100);\n        v2 = v3 = v1 / 100;\n        v4 = v5 = varg1;\n        if (varg1) {\n            v4 = varg1 != varg0;\n        }\n        if (v4) {\n            v6 = 0x1562((0xff & _getSuperReferrerRate[varg1]) + 50 & 0xff, v3);\n            assert(100);\n            v7 = 0x158e(varg1, v6 / 100);\n            require(v6 / 100 <= v3);\n            v2 = v3 - v6 / 100;\n        }\n        v8 = 0x1562(97, v0 / 100);\n        assert(100);\n        v9 = 0x1562(0xde0b6b3a7640000, v8 / 100);\n        assert(_buyingPrice);\n        require(v9 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n        _balanceOf[_owner] += v9 / _buyingPrice;\n        require(v9 / _buyingPrice + _totalSupply >= _totalSupply);\n        _totalSupply += v9 / _buyingPrice;\n        emit onBuyEvent(_owner, v9 / _buyingPrice);\n        v10 = v11 = 0x158e(varg0, msg.value - v2 - v0 / 100);\n        require(msg.value + _totalContractBalance >= _totalContractBalance);\n        _totalContractBalance += msg.value;\n        if (0xde0b6b3a7640000 < _totalSupply) {\n            v12 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v12 / _totalSupply;\n        }\n    } else {\n        v10 = v13 = 0;\n    }\n    return v10;\n}\n\nfunction buyingPrice(bool varg0) public nonPayable { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x1562(3, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x1562(1, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return v0 + _buyingPrice + v0;\n}\n\nfunction addGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = 0x1 | ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOfNoFee() public nonPayable { \n    v0 = 0xfa6(msg.sender);\n    return v0;\n}\n\nfunction checkGameListed(address varg0) public nonPayable { \n    return 0xff & _checkGameListed[varg0];\n}\n\nfunction 0x638(uint256 varg0) private { \n    require(msg.value > 0);\n    v0 = 0x1562(1, msg.value);\n    assert(100);\n    v1 = 0x1562(3, msg.value);\n    assert(100);\n    v2 = v3 = v1 / 100;\n    v4 = !address(varg0);\n    v5 = v6 = address(varg0);\n    if (address(varg0)) {\n        v5 = v7 = address(varg0) != msg.sender;\n    }\n    if (v5) {\n        v8 = address(varg0);\n        v9 = 0x1562((0xff & _getSuperReferrerRate[v8]) + 50 & 0xff, v3);\n        assert(100);\n        v10 = 0x158e(varg0, v9 / 100);\n        require(v9 / 100 <= v3);\n        v2 = v3 - v9 / 100;\n    }\n    v11 = 0x1562(97, v0 / 100);\n    assert(100);\n    v12 = 0x1562(0xde0b6b3a7640000, v11 / 100);\n    assert(_buyingPrice);\n    require(v12 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n    _balanceOf[_owner] += v12 / _buyingPrice;\n    require(v12 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v12 / _buyingPrice;\n    emit onBuyEvent(_owner, v12 / _buyingPrice);\n    v13 = 0x158e(msg.sender, msg.value - v2 - v0 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v14 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v14 / _totalSupply;\n    }\n    return v13;\n}\n\nfunction 0x849(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x1562(3, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x1562(1, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return _buyingPrice - v0 - v0;\n}\n\nfunction 0xee7(uint256 varg0) private { \n    v0 = 0x849(1);\n    v1 = address(varg0);\n    v2 = 0x1562(v0, _balanceOf[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xfa6(uint256 varg0) private { \n    v0 = 0x849(0);\n    v1 = address(varg0);\n    v2 = 0x1562(v0, _balanceOf[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xfc5() private { \n    return _balanceOf[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x1097b9ee == function_selector) {\n            sellingPrice(bool);\n        } else if (0x16ff1c76 == function_selector) {\n            appreciateTokenPrice();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2397e4d7 == function_selector) {\n            sellToken(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3a9d8be8 == function_selector) {\n            moveAccountOut();\n        } else if (0x52dde1c3 == function_selector) {\n            payWithToken(uint256,address);\n        } else if (0x5353a2d8 == function_selector) {\n            changeName(string);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7252bbf2 == function_selector) {\n            ethBalanceOf(address);\n        } else if (0x7e72fb52 == function_selector) {\n            buyToken(address);\n        } else if (0x7f630259 == function_selector) {\n            getSuperReferrerRate(address);\n        } else if (0x814487c4 == function_selector) {\n            addSuperReferrer(address,uint8);\n        } else if (0x87f5c846 == function_selector) {\n            ethBalanceOfNoFee(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9a74adda == function_selector) {\n            moveAccountIn(address);\n        } else if (0xa3895fff == function_selector) {\n            changeSymbol(string);\n        } else if (0xa546f2e7 == function_selector) {\n            changeNewHDX20Contract(address);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbac03cd7 == function_selector) {\n            totalContractBalance();\n        } else if (0xbce24669 == function_selector) {\n            removeGame(address);\n        } else if (0xc53b12f9 == function_selector) {\n            myEthBalanceOf();\n        } else if (0xc671b934 == function_selector) {\n            buyTokenFromGame(address,address);\n        } else if (0xc9a7623a == function_selector) {\n            buyingPrice(bool);\n        } else if (0xd72d04db == function_selector) {\n            addGame(address);\n        } else if (0xd784601a == function_selector) {\n            myEthBalanceOfNoFee();\n        } else if (0xdc62da61 == function_selector) {\n            checkGameListed(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 10:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256[] _name; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalContractBalance; // STORAGE[0x6]\nuint256 _buyingPrice; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _checkGameListed; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _getSuperReferrerRate; // STORAGE[0x9]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nonSellEvent(address, uint256);\nonAccountMovedIn(address, address, uint256, uint256);\nHDXcontractChanged(address, address, uint256);\nOwnershipTransferred(address, address);\nonBuyEvent(address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1562(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x158e(uint256 varg0, uint256 varg1) private { \n    v0 = 0x1562(0xde0b6b3a7640000, varg1);\n    assert(_buyingPrice);\n    v1 = address(varg0);\n    require(v0 / _buyingPrice + _balanceOf[v1] >= _balanceOf[v1]);\n    v2 = address(varg0);\n    _balanceOf[v2] = v0 / _buyingPrice + _balanceOf[v1];\n    require(v0 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v0 / _buyingPrice;\n    v3 = address(varg0);\n    emit onBuyEvent(v3, v0 / _buyingPrice);\n    return v0 / _buyingPrice;\n}\n\nfunction fallback() public payable { \n    v0 = 0x638(0);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction sellingPrice(bool varg0) public nonPayable { \n    v0 = 0x849(varg0);\n    return v0;\n}\n\nfunction appreciateTokenPrice() public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v0 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v0 / _totalSupply;\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction sellToken(uint256 varg0) public nonPayable { \n    v0 = 0xfc5();\n    require(v0 > 0);\n    require(varg0 <= _balanceOf[msg.sender]);\n    v1 = 0x1562(_buyingPrice, varg0);\n    assert(0xde0b6b3a7640000);\n    v2 = 0x1562(3, v1 / 0xde0b6b3a7640000);\n    assert(100);\n    v3 = 0x1562(1, v1 / 0xde0b6b3a7640000);\n    assert(100);\n    require(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v4 = 0x1562(97, v3 / 100);\n    assert(100);\n    v5 = 0x1562(0xde0b6b3a7640000, v4 / 100);\n    assert(_buyingPrice);\n    require(v5 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n    _balanceOf[_owner] += v5 / _buyingPrice;\n    require(v5 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v5 / _buyingPrice;\n    emit onBuyEvent(_owner, v5 / _buyingPrice);\n    require(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - (v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100);\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v6 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v6 / _totalSupply;\n    }\n    emit onSellEvent(msg.sender, varg0);\n    v7 = msg.sender.call().value(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100).gas(2300 * !(v1 / 0xde0b6b3a7640000 - v2 / 100 - v3 / 100));\n    require(v7); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction moveAccountOut() public nonPayable { \n    v0 = 0xfc5();\n    require(v0 > 0);\n    v1 = 0xfa6(msg.sender);\n    v2 = v3 = v1 > 0;\n    if (v3) {\n        v2 = stor_0_0_0;\n    }\n    require(v2);\n    v4 = 0x1562(_buyingPrice, _balanceOf[msg.sender]);\n    assert(0xde0b6b3a7640000);\n    require(_balanceOf[msg.sender] <= _totalSupply);\n    _totalSupply = _totalSupply - _balanceOf[msg.sender];\n    _balanceOf[msg.sender] = 0;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    emit 0x613f3007a01cf0dc9b10750d673c7e934a1c83f14715bc21a835824408f0555(msg.sender, stor_0_0_19, _balanceOf[msg.sender], v4 / 0xde0b6b3a7640000);\n    require(stor_0_0_19.code.size);\n    v6 = stor_0_0_19.moveAccountIn(msg.sender).value(v4 / 0xde0b6b3a7640000).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n}\n\nfunction payWithToken(uint256 varg0, address varg1) public nonPayable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v2 = 0xfa6(varg1);\n        v0 = varg0 <= v2;\n    }\n    require(v0);\n    v3 = 0x1562(0xde0b6b3a7640000, varg0);\n    assert(_buyingPrice);\n    require(v3 / _buyingPrice <= _balanceOf[varg1]);\n    v4 = 0x1562(_buyingPrice, v3 / _buyingPrice);\n    assert(0xde0b6b3a7640000);\n    require(v3 / _buyingPrice <= _balanceOf[varg1]);\n    require(v3 / _buyingPrice <= _totalSupply);\n    _totalSupply = _totalSupply - v3 / _buyingPrice;\n    _balanceOf[varg1] = _balanceOf[varg1] - v3 / _buyingPrice;\n    require(v4 / 0xde0b6b3a7640000 <= _totalContractBalance);\n    _totalContractBalance = _totalContractBalance - v4 / 0xde0b6b3a7640000;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v5 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v5 / _totalSupply;\n    }\n    v6 = msg.sender.call().value(v4 / 0xde0b6b3a7640000).gas(2300 * !(v4 / 0xde0b6b3a7640000));\n    require(v6); // checks call status, propagates error data on error\n    return v4 / 0xde0b6b3a7640000;\n}\n\nfunction changeName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(msg.sender == _owner);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ethBalanceOf(address varg0) public nonPayable { \n    v0 = 0xee7(varg0);\n    return v0;\n}\n\nfunction buyToken(address varg0) public payable { \n    v0 = 0x638(varg0);\n    return v0;\n}\n\nfunction getSuperReferrerRate(address varg0) public nonPayable { \n    return 50 + (0xff & _getSuperReferrerRate[varg0]) & 0xff;\n}\n\nfunction addSuperReferrer(address varg0, uint8 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _getSuperReferrerRate[varg0] = varg1 & 0xff & 0xff | ~0xff & _getSuperReferrerRate[varg0];\n}\n\nfunction ethBalanceOfNoFee(address varg0) public nonPayable { \n    v0 = 0xfa6(varg0);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xfc5();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction moveAccountIn(address varg0) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    v0 = 0x158e(varg0, msg.value);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v1 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v1 / _totalSupply;\n    }\n    emit onAccountMovedIn(msg.sender, varg0, v0, msg.value);\n}\n\nfunction changeSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(msg.sender == _owner);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction changeNewHDX20Contract(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(stor_0_0_19 != varg0);\n    require(varg0);\n    emit HDXcontractChanged(stor_0_0_19, varg0, block.timestamp);\n    stor_0_0_19 = varg0;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_owner != varg0);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[msg.sender]);\n    if (varg1 > 0) {\n        v0 = 0x1562(2, varg1);\n        assert(100);\n        require(varg1 <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        require(varg1 - (v0 / 100 >> 1 << 1) + _balanceOf[varg0] >= _balanceOf[varg0]);\n        _balanceOf[varg0] += varg1 - (v0 / 100 >> 1 << 1);\n        _balanceOf[_owner] += v0 / 100 >> 1;\n        require(v0 / 100 >> 1 <= _totalSupply);\n        _totalSupply = _totalSupply - (v0 / 100 >> 1);\n        if (0xde0b6b3a7640000 < _totalSupply - (v0 / 100 >> 1)) {\n            v1 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v1 / _totalSupply;\n        }\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalContractBalance() public nonPayable { \n    return _totalContractBalance;\n}\n\nfunction removeGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOf() public nonPayable { \n    v0 = 0xee7(msg.sender);\n    return v0;\n}\n\nfunction buyTokenFromGame(address varg0, address varg1) public payable { \n    require(1 == 0xff & _checkGameListed[msg.sender]);\n    if (msg.value) {\n        v0 = 0x1562(1, msg.value);\n        assert(100);\n        v1 = 0x1562(3, msg.value);\n        assert(100);\n        v2 = v3 = v1 / 100;\n        v4 = v5 = varg1;\n        if (varg1) {\n            v4 = varg1 != varg0;\n        }\n        if (v4) {\n            v6 = 0x1562((0xff & _getSuperReferrerRate[varg1]) + 50 & 0xff, v3);\n            assert(100);\n            v7 = 0x158e(varg1, v6 / 100);\n            require(v6 / 100 <= v3);\n            v2 = v3 - v6 / 100;\n        }\n        v8 = 0x1562(97, v0 / 100);\n        assert(100);\n        v9 = 0x1562(0xde0b6b3a7640000, v8 / 100);\n        assert(_buyingPrice);\n        require(v9 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n        _balanceOf[_owner] += v9 / _buyingPrice;\n        require(v9 / _buyingPrice + _totalSupply >= _totalSupply);\n        _totalSupply += v9 / _buyingPrice;\n        emit onBuyEvent(_owner, v9 / _buyingPrice);\n        v10 = v11 = 0x158e(varg0, msg.value - v2 - v0 / 100);\n        require(msg.value + _totalContractBalance >= _totalContractBalance);\n        _totalContractBalance += msg.value;\n        if (0xde0b6b3a7640000 < _totalSupply) {\n            v12 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n            assert(_totalSupply);\n            _buyingPrice = v12 / _totalSupply;\n        }\n    } else {\n        v10 = v13 = 0;\n    }\n    return v10;\n}\n\nfunction buyingPrice(bool varg0) public nonPayable { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x1562(3, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x1562(1, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return v0 + _buyingPrice + v0;\n}\n\nfunction addGame(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _checkGameListed[varg0] = 0x1 | ~0xff & _checkGameListed[varg0];\n}\n\nfunction myEthBalanceOfNoFee() public nonPayable { \n    v0 = 0xfa6(msg.sender);\n    return v0;\n}\n\nfunction checkGameListed(address varg0) public nonPayable { \n    return 0xff & _checkGameListed[varg0];\n}\n\nfunction 0x638(uint256 varg0) private { \n    require(msg.value > 0);\n    v0 = 0x1562(1, msg.value);\n    assert(100);\n    v1 = 0x1562(3, msg.value);\n    assert(100);\n    v2 = v3 = v1 / 100;\n    v4 = !address(varg0);\n    v5 = v6 = address(varg0);\n    if (address(varg0)) {\n        v5 = v7 = address(varg0) != msg.sender;\n    }\n    if (v5) {\n        v8 = address(varg0);\n        v9 = 0x1562((0xff & _getSuperReferrerRate[v8]) + 50 & 0xff, v3);\n        assert(100);\n        v10 = 0x158e(varg0, v9 / 100);\n        require(v9 / 100 <= v3);\n        v2 = v3 - v9 / 100;\n    }\n    v11 = 0x1562(97, v0 / 100);\n    assert(100);\n    v12 = 0x1562(0xde0b6b3a7640000, v11 / 100);\n    assert(_buyingPrice);\n    require(v12 / _buyingPrice + _balanceOf[_owner] >= _balanceOf[_owner]);\n    _balanceOf[_owner] += v12 / _buyingPrice;\n    require(v12 / _buyingPrice + _totalSupply >= _totalSupply);\n    _totalSupply += v12 / _buyingPrice;\n    emit onBuyEvent(_owner, v12 / _buyingPrice);\n    v13 = 0x158e(msg.sender, msg.value - v2 - v0 / 100);\n    require(msg.value + _totalContractBalance >= _totalContractBalance);\n    _totalContractBalance += msg.value;\n    if (0xde0b6b3a7640000 < _totalSupply) {\n        v14 = 0x1562(0xde0b6b3a7640000, _totalContractBalance);\n        assert(_totalSupply);\n        _buyingPrice = v14 / _totalSupply;\n    }\n    return v13;\n}\n\nfunction 0x849(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0) {\n        v2 = 0x1562(3, _buyingPrice);\n        assert(100);\n        v0 = v3 = v2 / 100;\n        v4 = 0x1562(1, _buyingPrice);\n        assert(100);\n        v0 = v5 = v4 / 100;\n    }\n    return _buyingPrice - v0 - v0;\n}\n\nfunction 0xee7(uint256 varg0) private { \n    v0 = 0x849(1);\n    v1 = address(varg0);\n    v2 = 0x1562(v0, _balanceOf[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xfa6(uint256 varg0) private { \n    v0 = 0x849(0);\n    v1 = address(varg0);\n    v2 = 0x1562(v0, _balanceOf[v1]);\n    assert(0xde0b6b3a7640000);\n    return v2 / 0xde0b6b3a7640000;\n}\n\nfunction 0xfc5() private { \n    return _balanceOf[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x1097b9ee == function_selector) {\n            sellingPrice(bool);\n        } else if (0x16ff1c76 == function_selector) {\n            appreciateTokenPrice();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2397e4d7 == function_selector) {\n            sellToken(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3a9d8be8 == function_selector) {\n            moveAccountOut();\n        } else if (0x52dde1c3 == function_selector) {\n            payWithToken(uint256,address);\n        } else if (0x5353a2d8 == function_selector) {\n            changeName(string);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7252bbf2 == function_selector) {\n            ethBalanceOf(address);\n        } else if (0x7e72fb52 == function_selector) {\n            buyToken(address);\n        } else if (0x7f630259 == function_selector) {\n            getSuperReferrerRate(address);\n        } else if (0x814487c4 == function_selector) {\n            addSuperReferrer(address,uint8);\n        } else if (0x87f5c846 == function_selector) {\n            ethBalanceOfNoFee(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9a74adda == function_selector) {\n            moveAccountIn(address);\n        } else if (0xa3895fff == function_selector) {\n            changeSymbol(string);\n        } else if (0xa546f2e7 == function_selector) {\n            changeNewHDX20Contract(address);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbac03cd7 == function_selector) {\n            totalContractBalance();\n        } else if (0xbce24669 == function_selector) {\n            removeGame(address);\n        } else if (0xc53b12f9 == function_selector) {\n            myEthBalanceOf();\n        } else if (0xc671b934 == function_selector) {\n            buyTokenFromGame(address,address);\n        } else if (0xc9a7623a == function_selector) {\n            buyingPrice(bool);\n        } else if (0xd72d04db == function_selector) {\n            addGame(address);\n        } else if (0xd784601a == function_selector) {\n            myEthBalanceOfNoFee();\n        } else if (0xdc62da61 == function_selector) {\n            checkGameListed(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 6.703717470169067,
	"usage": {
		"completion_tokens": 157,
		"prompt_tokens": 6690,
		"total_tokens": 6847
	}
}