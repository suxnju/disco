{
	"address": "0x9c6a68be3b5bfa059af5da21678ff3cfe4426fdb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the reconstructed Solidity contract code based on the provided decompiled code:\n\n```Solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    address private _token;\n    address private _withdrawOnlyETH;\n    address private _changeTimeExpired;\n    uint256 private stor_1;\n\n    function token() public view returns(address) {\n        return _token;\n    }\n\n    function changeTimeExpired(uint256 varg0) public {\n        require(msg.sender == _changeTimeExpired, 'Only admin');\n        stor_1 = varg0;\n    }\n\n    function changeAdmin(address varg0) public {\n        require(msg.sender == _changeTimeExpired, 'Only admin');\n        require(varg0 != address(0));\n        _changeTimeExpired = varg0;\n    }\n\n    function withdrawOnlyETH() public {\n        require(msg.sender == _withdrawOnlyETH || msg.sender == _changeTimeExpired, 'No permission');\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function changeOwner(address varg0) public {\n        require(msg.sender == _withdrawOnlyETH || msg.sender == _changeTimeExpired, 'No permission');\n        require(varg0 != address(0));\n        _withdrawOnlyETH = varg0;\n    }\n\n    function withdrawByType(address varg0) public {\n        require(msg.sender == _withdrawOnlyETH || msg.sender == _changeTimeExpired, 'No permission');\n        require(varg0 != address(0), 'Address must different 0x0!');\n        _token = varg0;\n        IERC20 token = IERC20(_token);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(msg.sender, balance), 'Withdraw failed!');\n    }\n   \n    fallback() external payable { }\n\n    receive() external payable { }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\nPlease note that the above Solidity code assumes the use of an ERC20 token interface for interactions with `_token`. The `withdrawByType` method retrieves the balance of the contract in `_token` and attempts to transfer this balance to `msg.sender`. \n\nThe `fallback()` and `receive()` functions are made for receiving Ether sent to the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462564,
	"id": "chatcmpl-8R4QWj5f6tIBCKA1C0jvMtcBI5Hns",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 23:12 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_1; // STORAGE[0x1]\naddress _token; // STORAGE[0x0] bytes 0 to 19\naddress _withdrawOnlyETH; // STORAGE[0x2] bytes 0 to 19\naddress _changeTimeExpired; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction fallback() public payable { \n}\n\nfunction changeTimeExpired(uint256 varg0) public nonPayable { \n    require(msg.sender == _changeTimeExpired, 'Only admin');\n    stor_1 = varg0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.sender == _changeTimeExpired, 'Only admin');\n    require(varg0);\n    _changeTimeExpired = varg0;\n}\n\nfunction withdrawOnlyETH() public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_1;\n    }\n    if (!v0) {\n        v0 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    v3 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (msg.sender != _withdrawOnlyETH) {\n        v0 = v2 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    require(varg0);\n    _withdrawOnlyETH = varg0;\n}\n\nfunction withdrawByType(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_1;\n    }\n    if (!v0) {\n        v0 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    require(varg0, 'Address must different 0x0!');\n    _token = varg0;\n    require(_token.code.size);\n    v3, v4 = _token.balanceOf(this).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token.code.size);\n    v5, v6 = _token.transfer(msg.sender, v4).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Withdraw failed!');\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1245666f) {\n            changeTimeExpired(uint256);\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0x9a44a52f == function_selector) {\n            withdrawOnlyETH();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xacce3bf0 == function_selector) {\n            withdrawByType(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 23:12 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_1; // STORAGE[0x1]\naddress _token; // STORAGE[0x0] bytes 0 to 19\naddress _withdrawOnlyETH; // STORAGE[0x2] bytes 0 to 19\naddress _changeTimeExpired; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction fallback() public payable { \n}\n\nfunction changeTimeExpired(uint256 varg0) public nonPayable { \n    require(msg.sender == _changeTimeExpired, 'Only admin');\n    stor_1 = varg0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.sender == _changeTimeExpired, 'Only admin');\n    require(varg0);\n    _changeTimeExpired = varg0;\n}\n\nfunction withdrawOnlyETH() public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_1;\n    }\n    if (!v0) {\n        v0 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    v3 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (msg.sender != _withdrawOnlyETH) {\n        v0 = v2 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    require(varg0);\n    _withdrawOnlyETH = varg0;\n}\n\nfunction withdrawByType(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_1;\n    }\n    if (!v0) {\n        v0 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    require(varg0, 'Address must different 0x0!');\n    _token = varg0;\n    require(_token.code.size);\n    v3, v4 = _token.balanceOf(this).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token.code.size);\n    v5, v6 = _token.transfer(msg.sender, v4).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Withdraw failed!');\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1245666f) {\n            changeTimeExpired(uint256);\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0x9a44a52f == function_selector) {\n            withdrawOnlyETH();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xacce3bf0 == function_selector) {\n            withdrawByType(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 23:12 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_1; // STORAGE[0x1]\naddress _token; // STORAGE[0x0] bytes 0 to 19\naddress _withdrawOnlyETH; // STORAGE[0x2] bytes 0 to 19\naddress _changeTimeExpired; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction fallback() public payable { \n}\n\nfunction changeTimeExpired(uint256 varg0) public nonPayable { \n    require(msg.sender == _changeTimeExpired, 'Only admin');\n    stor_1 = varg0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.sender == _changeTimeExpired, 'Only admin');\n    require(varg0);\n    _changeTimeExpired = varg0;\n}\n\nfunction withdrawOnlyETH() public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_1;\n    }\n    if (!v0) {\n        v0 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    v3 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (msg.sender != _withdrawOnlyETH) {\n        v0 = v2 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    require(varg0);\n    _withdrawOnlyETH = varg0;\n}\n\nfunction withdrawByType(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _withdrawOnlyETH;\n    if (v1) {\n        v0 = v2 = block.timestamp > stor_1;\n    }\n    if (!v0) {\n        v0 = msg.sender == _changeTimeExpired;\n    }\n    require(v0, 'No permission');\n    require(varg0, 'Address must different 0x0!');\n    _token = varg0;\n    require(_token.code.size);\n    v3, v4 = _token.balanceOf(this).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token.code.size);\n    v5, v6 = _token.transfer(msg.sender, v4).gas(msg.gas);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v6, 'Withdraw failed!');\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1245666f) {\n            changeTimeExpired(uint256);\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0x9a44a52f == function_selector) {\n            withdrawOnlyETH();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xacce3bf0 == function_selector) {\n            withdrawByType(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 30.975419998168945,
	"usage": {
		"completion_tokens": 486,
		"prompt_tokens": 899,
		"total_tokens": 1385
	}
}