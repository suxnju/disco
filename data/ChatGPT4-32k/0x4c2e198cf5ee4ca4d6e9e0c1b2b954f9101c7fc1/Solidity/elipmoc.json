{
	"address": "0x4c2e198cf5ee4ca4d6e9e0c1b2b954f9101c7fc1",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The following is a Solidity code that mirrors the given decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract MyContract {\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => bool) public frozenAccount;\n    address public owner;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    uint256 public sellPrice;\n    uint256 public buyPrice;\n    bool public closeSell;\n    bool public closeBuy;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event FrozenFunds(address target, bool frozen);\n\n    constructor(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol,\n        uint8 decimalUnits,\n        address centralMinter\n    ) public {\n        if(centralMinter != 0 ) owner = centralMinter;\n        else owner = msg.sender;\n        totalSupply = initialSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n        balanceOf[msg.sender] = initialSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        require(balanceOf[msg.sender] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function mintToken(address target, uint256 mintedAmount) public {\n        require(msg.sender == owner);\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(0, owner, mintedAmount);\n        emit Transfer(owner, target, mintedAmount);\n    }\n\n    function freezeAccount(address target, bool freeze) public {\n        require(msg.sender == owner);\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\n        require(msg.sender == owner);\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n\n    function buy() public payable {\n        uint amount = msg.value / buyPrice;\n        require(balanceOf[this] >= amount);\n        balanceOf[msg.sender] += amount;\n        balanceOf[this] -= amount;\n        emit Transfer(this, msg.sender, amount);\n    }\n\n    function sell(uint256 amount) public {\n        require(balanceOf[msg.sender] >= amount );\n        balanceOf[this] += amount;\n        balanceOf[msg.sender] -= amount;\n        if (!msg.sender.send(amount * sellPrice)) {\n            balanceOf[this] -= amount;\n            balanceOf[msg.sender] += amount;\n        } else {\n            emit Transfer(msg.sender, this, amount);\n        }\n    }\n}\n```\n\nPlease note that this is a general contract that has similar functionality to the given decompiled EVM bytecode. It may not follow the exact logic and functionality of the original contract as some information about execution flow and particular logic might be lost during decompilation.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463016,
	"id": "chatcmpl-8R4XohMErW9WBJHQlA1D0hGwgMBIJ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 00:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _closeBuy; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0xa]\naddress _refillTokens; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nLogWithdrawal(address, uint256);\nLogDeposit(address, uint256);\nFrozenFunds(address, bool);\nTransfer(address, address, uint256);\n\nfunction buy() public payable { \n    require(!(0xff & _closeBuy));\n    assert(_buyPrice);\n    require((address(this)).balance >= msg.value / _buyPrice * _buyPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(msg.value / _buyPrice * _buyPrice / 100).gas(!(msg.value / _buyPrice * _buyPrice / 100) * 2300);\n    require(v0);\n    0xb32(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    require((address(this)).balance >= varg2 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg2 * _sellPrice / 100).gas(!(varg2 * _sellPrice / 100) * 2300);\n    require(v0);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0xb32(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    emit LogWithdrawal(msg.sender, varg0);\n    v0 = _refillTokens.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction commissionGetter() public nonPayable { \n    return address(_closeBuy >> 16);\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction refillTokens(uint256 varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    0xb32(varg0, this, msg.sender);\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _refillTokens;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require((address(this)).balance >= varg1 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg1 * _sellPrice / 100).gas(!(varg1 * _sellPrice / 100) * 2300);\n    require(v0);\n    0xb32(varg1, varg0, msg.sender);\n}\n\nfunction setStatus(bool varg0, bool varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _closeBuy = varg1 << 8 | ~0xff00 & (varg0 | ~0xff & _closeBuy);\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction closeSell() public nonPayable { \n    return 0xff & _closeBuy >> 8;\n}\n\nfunction closeBuy() public nonPayable { \n    return 0xff & _closeBuy;\n}\n\nfunction deposit() public payable { \n    require(msg.value + (address(this)).balance > (address(this)).balance);\n    emit LogDeposit(msg.sender, msg.value);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(!(0xff & _closeBuy >> 8));\n    require((address(this)).balance >= varg0 * _sellPrice + varg0 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg0 * _sellPrice / 100).gas(!(varg0 * _sellPrice / 100) * 2300);\n    require(v0);\n    0xb32(varg0, this, msg.sender);\n    v1 = msg.sender.call().value(varg0 * _sellPrice).gas(2300 * !(varg0 * _sellPrice));\n    require(v1);\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _refillTokens = varg0;\n}\n\nfunction 0xb32(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    require(!(0xff & _frozenAccount[v2]));\n    v3 = address(varg1);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg2);\n    _balanceOf[v4] = _balanceOf[v4] - varg0;\n    v5 = address(varg1);\n    _balanceOf[v5] += varg0;\n    emit Transfer(v4, v5, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x5fefda7) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3651b401 == function_selector) {\n            commissionGetter();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7ef5b6ea == function_selector) {\n            refillTokens(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a != function_selector) {\n            if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xb3c2eac1 == function_selector) {\n                setStatus(bool,bool);\n            } else if (0xb414d4b6 == function_selector) {\n                frozenAccount(address);\n            } else if (0xba83c970 == function_selector) {\n                closeSell();\n            } else if (0xc6ab5cdc == function_selector) {\n                closeBuy();\n            } else if (0xd0e30db0 == function_selector) {\n                deposit();\n            } else if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xe4849b32 == function_selector) {\n                sell(uint256);\n            } else if (0xe724529c == function_selector) {\n                freezeAccount(address,bool);\n            } else if (0xf2fde38b == function_selector) {\n                transferOwnership(address);\n            }\n        }\n    }\n    buy();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 00:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _closeBuy; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0xa]\naddress _refillTokens; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nLogWithdrawal(address, uint256);\nLogDeposit(address, uint256);\nFrozenFunds(address, bool);\nTransfer(address, address, uint256);\n\nfunction buy() public payable { \n    require(!(0xff & _closeBuy));\n    assert(_buyPrice);\n    require((address(this)).balance >= msg.value / _buyPrice * _buyPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(msg.value / _buyPrice * _buyPrice / 100).gas(!(msg.value / _buyPrice * _buyPrice / 100) * 2300);\n    require(v0);\n    0xb32(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    require((address(this)).balance >= varg2 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg2 * _sellPrice / 100).gas(!(varg2 * _sellPrice / 100) * 2300);\n    require(v0);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0xb32(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    emit LogWithdrawal(msg.sender, varg0);\n    v0 = _refillTokens.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction commissionGetter() public nonPayable { \n    return address(_closeBuy >> 16);\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction refillTokens(uint256 varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    0xb32(varg0, this, msg.sender);\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _refillTokens;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require((address(this)).balance >= varg1 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg1 * _sellPrice / 100).gas(!(varg1 * _sellPrice / 100) * 2300);\n    require(v0);\n    0xb32(varg1, varg0, msg.sender);\n}\n\nfunction setStatus(bool varg0, bool varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _closeBuy = varg1 << 8 | ~0xff00 & (varg0 | ~0xff & _closeBuy);\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction closeSell() public nonPayable { \n    return 0xff & _closeBuy >> 8;\n}\n\nfunction closeBuy() public nonPayable { \n    return 0xff & _closeBuy;\n}\n\nfunction deposit() public payable { \n    require(msg.value + (address(this)).balance > (address(this)).balance);\n    emit LogDeposit(msg.sender, msg.value);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(!(0xff & _closeBuy >> 8));\n    require((address(this)).balance >= varg0 * _sellPrice + varg0 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg0 * _sellPrice / 100).gas(!(varg0 * _sellPrice / 100) * 2300);\n    require(v0);\n    0xb32(varg0, this, msg.sender);\n    v1 = msg.sender.call().value(varg0 * _sellPrice).gas(2300 * !(varg0 * _sellPrice));\n    require(v1);\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _refillTokens = varg0;\n}\n\nfunction 0xb32(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    require(!(0xff & _frozenAccount[v2]));\n    v3 = address(varg1);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg2);\n    _balanceOf[v4] = _balanceOf[v4] - varg0;\n    v5 = address(varg1);\n    _balanceOf[v5] += varg0;\n    emit Transfer(v4, v5, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x5fefda7) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3651b401 == function_selector) {\n            commissionGetter();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7ef5b6ea == function_selector) {\n            refillTokens(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a != function_selector) {\n            if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xb3c2eac1 == function_selector) {\n                setStatus(bool,bool);\n            } else if (0xb414d4b6 == function_selector) {\n                frozenAccount(address);\n            } else if (0xba83c970 == function_selector) {\n                closeSell();\n            } else if (0xc6ab5cdc == function_selector) {\n                closeBuy();\n            } else if (0xd0e30db0 == function_selector) {\n                deposit();\n            } else if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xe4849b32 == function_selector) {\n                sell(uint256);\n            } else if (0xe724529c == function_selector) {\n                freezeAccount(address,bool);\n            } else if (0xf2fde38b == function_selector) {\n                transferOwnership(address);\n            }\n        }\n    }\n    buy();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 00:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _closeBuy; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0xa]\naddress _refillTokens; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nLogWithdrawal(address, uint256);\nLogDeposit(address, uint256);\nFrozenFunds(address, bool);\nTransfer(address, address, uint256);\n\nfunction buy() public payable { \n    require(!(0xff & _closeBuy));\n    assert(_buyPrice);\n    require((address(this)).balance >= msg.value / _buyPrice * _buyPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(msg.value / _buyPrice * _buyPrice / 100).gas(!(msg.value / _buyPrice * _buyPrice / 100) * 2300);\n    require(v0);\n    0xb32(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    require((address(this)).balance >= varg2 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg2 * _sellPrice / 100).gas(!(varg2 * _sellPrice / 100) * 2300);\n    require(v0);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0xb32(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    emit LogWithdrawal(msg.sender, varg0);\n    v0 = _refillTokens.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction commissionGetter() public nonPayable { \n    return address(_closeBuy >> 16);\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction refillTokens(uint256 varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    0xb32(varg0, this, msg.sender);\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _refillTokens;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require((address(this)).balance >= varg1 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg1 * _sellPrice / 100).gas(!(varg1 * _sellPrice / 100) * 2300);\n    require(v0);\n    0xb32(varg1, varg0, msg.sender);\n}\n\nfunction setStatus(bool varg0, bool varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _closeBuy = varg1 << 8 | ~0xff00 & (varg0 | ~0xff & _closeBuy);\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction closeSell() public nonPayable { \n    return 0xff & _closeBuy >> 8;\n}\n\nfunction closeBuy() public nonPayable { \n    return 0xff & _closeBuy;\n}\n\nfunction deposit() public payable { \n    require(msg.value + (address(this)).balance > (address(this)).balance);\n    emit LogDeposit(msg.sender, msg.value);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(!(0xff & _closeBuy >> 8));\n    require((address(this)).balance >= varg0 * _sellPrice + varg0 * _sellPrice / 100);\n    v0 = address(_closeBuy >> 16).call().value(varg0 * _sellPrice / 100).gas(!(varg0 * _sellPrice / 100) * 2300);\n    require(v0);\n    0xb32(varg0, this, msg.sender);\n    v1 = msg.sender.call().value(varg0 * _sellPrice).gas(2300 * !(varg0 * _sellPrice));\n    require(v1);\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_refillTokens == msg.sender);\n    _refillTokens = varg0;\n}\n\nfunction 0xb32(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    require(!(0xff & _frozenAccount[v2]));\n    v3 = address(varg1);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg2);\n    _balanceOf[v4] = _balanceOf[v4] - varg0;\n    v5 = address(varg1);\n    _balanceOf[v5] += varg0;\n    emit Transfer(v4, v5, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x5fefda7) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3651b401 == function_selector) {\n            commissionGetter();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7ef5b6ea == function_selector) {\n            refillTokens(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a != function_selector) {\n            if (0xa9059cbb == function_selector) {\n                transfer(address,uint256);\n            } else if (0xb3c2eac1 == function_selector) {\n                setStatus(bool,bool);\n            } else if (0xb414d4b6 == function_selector) {\n                frozenAccount(address);\n            } else if (0xba83c970 == function_selector) {\n                closeSell();\n            } else if (0xc6ab5cdc == function_selector) {\n                closeBuy();\n            } else if (0xd0e30db0 == function_selector) {\n                deposit();\n            } else if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xe4849b32 == function_selector) {\n                sell(uint256);\n            } else if (0xe724529c == function_selector) {\n                freezeAccount(address,bool);\n            } else if (0xf2fde38b == function_selector) {\n                transferOwnership(address);\n            }\n        }\n    }\n    buy();\n}\n.",
	"status": "1",
	"time_cost": 33.112847089767456,
	"usage": {
		"completion_tokens": 818,
		"prompt_tokens": 2758,
		"total_tokens": 3576
	}
}