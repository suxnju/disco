{
	"address": "0xc7f1c3500496771b2ef4e17ad10624131ade5cd9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is a simplified version of a Solidity contract that corresponds to the given decompiled code. Due to the complexity of the original code, not all parts could be fully represented, but the main elements, such as storage variables, fallback function, and a few other functions, are included.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    uint256 public _totalSupply;\n    uint256 public _circulatingSupply;\n    uint256 public _frozenTokens;\n    address public _owner;\n    address public _dev;\n    mapping (address => uint256) public _balances;\n    mapping (address => bool) public _exchangePartners;\n    mapping (address => uint256) public _exchangeRates;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor(uint256 totalSupply) public {\n        _totalSupply = totalSupply;\n        _owner = msg.sender;\n        _balances[_owner] = totalSupply;\n    }\n\n    function fallback() external payable {\n        require(msg.value > 0);\n        uint256 tokensPerEth = 1000;  // Simplified for the example, in real contract this should be a variable.\n        uint256 tokens = tokensPerEth * msg.value;\n        require(_totalSupply >= tokens);\n        _totalSupply -= tokens;\n        _balances[msg.sender] += tokens;\n        _circulatingSupply += tokens;\n        emit Transfer(address(this), msg.sender, tokens);\n    }\n    \n    function transfer(address to, uint256 tokens) public {\n        require(_balances[msg.sender] >= tokens);\n        _balances[msg.sender] -= tokens;\n        _balances[to] += tokens;\n        emit Transfer(msg.sender, to, tokens);\n    }\n\n    function addExchangePartner(address partner, uint256 rate) public {\n        require(msg.sender == _owner);\n        _exchangePartners[partner] = true;\n        _exchangeRates[partner] = rate;\n    }\n\n    function exchangeTokens(address partner, uint256 tokens) public {\n        require(_exchangePartners[partner]);\n        require(_balances[msg.sender] >= tokens);\n        _balances[msg.sender] -= tokens;\n        _balances[partner] += tokens;\n        emit Transfer(msg.sender, partner, tokens);\n    }\n}\n```\nThis code implements a simple ERC20-like contract that has a total supply of tokens, allows for transfers of these tokens and keeps track of the balances of each address. It also has functionality to add exchange partners and exchange tokens with these partners. The original EVM bytecode likely represents a much more complex contract, but this should give you a good starting point.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468052,
	"id": "chatcmpl-8R5r2JOCpx7IKO08jtuQzcFs7yVi7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 00:03 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 __tokePerEth; // STORAGE[0x7]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 __totalSupply; // STORAGE[0xd]\nuint256 __circulatingSupply; // STORAGE[0xe]\nuint256 __frozenTokens; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _exchangePartners; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _exchangeRates; // STORAGE[0x12]\nuint8 _decimals; // STORAGE[0x1] bytes 0 to 0\nuint8 __coldStorage; // STORAGE[0x8] bytes 0 to 0\nuint8 __receiveEth; // STORAGE[0x8] bytes 1 to 1\nuint8 stor_8_2_2; // STORAGE[0x8] bytes 2 to 2\nuint8 _withdrawDevFees; // STORAGE[0x8] bytes 3 to 3\naddress __owner; // STORAGE[0x3] bytes 0 to 19\nuint160 __premine; // STORAGE[0x4] bytes 0 to 19\naddress __dev; // STORAGE[0x5] bytes 0 to 19\naddress __devFeesAddr; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nExchanged(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.value > 0;\n    if (v1) {\n        v0 = v2 = __receiveEth;\n    }\n    require(v0);\n    v3 = _SafeMul(__tokePerEth, msg.value);\n    assert(0xde0b6b3a7640000);\n    require(__totalSupply >= v3 / 0xde0b6b3a7640000);\n    require(v3 / 0xde0b6b3a7640000 <= __totalSupply);\n    __totalSupply = __totalSupply - v3 / 0xde0b6b3a7640000;\n    require(_balances[msg.sender] + v3 / 0xde0b6b3a7640000 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v3 / 0xde0b6b3a7640000;\n    require(__circulatingSupply + v3 / 0xde0b6b3a7640000 >= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply + v3 / 0xde0b6b3a7640000;\n    emit Transfer(address(this), msg.sender, v3 / 0xde0b6b3a7640000);\n    require(stor_a + msg.value >= stor_a);\n    stor_a = stor_a + msg.value;\n    if (stor_8_2_2) {\n        if (!_withdrawDevFees) {\n            if (stor_a >= stor_b) {\n                _withdrawDevFees = 1;\n            }\n        }\n        if (_withdrawDevFees) {\n            require(stor_c + msg.value * stor_9 / 10000 >= stor_c);\n            stor_c = stor_c + msg.value * stor_9 / 10000;\n        }\n    }\n}\n\nfunction 0x27b2(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(0xff & _exchangePartners[v0]);\n    v1 = address(varg1);\n    require(v1.code.size);\n    v2 = v1.exchangeTokensFromOtherContract(address(this), msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(1);\n    if (!__coldStorage) {\n        v3 = __totalSupply + varg0;\n        require(v3 >= __totalSupply);\n        __totalSupply = v3;\n    } else {\n        v4 = __frozenTokens + varg0;\n        require(v4 >= __frozenTokens);\n        __frozenTokens = v4;\n    }\n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    require(varg0 <= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply - varg0;\n    emit Exchanged(msg.sender, address(varg1), varg0);\n    emit Transfer(msg.sender, address(this), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _devFeesAddr() public nonPayable { \n    return __devFeesAddr;\n}\n\nfunction _premine() public nonPayable { \n    return __premine;\n}\n\nfunction changeDevFeesAddr(address varg0) public nonPayable { \n    require(msg.sender == __dev);\n    __devFeesAddr = varg0;\n}\n\nfunction withdrawDevFees() public nonPayable { \n    require(_withdrawDevFees);\n    v0 = __devFeesAddr.call().value(stor_c).gas(!stor_c * 2300);\n    require(v0); // checks call status, propagates error data on error\n    stor_c = 0;\n}\n\nfunction _coldStorage() public nonPayable { \n    return __coldStorage;\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction exchangeTokensFromOtherContract(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_exchangeRates[msg.sender] > 0);\n    v0 = _SafeMul(_exchangeRates[varg0], varg2);\n    require(v0 <= __totalSupply);\n    require(_balances[varg1] + v0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + v0;\n    require(v0 <= __totalSupply);\n    __totalSupply = __totalSupply - v0;\n    require(__circulatingSupply + v0 >= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply + v0;\n    emit Exchanged(varg0, varg1, v0);\n    emit Transfer(address(this), varg1, v0);\n}\n\nfunction getCirculatingSupply() public nonPayable { \n    return __circulatingSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction addExchangePartnerAddressAndRate(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    require(varg0.code.size > 0);\n    _exchangeRates[varg0] = varg1;\n}\n\nfunction addExchangePartnerTargetAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    _exchangePartners[varg0] = 0x1 | ~0xff & _exchangePartners[varg0];\n}\n\nfunction defrostFrozenTokens() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    require(__totalSupply + __frozenTokens >= __totalSupply);\n    __totalSupply = __totalSupply + __frozenTokens;\n    __frozenTokens = 0;\n}\n\nfunction toggleReceiveEth() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (__receiveEth) {\n        __receiveEth = 0;\n    } else {\n        __receiveEth = 1;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction getLifeVal() public nonPayable { \n    v0 = v1 = msg.sender == __owner;\n    if (msg.sender != __owner) {\n        v0 = v2 = msg.sender == __dev;\n    }\n    require(v0);\n    return stor_a;\n}\n\nfunction _frozenTokens() public nonPayable { \n    return __frozenTokens;\n}\n\nfunction exchangeRates(address varg0) public nonPayable { \n    return _exchangeRates[varg0];\n}\n\nfunction changeDev(address varg0) public nonPayable { \n    require(msg.sender == __dev);\n    __owner = varg0;\n}\n\nfunction _receiveEth() public nonPayable { \n    return __receiveEth;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateFeeAmount(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    v3 = v4 = varg0 >= 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 100;\n    }\n    require(v3);\n    stor_9 = varg0 * 100;\n}\n\nfunction _circulatingSupply() public nonPayable { \n    return __circulatingSupply;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == __owner);\n    __dev = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (varg0.code.size == 0) {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            0x27b2(varg1, varg0);\n        }\n    } else {\n        require(__totalSupply + varg1 >= __totalSupply);\n        __totalSupply = __totalSupply + varg1;\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction toggleFreezeTokensFlag() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (__coldStorage) {\n        __coldStorage = 0;\n    } else {\n        __coldStorage = 1;\n    }\n}\n\nfunction _owner() public nonPayable { \n    return __owner;\n}\n\nfunction transfer(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (varg0.code.size == 0) {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            0x27b2(varg1, varg0);\n        }\n    } else {\n        require(__totalSupply + varg1 >= __totalSupply);\n        __totalSupply = __totalSupply + varg1;\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction contractExchangeRate(address varg0) public nonPayable { \n    return _exchangeRates[varg0];\n}\n\nfunction payFeesToggle() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (!_withdrawDevFees) {\n        _withdrawDevFees = 1;\n    } else {\n        _withdrawDevFees = 0;\n    }\n}\n\nfunction safeWithdrawal(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == __owner);\n    v0 = _SafeMul(0xde0b6b3a7640000, varg1);\n    if (stor_8_2_2) {\n        if (_withdrawDevFees) {\n            v1 = __devFeesAddr.call().value(stor_c).gas(!stor_c * 2300);\n            require(v1); // checks call status, propagates error data on error\n        }\n        stor_c = 0;\n    }\n    require(v0 <= (address(this)).balance);\n    v2 = varg0.call().value(v0).gas(!v0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction _tokePerEth() public nonPayable { \n    return __tokePerEth;\n}\n\nfunction changePayRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == __owner;\n    if (msg.sender != __owner) {\n        v0 = v2 = msg.sender == __dev;\n    }\n    if (v0) {\n        v0 = v3 = varg0 >= 0;\n    }\n    require(v0);\n    __tokePerEth = varg0;\n}\n\nfunction canExchange(address varg0) public nonPayable { \n    return 0xff & _exchangePartners[varg0];\n}\n\nfunction _dev() public nonPayable { \n    return __dev;\n}\n\nfunction exchangePartners(address varg0) public nonPayable { \n    return 0xff & _exchangePartners[varg0];\n}\n\nfunction removeExchangePartnerTargetAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    _exchangePartners[varg0] = 0x0 | ~0xff & _exchangePartners[varg0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x84794f8 == function_selector) {\n            _devFeesAddr();\n        } else if (0x8daaf4a == function_selector) {\n            _premine();\n        } else if (0xa9a70c0 == function_selector) {\n            changeDevFeesAddr(address);\n        } else if (0xda590d4 == function_selector) {\n            withdrawDevFees();\n        } else if (0xdf3a342 == function_selector) {\n            _coldStorage();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x2aeacd4a == function_selector) {\n            exchangeTokensFromOtherContract(address,address,uint256);\n        } else if (0x2b112e49 == function_selector) {\n            getCirculatingSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x4e2133ba == function_selector) {\n            addExchangePartnerAddressAndRate(address,uint256);\n        } else if (0x53e1509c == function_selector) {\n            addExchangePartnerTargetAddress(address);\n        } else if (0x6230ebda == function_selector) {\n            defrostFrozenTokens();\n        } else if (0x626ebe39 == function_selector) {\n            toggleReceiveEth();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79e2bbea == function_selector) {\n            getLifeVal();\n        } else if (0x803287de == function_selector) {\n            _frozenTokens();\n        } else if (0x85c15d9a == function_selector) {\n            exchangeRates(address);\n        } else if (0x88a8c95c == function_selector) {\n            changeDev(address);\n        } else if (0x9478f7cf == function_selector) {\n            _receiveEth();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ea55bb0 == function_selector) {\n            updateFeeAmount(uint256);\n        } else if (0xa253c06e == function_selector) {\n            _circulatingSupply();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xafbddfa9 == function_selector) {\n            toggleFreezeTokensFlag();\n        } else if (0xb2bdfa7b == function_selector) {\n            _owner();\n        } else if (0xbe45fd62 == function_selector) {\n            transfer(address,uint256,bytes);\n        } else if (0xc1d6036b == function_selector) {\n            contractExchangeRate(address);\n        } else if (0xc42edd61 == function_selector) {\n            payFeesToggle();\n        } else if (0xd34dd1f0 == function_selector) {\n            safeWithdrawal(address,uint256);\n        } else if (0xd7be503f == function_selector) {\n            _tokePerEth();\n        } else if (0xda9c87fa == function_selector) {\n            changePayRate(uint256);\n        } else if (0xe77b077f == function_selector) {\n            canExchange(address);\n        } else if (0xe79ffa11 == function_selector) {\n            _dev();\n        } else if (0xec2f5685 == function_selector) {\n            exchangePartners(address);\n        } else if (0xf4ed216c == function_selector) {\n            removeExchangePartnerTargetAddress(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 00:03 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 __tokePerEth; // STORAGE[0x7]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 __totalSupply; // STORAGE[0xd]\nuint256 __circulatingSupply; // STORAGE[0xe]\nuint256 __frozenTokens; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _exchangePartners; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _exchangeRates; // STORAGE[0x12]\nuint8 _decimals; // STORAGE[0x1] bytes 0 to 0\nuint8 __coldStorage; // STORAGE[0x8] bytes 0 to 0\nuint8 __receiveEth; // STORAGE[0x8] bytes 1 to 1\nuint8 stor_8_2_2; // STORAGE[0x8] bytes 2 to 2\nuint8 _withdrawDevFees; // STORAGE[0x8] bytes 3 to 3\naddress __owner; // STORAGE[0x3] bytes 0 to 19\nuint160 __premine; // STORAGE[0x4] bytes 0 to 19\naddress __dev; // STORAGE[0x5] bytes 0 to 19\naddress __devFeesAddr; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nExchanged(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.value > 0;\n    if (v1) {\n        v0 = v2 = __receiveEth;\n    }\n    require(v0);\n    v3 = _SafeMul(__tokePerEth, msg.value);\n    assert(0xde0b6b3a7640000);\n    require(__totalSupply >= v3 / 0xde0b6b3a7640000);\n    require(v3 / 0xde0b6b3a7640000 <= __totalSupply);\n    __totalSupply = __totalSupply - v3 / 0xde0b6b3a7640000;\n    require(_balances[msg.sender] + v3 / 0xde0b6b3a7640000 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v3 / 0xde0b6b3a7640000;\n    require(__circulatingSupply + v3 / 0xde0b6b3a7640000 >= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply + v3 / 0xde0b6b3a7640000;\n    emit Transfer(address(this), msg.sender, v3 / 0xde0b6b3a7640000);\n    require(stor_a + msg.value >= stor_a);\n    stor_a = stor_a + msg.value;\n    if (stor_8_2_2) {\n        if (!_withdrawDevFees) {\n            if (stor_a >= stor_b) {\n                _withdrawDevFees = 1;\n            }\n        }\n        if (_withdrawDevFees) {\n            require(stor_c + msg.value * stor_9 / 10000 >= stor_c);\n            stor_c = stor_c + msg.value * stor_9 / 10000;\n        }\n    }\n}\n\nfunction 0x27b2(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(0xff & _exchangePartners[v0]);\n    v1 = address(varg1);\n    require(v1.code.size);\n    v2 = v1.exchangeTokensFromOtherContract(address(this), msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(1);\n    if (!__coldStorage) {\n        v3 = __totalSupply + varg0;\n        require(v3 >= __totalSupply);\n        __totalSupply = v3;\n    } else {\n        v4 = __frozenTokens + varg0;\n        require(v4 >= __frozenTokens);\n        __frozenTokens = v4;\n    }\n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    require(varg0 <= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply - varg0;\n    emit Exchanged(msg.sender, address(varg1), varg0);\n    emit Transfer(msg.sender, address(this), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _devFeesAddr() public nonPayable { \n    return __devFeesAddr;\n}\n\nfunction _premine() public nonPayable { \n    return __premine;\n}\n\nfunction changeDevFeesAddr(address varg0) public nonPayable { \n    require(msg.sender == __dev);\n    __devFeesAddr = varg0;\n}\n\nfunction withdrawDevFees() public nonPayable { \n    require(_withdrawDevFees);\n    v0 = __devFeesAddr.call().value(stor_c).gas(!stor_c * 2300);\n    require(v0); // checks call status, propagates error data on error\n    stor_c = 0;\n}\n\nfunction _coldStorage() public nonPayable { \n    return __coldStorage;\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction exchangeTokensFromOtherContract(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_exchangeRates[msg.sender] > 0);\n    v0 = _SafeMul(_exchangeRates[varg0], varg2);\n    require(v0 <= __totalSupply);\n    require(_balances[varg1] + v0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + v0;\n    require(v0 <= __totalSupply);\n    __totalSupply = __totalSupply - v0;\n    require(__circulatingSupply + v0 >= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply + v0;\n    emit Exchanged(varg0, varg1, v0);\n    emit Transfer(address(this), varg1, v0);\n}\n\nfunction getCirculatingSupply() public nonPayable { \n    return __circulatingSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction addExchangePartnerAddressAndRate(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    require(varg0.code.size > 0);\n    _exchangeRates[varg0] = varg1;\n}\n\nfunction addExchangePartnerTargetAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    _exchangePartners[varg0] = 0x1 | ~0xff & _exchangePartners[varg0];\n}\n\nfunction defrostFrozenTokens() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    require(__totalSupply + __frozenTokens >= __totalSupply);\n    __totalSupply = __totalSupply + __frozenTokens;\n    __frozenTokens = 0;\n}\n\nfunction toggleReceiveEth() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (__receiveEth) {\n        __receiveEth = 0;\n    } else {\n        __receiveEth = 1;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction getLifeVal() public nonPayable { \n    v0 = v1 = msg.sender == __owner;\n    if (msg.sender != __owner) {\n        v0 = v2 = msg.sender == __dev;\n    }\n    require(v0);\n    return stor_a;\n}\n\nfunction _frozenTokens() public nonPayable { \n    return __frozenTokens;\n}\n\nfunction exchangeRates(address varg0) public nonPayable { \n    return _exchangeRates[varg0];\n}\n\nfunction changeDev(address varg0) public nonPayable { \n    require(msg.sender == __dev);\n    __owner = varg0;\n}\n\nfunction _receiveEth() public nonPayable { \n    return __receiveEth;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateFeeAmount(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    v3 = v4 = varg0 >= 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 100;\n    }\n    require(v3);\n    stor_9 = varg0 * 100;\n}\n\nfunction _circulatingSupply() public nonPayable { \n    return __circulatingSupply;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == __owner);\n    __dev = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (varg0.code.size == 0) {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            0x27b2(varg1, varg0);\n        }\n    } else {\n        require(__totalSupply + varg1 >= __totalSupply);\n        __totalSupply = __totalSupply + varg1;\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction toggleFreezeTokensFlag() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (__coldStorage) {\n        __coldStorage = 0;\n    } else {\n        __coldStorage = 1;\n    }\n}\n\nfunction _owner() public nonPayable { \n    return __owner;\n}\n\nfunction transfer(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (varg0.code.size == 0) {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            0x27b2(varg1, varg0);\n        }\n    } else {\n        require(__totalSupply + varg1 >= __totalSupply);\n        __totalSupply = __totalSupply + varg1;\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction contractExchangeRate(address varg0) public nonPayable { \n    return _exchangeRates[varg0];\n}\n\nfunction payFeesToggle() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (!_withdrawDevFees) {\n        _withdrawDevFees = 1;\n    } else {\n        _withdrawDevFees = 0;\n    }\n}\n\nfunction safeWithdrawal(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == __owner);\n    v0 = _SafeMul(0xde0b6b3a7640000, varg1);\n    if (stor_8_2_2) {\n        if (_withdrawDevFees) {\n            v1 = __devFeesAddr.call().value(stor_c).gas(!stor_c * 2300);\n            require(v1); // checks call status, propagates error data on error\n        }\n        stor_c = 0;\n    }\n    require(v0 <= (address(this)).balance);\n    v2 = varg0.call().value(v0).gas(!v0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction _tokePerEth() public nonPayable { \n    return __tokePerEth;\n}\n\nfunction changePayRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == __owner;\n    if (msg.sender != __owner) {\n        v0 = v2 = msg.sender == __dev;\n    }\n    if (v0) {\n        v0 = v3 = varg0 >= 0;\n    }\n    require(v0);\n    __tokePerEth = varg0;\n}\n\nfunction canExchange(address varg0) public nonPayable { \n    return 0xff & _exchangePartners[varg0];\n}\n\nfunction _dev() public nonPayable { \n    return __dev;\n}\n\nfunction exchangePartners(address varg0) public nonPayable { \n    return 0xff & _exchangePartners[varg0];\n}\n\nfunction removeExchangePartnerTargetAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    _exchangePartners[varg0] = 0x0 | ~0xff & _exchangePartners[varg0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x84794f8 == function_selector) {\n            _devFeesAddr();\n        } else if (0x8daaf4a == function_selector) {\n            _premine();\n        } else if (0xa9a70c0 == function_selector) {\n            changeDevFeesAddr(address);\n        } else if (0xda590d4 == function_selector) {\n            withdrawDevFees();\n        } else if (0xdf3a342 == function_selector) {\n            _coldStorage();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x2aeacd4a == function_selector) {\n            exchangeTokensFromOtherContract(address,address,uint256);\n        } else if (0x2b112e49 == function_selector) {\n            getCirculatingSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x4e2133ba == function_selector) {\n            addExchangePartnerAddressAndRate(address,uint256);\n        } else if (0x53e1509c == function_selector) {\n            addExchangePartnerTargetAddress(address);\n        } else if (0x6230ebda == function_selector) {\n            defrostFrozenTokens();\n        } else if (0x626ebe39 == function_selector) {\n            toggleReceiveEth();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79e2bbea == function_selector) {\n            getLifeVal();\n        } else if (0x803287de == function_selector) {\n            _frozenTokens();\n        } else if (0x85c15d9a == function_selector) {\n            exchangeRates(address);\n        } else if (0x88a8c95c == function_selector) {\n            changeDev(address);\n        } else if (0x9478f7cf == function_selector) {\n            _receiveEth();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ea55bb0 == function_selector) {\n            updateFeeAmount(uint256);\n        } else if (0xa253c06e == function_selector) {\n            _circulatingSupply();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xafbddfa9 == function_selector) {\n            toggleFreezeTokensFlag();\n        } else if (0xb2bdfa7b == function_selector) {\n            _owner();\n        } else if (0xbe45fd62 == function_selector) {\n            transfer(address,uint256,bytes);\n        } else if (0xc1d6036b == function_selector) {\n            contractExchangeRate(address);\n        } else if (0xc42edd61 == function_selector) {\n            payFeesToggle();\n        } else if (0xd34dd1f0 == function_selector) {\n            safeWithdrawal(address,uint256);\n        } else if (0xd7be503f == function_selector) {\n            _tokePerEth();\n        } else if (0xda9c87fa == function_selector) {\n            changePayRate(uint256);\n        } else if (0xe77b077f == function_selector) {\n            canExchange(address);\n        } else if (0xe79ffa11 == function_selector) {\n            _dev();\n        } else if (0xec2f5685 == function_selector) {\n            exchangePartners(address);\n        } else if (0xf4ed216c == function_selector) {\n            removeExchangePartnerTargetAddress(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 00:03 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 __tokePerEth; // STORAGE[0x7]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 __totalSupply; // STORAGE[0xd]\nuint256 __circulatingSupply; // STORAGE[0xe]\nuint256 __frozenTokens; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _exchangePartners; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _exchangeRates; // STORAGE[0x12]\nuint8 _decimals; // STORAGE[0x1] bytes 0 to 0\nuint8 __coldStorage; // STORAGE[0x8] bytes 0 to 0\nuint8 __receiveEth; // STORAGE[0x8] bytes 1 to 1\nuint8 stor_8_2_2; // STORAGE[0x8] bytes 2 to 2\nuint8 _withdrawDevFees; // STORAGE[0x8] bytes 3 to 3\naddress __owner; // STORAGE[0x3] bytes 0 to 19\nuint160 __premine; // STORAGE[0x4] bytes 0 to 19\naddress __dev; // STORAGE[0x5] bytes 0 to 19\naddress __devFeesAddr; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nExchanged(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.value > 0;\n    if (v1) {\n        v0 = v2 = __receiveEth;\n    }\n    require(v0);\n    v3 = _SafeMul(__tokePerEth, msg.value);\n    assert(0xde0b6b3a7640000);\n    require(__totalSupply >= v3 / 0xde0b6b3a7640000);\n    require(v3 / 0xde0b6b3a7640000 <= __totalSupply);\n    __totalSupply = __totalSupply - v3 / 0xde0b6b3a7640000;\n    require(_balances[msg.sender] + v3 / 0xde0b6b3a7640000 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v3 / 0xde0b6b3a7640000;\n    require(__circulatingSupply + v3 / 0xde0b6b3a7640000 >= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply + v3 / 0xde0b6b3a7640000;\n    emit Transfer(address(this), msg.sender, v3 / 0xde0b6b3a7640000);\n    require(stor_a + msg.value >= stor_a);\n    stor_a = stor_a + msg.value;\n    if (stor_8_2_2) {\n        if (!_withdrawDevFees) {\n            if (stor_a >= stor_b) {\n                _withdrawDevFees = 1;\n            }\n        }\n        if (_withdrawDevFees) {\n            require(stor_c + msg.value * stor_9 / 10000 >= stor_c);\n            stor_c = stor_c + msg.value * stor_9 / 10000;\n        }\n    }\n}\n\nfunction 0x27b2(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(0xff & _exchangePartners[v0]);\n    v1 = address(varg1);\n    require(v1.code.size);\n    v2 = v1.exchangeTokensFromOtherContract(address(this), msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(1);\n    if (!__coldStorage) {\n        v3 = __totalSupply + varg0;\n        require(v3 >= __totalSupply);\n        __totalSupply = v3;\n    } else {\n        v4 = __frozenTokens + varg0;\n        require(v4 >= __frozenTokens);\n        __frozenTokens = v4;\n    }\n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    require(varg0 <= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply - varg0;\n    emit Exchanged(msg.sender, address(varg1), varg0);\n    emit Transfer(msg.sender, address(this), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _devFeesAddr() public nonPayable { \n    return __devFeesAddr;\n}\n\nfunction _premine() public nonPayable { \n    return __premine;\n}\n\nfunction changeDevFeesAddr(address varg0) public nonPayable { \n    require(msg.sender == __dev);\n    __devFeesAddr = varg0;\n}\n\nfunction withdrawDevFees() public nonPayable { \n    require(_withdrawDevFees);\n    v0 = __devFeesAddr.call().value(stor_c).gas(!stor_c * 2300);\n    require(v0); // checks call status, propagates error data on error\n    stor_c = 0;\n}\n\nfunction _coldStorage() public nonPayable { \n    return __coldStorage;\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction exchangeTokensFromOtherContract(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_exchangeRates[msg.sender] > 0);\n    v0 = _SafeMul(_exchangeRates[varg0], varg2);\n    require(v0 <= __totalSupply);\n    require(_balances[varg1] + v0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + v0;\n    require(v0 <= __totalSupply);\n    __totalSupply = __totalSupply - v0;\n    require(__circulatingSupply + v0 >= __circulatingSupply);\n    __circulatingSupply = __circulatingSupply + v0;\n    emit Exchanged(varg0, varg1, v0);\n    emit Transfer(address(this), varg1, v0);\n}\n\nfunction getCirculatingSupply() public nonPayable { \n    return __circulatingSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction addExchangePartnerAddressAndRate(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    require(varg0.code.size > 0);\n    _exchangeRates[varg0] = varg1;\n}\n\nfunction addExchangePartnerTargetAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    _exchangePartners[varg0] = 0x1 | ~0xff & _exchangePartners[varg0];\n}\n\nfunction defrostFrozenTokens() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    require(__totalSupply + __frozenTokens >= __totalSupply);\n    __totalSupply = __totalSupply + __frozenTokens;\n    __frozenTokens = 0;\n}\n\nfunction toggleReceiveEth() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (__receiveEth) {\n        __receiveEth = 0;\n    } else {\n        __receiveEth = 1;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction getLifeVal() public nonPayable { \n    v0 = v1 = msg.sender == __owner;\n    if (msg.sender != __owner) {\n        v0 = v2 = msg.sender == __dev;\n    }\n    require(v0);\n    return stor_a;\n}\n\nfunction _frozenTokens() public nonPayable { \n    return __frozenTokens;\n}\n\nfunction exchangeRates(address varg0) public nonPayable { \n    return _exchangeRates[varg0];\n}\n\nfunction changeDev(address varg0) public nonPayable { \n    require(msg.sender == __dev);\n    __owner = varg0;\n}\n\nfunction _receiveEth() public nonPayable { \n    return __receiveEth;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateFeeAmount(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    v3 = v4 = varg0 >= 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 100;\n    }\n    require(v3);\n    stor_9 = varg0 * 100;\n}\n\nfunction _circulatingSupply() public nonPayable { \n    return __circulatingSupply;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == __owner);\n    __dev = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (varg0.code.size == 0) {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            0x27b2(varg1, varg0);\n        }\n    } else {\n        require(__totalSupply + varg1 >= __totalSupply);\n        __totalSupply = __totalSupply + varg1;\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction toggleFreezeTokensFlag() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (__coldStorage) {\n        __coldStorage = 0;\n    } else {\n        __coldStorage = 1;\n    }\n}\n\nfunction _owner() public nonPayable { \n    return __owner;\n}\n\nfunction transfer(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (varg0.code.size == 0) {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            0x27b2(varg1, varg0);\n        }\n    } else {\n        require(__totalSupply + varg1 >= __totalSupply);\n        __totalSupply = __totalSupply + varg1;\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction contractExchangeRate(address varg0) public nonPayable { \n    return _exchangeRates[varg0];\n}\n\nfunction payFeesToggle() public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = msg.sender == __owner;\n    }\n    require(v0);\n    if (!_withdrawDevFees) {\n        _withdrawDevFees = 1;\n    } else {\n        _withdrawDevFees = 0;\n    }\n}\n\nfunction safeWithdrawal(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == __owner);\n    v0 = _SafeMul(0xde0b6b3a7640000, varg1);\n    if (stor_8_2_2) {\n        if (_withdrawDevFees) {\n            v1 = __devFeesAddr.call().value(stor_c).gas(!stor_c * 2300);\n            require(v1); // checks call status, propagates error data on error\n        }\n        stor_c = 0;\n    }\n    require(v0 <= (address(this)).balance);\n    v2 = varg0.call().value(v0).gas(!v0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction _tokePerEth() public nonPayable { \n    return __tokePerEth;\n}\n\nfunction changePayRate(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == __owner;\n    if (msg.sender != __owner) {\n        v0 = v2 = msg.sender == __dev;\n    }\n    if (v0) {\n        v0 = v3 = varg0 >= 0;\n    }\n    require(v0);\n    __tokePerEth = varg0;\n}\n\nfunction canExchange(address varg0) public nonPayable { \n    return 0xff & _exchangePartners[varg0];\n}\n\nfunction _dev() public nonPayable { \n    return __dev;\n}\n\nfunction exchangePartners(address varg0) public nonPayable { \n    return 0xff & _exchangePartners[varg0];\n}\n\nfunction removeExchangePartnerTargetAddress(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == __dev;\n    if (msg.sender != __dev) {\n        v0 = v2 = msg.sender == __owner;\n    }\n    require(v0);\n    _exchangePartners[varg0] = 0x0 | ~0xff & _exchangePartners[varg0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x84794f8 == function_selector) {\n            _devFeesAddr();\n        } else if (0x8daaf4a == function_selector) {\n            _premine();\n        } else if (0xa9a70c0 == function_selector) {\n            changeDevFeesAddr(address);\n        } else if (0xda590d4 == function_selector) {\n            withdrawDevFees();\n        } else if (0xdf3a342 == function_selector) {\n            _coldStorage();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x2aeacd4a == function_selector) {\n            exchangeTokensFromOtherContract(address,address,uint256);\n        } else if (0x2b112e49 == function_selector) {\n            getCirculatingSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x4e2133ba == function_selector) {\n            addExchangePartnerAddressAndRate(address,uint256);\n        } else if (0x53e1509c == function_selector) {\n            addExchangePartnerTargetAddress(address);\n        } else if (0x6230ebda == function_selector) {\n            defrostFrozenTokens();\n        } else if (0x626ebe39 == function_selector) {\n            toggleReceiveEth();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79e2bbea == function_selector) {\n            getLifeVal();\n        } else if (0x803287de == function_selector) {\n            _frozenTokens();\n        } else if (0x85c15d9a == function_selector) {\n            exchangeRates(address);\n        } else if (0x88a8c95c == function_selector) {\n            changeDev(address);\n        } else if (0x9478f7cf == function_selector) {\n            _receiveEth();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ea55bb0 == function_selector) {\n            updateFeeAmount(uint256);\n        } else if (0xa253c06e == function_selector) {\n            _circulatingSupply();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xafbddfa9 == function_selector) {\n            toggleFreezeTokensFlag();\n        } else if (0xb2bdfa7b == function_selector) {\n            _owner();\n        } else if (0xbe45fd62 == function_selector) {\n            transfer(address,uint256,bytes);\n        } else if (0xc1d6036b == function_selector) {\n            contractExchangeRate(address);\n        } else if (0xc42edd61 == function_selector) {\n            payFeesToggle();\n        } else if (0xd34dd1f0 == function_selector) {\n            safeWithdrawal(address,uint256);\n        } else if (0xd7be503f == function_selector) {\n            _tokePerEth();\n        } else if (0xda9c87fa == function_selector) {\n            changePayRate(uint256);\n        } else if (0xe77b077f == function_selector) {\n            canExchange(address);\n        } else if (0xe79ffa11 == function_selector) {\n            _dev();\n        } else if (0xec2f5685 == function_selector) {\n            exchangePartners(address);\n        } else if (0xf4ed216c == function_selector) {\n            removeExchangePartnerTargetAddress(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 23.64307951927185,
	"usage": {
		"completion_tokens": 540,
		"prompt_tokens": 5043,
		"total_tokens": 5583
	}
}