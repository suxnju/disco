{
	"address": "0xff531d7874cab51b2661d6599d5f552edae3481e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, below is a Solidity version based on the decompiled code.\n\nPlease note that the original contract might contain additional modifiers or checks that are not visible in the decompiled version and that the original contract code might use different variable names.\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyToken {\n    mapping (address => uint256) private _balanceOf;\n    bytes32 private _name;\n    bytes32 private _symbol;\n    uint256 private _totalSupply;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 private _direct_drop_rate;\n    uint256 private _direct_drop_range_start;\n    uint256 private _direct_drop_range_end;\n    address private _admin_address;\n    uint8 private _decimals;\n    uint8 private _direct_drop_switch;\n    address private _account_address;\n    address private _direct_drop_address;\n    address private _direct_drop_withdraw_address;\n    uint8 private _direct_drop_range;\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n\n    function name() public view returns (bytes32) {\n        return _name;\n    }\n    \n    function symbol() public view returns (bytes32) {\n        return _symbol;\n    }\n\n    // ... other getters and setters ...\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[_from] >= _value);\n        require(_balanceOf[_to] + _value >= _balanceOf[_to]);\n        require(_value <= _allowance[_from][msg.sender]);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        _allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    // ... other functions ...\n}\n```\n\nThis code is a basic representation of the provided decompiled code. It includes a standard ERC20 implementation (balanceOf, allowance, transfer, transferFrom, approve). The `_direct_drop_*` variables and related functions seem to be part of a bespoke airdrop mechanism. The `TokenPurchase` event and related functionality suggest that this contract also has a mechanism for purchasing tokens, perhaps as part of an ICO.\n\nPlease note that this contract doesn't contain a constructor function to initialize the state variables, you may need to add one depending on your use case. \n\nAlso, this contract doesn't specify any access control mechanism, it's highly recommended to implement such a mechanism to prevent unauthorized access to certain functions (like `setAdmin`). \n\nThis representation may not cover all aspects of the original contract. Please use it as a start point and adjust according to your needs. \n\nAnd always remember to test your smart contract thoroughly before deploying it to the mainnet.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468737,
	"id": "chatcmpl-8R625YRrh6AhkdBLb8GGnLiEDceUk",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 15:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint256 _direct_drop_rate; // STORAGE[0xa]\nuint256 _direct_drop_range_start; // STORAGE[0xd]\nuint256 _direct_drop_range_end; // STORAGE[0xe]\naddress _admin_address; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _direct_drop_switch; // STORAGE[0x9] bytes 0 to 0\nuint160 _account_address; // STORAGE[0x1] bytes 0 to 19\nuint160 _direct_drop_address; // STORAGE[0xb] bytes 0 to 19\naddress _direct_drop_withdraw_address; // STORAGE[0xc] bytes 0 to 19\nuint8 _direct_drop_range; // STORAGE[0xc] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction fallback() public payable { \n    v0 = 0x927(msg.sender);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction direct_drop_withdraw_address() public nonPayable { \n    return _direct_drop_withdraw_address;\n}\n\nfunction 0x1e8b(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction withDraw() public nonPayable { \n    v0 = v1 = msg.sender == _admin_address;\n    if (msg.sender != _admin_address) {\n        v0 = msg.sender == _direct_drop_withdraw_address;\n    }\n    require(v0);\n    require((address(this)).balance > 0);\n    v2 = _direct_drop_withdraw_address.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction direct_drop_rate() public nonPayable { \n    return _direct_drop_rate;\n}\n\nfunction direct_drop_range_end() public nonPayable { \n    return _direct_drop_range_end;\n}\n\nfunction direct_drop_switch() public nonPayable { \n    return _direct_drop_switch;\n}\n\nfunction setDirectDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _direct_drop_switch = varg0;\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction direct_drop_range_start() public nonPayable { \n    return _direct_drop_range_start;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction account_address() public nonPayable { \n    return _account_address;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    require(varg0 != 0);\n    _admin_address = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction direct_drop_address() public nonPayable { \n    return _direct_drop_address;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction direct_drop_range() public nonPayable { \n    return _direct_drop_range;\n}\n\nfunction buyTokens(address varg0) public payable { \n    v0 = 0x927(varg0);\n    return v0;\n}\n\nfunction admin_address() public nonPayable { \n    return _admin_address;\n}\n\nfunction 0x927(uint256 varg0) private { \n    require(_direct_drop_switch);\n    require(address(varg0) != 0);\n    if (_direct_drop_range) {\n        v0 = v1 = block.timestamp >= _direct_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _direct_drop_range_end;\n        }\n        require(v0);\n    }\n    v3 = 0x1e8b(_direct_drop_rate, msg.value);\n    assert(0xde0b6b3a7640000);\n    v4 = 0x1e8b(v3 / 0xde0b6b3a7640000, 10 ** _decimals);\n    require(_balanceOf[_direct_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] >= _balanceOf[_direct_drop_address]);\n    assert(v4 <= _balanceOf[_direct_drop_address]);\n    _balanceOf[_direct_drop_address] = _balanceOf[_direct_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v8] >= _balanceOf[_direct_drop_address]);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] == _balanceOf[_direct_drop_address] + _balanceOf[v8]);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3 / 0xde0b6b3a7640000);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x9451cb2 == function_selector) {\n            direct_drop_withdraw_address();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xfdb1c10 == function_selector) {\n            withDraw();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x324f8ac9 == function_selector) {\n            direct_drop_rate();\n        } else if (0x32d76483 == function_selector) {\n            direct_drop_range_end();\n        } else if (0x3381601e == function_selector) {\n            direct_drop_switch();\n        } else if (0x41ec2ec6 == function_selector) {\n            setDirectDrop(bool);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x44272b2f == function_selector) {\n            direct_drop_range_start();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x661be157 == function_selector) {\n            account_address();\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd373f4ee == function_selector) {\n            direct_drop_address();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xec78aa0f == function_selector) {\n            direct_drop_range();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2e62772 == function_selector) {\n            admin_address();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 15:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint256 _direct_drop_rate; // STORAGE[0xa]\nuint256 _direct_drop_range_start; // STORAGE[0xd]\nuint256 _direct_drop_range_end; // STORAGE[0xe]\naddress _admin_address; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _direct_drop_switch; // STORAGE[0x9] bytes 0 to 0\nuint160 _account_address; // STORAGE[0x1] bytes 0 to 19\nuint160 _direct_drop_address; // STORAGE[0xb] bytes 0 to 19\naddress _direct_drop_withdraw_address; // STORAGE[0xc] bytes 0 to 19\nuint8 _direct_drop_range; // STORAGE[0xc] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction fallback() public payable { \n    v0 = 0x927(msg.sender);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction direct_drop_withdraw_address() public nonPayable { \n    return _direct_drop_withdraw_address;\n}\n\nfunction 0x1e8b(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction withDraw() public nonPayable { \n    v0 = v1 = msg.sender == _admin_address;\n    if (msg.sender != _admin_address) {\n        v0 = msg.sender == _direct_drop_withdraw_address;\n    }\n    require(v0);\n    require((address(this)).balance > 0);\n    v2 = _direct_drop_withdraw_address.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction direct_drop_rate() public nonPayable { \n    return _direct_drop_rate;\n}\n\nfunction direct_drop_range_end() public nonPayable { \n    return _direct_drop_range_end;\n}\n\nfunction direct_drop_switch() public nonPayable { \n    return _direct_drop_switch;\n}\n\nfunction setDirectDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _direct_drop_switch = varg0;\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction direct_drop_range_start() public nonPayable { \n    return _direct_drop_range_start;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction account_address() public nonPayable { \n    return _account_address;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    require(varg0 != 0);\n    _admin_address = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction direct_drop_address() public nonPayable { \n    return _direct_drop_address;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction direct_drop_range() public nonPayable { \n    return _direct_drop_range;\n}\n\nfunction buyTokens(address varg0) public payable { \n    v0 = 0x927(varg0);\n    return v0;\n}\n\nfunction admin_address() public nonPayable { \n    return _admin_address;\n}\n\nfunction 0x927(uint256 varg0) private { \n    require(_direct_drop_switch);\n    require(address(varg0) != 0);\n    if (_direct_drop_range) {\n        v0 = v1 = block.timestamp >= _direct_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _direct_drop_range_end;\n        }\n        require(v0);\n    }\n    v3 = 0x1e8b(_direct_drop_rate, msg.value);\n    assert(0xde0b6b3a7640000);\n    v4 = 0x1e8b(v3 / 0xde0b6b3a7640000, 10 ** _decimals);\n    require(_balanceOf[_direct_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] >= _balanceOf[_direct_drop_address]);\n    assert(v4 <= _balanceOf[_direct_drop_address]);\n    _balanceOf[_direct_drop_address] = _balanceOf[_direct_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v8] >= _balanceOf[_direct_drop_address]);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] == _balanceOf[_direct_drop_address] + _balanceOf[v8]);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3 / 0xde0b6b3a7640000);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x9451cb2 == function_selector) {\n            direct_drop_withdraw_address();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xfdb1c10 == function_selector) {\n            withDraw();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x324f8ac9 == function_selector) {\n            direct_drop_rate();\n        } else if (0x32d76483 == function_selector) {\n            direct_drop_range_end();\n        } else if (0x3381601e == function_selector) {\n            direct_drop_switch();\n        } else if (0x41ec2ec6 == function_selector) {\n            setDirectDrop(bool);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x44272b2f == function_selector) {\n            direct_drop_range_start();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x661be157 == function_selector) {\n            account_address();\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd373f4ee == function_selector) {\n            direct_drop_address();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xec78aa0f == function_selector) {\n            direct_drop_range();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2e62772 == function_selector) {\n            admin_address();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 15:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint256 _direct_drop_rate; // STORAGE[0xa]\nuint256 _direct_drop_range_start; // STORAGE[0xd]\nuint256 _direct_drop_range_end; // STORAGE[0xe]\naddress _admin_address; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _direct_drop_switch; // STORAGE[0x9] bytes 0 to 0\nuint160 _account_address; // STORAGE[0x1] bytes 0 to 19\nuint160 _direct_drop_address; // STORAGE[0xb] bytes 0 to 19\naddress _direct_drop_withdraw_address; // STORAGE[0xc] bytes 0 to 19\nuint8 _direct_drop_range; // STORAGE[0xc] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction fallback() public payable { \n    v0 = 0x927(msg.sender);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction direct_drop_withdraw_address() public nonPayable { \n    return _direct_drop_withdraw_address;\n}\n\nfunction 0x1e8b(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction withDraw() public nonPayable { \n    v0 = v1 = msg.sender == _admin_address;\n    if (msg.sender != _admin_address) {\n        v0 = msg.sender == _direct_drop_withdraw_address;\n    }\n    require(v0);\n    require((address(this)).balance > 0);\n    v2 = _direct_drop_withdraw_address.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction direct_drop_rate() public nonPayable { \n    return _direct_drop_rate;\n}\n\nfunction direct_drop_range_end() public nonPayable { \n    return _direct_drop_range_end;\n}\n\nfunction direct_drop_switch() public nonPayable { \n    return _direct_drop_switch;\n}\n\nfunction setDirectDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _direct_drop_switch = varg0;\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction direct_drop_range_start() public nonPayable { \n    return _direct_drop_range_start;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction account_address() public nonPayable { \n    return _account_address;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    require(varg0 != 0);\n    _admin_address = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction direct_drop_address() public nonPayable { \n    return _direct_drop_address;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction direct_drop_range() public nonPayable { \n    return _direct_drop_range;\n}\n\nfunction buyTokens(address varg0) public payable { \n    v0 = 0x927(varg0);\n    return v0;\n}\n\nfunction admin_address() public nonPayable { \n    return _admin_address;\n}\n\nfunction 0x927(uint256 varg0) private { \n    require(_direct_drop_switch);\n    require(address(varg0) != 0);\n    if (_direct_drop_range) {\n        v0 = v1 = block.timestamp >= _direct_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _direct_drop_range_end;\n        }\n        require(v0);\n    }\n    v3 = 0x1e8b(_direct_drop_rate, msg.value);\n    assert(0xde0b6b3a7640000);\n    v4 = 0x1e8b(v3 / 0xde0b6b3a7640000, 10 ** _decimals);\n    require(_balanceOf[_direct_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] >= _balanceOf[_direct_drop_address]);\n    assert(v4 <= _balanceOf[_direct_drop_address]);\n    _balanceOf[_direct_drop_address] = _balanceOf[_direct_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v8] >= _balanceOf[_direct_drop_address]);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] == _balanceOf[_direct_drop_address] + _balanceOf[v8]);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3 / 0xde0b6b3a7640000);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x9451cb2 == function_selector) {\n            direct_drop_withdraw_address();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xfdb1c10 == function_selector) {\n            withDraw();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x324f8ac9 == function_selector) {\n            direct_drop_rate();\n        } else if (0x32d76483 == function_selector) {\n            direct_drop_range_end();\n        } else if (0x3381601e == function_selector) {\n            direct_drop_switch();\n        } else if (0x41ec2ec6 == function_selector) {\n            setDirectDrop(bool);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x44272b2f == function_selector) {\n            direct_drop_range_start();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x661be157 == function_selector) {\n            account_address();\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xd373f4ee == function_selector) {\n            direct_drop_address();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xec78aa0f == function_selector) {\n            direct_drop_range();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2e62772 == function_selector) {\n            admin_address();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.70425248146057,
	"usage": {
		"completion_tokens": 641,
		"prompt_tokens": 3188,
		"total_tokens": 3829
	}
}