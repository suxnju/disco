{
	"address": "0x69d1ef860246fa242041bf1d784e8cb43e2a9b07",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, here is the Solidity version. Please note that this Solidity version is a rough translation and might not function exactly as the original contract. \n\n```solidity\npragma solidity ^0.5.16;\n\ncontract SmartContract {\n    mapping (address => uint256) private _investorInfo;\n    mapping (address => uint256) private owner_1;\n    mapping (address => uint256) private owner_2;\n    mapping (address => uint256) private owner_3;\n    address private constant ADDRESS = 0x27fe767c1da8a69731c64f15d6ee98ee8af62e72;\n\n    function investorInfo(address varg0) public view returns (uint256, uint256, uint256, uint256, uint256) {\n        require(msg.data.length - 4 >= 32);\n        int256 v0 = 1440 - int256((block.number - owner_3[varg0]) >> 2);\n        if (v0 < 0) {\n            v0 = 0;\n        }\n        return (_investorInfo[varg0], (_investorInfo[varg0] << 1) - owner_3[varg0], owner_3[varg0], uint256(v0), owner_3[varg0]);\n    }\n\n    function () external payable {\n        if (msg.value < 1000) {\n            bool v0 = owner_3[msg.sender] << 1 > owner_3[msg.sender];\n            if (v0) {\n                v0 = block.number - owner_1[msg.sender] > 5900;\n            }\n            if (v0) {\n                owner_3[msg.sender] += owner_2[msg.sender];\n                (bool v3,) = msg.sender.call.value(owner_2[msg.sender]).gas(2300 * uint256(!owner_2[msg.sender]))(\"\");\n                require(v3);\n            }\n        } else {\n            (bool v4,) = ADDRESS.call.value(msg.value / 10).gas(2300 * uint256(!(msg.value / 10)))(\"\");\n            require(v4);\n            if (_investorInfo[msg.sender] == 0) {\n                owner_1[msg.sender] = block.number;\n            }\n            _investorInfo[msg.sender] += msg.value;\n            _investorInfo[msg.sender] += msg.value / 20;\n            owner_3[msg.sender] = ((msg.value / 20 + _investorInfo[msg.sender] << 1) - owner_3[msg.sender]) / 40;\n        }\n    }\n}\n```\nPlease note that because of the limitations of solidity language and the complexity of EVM bytecode, not all features and behaviors can be precisely translated into Solidity. For example, the manipulation of memory like `MEM[32] = 2;` and `MEM[v5.data + msg.data.length] = 0;` can't be precisely translated into Solidity language. The contract might behave differently than expected.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469722,
	"id": "chatcmpl-8R6Hybs4SqAfcksSodanyN7OPOYLP",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 00:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _investorInfo; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\n\n\nfunction investorInfo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 1440 - (block.number - owner_3[varg0] >> 2);\n    if (v1 < 0) {\n        v0 = v2 = 0;\n    }\n    return _investorInfo[varg0], (_investorInfo[varg0] << 1) - owner_3[varg0], owner_3[varg0], v0, owner_3[varg0];\n}\n\nfunction fallback() public payable { \n    if (msg.value < 1000) {\n        v0 = v1 = owner_3[msg.sender] << 1 > owner_3[msg.sender];\n        if (v1) {\n            v0 = v2 = block.number - owner_1[msg.sender] > 5900;\n        }\n        if (v0) {\n            owner_3[msg.sender] += owner_2[msg.sender];\n            MEM[32] = 2;\n            v3 = msg.sender.call().value(owner_2[msg.sender]).gas(2300 * !owner_2[msg.sender]);\n            require(v3); // checks call status, propagates error data on error\n        }\n    } else {\n        v4 = 0x27fe767c1da8a69731c64f15d6ee98ee8af62e72.call().value(msg.value / 10).gas(2300 * !(msg.value / 10));\n        require(v4); // checks call status, propagates error data on error\n        if (!_investorInfo[msg.sender]) {\n            owner_1[msg.sender] = block.number;\n        }\n        _investorInfo[msg.sender] += msg.value;\n        v5 = new bytes[](msg.data.length);\n        CALLDATACOPY(v5.data, 0, msg.data.length);\n        MEM[v5.data + msg.data.length] = 0;\n        v6 = v7 = _investorInfo[address(MEM[20 + v5])];\n        if (_investorInfo[address(MEM[20 + v5])]) {\n            v6 = v8 = msg.sender != address(MEM[20 + v5]);\n        }\n        if (v6) {\n            _investorInfo[address(MEM[20 + v5])] += msg.value / 20;\n        }\n        _investorInfo[msg.sender] += msg.value / 20;\n        owner_3[msg.sender] = ((msg.value / 20 + _investorInfo[msg.sender] << 1) - owner_3[msg.sender]) / 40;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xdbcbaca4) {\n            investorInfo(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 00:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _investorInfo; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\n\n\nfunction investorInfo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 1440 - (block.number - owner_3[varg0] >> 2);\n    if (v1 < 0) {\n        v0 = v2 = 0;\n    }\n    return _investorInfo[varg0], (_investorInfo[varg0] << 1) - owner_3[varg0], owner_3[varg0], v0, owner_3[varg0];\n}\n\nfunction fallback() public payable { \n    if (msg.value < 1000) {\n        v0 = v1 = owner_3[msg.sender] << 1 > owner_3[msg.sender];\n        if (v1) {\n            v0 = v2 = block.number - owner_1[msg.sender] > 5900;\n        }\n        if (v0) {\n            owner_3[msg.sender] += owner_2[msg.sender];\n            MEM[32] = 2;\n            v3 = msg.sender.call().value(owner_2[msg.sender]).gas(2300 * !owner_2[msg.sender]);\n            require(v3); // checks call status, propagates error data on error\n        }\n    } else {\n        v4 = 0x27fe767c1da8a69731c64f15d6ee98ee8af62e72.call().value(msg.value / 10).gas(2300 * !(msg.value / 10));\n        require(v4); // checks call status, propagates error data on error\n        if (!_investorInfo[msg.sender]) {\n            owner_1[msg.sender] = block.number;\n        }\n        _investorInfo[msg.sender] += msg.value;\n        v5 = new bytes[](msg.data.length);\n        CALLDATACOPY(v5.data, 0, msg.data.length);\n        MEM[v5.data + msg.data.length] = 0;\n        v6 = v7 = _investorInfo[address(MEM[20 + v5])];\n        if (_investorInfo[address(MEM[20 + v5])]) {\n            v6 = v8 = msg.sender != address(MEM[20 + v5]);\n        }\n        if (v6) {\n            _investorInfo[address(MEM[20 + v5])] += msg.value / 20;\n        }\n        _investorInfo[msg.sender] += msg.value / 20;\n        owner_3[msg.sender] = ((msg.value / 20 + _investorInfo[msg.sender] << 1) - owner_3[msg.sender]) / 40;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xdbcbaca4) {\n            investorInfo(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 00:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _investorInfo; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\n\n\nfunction investorInfo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 1440 - (block.number - owner_3[varg0] >> 2);\n    if (v1 < 0) {\n        v0 = v2 = 0;\n    }\n    return _investorInfo[varg0], (_investorInfo[varg0] << 1) - owner_3[varg0], owner_3[varg0], v0, owner_3[varg0];\n}\n\nfunction fallback() public payable { \n    if (msg.value < 1000) {\n        v0 = v1 = owner_3[msg.sender] << 1 > owner_3[msg.sender];\n        if (v1) {\n            v0 = v2 = block.number - owner_1[msg.sender] > 5900;\n        }\n        if (v0) {\n            owner_3[msg.sender] += owner_2[msg.sender];\n            MEM[32] = 2;\n            v3 = msg.sender.call().value(owner_2[msg.sender]).gas(2300 * !owner_2[msg.sender]);\n            require(v3); // checks call status, propagates error data on error\n        }\n    } else {\n        v4 = 0x27fe767c1da8a69731c64f15d6ee98ee8af62e72.call().value(msg.value / 10).gas(2300 * !(msg.value / 10));\n        require(v4); // checks call status, propagates error data on error\n        if (!_investorInfo[msg.sender]) {\n            owner_1[msg.sender] = block.number;\n        }\n        _investorInfo[msg.sender] += msg.value;\n        v5 = new bytes[](msg.data.length);\n        CALLDATACOPY(v5.data, 0, msg.data.length);\n        MEM[v5.data + msg.data.length] = 0;\n        v6 = v7 = _investorInfo[address(MEM[20 + v5])];\n        if (_investorInfo[address(MEM[20 + v5])]) {\n            v6 = v8 = msg.sender != address(MEM[20 + v5]);\n        }\n        if (v6) {\n            _investorInfo[address(MEM[20 + v5])] += msg.value / 20;\n        }\n        _investorInfo[msg.sender] += msg.value / 20;\n        owner_3[msg.sender] = ((msg.value / 20 + _investorInfo[msg.sender] << 1) - owner_3[msg.sender]) / 40;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xdbcbaca4) {\n            investorInfo(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 22.47695755958557,
	"usage": {
		"completion_tokens": 624,
		"prompt_tokens": 823,
		"total_tokens": 1447
	}
}