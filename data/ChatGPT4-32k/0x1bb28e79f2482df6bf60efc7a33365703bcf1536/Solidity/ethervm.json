{
	"address": "0x1bb28e79f2482df6bf60efc7a33365703bcf1536",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code equivalent to the given decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Contract {\n    mapping(address => uint256) private hodlerBalances;\n    uint256 private constant PARTY_TRIGGER = 0x5f220d80;\n\n    function () external payable {\n        if (msg.data.length == 0) {\n            hodlerBalances[msg.sender] += msg.value;\n        } else {\n            revert();\n        }\n    }\n\n    function party() public {\n        require(block.timestamp > PARTY_TRIGGER, \"Party has not started yet\");\n        uint256 balance = hodlerBalances[msg.sender];\n        require(balance > 0, \"No balance to withdraw\");\n        hodlerBalances[msg.sender] = 0;\n\n        (bool success,) = msg.sender.call.value(balance)(\"\");\n        require(success, \"Transfer failed\");\n\n        emit LogWithdrawal(msg.sender, balance);\n    }\n\n    function hodlers(address hodler) public view returns (uint256) {\n        return hodlerBalances[hodler];\n    }\n\n    event LogWithdrawal(address indexed hodler, uint256 amount);\n}\n```\n\nThis contract allows users to send ether to it, which is then tracked in the `hodlerBalances` mapping. The `party` function allows users to withdraw their ether, but only after a certain timestamp (`PARTY_TRIGGER`). The `hodlers` function allows anyone to check the balance of a hodler.\n\nNote: The above contract does not exactly match the EVM Bytecode, as it lacks some details like dispatch table entries. It's also worth mentioning that directly interacting with memory and storage like the EVM Bytecode does is not something that's done in high-level Solidity code - the compiler handles these details.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474009,
	"id": "chatcmpl-8MvG5nou95jhvOAGlIJRFkjVYUlB0",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) {\n        label_004A:\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            var temp0 = keccak256(memory[0x00:0x40]);\n            storage[temp0] = storage[temp0] + msg.value;\n            var temp1 = memory[0x40:0x60];\n            log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x115522125a340a348d82c36b243d9dcbb357931a24824ddbe1d13179155e3091, msg.sender, msg.value]);\n            stop();\n        } else {\n            var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x354284f2) {\n                // Dispatch table entry for party()\n                if (msg.value) { assert(); }\n            \n                var var1 = 0x00f7;\n                party();\n                stop();\n            } else if (var0 == 0x4a3f17e7) {\n                // Dispatch table entry for hodlers(address)\n                if (msg.value) { assert(); }\n            \n                var1 = 0x012d;\n                var var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n                var2 = hodlers(var2);\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = var2;\n                var temp3 = memory[0x40:0x60];\n                return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n            } else { goto label_004A; }\n        }\n    }\n    \n    function party() {\n        var var0 = 0x00;\n        var var1 = block.timestamp > 0x5f220d80;\n    \n        if (var1) {\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n        \n            if (storage[keccak256(memory[0x00:0x40])] > 0x00) { goto label_01A3; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var1) {\n        label_01A3:\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            var temp0 = storage[keccak256(memory[0x00:0x40])];\n            var0 = temp0;\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            storage[keccak256(memory[0x00:0x40])] = 0x00;\n            var temp1 = memory[0x40:0x60];\n            var temp2;\n            temp2, memory[temp1:temp1 + 0x00] = address(msg.sender).call.gas(!var0 * 0x08fc).value(var0)(memory[temp1:temp1 + memory[0x40:0x60] - temp1]);\n        \n            if (!temp2) { assert(); }\n        \n            var temp3 = memory[0x40:0x60];\n            log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x0dc8f43545dbeec87c6f54e44dac2d8889f2a4b3bf0f62683cd7e1c6346128e7, msg.sender, stack[-1]]);\n            return;\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function hodlers(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x00;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) {\n        label_004A:\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            var temp0 = keccak256(memory[0x00:0x40]);\n            storage[temp0] = storage[temp0] + msg.value;\n            var temp1 = memory[0x40:0x60];\n            log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x115522125a340a348d82c36b243d9dcbb357931a24824ddbe1d13179155e3091, msg.sender, msg.value]);\n            stop();\n        } else {\n            var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x354284f2) {\n                // Dispatch table entry for party()\n                if (msg.value) { assert(); }\n            \n                var var1 = 0x00f7;\n                party();\n                stop();\n            } else if (var0 == 0x4a3f17e7) {\n                // Dispatch table entry for hodlers(address)\n                if (msg.value) { assert(); }\n            \n                var1 = 0x012d;\n                var var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n                var2 = hodlers(var2);\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = var2;\n                var temp3 = memory[0x40:0x60];\n                return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n            } else { goto label_004A; }\n        }\n    }\n    \n    function party() {\n        var var0 = 0x00;\n        var var1 = block.timestamp > 0x5f220d80;\n    \n        if (var1) {\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n        \n            if (storage[keccak256(memory[0x00:0x40])] > 0x00) { goto label_01A3; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var1) {\n        label_01A3:\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            var temp0 = storage[keccak256(memory[0x00:0x40])];\n            var0 = temp0;\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            storage[keccak256(memory[0x00:0x40])] = 0x00;\n            var temp1 = memory[0x40:0x60];\n            var temp2;\n            temp2, memory[temp1:temp1 + 0x00] = address(msg.sender).call.gas(!var0 * 0x08fc).value(var0)(memory[temp1:temp1 + memory[0x40:0x60] - temp1]);\n        \n            if (!temp2) { assert(); }\n        \n            var temp3 = memory[0x40:0x60];\n            log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x0dc8f43545dbeec87c6f54e44dac2d8889f2a4b3bf0f62683cd7e1c6346128e7, msg.sender, stack[-1]]);\n            return;\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function hodlers(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x00;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) {\n        label_004A:\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            var temp0 = keccak256(memory[0x00:0x40]);\n            storage[temp0] = storage[temp0] + msg.value;\n            var temp1 = memory[0x40:0x60];\n            log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x115522125a340a348d82c36b243d9dcbb357931a24824ddbe1d13179155e3091, msg.sender, msg.value]);\n            stop();\n        } else {\n            var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n        \n            if (var0 == 0x354284f2) {\n                // Dispatch table entry for party()\n                if (msg.value) { assert(); }\n            \n                var var1 = 0x00f7;\n                party();\n                stop();\n            } else if (var0 == 0x4a3f17e7) {\n                // Dispatch table entry for hodlers(address)\n                if (msg.value) { assert(); }\n            \n                var1 = 0x012d;\n                var var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n                var2 = hodlers(var2);\n                var temp2 = memory[0x40:0x60];\n                memory[temp2:temp2 + 0x20] = var2;\n                var temp3 = memory[0x40:0x60];\n                return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n            } else { goto label_004A; }\n        }\n    }\n    \n    function party() {\n        var var0 = 0x00;\n        var var1 = block.timestamp > 0x5f220d80;\n    \n        if (var1) {\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n        \n            if (storage[keccak256(memory[0x00:0x40])] > 0x00) { goto label_01A3; }\n            else { revert(memory[0x00:0x00]); }\n        } else if (var1) {\n        label_01A3:\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            var temp0 = storage[keccak256(memory[0x00:0x40])];\n            var0 = temp0;\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = 0x00;\n            storage[keccak256(memory[0x00:0x40])] = 0x00;\n            var temp1 = memory[0x40:0x60];\n            var temp2;\n            temp2, memory[temp1:temp1 + 0x00] = address(msg.sender).call.gas(!var0 * 0x08fc).value(var0)(memory[temp1:temp1 + memory[0x40:0x60] - temp1]);\n        \n            if (!temp2) { assert(); }\n        \n            var temp3 = memory[0x40:0x60];\n            log(memory[temp3:temp3 + memory[0x40:0x60] - temp3], [0x0dc8f43545dbeec87c6f54e44dac2d8889f2a4b3bf0f62683cd7e1c6346128e7, msg.sender, stack[-1]]);\n            return;\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function hodlers(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x00;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 17.518544912338257,
	"usage": {
		"completion_tokens": 368,
		"prompt_tokens": 1035,
		"total_tokens": 1403
	}
}