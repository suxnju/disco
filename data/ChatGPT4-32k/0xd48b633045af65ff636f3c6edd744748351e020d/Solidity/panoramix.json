{
	"address": "0xd48b633045af65ff636f3c6edd744748351e020d",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst icoHashedPass = 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  stakingRequirement is uint256 at storage 0\n  name is array of uint256 at storage 1\n  symbol is array of uint256 at storage 2\n  stor3 is address at storage 3\n  balanceOf is mapping of uint256 at storage 5\n  dividendTokenBalanceOf is mapping of uint256 at storage 6\n  allowed is mapping of uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n  stor9 is mapping of uint8 at storage 9\n  stor10 is mapping of uint8 at storage 10\n  stor11 is mapping of uint256 at storage 11\n  stor12 is mapping of uint256 at storage 12\n  stor14 is uint256 at storage 14\n  ethInvestedDuringICO is uint256 at storage 15\n  currentEthInvested is uint256 at storage 16\n  frontEndTokenSupply is uint256 at storage 17\n  stor18 is uint256 at storage 18\n  stor19 is uint256 at storage 19\n  stor20 is mapping of uint8 at storage 20\n  icoPhase is uint8 at storage 21\n  regularPhase is uint8 at storage 21 offset 8\n  stor22 is uint256 at storage 22\n\ndef totalEthereumICOReceived(): # not payable\n  return ethInvestedDuringICO\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return frontEndTokenSupply\n\ndef currentEthInvested(): # not payable\n  return currentEthInvested\n\ndef regularPhase(): # not payable\n  return bool(regularPhase)\n\ndef getFrontEndTokenBalanceOf(address _customerAddress): # not payable\n  return balanceOf[address(_customerAddress)]\n\ndef getDividendTokenBalanceOf(address _customerAddress): # not payable\n  return uint256(dividendTokenBalanceOf[address(_customerAddress)])\n\ndef stakingRequirement(): # not payable\n  return stakingRequirement\n\ndef allowed(address _param1, address _param2): # not payable\n  return allowed[_param1][_param2]\n\ndef ethInvestedDuringICO(): # not payable\n  return ethInvestedDuringICO\n\ndef myDividendTokens(): # not payable\n  return uint256(dividendTokenBalanceOf[caller])\n\ndef icoPhase(): # not payable\n  return bool(icoPhase)\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef administrators(address _param1): # not payable\n  return bool(stor20[_param1])\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef getFrontEndTokenSupply(): # not payable\n  return frontEndTokenSupply\n\n#\n#  Regular functions\n#\n\ndef injectEther() payable: \n  require stor20[caller]\n\ndef startRegularPhase(): # not payable\n  require stor20[caller]\n  icoPhase = 0\n  regularPhase = 1\n\ndef publicStartRegularPhase(): # not payable\n  require block.timestamp > stor22 + (336 * 24 * 3600)\n  require stor22\n  icoPhase = 0\n  regularPhase = 1\n\ndef getMyAverageDividendRate(): # not payable\n  require balanceOf[caller]\n  return (Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller])\n\ndef setStakingRequirement(uint256 _amountOfTokens): # not payable\n  require stor20[caller]\n  require _amountOfTokens >= 100 * 10^18\n  stakingRequirement = _amountOfTokens\n\ndef setAdministrator(address _identifier, bool _status): # not payable\n  require stor20[caller]\n  stor20[address(_identifier)] = uint8(_status)\n\ndef sqrt(uint256 y): # not payable\n  s = y + 1 / 2\n  t = y\n  while s < t:\n      require s\n      s = (y / s) + s / 2\n      t = s\n      continue \n  return t\n\ndef dividendsOf(address _customerAddress): # not payable\n  return (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_customerAddress)]) * stor19) - stor12[address(_customerAddress)]) >> 64)\n\ndef approve(address spender, uint256 amount): # not payable\n  allowed[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return ((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller])\n  return (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64)\n\ndef withdraw(address _asset): # not payable\n  require (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller] > 0\n  require regularPhase\n  stor12[caller] += Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller])\n  stor11[caller] = 0\n  if _asset:\n      call _asset with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller]),\n            uint256 ethereumWithdrawn=_asset)\n  else:\n      call caller with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller]),\n            uint256 ethereumWithdrawn=caller)\n\ndef transferTo(address _from, address _to, uint256 _amountOfTokens, bytes _data): # not payable\n  require _amountOfTokens >= 10^10\n  require _amountOfTokens <= balanceOf[address(_from)]\n  if caller == _from:\n  else:\n      require _amountOfTokens <= allowed[address(_from)][caller]\n  require regularPhase\n  require _to\n  if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor19) - stor12[address(_from)]) >> 64) + stor11[address(_from)] > 0:\n      stor12[address(_from)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor19) - stor12[address(_from)])\n      stor11[address(_from)] = 0\n      call _from with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor19) - stor12[address(_from)]) >> 64) + stor11[address(_from)] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_from)]) * stor19) - stor12[address(_from)]) >> 64) + stor11[address(_from)]),\n            uint256 ethereumWithdrawn=_from)\n  require balanceOf[address(_from)]\n  if not _amountOfTokens:\n      if _from != caller:\n          allowed[address(_from)][caller] -= _amountOfTokens\n      require _amountOfTokens <= balanceOf[address(_from)]\n      balanceOf[address(_from)] -= _amountOfTokens\n      require _amountOfTokens + balanceOf[_to] >= balanceOf[_to]\n      balanceOf[address(_to)] = _amountOfTokens + balanceOf[_to]\n      require 0 <= uint256(dividendTokenBalanceOf[address(_from)])\n      require uint256(dividendTokenBalanceOf[_to]) >= uint256(dividendTokenBalanceOf[_to])\n      uint256(dividendTokenBalanceOf[address(_to)]) = uint256(dividendTokenBalanceOf[_to])\n      if not stor9[address(_to)]:\n          stor9[address(_to)] = 1\n          stor10[_to] = stor10[address(_from)]\n  else:\n      require Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens / _amountOfTokens == Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)]\n      if _from != caller:\n          allowed[address(_from)][caller] -= _amountOfTokens\n      require _amountOfTokens <= balanceOf[address(_from)]\n      balanceOf[address(_from)] -= _amountOfTokens\n      require _amountOfTokens + balanceOf[_to] >= balanceOf[_to]\n      balanceOf[address(_to)] = _amountOfTokens + balanceOf[_to]\n      require Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64 <= uint256(dividendTokenBalanceOf[address(_from)])\n      uint256(dividendTokenBalanceOf[address(_from)]) -= Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64\n      require (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64) + uint256(dividendTokenBalanceOf[_to]) >= uint256(dividendTokenBalanceOf[_to])\n      uint256(dividendTokenBalanceOf[address(_to)]) = (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64) + uint256(dividendTokenBalanceOf[_to])\n      if not stor9[address(_to)]:\n          stor9[address(_to)] = 1\n          stor10[_to] = stor10[address(_from)]\n      stor12[address(_from)] += -1 * Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64 * stor19\n      stor12[_to] += Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(_from)]) / balanceOf[address(_from)] * _amountOfTokens) >> 64 * stor19\n  if ext_code.size(_to) > 0:\n      require ext_code.size(_to)\n      call _to.tokenFallback(address _from, uint256 _value, bytes _data) with:\n           gas gas_remaining wei\n          args address(_from), _amountOfTokens, Array(len=_data.length, data=_data[all])\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n  log Transfer(\n        address from=_amountOfTokens,\n        address to=_from,\n        uint256 value=_to)\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require amount >= 10^10\n  require amount <= balanceOf[address(sender)]\n  require amount <= allowed[address(sender)][caller]\n  require regularPhase\n  require recipient\n  if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor19) - stor12[address(sender)]) >> 64) + stor11[address(sender)] > 0:\n      stor12[address(sender)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor19) - stor12[address(sender)])\n      stor11[address(sender)] = 0\n      call sender with:\n         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor19) - stor12[address(sender)]) >> 64) + stor11[address(sender)] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(sender)]) * stor19) - stor12[address(sender)]) >> 64) + stor11[address(sender)]),\n            uint256 ethereumWithdrawn=sender)\n  require balanceOf[address(sender)]\n  if not amount:\n      if sender != caller:\n          allowed[address(sender)][caller] -= amount\n      require amount <= balanceOf[address(sender)]\n      balanceOf[address(sender)] -= amount\n      require amount + balanceOf[recipient] >= balanceOf[recipient]\n      balanceOf[address(recipient)] = amount + balanceOf[recipient]\n      require 0 <= uint256(dividendTokenBalanceOf[address(sender)])\n      require uint256(dividendTokenBalanceOf[recipient]) >= uint256(dividendTokenBalanceOf[recipient])\n      uint256(dividendTokenBalanceOf[address(recipient)]) = uint256(dividendTokenBalanceOf[recipient])\n      if not stor9[address(recipient)]:\n          stor9[address(recipient)] = 1\n          stor10[recipient] = stor10[address(sender)]\n  else:\n      require Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount / amount == Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)]\n      if sender != caller:\n          allowed[address(sender)][caller] -= amount\n      require amount <= balanceOf[address(sender)]\n      balanceOf[address(sender)] -= amount\n      require amount + balanceOf[recipient] >= balanceOf[recipient]\n      balanceOf[address(recipient)] = amount + balanceOf[recipient]\n      require Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64 <= uint256(dividendTokenBalanceOf[address(sender)])\n      uint256(dividendTokenBalanceOf[address(sender)]) -= Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64\n      require (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64) + uint256(dividendTokenBalanceOf[recipient]) >= uint256(dividendTokenBalanceOf[recipient])\n      uint256(dividendTokenBalanceOf[address(recipient)]) = (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64) + uint256(dividendTokenBalanceOf[recipient])\n      if not stor9[address(recipient)]:\n          stor9[address(recipient)] = 1\n          stor10[recipient] = stor10[address(sender)]\n      stor12[address(sender)] += -1 * Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64 * stor19\n      stor12[recipient] += Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[address(sender)]) / balanceOf[address(sender)] * amount) >> 64 * stor19\n  if ext_code.size(recipient) > 0:\n      mem[228 len 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000] = 0, amount, 96, 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000, mem[228 len 0xc0ee0b89ffffffffffffffffffffffffffffffffffffffffffffffffffffff9c]\n      require ext_code.size(recipient)\n      call recipient.tokenFallback(address _from, uint256 _value, bytes _data) with:\n           gas gas_remaining wei\n          args 0, 0, amount, 96, 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000, mem[228 len 0xc0ee0b8a00000000000000000000000000000000000000000000000000000000]\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  if not _ethereumToSpend:\n      if 0 <= _ethereumToSpend:\n          if _ethereumToSpend <= 10^14:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Tried to buy tokens with too little eth.'\n          if icoPhase:\n              return (10^18 * _ethereumToSpend / 653 * 10^12)\n          if currentEthInvested >= ethInvestedDuringICO:\n              if _ethereumToSpend == _ethereumToSpend:\n                  if _ethereumToSpend:\n                      s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                      t = (frontEndTokenSupply / 9615 * 10^6)^3\n                      while s < t:\n                          require s\n                          s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                          t = s\n                          continue \n                      if not t:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if 2 * t / t == 2:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if currentEthInvested + _ethereumToSpend <= ethInvestedDuringICO:\n                  if _ethereumToSpend == _ethereumToSpend:\n                      if _ethereumToSpend:\n                          if _ethereumToSpend:\n                              if 10^18 * _ethereumToSpend / _ethereumToSpend == 10^18:\n                                  if 10^18 * _ethereumToSpend / 653 * 10^12 > 0:\n                                      return (10^18 * _ethereumToSpend / 653 * 10^12)\n              else:\n                  require currentEthInvested < ethInvestedDuringICO\n                  require currentEthInvested + _ethereumToSpend > ethInvestedDuringICO\n                  if currentEthInvested <= ethInvestedDuringICO:\n                      if ethInvestedDuringICO - currentEthInvested <= _ethereumToSpend:\n                          if _ethereumToSpend == _ethereumToSpend:\n                              if not ethInvestedDuringICO - currentEthInvested:\n                                  if _ethereumToSpend - ethInvestedDuringICO + currentEthInvested:\n                                      s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 2 * t / t == 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                                      if _ethereumToSpend - ethInvestedDuringICO + currentEthInvested:\n                                          s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                          t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 2 * t / t == 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                          if not _ethereumToSpend - ethInvestedDuringICO + currentEthInvested:\n                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                  return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                          else:\n                                              s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                              t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                              while s < t:\n                                                  require s\n                                                  s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 2 * t / t == 2:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if stor10[caller] * _ethereumToSpend / _ethereumToSpend == stor10[caller]:\n          if stor10[caller] * _ethereumToSpend / 100 <= _ethereumToSpend:\n              if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) <= 10^14:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Tried to buy tokens with too little eth.'\n              if icoPhase:\n                  return (10^18 * _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) / 653 * 10^12)\n              if currentEthInvested >= ethInvestedDuringICO:\n                  if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) == _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                      if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                          s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                          t = (frontEndTokenSupply / 9615 * 10^6)^3\n                          while s < t:\n                              require s\n                              s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                              t = s\n                              continue \n                          if not t:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 2 * t / t == 2:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested + _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) <= ethInvestedDuringICO:\n                      if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) == _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                          if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                              if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                                  if (10^18 * _ethereumToSpend) - (10^18 * stor10[caller] * _ethereumToSpend / 100) / _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) == 10^18:\n                                      if (10^18 * _ethereumToSpend) - (10^18 * stor10[caller] * _ethereumToSpend / 100) / 653 * 10^12 > 0:\n                                          return ((10^18 * _ethereumToSpend) - (10^18 * stor10[caller] * _ethereumToSpend / 100) / 653 * 10^12)\n                  else:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                              if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) == _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100):\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                                      if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) - ethInvestedDuringICO + currentEthInvested:\n                                          s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                          t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 2 * t / t == 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not ethInvestedDuringICO - currentEthInvested:\n                                          if _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) - ethInvestedDuringICO + currentEthInvested:\n                                              s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                              t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                              while s < t:\n                                                  require s\n                                                  s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 2 * t / t == 2:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                              if not _ethereumToSpend - (stor10[caller] * _ethereumToSpend / 100) - ethInvestedDuringICO + currentEthInvested:\n                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                      return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                              else:\n                                                  s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                                  t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                                  while s < t:\n                                                      require s\n                                                      s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                      t = s\n                                                      continue \n                                                  if not t:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if 2 * t / t == 2:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef sellPrice(): # not payable\n  if icoPhase:\n      if balanceOf[caller]:\n          if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n              if Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 653 * 10^12:\n                  return (-(Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 653 * 10^12)\n  else:\n      if currentEthInvested < ethInvestedDuringICO:\n          if balanceOf[caller]:\n              if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                  if Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 653 * 10^12:\n                      return (-(Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 653 * 10^12)\n      else:\n          if icoPhase:\n              if balanceOf[caller]:\n                  if 10^15 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 10^15 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                      if Mask(192, 64, 10^15 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 10^15:\n                          return (-(Mask(192, 64, 10^15 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 10^15)\n          else:\n              if currentEthInvested >= ethInvestedDuringICO:\n                  s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                  t = (frontEndTokenSupply / 9615 * 10^6)^3\n                  while s < t:\n                      require s\n                      s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                      t = s\n                      continue \n                  if not t:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if 2 * t / t == 2:\n                      if 2 * t / 3:\n                          if 3 * 2 * t / 3 / 2 * t / 3 == 3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if (2 * t / 3) + 10^15:\n                              if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested + 10^15 <= ethInvestedDuringICO:\n                      if balanceOf[caller]:\n                          if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                              if Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64 <= 653 * 10^12:\n                                  return (-(Mask(192, 64, 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 100) >> 64) + 653 * 10^12)\n                  else:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + 10^15 > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= 10^15:\n                              if not ethInvestedDuringICO - currentEthInvested:\n                                  if -ethInvestedDuringICO + currentEthInvested + 10^15:\n                                      s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          if not ethInvestedDuringICO - currentEthInvested:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if 2 * t / t == 2:\n                                              if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                  if (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              else:\n                                                  if (2 * t / 3) + 10^15:\n                                                      if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                                      if -ethInvestedDuringICO + currentEthInvested + 10^15:\n                                          s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                          t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              if not ethInvestedDuringICO - currentEthInvested:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          else:\n                                              if 2 * t / t == 2:\n                                                  if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                      if (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  else:\n                                                      if (2 * t / 3) + 10^15:\n                                                          if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                          if not -ethInvestedDuringICO + currentEthInvested + 10^15:\n                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                      if balanceOf[caller]:\n                                                          if not 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                              if 0 <= 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                  return (1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                                          else:\n                                                              if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 100) >> 64 <= 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                      return ((1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 100) >> 64))\n                                          else:\n                                              s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                              t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                              while s < t:\n                                                  require s\n                                                  s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  if not ethInvestedDuringICO - currentEthInvested:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              else:\n                                                  if 2 * t / t == 2:\n                                                      if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                          if (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3:\n                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                      else:\n                                                          if (2 * t / 3) + 10^15:\n                                                              if (3 * 2 * t / 3) + 3 * 10^15 / (2 * t / 3) + 10^15 == 3:\n                                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                          else:\n                                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                      if balanceOf[caller]:\n                                                                          if not 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12:\n                                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                                          if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 / 1000000000000000 * 10^18 / (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef ethereumToTokens_(uint256 _ethereum): # not payable\n  if _ethereum <= 10^14:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Tried to buy tokens with too little eth.'\n  if icoPhase:\n      return (10^18 * _ethereum / 653 * 10^12)\n  if currentEthInvested >= ethInvestedDuringICO:\n      if _ethereum == _ethereum:\n          if _ethereum:\n              s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n              t = (frontEndTokenSupply / 9615 * 10^6)^3\n              while s < t:\n                  require s\n                  s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                  t = s\n                  continue \n              if not t:\n                  if _ethereum:\n                      if 3 * _ethereum / _ethereum == 3:\n                          s = (3 * _ethereum / 2)^2 + 1 / 3\n                          t = (3 * _ethereum / 2)^2\n                          while s < t:\n                              require s * s\n                              s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                              t = s\n                              continue \n                          if not t:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 9615 * t / t == 9615:\n                              if 0 <= 9615 * t:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if 2 * t / t == 2:\n                      if 2 * t / 3:\n                          require 3 * 2 * t / 3 / 2 * t / 3 == 3\n                          s = (3 * 2 * t / 3 / 2)^2 + 1 / 3\n                          u = (3 * 2 * t / 3 / 2)^2\n                          while s < u:\n                              require s * s\n                              s = ((3 * 2 * t / 3 / 2)^2 / s * s) + (2 * s) / 3\n                              u = s\n                              continue \n                          if not u:\n                              if not (2 * t / 3) + _ethereum:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 9615 * u / u == 9615\n                          if (2 * t / 3) + _ethereum:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if (2 * t / 3) + _ethereum:\n                          if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                              s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                              u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                              while s < u:\n                                  require s * s\n                                  s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                  u = s\n                                  continue \n                              if not u:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 9615 * u / u == 9615:\n                                  if 0 <= 9615 * u:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if currentEthInvested + _ethereum <= ethInvestedDuringICO:\n          if _ethereum == _ethereum:\n              if _ethereum:\n                  if _ethereum:\n                      if 10^18 * _ethereum / _ethereum == 10^18:\n                          if 10^18 * _ethereum / 653 * 10^12 > 0:\n                              return (10^18 * _ethereum / 653 * 10^12)\n      else:\n          require currentEthInvested < ethInvestedDuringICO\n          require currentEthInvested + _ethereum > ethInvestedDuringICO\n          if currentEthInvested <= ethInvestedDuringICO:\n              if ethInvestedDuringICO - currentEthInvested <= _ethereum:\n                  if _ethereum == _ethereum:\n                      if not ethInvestedDuringICO - currentEthInvested:\n                          if _ethereum - ethInvestedDuringICO + currentEthInvested:\n                              s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                              t = (frontEndTokenSupply / 9615 * 10^6)^3\n                              while s < t:\n                                  require s\n                                  s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                  t = s\n                                  continue \n                              if not t:\n                                  if ethInvestedDuringICO - currentEthInvested:\n                                      require (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3\n                                      s = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                      t = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                      while s < t:\n                                          require s * s\n                                          s = (((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                          t = s\n                                          continue \n                                      if not t:\n                                          if not _ethereum:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 3 * _ethereum / _ethereum == 3\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 9615 * t / t == 9615\n                                      if _ethereum:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if _ethereum:\n                                      if 3 * _ethereum / _ethereum == 3:\n                                          s = (3 * _ethereum / 2)^2 + 1 / 3\n                                          t = (3 * _ethereum / 2)^2\n                                          while s < t:\n                                              require s * s\n                                              s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                                              t = s\n                                              continue \n                                          if not t:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 9615 * t / t == 9615:\n                                              if 0 <= 9615 * t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if 2 * t / t == 2:\n                                      if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                          require (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3\n                                          s = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                          u = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                          while s < u:\n                                              require s * s\n                                              s = (((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                              u = s\n                                              continue \n                                          if not u:\n                                              if not (2 * t / 3) + _ethereum:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 9615 * u / u == 9615\n                                          if (2 * t / 3) + _ethereum:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (2 * t / 3) + _ethereum:\n                                          if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                                              s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                                              u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                                              while s < u:\n                                                  require s * s\n                                                  s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                                  u = s\n                                                  continue \n                                              if not u:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 9615 * u / u == 9615:\n                                                  if 0 <= 9615 * u:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if not ethInvestedDuringICO - currentEthInvested:\n                              if _ethereum - ethInvestedDuringICO + currentEthInvested:\n                                  s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                  t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                  while s < t:\n                                      require s\n                                      s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                      t = s\n                                      continue \n                                  if not t:\n                                      if ethInvestedDuringICO - currentEthInvested:\n                                          require (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3\n                                          s = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                          t = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                          while s < t:\n                                              require s * s\n                                              s = (((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                              t = s\n                                              continue \n                                          if not t:\n                                              if not _ethereum:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require 3 * _ethereum / _ethereum == 3\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require 9615 * t / t == 9615\n                                          if _ethereum:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if _ethereum:\n                                          if 3 * _ethereum / _ethereum == 3:\n                                              s = (3 * _ethereum / 2)^2 + 1 / 3\n                                              t = (3 * _ethereum / 2)^2\n                                              while s < t:\n                                                  require s * s\n                                                  s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if 9615 * t / t == 9615:\n                                                  if 0 <= 9615 * t:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if 2 * t / t == 2:\n                                          if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                              require (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3\n                                              s = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                              u = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                              while s < u:\n                                                  require s * s\n                                                  s = (((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                                  u = s\n                                                  continue \n                                              if not u:\n                                                  if not (2 * t / 3) + _ethereum:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require 9615 * u / u == 9615\n                                              if (2 * t / 3) + _ethereum:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (2 * t / 3) + _ethereum:\n                                              if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                                                  s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                                                  u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                                                  while s < u:\n                                                      require s * s\n                                                      s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                                      u = s\n                                                      continue \n                                                  if not u:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if 9615 * u / u == 9615:\n                                                      if 0 <= 9615 * u:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 10^18:\n                                  if not _ethereum - ethInvestedDuringICO + currentEthInvested:\n                                      if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                          return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                  else:\n                                      s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          if ethInvestedDuringICO - currentEthInvested:\n                                              require (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / ethInvestedDuringICO - currentEthInvested == 3\n                                              s = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                              t = ((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                              while s < t:\n                                                  require s * s\n                                                  s = (((3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                                  t = s\n                                                  continue \n                                              if not t:\n                                                  if not _ethereum:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  require 3 * _ethereum / _ethereum == 3\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              require 9615 * t / t == 9615\n                                              if _ethereum:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if not _ethereum:\n                                              if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                  return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                          else:\n                                              if 3 * _ethereum / _ethereum == 3:\n                                                  s = (3 * _ethereum / 2)^2 + 1 / 3\n                                                  t = (3 * _ethereum / 2)^2\n                                                  while s < t:\n                                                      require s * s\n                                                      s = ((3 * _ethereum / 2)^2 / s * s) + (2 * s) / 3\n                                                      t = s\n                                                      continue \n                                                  if not t:\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  if 9615 * t / t == 9615:\n                                                      if 0 <= 9615 * t:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if 2 * t / t == 2:\n                                              if (2 * t / 3) + ethInvestedDuringICO - currentEthInvested:\n                                                  require (3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / (2 * t / 3) + ethInvestedDuringICO - currentEthInvested == 3\n                                                  s = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 + 1 / 3\n                                                  u = ((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2\n                                                  while s < u:\n                                                      require s * s\n                                                      s = (((3 * 2 * t / 3) + (3 * ethInvestedDuringICO) - (3 * currentEthInvested) / 2)^2 / s * s) + (2 * s) / 3\n                                                      u = s\n                                                      continue \n                                                  if not u:\n                                                      if not (2 * t / 3) + _ethereum:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                      require (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3\n                                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                  require 9615 * u / u == 9615\n                                                  if (2 * t / 3) + _ethereum:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if not (2 * t / 3) + _ethereum:\n                                                  if (10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12 > 0:\n                                                      return ((10^18 * ethInvestedDuringICO) - (10^18 * currentEthInvested) / 653 * 10^12)\n                                              else:\n                                                  if (3 * 2 * t / 3) + (3 * _ethereum) / (2 * t / 3) + _ethereum == 3:\n                                                      s = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 + 1 / 3\n                                                      u = ((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2\n                                                      while s < u:\n                                                          require s * s\n                                                          s = (((3 * 2 * t / 3) + (3 * _ethereum) / 2)^2 / s * s) + (2 * s) / 3\n                                                          u = s\n                                                          continue \n                                                      if not u:\n                                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                                      if 9615 * u / u == 9615:\n                                                          if 0 <= 9615 * u:\n                                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= frontEndTokenSupply\n  if _tokensToSell < 10^14:\n      revert with 0, 'Tried to sell too few tokens.'\n  if frontEndTokenSupply <= stor14:\n      if _tokensToSell == _tokensToSell:\n          if _tokensToSell:\n              if _tokensToSell:\n                  if 653 * 10^12 * _tokensToSell / _tokensToSell == 653 * 10^12:\n                      if 653 * 10^12 * _tokensToSell / 10^18 > 0:\n                          if balanceOf[caller]:\n                              if not 653 * 10^12 * _tokensToSell / 10^18:\n                                  if 0 <= 653 * 10^12 * _tokensToSell / 10^18:\n                                      return (653 * 10^12 * _tokensToSell / 10^18)\n                              else:\n                                  if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 653 * 10^12 * _tokensToSell / 10^18 / 653 * 10^12 * _tokensToSell / 10^18 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                      if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 653 * 10^12 * _tokensToSell / 10^18 / 100) >> 64 <= 653 * 10^12 * _tokensToSell / 10^18:\n                                          return ((653 * 10^12 * _tokensToSell / 10^18) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 653 * 10^12 * _tokensToSell / 10^18 / 100) >> 64))\n  else:\n      if frontEndTokenSupply - _tokensToSell >= stor14:\n          if _tokensToSell == _tokensToSell:\n              if _tokensToSell:\n                  s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                  t = (frontEndTokenSupply / 9615 * 10^6)^3\n                  while s < t:\n                      require s\n                      s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                      t = s\n                      continue \n                  if not t:\n                      s = (frontEndTokenSupply - _tokensToSell / 9615 * 10^6)^3 + 1 / 2\n                      t = (frontEndTokenSupply - _tokensToSell / 9615 * 10^6)^3\n                      while s < t:\n                          require s\n                          s = ((frontEndTokenSupply - _tokensToSell / 9615 * 10^6)^3 / s) + s / 2\n                          t = s\n                          continue \n                      if t:\n                          if 2 * t / t == 2:\n                              if 2 * t / 3 <= 0:\n                                  if -2 * t / 3 > 0:\n                                      if balanceOf[caller]:\n                                          if not -2 * t / 3:\n                                              if 0 <= -2 * t / 3:\n                                                  return -(2 * t / 3)\n                                          else:\n                                              if -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / -2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                  if Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= -2 * t / 3:\n                                                      return (-(2 * t / 3) - (Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                  else:\n                      if 2 * t / t == 2:\n                          s = (frontEndTokenSupply - _tokensToSell / 9615 * 10^6)^3 + 1 / 2\n                          u = (frontEndTokenSupply - _tokensToSell / 9615 * 10^6)^3\n                          while s < u:\n                              require s\n                              s = ((frontEndTokenSupply - _tokensToSell / 9615 * 10^6)^3 / s) + s / 2\n                              u = s\n                              continue \n                          if not u:\n                              if 0 <= 2 * t / 3:\n                                  if 2 * t / 3 > 0:\n                                      if balanceOf[caller]:\n                                          if not 2 * t / 3:\n                                              if 0 <= 2 * t / 3:\n                                                  return (2 * t / 3)\n                                          else:\n                                              if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                  if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= 2 * t / 3:\n                                                      return ((2 * t / 3) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                          else:\n                              if 2 * u / u == 2:\n                                  if 2 * u / 3 <= 2 * t / 3:\n                                      if (2 * t / 3) - (2 * u / 3) > 0:\n                                          if balanceOf[caller]:\n                                              if not (2 * t / 3) - (2 * u / 3):\n                                                  if 0 <= (2 * t / 3) - (2 * u / 3):\n                                                      return ((2 * t / 3) - (2 * u / 3))\n                                              else:\n                                                  if (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                      if Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= (2 * t / 3) - (2 * u / 3):\n                                                          return ((2 * t / 3) - (2 * u / 3) - (Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n      else:\n          require frontEndTokenSupply > stor14\n          require frontEndTokenSupply - _tokensToSell < stor14\n          if stor14 <= frontEndTokenSupply:\n              if frontEndTokenSupply - stor14 <= _tokensToSell:\n                  if _tokensToSell == _tokensToSell:\n                      if not _tokensToSell - frontEndTokenSupply + stor14:\n                          if frontEndTokenSupply - stor14:\n                              s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                              t = (frontEndTokenSupply / 9615 * 10^6)^3\n                              while s < t:\n                                  require s\n                                  s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                  t = s\n                                  continue \n                              if not t:\n                                  s = (stor14 / 9615 * 10^6)^3 + 1 / 2\n                                  t = (stor14 / 9615 * 10^6)^3\n                                  while s < t:\n                                      require s\n                                      s = ((stor14 / 9615 * 10^6)^3 / s) + s / 2\n                                      t = s\n                                      continue \n                                  if t:\n                                      if 2 * t / t == 2:\n                                          if 2 * t / 3 <= 0:\n                                              if -2 * t / 3 > 0:\n                                                  if balanceOf[caller]:\n                                                      if not -2 * t / 3:\n                                                          if 0 <= -2 * t / 3:\n                                                              return -(2 * t / 3)\n                                                      else:\n                                                          if -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / -2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                              if Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= -2 * t / 3:\n                                                                  return (-(2 * t / 3) - (Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                              else:\n                                  if 2 * t / t == 2:\n                                      s = (stor14 / 9615 * 10^6)^3 + 1 / 2\n                                      u = (stor14 / 9615 * 10^6)^3\n                                      while s < u:\n                                          require s\n                                          s = ((stor14 / 9615 * 10^6)^3 / s) + s / 2\n                                          u = s\n                                          continue \n                                      if not u:\n                                          if 0 <= 2 * t / 3:\n                                              if 2 * t / 3 > 0:\n                                                  if balanceOf[caller]:\n                                                      if not 2 * t / 3:\n                                                          if 0 <= 2 * t / 3:\n                                                              return (2 * t / 3)\n                                                      else:\n                                                          if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                              if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= 2 * t / 3:\n                                                                  return ((2 * t / 3) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                                      else:\n                                          if 2 * u / u == 2:\n                                              if 2 * u / 3 <= 2 * t / 3:\n                                                  if (2 * t / 3) - (2 * u / 3) > 0:\n                                                      if balanceOf[caller]:\n                                                          if not (2 * t / 3) - (2 * u / 3):\n                                                              if 0 <= (2 * t / 3) - (2 * u / 3):\n                                                                  return ((2 * t / 3) - (2 * u / 3))\n                                                          else:\n                                                              if (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= (2 * t / 3) - (2 * u / 3):\n                                                                      return ((2 * t / 3) - (2 * u / 3) - (Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                      else:\n                          if not _tokensToSell - frontEndTokenSupply + stor14:\n                              if frontEndTokenSupply - stor14:\n                                  s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                  t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                  while s < t:\n                                      require s\n                                      s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                      t = s\n                                      continue \n                                  if not t:\n                                      s = (stor14 / 9615 * 10^6)^3 + 1 / 2\n                                      t = (stor14 / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((stor14 / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if t:\n                                          if 2 * t / t == 2:\n                                              if 2 * t / 3 <= 0:\n                                                  if -2 * t / 3 > 0:\n                                                      if balanceOf[caller]:\n                                                          if not -2 * t / 3:\n                                                              if 0 <= -2 * t / 3:\n                                                                  return -(2 * t / 3)\n                                                          else:\n                                                              if -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / -2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= -2 * t / 3:\n                                                                      return (-(2 * t / 3) - (Mask(192, 64, -1 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                                  else:\n                                      if 2 * t / t == 2:\n                                          s = (stor14 / 9615 * 10^6)^3 + 1 / 2\n                                          u = (stor14 / 9615 * 10^6)^3\n                                          while s < u:\n                                              require s\n                                              s = ((stor14 / 9615 * 10^6)^3 / s) + s / 2\n                                              u = s\n                                              continue \n                                          if not u:\n                                              if 0 <= 2 * t / 3:\n                                                  if 2 * t / 3 > 0:\n                                                      if balanceOf[caller]:\n                                                          if not 2 * t / 3:\n                                                              if 0 <= 2 * t / 3:\n                                                                  return (2 * t / 3)\n                                                          else:\n                                                              if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 2 * t / 3 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                  if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64 <= 2 * t / 3:\n                                                                      return ((2 * t / 3) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * 2 * t / 3 / 100) >> 64))\n                                          else:\n                                              if 2 * u / u == 2:\n                                                  if 2 * u / 3 <= 2 * t / 3:\n                                                      if (2 * t / 3) - (2 * u / 3) > 0:\n                                                          if balanceOf[caller]:\n                                                              if not (2 * t / 3) - (2 * u / 3):\n                                                                  if 0 <= (2 * t / 3) - (2 * u / 3):\n                                                                      return ((2 * t / 3) - (2 * u / 3))\n                                                              else:\n                                                                  if (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                      if Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= (2 * t / 3) - (2 * u / 3):\n                                                                          return ((2 * t / 3) - (2 * u / 3) - (Mask(192, 64, (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                          else:\n                              if (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / _tokensToSell - frontEndTokenSupply + stor14 == 653 * 10^12:\n                                  if not frontEndTokenSupply - stor14:\n                                      if (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 > 0:\n                                          if balanceOf[caller]:\n                                              if not (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18:\n                                                  if 0 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18:\n                                                      return ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18)\n                                              else:\n                                                  if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 / (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                      if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 / 100) >> 64 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18:\n                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 / 100) >> 64))\n                                  else:\n                                      s = (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2\n                                      t = (frontEndTokenSupply / 9615 * 10^6)^3\n                                      while s < t:\n                                          require s\n                                          s = ((frontEndTokenSupply / 9615 * 10^6)^3 / s) + s / 2\n                                          t = s\n                                          continue \n                                      if not t:\n                                          s = (stor14 / 9615 * 10^6)^3 + 1 / 2\n                                          t = (stor14 / 9615 * 10^6)^3\n                                          while s < t:\n                                              require s\n                                              s = ((stor14 / 9615 * 10^6)^3 / s) + s / 2\n                                              t = s\n                                              continue \n                                          if not t:\n                                              if (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 > 0:\n                                                  if balanceOf[caller]:\n                                                      if not (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18:\n                                                          if 0 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18:\n                                                              return ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18)\n                                                      else:\n                                                          if Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 / (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                              if Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 / 100) >> 64 <= (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18:\n                                                                  return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (Mask(192, 64, Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] * (653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 / 100) >> 64))\n                                          else:\n                                              if 2 * t / t == 2:\n                                                  if 2 * t / 3 <= 0:\n                                                      if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3) > 0:\n                                                          if balanceOf[caller]:\n                                                              if not ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3):\n                                                                  if 0 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3):\n                                                                      return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3))\n                                                              else:\n                                                                  if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                      if Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3):\n                                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) - (2 * t / 3) - (Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                                      else:\n                                          if 2 * t / t == 2:\n                                              s = (stor14 / 9615 * 10^6)^3 + 1 / 2\n                                              u = (stor14 / 9615 * 10^6)^3\n                                              while s < u:\n                                                  require s\n                                                  s = ((stor14 / 9615 * 10^6)^3 / s) + s / 2\n                                                  u = s\n                                                  continue \n                                              if not u:\n                                                  if 0 <= 2 * t / 3:\n                                                      if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) > 0:\n                                                          if balanceOf[caller]:\n                                                              if not ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3):\n                                                                  if 0 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3):\n                                                                      return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3))\n                                                              else:\n                                                                  if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                      if Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3):\n                                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n                                              else:\n                                                  if 2 * u / u == 2:\n                                                      if 2 * u / 3 <= 2 * t / 3:\n                                                          if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3) > 0:\n                                                              if balanceOf[caller]:\n                                                                  if not ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3):\n                                                                      if 0 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3):\n                                                                          return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3))\n                                                                  else:\n                                                                      if ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3) == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                                          if Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64 <= ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3):\n                                                                              return (((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18) + (2 * t / 3) - (2 * u / 3) - (Mask(192, 64, ((653 * 10^12 * _tokensToSell) - (653 * 10^12 * frontEndTokenSupply) + (653 * 10^12 * stor14) / 10^18 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) + (2 * t / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) - (2 * u / 3 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]) / 100) >> 64))\n  revert\n\ndef buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass) payable: \n  if icoPhase:\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  require regularPhase\n  if icoPhase:\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  require stor8[_divChoice << 248]\n  stor9[caller] = 1\n  stor10[caller] = _divChoice\n  log UserDividendRate(\n        address user=caller,\n        uint256 divRate=_divChoice)\n  if call.value >= 10^14:\n      if regularPhase:\n          require call.value / 100 <= call.value\n          if not call.value - (call.value / 100):\n              require 0 <= call.value - (call.value / 100)\n              if call.value - (call.value / 100) <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if not icoPhase:\n                  if icoPhase:\n                      if 10^18 * call.value - (call.value / 100) / 653 * 10^12:\n                  else:\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          require call.value - (call.value / 100)\n                      else:\n                          if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO\n                          else:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              if call.value - (call.value / 100):\n              else:\n                  if stor3 != caller:\n                      if not icoPhase:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              require call.value - (call.value / 100)\n                          else:\n                              if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  else:\n                      if not icoPhase:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              require call.value - (call.value / 100)\n                          else:\n                              if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n          else:\n              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n              if not icoPhase:\n                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                          require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                      else:\n                          if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO\n                          else:\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n              else:\n                  if caller == stor3:\n                      if call.value - (call.value / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if currentEthInvested < ethInvestedDuringICO:\n                              if currentEthInvested + call.value - (call.value / 100) <= ethInvestedDuringICO:\n                          else:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  else:\n                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                          else:\n                              if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                              else:\n                                  require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n      else:\n          if call.value:\n              require stor10[caller] * call.value / call.value == stor10[caller]\n              require stor10[caller] * call.value / 100 <= call.value\n              if not icoPhase:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if not 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                          require stor18 >= stor18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                  else:\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                          require call.value - (stor10[caller] * call.value / 100)\n                      else:\n                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) <= ethInvestedDuringICO:\n                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              require call.value - (stor10[caller] * call.value / 100)\n                              if not call.value - (stor10[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                          require currentEthInvested <= ethInvestedDuringICO\n                          require ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100)\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if stor3 != caller:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                      else:\n                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                          if call.value - (stor10[caller] * call.value / 100):\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                              if call.value - (stor10[caller] * call.value / 100):\n                                  if not call.value - (stor10[caller] * call.value / 100):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if 10^18 * call.value / 653 * 10^12:\n                          require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                          require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if call.value == call.value:\n                          if call.value:\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 10^18 * call.value / call.value == 10^18:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              revert\n          require 0 <= call.value\n          if call.value <= 10^14:\n              revert with 0, 'Tried to buy tokens with too little eth.'\n          if not icoPhase:\n              if icoPhase:\n                  if 10^18 * call.value / 653 * 10^12:\n                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                      require (10^18 * stor10[caller] * call.value / 653 * 10^12) + stor18 >= stor18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                  require stor18 >= stor18\n                  currentEthInvested += call.value\n              else:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                  else:\n                      if currentEthInvested + call.value <= ethInvestedDuringICO:\n                          require call.value == call.value\n                          require call.value\n                          if not call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * call.value / call.value == 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value > ethInvestedDuringICO\n                      require currentEthInvested <= ethInvestedDuringICO\n                      require ethInvestedDuringICO - currentEthInvested <= call.value\n                      require call.value == call.value\n          else:\n              if caller == stor3:\n                  if icoPhase:\n                      if 10^18 * call.value / 653 * 10^12:\n                          require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                      else:\n                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      if call.value == call.value:\n                          if call.value:\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value == call.value:\n                              if call.value:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 10^18 * call.value / call.value == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if icoPhase:\n                  if not 10^18 * call.value / 653 * 10^12:\n                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                      require stor18 >= stor18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n              else:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                  else:\n                      if currentEthInvested + call.value <= ethInvestedDuringICO:\n                          require call.value == call.value\n                          require call.value\n                          if not call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * call.value / call.value == 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value > ethInvestedDuringICO\n                      require currentEthInvested <= ethInvestedDuringICO\n                      require ethInvestedDuringICO - currentEthInvested <= call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if stor3 != caller:\n      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n  if regularPhase:\n      require call.value / 100 <= call.value\n      if call.value - (call.value / 100):\n          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n          if not icoPhase:\n              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if not icoPhase:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                      require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                  else:\n                      if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                      else:\n                          require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n          else:\n              if stor3 != caller:\n                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if currentEthInvested < ethInvestedDuringICO:\n                          if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= ethInvestedDuringICO:\n                      else:\n                          require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n              else:\n                  if call.value - (call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if currentEthInvested < ethInvestedDuringICO:\n                          if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                      else:\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n      else:\n          require 0 <= call.value - (call.value / 100)\n          if call.value - (call.value / 100) <= 10^14:\n              revert with 0, 'Tried to buy tokens with too little eth.'\n          if not icoPhase:\n              if not icoPhase:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                      require call.value - (call.value / 100)\n                  else:\n                      if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO\n                      else:\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n          else:\n              if caller == stor3:\n                  if not icoPhase:\n                      if currentEthInvested < ethInvestedDuringICO:\n                          if currentEthInvested + call.value - (call.value / 100) <= ethInvestedDuringICO:\n                      else:\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n              else:\n                  if not icoPhase:\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          require call.value - (call.value / 100)\n                      else:\n                          if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                          else:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if not call.value:\n      if 0 <= call.value:\n          if call.value <= 10^14:\n              revert with 0, 'Tried to buy tokens with too little eth.'\n          if not icoPhase:\n              if icoPhase:\n                  if not 10^18 * call.value / 653 * 10^12:\n                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                      require stor18 >= stor18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n              else:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                  else:\n                      if currentEthInvested + call.value <= ethInvestedDuringICO:\n                          require call.value == call.value\n                          require call.value\n                          if not call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * call.value / call.value == 10^18\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value > ethInvestedDuringICO\n                      require currentEthInvested <= ethInvestedDuringICO\n                      require ethInvestedDuringICO - currentEthInvested <= call.value\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if stor3 != caller:\n              if icoPhase:\n                  if 10^18 * call.value / 653 * 10^12:\n                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                  else:\n                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if currentEthInvested >= ethInvestedDuringICO:\n                  if call.value == call.value:\n                      if call.value:\n                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if call.value == call.value:\n                          if call.value:\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 10^18 * call.value / call.value == 10^18:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if icoPhase:\n                  if 10^18 * call.value / 653 * 10^12:\n                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if currentEthInvested >= ethInvestedDuringICO:\n                  require call.value == call.value\n                  require call.value\n                  if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if currentEthInvested + call.value > ethInvestedDuringICO:\n                  require currentEthInvested < ethInvestedDuringICO\n                  require currentEthInvested + call.value > ethInvestedDuringICO\n                  if currentEthInvested <= ethInvestedDuringICO:\n                      if ethInvestedDuringICO - currentEthInvested <= call.value:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if call.value == call.value:\n                      if call.value:\n                          if not call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 10^18 * call.value / call.value == 10^18:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if stor10[caller] * call.value / call.value == stor10[caller]:\n          if stor10[caller] * call.value / 100 <= call.value:\n              if not icoPhase:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                      else:\n                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                          if call.value - (stor10[caller] * call.value / 100):\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                              if call.value - (stor10[caller] * call.value / 100):\n                                  if not call.value - (stor10[caller] * call.value / 100):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor3 != caller:\n                      if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if icoPhase:\n                          if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                              require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                              require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                          require call.value - (stor10[caller] * call.value / 100)\n                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                              if call.value - (stor10[caller] * call.value / 100):\n                                  if not call.value - (stor10[caller] * call.value / 100):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if call.value <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if icoPhase:\n                          if not 10^18 * call.value / 653 * 10^12:\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          require call.value == call.value\n                          require call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value > ethInvestedDuringICO\n                          require currentEthInvested <= ethInvestedDuringICO\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if call.value == call.value:\n                          if call.value:\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 10^18 * call.value / call.value == 10^18:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef buyAndTransfer(address _referredBy, address target) payable: \n  require regularPhase\n  if stor9[caller]:\n      if not icoPhase:\n          require regularPhase\n          if not icoPhase:\n              require stor8[20]\n              stor9[caller] = 1\n              stor10[caller] = 20\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=20)\n              if call.value >= 10^14:\n                  if regularPhase:\n                      require call.value / 100 <= call.value\n                      if call.value - (call.value / 100):\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                          if not icoPhase:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                      else:\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if caller == stor3:\n                              if not icoPhase:\n                          else:\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value == call.value\n                                      require call.value\n                                      if call.value:\n                          else:\n                              if stor3 != caller:\n                                  if icoPhase:\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                      else:\n                          require stor10[caller] * call.value / call.value == stor10[caller]\n                          require stor10[caller] * call.value / 100 <= call.value\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if not 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              require call.value - (stor10[caller] * call.value / 100)\n                          else:\n                              if caller == stor3:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                              if call.value - (stor10[caller] * call.value / 100):\n              else:\n                  if stor3 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if regularPhase:\n                      require call.value / 100 <= call.value\n                      if not call.value - (call.value / 100):\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                          else:\n                              if not icoPhase:\n                      else:\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                          if not icoPhase:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                          else:\n                              if caller == stor3:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                  else:\n                      if call.value:\n                          require stor10[caller] * call.value / call.value == stor10[caller]\n                          require stor10[caller] * call.value / 100 <= call.value\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          if call.value - (stor10[caller] * call.value / 100):\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if caller == stor3:\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n  else:\n      if not icoPhase:\n          require regularPhase\n          if not icoPhase:\n              require stor8[20]\n              stor9[caller] = 1\n              stor10[caller] = 20\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=20)\n              if call.value >= 10^14:\n                  if regularPhase:\n                      require call.value / 100 <= call.value\n                      if not call.value - (call.value / 100):\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          else:\n                              if stor3 != caller:\n                                  if icoPhase:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                      else:\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                          if not icoPhase:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if caller == stor3:\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                          else:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                  else:\n                      if call.value:\n                          require stor10[caller] * call.value / call.value == stor10[caller]\n                          require stor10[caller] * call.value / 100 <= call.value\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                      if call.value - (stor10[caller] * call.value / 100):\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if not 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                  require call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * call.value / call.value == 10^18\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if caller == stor3:\n                              if icoPhase:\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if icoPhase:\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value == call.value\n                                      require call.value\n                                      if call.value:\n              else:\n                  if stor3 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if regularPhase:\n                      require call.value / 100 <= call.value\n                      if call.value - (call.value / 100):\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                          if not icoPhase:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                      else:\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if caller == stor3:\n                              if not icoPhase:\n                          else:\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  if 10^18 * call.value / 653 * 10^12:\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require call.value == call.value\n                                      require call.value\n                                      if call.value:\n                          else:\n                              if stor3 != caller:\n                                  if icoPhase:\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                          require currentEthInvested <= ethInvestedDuringICO\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                      else:\n                          require stor10[caller] * call.value / call.value == stor10[caller]\n                          require stor10[caller] * call.value / 100 <= call.value\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if not 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              require call.value - (stor10[caller] * call.value / 100)\n                          else:\n                              if caller == stor3:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                              if call.value - (stor10[caller] * call.value / 100):\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice) payable: \n  require regularPhase\n  if not stor9[caller]:\n      if not icoPhase:\n          require regularPhase\n          if not icoPhase:\n              require stor8[divChoice << 248]\n              stor9[caller] = 1\n              stor10[caller] = divChoice\n              log UserDividendRate(\n                    address user=caller,\n                    uint256 divRate=divChoice)\n              if call.value >= 10^14:\n                  if regularPhase:\n                      require call.value / 100 <= call.value\n                      if not call.value - (call.value / 100):\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                          else:\n                              if not icoPhase:\n                      else:\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                          if not icoPhase:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                          else:\n                              if caller == stor3:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                  else:\n                      if call.value:\n                          require stor10[caller] * call.value / call.value == stor10[caller]\n                          require stor10[caller] * call.value / 100 <= call.value\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          if call.value - (stor10[caller] * call.value / 100):\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  if not 10^18 * call.value / 653 * 10^12:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require call.value == call.value\n                              require call.value\n                          else:\n                              if caller == stor3:\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n              else:\n                  if stor3 != caller:\n                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                  if regularPhase:\n                      require call.value / 100 <= call.value\n                      if call.value - (call.value / 100):\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                          require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                          if not icoPhase:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          require 0 <= call.value - (call.value / 100)\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if not icoPhase:\n                          else:\n                              if caller == stor3:\n                              else:\n                                  if not icoPhase:\n                  else:\n                      if not call.value:\n                          require 0 <= call.value\n                          if call.value <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if icoPhase:\n                                  if 10^18 * call.value / 653 * 10^12:\n                              else:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                  else:\n                                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value > ethInvestedDuringICO\n                                      else:\n                                          require call.value == call.value\n                                          if call.value:\n                          else:\n                              if stor3 != caller:\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                      else:\n                          require stor10[caller] * call.value / call.value == stor10[caller]\n                          require stor10[caller] * call.value / 100 <= call.value\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      else:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                          else:\n                              if caller == stor3:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      else:\n                                          require call.value == call.value\n                              else:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n  else:\n      if not divChoice:\n          if call.value >= 10^14:\n              if regularPhase:\n                  require call.value / 100 <= call.value\n                  if call.value - (call.value / 100):\n                      require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                      require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                      if not icoPhase:\n                          if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                                  require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                              else:\n                                  if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                  else:\n                                      require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                      else:\n                          if stor3 != caller:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                          else:\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  else:\n                      require 0 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if not icoPhase:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                                  require call.value - (call.value / 100)\n                              else:\n                                  if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                      else:\n                          if caller == stor3:\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) <= ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          else:\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                                      require call.value - (call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                      else:\n                                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if not call.value:\n                  if 0 <= call.value:\n                      if call.value <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if icoPhase:\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                                  require stor18 >= stor18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * call.value / call.value == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor3 != caller:\n                          if icoPhase:\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                              else:\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if icoPhase:\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor10[caller] * call.value / call.value == stor10[caller]:\n                      if stor10[caller] * call.value / 100 <= call.value:\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                  else:\n                                  require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                                      if call.value - (stor10[caller] * call.value / 100):\n                                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                                          if call.value - (stor10[caller] * call.value / 100):\n                                              if not call.value - (stor10[caller] * call.value / 100):\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                          require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                                          if call.value - (stor10[caller] * call.value / 100):\n                                              if not call.value - (stor10[caller] * call.value / 100):\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              revert\n          if stor3 != caller:\n              revert with 0, 'Tried to buy below the min eth buyin threshold.'\n          if regularPhase:\n              require call.value / 100 <= call.value\n              if not call.value - (call.value / 100):\n                  require 0 <= call.value - (call.value / 100)\n                  if call.value - (call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if not icoPhase:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              require call.value - (call.value / 100)\n                          else:\n                              if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  else:\n                      if stor3 != caller:\n                          if not icoPhase:\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (call.value / 100) <= ethInvestedDuringICO:\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                      else:\n                          if not icoPhase:\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n              else:\n                  require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                  require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                  if not icoPhase:\n                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if currentEthInvested < ethInvestedDuringICO:\n                              if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= ethInvestedDuringICO:\n                          else:\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                  else:\n                      if caller == stor3:\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if icoPhase:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested < ethInvestedDuringICO:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if currentEthInvested < ethInvestedDuringICO:\n                              if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                          else:\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n          else:\n              if not call.value:\n                  require 0 <= call.value\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if icoPhase:\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                          else:\n                          require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          if call.value == call.value:\n                              if call.value:\n                                  if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if stor3 != caller:\n                          if icoPhase:\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if icoPhase:\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if call.value == call.value:\n                              if call.value:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 10^18 * call.value / call.value == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require stor10[caller] * call.value / call.value == stor10[caller]\n              require stor10[caller] * call.value / 100 <= call.value\n              if not icoPhase:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                      require call.value - (stor10[caller] * call.value / 100)\n                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                          if call.value - (stor10[caller] * call.value / 100):\n                              if not call.value - (stor10[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if stor3 != caller:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if not 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                      require call.value - (stor10[caller] * call.value / 100)\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                      require currentEthInvested <= ethInvestedDuringICO\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                  require call.value - (stor10[caller] * call.value / 100)\n                  if not call.value - (stor10[caller] * call.value / 100):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if call.value <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if icoPhase:\n                  if 10^18 * call.value / 653 * 10^12:\n                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                  else:\n                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value > ethInvestedDuringICO\n                          require currentEthInvested <= ethInvestedDuringICO\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.value == call.value\n                      require call.value\n                      if call.value:\n      else:\n          if not icoPhase:\n              require regularPhase\n              if not icoPhase:\n                  require stor8[divChoice << 248]\n                  stor9[caller] = 1\n                  stor10[caller] = divChoice\n                  log UserDividendRate(\n                        address user=caller,\n                        uint256 divRate=divChoice)\n                  if call.value >= 10^14:\n                      if regularPhase:\n                          require call.value / 100 <= call.value\n                          if call.value - (call.value / 100):\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                              if not icoPhase:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                              else:\n                                  if stor3 != caller:\n                                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                          else:\n                              require 0 <= call.value - (call.value / 100)\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if not icoPhase:\n                              else:\n                                  if caller == stor3:\n                                  else:\n                                      if not icoPhase:\n                      else:\n                          if not call.value:\n                              require 0 <= call.value\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                              else:\n                                  if stor3 != caller:\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n                                  else:\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n                          else:\n                              require stor10[caller] * call.value / call.value == stor10[caller]\n                              require stor10[caller] * call.value / 100 <= call.value\n                              if not icoPhase:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if caller == stor3:\n                                      if call.value <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                                  else:\n                                      if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                              require call.value - (stor10[caller] * call.value / 100)\n                                          else:\n                                              if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                  else:\n                      if stor3 != caller:\n                          revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                      if regularPhase:\n                          require call.value / 100 <= call.value\n                          if call.value - (call.value / 100):\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                              if not icoPhase:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if stor3 != caller:\n                          else:\n                              require 0 <= call.value - (call.value / 100)\n                              if not icoPhase:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                              else:\n                                  if stor3 != caller:\n                                      if call.value - (call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          if call.value:\n                              require stor10[caller] * call.value / call.value == stor10[caller]\n                              require stor10[caller] * call.value / 100 <= call.value\n                              if not icoPhase:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if stor3 != caller:\n                                      if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value - (stor10[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                  else:\n                                      if call.value <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                          else:\n                              require 0 <= call.value\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if caller == stor3:\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                                  else:\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef _fallback(?) payable: # default function\n  if calldata.size < 4:\n      require regularPhase\n      if stor9[caller]:\n          if call.value >= 10^14:\n              if regularPhase:\n                  require call.value / 100 <= call.value\n                  if call.value - (call.value / 100):\n                      require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                      require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                      if not icoPhase:\n                          if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if not icoPhase:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                                  require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                              else:\n                                  if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                  else:\n                                      require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                      else:\n                          if stor3 != caller:\n                              if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                          else:\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  else:\n                      require 0 <= call.value - (call.value / 100)\n                      if call.value - (call.value / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if not icoPhase:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                                  require call.value - (call.value / 100)\n                              else:\n                                  if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                      else:\n                          if caller == stor3:\n                              if not icoPhase:\n                                  if currentEthInvested < ethInvestedDuringICO:\n                                      if currentEthInvested + call.value - (call.value / 100) <= ethInvestedDuringICO:\n                                  else:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          else:\n                              if not icoPhase:\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (call.value / 100) == call.value - (call.value / 100)\n                                      require call.value - (call.value / 100)\n                                  else:\n                                      if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                          require currentEthInvested < ethInvestedDuringICO\n                                      else:\n                                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if not call.value:\n                  if 0 <= call.value:\n                      if call.value <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if icoPhase:\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                                  require stor18 >= stor18\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                          else:\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require call.value == call.value\n                                  require call.value\n                              else:\n                                  if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * call.value / call.value == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if stor3 != caller:\n                          if icoPhase:\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                              else:\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                  if currentEthInvested <= ethInvestedDuringICO:\n                                      if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if icoPhase:\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor10[caller] * call.value / call.value == stor10[caller]:\n                      if stor10[caller] * call.value / 100 <= call.value:\n                          if not icoPhase:\n                              if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                  else:\n                                  require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                                      if call.value - (stor10[caller] * call.value / 100):\n                                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                                          if call.value - (stor10[caller] * call.value / 100):\n                                              if not call.value - (stor10[caller] * call.value / 100):\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if stor3 != caller:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                                          require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                      require call.value - (stor10[caller] * call.value / 100)\n                                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                      if currentEthInvested <= ethInvestedDuringICO:\n                                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                                          if call.value - (stor10[caller] * call.value / 100):\n                                              if not call.value - (stor10[caller] * call.value / 100):\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                              if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if call.value <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if icoPhase:\n                                      if not 10^18 * call.value / 653 * 10^12:\n                                          require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested >= ethInvestedDuringICO:\n                                      require call.value == call.value\n                                      require call.value\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if currentEthInvested + call.value > ethInvestedDuringICO:\n                                      require currentEthInvested < ethInvestedDuringICO\n                                      require currentEthInvested + call.value > ethInvestedDuringICO\n                                      require currentEthInvested <= ethInvestedDuringICO\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if call.value == call.value:\n                                      if call.value:\n                                          if not call.value:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if 10^18 * call.value / call.value == 10^18:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              revert\n          if stor3 != caller:\n              revert with 0, 'Tried to buy below the min eth buyin threshold.'\n          if regularPhase:\n              require call.value / 100 <= call.value\n              if not call.value - (call.value / 100):\n                  require 0 <= call.value - (call.value / 100)\n                  if call.value - (call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if not icoPhase:\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value - (call.value / 100) == call.value - (call.value / 100)\n                              require call.value - (call.value / 100)\n                          else:\n                              if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                                  require currentEthInvested < ethInvestedDuringICO\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                  else:\n                      if stor3 != caller:\n                          if not icoPhase:\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (call.value / 100) <= ethInvestedDuringICO:\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n                      else:\n                          if not icoPhase:\n                              if currentEthInvested < ethInvestedDuringICO:\n                                  if currentEthInvested + call.value - (call.value / 100) > ethInvestedDuringICO:\n                              else:\n                                  require call.value - (call.value / 100) == call.value - (call.value / 100)\n              else:\n                  require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                  require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                  if not icoPhase:\n                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if currentEthInvested < ethInvestedDuringICO:\n                              if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= ethInvestedDuringICO:\n                          else:\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n                  else:\n                      if caller == stor3:\n                          if call.value - (call.value / 100) <= 10^14:\n                              revert with 0, 'Tried to buy tokens with too little eth.'\n                          if icoPhase:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested < ethInvestedDuringICO:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.value - (call.value / 100) == call.value - (call.value / 100)\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      if not icoPhase:\n                          if currentEthInvested < ethInvestedDuringICO:\n                              if currentEthInvested + call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) > ethInvestedDuringICO:\n                          else:\n                              require call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) == call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100)\n          else:\n              if not call.value:\n                  require 0 <= call.value\n                  if call.value <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if not icoPhase:\n                      if icoPhase:\n                          if 10^18 * call.value / 653 * 10^12:\n                              require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                          else:\n                          require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if currentEthInvested >= ethInvestedDuringICO:\n                          if call.value == call.value:\n                              if call.value:\n                                  if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if stor3 != caller:\n                          if icoPhase:\n                              if 10^18 * call.value / 653 * 10^12:\n                                  require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                              frontEndTokenSupply += 10^18 * call.value / 653 * 10^12\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              if currentEthInvested <= ethInvestedDuringICO:\n                                  if ethInvestedDuringICO - currentEthInvested <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if call.value == call.value:\n                                  if call.value:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 10^18 * call.value / call.value == 10^18:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if icoPhase:\n                              if not 10^18 * call.value / 653 * 10^12:\n                                  require (10^18 * call.value / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested >= ethInvestedDuringICO:\n                              require call.value == call.value\n                              require call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                              require currentEthInvested < ethInvestedDuringICO\n                              require currentEthInvested + call.value > ethInvestedDuringICO\n                              require currentEthInvested <= ethInvestedDuringICO\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if call.value == call.value:\n                              if call.value:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 10^18 * call.value / call.value == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require stor10[caller] * call.value / call.value == stor10[caller]\n              require stor10[caller] * call.value / 100 <= call.value\n              if not icoPhase:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                      frontEndTokenSupply += 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                      require call.value - (stor10[caller] * call.value / 100)\n                      if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 < (frontEndTokenSupply / 9615 * 10^6)^3:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                      if currentEthInvested <= ethInvestedDuringICO:\n                          if ethInvestedDuringICO - currentEthInvested <= call.value - (stor10[caller] * call.value / 100):\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100):\n                          if call.value - (stor10[caller] * call.value / 100):\n                              if not call.value - (stor10[caller] * call.value / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if stor3 != caller:\n                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      if not 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12:\n                          require (10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12) + frontEndTokenSupply >= frontEndTokenSupply\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 10^18 * stor10[caller] * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 / 10^18 * call.value - (stor10[caller] * call.value / 100) / 653 * 10^12 == stor10[caller]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                      require call.value - (stor10[caller] * call.value / 100)\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                      require currentEthInvested < ethInvestedDuringICO\n                      require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                      require currentEthInvested <= ethInvestedDuringICO\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                  require call.value - (stor10[caller] * call.value / 100)\n                  if not call.value - (stor10[caller] * call.value / 100):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require (10^18 * call.value) - (10^18 * stor10[caller] * call.value / 100) / call.value - (stor10[caller] * call.value / 100) == 10^18\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              if call.value <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if icoPhase:\n                  if 10^18 * call.value / 653 * 10^12:\n                      require 10^18 * stor10[caller] * call.value / 653 * 10^12 / 10^18 * call.value / 653 * 10^12 == stor10[caller]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      require call.value == call.value\n                      require call.value\n                  else:\n                      if currentEthInvested + call.value > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + call.value > ethInvestedDuringICO\n                          require currentEthInvested <= ethInvestedDuringICO\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.value == call.value\n                      require call.value\n                      if call.value:\n      else:\n          if not icoPhase:\n              require regularPhase\n              if not icoPhase:\n                  require stor8[20]\n                  stor9[caller] = 1\n                  stor10[caller] = 20\n                  log UserDividendRate(\n                        address user=caller,\n                        uint256 divRate=20)\n                  if call.value >= 10^14:\n                      if regularPhase:\n                          require call.value / 100 <= call.value\n                          if call.value - (call.value / 100):\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                              if not icoPhase:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                              else:\n                                  if stor3 != caller:\n                                      if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                          else:\n                              require 0 <= call.value - (call.value / 100)\n                              if call.value - (call.value / 100) <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if not icoPhase:\n                              else:\n                                  if caller == stor3:\n                                  else:\n                                      if not icoPhase:\n                      else:\n                          if not call.value:\n                              require 0 <= call.value\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if icoPhase:\n                                      if 10^18 * call.value / 653 * 10^12:\n                                  else:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                                              if call.value:\n                              else:\n                                  if stor3 != caller:\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                                  require currentEthInvested + call.value > ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n                                  else:\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n                          else:\n                              require stor10[caller] * call.value / call.value == stor10[caller]\n                              require stor10[caller] * call.value / 100 <= call.value\n                              if not icoPhase:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if caller == stor3:\n                                      if call.value <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                                  else:\n                                      if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                              require call.value - (stor10[caller] * call.value / 100)\n                                          else:\n                                              if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                  else:\n                      if stor3 != caller:\n                          revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                      if regularPhase:\n                          require call.value / 100 <= call.value\n                          if call.value - (call.value / 100):\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / call.value - (call.value / 100) == stor10[caller]\n                              require (call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100 <= call.value - (call.value / 100)\n                              if not icoPhase:\n                                  if call.value - (call.value / 100) - ((call.value * stor10[caller]) - (call.value / 100 * stor10[caller]) / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                              else:\n                                  if stor3 != caller:\n                          else:\n                              require 0 <= call.value - (call.value / 100)\n                              if not icoPhase:\n                                  if call.value - (call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                              else:\n                                  if stor3 != caller:\n                                      if call.value - (call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                      else:\n                          if call.value:\n                              require stor10[caller] * call.value / call.value == stor10[caller]\n                              require stor10[caller] * call.value / 100 <= call.value\n                              if not icoPhase:\n                                  if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                      revert with 0, 'Tried to buy tokens with too little eth.'\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                          require call.value - (stor10[caller] * call.value / 100)\n                                      else:\n                                          if currentEthInvested + call.value - (stor10[caller] * call.value / 100) > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                              else:\n                                  if stor3 != caller:\n                                      if call.value - (stor10[caller] * call.value / 100) <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value - (stor10[caller] * call.value / 100) <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value - (stor10[caller] * call.value / 100) == call.value - (stor10[caller] * call.value / 100)\n                                  else:\n                                      if call.value <= 10^14:\n                                          revert with 0, 'Tried to buy tokens with too little eth.'\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                          else:\n                              require 0 <= call.value\n                              if call.value <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if not icoPhase:\n                                  if not icoPhase:\n                                      if currentEthInvested >= ethInvestedDuringICO:\n                                          require call.value == call.value\n                                          require call.value\n                                      else:\n                                          if currentEthInvested + call.value > ethInvestedDuringICO:\n                                              require currentEthInvested < ethInvestedDuringICO\n                                              require currentEthInvested + call.value > ethInvestedDuringICO\n                                          else:\n                                              require call.value == call.value\n                              else:\n                                  if caller == stor3:\n                                      if not icoPhase:\n                                          if currentEthInvested < ethInvestedDuringICO:\n                                              if currentEthInvested + call.value <= ethInvestedDuringICO:\n                                          else:\n                                              require call.value == call.value\n                                  else:\n                                      if not icoPhase:\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              require call.value == call.value\n                                              require call.value\n                                          else:\n                                              if currentEthInvested + call.value > ethInvestedDuringICO:\n                                                  require currentEthInvested < ethInvestedDuringICO\n                                              else:\n                                                  require call.value == call.value\n  else:\n      if uint32(call.func_hash) == dividendsOf(address _customerAddress):\n          require not call.value\n          return (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64)\n      if totalEthereumICOReceived() == uint32(call.func_hash):\n          require not call.value\n          return ethInvestedDuringICO\n      if name() == uint32(call.func_hash):\n          require not call.value\n      else:\n          if approve(address spender, uint256 amount) == uint32(call.func_hash):\n              require not call.value\n              allowed[caller][address(_param1)] = _param2\n              log Approval(\n                    address owner=_param2,\n                    address spender=caller,\n                    uint256 value=_param1)\n              return 1\n          if icoHashedPass() == uint32(call.func_hash):\n              require not call.value\n              return 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262\n          if calculateTokensReceived(uint256 _ethereumToSpend) == uint32(call.func_hash):\n              require not call.value\n              if _param1:\n                  require stor10[caller] * _param1 / _param1 == stor10[caller]\n                  require stor10[caller] * _param1 / 100 <= _param1\n                  if _param1 - (stor10[caller] * _param1 / 100) <= 10^14:\n                      revert with 0, 'Tried to buy tokens with too little eth.'\n                  if icoPhase:\n                      return (10^18 * _param1 - (stor10[caller] * _param1 / 100) / 653 * 10^12)\n                  if currentEthInvested >= ethInvestedDuringICO:\n                      if _param1 - (stor10[caller] * _param1 / 100) == _param1 - (stor10[caller] * _param1 / 100):\n                          if _param1 - (stor10[caller] * _param1 / 100):\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2 >= (frontEndTokenSupply / 9615 * 10^6)^3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if (frontEndTokenSupply / 9615 * 10^6)^3 + 1 / 2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if currentEthInvested + _param1 - (stor10[caller] * _param1 / 100) > ethInvestedDuringICO:\n                          require currentEthInvested < ethInvestedDuringICO\n                          require currentEthInvested + _param1 - (stor10[caller] * _param1 / 100) > ethInvestedDuringICO\n                          if currentEthInvested <= ethInvestedDuringICO:\n                              if ethInvestedDuringICO - currentEthInvested <= _param1 - (stor10[caller] * _param1 / 100):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if _param1 - (stor10[caller] * _param1 / 100) == _param1 - (stor10[caller] * _param1 / 100):\n                              if _param1 - (stor10[caller] * _param1 / 100):\n                                  if not _param1 - (stor10[caller] * _param1 / 100):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if (10^18 * _param1) - (10^18 * stor10[caller] * _param1 / 100) / _param1 - (stor10[caller] * _param1 / 100) == 10^18:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require 0 <= _param1\n              if _param1 <= 10^14:\n                  revert with 0, 'Tried to buy tokens with too little eth.'\n              if icoPhase:\n                  return (10^18 * _param1 / 653 * 10^12)\n              if currentEthInvested >= ethInvestedDuringICO:\n                  require _param1 == _param1\n                  require _param1\n              else:\n                  if currentEthInvested + _param1 <= ethInvestedDuringICO:\n                      require _param1 == _param1\n                      require _param1\n                      if not _param1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 10^18 * _param1 / _param1 == 10^18\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require currentEthInvested < ethInvestedDuringICO\n                  require currentEthInvested + _param1 > ethInvestedDuringICO\n                  require currentEthInvested <= ethInvestedDuringICO\n                  require ethInvestedDuringICO - currentEthInvested <= _param1\n          else:\n              if totalSupply() == uint32(call.func_hash):\n                  require not call.value\n                  return frontEndTokenSupply\n              if transferTo(address _from, address _to, uint256 _amountOfTokens, bytes _data) == uint32(call.func_hash):\n                  require not call.value\n                  require _param3 >= 10^10\n                  require _param3 <= balanceOf[address(_param1)]\n                  if caller == _param1:\n                      require regularPhase\n                      require address(_param2)\n                      if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)] <= 0:\n                          require balanceOf[address(_param1)]\n                          if not _param3:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require Mask(192, 0, dividendTokenBalanceOf[address(_param1)]) / balanceOf[address(_param1)] * _param3 / _param3 == Mask(192, 0, dividendTokenBalanceOf[address(_param1)]) / balanceOf[address(_param1)]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor12[address(_param1)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)])\n                      stor11[address(_param1)] = 0\n                      call _param1 with:\n                         value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)] wei\n                           gas 2300 * is_zero(value) wei\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      log onWithdraw(\n                            address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)]),\n                            uint256 ethereumWithdrawn=_param1)\n                  else:\n                      require _param3 <= allowed[address(_param1)][caller]\n                      require regularPhase\n                      require address(_param2)\n                      if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)] <= 0:\n                          require balanceOf[address(_param1)]\n                          if _param3:\n                      else:\n                          stor12[address(_param1)] += Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)])\n                          stor11[address(_param1)] = 0\n                          call _param1 with:\n                             value (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)] wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          log onWithdraw(\n                                address customerAddress=((Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)]),\n                                uint256 ethereumWithdrawn=_param1)\n              else:\n                  if currentEthInvested() == uint32(call.func_hash):\n                      require not call.value\n                      return currentEthInvested\n                  if regularPhase() == uint32(call.func_hash):\n                      require not call.value\n                      return bool(regularPhase)\n                  if calculateEthereumReceived(uint256 _tokensToSell) == uint32(call.func_hash):\n                      require not call.value\n                      require _param1 <= frontEndTokenSupply\n                      if _param1 < 10^14:\n                          revert with 0, 'Tried to sell too few tokens.'\n                      if frontEndTokenSupply <= stor14:\n                          require _param1 == _param1\n                          require _param1\n                          require _param1\n                          require 653 * 10^12 * _param1 / _param1 == 653 * 10^12\n                          require 653 * 10^12 * _param1 / 10^18 > 0\n                          require balanceOf[caller]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if frontEndTokenSupply - _param1 >= stor14:\n                          require _param1 == _param1\n                          require _param1\n                      else:\n                          require frontEndTokenSupply > stor14\n                          require frontEndTokenSupply - _param1 < stor14\n                          require stor14 <= frontEndTokenSupply\n                          require frontEndTokenSupply - stor14 <= _param1\n                          require _param1 == _param1\n                          if not _param1 - frontEndTokenSupply + stor14:\n                              require frontEndTokenSupply - stor14\n                          else:\n                              if _param1 - frontEndTokenSupply + stor14:\n                  else:\n                      if transferFrom(address sender, address recipient, uint256 amount) == uint32(call.func_hash):\n                          require not call.value\n                          require _param3 >= 10^10\n                          require _param3 <= balanceOf[address(_param1)]\n                          require _param3 <= allowed[address(_param1)][caller]\n                          require regularPhase\n                          require address(_param2)\n                          if (Mask(192, 64, (uint256(dividendTokenBalanceOf[address(_param1)]) * stor19) - stor12[address(_param1)]) >> 64) + stor11[address(_param1)] <= 0:\n                              require balanceOf[address(_param1)]\n                      else:\n                          if buyAndTransfer(address _referredBy, address target) == uint32(call.func_hash):\n                              require regularPhase\n                              if icoPhase:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require regularPhase\n                              if icoPhase:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require stor8[20]\n                              stor9[caller] = 1\n                              stor10[caller] = 20\n                              log UserDividendRate(\n                                    address user=caller,\n                                    uint256 divRate=20)\n                              if call.value < 10^14:\n                                  if stor3 != caller:\n                                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                              if regularPhase:\n                                  if call.value / 100 <= call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if stor10[caller] * call.value / call.value == stor10[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              revert\n                          if startRegularPhase() == uint32(call.func_hash):\n                              require not call.value\n                              require stor20[caller]\n                              icoPhase = 0\n                              regularPhase = 1\n                              stop\n                          if ethereumToTokens_(uint256 _ethereum) == uint32(call.func_hash):\n                              require not call.value\n                              if _param1 <= 10^14:\n                                  revert with 0, 'Tried to buy tokens with too little eth.'\n                              if icoPhase:\n                                  return (10^18 * _param1 / 653 * 10^12)\n                              if currentEthInvested >= ethInvestedDuringICO:\n                                  require _param1 == _param1\n                                  require _param1\n                              else:\n                                  if currentEthInvested + _param1 <= ethInvestedDuringICO:\n                                      require _param1 == _param1\n                                      require _param1\n                                      if not _param1:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require 10^18 * _param1 / _param1 == 10^18\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require currentEthInvested < ethInvestedDuringICO\n                                  require currentEthInvested + _param1 > ethInvestedDuringICO\n                                  require currentEthInvested <= ethInvestedDuringICO\n                                  require ethInvestedDuringICO - currentEthInvested <= _param1\n                                  require _param1 == _param1\n                                  if not ethInvestedDuringICO - currentEthInvested:\n                          else:\n                              if decimals() == uint32(call.func_hash):\n                                  require not call.value\n                                  return 18\n                              if publicStartRegularPhase() == uint32(call.func_hash):\n                                  require not call.value\n                                  require block.timestamp > stor22 + (336 * 24 * 3600)\n                                  require stor22\n                                  icoPhase = 0\n                                  regularPhase = 1\n                                  stop\n                              if sellPrice() == uint32(call.func_hash):\n                                  require not call.value\n                                  if icoPhase:\n                                      if balanceOf[caller]:\n                                          if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if currentEthInvested < ethInvestedDuringICO:\n                                          if balanceOf[caller]:\n                                              if 653 * 10^12 * Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller] / 653 * 10^12 == Mask(192, 0, dividendTokenBalanceOf[caller]) / balanceOf[caller]:\n                                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      else:\n                                          if icoPhase:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if currentEthInvested >= ethInvestedDuringICO:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          if currentEthInvested + 10^15 <= ethInvestedDuringICO:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                          require currentEthInvested < ethInvestedDuringICO\n                                          require currentEthInvested + 10^15 > ethInvestedDuringICO\n                                          if currentEthInvested <= ethInvestedDuringICO:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                              if getFrontEndTokenBalanceOf(address _customerAddress) == uint32(call.func_hash):\n                                  require not call.value\n                                  return balanceOf[address(_param1)]\n                              if getDividendTokenBalanceOf(address _customerAddress) == uint32(call.func_hash):\n                                  require not call.value\n                                  return uint256(dividendTokenBalanceOf[address(_param1)])\n                              if withdraw(address _asset) == uint32(call.func_hash):\n                                  require not call.value\n                                  require (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller] > 0\n                                  require regularPhase\n                              else:\n                                  if stakingRequirement() == uint32(call.func_hash):\n                                      require not call.value\n                                      return stakingRequirement\n                                  if allowed(address _param1, address _param2) == uint32(call.func_hash):\n                                      require not call.value\n                                      return allowed[_param1][address(_param2)]\n                                  if ethInvestedDuringICO() == uint32(call.func_hash):\n                                      require not call.value\n                                      return ethInvestedDuringICO\n                                  if myDividendTokens() == uint32(call.func_hash):\n                                      require not call.value\n                                      return uint256(dividendTokenBalanceOf[caller])\n                                  if buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice) == uint32(call.func_hash):\n                                      require regularPhase\n                                      if not stor9[caller]:\n                                          if not icoPhase:\n                                              require regularPhase\n                                              if not icoPhase:\n                                      else:\n                                          if _param4:\n                                              if not icoPhase:\n                                                  require regularPhase\n                                          else:\n                                              if call.value < 10^14:\n                                                  if stor3 != caller:\n                                                      revert with 0, 'Tried to buy below the min eth buyin threshold.'\n                                  else:\n                                      if sqrt(uint256 y) == uint32(call.func_hash):\n                                          require not call.value\n                                      else:\n                                          if myDividends(bool _includeReferralBonus) == uint32(call.func_hash):\n                                              require not call.value\n                                              if _param1:\n                                                  return ((Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64) + stor11[caller])\n                                              return (Mask(192, 64, (uint256(dividendTokenBalanceOf[caller]) * stor19) - stor12[caller]) >> 64)\n                                          if icoPhase() == uint32(call.func_hash):\n                                              require not call.value\n                                              return bool(icoPhase)\n                                          if injectEther() == uint32(call.func_hash):\n                                              require stor20[caller]\n                                              stop\n                                          if totalEthereumBalance() == uint32(call.func_hash):\n                                              require not call.value\n                                              return eth.balance(this.address)\n                                          if balanceOf(address account) == uint32(call.func_hash):\n                                              require not call.value\n                                          else:\n                                              if uint32(call.func_hash) != buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass):\n                                                  if administrators(address _param1) == uint32(call.func_hash):\n                                                      require not call.value\n                                                  else:\n                                                      if uint32(call.func_hash) != getMyAverageDividendRate():\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 69641 tokens. Please reduce the length of the messages."
}