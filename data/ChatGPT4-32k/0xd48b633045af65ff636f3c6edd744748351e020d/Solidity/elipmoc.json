{
	"address": "0xd48b633045af65ff636f3c6edd744748351e020d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code based on the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    \n    constructor() {\n        _name = \"MyToken\";\n        _symbol = \"MTK\";\n        _decimals = 18;\n        _totalSupply = 1000000 * 10**_decimals;\n        _balances[msg.sender] = _totalSupply;\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balances[msg.sender] >= amount, \"Insufficient balance.\");\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        return true;\n    }\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        return true;\n    }\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_balances[sender] >= amount, \"Insufficient balance.\");\n        require(_allowances[sender][msg.sender] >= amount, \"Transfer amount exceeds allowance.\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        return true;\n    }\n}\n```\n\nPlease note that the above code doesn't include all the events and functions in the decompiled Bytecode. Only the basic ERC20 functions are included. The contract name, symbol, and decimals are arbitrary and you should change them to fit your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038971,
	"id": "chatcmpl-8ChnHDg7xNjWWuJ4UTuyzaFxElvKN",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 11:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _stakingRequirement; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getFrontEndTokenBalanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _myDividendTokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_8; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _getMyDividendRate; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _calculateTokensReceived; // STORAGE[0xa]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nuint256 _tokensMintedDuringICO; // STORAGE[0xe]\nuint256 _totalEthereumICOReceived; // STORAGE[0xf]\nuint256 _currentEthInvested; // STORAGE[0x10]\nuint256 _totalSupply; // STORAGE[0x11]\nuint256 _getDividendTokenSupply; // STORAGE[0x12]\nuint256 owner_13; // STORAGE[0x13]\nmapping (uint256 => [uint256]) _injectEther; // STORAGE[0x14]\nuint256 _publicStartRegularPhase; // STORAGE[0x16]\nuint8 _icoPhase; // STORAGE[0x15] bytes 0 to 0\nuint16 stor_15_0_1; // STORAGE[0x15] bytes 0 to 1\nuint8 _regularPhase; // STORAGE[0x15] bytes 1 to 1\naddress owner_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nReferral(address, uint256);\nAllocation(uint256, uint256, uint256, uint256, uint256);\nUserDividendRate(address, uint256);\nApproval(address, address, uint256);\nonWithdraw(address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x119f(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = _icoPhase;\n    if (!v3) {\n        v2 = v4 = _regularPhase;\n    }\n    require(v2);\n    if (_icoPhase) {\n        v5 = v6 = v6.data;\n        v7 = v8 = varg0.length;\n        v9 = v10 = varg0.data;\n        while (v7 >= 32) {\n            MEM[v5] = MEM[v9];\n            v7 = v7 + ~31;\n            v5 += 32;\n            v9 += 32;\n        }\n        MEM[v5] = MEM[v5] & ~0 + 256 ** (32 - v7) | MEM[v9] & ~(~0 + 256 ** (32 - v7));\n        v0 = v11 = keccak256(v6);\n        v12 = v13 = v11 == 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262;\n        if (v11 != 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262) {\n            v12 = v14 = msg.sender == owner_3_0_19;\n        }\n        require(v12);\n        v15 = v16 = msg.gas <= 0xba43b7400;\n        if (msg.gas <= 0xba43b7400) {\n            v15 = v17 = _totalEthereumICOReceived <= 0xd8d726b7177a80000;\n        }\n        require(v15);\n    }\n    v18 = varg1 & 0xff;\n    require(map_8[v18] & 0xff);\n    _getMyDividendRate[msg.sender] = 0x1 | ~0xff & _getMyDividendRate[msg.sender];\n    v19 = varg1 & 0xff;\n    _calculateTokensReceived[msg.sender] = v19 | ~0xff & _calculateTokensReceived[msg.sender];\n    emit UserDividendRate(msg.sender, v19);\n    v20 = 0xbcb(v21);\n    return v0;\n}\n\nfunction 0x1501(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (msg.sender == address(varg3)) {\n        v0 = v1 = varg1 >= 0x2540be400;\n        if (v1) {\n            v2 = address(varg3);\n            v0 = v3 = varg1 <= _getFrontEndTokenBalanceOf[v2];\n        }\n        require(v0);\n    } else {\n        v4 = v5 = varg1 >= 0x2540be400;\n        if (v5) {\n            v6 = address(varg3);\n            v4 = v7 = varg1 <= _getFrontEndTokenBalanceOf[v6];\n        }\n        if (v4) {\n            v8 = address(varg3);\n            v4 = v9 = varg1 <= _allowed[msg.sender];\n        }\n        require(v4);\n    }\n    0x277a(varg0, varg1, varg2, varg3);\n    return ;\n}\n\nfunction 0x170e() private { \n    v0 = v1 = 0;\n    require(v0 > 0x5af3107a4000, 'Tried to buy tokens with too little eth.');\n    if (!_icoPhase) {\n        v0 = v2 = 0;\n        if (_currentEthInvested < _totalEthereumICOReceived) {\n            v3 = v4 = _currentEthInvested < _totalEthereumICOReceived;\n            if (v4) {\n                v3 = v5 = _currentEthInvested + v0 <= _totalEthereumICOReceived;\n            }\n            if (!v3) {\n                v6 = v7 = _currentEthInvested < _totalEthereumICOReceived;\n                if (v7) {\n                    v6 = v8 = _currentEthInvested + v0 > _totalEthereumICOReceived;\n                }\n                require(v6);\n                assert(_currentEthInvested <= _totalEthereumICOReceived);\n                v0 = v9 = _totalEthereumICOReceived - _currentEthInvested;\n                assert(v9 <= v0);\n                v0 = v10 = v0 - v9;\n            }\n        }\n        assert(v0 == v0 + v0);\n        v0 = v11 = 0;\n        if (v0) {\n            v0 = v12 = 6321;\n            v0 = v13 = 0x251e66909d000;\n            v0 = v14 = _SafeMul(0xde0b6b3a7640000, v0);\n        }\n        while (1) {\n            assert(v0);\n            v0 = v0 / v0;\n            goto {'0x191c', '0x18b1', '0x18f5'};\n            v0 += v0;\n            v0 += v0;\n            v0 = v15 = 6433;\n            v0 = v16 = 9615;\n            v0 = v17 = 6377;\n            v0 = v18 = 6428;\n            v0 = v19 = 2;\n            v0 = _SafeMul(3, v0);\n            v20 = 0x25bc(v0 ** 2);\n        }\n        v0 = _SafeMul(v0, v20);\n        v0 = v21 = 6466;\n        v0 = v22 = 9615;\n        v0 = v23 = 6377;\n        v0 = v24 = 6428;\n        v0 = v25 = 2;\n        v0 = _SafeMul(3, v0);\n        assert(v0 <= v0);\n        v0 = v26 = 0xf4240 * (v0 - v0);\n        if (v0) {\n            v0 = v27 = 6389;\n            v0 = v28 = 3;\n            v0 = v29 = 3314;\n            v0 = v30 = 2;\n            assert(0x23d1941c0);\n            v20 = 0x1ca3((_totalSupply / 0x23d1941c0) ** 3);\n            goto 0x18e90x170e;\n        }\n        v31 = v32 = v0 + v0;\n        assert(v32 > 0);\n    } else {\n        assert(0x251e66909d000);\n        v31 = v33 = 0xde0b6b3a7640000 * (v0 / 0x251e66909d000);\n    }\n    return v31;\n}\n\nfunction 0x1a8d(uint256 varg0) private { \n    v0 = 0x1cde(1);\n    require(v0 > 0);\n    require(_regularPhase);\n    v1 = 0x1cde(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    if (!address(varg0)) {\n        varg0 = v2 = msg.sender;\n    }\n    v3 = address(varg0).call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v3); // checks call status, propagates error data on error\n    emit onWithdraw(address(varg0), v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0x1bca(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(_regularPhase);\n    v0 = _getFrontEndTokenBalanceOf[msg.sender];\n    v1 = v2 = 0xff & _getMyDividendRate[msg.sender];\n    if (v2) {\n        v1 = v3 = !(varg0 & 0xff);\n    }\n    if (!v1) {\n        v4 = 0x119f(0x3078300000000000000000000000000000000000000000000000000000000000, varg0);\n    } else {\n        v5 = 0xbcb(v6);\n    }\n    assert(0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n    0x1501(varg0, _getFrontEndTokenBalanceOf[msg.sender] - 0, varg1, msg.sender);\n    return ;\n}\n\nfunction 0x1ca3(uint256 varg0) private { \n    varg0 = v0 = varg0 + 1 >> 1;\n    while (varg0 < varg0) {\n        assert(varg0);\n        assert(2);\n        varg0 = varg0 / varg0 + varg0 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x1cde(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_myDividendTokens[msg.sender] * owner_13 - _dividendsOf[msg.sender] >> 64) + owner_b[msg.sender];\n    } else {\n        v0 = _myDividendTokens[msg.sender] * owner_13 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x1f60(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = address(varg0);\n        v1 = address(varg0);\n        v2 = v3 = (_myDividendTokens[v1] * owner_13 - _dividendsOf[v1] >> 64) + owner_b[v0];\n    } else {\n        v4 = address(varg0);\n        v2 = _myDividendTokens[v4] * owner_13 - _dividendsOf[v4] >> 64;\n    }\n    return v2;\n}\n\nfunction 0x2004() private { \n    return _getFrontEndTokenBalanceOf[msg.sender];\n}\n\nfunction 0x2010(uint256 varg0) private { \n    v0 = v1 = 0;\n    require(varg0 >= 0x5af3107a4000, 'Tried to sell too few tokens.');\n    varg0 = v2 = 0;\n    if (_totalSupply > _tokensMintedDuringICO) {\n        v3 = v4 = _totalSupply > _tokensMintedDuringICO;\n        if (v4) {\n            v3 = v5 = _totalSupply - varg0 >= _tokensMintedDuringICO;\n        }\n        if (!v3) {\n            v6 = v7 = _totalSupply > _tokensMintedDuringICO;\n            if (v7) {\n                v6 = v8 = _totalSupply - varg0 < _tokensMintedDuringICO;\n            }\n            require(v6);\n            assert(_tokensMintedDuringICO <= _totalSupply);\n            varg0 = v9 = _totalSupply - _tokensMintedDuringICO;\n            assert(v9 <= varg0);\n            varg0 = v10 = varg0 - v9;\n        }\n    }\n    assert(varg0 == varg0 + varg0);\n    if (varg0) {\n        v11 = v12 = 8521;\n        v13 = v14 = 0xde0b6b3a7640000;\n        v15 = v16 = _SafeMul(0x251e66909d000, varg0);\n    }\n    assert(v13);\n    v0 = v15 / v13;\n    goto {'0x21a8', '0x217b', '0x2149'};\n    v11 = v17 = 8616;\n    v13 = v18 = 3;\n    v19 = v20 = 3314;\n    v21 = v22 = 2;\n    v23 = v24 = 6377;\n    assert(0x23d1941c0);\n    v25 = (_totalSupply - varg0) / 0x23d1941c0;\n    goto 0x18e40x2010;\n    assert(v0 <= v0);\n    v0 = v26 = v0 - v0;\n    if (varg0) {\n        v11 = v27 = 8571;\n        v13 = v28 = 3;\n        v19 = v29 = 3314;\n        v21 = v30 = 2;\n        v23 = v31 = 6377;\n        assert(0x23d1941c0);\n        v25 = v32 = _totalSupply / 0x23d1941c0;\n    }\n    v33 = 0x1ca3(v25 ** 3);\n    v15 = v34 = _SafeMul(v21, v33);\n    assert(v0 + v0 > 0);\n    return v0 + v0;\n}\n\nfunction 0x22d2(uint256 varg0) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v4 = 0x2004();\n    require(v4 > v3);\n    require(!_icoPhase);\n    require(_regularPhase);\n    require(varg0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n    v0 = v5 = 0x25f6(msg.sender);\n    v6 = v7 = v5 >= 0x20000000000000000;\n    if (v5 >= 0x20000000000000000) {\n        v6 = v8 = v5 <= 0x320000000000000000;\n    }\n    require(v6);\n    v0 = v9 = 9098;\n    v0 = v10 = 0x10000000000000000;\n    v0 = v11 = _SafeMul(v5, varg0);\n    while (!v0) {\n        assert(v0);\n        assert(v0 <= v0);\n        assert(v0 <= _totalSupply);\n        _totalSupply = _totalSupply - v0;\n        assert(v0 <= _getDividendTokenSupply);\n        _getDividendTokenSupply = _getDividendTokenSupply - v0;\n        assert(v0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n        _getFrontEndTokenBalanceOf[msg.sender] = _getFrontEndTokenBalanceOf[msg.sender] - v0;\n        assert(v0 <= _myDividendTokens[msg.sender]);\n        _myDividendTokens[msg.sender] = _myDividendTokens[msg.sender] - v0;\n        _myDividendTokens[msg.sender] = _myDividendTokens[msg.sender] - ((v0 - v0 << 64) + v0 * owner_13);\n        if (0 < _getDividendTokenSupply) {\n            assert(_getDividendTokenSupply);\n            assert((v0 << 64) / _getDividendTokenSupply + owner_13 >= owner_13);\n            owner_13 += (v0 << 64) / _getDividendTokenSupply;\n        }\n        emit onTokenSell(msg.sender, v0, v0 - v0);\n        return ;\n        v0 = v0 / v0;\n        goto {'0xcf20x22d2', '0x23d3', '0x238a'};\n        v0 = v12 = 0x2010(v0);\n        if (v12 <= _currentEthInvested) {\n            _currentEthInvested = _currentEthInvested - v12;\n        } else {\n            _currentEthInvested = 0;\n        }\n        v0 = v13 = 9171;\n        v0 = v14 = 0x10000000000000000;\n        v0 = v15 = 3314;\n        v0 = v16 = 100;\n        v17 = 0x25f6(msg.sender);\n        v0 = _SafeMul(v17, v12);\n    }\n}\n\nfunction 0x25bc(uint256 varg0) private { \n    varg0 = v0 = (varg0 + 1) / 3;\n    while (varg0 < varg0) {\n        assert(varg0 * varg0);\n        assert(3);\n        varg0 = (varg0 / (varg0 * varg0) + (varg0 << 1)) / 3;\n    }\n    return varg0;\n}\n\nfunction 0x25f6(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_getFrontEndTokenBalanceOf[v0]);\n    return (_myDividendTokens[v0] << 64) / _getFrontEndTokenBalanceOf[v0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0x277a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    require(_regularPhase);\n    require(address(varg2));\n    v0 = 0x1f60(varg3, 1);\n    if (v0 > 0) {\n        v1 = 0x1f60(varg3, 0);\n        v2 = address(varg3);\n        _dividendsOf[v2] += v1 << 64;\n        _dividendsOf[v2] = 0;\n        v3 = v2.call().value(v1 + _dividendsOf[v2]).gas(2300 * !(v1 + _dividendsOf[v2]));\n        require(v3); // checks call status, propagates error data on error\n        emit onWithdraw(address(varg3), v1 + _dividendsOf[v2]);\n    }\n    v4 = 0x25f6(varg3);\n    v5 = _SafeMul(v4, varg1);\n    assert(0x10000000000000000);\n    if (msg.sender != address(varg3)) {\n        v6 = address(varg3);\n        _allowed[msg.sender] = _allowed[msg.sender] - varg1;\n    }\n    v7 = address(varg3);\n    assert(varg1 <= _getFrontEndTokenBalanceOf[v7]);\n    v8 = address(varg3);\n    _getFrontEndTokenBalanceOf[v8] = _getFrontEndTokenBalanceOf[v7] - varg1;\n    v9 = address(varg2);\n    v10 = varg1 + _getFrontEndTokenBalanceOf[v9];\n    assert(v10 >= _getFrontEndTokenBalanceOf[v9]);\n    v11 = address(varg2);\n    _getFrontEndTokenBalanceOf[v11] = v10;\n    v12 = address(varg3);\n    assert(v5 >> 64 <= _myDividendTokens[v12]);\n    v13 = address(varg3);\n    _myDividendTokens[v13] = _myDividendTokens[v12] - (v5 >> 64);\n    v14 = address(varg2);\n    assert((v5 >> 64) + _myDividendTokens[v14] >= _myDividendTokens[v14]);\n    v15 = address(varg2);\n    _myDividendTokens[v15] = (v5 >> 64) + _myDividendTokens[v14];\n    if (!(0xff & _myDividendTokens[v15])) {\n        v16 = address(varg2);\n        _getMyDividendRate[v16] = 0x1 | ~0xff & _getMyDividendRate[v16];\n        v17 = address(varg3);\n        _calculateTokensReceived[v17] = 0xff & _calculateTokensReceived[v17] | ~0xff & _calculateTokensReceived[v17];\n    }\n    v18 = address(varg3);\n    _dividendsOf[v18] = _dividendsOf[v18] - (v5 >> 64) * owner_13;\n    v19 = address(varg2);\n    _dividendsOf[v19] = _dividendsOf[v19] + (v5 >> 64) * owner_13;\n    if (varg2.code.size > 0) {\n        v20 = address(varg3);\n        v21 = new array[](varg0.length);\n        v22 = address(varg2);\n        v23 = v24 = 0;\n        while (v23 < varg0.length) {\n            MEM[v23 + v21.data] = MEM[v23 + varg0.data];\n            v23 += 32;\n        }\n        v25 = v26 = varg0.length + v21.data;\n        if (0x1f & varg0.length) {\n            MEM[v26 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v26 - (0x1f & varg0.length)];\n        }\n        require(v22.code.size);\n        v27 = v22.tokenFallback(v20, varg1, v21).gas(msg.gas);\n        require(v27); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    emit Transfer(address(varg3), address(varg2), varg1);\n    return ;\n}\n\nfunction fallback() public payable { \n    require(_regularPhase);\n    if (!(0xff & _getMyDividendRate[msg.sender])) {\n        v0 = 0x119f(0x3078300000000000000000000000000000000000000000000000000000000000, 20);\n    } else {\n        v1 = 0xbcb(0);\n    }\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _myDividendTokens[varg0] * owner_13 - _dividendsOf[varg0] >> 64;\n}\n\nfunction totalEthereumICOReceived() public nonPayable { \n    return _totalEthereumICOReceived;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction icoHashedPass() public nonPayable { \n    return 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = _SafeMul(0xff & _calculateTokensReceived[msg.sender], varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    v1 = 0x170e();\n    return v1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferTo(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    0x1501(v0, varg2, varg1, varg0);\n}\n\nfunction currentEthInvested() public nonPayable { \n    return _currentEthInvested;\n}\n\nfunction regularPhase() public nonPayable { \n    return _regularPhase;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v0 = v4 = 0;\n    require(varg0 <= _totalSupply);\n    v2 = v5 = 0x2010(varg0);\n    v0 = v6 = 0x25f6(msg.sender);\n    v2 = v7 = 5674;\n    v0 = v8 = 0x10000000000000000;\n    v2 = v9 = 3314;\n    v0 = v10 = 100;\n    v11 = v12 = _SafeMul(v6, v5);\n    while (!v0) {\n        assert(v0);\n        assert(v11 <= v2);\n        return v2 - v11;\n        v11 = v11 / v0;\n        goto {'0xcf20x15dbB0x55b', '0x162aB0x55b'};\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = varg2 >= 0x2540be400;\n    if (varg2 >= 0x2540be400) {\n        v0 = v2 = varg2 <= _getFrontEndTokenBalanceOf[varg0];\n    }\n    if (v0) {\n        v0 = v3 = varg2 <= _allowed[msg.sender];\n    }\n    require(v0);\n    0x277a(96, varg2, varg1, varg0);\n    return 1;\n}\n\nfunction buyAndTransfer(address varg0, address varg1) public payable { \n    0x1bca(20, 96, varg1);\n}\n\nfunction startRegularPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    stor_15_0_1 = 256;\n}\n\nfunction ethereumToTokens_(uint256 varg0) public nonPayable { \n    v0 = 0x170e();\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction publicStartRegularPhase() public nonPayable { \n    v0 = v1 = block.timestamp > 0x127500 + _publicStartRegularPhase;\n    if (v1) {\n        v0 = v2 = _publicStartRegularPhase;\n    }\n    require(v0);\n    stor_15_0_1 = 256;\n}\n\nfunction sellPrice() public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = _icoPhase;\n    if (!v3) {\n        v2 = _currentEthInvested < _totalEthereumICOReceived;\n    }\n    if (!v2) {\n        v0 = v4 = 6645;\n        v0 = v5 = 0x170e();\n        assert(v5);\n        v0 = v6 = 0x314dc6448d9338c15b0a00000000 / v5;\n    } else {\n        v0 = v7 = 0x251e66909d000;\n    }\n    v0 = v8 = 6735;\n    v0 = v9 = 6722;\n    v0 = v10 = 0x10000000000000000;\n    v0 = v11 = 3314;\n    v0 = v12 = 100;\n    v13 = 0x25f6(msg.sender);\n    v14 = v15 = _SafeMul(v13, v0);\n    while (!v0) {\n        assert(v0);\n        assert(v14 <= v0);\n        return v0 - v14;\n        v14 = v14 / v0;\n        goto {'0xcf20x19b4B0x624', '0x1a42B0x624'};\n    }\n}\n\nfunction getFrontEndTokenBalanceOf(address varg0) public nonPayable { \n    return _getFrontEndTokenBalanceOf[varg0];\n}\n\nfunction getDividendTokenBalanceOf(address varg0) public nonPayable { \n    return _myDividendTokens[varg0];\n}\n\nfunction withdraw(address varg0) public nonPayable { \n    0x1a8d(varg0);\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction ethInvestedDuringICO() public nonPayable { \n    return _totalEthereumICOReceived;\n}\n\nfunction myDividendTokens() public nonPayable { \n    return _myDividendTokens[msg.sender];\n}\n\nfunction buyAndTransfer(address varg0, address varg1, bytes varg2, uint8 varg3) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x1bca(0xff & varg3, v0, varg1);\n}\n\nfunction sqrt(uint256 varg0) public nonPayable { \n    v0 = 0x1ca3(varg0);\n    return v0;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x1cde(varg0);\n    return v0;\n}\n\nfunction icoPhase() public nonPayable { \n    return _icoPhase;\n}\n\nfunction injectEther() public payable { \n    require(0xff & _injectEther[msg.sender]);\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _getFrontEndTokenBalanceOf[varg0];\n}\n\nfunction buyAndSetDivPercentage(address varg0, uint8 varg1, string varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    v2 = 0x119f(v0, 0xff & varg1);\n    return v2;\n}\n\nfunction administrators(address varg0) public nonPayable { \n    return 0xff & _injectEther[varg0];\n}\n\nfunction getMyAverageDividendRate() public nonPayable { \n    v0 = 0x25f6(msg.sender);\n    return v0;\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    require(varg0 >= 0x56bc75e2d63100000);\n    _stakingRequirement = varg0;\n}\n\nfunction setAdministrator(address varg0, bool varg1) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    _injectEther[varg0] = varg1 | ~0xff & _injectEther[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction toPowerOfTwoThirds(uint256 varg0) public nonPayable { \n    v0 = 0x25bc(varg0 ** 2);\n    return v0;\n}\n\nfunction endICOPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    _icoPhase = 0;\n}\n\nfunction myReferralDividends() public nonPayable { \n    v0 = 0x1cde(0);\n    v1 = 0x1cde(1);\n    return v1 - v0;\n}\n\nfunction changeBankroll(address varg0) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    owner_3_0_19 = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x2004();\n    require(v0 > 0);\n    v1 = v2 = varg1 >= 0x2540be400;\n    if (v2) {\n        v1 = v3 = varg1 <= _getFrontEndTokenBalanceOf[msg.sender];\n    }\n    require(v1);\n    0x277a(96, varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction theDividendsOf(bool varg0, address varg1) public nonPayable { \n    v0 = 0x1f60(varg1, varg0);\n    return v0;\n}\n\nfunction getMyDividendRate() public nonPayable { \n    require(0xff & _getMyDividendRate[msg.sender]);\n    return 0xff & _calculateTokensReceived[msg.sender] & 0xff;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(0xff & _injectEther[msg.sender]);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction myFrontEndTokens() public nonPayable { \n    v0 = 0x2004();\n    return v0;\n}\n\nfunction tokensToEthereum_(uint256 varg0) public nonPayable { \n    v0 = 0x2010(varg0);\n    return v0;\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(0xff & _injectEther[msg.sender]);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction buyPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = _icoPhase;\n    if (!v1) {\n        v0 = _currentEthInvested < _totalEthereumICOReceived;\n    }\n    if (!v0) {\n        v2 = 0x170e();\n        assert(v2);\n        v3 = v4 = 0x314dc6448d9338c15b0a00000000 / v2;\n    } else {\n        v3 = v5 = 0x251e66909d000;\n    }\n    v6 = _SafeMul(0, v3);\n    assert(100);\n    assert(v3 + v6 / 100 >= v6 / 100);\n    return v3 + v6 / 100;\n}\n\nfunction startICOPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    require(!_publicStartRegularPhase);\n    _icoPhase = 1;\n    _publicStartRegularPhase = block.timestamp;\n}\n\nfunction tokensMintedDuringICO() public nonPayable { \n    return _tokensMintedDuringICO;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x22d2(varg0);\n}\n\nfunction exit() public nonPayable { \n    require(_regularPhase);\n    if (_getFrontEndTokenBalanceOf[msg.sender] > 0) {\n        0x22d2(_getFrontEndTokenBalanceOf[msg.sender]);\n    }\n    0x1a8d(msg.sender);\n}\n\nfunction buy(address varg0) public payable { \n    require(_regularPhase);\n    require(0xff & _getMyDividendRate[msg.sender]);\n    v0 = 0xbcb(varg0);\n    return msg.sender;\n}\n\nfunction buyAndTransfer(address varg0, address varg1, bytes varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x1bca(20, v0, varg1);\n}\n\nfunction cbrt(uint256 varg0) public nonPayable { \n    v0 = 0x25bc(varg0);\n    return v0;\n}\n\nfunction getUserAverageDividendRate(address varg0) public nonPayable { \n    v0 = 0x25f6(varg0);\n    return v0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x1cde(1);\n    require(v0 > 0);\n    require(_regularPhase);\n    v1 = 0x1cde(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0xbcb(0);\n    emit onReinvestment(0, msg.sender, v2);\n}\n\nfunction toPowerOfThreeHalves(uint256 varg0) public nonPayable { \n    v0 = 0x1ca3(varg0 ** 3);\n    return v0;\n}\n\nfunction getDividendTokenSupply() public nonPayable { \n    return _getDividendTokenSupply;\n}\n\nfunction 0xbcb(uint256 varg0) private { \n    varg0 = v0 = 0;\n    varg0 = v1 = 0;\n    varg0 = v2 = 0;\n    varg0 = v3 = 0;\n    varg0 = v4 = 0;\n    varg0 = v5 = 0;\n    v6 = v7 = v8 >= 0x5af3107a4000;\n    if (v8 < 0x5af3107a4000) {\n        v6 = v9 = msg.sender == owner_3_0_19;\n    }\n    require(v6, 'Tried to buy below the min eth buyin threshold.');\n    if (_regularPhase) {\n        assert(100);\n        varg0 = v10 = v8 / 100;\n        assert(v10 <= v8);\n        varg0 = v11 = v8 - v10;\n    }\n    varg0 = v12 = 0xff & _calculateTokensReceived[msg.sender];\n    v13 = v14 = 3326;\n    v15 = v16 = 100;\n    v17 = v18 = _SafeMul(v12, varg0);\n    while (!v15) {\n        assert(v15);\n        assert(varg0 + owner_13 >= owner_13);\n        owner_13 += varg0;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (varg0 * (varg0 + owner_13) - varg0);\n        v19 = varg0 + _getFrontEndTokenBalanceOf[msg.sender];\n        assert(v19 >= _getFrontEndTokenBalanceOf[msg.sender]);\n        _getFrontEndTokenBalanceOf[msg.sender] = v19;\n        v20 = varg0 + _myDividendTokens[msg.sender];\n        assert(v20 >= _myDividendTokens[msg.sender]);\n        _myDividendTokens[msg.sender] = v20;\n        if (varg0) {\n            require(owner_3_0_19.code.size);\n            v21 = owner_3_0_19.receiveDividends().value(varg0).gas(msg.gas);\n            require(v21); // checks call status, propagates error data on error\n        }\n        if (_regularPhase) {\n            require(stor_4_0_19.code.size);\n            v22 = stor_4_0_19.receiveDividends(varg0).value(varg0).gas(msg.gas);\n            require(v22); // checks call status, propagates error data on error\n        }\n        emit Allocation(varg0, varg0, varg0, varg0, varg0);\n        assert(!(varg0 + (varg0 + (varg0 + (varg0 + varg0))) - varg0));\n        return varg0;\n        varg0 = v17 / v15;\n        goto {'0xeca', '0xcfe', '0xf81'};\n        if (varg0 <= varg0) {\n            break;\n        }\n        assert(varg0 <= varg0);\n        v23 = varg0 - varg0;\n        v24 = v25 = _icoPhase;\n        if (v25) {\n            v24 = v26 = msg.sender == owner_3_0_19;\n        }\n        if (v24) {\n            v23 += varg0;\n        }\n        varg0 = v27 = 3394;\n        varg0 = 0x170e();\n        varg0 = _SafeMul(varg0, varg0);\n        assert(varg0 + _totalSupply >= _totalSupply);\n        _totalSupply += varg0;\n        assert(varg0 + _getDividendTokenSupply >= _getDividendTokenSupply);\n        _getDividendTokenSupply += varg0;\n        _currentEthInvested += varg0;\n        if (!_icoPhase) {\n            v28 = !address(varg0);\n            v29 = v30 = address(varg0);\n            if (address(varg0)) {\n                v29 = v31 = msg.sender != address(varg0);\n            }\n            if (v29) {\n                v32 = address(varg0);\n                v29 = v33 = _getFrontEndTokenBalanceOf[v32] >= _stakingRequirement;\n            }\n            if (v29) {\n                v13 = v34 = 3786;\n                v15 = v35 = 100;\n                v17 = _SafeMul(25, varg0);\n            }\n        } else {\n            if (msg.sender == owner_3_0_19) {\n                varg0 = v36 = 0;\n            }\n            _totalEthereumICOReceived += varg0;\n            _tokensMintedDuringICO += varg0;\n            varg0 = v37 = 0;\n            require(0xd8d726b7177a80000 >= varg0 + _totalEthereumICOReceived);\n            v38 = v39 = msg.sender == tx.origin;\n            if (msg.sender != tx.origin) {\n                v38 = v40 = msg.sender == owner_3_0_19;\n            }\n            require(v38);\n            owner_d[msg.sender] += varg0;\n            v41 = v42 = 0xde0b6b3a7640000 >= varg0 + owner_d[msg.sender];\n            if (0xde0b6b3a7640000 < varg0 + owner_d[msg.sender]) {\n                v41 = v43 = msg.sender == owner_3_0_19;\n            }\n            require(v41);\n            if (_totalEthereumICOReceived == 0xd8d726b7177a80000) {\n                _icoPhase = 0;\n            }\n        }\n        v44 = address(varg0);\n        owner_b[v44] += varg0;\n        emit Referral(v44, varg0);\n        assert(varg0 <= varg0);\n        varg0 = v45 = varg0 - varg0;\n        assert(_getDividendTokenSupply);\n        varg0 = (v45 << 64) - ((v45 << 64) - varg0 * ((v45 << 64) / _getDividendTokenSupply));\n        varg0 = v46 = 3984;\n        v13 = v47 = 3969;\n        v15 = v48 = _getDividendTokenSupply;\n        v17 = _SafeMul(0x10000000000000000, v45);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x3d499ef == function_selector) {\n            totalEthereumICOReceived();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc3c450e == function_selector) {\n            icoHashedPass();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else {\n            if (0x18160ddd != function_selector) {\n                if (0x19fb361f == function_selector) {\n                    transferTo(address,address,uint256,bytes);\n                } else if (0x1b1686b6 == function_selector) {\n                    currentEthInvested();\n                } else if (0x214dda84 == function_selector) {\n                    regularPhase();\n                } else if (0x22609373 == function_selector) {\n                    calculateEthereumReceived(uint256);\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                } else if (0x269a7c3f == function_selector) {\n                    buyAndTransfer(address,address);\n                } else if (0x27dffba6 == function_selector) {\n                    startRegularPhase();\n                } else if (0x2a9121c7 == function_selector) {\n                    ethereumToTokens_(uint256);\n                } else if (0x313ce567 == function_selector) {\n                    decimals();\n                } else if (0x3c7d6f30 == function_selector) {\n                    publicStartRegularPhase();\n                } else if (0x4b750334 == function_selector) {\n                    sellPrice();\n                } else if (0x4c146f38 == function_selector) {\n                    getFrontEndTokenBalanceOf(address);\n                } else if (0x51392041 == function_selector) {\n                    getDividendTokenBalanceOf(address);\n                } else if (0x51cff8d9 == function_selector) {\n                    withdraw(address);\n                } else if (0x56d399e8 == function_selector) {\n                    stakingRequirement();\n                } else if (0x5c658165 == function_selector) {\n                    allowed(address,address);\n                } else if (0x5ccb5460 == function_selector) {\n                    ethInvestedDuringICO();\n                } else if (0x6135e084 == function_selector) {\n                    myDividendTokens();\n                } else if (0x627aa6d2 == function_selector) {\n                    buyAndTransfer(address,address,bytes,uint8);\n                } else if (0x677342ce == function_selector) {\n                    sqrt(uint256);\n                } else if (0x688abbf7 == function_selector) {\n                    myDividends(bool);\n                } else if (0x68955fb1 == function_selector) {\n                    icoPhase();\n                } else if (0x6a3a2119 == function_selector) {\n                    injectEther();\n                } else if (0x6b2f4632 == function_selector) {\n                    totalEthereumBalance();\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x724fcd4c == function_selector) {\n                    buyAndSetDivPercentage(address,uint8,string);\n                } else if (0x76be1585 == function_selector) {\n                    administrators(address);\n                } else if (0x7b89eef2 == function_selector) {\n                    getMyAverageDividendRate();\n                } else if (0x8328b610 == function_selector) {\n                    setStakingRequirement(uint256);\n                } else if (0x87c95058 == function_selector) {\n                    setAdministrator(address,bool);\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0x96242f41 != function_selector) {\n                    if (0x965447d9 == function_selector) {\n                        toPowerOfTwoThirds(uint256);\n                    } else if (0xa3a06c54 == function_selector) {\n                        endICOPhase();\n                    } else if (0xa6d87f7d == function_selector) {\n                        myReferralDividends();\n                    } else if (0xa78bcf6e == function_selector) {\n                        changeBankroll(address);\n                    } else if (0xa9059cbb == function_selector) {\n                        transfer(address,uint256);\n                    } else if (0xb1f253f6 == function_selector) {\n                        theDividendsOf(bool,address);\n                    } else if (0xb607068c == function_selector) {\n                        getMyDividendRate();\n                    } else if (0xb84c8246 == function_selector) {\n                        setSymbol(string);\n                    } else if (0xbcaa218e == function_selector) {\n                        myFrontEndTokens();\n                    } else if (0xbf3b397b == function_selector) {\n                        tokensToEthereum_(uint256);\n                    } else if (0xc47f0027 == function_selector) {\n                        setName(string);\n                    } else if (0xc4dbf622 == function_selector) {\n                        buyPrice(uint256);\n                    } else if (0xccb53365 == function_selector) {\n                        startICOPhase();\n                    } else if (0xd161b56a == function_selector) {\n                        tokensMintedDuringICO();\n                    } else if (0xe4849b32 == function_selector) {\n                        sell(uint256);\n                    } else if (0xe9fad8ee == function_selector) {\n                        exit();\n                    } else if (0xf088d547 == function_selector) {\n                        buy(address);\n                    } else if (0xf2f8569f == function_selector) {\n                        buyAndTransfer(address,address,bytes);\n                    } else if (0xf42c56c2 == function_selector) {\n                        cbrt(uint256);\n                    } else if (0xf8ead7cf == function_selector) {\n                        getUserAverageDividendRate(address);\n                    } else if (0xfdb5a03e == function_selector) {\n                        reinvest();\n                    } else if (0xfdc89f73 == function_selector) {\n                        toPowerOfThreeHalves(uint256);\n                    } else if (0xffcb1edb == function_selector) {\n                        getDividendTokenSupply();\n                    }\n                }\n            }\n            totalSupply();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 11:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _stakingRequirement; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getFrontEndTokenBalanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _myDividendTokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_8; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _getMyDividendRate; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _calculateTokensReceived; // STORAGE[0xa]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nuint256 _tokensMintedDuringICO; // STORAGE[0xe]\nuint256 _totalEthereumICOReceived; // STORAGE[0xf]\nuint256 _currentEthInvested; // STORAGE[0x10]\nuint256 _totalSupply; // STORAGE[0x11]\nuint256 _getDividendTokenSupply; // STORAGE[0x12]\nuint256 owner_13; // STORAGE[0x13]\nmapping (uint256 => [uint256]) _injectEther; // STORAGE[0x14]\nuint256 _publicStartRegularPhase; // STORAGE[0x16]\nuint8 _icoPhase; // STORAGE[0x15] bytes 0 to 0\nuint16 stor_15_0_1; // STORAGE[0x15] bytes 0 to 1\nuint8 _regularPhase; // STORAGE[0x15] bytes 1 to 1\naddress owner_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nReferral(address, uint256);\nAllocation(uint256, uint256, uint256, uint256, uint256);\nUserDividendRate(address, uint256);\nApproval(address, address, uint256);\nonWithdraw(address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x119f(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = _icoPhase;\n    if (!v3) {\n        v2 = v4 = _regularPhase;\n    }\n    require(v2);\n    if (_icoPhase) {\n        v5 = v6 = v6.data;\n        v7 = v8 = varg0.length;\n        v9 = v10 = varg0.data;\n        while (v7 >= 32) {\n            MEM[v5] = MEM[v9];\n            v7 = v7 + ~31;\n            v5 += 32;\n            v9 += 32;\n        }\n        MEM[v5] = MEM[v5] & ~0 + 256 ** (32 - v7) | MEM[v9] & ~(~0 + 256 ** (32 - v7));\n        v0 = v11 = keccak256(v6);\n        v12 = v13 = v11 == 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262;\n        if (v11 != 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262) {\n            v12 = v14 = msg.sender == owner_3_0_19;\n        }\n        require(v12);\n        v15 = v16 = msg.gas <= 0xba43b7400;\n        if (msg.gas <= 0xba43b7400) {\n            v15 = v17 = _totalEthereumICOReceived <= 0xd8d726b7177a80000;\n        }\n        require(v15);\n    }\n    v18 = varg1 & 0xff;\n    require(map_8[v18] & 0xff);\n    _getMyDividendRate[msg.sender] = 0x1 | ~0xff & _getMyDividendRate[msg.sender];\n    v19 = varg1 & 0xff;\n    _calculateTokensReceived[msg.sender] = v19 | ~0xff & _calculateTokensReceived[msg.sender];\n    emit UserDividendRate(msg.sender, v19);\n    v20 = 0xbcb(v21);\n    return v0;\n}\n\nfunction 0x1501(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (msg.sender == address(varg3)) {\n        v0 = v1 = varg1 >= 0x2540be400;\n        if (v1) {\n            v2 = address(varg3);\n            v0 = v3 = varg1 <= _getFrontEndTokenBalanceOf[v2];\n        }\n        require(v0);\n    } else {\n        v4 = v5 = varg1 >= 0x2540be400;\n        if (v5) {\n            v6 = address(varg3);\n            v4 = v7 = varg1 <= _getFrontEndTokenBalanceOf[v6];\n        }\n        if (v4) {\n            v8 = address(varg3);\n            v4 = v9 = varg1 <= _allowed[msg.sender];\n        }\n        require(v4);\n    }\n    0x277a(varg0, varg1, varg2, varg3);\n    return ;\n}\n\nfunction 0x170e() private { \n    v0 = v1 = 0;\n    require(v0 > 0x5af3107a4000, 'Tried to buy tokens with too little eth.');\n    if (!_icoPhase) {\n        v0 = v2 = 0;\n        if (_currentEthInvested < _totalEthereumICOReceived) {\n            v3 = v4 = _currentEthInvested < _totalEthereumICOReceived;\n            if (v4) {\n                v3 = v5 = _currentEthInvested + v0 <= _totalEthereumICOReceived;\n            }\n            if (!v3) {\n                v6 = v7 = _currentEthInvested < _totalEthereumICOReceived;\n                if (v7) {\n                    v6 = v8 = _currentEthInvested + v0 > _totalEthereumICOReceived;\n                }\n                require(v6);\n                assert(_currentEthInvested <= _totalEthereumICOReceived);\n                v0 = v9 = _totalEthereumICOReceived - _currentEthInvested;\n                assert(v9 <= v0);\n                v0 = v10 = v0 - v9;\n            }\n        }\n        assert(v0 == v0 + v0);\n        v0 = v11 = 0;\n        if (v0) {\n            v0 = v12 = 6321;\n            v0 = v13 = 0x251e66909d000;\n            v0 = v14 = _SafeMul(0xde0b6b3a7640000, v0);\n        }\n        while (1) {\n            assert(v0);\n            v0 = v0 / v0;\n            goto {'0x191c', '0x18b1', '0x18f5'};\n            v0 += v0;\n            v0 += v0;\n            v0 = v15 = 6433;\n            v0 = v16 = 9615;\n            v0 = v17 = 6377;\n            v0 = v18 = 6428;\n            v0 = v19 = 2;\n            v0 = _SafeMul(3, v0);\n            v20 = 0x25bc(v0 ** 2);\n        }\n        v0 = _SafeMul(v0, v20);\n        v0 = v21 = 6466;\n        v0 = v22 = 9615;\n        v0 = v23 = 6377;\n        v0 = v24 = 6428;\n        v0 = v25 = 2;\n        v0 = _SafeMul(3, v0);\n        assert(v0 <= v0);\n        v0 = v26 = 0xf4240 * (v0 - v0);\n        if (v0) {\n            v0 = v27 = 6389;\n            v0 = v28 = 3;\n            v0 = v29 = 3314;\n            v0 = v30 = 2;\n            assert(0x23d1941c0);\n            v20 = 0x1ca3((_totalSupply / 0x23d1941c0) ** 3);\n            goto 0x18e90x170e;\n        }\n        v31 = v32 = v0 + v0;\n        assert(v32 > 0);\n    } else {\n        assert(0x251e66909d000);\n        v31 = v33 = 0xde0b6b3a7640000 * (v0 / 0x251e66909d000);\n    }\n    return v31;\n}\n\nfunction 0x1a8d(uint256 varg0) private { \n    v0 = 0x1cde(1);\n    require(v0 > 0);\n    require(_regularPhase);\n    v1 = 0x1cde(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    if (!address(varg0)) {\n        varg0 = v2 = msg.sender;\n    }\n    v3 = address(varg0).call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v3); // checks call status, propagates error data on error\n    emit onWithdraw(address(varg0), v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0x1bca(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(_regularPhase);\n    v0 = _getFrontEndTokenBalanceOf[msg.sender];\n    v1 = v2 = 0xff & _getMyDividendRate[msg.sender];\n    if (v2) {\n        v1 = v3 = !(varg0 & 0xff);\n    }\n    if (!v1) {\n        v4 = 0x119f(0x3078300000000000000000000000000000000000000000000000000000000000, varg0);\n    } else {\n        v5 = 0xbcb(v6);\n    }\n    assert(0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n    0x1501(varg0, _getFrontEndTokenBalanceOf[msg.sender] - 0, varg1, msg.sender);\n    return ;\n}\n\nfunction 0x1ca3(uint256 varg0) private { \n    varg0 = v0 = varg0 + 1 >> 1;\n    while (varg0 < varg0) {\n        assert(varg0);\n        assert(2);\n        varg0 = varg0 / varg0 + varg0 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x1cde(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_myDividendTokens[msg.sender] * owner_13 - _dividendsOf[msg.sender] >> 64) + owner_b[msg.sender];\n    } else {\n        v0 = _myDividendTokens[msg.sender] * owner_13 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x1f60(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = address(varg0);\n        v1 = address(varg0);\n        v2 = v3 = (_myDividendTokens[v1] * owner_13 - _dividendsOf[v1] >> 64) + owner_b[v0];\n    } else {\n        v4 = address(varg0);\n        v2 = _myDividendTokens[v4] * owner_13 - _dividendsOf[v4] >> 64;\n    }\n    return v2;\n}\n\nfunction 0x2004() private { \n    return _getFrontEndTokenBalanceOf[msg.sender];\n}\n\nfunction 0x2010(uint256 varg0) private { \n    v0 = v1 = 0;\n    require(varg0 >= 0x5af3107a4000, 'Tried to sell too few tokens.');\n    varg0 = v2 = 0;\n    if (_totalSupply > _tokensMintedDuringICO) {\n        v3 = v4 = _totalSupply > _tokensMintedDuringICO;\n        if (v4) {\n            v3 = v5 = _totalSupply - varg0 >= _tokensMintedDuringICO;\n        }\n        if (!v3) {\n            v6 = v7 = _totalSupply > _tokensMintedDuringICO;\n            if (v7) {\n                v6 = v8 = _totalSupply - varg0 < _tokensMintedDuringICO;\n            }\n            require(v6);\n            assert(_tokensMintedDuringICO <= _totalSupply);\n            varg0 = v9 = _totalSupply - _tokensMintedDuringICO;\n            assert(v9 <= varg0);\n            varg0 = v10 = varg0 - v9;\n        }\n    }\n    assert(varg0 == varg0 + varg0);\n    if (varg0) {\n        v11 = v12 = 8521;\n        v13 = v14 = 0xde0b6b3a7640000;\n        v15 = v16 = _SafeMul(0x251e66909d000, varg0);\n    }\n    assert(v13);\n    v0 = v15 / v13;\n    goto {'0x21a8', '0x217b', '0x2149'};\n    v11 = v17 = 8616;\n    v13 = v18 = 3;\n    v19 = v20 = 3314;\n    v21 = v22 = 2;\n    v23 = v24 = 6377;\n    assert(0x23d1941c0);\n    v25 = (_totalSupply - varg0) / 0x23d1941c0;\n    goto 0x18e40x2010;\n    assert(v0 <= v0);\n    v0 = v26 = v0 - v0;\n    if (varg0) {\n        v11 = v27 = 8571;\n        v13 = v28 = 3;\n        v19 = v29 = 3314;\n        v21 = v30 = 2;\n        v23 = v31 = 6377;\n        assert(0x23d1941c0);\n        v25 = v32 = _totalSupply / 0x23d1941c0;\n    }\n    v33 = 0x1ca3(v25 ** 3);\n    v15 = v34 = _SafeMul(v21, v33);\n    assert(v0 + v0 > 0);\n    return v0 + v0;\n}\n\nfunction 0x22d2(uint256 varg0) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v4 = 0x2004();\n    require(v4 > v3);\n    require(!_icoPhase);\n    require(_regularPhase);\n    require(varg0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n    v0 = v5 = 0x25f6(msg.sender);\n    v6 = v7 = v5 >= 0x20000000000000000;\n    if (v5 >= 0x20000000000000000) {\n        v6 = v8 = v5 <= 0x320000000000000000;\n    }\n    require(v6);\n    v0 = v9 = 9098;\n    v0 = v10 = 0x10000000000000000;\n    v0 = v11 = _SafeMul(v5, varg0);\n    while (!v0) {\n        assert(v0);\n        assert(v0 <= v0);\n        assert(v0 <= _totalSupply);\n        _totalSupply = _totalSupply - v0;\n        assert(v0 <= _getDividendTokenSupply);\n        _getDividendTokenSupply = _getDividendTokenSupply - v0;\n        assert(v0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n        _getFrontEndTokenBalanceOf[msg.sender] = _getFrontEndTokenBalanceOf[msg.sender] - v0;\n        assert(v0 <= _myDividendTokens[msg.sender]);\n        _myDividendTokens[msg.sender] = _myDividendTokens[msg.sender] - v0;\n        _myDividendTokens[msg.sender] = _myDividendTokens[msg.sender] - ((v0 - v0 << 64) + v0 * owner_13);\n        if (0 < _getDividendTokenSupply) {\n            assert(_getDividendTokenSupply);\n            assert((v0 << 64) / _getDividendTokenSupply + owner_13 >= owner_13);\n            owner_13 += (v0 << 64) / _getDividendTokenSupply;\n        }\n        emit onTokenSell(msg.sender, v0, v0 - v0);\n        return ;\n        v0 = v0 / v0;\n        goto {'0xcf20x22d2', '0x23d3', '0x238a'};\n        v0 = v12 = 0x2010(v0);\n        if (v12 <= _currentEthInvested) {\n            _currentEthInvested = _currentEthInvested - v12;\n        } else {\n            _currentEthInvested = 0;\n        }\n        v0 = v13 = 9171;\n        v0 = v14 = 0x10000000000000000;\n        v0 = v15 = 3314;\n        v0 = v16 = 100;\n        v17 = 0x25f6(msg.sender);\n        v0 = _SafeMul(v17, v12);\n    }\n}\n\nfunction 0x25bc(uint256 varg0) private { \n    varg0 = v0 = (varg0 + 1) / 3;\n    while (varg0 < varg0) {\n        assert(varg0 * varg0);\n        assert(3);\n        varg0 = (varg0 / (varg0 * varg0) + (varg0 << 1)) / 3;\n    }\n    return varg0;\n}\n\nfunction 0x25f6(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_getFrontEndTokenBalanceOf[v0]);\n    return (_myDividendTokens[v0] << 64) / _getFrontEndTokenBalanceOf[v0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0x277a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    require(_regularPhase);\n    require(address(varg2));\n    v0 = 0x1f60(varg3, 1);\n    if (v0 > 0) {\n        v1 = 0x1f60(varg3, 0);\n        v2 = address(varg3);\n        _dividendsOf[v2] += v1 << 64;\n        _dividendsOf[v2] = 0;\n        v3 = v2.call().value(v1 + _dividendsOf[v2]).gas(2300 * !(v1 + _dividendsOf[v2]));\n        require(v3); // checks call status, propagates error data on error\n        emit onWithdraw(address(varg3), v1 + _dividendsOf[v2]);\n    }\n    v4 = 0x25f6(varg3);\n    v5 = _SafeMul(v4, varg1);\n    assert(0x10000000000000000);\n    if (msg.sender != address(varg3)) {\n        v6 = address(varg3);\n        _allowed[msg.sender] = _allowed[msg.sender] - varg1;\n    }\n    v7 = address(varg3);\n    assert(varg1 <= _getFrontEndTokenBalanceOf[v7]);\n    v8 = address(varg3);\n    _getFrontEndTokenBalanceOf[v8] = _getFrontEndTokenBalanceOf[v7] - varg1;\n    v9 = address(varg2);\n    v10 = varg1 + _getFrontEndTokenBalanceOf[v9];\n    assert(v10 >= _getFrontEndTokenBalanceOf[v9]);\n    v11 = address(varg2);\n    _getFrontEndTokenBalanceOf[v11] = v10;\n    v12 = address(varg3);\n    assert(v5 >> 64 <= _myDividendTokens[v12]);\n    v13 = address(varg3);\n    _myDividendTokens[v13] = _myDividendTokens[v12] - (v5 >> 64);\n    v14 = address(varg2);\n    assert((v5 >> 64) + _myDividendTokens[v14] >= _myDividendTokens[v14]);\n    v15 = address(varg2);\n    _myDividendTokens[v15] = (v5 >> 64) + _myDividendTokens[v14];\n    if (!(0xff & _myDividendTokens[v15])) {\n        v16 = address(varg2);\n        _getMyDividendRate[v16] = 0x1 | ~0xff & _getMyDividendRate[v16];\n        v17 = address(varg3);\n        _calculateTokensReceived[v17] = 0xff & _calculateTokensReceived[v17] | ~0xff & _calculateTokensReceived[v17];\n    }\n    v18 = address(varg3);\n    _dividendsOf[v18] = _dividendsOf[v18] - (v5 >> 64) * owner_13;\n    v19 = address(varg2);\n    _dividendsOf[v19] = _dividendsOf[v19] + (v5 >> 64) * owner_13;\n    if (varg2.code.size > 0) {\n        v20 = address(varg3);\n        v21 = new array[](varg0.length);\n        v22 = address(varg2);\n        v23 = v24 = 0;\n        while (v23 < varg0.length) {\n            MEM[v23 + v21.data] = MEM[v23 + varg0.data];\n            v23 += 32;\n        }\n        v25 = v26 = varg0.length + v21.data;\n        if (0x1f & varg0.length) {\n            MEM[v26 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v26 - (0x1f & varg0.length)];\n        }\n        require(v22.code.size);\n        v27 = v22.tokenFallback(v20, varg1, v21).gas(msg.gas);\n        require(v27); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    emit Transfer(address(varg3), address(varg2), varg1);\n    return ;\n}\n\nfunction fallback() public payable { \n    require(_regularPhase);\n    if (!(0xff & _getMyDividendRate[msg.sender])) {\n        v0 = 0x119f(0x3078300000000000000000000000000000000000000000000000000000000000, 20);\n    } else {\n        v1 = 0xbcb(0);\n    }\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _myDividendTokens[varg0] * owner_13 - _dividendsOf[varg0] >> 64;\n}\n\nfunction totalEthereumICOReceived() public nonPayable { \n    return _totalEthereumICOReceived;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction icoHashedPass() public nonPayable { \n    return 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = _SafeMul(0xff & _calculateTokensReceived[msg.sender], varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    v1 = 0x170e();\n    return v1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferTo(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    0x1501(v0, varg2, varg1, varg0);\n}\n\nfunction currentEthInvested() public nonPayable { \n    return _currentEthInvested;\n}\n\nfunction regularPhase() public nonPayable { \n    return _regularPhase;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v0 = v4 = 0;\n    require(varg0 <= _totalSupply);\n    v2 = v5 = 0x2010(varg0);\n    v0 = v6 = 0x25f6(msg.sender);\n    v2 = v7 = 5674;\n    v0 = v8 = 0x10000000000000000;\n    v2 = v9 = 3314;\n    v0 = v10 = 100;\n    v11 = v12 = _SafeMul(v6, v5);\n    while (!v0) {\n        assert(v0);\n        assert(v11 <= v2);\n        return v2 - v11;\n        v11 = v11 / v0;\n        goto {'0xcf20x15dbB0x55b', '0x162aB0x55b'};\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = varg2 >= 0x2540be400;\n    if (varg2 >= 0x2540be400) {\n        v0 = v2 = varg2 <= _getFrontEndTokenBalanceOf[varg0];\n    }\n    if (v0) {\n        v0 = v3 = varg2 <= _allowed[msg.sender];\n    }\n    require(v0);\n    0x277a(96, varg2, varg1, varg0);\n    return 1;\n}\n\nfunction buyAndTransfer(address varg0, address varg1) public payable { \n    0x1bca(20, 96, varg1);\n}\n\nfunction startRegularPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    stor_15_0_1 = 256;\n}\n\nfunction ethereumToTokens_(uint256 varg0) public nonPayable { \n    v0 = 0x170e();\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction publicStartRegularPhase() public nonPayable { \n    v0 = v1 = block.timestamp > 0x127500 + _publicStartRegularPhase;\n    if (v1) {\n        v0 = v2 = _publicStartRegularPhase;\n    }\n    require(v0);\n    stor_15_0_1 = 256;\n}\n\nfunction sellPrice() public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = _icoPhase;\n    if (!v3) {\n        v2 = _currentEthInvested < _totalEthereumICOReceived;\n    }\n    if (!v2) {\n        v0 = v4 = 6645;\n        v0 = v5 = 0x170e();\n        assert(v5);\n        v0 = v6 = 0x314dc6448d9338c15b0a00000000 / v5;\n    } else {\n        v0 = v7 = 0x251e66909d000;\n    }\n    v0 = v8 = 6735;\n    v0 = v9 = 6722;\n    v0 = v10 = 0x10000000000000000;\n    v0 = v11 = 3314;\n    v0 = v12 = 100;\n    v13 = 0x25f6(msg.sender);\n    v14 = v15 = _SafeMul(v13, v0);\n    while (!v0) {\n        assert(v0);\n        assert(v14 <= v0);\n        return v0 - v14;\n        v14 = v14 / v0;\n        goto {'0xcf20x19b4B0x624', '0x1a42B0x624'};\n    }\n}\n\nfunction getFrontEndTokenBalanceOf(address varg0) public nonPayable { \n    return _getFrontEndTokenBalanceOf[varg0];\n}\n\nfunction getDividendTokenBalanceOf(address varg0) public nonPayable { \n    return _myDividendTokens[varg0];\n}\n\nfunction withdraw(address varg0) public nonPayable { \n    0x1a8d(varg0);\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction ethInvestedDuringICO() public nonPayable { \n    return _totalEthereumICOReceived;\n}\n\nfunction myDividendTokens() public nonPayable { \n    return _myDividendTokens[msg.sender];\n}\n\nfunction buyAndTransfer(address varg0, address varg1, bytes varg2, uint8 varg3) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x1bca(0xff & varg3, v0, varg1);\n}\n\nfunction sqrt(uint256 varg0) public nonPayable { \n    v0 = 0x1ca3(varg0);\n    return v0;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x1cde(varg0);\n    return v0;\n}\n\nfunction icoPhase() public nonPayable { \n    return _icoPhase;\n}\n\nfunction injectEther() public payable { \n    require(0xff & _injectEther[msg.sender]);\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _getFrontEndTokenBalanceOf[varg0];\n}\n\nfunction buyAndSetDivPercentage(address varg0, uint8 varg1, string varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    v2 = 0x119f(v0, 0xff & varg1);\n    return v2;\n}\n\nfunction administrators(address varg0) public nonPayable { \n    return 0xff & _injectEther[varg0];\n}\n\nfunction getMyAverageDividendRate() public nonPayable { \n    v0 = 0x25f6(msg.sender);\n    return v0;\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    require(varg0 >= 0x56bc75e2d63100000);\n    _stakingRequirement = varg0;\n}\n\nfunction setAdministrator(address varg0, bool varg1) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    _injectEther[varg0] = varg1 | ~0xff & _injectEther[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction toPowerOfTwoThirds(uint256 varg0) public nonPayable { \n    v0 = 0x25bc(varg0 ** 2);\n    return v0;\n}\n\nfunction endICOPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    _icoPhase = 0;\n}\n\nfunction myReferralDividends() public nonPayable { \n    v0 = 0x1cde(0);\n    v1 = 0x1cde(1);\n    return v1 - v0;\n}\n\nfunction changeBankroll(address varg0) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    owner_3_0_19 = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x2004();\n    require(v0 > 0);\n    v1 = v2 = varg1 >= 0x2540be400;\n    if (v2) {\n        v1 = v3 = varg1 <= _getFrontEndTokenBalanceOf[msg.sender];\n    }\n    require(v1);\n    0x277a(96, varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction theDividendsOf(bool varg0, address varg1) public nonPayable { \n    v0 = 0x1f60(varg1, varg0);\n    return v0;\n}\n\nfunction getMyDividendRate() public nonPayable { \n    require(0xff & _getMyDividendRate[msg.sender]);\n    return 0xff & _calculateTokensReceived[msg.sender] & 0xff;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(0xff & _injectEther[msg.sender]);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction myFrontEndTokens() public nonPayable { \n    v0 = 0x2004();\n    return v0;\n}\n\nfunction tokensToEthereum_(uint256 varg0) public nonPayable { \n    v0 = 0x2010(varg0);\n    return v0;\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(0xff & _injectEther[msg.sender]);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction buyPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = _icoPhase;\n    if (!v1) {\n        v0 = _currentEthInvested < _totalEthereumICOReceived;\n    }\n    if (!v0) {\n        v2 = 0x170e();\n        assert(v2);\n        v3 = v4 = 0x314dc6448d9338c15b0a00000000 / v2;\n    } else {\n        v3 = v5 = 0x251e66909d000;\n    }\n    v6 = _SafeMul(0, v3);\n    assert(100);\n    assert(v3 + v6 / 100 >= v6 / 100);\n    return v3 + v6 / 100;\n}\n\nfunction startICOPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    require(!_publicStartRegularPhase);\n    _icoPhase = 1;\n    _publicStartRegularPhase = block.timestamp;\n}\n\nfunction tokensMintedDuringICO() public nonPayable { \n    return _tokensMintedDuringICO;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x22d2(varg0);\n}\n\nfunction exit() public nonPayable { \n    require(_regularPhase);\n    if (_getFrontEndTokenBalanceOf[msg.sender] > 0) {\n        0x22d2(_getFrontEndTokenBalanceOf[msg.sender]);\n    }\n    0x1a8d(msg.sender);\n}\n\nfunction buy(address varg0) public payable { \n    require(_regularPhase);\n    require(0xff & _getMyDividendRate[msg.sender]);\n    v0 = 0xbcb(varg0);\n    return msg.sender;\n}\n\nfunction buyAndTransfer(address varg0, address varg1, bytes varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x1bca(20, v0, varg1);\n}\n\nfunction cbrt(uint256 varg0) public nonPayable { \n    v0 = 0x25bc(varg0);\n    return v0;\n}\n\nfunction getUserAverageDividendRate(address varg0) public nonPayable { \n    v0 = 0x25f6(varg0);\n    return v0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x1cde(1);\n    require(v0 > 0);\n    require(_regularPhase);\n    v1 = 0x1cde(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0xbcb(0);\n    emit onReinvestment(0, msg.sender, v2);\n}\n\nfunction toPowerOfThreeHalves(uint256 varg0) public nonPayable { \n    v0 = 0x1ca3(varg0 ** 3);\n    return v0;\n}\n\nfunction getDividendTokenSupply() public nonPayable { \n    return _getDividendTokenSupply;\n}\n\nfunction 0xbcb(uint256 varg0) private { \n    varg0 = v0 = 0;\n    varg0 = v1 = 0;\n    varg0 = v2 = 0;\n    varg0 = v3 = 0;\n    varg0 = v4 = 0;\n    varg0 = v5 = 0;\n    v6 = v7 = v8 >= 0x5af3107a4000;\n    if (v8 < 0x5af3107a4000) {\n        v6 = v9 = msg.sender == owner_3_0_19;\n    }\n    require(v6, 'Tried to buy below the min eth buyin threshold.');\n    if (_regularPhase) {\n        assert(100);\n        varg0 = v10 = v8 / 100;\n        assert(v10 <= v8);\n        varg0 = v11 = v8 - v10;\n    }\n    varg0 = v12 = 0xff & _calculateTokensReceived[msg.sender];\n    v13 = v14 = 3326;\n    v15 = v16 = 100;\n    v17 = v18 = _SafeMul(v12, varg0);\n    while (!v15) {\n        assert(v15);\n        assert(varg0 + owner_13 >= owner_13);\n        owner_13 += varg0;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (varg0 * (varg0 + owner_13) - varg0);\n        v19 = varg0 + _getFrontEndTokenBalanceOf[msg.sender];\n        assert(v19 >= _getFrontEndTokenBalanceOf[msg.sender]);\n        _getFrontEndTokenBalanceOf[msg.sender] = v19;\n        v20 = varg0 + _myDividendTokens[msg.sender];\n        assert(v20 >= _myDividendTokens[msg.sender]);\n        _myDividendTokens[msg.sender] = v20;\n        if (varg0) {\n            require(owner_3_0_19.code.size);\n            v21 = owner_3_0_19.receiveDividends().value(varg0).gas(msg.gas);\n            require(v21); // checks call status, propagates error data on error\n        }\n        if (_regularPhase) {\n            require(stor_4_0_19.code.size);\n            v22 = stor_4_0_19.receiveDividends(varg0).value(varg0).gas(msg.gas);\n            require(v22); // checks call status, propagates error data on error\n        }\n        emit Allocation(varg0, varg0, varg0, varg0, varg0);\n        assert(!(varg0 + (varg0 + (varg0 + (varg0 + varg0))) - varg0));\n        return varg0;\n        varg0 = v17 / v15;\n        goto {'0xeca', '0xcfe', '0xf81'};\n        if (varg0 <= varg0) {\n            break;\n        }\n        assert(varg0 <= varg0);\n        v23 = varg0 - varg0;\n        v24 = v25 = _icoPhase;\n        if (v25) {\n            v24 = v26 = msg.sender == owner_3_0_19;\n        }\n        if (v24) {\n            v23 += varg0;\n        }\n        varg0 = v27 = 3394;\n        varg0 = 0x170e();\n        varg0 = _SafeMul(varg0, varg0);\n        assert(varg0 + _totalSupply >= _totalSupply);\n        _totalSupply += varg0;\n        assert(varg0 + _getDividendTokenSupply >= _getDividendTokenSupply);\n        _getDividendTokenSupply += varg0;\n        _currentEthInvested += varg0;\n        if (!_icoPhase) {\n            v28 = !address(varg0);\n            v29 = v30 = address(varg0);\n            if (address(varg0)) {\n                v29 = v31 = msg.sender != address(varg0);\n            }\n            if (v29) {\n                v32 = address(varg0);\n                v29 = v33 = _getFrontEndTokenBalanceOf[v32] >= _stakingRequirement;\n            }\n            if (v29) {\n                v13 = v34 = 3786;\n                v15 = v35 = 100;\n                v17 = _SafeMul(25, varg0);\n            }\n        } else {\n            if (msg.sender == owner_3_0_19) {\n                varg0 = v36 = 0;\n            }\n            _totalEthereumICOReceived += varg0;\n            _tokensMintedDuringICO += varg0;\n            varg0 = v37 = 0;\n            require(0xd8d726b7177a80000 >= varg0 + _totalEthereumICOReceived);\n            v38 = v39 = msg.sender == tx.origin;\n            if (msg.sender != tx.origin) {\n                v38 = v40 = msg.sender == owner_3_0_19;\n            }\n            require(v38);\n            owner_d[msg.sender] += varg0;\n            v41 = v42 = 0xde0b6b3a7640000 >= varg0 + owner_d[msg.sender];\n            if (0xde0b6b3a7640000 < varg0 + owner_d[msg.sender]) {\n                v41 = v43 = msg.sender == owner_3_0_19;\n            }\n            require(v41);\n            if (_totalEthereumICOReceived == 0xd8d726b7177a80000) {\n                _icoPhase = 0;\n            }\n        }\n        v44 = address(varg0);\n        owner_b[v44] += varg0;\n        emit Referral(v44, varg0);\n        assert(varg0 <= varg0);\n        varg0 = v45 = varg0 - varg0;\n        assert(_getDividendTokenSupply);\n        varg0 = (v45 << 64) - ((v45 << 64) - varg0 * ((v45 << 64) / _getDividendTokenSupply));\n        varg0 = v46 = 3984;\n        v13 = v47 = 3969;\n        v15 = v48 = _getDividendTokenSupply;\n        v17 = _SafeMul(0x10000000000000000, v45);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x3d499ef == function_selector) {\n            totalEthereumICOReceived();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc3c450e == function_selector) {\n            icoHashedPass();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else {\n            if (0x18160ddd != function_selector) {\n                if (0x19fb361f == function_selector) {\n                    transferTo(address,address,uint256,bytes);\n                } else if (0x1b1686b6 == function_selector) {\n                    currentEthInvested();\n                } else if (0x214dda84 == function_selector) {\n                    regularPhase();\n                } else if (0x22609373 == function_selector) {\n                    calculateEthereumReceived(uint256);\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                } else if (0x269a7c3f == function_selector) {\n                    buyAndTransfer(address,address);\n                } else if (0x27dffba6 == function_selector) {\n                    startRegularPhase();\n                } else if (0x2a9121c7 == function_selector) {\n                    ethereumToTokens_(uint256);\n                } else if (0x313ce567 == function_selector) {\n                    decimals();\n                } else if (0x3c7d6f30 == function_selector) {\n                    publicStartRegularPhase();\n                } else if (0x4b750334 == function_selector) {\n                    sellPrice();\n                } else if (0x4c146f38 == function_selector) {\n                    getFrontEndTokenBalanceOf(address);\n                } else if (0x51392041 == function_selector) {\n                    getDividendTokenBalanceOf(address);\n                } else if (0x51cff8d9 == function_selector) {\n                    withdraw(address);\n                } else if (0x56d399e8 == function_selector) {\n                    stakingRequirement();\n                } else if (0x5c658165 == function_selector) {\n                    allowed(address,address);\n                } else if (0x5ccb5460 == function_selector) {\n                    ethInvestedDuringICO();\n                } else if (0x6135e084 == function_selector) {\n                    myDividendTokens();\n                } else if (0x627aa6d2 == function_selector) {\n                    buyAndTransfer(address,address,bytes,uint8);\n                } else if (0x677342ce == function_selector) {\n                    sqrt(uint256);\n                } else if (0x688abbf7 == function_selector) {\n                    myDividends(bool);\n                } else if (0x68955fb1 == function_selector) {\n                    icoPhase();\n                } else if (0x6a3a2119 == function_selector) {\n                    injectEther();\n                } else if (0x6b2f4632 == function_selector) {\n                    totalEthereumBalance();\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x724fcd4c == function_selector) {\n                    buyAndSetDivPercentage(address,uint8,string);\n                } else if (0x76be1585 == function_selector) {\n                    administrators(address);\n                } else if (0x7b89eef2 == function_selector) {\n                    getMyAverageDividendRate();\n                } else if (0x8328b610 == function_selector) {\n                    setStakingRequirement(uint256);\n                } else if (0x87c95058 == function_selector) {\n                    setAdministrator(address,bool);\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0x96242f41 != function_selector) {\n                    if (0x965447d9 == function_selector) {\n                        toPowerOfTwoThirds(uint256);\n                    } else if (0xa3a06c54 == function_selector) {\n                        endICOPhase();\n                    } else if (0xa6d87f7d == function_selector) {\n                        myReferralDividends();\n                    } else if (0xa78bcf6e == function_selector) {\n                        changeBankroll(address);\n                    } else if (0xa9059cbb == function_selector) {\n                        transfer(address,uint256);\n                    } else if (0xb1f253f6 == function_selector) {\n                        theDividendsOf(bool,address);\n                    } else if (0xb607068c == function_selector) {\n                        getMyDividendRate();\n                    } else if (0xb84c8246 == function_selector) {\n                        setSymbol(string);\n                    } else if (0xbcaa218e == function_selector) {\n                        myFrontEndTokens();\n                    } else if (0xbf3b397b == function_selector) {\n                        tokensToEthereum_(uint256);\n                    } else if (0xc47f0027 == function_selector) {\n                        setName(string);\n                    } else if (0xc4dbf622 == function_selector) {\n                        buyPrice(uint256);\n                    } else if (0xccb53365 == function_selector) {\n                        startICOPhase();\n                    } else if (0xd161b56a == function_selector) {\n                        tokensMintedDuringICO();\n                    } else if (0xe4849b32 == function_selector) {\n                        sell(uint256);\n                    } else if (0xe9fad8ee == function_selector) {\n                        exit();\n                    } else if (0xf088d547 == function_selector) {\n                        buy(address);\n                    } else if (0xf2f8569f == function_selector) {\n                        buyAndTransfer(address,address,bytes);\n                    } else if (0xf42c56c2 == function_selector) {\n                        cbrt(uint256);\n                    } else if (0xf8ead7cf == function_selector) {\n                        getUserAverageDividendRate(address);\n                    } else if (0xfdb5a03e == function_selector) {\n                        reinvest();\n                    } else if (0xfdc89f73 == function_selector) {\n                        toPowerOfThreeHalves(uint256);\n                    } else if (0xffcb1edb == function_selector) {\n                        getDividendTokenSupply();\n                    }\n                }\n            }\n            totalSupply();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 11:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _stakingRequirement; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getFrontEndTokenBalanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _myDividendTokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_8; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _getMyDividendRate; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _calculateTokensReceived; // STORAGE[0xa]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nuint256 _tokensMintedDuringICO; // STORAGE[0xe]\nuint256 _totalEthereumICOReceived; // STORAGE[0xf]\nuint256 _currentEthInvested; // STORAGE[0x10]\nuint256 _totalSupply; // STORAGE[0x11]\nuint256 _getDividendTokenSupply; // STORAGE[0x12]\nuint256 owner_13; // STORAGE[0x13]\nmapping (uint256 => [uint256]) _injectEther; // STORAGE[0x14]\nuint256 _publicStartRegularPhase; // STORAGE[0x16]\nuint8 _icoPhase; // STORAGE[0x15] bytes 0 to 0\nuint16 stor_15_0_1; // STORAGE[0x15] bytes 0 to 1\nuint8 _regularPhase; // STORAGE[0x15] bytes 1 to 1\naddress owner_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nReferral(address, uint256);\nAllocation(uint256, uint256, uint256, uint256, uint256);\nUserDividendRate(address, uint256);\nApproval(address, address, uint256);\nonWithdraw(address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x119f(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = _icoPhase;\n    if (!v3) {\n        v2 = v4 = _regularPhase;\n    }\n    require(v2);\n    if (_icoPhase) {\n        v5 = v6 = v6.data;\n        v7 = v8 = varg0.length;\n        v9 = v10 = varg0.data;\n        while (v7 >= 32) {\n            MEM[v5] = MEM[v9];\n            v7 = v7 + ~31;\n            v5 += 32;\n            v9 += 32;\n        }\n        MEM[v5] = MEM[v5] & ~0 + 256 ** (32 - v7) | MEM[v9] & ~(~0 + 256 ** (32 - v7));\n        v0 = v11 = keccak256(v6);\n        v12 = v13 = v11 == 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262;\n        if (v11 != 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262) {\n            v12 = v14 = msg.sender == owner_3_0_19;\n        }\n        require(v12);\n        v15 = v16 = msg.gas <= 0xba43b7400;\n        if (msg.gas <= 0xba43b7400) {\n            v15 = v17 = _totalEthereumICOReceived <= 0xd8d726b7177a80000;\n        }\n        require(v15);\n    }\n    v18 = varg1 & 0xff;\n    require(map_8[v18] & 0xff);\n    _getMyDividendRate[msg.sender] = 0x1 | ~0xff & _getMyDividendRate[msg.sender];\n    v19 = varg1 & 0xff;\n    _calculateTokensReceived[msg.sender] = v19 | ~0xff & _calculateTokensReceived[msg.sender];\n    emit UserDividendRate(msg.sender, v19);\n    v20 = 0xbcb(v21);\n    return v0;\n}\n\nfunction 0x1501(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (msg.sender == address(varg3)) {\n        v0 = v1 = varg1 >= 0x2540be400;\n        if (v1) {\n            v2 = address(varg3);\n            v0 = v3 = varg1 <= _getFrontEndTokenBalanceOf[v2];\n        }\n        require(v0);\n    } else {\n        v4 = v5 = varg1 >= 0x2540be400;\n        if (v5) {\n            v6 = address(varg3);\n            v4 = v7 = varg1 <= _getFrontEndTokenBalanceOf[v6];\n        }\n        if (v4) {\n            v8 = address(varg3);\n            v4 = v9 = varg1 <= _allowed[msg.sender];\n        }\n        require(v4);\n    }\n    0x277a(varg0, varg1, varg2, varg3);\n    return ;\n}\n\nfunction 0x170e() private { \n    v0 = v1 = 0;\n    require(v0 > 0x5af3107a4000, 'Tried to buy tokens with too little eth.');\n    if (!_icoPhase) {\n        v0 = v2 = 0;\n        if (_currentEthInvested < _totalEthereumICOReceived) {\n            v3 = v4 = _currentEthInvested < _totalEthereumICOReceived;\n            if (v4) {\n                v3 = v5 = _currentEthInvested + v0 <= _totalEthereumICOReceived;\n            }\n            if (!v3) {\n                v6 = v7 = _currentEthInvested < _totalEthereumICOReceived;\n                if (v7) {\n                    v6 = v8 = _currentEthInvested + v0 > _totalEthereumICOReceived;\n                }\n                require(v6);\n                assert(_currentEthInvested <= _totalEthereumICOReceived);\n                v0 = v9 = _totalEthereumICOReceived - _currentEthInvested;\n                assert(v9 <= v0);\n                v0 = v10 = v0 - v9;\n            }\n        }\n        assert(v0 == v0 + v0);\n        v0 = v11 = 0;\n        if (v0) {\n            v0 = v12 = 6321;\n            v0 = v13 = 0x251e66909d000;\n            v0 = v14 = _SafeMul(0xde0b6b3a7640000, v0);\n        }\n        while (1) {\n            assert(v0);\n            v0 = v0 / v0;\n            goto {'0x191c', '0x18b1', '0x18f5'};\n            v0 += v0;\n            v0 += v0;\n            v0 = v15 = 6433;\n            v0 = v16 = 9615;\n            v0 = v17 = 6377;\n            v0 = v18 = 6428;\n            v0 = v19 = 2;\n            v0 = _SafeMul(3, v0);\n            v20 = 0x25bc(v0 ** 2);\n        }\n        v0 = _SafeMul(v0, v20);\n        v0 = v21 = 6466;\n        v0 = v22 = 9615;\n        v0 = v23 = 6377;\n        v0 = v24 = 6428;\n        v0 = v25 = 2;\n        v0 = _SafeMul(3, v0);\n        assert(v0 <= v0);\n        v0 = v26 = 0xf4240 * (v0 - v0);\n        if (v0) {\n            v0 = v27 = 6389;\n            v0 = v28 = 3;\n            v0 = v29 = 3314;\n            v0 = v30 = 2;\n            assert(0x23d1941c0);\n            v20 = 0x1ca3((_totalSupply / 0x23d1941c0) ** 3);\n            goto 0x18e90x170e;\n        }\n        v31 = v32 = v0 + v0;\n        assert(v32 > 0);\n    } else {\n        assert(0x251e66909d000);\n        v31 = v33 = 0xde0b6b3a7640000 * (v0 / 0x251e66909d000);\n    }\n    return v31;\n}\n\nfunction 0x1a8d(uint256 varg0) private { \n    v0 = 0x1cde(1);\n    require(v0 > 0);\n    require(_regularPhase);\n    v1 = 0x1cde(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    if (!address(varg0)) {\n        varg0 = v2 = msg.sender;\n    }\n    v3 = address(varg0).call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v3); // checks call status, propagates error data on error\n    emit onWithdraw(address(varg0), v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0x1bca(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(_regularPhase);\n    v0 = _getFrontEndTokenBalanceOf[msg.sender];\n    v1 = v2 = 0xff & _getMyDividendRate[msg.sender];\n    if (v2) {\n        v1 = v3 = !(varg0 & 0xff);\n    }\n    if (!v1) {\n        v4 = 0x119f(0x3078300000000000000000000000000000000000000000000000000000000000, varg0);\n    } else {\n        v5 = 0xbcb(v6);\n    }\n    assert(0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n    0x1501(varg0, _getFrontEndTokenBalanceOf[msg.sender] - 0, varg1, msg.sender);\n    return ;\n}\n\nfunction 0x1ca3(uint256 varg0) private { \n    varg0 = v0 = varg0 + 1 >> 1;\n    while (varg0 < varg0) {\n        assert(varg0);\n        assert(2);\n        varg0 = varg0 / varg0 + varg0 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x1cde(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_myDividendTokens[msg.sender] * owner_13 - _dividendsOf[msg.sender] >> 64) + owner_b[msg.sender];\n    } else {\n        v0 = _myDividendTokens[msg.sender] * owner_13 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x1f60(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = address(varg0);\n        v1 = address(varg0);\n        v2 = v3 = (_myDividendTokens[v1] * owner_13 - _dividendsOf[v1] >> 64) + owner_b[v0];\n    } else {\n        v4 = address(varg0);\n        v2 = _myDividendTokens[v4] * owner_13 - _dividendsOf[v4] >> 64;\n    }\n    return v2;\n}\n\nfunction 0x2004() private { \n    return _getFrontEndTokenBalanceOf[msg.sender];\n}\n\nfunction 0x2010(uint256 varg0) private { \n    v0 = v1 = 0;\n    require(varg0 >= 0x5af3107a4000, 'Tried to sell too few tokens.');\n    varg0 = v2 = 0;\n    if (_totalSupply > _tokensMintedDuringICO) {\n        v3 = v4 = _totalSupply > _tokensMintedDuringICO;\n        if (v4) {\n            v3 = v5 = _totalSupply - varg0 >= _tokensMintedDuringICO;\n        }\n        if (!v3) {\n            v6 = v7 = _totalSupply > _tokensMintedDuringICO;\n            if (v7) {\n                v6 = v8 = _totalSupply - varg0 < _tokensMintedDuringICO;\n            }\n            require(v6);\n            assert(_tokensMintedDuringICO <= _totalSupply);\n            varg0 = v9 = _totalSupply - _tokensMintedDuringICO;\n            assert(v9 <= varg0);\n            varg0 = v10 = varg0 - v9;\n        }\n    }\n    assert(varg0 == varg0 + varg0);\n    if (varg0) {\n        v11 = v12 = 8521;\n        v13 = v14 = 0xde0b6b3a7640000;\n        v15 = v16 = _SafeMul(0x251e66909d000, varg0);\n    }\n    assert(v13);\n    v0 = v15 / v13;\n    goto {'0x21a8', '0x217b', '0x2149'};\n    v11 = v17 = 8616;\n    v13 = v18 = 3;\n    v19 = v20 = 3314;\n    v21 = v22 = 2;\n    v23 = v24 = 6377;\n    assert(0x23d1941c0);\n    v25 = (_totalSupply - varg0) / 0x23d1941c0;\n    goto 0x18e40x2010;\n    assert(v0 <= v0);\n    v0 = v26 = v0 - v0;\n    if (varg0) {\n        v11 = v27 = 8571;\n        v13 = v28 = 3;\n        v19 = v29 = 3314;\n        v21 = v30 = 2;\n        v23 = v31 = 6377;\n        assert(0x23d1941c0);\n        v25 = v32 = _totalSupply / 0x23d1941c0;\n    }\n    v33 = 0x1ca3(v25 ** 3);\n    v15 = v34 = _SafeMul(v21, v33);\n    assert(v0 + v0 > 0);\n    return v0 + v0;\n}\n\nfunction 0x22d2(uint256 varg0) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v4 = 0x2004();\n    require(v4 > v3);\n    require(!_icoPhase);\n    require(_regularPhase);\n    require(varg0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n    v0 = v5 = 0x25f6(msg.sender);\n    v6 = v7 = v5 >= 0x20000000000000000;\n    if (v5 >= 0x20000000000000000) {\n        v6 = v8 = v5 <= 0x320000000000000000;\n    }\n    require(v6);\n    v0 = v9 = 9098;\n    v0 = v10 = 0x10000000000000000;\n    v0 = v11 = _SafeMul(v5, varg0);\n    while (!v0) {\n        assert(v0);\n        assert(v0 <= v0);\n        assert(v0 <= _totalSupply);\n        _totalSupply = _totalSupply - v0;\n        assert(v0 <= _getDividendTokenSupply);\n        _getDividendTokenSupply = _getDividendTokenSupply - v0;\n        assert(v0 <= _getFrontEndTokenBalanceOf[msg.sender]);\n        _getFrontEndTokenBalanceOf[msg.sender] = _getFrontEndTokenBalanceOf[msg.sender] - v0;\n        assert(v0 <= _myDividendTokens[msg.sender]);\n        _myDividendTokens[msg.sender] = _myDividendTokens[msg.sender] - v0;\n        _myDividendTokens[msg.sender] = _myDividendTokens[msg.sender] - ((v0 - v0 << 64) + v0 * owner_13);\n        if (0 < _getDividendTokenSupply) {\n            assert(_getDividendTokenSupply);\n            assert((v0 << 64) / _getDividendTokenSupply + owner_13 >= owner_13);\n            owner_13 += (v0 << 64) / _getDividendTokenSupply;\n        }\n        emit onTokenSell(msg.sender, v0, v0 - v0);\n        return ;\n        v0 = v0 / v0;\n        goto {'0xcf20x22d2', '0x23d3', '0x238a'};\n        v0 = v12 = 0x2010(v0);\n        if (v12 <= _currentEthInvested) {\n            _currentEthInvested = _currentEthInvested - v12;\n        } else {\n            _currentEthInvested = 0;\n        }\n        v0 = v13 = 9171;\n        v0 = v14 = 0x10000000000000000;\n        v0 = v15 = 3314;\n        v0 = v16 = 100;\n        v17 = 0x25f6(msg.sender);\n        v0 = _SafeMul(v17, v12);\n    }\n}\n\nfunction 0x25bc(uint256 varg0) private { \n    varg0 = v0 = (varg0 + 1) / 3;\n    while (varg0 < varg0) {\n        assert(varg0 * varg0);\n        assert(3);\n        varg0 = (varg0 / (varg0 * varg0) + (varg0 << 1)) / 3;\n    }\n    return varg0;\n}\n\nfunction 0x25f6(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_getFrontEndTokenBalanceOf[v0]);\n    return (_myDividendTokens[v0] << 64) / _getFrontEndTokenBalanceOf[v0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0x277a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    require(_regularPhase);\n    require(address(varg2));\n    v0 = 0x1f60(varg3, 1);\n    if (v0 > 0) {\n        v1 = 0x1f60(varg3, 0);\n        v2 = address(varg3);\n        _dividendsOf[v2] += v1 << 64;\n        _dividendsOf[v2] = 0;\n        v3 = v2.call().value(v1 + _dividendsOf[v2]).gas(2300 * !(v1 + _dividendsOf[v2]));\n        require(v3); // checks call status, propagates error data on error\n        emit onWithdraw(address(varg3), v1 + _dividendsOf[v2]);\n    }\n    v4 = 0x25f6(varg3);\n    v5 = _SafeMul(v4, varg1);\n    assert(0x10000000000000000);\n    if (msg.sender != address(varg3)) {\n        v6 = address(varg3);\n        _allowed[msg.sender] = _allowed[msg.sender] - varg1;\n    }\n    v7 = address(varg3);\n    assert(varg1 <= _getFrontEndTokenBalanceOf[v7]);\n    v8 = address(varg3);\n    _getFrontEndTokenBalanceOf[v8] = _getFrontEndTokenBalanceOf[v7] - varg1;\n    v9 = address(varg2);\n    v10 = varg1 + _getFrontEndTokenBalanceOf[v9];\n    assert(v10 >= _getFrontEndTokenBalanceOf[v9]);\n    v11 = address(varg2);\n    _getFrontEndTokenBalanceOf[v11] = v10;\n    v12 = address(varg3);\n    assert(v5 >> 64 <= _myDividendTokens[v12]);\n    v13 = address(varg3);\n    _myDividendTokens[v13] = _myDividendTokens[v12] - (v5 >> 64);\n    v14 = address(varg2);\n    assert((v5 >> 64) + _myDividendTokens[v14] >= _myDividendTokens[v14]);\n    v15 = address(varg2);\n    _myDividendTokens[v15] = (v5 >> 64) + _myDividendTokens[v14];\n    if (!(0xff & _myDividendTokens[v15])) {\n        v16 = address(varg2);\n        _getMyDividendRate[v16] = 0x1 | ~0xff & _getMyDividendRate[v16];\n        v17 = address(varg3);\n        _calculateTokensReceived[v17] = 0xff & _calculateTokensReceived[v17] | ~0xff & _calculateTokensReceived[v17];\n    }\n    v18 = address(varg3);\n    _dividendsOf[v18] = _dividendsOf[v18] - (v5 >> 64) * owner_13;\n    v19 = address(varg2);\n    _dividendsOf[v19] = _dividendsOf[v19] + (v5 >> 64) * owner_13;\n    if (varg2.code.size > 0) {\n        v20 = address(varg3);\n        v21 = new array[](varg0.length);\n        v22 = address(varg2);\n        v23 = v24 = 0;\n        while (v23 < varg0.length) {\n            MEM[v23 + v21.data] = MEM[v23 + varg0.data];\n            v23 += 32;\n        }\n        v25 = v26 = varg0.length + v21.data;\n        if (0x1f & varg0.length) {\n            MEM[v26 - (0x1f & varg0.length)] = ~(256 ** (32 - (0x1f & varg0.length)) - 1) & MEM[v26 - (0x1f & varg0.length)];\n        }\n        require(v22.code.size);\n        v27 = v22.tokenFallback(v20, varg1, v21).gas(msg.gas);\n        require(v27); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    emit Transfer(address(varg3), address(varg2), varg1);\n    return ;\n}\n\nfunction fallback() public payable { \n    require(_regularPhase);\n    if (!(0xff & _getMyDividendRate[msg.sender])) {\n        v0 = 0x119f(0x3078300000000000000000000000000000000000000000000000000000000000, 20);\n    } else {\n        v1 = 0xbcb(0);\n    }\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _myDividendTokens[varg0] * owner_13 - _dividendsOf[varg0] >> 64;\n}\n\nfunction totalEthereumICOReceived() public nonPayable { \n    return _totalEthereumICOReceived;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction icoHashedPass() public nonPayable { \n    return 0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = _SafeMul(0xff & _calculateTokensReceived[msg.sender], varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    v1 = 0x170e();\n    return v1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferTo(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    0x1501(v0, varg2, varg1, varg0);\n}\n\nfunction currentEthInvested() public nonPayable { \n    return _currentEthInvested;\n}\n\nfunction regularPhase() public nonPayable { \n    return _regularPhase;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v0 = v4 = 0;\n    require(varg0 <= _totalSupply);\n    v2 = v5 = 0x2010(varg0);\n    v0 = v6 = 0x25f6(msg.sender);\n    v2 = v7 = 5674;\n    v0 = v8 = 0x10000000000000000;\n    v2 = v9 = 3314;\n    v0 = v10 = 100;\n    v11 = v12 = _SafeMul(v6, v5);\n    while (!v0) {\n        assert(v0);\n        assert(v11 <= v2);\n        return v2 - v11;\n        v11 = v11 / v0;\n        goto {'0xcf20x15dbB0x55b', '0x162aB0x55b'};\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = varg2 >= 0x2540be400;\n    if (varg2 >= 0x2540be400) {\n        v0 = v2 = varg2 <= _getFrontEndTokenBalanceOf[varg0];\n    }\n    if (v0) {\n        v0 = v3 = varg2 <= _allowed[msg.sender];\n    }\n    require(v0);\n    0x277a(96, varg2, varg1, varg0);\n    return 1;\n}\n\nfunction buyAndTransfer(address varg0, address varg1) public payable { \n    0x1bca(20, 96, varg1);\n}\n\nfunction startRegularPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    stor_15_0_1 = 256;\n}\n\nfunction ethereumToTokens_(uint256 varg0) public nonPayable { \n    v0 = 0x170e();\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction publicStartRegularPhase() public nonPayable { \n    v0 = v1 = block.timestamp > 0x127500 + _publicStartRegularPhase;\n    if (v1) {\n        v0 = v2 = _publicStartRegularPhase;\n    }\n    require(v0);\n    stor_15_0_1 = 256;\n}\n\nfunction sellPrice() public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = _icoPhase;\n    if (!v3) {\n        v2 = _currentEthInvested < _totalEthereumICOReceived;\n    }\n    if (!v2) {\n        v0 = v4 = 6645;\n        v0 = v5 = 0x170e();\n        assert(v5);\n        v0 = v6 = 0x314dc6448d9338c15b0a00000000 / v5;\n    } else {\n        v0 = v7 = 0x251e66909d000;\n    }\n    v0 = v8 = 6735;\n    v0 = v9 = 6722;\n    v0 = v10 = 0x10000000000000000;\n    v0 = v11 = 3314;\n    v0 = v12 = 100;\n    v13 = 0x25f6(msg.sender);\n    v14 = v15 = _SafeMul(v13, v0);\n    while (!v0) {\n        assert(v0);\n        assert(v14 <= v0);\n        return v0 - v14;\n        v14 = v14 / v0;\n        goto {'0xcf20x19b4B0x624', '0x1a42B0x624'};\n    }\n}\n\nfunction getFrontEndTokenBalanceOf(address varg0) public nonPayable { \n    return _getFrontEndTokenBalanceOf[varg0];\n}\n\nfunction getDividendTokenBalanceOf(address varg0) public nonPayable { \n    return _myDividendTokens[varg0];\n}\n\nfunction withdraw(address varg0) public nonPayable { \n    0x1a8d(varg0);\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction ethInvestedDuringICO() public nonPayable { \n    return _totalEthereumICOReceived;\n}\n\nfunction myDividendTokens() public nonPayable { \n    return _myDividendTokens[msg.sender];\n}\n\nfunction buyAndTransfer(address varg0, address varg1, bytes varg2, uint8 varg3) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x1bca(0xff & varg3, v0, varg1);\n}\n\nfunction sqrt(uint256 varg0) public nonPayable { \n    v0 = 0x1ca3(varg0);\n    return v0;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x1cde(varg0);\n    return v0;\n}\n\nfunction icoPhase() public nonPayable { \n    return _icoPhase;\n}\n\nfunction injectEther() public payable { \n    require(0xff & _injectEther[msg.sender]);\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _getFrontEndTokenBalanceOf[varg0];\n}\n\nfunction buyAndSetDivPercentage(address varg0, uint8 varg1, string varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    v2 = 0x119f(v0, 0xff & varg1);\n    return v2;\n}\n\nfunction administrators(address varg0) public nonPayable { \n    return 0xff & _injectEther[varg0];\n}\n\nfunction getMyAverageDividendRate() public nonPayable { \n    v0 = 0x25f6(msg.sender);\n    return v0;\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    require(varg0 >= 0x56bc75e2d63100000);\n    _stakingRequirement = varg0;\n}\n\nfunction setAdministrator(address varg0, bool varg1) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    _injectEther[varg0] = varg1 | ~0xff & _injectEther[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction toPowerOfTwoThirds(uint256 varg0) public nonPayable { \n    v0 = 0x25bc(varg0 ** 2);\n    return v0;\n}\n\nfunction endICOPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    _icoPhase = 0;\n}\n\nfunction myReferralDividends() public nonPayable { \n    v0 = 0x1cde(0);\n    v1 = 0x1cde(1);\n    return v1 - v0;\n}\n\nfunction changeBankroll(address varg0) public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    owner_3_0_19 = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x2004();\n    require(v0 > 0);\n    v1 = v2 = varg1 >= 0x2540be400;\n    if (v2) {\n        v1 = v3 = varg1 <= _getFrontEndTokenBalanceOf[msg.sender];\n    }\n    require(v1);\n    0x277a(96, varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction theDividendsOf(bool varg0, address varg1) public nonPayable { \n    v0 = 0x1f60(varg1, varg0);\n    return v0;\n}\n\nfunction getMyDividendRate() public nonPayable { \n    require(0xff & _getMyDividendRate[msg.sender]);\n    return 0xff & _calculateTokensReceived[msg.sender] & 0xff;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(0xff & _injectEther[msg.sender]);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _symbol.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction myFrontEndTokens() public nonPayable { \n    v0 = 0x2004();\n    return v0;\n}\n\nfunction tokensToEthereum_(uint256 varg0) public nonPayable { \n    v0 = 0x2010(varg0);\n    return v0;\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    require(0xff & _injectEther[msg.sender]);\n    v2 = v3 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v3 + v0.length > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + _name.length >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n}\n\nfunction buyPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = _icoPhase;\n    if (!v1) {\n        v0 = _currentEthInvested < _totalEthereumICOReceived;\n    }\n    if (!v0) {\n        v2 = 0x170e();\n        assert(v2);\n        v3 = v4 = 0x314dc6448d9338c15b0a00000000 / v2;\n    } else {\n        v3 = v5 = 0x251e66909d000;\n    }\n    v6 = _SafeMul(0, v3);\n    assert(100);\n    assert(v3 + v6 / 100 >= v6 / 100);\n    return v3 + v6 / 100;\n}\n\nfunction startICOPhase() public nonPayable { \n    require(0xff & _injectEther[msg.sender]);\n    require(!_publicStartRegularPhase);\n    _icoPhase = 1;\n    _publicStartRegularPhase = block.timestamp;\n}\n\nfunction tokensMintedDuringICO() public nonPayable { \n    return _tokensMintedDuringICO;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x22d2(varg0);\n}\n\nfunction exit() public nonPayable { \n    require(_regularPhase);\n    if (_getFrontEndTokenBalanceOf[msg.sender] > 0) {\n        0x22d2(_getFrontEndTokenBalanceOf[msg.sender]);\n    }\n    0x1a8d(msg.sender);\n}\n\nfunction buy(address varg0) public payable { \n    require(_regularPhase);\n    require(0xff & _getMyDividendRate[msg.sender]);\n    v0 = 0xbcb(varg0);\n    return msg.sender;\n}\n\nfunction buyAndTransfer(address varg0, address varg1, bytes varg2) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x1bca(20, v0, varg1);\n}\n\nfunction cbrt(uint256 varg0) public nonPayable { \n    v0 = 0x25bc(varg0);\n    return v0;\n}\n\nfunction getUserAverageDividendRate(address varg0) public nonPayable { \n    v0 = 0x25f6(varg0);\n    return v0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x1cde(1);\n    require(v0 > 0);\n    require(_regularPhase);\n    v1 = 0x1cde(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0xbcb(0);\n    emit onReinvestment(0, msg.sender, v2);\n}\n\nfunction toPowerOfThreeHalves(uint256 varg0) public nonPayable { \n    v0 = 0x1ca3(varg0 ** 3);\n    return v0;\n}\n\nfunction getDividendTokenSupply() public nonPayable { \n    return _getDividendTokenSupply;\n}\n\nfunction 0xbcb(uint256 varg0) private { \n    varg0 = v0 = 0;\n    varg0 = v1 = 0;\n    varg0 = v2 = 0;\n    varg0 = v3 = 0;\n    varg0 = v4 = 0;\n    varg0 = v5 = 0;\n    v6 = v7 = v8 >= 0x5af3107a4000;\n    if (v8 < 0x5af3107a4000) {\n        v6 = v9 = msg.sender == owner_3_0_19;\n    }\n    require(v6, 'Tried to buy below the min eth buyin threshold.');\n    if (_regularPhase) {\n        assert(100);\n        varg0 = v10 = v8 / 100;\n        assert(v10 <= v8);\n        varg0 = v11 = v8 - v10;\n    }\n    varg0 = v12 = 0xff & _calculateTokensReceived[msg.sender];\n    v13 = v14 = 3326;\n    v15 = v16 = 100;\n    v17 = v18 = _SafeMul(v12, varg0);\n    while (!v15) {\n        assert(v15);\n        assert(varg0 + owner_13 >= owner_13);\n        owner_13 += varg0;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (varg0 * (varg0 + owner_13) - varg0);\n        v19 = varg0 + _getFrontEndTokenBalanceOf[msg.sender];\n        assert(v19 >= _getFrontEndTokenBalanceOf[msg.sender]);\n        _getFrontEndTokenBalanceOf[msg.sender] = v19;\n        v20 = varg0 + _myDividendTokens[msg.sender];\n        assert(v20 >= _myDividendTokens[msg.sender]);\n        _myDividendTokens[msg.sender] = v20;\n        if (varg0) {\n            require(owner_3_0_19.code.size);\n            v21 = owner_3_0_19.receiveDividends().value(varg0).gas(msg.gas);\n            require(v21); // checks call status, propagates error data on error\n        }\n        if (_regularPhase) {\n            require(stor_4_0_19.code.size);\n            v22 = stor_4_0_19.receiveDividends(varg0).value(varg0).gas(msg.gas);\n            require(v22); // checks call status, propagates error data on error\n        }\n        emit Allocation(varg0, varg0, varg0, varg0, varg0);\n        assert(!(varg0 + (varg0 + (varg0 + (varg0 + varg0))) - varg0));\n        return varg0;\n        varg0 = v17 / v15;\n        goto {'0xeca', '0xcfe', '0xf81'};\n        if (varg0 <= varg0) {\n            break;\n        }\n        assert(varg0 <= varg0);\n        v23 = varg0 - varg0;\n        v24 = v25 = _icoPhase;\n        if (v25) {\n            v24 = v26 = msg.sender == owner_3_0_19;\n        }\n        if (v24) {\n            v23 += varg0;\n        }\n        varg0 = v27 = 3394;\n        varg0 = 0x170e();\n        varg0 = _SafeMul(varg0, varg0);\n        assert(varg0 + _totalSupply >= _totalSupply);\n        _totalSupply += varg0;\n        assert(varg0 + _getDividendTokenSupply >= _getDividendTokenSupply);\n        _getDividendTokenSupply += varg0;\n        _currentEthInvested += varg0;\n        if (!_icoPhase) {\n            v28 = !address(varg0);\n            v29 = v30 = address(varg0);\n            if (address(varg0)) {\n                v29 = v31 = msg.sender != address(varg0);\n            }\n            if (v29) {\n                v32 = address(varg0);\n                v29 = v33 = _getFrontEndTokenBalanceOf[v32] >= _stakingRequirement;\n            }\n            if (v29) {\n                v13 = v34 = 3786;\n                v15 = v35 = 100;\n                v17 = _SafeMul(25, varg0);\n            }\n        } else {\n            if (msg.sender == owner_3_0_19) {\n                varg0 = v36 = 0;\n            }\n            _totalEthereumICOReceived += varg0;\n            _tokensMintedDuringICO += varg0;\n            varg0 = v37 = 0;\n            require(0xd8d726b7177a80000 >= varg0 + _totalEthereumICOReceived);\n            v38 = v39 = msg.sender == tx.origin;\n            if (msg.sender != tx.origin) {\n                v38 = v40 = msg.sender == owner_3_0_19;\n            }\n            require(v38);\n            owner_d[msg.sender] += varg0;\n            v41 = v42 = 0xde0b6b3a7640000 >= varg0 + owner_d[msg.sender];\n            if (0xde0b6b3a7640000 < varg0 + owner_d[msg.sender]) {\n                v41 = v43 = msg.sender == owner_3_0_19;\n            }\n            require(v41);\n            if (_totalEthereumICOReceived == 0xd8d726b7177a80000) {\n                _icoPhase = 0;\n            }\n        }\n        v44 = address(varg0);\n        owner_b[v44] += varg0;\n        emit Referral(v44, varg0);\n        assert(varg0 <= varg0);\n        varg0 = v45 = varg0 - varg0;\n        assert(_getDividendTokenSupply);\n        varg0 = (v45 << 64) - ((v45 << 64) - varg0 * ((v45 << 64) / _getDividendTokenSupply));\n        varg0 = v46 = 3984;\n        v13 = v47 = 3969;\n        v15 = v48 = _getDividendTokenSupply;\n        v17 = _SafeMul(0x10000000000000000, v45);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x3d499ef == function_selector) {\n            totalEthereumICOReceived();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc3c450e == function_selector) {\n            icoHashedPass();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else {\n            if (0x18160ddd != function_selector) {\n                if (0x19fb361f == function_selector) {\n                    transferTo(address,address,uint256,bytes);\n                } else if (0x1b1686b6 == function_selector) {\n                    currentEthInvested();\n                } else if (0x214dda84 == function_selector) {\n                    regularPhase();\n                } else if (0x22609373 == function_selector) {\n                    calculateEthereumReceived(uint256);\n                } else if (0x23b872dd == function_selector) {\n                    transferFrom(address,address,uint256);\n                } else if (0x269a7c3f == function_selector) {\n                    buyAndTransfer(address,address);\n                } else if (0x27dffba6 == function_selector) {\n                    startRegularPhase();\n                } else if (0x2a9121c7 == function_selector) {\n                    ethereumToTokens_(uint256);\n                } else if (0x313ce567 == function_selector) {\n                    decimals();\n                } else if (0x3c7d6f30 == function_selector) {\n                    publicStartRegularPhase();\n                } else if (0x4b750334 == function_selector) {\n                    sellPrice();\n                } else if (0x4c146f38 == function_selector) {\n                    getFrontEndTokenBalanceOf(address);\n                } else if (0x51392041 == function_selector) {\n                    getDividendTokenBalanceOf(address);\n                } else if (0x51cff8d9 == function_selector) {\n                    withdraw(address);\n                } else if (0x56d399e8 == function_selector) {\n                    stakingRequirement();\n                } else if (0x5c658165 == function_selector) {\n                    allowed(address,address);\n                } else if (0x5ccb5460 == function_selector) {\n                    ethInvestedDuringICO();\n                } else if (0x6135e084 == function_selector) {\n                    myDividendTokens();\n                } else if (0x627aa6d2 == function_selector) {\n                    buyAndTransfer(address,address,bytes,uint8);\n                } else if (0x677342ce == function_selector) {\n                    sqrt(uint256);\n                } else if (0x688abbf7 == function_selector) {\n                    myDividends(bool);\n                } else if (0x68955fb1 == function_selector) {\n                    icoPhase();\n                } else if (0x6a3a2119 == function_selector) {\n                    injectEther();\n                } else if (0x6b2f4632 == function_selector) {\n                    totalEthereumBalance();\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x724fcd4c == function_selector) {\n                    buyAndSetDivPercentage(address,uint8,string);\n                } else if (0x76be1585 == function_selector) {\n                    administrators(address);\n                } else if (0x7b89eef2 == function_selector) {\n                    getMyAverageDividendRate();\n                } else if (0x8328b610 == function_selector) {\n                    setStakingRequirement(uint256);\n                } else if (0x87c95058 == function_selector) {\n                    setAdministrator(address,bool);\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0x96242f41 != function_selector) {\n                    if (0x965447d9 == function_selector) {\n                        toPowerOfTwoThirds(uint256);\n                    } else if (0xa3a06c54 == function_selector) {\n                        endICOPhase();\n                    } else if (0xa6d87f7d == function_selector) {\n                        myReferralDividends();\n                    } else if (0xa78bcf6e == function_selector) {\n                        changeBankroll(address);\n                    } else if (0xa9059cbb == function_selector) {\n                        transfer(address,uint256);\n                    } else if (0xb1f253f6 == function_selector) {\n                        theDividendsOf(bool,address);\n                    } else if (0xb607068c == function_selector) {\n                        getMyDividendRate();\n                    } else if (0xb84c8246 == function_selector) {\n                        setSymbol(string);\n                    } else if (0xbcaa218e == function_selector) {\n                        myFrontEndTokens();\n                    } else if (0xbf3b397b == function_selector) {\n                        tokensToEthereum_(uint256);\n                    } else if (0xc47f0027 == function_selector) {\n                        setName(string);\n                    } else if (0xc4dbf622 == function_selector) {\n                        buyPrice(uint256);\n                    } else if (0xccb53365 == function_selector) {\n                        startICOPhase();\n                    } else if (0xd161b56a == function_selector) {\n                        tokensMintedDuringICO();\n                    } else if (0xe4849b32 == function_selector) {\n                        sell(uint256);\n                    } else if (0xe9fad8ee == function_selector) {\n                        exit();\n                    } else if (0xf088d547 == function_selector) {\n                        buy(address);\n                    } else if (0xf2f8569f == function_selector) {\n                        buyAndTransfer(address,address,bytes);\n                    } else if (0xf42c56c2 == function_selector) {\n                        cbrt(uint256);\n                    } else if (0xf8ead7cf == function_selector) {\n                        getUserAverageDividendRate(address);\n                    } else if (0xfdb5a03e == function_selector) {\n                        reinvest();\n                    } else if (0xfdc89f73 == function_selector) {\n                        toPowerOfThreeHalves(uint256);\n                    } else if (0xffcb1edb == function_selector) {\n                        getDividendTokenSupply();\n                    }\n                }\n            }\n            totalSupply();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 29.204202890396118,
	"usage": {
		"completion_tokens": 460,
		"prompt_tokens": 12630,
		"total_tokens": 13090
	}
}