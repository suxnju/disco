{
	"address": "0xcd19a08b139a4cc47bae0d9de41241f5056988c7",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity version of the decompiled code would look like this:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract{\n    uint256 private _totalSupply;\n    uint256 private _maxSupply;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    address private _owner;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(_allowance[from][msg.sender] >= value, \"Insufficient allowance\");\n        require(_balanceOf[from] >= value, \"Insufficient balance\");\n        require(value > 0, \"Transfer value must be greater than zero\");\n\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function RATE() public pure returns (uint256) {\n        return 10000;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    // Assumes symbol is \"BTW\"\n    function symbol() public pure returns (string memory) {\n        return \"BTW\";\n    }\n\n    function transfer(address to, uint256 value) public returns (bool){\n        require(to != address(0), \"Invalid address\");\n        require(_balanceOf[msg.sender] >= value, \"Insufficient balance\");\n\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function createTokens() public payable {\n        require(msg.value > 0, \"No ether provided\");\n        require(_totalSupply < _maxSupply, \"Maximum supply reached\");\n\n        uint256 newTokens = msg.value * RATE();\n        _balanceOf[msg.sender] += newTokens;\n        _totalSupply += newTokens;\n    }\n\n    function maxSupply() public view returns (uint256) {\n        return _maxSupply;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    // Assumes name is \"Bitway\"\n    function name() public pure returns (string memory) {\n        return \"Bitway\";\n    }\n\n    fallback() external payable {\n        createTokens();\n    }\n}\n```\nPlease note that it's not possible to accurately convert the `__function_selector__` function to Solidity since Solidity abstracts function selector logic away from the developer. Instead, function calls are determined by the function name and parameter types. The function selector is then automatically generated by the Solidity compiler.",
				"role": "assistant"
			}
		}
	],
	"created": 1701458230,
	"id": "chatcmpl-8R3IcAeP9UtgoOCC5Tb6ssVV2lI0T",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 22:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _maxSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x4]\nuint160 _owner; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _allowance[msg.sender] >= varg2;\n    if (v1) {\n        v0 = v2 = _balanceOf[varg0] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    require(v0);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _balanceOf[msg.sender]);\n    _allowance[msg.sender] = _balanceOf[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction RATE() public nonPayable { \n    return 10000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4254570000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction createTokens() public payable { \n    0x4d4();\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction 0x4d4() private { \n    require(msg.value > 0);\n    require(_totalSupply < _maxSupply);\n    if (msg.value != 0) {\n        v0 = v1 = msg.value * 10000;\n        assert(msg.value);\n        assert(v1 / msg.value == 10000);\n    } else {\n        v0 = v2 = 0;\n    }\n    assert(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    assert(_totalSupply + v0 >= _totalSupply);\n    _totalSupply = _totalSupply + v0;\n    return ;\n}\n\nfunction fallback() public payable { \n    0x4d4();\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'Bitway';\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x664e9704 == function_selector) {\n            RATE();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 22:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _maxSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x4]\nuint160 _owner; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _allowance[msg.sender] >= varg2;\n    if (v1) {\n        v0 = v2 = _balanceOf[varg0] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    require(v0);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _balanceOf[msg.sender]);\n    _allowance[msg.sender] = _balanceOf[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction RATE() public nonPayable { \n    return 10000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4254570000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction createTokens() public payable { \n    0x4d4();\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction 0x4d4() private { \n    require(msg.value > 0);\n    require(_totalSupply < _maxSupply);\n    if (msg.value != 0) {\n        v0 = v1 = msg.value * 10000;\n        assert(msg.value);\n        assert(v1 / msg.value == 10000);\n    } else {\n        v0 = v2 = 0;\n    }\n    assert(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    assert(_totalSupply + v0 >= _totalSupply);\n    _totalSupply = _totalSupply + v0;\n    return ;\n}\n\nfunction fallback() public payable { \n    0x4d4();\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'Bitway';\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x664e9704 == function_selector) {\n            RATE();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 22:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _maxSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x4]\nuint160 _owner; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _allowance[msg.sender] >= varg2;\n    if (v1) {\n        v0 = v2 = _balanceOf[varg0] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    require(v0);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _balanceOf[msg.sender]);\n    _allowance[msg.sender] = _balanceOf[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction RATE() public nonPayable { \n    return 10000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4254570000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction createTokens() public payable { \n    0x4d4();\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction 0x4d4() private { \n    require(msg.value > 0);\n    require(_totalSupply < _maxSupply);\n    if (msg.value != 0) {\n        v0 = v1 = msg.value * 10000;\n        assert(msg.value);\n        assert(v1 / msg.value == 10000);\n    } else {\n        v0 = v2 = 0;\n    }\n    assert(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    assert(_totalSupply + v0 >= _totalSupply);\n    _totalSupply = _totalSupply + v0;\n    return ;\n}\n\nfunction fallback() public payable { \n    0x4d4();\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'Bitway';\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x664e9704 == function_selector) {\n            RATE();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.10506844520569,
	"usage": {
		"completion_tokens": 704,
		"prompt_tokens": 1478,
		"total_tokens": 2182
	}
}