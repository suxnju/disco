{
	"address": "0xb9355614ffa3dfc357468923b28f553ae2d50a88",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a simplified Solidity smart contract code based on the provided decompiled code. Note that not all details can be inferred from the decompiled code, so some parts are left as placeholders:\n\n```solidity\npragma solidity ^0.8.19;\n\ncontract MyContract {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    address private _owner;\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\nPlease note that the code above is a basic ERC20 token contract. The provided decompiled code contains more complex features such as trading enablement, different tax rates, liquidity provisions, etc. You would need to build those features into the contract based on your specific requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1700631665,
	"id": "chatcmpl-8NaGv0b3aV4uIk9kz3H4OqzDTprpk",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.15 19:25 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_201; // STORAGE[0x3]\nuint256[] _@symbol_210; // STORAGE[0x4]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _maxWalletLimit; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _taxes; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 _sellTaxes; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nmapping (uint256 => uint256) _exemptFee; // STORAGE[0x10]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_13; // STORAGE[0x13]\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _router; // STORAGE[0x6] bytes 0 to 19\nuint256 _pair; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 stor_7_20_20; // STORAGE[0x7] bytes 20 to 20\nuint256 stor_7_21_21; // STORAGE[0x7] bytes 21 to 21\nuint256 _tradingEnabled; // STORAGE[0x7] bytes 22 to 22\n\n\n// Events\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\nTransfer(address, address, uint256);\n\nfunction @_approve_578(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1712(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = !uint8(_exemptFee[address(varg2)]);\n    if (!bool(uint8(_exemptFee[address(varg2)]))) {\n        v0 = v2 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v0) {\n        require(_tradingEnabled, Error('Trading not enabled'));\n    }\n    v3 = v4 = _pair == address(varg2);\n    if (v4) {\n        v3 = v5 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v3) {\n        v3 = v6 = !stor_7_20_20;\n    }\n    if (v3) {\n        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n        require(varg0 + _balanceOf[address(varg1)] <= _maxWalletLimit, Error('You are exceeding maxWalletLimit'));\n    }\n    v7 = v8 = _pair == address(varg2);\n    if (v8) {\n        v7 = v9 = stor_14_0_19 == address(varg1);\n    }\n    if (v7) {\n        if (~0 > _allowance[address(varg2)][address(varg1)]) {\n            _allowance[address(varg2)][address(varg1)] = ~0;\n            // Unknown jump to Block 0x154b. Refer to 3-address code (TAC);\n        }\n    }\n    v10 = v11 = _pair != address(varg2);\n    if (_pair != address(varg2)) {\n        v10 = v12 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v10) {\n        v10 = v13 = !uint8(_exemptFee[address(varg2)]);\n    }\n    if (v10) {\n        v10 = v14 = !stor_7_20_20;\n    }\n    if (v10) {\n        if (_pair != address(varg1)) {\n            require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n            require(varg0 + _balanceOf[address(varg1)] <= _maxWalletLimit, Error('You are exceeding maxWalletLimit'));\n        }\n    }\n    v15 = v16 = 0;\n    v17 = v18 = MEM[64];\n    MEM[v18] = 0;\n    MEM[32 + v18] = 0;\n    v19 = v20 = !uint8(_exemptFee[address(varg2)]);\n    if (!bool(uint8(_exemptFee[address(varg2)]))) {\n        v19 = v21 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v19) {\n        require(stor_b <= stor_12 + stor_b, Panic(17)); // arithmetic overflow or underflow\n        v19 = v22 = block.number < stor_12 + stor_b;\n    }\n    v23 = v24 = stor_7_20_20;\n    if (!v24) {\n        v23 = v25 = uint8(_exemptFee[address(varg2)]);\n    }\n    if (!v23) {\n        v23 = v26 = uint8(_exemptFee[address(varg1)]);\n    }\n    if (!v23) {\n        v27 = v28 = _pair == address(varg1);\n        if (v28) {\n            v27 = v29 = !v19;\n        }\n        if (!v27) {\n            if (v19) {\n                if (v19) {\n                    v15 = v30 = stor_13;\n                }\n            } else {\n                v15 = _taxes + stor_d;\n                require(stor_d <= v15, Panic(17)); // arithmetic overflow or underflow\n                v17 = v31 = MEM[64];\n                MEM[64] = 64 + v31;\n                MEM[v31] = _taxes;\n                MEM[v31 + 32] = stor_d;\n            }\n        } else {\n            v15 = v32 = _sellTaxes + stor_f;\n            require(stor_f <= v32, Panic(17)); // arithmetic overflow or underflow\n            v17 = v33 = MEM[64];\n            MEM[64] = 64 + v33;\n            MEM[v33] = _sellTaxes;\n            MEM[v33 + 32] = stor_f;\n        }\n    }\n    require((v15 == v15 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    v34 = v35 = stor_7_21_21;\n    if (v35) {\n        v34 = v36 = _pair != address(varg2);\n    }\n    if (v34) {\n        if (!stor_7_20_20) {\n            stor_7_20_20 = 1;\n            if (v15) {\n                v37 = v38 = _balanceOf[this];\n                if (v38 >= stor_9) {\n                    if (stor_9 > 1) {\n                        v37 = stor_9;\n                    }\n                    require((v15 == v15 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                    require((MEM[32 + v17] == MEM[32 + v17] * v37 / v37) | !v37, Panic(17)); // arithmetic overflow or underflow\n                    require(v15 << 1, Panic(18)); // division by zero\n                    v39 = MEM[32 + v17] * v37 / (v15 << 1);\n                    require(v37 - v39 <= v37, Panic(17)); // arithmetic overflow or underflow\n                    v40 = new address[](2);\n                    CALLDATACOPY(v40.data, msg.data.length, 64);\n                    require(0 < v40.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v41 = v40.data;\n                    v40[0] = address(this);\n                    v42, /* address */ v43 = _router.WETH().gas(msg.gas);\n                    require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                    require(v43 == address(v43));\n                    require(1 < v40.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v40[1] = address(v43);\n                    @_approve_578(v37 - v39, _router, this);\n                    v44 = new address[](v40.length);\n                    v45 = v46 = v44.data;\n                    v47 = v48 = v40.data;\n                    v49 = v50 = 0;\n                    while (v49 < v40.length) {\n                        MEM[v45] = address(MEM[v47]);\n                        v47 += 32;\n                        v45 += 32;\n                        v49 += 1;\n                    }\n                    require(bool(_router.code.size));\n                    v51 = _router.swapExactTokensForETHSupportingFeeOnTransferTokens(v37 - v39, 0, v44, address(this), block.timestamp, v52, address(this)).gas(msg.gas);\n                    require(bool(v51), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(this.balance - this.balance <= this.balance, Panic(17)); // arithmetic overflow or underflow\n                    require((v15 << 1) - MEM[32 + v17] <= v15 << 1, Panic(17)); // arithmetic overflow or underflow\n                    require((v15 << 1) - MEM[32 + v17], Panic(18)); // division by zero\n                    v53 = (this.balance - this.balance) / ((v15 << 1) - MEM[32 + v17]);\n                    require((MEM[32 + v17] == MEM[32 + v17] * v53 / v53) | !v53, Panic(17)); // arithmetic overflow or underflow\n                    if (MEM[32 + v17] * v53) {\n                        @_approve_578(v39, _router, this);\n                        v54, /* uint256 */ v55, /* uint256 */ v56, /* uint256 */ v57 = _router.addLiquidityETH(address(this), v39, 0, 0, address(0xdead), block.timestamp).value(MEM[32 + v17] * v53).gas(msg.gas);\n                        require(bool(v54), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    }\n                    require((v53 == v53 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                    require((MEM[v17] == MEM[v17] * (v53 << 1) / (v53 << 1)) | !(v53 << 1), Panic(17)); // arithmetic overflow or underflow\n                    if (MEM[v17] * (v53 << 1)) {\n                        require(this.balance >= MEM[v17] * (v53 << 1), Error('Address: insufficient balance'));\n                        v58, /* uint256 */ v59 = stor_14_0_19.call().value(MEM[v17] * (v53 << 1)).gas(msg.gas);\n                        if (RETURNDATASIZE() != 0) {\n                            v60 = new bytes[](RETURNDATASIZE());\n                            RETURNDATACOPY(v60.data, 0, RETURNDATASIZE());\n                        }\n                        require(v58, Error('Address: unable to send value, recipient may have reverted'));\n                        // Unknown jump to Block 0x1aabB0x1818. Refer to 3-address code (TAC);\n                    }\n                }\n            }\n            stor_7_20_20 = 0;\n            // Unknown jump to Block 0x1821. Refer to 3-address code (TAC);\n        }\n    }\n    require(varg0 - v15 * varg0 / 100 <= varg0, Panic(17)); // arithmetic overflow or underflow\n    @_transfer_488(varg0 - v15 * varg0 / 100, varg1, varg2);\n    if (!(v15 * varg0 / 100)) {\n        return ;\n    } else if (!v15) {\n        return ;\n    } else if (_pair == address(varg2)) {\n        if (address(varg2) - _pair) {\n            return ;\n        } else {\n            require((v15 == v15 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n            require(100, Panic(18)); // division by zero\n            @_transfer_488(v15 * varg0 / 100, this, varg2);\n            return ;\n        }\n    } else {\n        require(0x38d7ea4c68000, Panic(18)); // division by zero\n        require(v15 - this.balance / 0x38d7ea4c68000 <= v15, Panic(17)); // arithmetic overflow or underflow\n        require((v15 - this.balance / 0x38d7ea4c68000 == (v15 - this.balance / 0x38d7ea4c68000) * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n        require(100, Panic(18)); // division by zero\n        @_transfer_488((v15 - this.balance / 0x38d7ea4c68000) * varg0 / 100, this, varg2);\n        return ;\n    }\n}\n\nfunction @_transfer_488(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[varg2] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    require(_balanceOf[varg2] - varg0 <= _balanceOf[varg2], Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg2] = _balanceOf[varg2] - varg0;\n    require(_balanceOf[varg1] <= varg0 + _balanceOf[varg1], Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg1] += varg0;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_201();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_578(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateLiquidityProvide(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_7_21_21 = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1712(varg2, varg1, varg0);\n    require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: transfer amount exceeds allowance'));\n    require(_allowance[varg0][msg.sender] - varg2 <= _allowance[varg0][msg.sender], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction RemovebulkExemptFee(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _exemptFee[address(v0[v5])] = bool(0) | bytes31(_exemptFee[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(_allowance[msg.sender][varg0] <= varg1 + _allowance[msg.sender][varg0], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(varg1 + _allowance[msg.sender][varg0], varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateDeadline(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!_tradingEnabled, Error(\"Can't change when trading has started\"));\n    stor_12 = varg0;\n}\n\nfunction updateLiquidityTreshhold(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(18));\n    require((v0 == v0 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    stor_9 = v0 * varg0;\n}\n\nfunction tradingEnabled() public nonPayable { \n    return _tradingEnabled;\n}\n\nfunction () public payable { \n}\n\nfunction AddExemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _exemptFee[varg0] = 0x1 | bytes31(_exemptFee[address(varg0)]);\n}\n\nfunction updateMaxAllLimits(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(18));\n    require((v0 == v0 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    _maxWalletLimit = v0 * varg0;\n}\n\nfunction maxWalletLimit() public nonPayable { \n    return _maxWalletLimit;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction taxes() public nonPayable { \n    return _taxes, stor_d;\n}\n\nfunction updateTeamWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_14_0_19 = varg0;\n}\n\nfunction RemoveExemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _exemptFee[varg0] = bytes31(_exemptFee[address(varg0)]);\n}\n\nfunction deadWallet() public nonPayable { \n    return address(0xdead);\n}\n\nfunction enableTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* address */ v1 = _router.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = _router.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _pair = v5;\n    @_approve_578(~0, _router, msg.sender);\n    v6, /* uint256 */ v7, /* uint256 */ v8, /* uint256 */ v9 = _router.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    require(!_tradingEnabled, Error('Trading is already enabled'));\n    _tradingEnabled = 1;\n    stor_b = block.number;\n}\n\nfunction rescueERC20(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* bool */ v1 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == bool(v1));\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_210();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction rescueETH(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(_allowance[msg.sender][varg0] >= varg1, Error('ERC20: decreased allowance below zero'));\n    require(_allowance[msg.sender][varg0] - varg1 <= _allowance[msg.sender][varg0], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(_allowance[msg.sender][varg0] - varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1712(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction exemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_exemptFee[varg0]));\n}\n\nfunction UpdateBuyTaxes(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    MEM[64] += 64;\n    MEM[MEM[64]] = varg0;\n    MEM[32 + MEM[64]] = varg1;\n    _taxes = varg0;\n    stor_d = varg1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction SetSellTaxes(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    MEM[64] += 64;\n    MEM[MEM[64]] = varg0;\n    MEM[32 + MEM[64]] = varg1;\n    _sellTaxes = varg0;\n    stor_f = varg1;\n}\n\nfunction AddbulkExemptFee(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _exemptFee[address(v0[v5])] = bool(1) | bytes31(_exemptFee[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction sellTaxes() public nonPayable { \n    return _sellTaxes, stor_f;\n}\n\nfunction router() public nonPayable { \n    return _router;\n}\n\nfunction @name_201() private { \n    v0 = v1 = _@name_201.length >> 1;\n    if (!(_@name_201.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_201.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_201.length >> 1;\n    if (!(_@name_201.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_201.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_201.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_201.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @symbol_210() private { \n    v0 = v1 = _@symbol_210.length >> 1;\n    if (!(_@symbol_210.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_210.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_210.length >> 1;\n    if (!(_@symbol_210.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_210.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_210.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_210.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x832c2bd2 > v0) {\n            if (0x42b6fa11 > v0) {\n                if (0x23b872dd > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x1340538f == v0) {\n                        updateLiquidityProvide(bool);\n                    } else {\n                        require(0x18160ddd == v0);\n                        totalSupply();\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x251ef095 == v0) {\n                    RemovebulkExemptFee(address[]);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else {\n                    require(0x42af1884 == v0);\n                    updateDeadline(uint256);\n                }\n            } else if (0x66a88d96 > v0) {\n                if (0x42b6fa11 == v0) {\n                    updateLiquidityTreshhold(uint256);\n                } else if (0x4ada218b == v0) {\n                    tradingEnabled();\n                } else if (0x5dbdb7e3 == v0) {\n                    AddExemptFee(address);\n                } else {\n                    require(0x65de1846 == v0);\n                    updateMaxAllLimits(uint256);\n                }\n            } else if (0x66a88d96 == v0) {\n                maxWalletLimit();\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            } else if (0x715018a6 == v0) {\n                renounceOwnership();\n            } else if (0x728f8eea == v0) {\n                taxes();\n            } else {\n                require(0x7cb332bb == v0);\n                updateTeamWallet(address);\n            }\n        } else if (0xa9059cbb > v0) {\n            if (0x8da5cb5b > v0) {\n                if (0x832c2bd2 == v0) {\n                    RemoveExemptFee(address);\n                } else if (0x85141a77 == v0) {\n                    deadWallet();\n                } else if (0x8a8c523c == v0) {\n                    enableTrading();\n                } else {\n                    require(0x8cd4426d == v0);\n                    rescueERC20(address,uint256);\n                }\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else if (0x9e252f00 == v0) {\n                rescueETH(uint256);\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else {\n                require(0xa8aa1b31 == v0);\n                pair();\n            }\n        } else if (0xf2fde38b > v0) {\n            if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xc5d32bb2 == v0) {\n                exemptFee(address);\n            } else if (0xd695609b == v0) {\n                UpdateBuyTaxes(uint256,uint256);\n            } else {\n                require(0xdd62ed3e == v0);\n                allowance(address,address);\n            }\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf52be97c == v0) {\n            SetSellTaxes(uint256,uint256);\n        } else if (0xf570d4de == v0) {\n            AddbulkExemptFee(address[]);\n        } else if (0xf66895a3 == v0) {\n            sellTaxes();\n        } else {\n            require(0xf887ea40 == v0);\n            router();\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.15 19:25 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_201; // STORAGE[0x3]\nuint256[] _@symbol_210; // STORAGE[0x4]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _maxWalletLimit; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _taxes; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 _sellTaxes; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nmapping (uint256 => uint256) _exemptFee; // STORAGE[0x10]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_13; // STORAGE[0x13]\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _router; // STORAGE[0x6] bytes 0 to 19\nuint256 _pair; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 stor_7_20_20; // STORAGE[0x7] bytes 20 to 20\nuint256 stor_7_21_21; // STORAGE[0x7] bytes 21 to 21\nuint256 _tradingEnabled; // STORAGE[0x7] bytes 22 to 22\n\n\n// Events\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\nTransfer(address, address, uint256);\n\nfunction @_approve_578(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1712(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = !uint8(_exemptFee[address(varg2)]);\n    if (!bool(uint8(_exemptFee[address(varg2)]))) {\n        v0 = v2 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v0) {\n        require(_tradingEnabled, Error('Trading not enabled'));\n    }\n    v3 = v4 = _pair == address(varg2);\n    if (v4) {\n        v3 = v5 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v3) {\n        v3 = v6 = !stor_7_20_20;\n    }\n    if (v3) {\n        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n        require(varg0 + _balanceOf[address(varg1)] <= _maxWalletLimit, Error('You are exceeding maxWalletLimit'));\n    }\n    v7 = v8 = _pair == address(varg2);\n    if (v8) {\n        v7 = v9 = stor_14_0_19 == address(varg1);\n    }\n    if (v7) {\n        if (~0 > _allowance[address(varg2)][address(varg1)]) {\n            _allowance[address(varg2)][address(varg1)] = ~0;\n            // Unknown jump to Block 0x154b. Refer to 3-address code (TAC);\n        }\n    }\n    v10 = v11 = _pair != address(varg2);\n    if (_pair != address(varg2)) {\n        v10 = v12 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v10) {\n        v10 = v13 = !uint8(_exemptFee[address(varg2)]);\n    }\n    if (v10) {\n        v10 = v14 = !stor_7_20_20;\n    }\n    if (v10) {\n        if (_pair != address(varg1)) {\n            require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n            require(varg0 + _balanceOf[address(varg1)] <= _maxWalletLimit, Error('You are exceeding maxWalletLimit'));\n        }\n    }\n    v15 = v16 = 0;\n    v17 = v18 = MEM[64];\n    MEM[v18] = 0;\n    MEM[32 + v18] = 0;\n    v19 = v20 = !uint8(_exemptFee[address(varg2)]);\n    if (!bool(uint8(_exemptFee[address(varg2)]))) {\n        v19 = v21 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v19) {\n        require(stor_b <= stor_12 + stor_b, Panic(17)); // arithmetic overflow or underflow\n        v19 = v22 = block.number < stor_12 + stor_b;\n    }\n    v23 = v24 = stor_7_20_20;\n    if (!v24) {\n        v23 = v25 = uint8(_exemptFee[address(varg2)]);\n    }\n    if (!v23) {\n        v23 = v26 = uint8(_exemptFee[address(varg1)]);\n    }\n    if (!v23) {\n        v27 = v28 = _pair == address(varg1);\n        if (v28) {\n            v27 = v29 = !v19;\n        }\n        if (!v27) {\n            if (v19) {\n                if (v19) {\n                    v15 = v30 = stor_13;\n                }\n            } else {\n                v15 = _taxes + stor_d;\n                require(stor_d <= v15, Panic(17)); // arithmetic overflow or underflow\n                v17 = v31 = MEM[64];\n                MEM[64] = 64 + v31;\n                MEM[v31] = _taxes;\n                MEM[v31 + 32] = stor_d;\n            }\n        } else {\n            v15 = v32 = _sellTaxes + stor_f;\n            require(stor_f <= v32, Panic(17)); // arithmetic overflow or underflow\n            v17 = v33 = MEM[64];\n            MEM[64] = 64 + v33;\n            MEM[v33] = _sellTaxes;\n            MEM[v33 + 32] = stor_f;\n        }\n    }\n    require((v15 == v15 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    v34 = v35 = stor_7_21_21;\n    if (v35) {\n        v34 = v36 = _pair != address(varg2);\n    }\n    if (v34) {\n        if (!stor_7_20_20) {\n            stor_7_20_20 = 1;\n            if (v15) {\n                v37 = v38 = _balanceOf[this];\n                if (v38 >= stor_9) {\n                    if (stor_9 > 1) {\n                        v37 = stor_9;\n                    }\n                    require((v15 == v15 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                    require((MEM[32 + v17] == MEM[32 + v17] * v37 / v37) | !v37, Panic(17)); // arithmetic overflow or underflow\n                    require(v15 << 1, Panic(18)); // division by zero\n                    v39 = MEM[32 + v17] * v37 / (v15 << 1);\n                    require(v37 - v39 <= v37, Panic(17)); // arithmetic overflow or underflow\n                    v40 = new address[](2);\n                    CALLDATACOPY(v40.data, msg.data.length, 64);\n                    require(0 < v40.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v41 = v40.data;\n                    v40[0] = address(this);\n                    v42, /* address */ v43 = _router.WETH().gas(msg.gas);\n                    require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                    require(v43 == address(v43));\n                    require(1 < v40.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v40[1] = address(v43);\n                    @_approve_578(v37 - v39, _router, this);\n                    v44 = new address[](v40.length);\n                    v45 = v46 = v44.data;\n                    v47 = v48 = v40.data;\n                    v49 = v50 = 0;\n                    while (v49 < v40.length) {\n                        MEM[v45] = address(MEM[v47]);\n                        v47 += 32;\n                        v45 += 32;\n                        v49 += 1;\n                    }\n                    require(bool(_router.code.size));\n                    v51 = _router.swapExactTokensForETHSupportingFeeOnTransferTokens(v37 - v39, 0, v44, address(this), block.timestamp, v52, address(this)).gas(msg.gas);\n                    require(bool(v51), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(this.balance - this.balance <= this.balance, Panic(17)); // arithmetic overflow or underflow\n                    require((v15 << 1) - MEM[32 + v17] <= v15 << 1, Panic(17)); // arithmetic overflow or underflow\n                    require((v15 << 1) - MEM[32 + v17], Panic(18)); // division by zero\n                    v53 = (this.balance - this.balance) / ((v15 << 1) - MEM[32 + v17]);\n                    require((MEM[32 + v17] == MEM[32 + v17] * v53 / v53) | !v53, Panic(17)); // arithmetic overflow or underflow\n                    if (MEM[32 + v17] * v53) {\n                        @_approve_578(v39, _router, this);\n                        v54, /* uint256 */ v55, /* uint256 */ v56, /* uint256 */ v57 = _router.addLiquidityETH(address(this), v39, 0, 0, address(0xdead), block.timestamp).value(MEM[32 + v17] * v53).gas(msg.gas);\n                        require(bool(v54), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    }\n                    require((v53 == v53 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                    require((MEM[v17] == MEM[v17] * (v53 << 1) / (v53 << 1)) | !(v53 << 1), Panic(17)); // arithmetic overflow or underflow\n                    if (MEM[v17] * (v53 << 1)) {\n                        require(this.balance >= MEM[v17] * (v53 << 1), Error('Address: insufficient balance'));\n                        v58, /* uint256 */ v59 = stor_14_0_19.call().value(MEM[v17] * (v53 << 1)).gas(msg.gas);\n                        if (RETURNDATASIZE() != 0) {\n                            v60 = new bytes[](RETURNDATASIZE());\n                            RETURNDATACOPY(v60.data, 0, RETURNDATASIZE());\n                        }\n                        require(v58, Error('Address: unable to send value, recipient may have reverted'));\n                        // Unknown jump to Block 0x1aabB0x1818. Refer to 3-address code (TAC);\n                    }\n                }\n            }\n            stor_7_20_20 = 0;\n            // Unknown jump to Block 0x1821. Refer to 3-address code (TAC);\n        }\n    }\n    require(varg0 - v15 * varg0 / 100 <= varg0, Panic(17)); // arithmetic overflow or underflow\n    @_transfer_488(varg0 - v15 * varg0 / 100, varg1, varg2);\n    if (!(v15 * varg0 / 100)) {\n        return ;\n    } else if (!v15) {\n        return ;\n    } else if (_pair == address(varg2)) {\n        if (address(varg2) - _pair) {\n            return ;\n        } else {\n            require((v15 == v15 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n            require(100, Panic(18)); // division by zero\n            @_transfer_488(v15 * varg0 / 100, this, varg2);\n            return ;\n        }\n    } else {\n        require(0x38d7ea4c68000, Panic(18)); // division by zero\n        require(v15 - this.balance / 0x38d7ea4c68000 <= v15, Panic(17)); // arithmetic overflow or underflow\n        require((v15 - this.balance / 0x38d7ea4c68000 == (v15 - this.balance / 0x38d7ea4c68000) * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n        require(100, Panic(18)); // division by zero\n        @_transfer_488((v15 - this.balance / 0x38d7ea4c68000) * varg0 / 100, this, varg2);\n        return ;\n    }\n}\n\nfunction @_transfer_488(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[varg2] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    require(_balanceOf[varg2] - varg0 <= _balanceOf[varg2], Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg2] = _balanceOf[varg2] - varg0;\n    require(_balanceOf[varg1] <= varg0 + _balanceOf[varg1], Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg1] += varg0;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_201();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_578(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateLiquidityProvide(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_7_21_21 = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1712(varg2, varg1, varg0);\n    require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: transfer amount exceeds allowance'));\n    require(_allowance[varg0][msg.sender] - varg2 <= _allowance[varg0][msg.sender], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction RemovebulkExemptFee(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _exemptFee[address(v0[v5])] = bool(0) | bytes31(_exemptFee[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(_allowance[msg.sender][varg0] <= varg1 + _allowance[msg.sender][varg0], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(varg1 + _allowance[msg.sender][varg0], varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateDeadline(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!_tradingEnabled, Error(\"Can't change when trading has started\"));\n    stor_12 = varg0;\n}\n\nfunction updateLiquidityTreshhold(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(18));\n    require((v0 == v0 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    stor_9 = v0 * varg0;\n}\n\nfunction tradingEnabled() public nonPayable { \n    return _tradingEnabled;\n}\n\nfunction () public payable { \n}\n\nfunction AddExemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _exemptFee[varg0] = 0x1 | bytes31(_exemptFee[address(varg0)]);\n}\n\nfunction updateMaxAllLimits(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(18));\n    require((v0 == v0 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    _maxWalletLimit = v0 * varg0;\n}\n\nfunction maxWalletLimit() public nonPayable { \n    return _maxWalletLimit;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction taxes() public nonPayable { \n    return _taxes, stor_d;\n}\n\nfunction updateTeamWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_14_0_19 = varg0;\n}\n\nfunction RemoveExemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _exemptFee[varg0] = bytes31(_exemptFee[address(varg0)]);\n}\n\nfunction deadWallet() public nonPayable { \n    return address(0xdead);\n}\n\nfunction enableTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* address */ v1 = _router.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = _router.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _pair = v5;\n    @_approve_578(~0, _router, msg.sender);\n    v6, /* uint256 */ v7, /* uint256 */ v8, /* uint256 */ v9 = _router.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    require(!_tradingEnabled, Error('Trading is already enabled'));\n    _tradingEnabled = 1;\n    stor_b = block.number;\n}\n\nfunction rescueERC20(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* bool */ v1 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == bool(v1));\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_210();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction rescueETH(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(_allowance[msg.sender][varg0] >= varg1, Error('ERC20: decreased allowance below zero'));\n    require(_allowance[msg.sender][varg0] - varg1 <= _allowance[msg.sender][varg0], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(_allowance[msg.sender][varg0] - varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1712(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction exemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_exemptFee[varg0]));\n}\n\nfunction UpdateBuyTaxes(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    MEM[64] += 64;\n    MEM[MEM[64]] = varg0;\n    MEM[32 + MEM[64]] = varg1;\n    _taxes = varg0;\n    stor_d = varg1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction SetSellTaxes(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    MEM[64] += 64;\n    MEM[MEM[64]] = varg0;\n    MEM[32 + MEM[64]] = varg1;\n    _sellTaxes = varg0;\n    stor_f = varg1;\n}\n\nfunction AddbulkExemptFee(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _exemptFee[address(v0[v5])] = bool(1) | bytes31(_exemptFee[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction sellTaxes() public nonPayable { \n    return _sellTaxes, stor_f;\n}\n\nfunction router() public nonPayable { \n    return _router;\n}\n\nfunction @name_201() private { \n    v0 = v1 = _@name_201.length >> 1;\n    if (!(_@name_201.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_201.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_201.length >> 1;\n    if (!(_@name_201.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_201.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_201.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_201.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @symbol_210() private { \n    v0 = v1 = _@symbol_210.length >> 1;\n    if (!(_@symbol_210.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_210.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_210.length >> 1;\n    if (!(_@symbol_210.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_210.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_210.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_210.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x832c2bd2 > v0) {\n            if (0x42b6fa11 > v0) {\n                if (0x23b872dd > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x1340538f == v0) {\n                        updateLiquidityProvide(bool);\n                    } else {\n                        require(0x18160ddd == v0);\n                        totalSupply();\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x251ef095 == v0) {\n                    RemovebulkExemptFee(address[]);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else {\n                    require(0x42af1884 == v0);\n                    updateDeadline(uint256);\n                }\n            } else if (0x66a88d96 > v0) {\n                if (0x42b6fa11 == v0) {\n                    updateLiquidityTreshhold(uint256);\n                } else if (0x4ada218b == v0) {\n                    tradingEnabled();\n                } else if (0x5dbdb7e3 == v0) {\n                    AddExemptFee(address);\n                } else {\n                    require(0x65de1846 == v0);\n                    updateMaxAllLimits(uint256);\n                }\n            } else if (0x66a88d96 == v0) {\n                maxWalletLimit();\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            } else if (0x715018a6 == v0) {\n                renounceOwnership();\n            } else if (0x728f8eea == v0) {\n                taxes();\n            } else {\n                require(0x7cb332bb == v0);\n                updateTeamWallet(address);\n            }\n        } else if (0xa9059cbb > v0) {\n            if (0x8da5cb5b > v0) {\n                if (0x832c2bd2 == v0) {\n                    RemoveExemptFee(address);\n                } else if (0x85141a77 == v0) {\n                    deadWallet();\n                } else if (0x8a8c523c == v0) {\n                    enableTrading();\n                } else {\n                    require(0x8cd4426d == v0);\n                    rescueERC20(address,uint256);\n                }\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else if (0x9e252f00 == v0) {\n                rescueETH(uint256);\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else {\n                require(0xa8aa1b31 == v0);\n                pair();\n            }\n        } else if (0xf2fde38b > v0) {\n            if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xc5d32bb2 == v0) {\n                exemptFee(address);\n            } else if (0xd695609b == v0) {\n                UpdateBuyTaxes(uint256,uint256);\n            } else {\n                require(0xdd62ed3e == v0);\n                allowance(address,address);\n            }\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf52be97c == v0) {\n            SetSellTaxes(uint256,uint256);\n        } else if (0xf570d4de == v0) {\n            AddbulkExemptFee(address[]);\n        } else if (0xf66895a3 == v0) {\n            sellTaxes();\n        } else {\n            require(0xf887ea40 == v0);\n            router();\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.15 19:25 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_201; // STORAGE[0x3]\nuint256[] _@symbol_210; // STORAGE[0x4]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _maxWalletLimit; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _taxes; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 _sellTaxes; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nmapping (uint256 => uint256) _exemptFee; // STORAGE[0x10]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_13; // STORAGE[0x13]\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _router; // STORAGE[0x6] bytes 0 to 19\nuint256 _pair; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 stor_7_20_20; // STORAGE[0x7] bytes 20 to 20\nuint256 stor_7_21_21; // STORAGE[0x7] bytes 21 to 21\nuint256 _tradingEnabled; // STORAGE[0x7] bytes 22 to 22\n\n\n// Events\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\nTransfer(address, address, uint256);\n\nfunction @_approve_578(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1712(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = !uint8(_exemptFee[address(varg2)]);\n    if (!bool(uint8(_exemptFee[address(varg2)]))) {\n        v0 = v2 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v0) {\n        require(_tradingEnabled, Error('Trading not enabled'));\n    }\n    v3 = v4 = _pair == address(varg2);\n    if (v4) {\n        v3 = v5 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v3) {\n        v3 = v6 = !stor_7_20_20;\n    }\n    if (v3) {\n        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n        require(varg0 + _balanceOf[address(varg1)] <= _maxWalletLimit, Error('You are exceeding maxWalletLimit'));\n    }\n    v7 = v8 = _pair == address(varg2);\n    if (v8) {\n        v7 = v9 = stor_14_0_19 == address(varg1);\n    }\n    if (v7) {\n        if (~0 > _allowance[address(varg2)][address(varg1)]) {\n            _allowance[address(varg2)][address(varg1)] = ~0;\n            // Unknown jump to Block 0x154b. Refer to 3-address code (TAC);\n        }\n    }\n    v10 = v11 = _pair != address(varg2);\n    if (_pair != address(varg2)) {\n        v10 = v12 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v10) {\n        v10 = v13 = !uint8(_exemptFee[address(varg2)]);\n    }\n    if (v10) {\n        v10 = v14 = !stor_7_20_20;\n    }\n    if (v10) {\n        if (_pair != address(varg1)) {\n            require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n            require(varg0 + _balanceOf[address(varg1)] <= _maxWalletLimit, Error('You are exceeding maxWalletLimit'));\n        }\n    }\n    v15 = v16 = 0;\n    v17 = v18 = MEM[64];\n    MEM[v18] = 0;\n    MEM[32 + v18] = 0;\n    v19 = v20 = !uint8(_exemptFee[address(varg2)]);\n    if (!bool(uint8(_exemptFee[address(varg2)]))) {\n        v19 = v21 = !uint8(_exemptFee[address(varg1)]);\n    }\n    if (v19) {\n        require(stor_b <= stor_12 + stor_b, Panic(17)); // arithmetic overflow or underflow\n        v19 = v22 = block.number < stor_12 + stor_b;\n    }\n    v23 = v24 = stor_7_20_20;\n    if (!v24) {\n        v23 = v25 = uint8(_exemptFee[address(varg2)]);\n    }\n    if (!v23) {\n        v23 = v26 = uint8(_exemptFee[address(varg1)]);\n    }\n    if (!v23) {\n        v27 = v28 = _pair == address(varg1);\n        if (v28) {\n            v27 = v29 = !v19;\n        }\n        if (!v27) {\n            if (v19) {\n                if (v19) {\n                    v15 = v30 = stor_13;\n                }\n            } else {\n                v15 = _taxes + stor_d;\n                require(stor_d <= v15, Panic(17)); // arithmetic overflow or underflow\n                v17 = v31 = MEM[64];\n                MEM[64] = 64 + v31;\n                MEM[v31] = _taxes;\n                MEM[v31 + 32] = stor_d;\n            }\n        } else {\n            v15 = v32 = _sellTaxes + stor_f;\n            require(stor_f <= v32, Panic(17)); // arithmetic overflow or underflow\n            v17 = v33 = MEM[64];\n            MEM[64] = 64 + v33;\n            MEM[v33] = _sellTaxes;\n            MEM[v33 + 32] = stor_f;\n        }\n    }\n    require((v15 == v15 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    v34 = v35 = stor_7_21_21;\n    if (v35) {\n        v34 = v36 = _pair != address(varg2);\n    }\n    if (v34) {\n        if (!stor_7_20_20) {\n            stor_7_20_20 = 1;\n            if (v15) {\n                v37 = v38 = _balanceOf[this];\n                if (v38 >= stor_9) {\n                    if (stor_9 > 1) {\n                        v37 = stor_9;\n                    }\n                    require((v15 == v15 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                    require((MEM[32 + v17] == MEM[32 + v17] * v37 / v37) | !v37, Panic(17)); // arithmetic overflow or underflow\n                    require(v15 << 1, Panic(18)); // division by zero\n                    v39 = MEM[32 + v17] * v37 / (v15 << 1);\n                    require(v37 - v39 <= v37, Panic(17)); // arithmetic overflow or underflow\n                    v40 = new address[](2);\n                    CALLDATACOPY(v40.data, msg.data.length, 64);\n                    require(0 < v40.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v41 = v40.data;\n                    v40[0] = address(this);\n                    v42, /* address */ v43 = _router.WETH().gas(msg.gas);\n                    require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                    require(v43 == address(v43));\n                    require(1 < v40.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v40[1] = address(v43);\n                    @_approve_578(v37 - v39, _router, this);\n                    v44 = new address[](v40.length);\n                    v45 = v46 = v44.data;\n                    v47 = v48 = v40.data;\n                    v49 = v50 = 0;\n                    while (v49 < v40.length) {\n                        MEM[v45] = address(MEM[v47]);\n                        v47 += 32;\n                        v45 += 32;\n                        v49 += 1;\n                    }\n                    require(bool(_router.code.size));\n                    v51 = _router.swapExactTokensForETHSupportingFeeOnTransferTokens(v37 - v39, 0, v44, address(this), block.timestamp, v52, address(this)).gas(msg.gas);\n                    require(bool(v51), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(this.balance - this.balance <= this.balance, Panic(17)); // arithmetic overflow or underflow\n                    require((v15 << 1) - MEM[32 + v17] <= v15 << 1, Panic(17)); // arithmetic overflow or underflow\n                    require((v15 << 1) - MEM[32 + v17], Panic(18)); // division by zero\n                    v53 = (this.balance - this.balance) / ((v15 << 1) - MEM[32 + v17]);\n                    require((MEM[32 + v17] == MEM[32 + v17] * v53 / v53) | !v53, Panic(17)); // arithmetic overflow or underflow\n                    if (MEM[32 + v17] * v53) {\n                        @_approve_578(v39, _router, this);\n                        v54, /* uint256 */ v55, /* uint256 */ v56, /* uint256 */ v57 = _router.addLiquidityETH(address(this), v39, 0, 0, address(0xdead), block.timestamp).value(MEM[32 + v17] * v53).gas(msg.gas);\n                        require(bool(v54), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    }\n                    require((v53 == v53 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                    require((MEM[v17] == MEM[v17] * (v53 << 1) / (v53 << 1)) | !(v53 << 1), Panic(17)); // arithmetic overflow or underflow\n                    if (MEM[v17] * (v53 << 1)) {\n                        require(this.balance >= MEM[v17] * (v53 << 1), Error('Address: insufficient balance'));\n                        v58, /* uint256 */ v59 = stor_14_0_19.call().value(MEM[v17] * (v53 << 1)).gas(msg.gas);\n                        if (RETURNDATASIZE() != 0) {\n                            v60 = new bytes[](RETURNDATASIZE());\n                            RETURNDATACOPY(v60.data, 0, RETURNDATASIZE());\n                        }\n                        require(v58, Error('Address: unable to send value, recipient may have reverted'));\n                        // Unknown jump to Block 0x1aabB0x1818. Refer to 3-address code (TAC);\n                    }\n                }\n            }\n            stor_7_20_20 = 0;\n            // Unknown jump to Block 0x1821. Refer to 3-address code (TAC);\n        }\n    }\n    require(varg0 - v15 * varg0 / 100 <= varg0, Panic(17)); // arithmetic overflow or underflow\n    @_transfer_488(varg0 - v15 * varg0 / 100, varg1, varg2);\n    if (!(v15 * varg0 / 100)) {\n        return ;\n    } else if (!v15) {\n        return ;\n    } else if (_pair == address(varg2)) {\n        if (address(varg2) - _pair) {\n            return ;\n        } else {\n            require((v15 == v15 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n            require(100, Panic(18)); // division by zero\n            @_transfer_488(v15 * varg0 / 100, this, varg2);\n            return ;\n        }\n    } else {\n        require(0x38d7ea4c68000, Panic(18)); // division by zero\n        require(v15 - this.balance / 0x38d7ea4c68000 <= v15, Panic(17)); // arithmetic overflow or underflow\n        require((v15 - this.balance / 0x38d7ea4c68000 == (v15 - this.balance / 0x38d7ea4c68000) * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n        require(100, Panic(18)); // division by zero\n        @_transfer_488((v15 - this.balance / 0x38d7ea4c68000) * varg0 / 100, this, varg2);\n        return ;\n    }\n}\n\nfunction @_transfer_488(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[varg2] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    require(_balanceOf[varg2] - varg0 <= _balanceOf[varg2], Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg2] = _balanceOf[varg2] - varg0;\n    require(_balanceOf[varg1] <= varg0 + _balanceOf[varg1], Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg1] += varg0;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_201();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_578(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateLiquidityProvide(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_7_21_21 = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1712(varg2, varg1, varg0);\n    require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: transfer amount exceeds allowance'));\n    require(_allowance[varg0][msg.sender] - varg2 <= _allowance[varg0][msg.sender], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction RemovebulkExemptFee(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _exemptFee[address(v0[v5])] = bool(0) | bytes31(_exemptFee[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(_allowance[msg.sender][varg0] <= varg1 + _allowance[msg.sender][varg0], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(varg1 + _allowance[msg.sender][varg0], varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateDeadline(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!_tradingEnabled, Error(\"Can't change when trading has started\"));\n    stor_12 = varg0;\n}\n\nfunction updateLiquidityTreshhold(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(18));\n    require((v0 == v0 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    stor_9 = v0 * varg0;\n}\n\nfunction tradingEnabled() public nonPayable { \n    return _tradingEnabled;\n}\n\nfunction () public payable { \n}\n\nfunction AddExemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _exemptFee[varg0] = 0x1 | bytes31(_exemptFee[address(varg0)]);\n}\n\nfunction updateMaxAllLimits(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(18));\n    require((v0 == v0 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    _maxWalletLimit = v0 * varg0;\n}\n\nfunction maxWalletLimit() public nonPayable { \n    return _maxWalletLimit;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction taxes() public nonPayable { \n    return _taxes, stor_d;\n}\n\nfunction updateTeamWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_14_0_19 = varg0;\n}\n\nfunction RemoveExemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _exemptFee[varg0] = bytes31(_exemptFee[address(varg0)]);\n}\n\nfunction deadWallet() public nonPayable { \n    return address(0xdead);\n}\n\nfunction enableTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* address */ v1 = _router.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = _router.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _pair = v5;\n    @_approve_578(~0, _router, msg.sender);\n    v6, /* uint256 */ v7, /* uint256 */ v8, /* uint256 */ v9 = _router.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    require(!_tradingEnabled, Error('Trading is already enabled'));\n    _tradingEnabled = 1;\n    stor_b = block.number;\n}\n\nfunction rescueERC20(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* bool */ v1 = varg0.transfer(_owner, varg1).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == bool(v1));\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_210();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction rescueETH(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(_allowance[msg.sender][varg0] >= varg1, Error('ERC20: decreased allowance below zero'));\n    require(_allowance[msg.sender][varg0] - varg1 <= _allowance[msg.sender][varg0], Panic(17)); // arithmetic overflow or underflow\n    @_approve_578(_allowance[msg.sender][varg0] - varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1712(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction exemptFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_exemptFee[varg0]));\n}\n\nfunction UpdateBuyTaxes(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    MEM[64] += 64;\n    MEM[MEM[64]] = varg0;\n    MEM[32 + MEM[64]] = varg1;\n    _taxes = varg0;\n    stor_d = varg1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction SetSellTaxes(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    MEM[64] += 64;\n    MEM[MEM[64]] = varg0;\n    MEM[32 + MEM[64]] = varg1;\n    _sellTaxes = varg0;\n    stor_f = varg1;\n}\n\nfunction AddbulkExemptFee(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _exemptFee[address(v0[v5])] = bool(1) | bytes31(_exemptFee[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction sellTaxes() public nonPayable { \n    return _sellTaxes, stor_f;\n}\n\nfunction router() public nonPayable { \n    return _router;\n}\n\nfunction @name_201() private { \n    v0 = v1 = _@name_201.length >> 1;\n    if (!(_@name_201.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_201.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_201.length >> 1;\n    if (!(_@name_201.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_201.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_201.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_201.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @symbol_210() private { \n    v0 = v1 = _@symbol_210.length >> 1;\n    if (!(_@symbol_210.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_210.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_210.length >> 1;\n    if (!(_@symbol_210.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_210.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_210.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_210.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x832c2bd2 > v0) {\n            if (0x42b6fa11 > v0) {\n                if (0x23b872dd > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x1340538f == v0) {\n                        updateLiquidityProvide(bool);\n                    } else {\n                        require(0x18160ddd == v0);\n                        totalSupply();\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x251ef095 == v0) {\n                    RemovebulkExemptFee(address[]);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else {\n                    require(0x42af1884 == v0);\n                    updateDeadline(uint256);\n                }\n            } else if (0x66a88d96 > v0) {\n                if (0x42b6fa11 == v0) {\n                    updateLiquidityTreshhold(uint256);\n                } else if (0x4ada218b == v0) {\n                    tradingEnabled();\n                } else if (0x5dbdb7e3 == v0) {\n                    AddExemptFee(address);\n                } else {\n                    require(0x65de1846 == v0);\n                    updateMaxAllLimits(uint256);\n                }\n            } else if (0x66a88d96 == v0) {\n                maxWalletLimit();\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            } else if (0x715018a6 == v0) {\n                renounceOwnership();\n            } else if (0x728f8eea == v0) {\n                taxes();\n            } else {\n                require(0x7cb332bb == v0);\n                updateTeamWallet(address);\n            }\n        } else if (0xa9059cbb > v0) {\n            if (0x8da5cb5b > v0) {\n                if (0x832c2bd2 == v0) {\n                    RemoveExemptFee(address);\n                } else if (0x85141a77 == v0) {\n                    deadWallet();\n                } else if (0x8a8c523c == v0) {\n                    enableTrading();\n                } else {\n                    require(0x8cd4426d == v0);\n                    rescueERC20(address,uint256);\n                }\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else if (0x9e252f00 == v0) {\n                rescueETH(uint256);\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else {\n                require(0xa8aa1b31 == v0);\n                pair();\n            }\n        } else if (0xf2fde38b > v0) {\n            if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xc5d32bb2 == v0) {\n                exemptFee(address);\n            } else if (0xd695609b == v0) {\n                UpdateBuyTaxes(uint256,uint256);\n            } else {\n                require(0xdd62ed3e == v0);\n                allowance(address,address);\n            }\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf52be97c == v0) {\n            SetSellTaxes(uint256,uint256);\n        } else if (0xf570d4de == v0) {\n            AddbulkExemptFee(address[]);\n        } else if (0xf66895a3 == v0) {\n            sellTaxes();\n        } else {\n            require(0xf887ea40 == v0);\n            router();\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 33.12769412994385,
	"usage": {
		"completion_tokens": 639,
		"prompt_tokens": 9007,
		"total_tokens": 9646
	}
}