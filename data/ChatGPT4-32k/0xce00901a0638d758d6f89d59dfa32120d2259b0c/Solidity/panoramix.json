{
	"address": "0xce00901a0638d758d6f89d59dfa32120d2259b0c",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - reclaimDeposit(address[] addresses, uint256[] uints, bytes32[] leaves, uint256[] indexes, bytes predecessor, bytes successor)\n#  - withdraw(address[] addresses, uint256[] uints, bytes signature, bytes proof, bytes32 root)\n#  - exitOnHalt(address[] addresses, uint256[] uints, bytes signature, bytes proof, bytes32 root)\n#  All the rest is below.\n#\n\nconst visibilityDelay = 3\nconst confirmationDelay = 5\nconst ETH = 0\n\ndef storage:\n  stor0 is uint8 at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is uint8 at storage 3 offset 8\n  stor3 is uint8 at storage 3 offset 16\n  stor3 is uint8 at storage 3 offset 24\n  stor4 is uint8 at storage 4 offset 8\n  stor4 is uint8 at storage 4 offset 16\n  stor4 is uint8 at storage 4 offset 24\n  version is array of uint256 at storage 5\n  nonceGenerator is uint256 at storage 6\n  operatorAddress is address at storage 7\n  registryAddress is address at storage 8\n  stor9 is mapping of uint8 at storage 9\n  stor10 is mapping of uint8 at storage 10\n  stor11 is array of struct at storage 11\n  stor12 is mapping of uint8 at storage 12\n  currentGblockNumber is uint256 at storage 13\n  gblocksByNumber is mapping of struct at storage 14\n  gblocksByDepositsRoot is mapping of uint256 at storage 15\n  gblocksByWithdrawalsRoot is mapping of uint256 at storage 16\n  gblocksByBalancesRoot is mapping of uint256 at storage 17\n  submissionInterval is uint256 at storage 18\n  submissionBlock is uint256 at storage 19\n  stor99 is mapping of uint8 at storage 99\n\ndef nonceGenerator(): # not payable\n  return nonceGenerator\n\ndef isOn(): # not payable\n  return bool(stor0)\n\ndef hasExited(address account, address asset): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor12[address(account)][address(asset)])\n\ndef isOwner(address account): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor1[account])\n\ndef withdrawn(bytes32 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor10[_param1])\n\ndef deposits(bytes32 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor9[_param1])\n\ndef submissionBlock(): # not payable\n  return submissionBlock\n\ndef exited(address _param1, address _param2): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor12[_param1][_param2])\n\ndef gblocksByNumber(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return uint256(gblocksByNumber[_param1].field_0), \n         uint256(gblocksByNumber[_param1].field_256),\n         uint256(gblocksByNumber[_param1].field_512),\n         uint256(gblocksByNumber[_param1].field_768)\n\ndef version(): # not payable\n  return version[0 len version.length]\n\ndef operator(): # not payable\n  return operatorAddress\n\ndef registry(): # not payable\n  return registryAddress\n\ndef includesWithdrawals(bytes32 root): # not payable\n  require calldata.size - 4 >= 32\n  return bool(gblocksByWithdrawalsRoot[root])\n\ndef gblocksByBalancesRoot(bytes32 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return gblocksByBalancesRoot[_param1]\n\ndef gblocksByWithdrawalsRoot(bytes32 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return gblocksByWithdrawalsRoot[_param1]\n\ndef currentGblockNumber(): # not payable\n  return currentGblockNumber\n\ndef submissionInterval(): # not payable\n  return submissionInterval\n\ndef gblocksByDepositsRoot(bytes32 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return gblocksByDepositsRoot[_param1]\n\n#\n#  Regular functions\n#\n\ndef canSubmit(): # not payable\n  return block.number >= submissionBlock\n\ndef switchOff(): # not payable\n  if not stor1[caller]:\n      revert with 0, 'invalid sender; must be owner'\n  if stor0:\n      stor0 = 0\n      log Off()\n\ndef isUnconfirmedBalances(bytes32 root): # not payable\n  require calldata.size - 4 >= 32\n  return (gblocksByBalancesRoot[root] == currentGblockNumber)\n\ndef isUnconfirmedWithdrawals(bytes32 root): # not payable\n  require calldata.size - 4 >= 32\n  return (gblocksByWithdrawalsRoot[root] == currentGblockNumber)\n\ndef isConfirmedGblock(uint256 number): # not payable\n  require calldata.size - 4 >= 32\n  if 0 >= number:\n      return (0 < number)\n  return (currentGblockNumber > number)\n\ndef isConfirmedWithdrawals(bytes32 root): # not payable\n  require calldata.size - 4 >= 32\n  if 0 >= gblocksByWithdrawalsRoot[root]:\n      return (0 < gblocksByWithdrawalsRoot[root])\n  return (currentGblockNumber > gblocksByWithdrawalsRoot[root])\n\ndef canExit(bytes32 entryHash): # not payable\n  require calldata.size - 4 >= 32\n  if not uint256(stor11[entryHash].field_3072):\n      return bool(uint256(stor11[entryHash].field_3072))\n  return currentGblockNumber >= uint256(stor11[entryHash].field_3072)\n\ndef depositEther() payable: \n  if not stor0:\n      revert with 0, 'smust be on'\n  nonceGenerator++\n  stor9[this.address][caller][0][call.value][stor6 + 1][stor13 + 3] = 1\n  log Deposited(\n        address custodian=call.value,\n        address account=nonceGenerator + 1,\n        address asset=currentGblockNumber + 3,\n        uint256 quantity=this.address,\n        uint256 nonce=caller,\n        uint256 designatedGblock=0)\n\ndef _fallback(?) payable: # default function\n  if not stor0:\n      revert with 0, 'smust be on'\n  nonceGenerator++\n  stor9[this.address][caller][0][call.value][stor6 + 1][stor13 + 3] = 1\n  log Deposited(\n        address custodian=call.value,\n        address account=nonceGenerator + 1,\n        address asset=currentGblockNumber + 3,\n        uint256 quantity=this.address,\n        uint256 nonce=caller,\n        uint256 designatedGblock=0)\n\ndef addOwner(address owner): # not payable\n  require calldata.size - 4 >= 32\n  if not stor1[caller]:\n      revert with 0, 'invalid sender; must be owner'\n  if not owner:\n      revert with 0, 'invalid address'\n  if not stor1[address(owner)]:\n      stor1[address(owner)] = 1\n      stor2.length++\n      address(stor2[stor2.length].field_0) = owner\n      log OwnerAdded(address newOwner=owner)\n\ndef getOwners(): # not payable\n  if not stor2.length:\n      mem[(32 * stor2.length) + 128] = 32\n      mem[(32 * stor2.length) + 160] = stor2.length\n      mem[(32 * stor2.length) + 192 len floor32(stor2.length)] = mem[128 len floor32(stor2.length)]\n      return memory\n        from (32 * stor2.length) + 128\n         len (96 * stor2.length) + 64\n  mem[128] = address(stor2.field_0)\n  idx = 128\n  s = 0\n  while (32 * stor2.length) + 96 > idx:\n      mem[idx + 32] = address(stor2[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * stor2.length) + 192 len floor32(stor2.length)] = mem[128 len floor32(stor2.length)]\n  return Array(len=stor2.length, data=mem[128 len floor32(stor2.length)], mem[(32 * stor2.length) + floor32(stor2.length) + 192 len (32 * stor2.length) - floor32(stor2.length)]), \n\ndef reclaimDepositOnHalt(address asset, uint256 quantity, uint256 nonce, uint256 designatedGblock): # not payable\n  require calldata.size - 4 >= 128\n  if stor0:\n      revert with 0, 'must be off'\n  if designatedGblock < currentGblockNumber:\n      revert with 0, \n                  32,\n                  62,\n                  0x6e64657369676e617465642067626c6f636b20697320616c726561647920636f6e6669726d65643b2075736520657869744f6e48616c7420696e73746561,\n                  mem[798 len 2]\n  if not stor9[this.address][caller][asset][quantity][nonce][designatedGblock]:\n      revert with 0, 'unknown deposit'\n  stor9[this.address][caller][asset][quantity][nonce][designatedGblock] = 0\n  if not asset:\n      call caller with:\n         value quantity wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with 0, 'failed to transfer ether'\n  else:\n      require ext_code.size(asset)\n      call asset.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining wei\n          args caller, quantity\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      if not ext_call.return_data[0]:\n          revert with 0, 'failed to transfer token'\n  log DepositReclaimed(\n        address custodian=quantity,\n        address account=nonce,\n        address asset=this.address,\n        uint256 quantity=caller,\n        uint256 nonce=asset)\n\ndef submit(uint256 gblockNumber, bytes32 withdrawalsRoot, bytes32 depositsRoot, bytes32 balancesRoot): # not payable\n  require calldata.size - 4 >= 128\n  if not stor0:\n      revert with 0, 'smust be on'\n  if block.number < submissionBlock:\n      revert with 0, 'cannot submit yet'\n  if operatorAddress != caller:\n      revert with 0, 'submitter must be the operator'\n  if gblockNumber != currentGblockNumber + 1:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  35,\n                  0x7267626c6f636b206d75737420626520746865206e65787420696e2073657175656e63,\n                  mem[199 len 29]\n  uint256(gblocksByNumber[gblockNumber].field_0) = gblockNumber\n  uint256(gblocksByNumber[gblockNumber].field_256) = withdrawalsRoot\n  uint256(gblocksByNumber[gblockNumber].field_512) = depositsRoot\n  uint256(gblocksByNumber[gblockNumber].field_768) = balancesRoot\n  gblocksByDepositsRoot[depositsRoot] = gblockNumber\n  gblocksByWithdrawalsRoot[withdrawalsRoot] = gblockNumber\n  gblocksByBalancesRoot[balancesRoot] = gblockNumber\n  currentGblockNumber = gblockNumber\n  submissionBlock = block.number + submissionInterval\n  log Submitted(\n        uint256 gblockNumber=gblockNumber,\n        bytes32 withdrawalsRoot=withdrawalsRoot,\n        bytes32 depositsRoot=depositsRoot,\n        bytes32 balancesRoot=balancesRoot)\n\ndef depositToken(address token, uint256 amount): # not payable\n  require calldata.size - 4 >= 64\n  if not token:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  41,\n                  0x6576616c7565206d75737420626520612076616c696420455243323020746f6b656e20616464726573,\n                  mem[205 len 23]\n  require ext_code.size(token)\n  static call token.balanceOf(address account) with:\n          gas gas_remaining wei\n         args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args caller, this.address, amount\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if not ext_call.return_data[0]:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  39,\n                  0x646661696c75726520746f207472616e73666572207175616e746974792066726f6d20746f6b65,\n                  mem[203 len 25]\n  require ext_code.size(token)\n  static call token.balanceOf(address account) with:\n          gas gas_remaining wei\n         args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  if amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  67,\n                  0x6e62616420546f6b656e3b207472616e7366657246726f6d206572726f6e656f75736c79207265706f72746564206f66207375636365737366756c207472616e736665,\n                  mem[231 len 29]\n  if not stor0:\n      revert with 0, 'smust be on'\n  nonceGenerator++\n  stor9[this.address][caller][token][amount][stor6 + 1][stor13 + 3] = 1\n  log Deposited(\n        address custodian=amount,\n        address account=nonceGenerator + 1,\n        address asset=currentGblockNumber + 3,\n        uint256 quantity=this.address,\n        uint256 nonce=caller,\n        uint256 designatedGblock=token)\n\ndef removeOwner(address owner): # not payable\n  require calldata.size - 4 >= 32\n  if not stor1[caller]:\n      revert with 0, 'invalid sender; must be owner'\n  if stor1[address(owner)]:\n      if 1 >= stor2.length:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      38,\n                      0x72656d6f76696e6720746865206c617374206f776e6572206973206e6f7420616c6c6f776500,\n                      mem[202 len 26]\n      stor1[address(owner)] = 0\n      idx = 0\n      while idx < stor2.length - 1:\n          require idx < stor2.length\n          mem[0] = 2\n          if address(stor2[idx].field_0) != owner:\n              idx = idx + 1\n              continue \n          require stor2.length - 1 < stor2.length\n          require idx < stor2.length\n          address(stor2[idx].field_0) = address(stor2[stor2.length].field_0)\n          require stor2.length - 1 < stor2.length\n          address(stor2[stor2.length].field_0) = 0\n          stor2.length--\n          if stor2.length > stor2.length - 1:\n              idx = stor2.length + sha3(2) - 1\n              while sha3(2) + stor2.length > idx:\n                  uint256(stor[idx]) = 0\n                  idx = idx + 1\n                  continue \n          log OwnerRemoved(address oldOwner=owner)\n          stop\n      stor2.length--\n      if stor2.length > stor2.length - 1:\n          idx = stor2.length - 1\n          while stor2.length > idx:\n              uint256(stor2[idx].field_0) = 0\n              idx = idx + 1\n              continue \n      log OwnerRemoved(address oldOwner=owner)\n\ndef checkProof(bytes proof, bytes32 root, bytes32 leaf): # not payable\n  require calldata.size - 4 >= 96\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  if not proof.length % 32:\n      idx = 32\n      s = leaf\n      t = 0\n      while idx <= proof.length:\n          _30 = mem[idx + 96]\n          if s < mem[idx + 96]:\n              _33 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _30\n              _34 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _38 = mem[_34]\n              t = _34 + 32\n              u = mem[64] + 32\n              s = mem[_34]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_34]) + 32] = mem[_34 + floor32(mem[_34]) + -(mem[_34] % 32) + 64 len mem[_34] % 32] or Mask(8 * -(mem[_34] % 32) + 32, -(8 * -(mem[_34] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_34]) + 32])\n              _55 = mem[64]\n              mem[mem[64]] = _38 + _33 + -mem[64] + 96\n              mem[64] = _38 + _33 + 128\n              idx = idx + 32\n              s = sha3(mem[_55 + 32 len mem[_55]])\n              t = _30\n              continue \n          _35 = mem[64]\n          mem[mem[64] + 32] = mem[idx + 96]\n          mem[mem[64] + 64] = s\n          _36 = mem[64]\n          mem[mem[64]] = 64\n          mem[64] = mem[64] + 96\n          _40 = mem[_36]\n          t = _36 + 32\n          u = mem[64] + 32\n          s = mem[_36]\n          while s >= 32:\n              mem[u] = mem[t]\n              t = t + 32\n              u = u + 32\n              s = s - 32\n              continue \n          mem[mem[64] + floor32(mem[_36]) + 32] = mem[_36 + floor32(mem[_36]) + -(mem[_36] % 32) + 64 len mem[_36] % 32] or Mask(8 * -(mem[_36] % 32) + 32, -(8 * -(mem[_36] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_36]) + 32])\n          _61 = mem[64]\n          mem[mem[64]] = _40 + _35 + -mem[64] + 96\n          mem[64] = _40 + _35 + 128\n          idx = idx + 32\n          s = sha3(mem[_61 + 32 len mem[_61]])\n          t = _30\n          continue \n      return (root == s)\n  mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef verifyIncluded(bytes proof, bytes32 root, bytes32 leaf): # not payable\n  require calldata.size - 4 >= 96\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  if not proof.length % 32:\n      idx = 32\n      s = leaf\n      t = 0\n      while idx <= proof.length:\n          _30 = mem[idx + 96]\n          if s < mem[idx + 96]:\n              _31 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _30\n              _32 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _36 = mem[_32]\n              t = _32 + 32\n              u = mem[64] + 32\n              s = mem[_32]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_32]) + 32] = mem[_32 + floor32(mem[_32]) + -(mem[_32] % 32) + 64 len mem[_32] % 32] or Mask(8 * -(mem[_32] % 32) + 32, -(8 * -(mem[_32] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_32]) + 32])\n              _55 = mem[64]\n              mem[mem[64]] = _36 + _31 + -mem[64] + 96\n              mem[64] = _36 + _31 + 128\n              idx = idx + 32\n              s = sha3(mem[_55 + 32 len mem[_55]])\n              t = _30\n              continue \n          _33 = mem[64]\n          mem[mem[64] + 32] = mem[idx + 96]\n          mem[mem[64] + 64] = s\n          _34 = mem[64]\n          mem[mem[64]] = 64\n          mem[64] = mem[64] + 96\n          _38 = mem[_34]\n          t = _34 + 32\n          u = mem[64] + 32\n          s = mem[_34]\n          while s >= 32:\n              mem[u] = mem[t]\n              t = t + 32\n              u = u + 32\n              s = s - 32\n              continue \n          mem[mem[64] + floor32(mem[_34]) + 32] = mem[_34 + floor32(mem[_34]) + -(mem[_34] % 32) + 64 len mem[_34] % 32] or Mask(8 * -(mem[_34] % 32) + 32, -(8 * -(mem[_34] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_34]) + 32])\n          _61 = mem[64]\n          mem[mem[64]] = _38 + _33 + -mem[64] + 96\n          mem[64] = _38 + _33 + 128\n          idx = idx + 32\n          s = sha3(mem[_61 + 32 len mem[_61]])\n          t = _30\n          continue \n      return (root == s)\n  mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef proveInUnconfirmedBalances(bytes proof, bytes32 root, bytes32 entryHash): # not payable\n  require calldata.size - 4 >= 96\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  mem[0] = currentGblockNumber\n  mem[32] = 14\n  if root != uint256(gblocksByNumber[stor13].field_768):\n      mem[ceil32(proof.length) + 128] = root == uint256(gblocksByNumber[stor13].field_768)\n  else:\n      if not proof.length % 32:\n          idx = 32\n          s = entryHash\n          t = 0\n          while idx <= proof.length:\n              _33 = mem[idx + 96]\n              if s >= mem[idx + 96]:\n                  _36 = mem[64]\n                  mem[mem[64] + 32] = mem[idx + 96]\n                  mem[mem[64] + 64] = s\n                  _37 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _41 = mem[_37]\n                  t = _37 + 32\n                  u = _36 + 128\n                  s = mem[_37]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_36 + floor32(mem[_37]) + 128] = mem[_37 + -(mem[_37] % 32) + floor32(mem[_37]) + 64 len mem[_37] % 32] or Mask(8 * -(mem[_37] % 32) + 32, -(8 * -(mem[_37] % 32) + 32) + 256, mem[_36 + floor32(mem[_37]) + 128])\n                  mem[_36 + 96] = _41\n                  mem[64] = _41 + _36 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_36 + 128 len _41])\n                  t = _33\n                  continue \n              _34 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _33\n              _35 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _39 = mem[_35]\n              t = _35 + 32\n              u = mem[64] + 32\n              s = mem[_35]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_35]) + 32] = mem[_35 + floor32(mem[_35]) + -(mem[_35] % 32) + 64 len mem[_35] % 32] or Mask(8 * -(mem[_35] % 32) + 32, -(8 * -(mem[_35] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_35]) + 32])\n              _58 = mem[64]\n              mem[mem[64]] = _39 + _34 + -mem[64] + 96\n              mem[64] = _39 + _34 + 128\n              idx = idx + 32\n              s = sha3(mem[_58 + 32 len mem[_58]])\n              t = _33\n              continue \n          return (root == s)\n      mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef proveInConfirmedBalances(bytes proof, bytes32 root, bytes32 entryHash): # not payable\n  require calldata.size - 4 >= 96\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  mem[0] = currentGblockNumber - 1\n  mem[32] = 14\n  if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n      mem[ceil32(proof.length) + 128] = root == uint256(gblocksByNumber[stor13 - 1].field_768)\n  else:\n      if not proof.length % 32:\n          idx = 32\n          s = entryHash\n          t = 0\n          while idx <= proof.length:\n              _33 = mem[idx + 96]\n              if s >= mem[idx + 96]:\n                  _36 = mem[64]\n                  mem[mem[64] + 32] = mem[idx + 96]\n                  mem[mem[64] + 64] = s\n                  _37 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _41 = mem[_37]\n                  t = _37 + 32\n                  u = _36 + 128\n                  s = mem[_37]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_36 + floor32(mem[_37]) + 128] = mem[_37 + -(mem[_37] % 32) + floor32(mem[_37]) + 64 len mem[_37] % 32] or Mask(8 * -(mem[_37] % 32) + 32, -(8 * -(mem[_37] % 32) + 32) + 256, mem[_36 + floor32(mem[_37]) + 128])\n                  mem[_36 + 96] = _41\n                  mem[64] = _41 + _36 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_36 + 128 len _41])\n                  t = _33\n                  continue \n              _34 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _33\n              _35 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _39 = mem[_35]\n              t = _35 + 32\n              u = mem[64] + 32\n              s = mem[_35]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_35]) + 32] = mem[_35 + floor32(mem[_35]) + -(mem[_35] % 32) + 64 len mem[_35] % 32] or Mask(8 * -(mem[_35] % 32) + 32, -(8 * -(mem[_35] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_35]) + 32])\n              _58 = mem[64]\n              mem[mem[64]] = _39 + _34 + -mem[64] + 96\n              mem[64] = _39 + _34 + 128\n              idx = idx + 32\n              s = sha3(mem[_58 + 32 len mem[_58]])\n              t = _33\n              continue \n          return (root == s)\n      mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef proveInConfirmedWithdrawals(bytes proof, bytes32 root, bytes32 entryHash): # not payable\n  require calldata.size - 4 >= 96\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  mem[0] = root\n  mem[32] = 16\n  if 0 >= gblocksByWithdrawalsRoot[root]:\n      mem[ceil32(proof.length) + 128] = 0 < gblocksByWithdrawalsRoot[root]\n  else:\n      if currentGblockNumber <= gblocksByWithdrawalsRoot[root]:\n          mem[ceil32(proof.length) + 128] = currentGblockNumber > gblocksByWithdrawalsRoot[root]\n      else:\n          if not proof.length % 32:\n              idx = 32\n              s = entryHash\n              t = 0\n              while idx <= proof.length:\n                  _35 = mem[idx + 96]\n                  if s < mem[idx + 96]:\n                      _36 = mem[64]\n                      mem[mem[64] + 32] = s\n                      mem[mem[64] + 64] = _35\n                      _37 = mem[64]\n                      mem[mem[64]] = 64\n                      mem[64] = mem[64] + 96\n                      _41 = mem[_37]\n                      t = _37 + 32\n                      u = _36 + 128\n                      s = mem[_37]\n                      while s >= 32:\n                          mem[u] = mem[t]\n                          t = t + 32\n                          u = u + 32\n                          s = s - 32\n                          continue \n                      mem[_36 + floor32(mem[_37]) + 128] = mem[_37 + -(mem[_37] % 32) + floor32(mem[_37]) + 64 len mem[_37] % 32] or Mask(8 * -(mem[_37] % 32) + 32, -(8 * -(mem[_37] % 32) + 32) + 256, mem[_36 + floor32(mem[_37]) + 128])\n                      mem[_36 + 96] = _41\n                      mem[64] = _41 + _36 + 128\n                      idx = idx + 32\n                      s = sha3(mem[_36 + 128 len _41])\n                      t = _35\n                      continue \n                  _38 = mem[64]\n                  mem[mem[64] + 32] = mem[idx + 96]\n                  mem[mem[64] + 64] = s\n                  _39 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _43 = mem[_39]\n                  t = _39 + 32\n                  u = _38 + 128\n                  s = mem[_39]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_38 + floor32(mem[_39]) + 128] = mem[_39 + -(mem[_39] % 32) + floor32(mem[_39]) + 64 len mem[_39] % 32] or Mask(8 * -(mem[_39] % 32) + 32, -(8 * -(mem[_39] % 32) + 32) + 256, mem[_38 + floor32(mem[_39]) + 128])\n                  mem[_38 + 96] = _43\n                  mem[64] = _43 + _38 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_38 + 128 len _43])\n                  t = _35\n                  continue \n              return (root == s)\n          mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef checkProofOrdered(bytes proof, bytes32 root, bytes32 leaf, uint256 index): # not payable\n  require calldata.size - 4 >= 128\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  if not proof.length % 32:\n      idx = 32\n      s = 0\n      s = leaf\n      t = 0\n      t = index\n      while idx <= proof.length:\n          _65 = mem[idx + 96]\n          _66 = mem[96]\n          if mem[96] + -idx + 32 / 32 <= 0:\n              if var19006 % 2:\n                  _123 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _65\n                  _124 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _125 = mem[_124]\n                  t = _124 + 32\n                  u = _123 + 128\n                  s = mem[_124]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_123 + floor32(mem[_124]) + 128] = mem[_124 + floor32(mem[_124]) + -(mem[_124] % 32) + 64 len mem[_124] % 32] or Mask(8 * -(mem[_124] % 32) + 32, -(8 * -(mem[_124] % 32) + 32) + 256, mem[_123 + floor32(mem[_124]) + 128])\n                  _179 = mem[64]\n                  mem[mem[64]] = _125 + _123 + -mem[64] + 96\n                  mem[64] = _125 + _123 + 128\n                  idx = idx + 32\n                  s = _66 + -idx + 32 / 32\n                  s = sha3(mem[_179 + 32 len mem[_179]])\n                  t = _65\n                  t = (var19006 / 2) + 1\n                  continue \n              _126 = mem[64]\n              mem[mem[64] + 32] = mem[idx + 96]\n              mem[mem[64] + 64] = s\n              _127 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _128 = mem[_127]\n              t = _127 + 32\n              u = _126 + 128\n              s = mem[_127]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[_126 + floor32(mem[_127]) + 128] = mem[_127 + floor32(mem[_127]) + -(mem[_127] % 32) + 64 len mem[_127] % 32] or Mask(8 * -(mem[_127] % 32) + 32, -(8 * -(mem[_127] % 32) + 32) + 256, mem[_126 + floor32(mem[_127]) + 128])\n              _185 = mem[64]\n              mem[mem[64]] = _128 + _126 + -mem[64] + 96\n              mem[64] = _128 + _126 + 128\n              idx = idx + 32\n              s = _66 + -idx + 32 / 32\n              s = sha3(mem[_185 + 32 len mem[_185]])\n              t = _65\n              t = var19006 / 2\n              continue \n          t = var19006\n          while var22001:\n              if var22007 > 2^(_66 + -idx + 32 / 32):\n                  if _66 + -idx + 32 / 32 <= 0:\n                      var22001 = _66 + -idx + 32 / 32 > 0\n                      var22007 = (var22007 / 2) + 1\n                      continue \n                  t = (var22007 / 2) + 1\n                  continue \n              if var22007 % 2:\n                  _231 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _65\n                  _232 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _233 = mem[_232]\n                  t = _232 + 32\n                  u = _231 + 128\n                  s = mem[_232]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_231 + floor32(mem[_232]) + 128] = mem[_232 + floor32(mem[_232]) + -(mem[_232] % 32) + 64 len mem[_232] % 32] or Mask(8 * -(mem[_232] % 32) + 32, -(8 * -(mem[_232] % 32) + 32) + 256, mem[_231 + floor32(mem[_232]) + 128])\n                  _275 = mem[64]\n                  mem[mem[64]] = _233 + _231 + -mem[64] + 96\n                  mem[64] = _233 + _231 + 128\n                  idx = idx + 32\n                  s = _66 + -idx + 32 / 32\n                  s = sha3(mem[_275 + 32 len mem[_275]])\n                  t = _65\n                  t = (var22007 / 2) + 1\n                  continue \n              _234 = mem[64]\n              mem[mem[64] + 32] = _65\n              mem[mem[64] + 64] = s\n              _235 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _236 = mem[_235]\n              t = _235 + 32\n              u = _234 + 128\n              s = mem[_235]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[_234 + floor32(mem[_235]) + 128] = mem[_235 + floor32(mem[_235]) + -(mem[_235] % 32) + 64 len mem[_235] % 32] or Mask(8 * -(mem[_235] % 32) + 32, -(8 * -(mem[_235] % 32) + 32) + 256, mem[_234 + floor32(mem[_235]) + 128])\n              _281 = mem[64]\n              mem[mem[64]] = _236 + _234 + -mem[64] + 96\n              mem[64] = _236 + _234 + 128\n              idx = idx + 32\n              s = _66 + -idx + 32 / 32\n              s = sha3(mem[_281 + 32 len mem[_281]])\n              t = _65\n              t = var22007 / 2\n              continue \n          if var22007 % 2:\n              _225 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _65\n              _226 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _227 = mem[_226]\n              t = _226 + 32\n              u = _225 + 128\n              s = mem[_226]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[_225 + floor32(mem[_226]) + 128] = mem[_226 + floor32(mem[_226]) + -(mem[_226] % 32) + 64 len mem[_226] % 32] or Mask(8 * -(mem[_226] % 32) + 32, -(8 * -(mem[_226] % 32) + 32) + 256, mem[_225 + floor32(mem[_226]) + 128])\n              _263 = mem[64]\n              mem[mem[64]] = _227 + _225 + -mem[64] + 96\n              mem[64] = _227 + _225 + 128\n              idx = idx + 32\n              s = _66 + -idx + 32 / 32\n              s = sha3(mem[_263 + 32 len mem[_263]])\n              t = _65\n              t = (var22007 / 2) + 1\n              continue \n          _228 = mem[64]\n          mem[mem[64] + 32] = _65\n          mem[mem[64] + 64] = s\n          _229 = mem[64]\n          mem[mem[64]] = 64\n          mem[64] = mem[64] + 96\n          _230 = mem[_229]\n          t = _229 + 32\n          u = _228 + 128\n          s = mem[_229]\n          while s >= 32:\n              mem[u] = mem[t]\n              t = t + 32\n              u = u + 32\n              s = s - 32\n              continue \n          mem[_228 + floor32(mem[_229]) + 128] = mem[_229 + floor32(mem[_229]) + -(mem[_229] % 32) + 64 len mem[_229] % 32] or Mask(8 * -(mem[_229] % 32) + 32, -(8 * -(mem[_229] % 32) + 32) + 256, mem[_228 + floor32(mem[_229]) + 128])\n          _269 = mem[64]\n          mem[mem[64]] = _230 + _228 + -mem[64] + 96\n          mem[64] = _230 + _228 + 128\n          idx = idx + 32\n          s = _66 + -idx + 32 / 32\n          s = sha3(mem[_269 + 32 len mem[_269]])\n          t = _65\n          t = var22007 / 2\n          continue \n      return (root == s)\n  mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef verifyIncludedAtIndex(bytes proof, bytes32 root, bytes32 leaf, uint256 index): # not payable\n  require calldata.size - 4 >= 128\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  mem[64] = ceil32(proof.length) + 128\n  mem[96] = proof.length\n  mem[128 len proof.length] = proof[all]\n  mem[proof.length + 128] = 0\n  if not proof.length % 32:\n      idx = 32\n      s = 0\n      s = leaf\n      t = 0\n      t = index\n      while idx <= proof.length:\n          _65 = mem[idx + 96]\n          _66 = mem[96]\n          if mem[96] + -idx + 32 / 32 <= 0:\n              if var20006 % 2:\n                  _123 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _65\n                  _124 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _125 = mem[_124]\n                  t = _124 + 32\n                  u = _123 + 128\n                  s = mem[_124]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_123 + floor32(mem[_124]) + 128] = mem[_124 + floor32(mem[_124]) + -(mem[_124] % 32) + 64 len mem[_124] % 32] or Mask(8 * -(mem[_124] % 32) + 32, -(8 * -(mem[_124] % 32) + 32) + 256, mem[_123 + floor32(mem[_124]) + 128])\n                  _179 = mem[64]\n                  mem[mem[64]] = _125 + _123 + -mem[64] + 96\n                  mem[64] = _125 + _123 + 128\n                  idx = idx + 32\n                  s = _66 + -idx + 32 / 32\n                  s = sha3(mem[_179 + 32 len mem[_179]])\n                  t = _65\n                  t = (var20006 / 2) + 1\n                  continue \n              _126 = mem[64]\n              mem[mem[64] + 32] = mem[idx + 96]\n              mem[mem[64] + 64] = s\n              _127 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _128 = mem[_127]\n              t = _127 + 32\n              u = _126 + 128\n              s = mem[_127]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[_126 + floor32(mem[_127]) + 128] = mem[_127 + floor32(mem[_127]) + -(mem[_127] % 32) + 64 len mem[_127] % 32] or Mask(8 * -(mem[_127] % 32) + 32, -(8 * -(mem[_127] % 32) + 32) + 256, mem[_126 + floor32(mem[_127]) + 128])\n              _185 = mem[64]\n              mem[mem[64]] = _128 + _126 + -mem[64] + 96\n              mem[64] = _128 + _126 + 128\n              idx = idx + 32\n              s = _66 + -idx + 32 / 32\n              s = sha3(mem[_185 + 32 len mem[_185]])\n              t = _65\n              t = var20006 / 2\n              continue \n          t = var20006\n          while var23001:\n              if var23007 > 2^(_66 + -idx + 32 / 32):\n                  if _66 + -idx + 32 / 32 <= 0:\n                      var23001 = _66 + -idx + 32 / 32 > 0\n                      var23007 = (var23007 / 2) + 1\n                      continue \n                  t = (var23007 / 2) + 1\n                  continue \n              if var23007 % 2:\n                  _231 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _65\n                  _232 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _233 = mem[_232]\n                  t = _232 + 32\n                  u = _231 + 128\n                  s = mem[_232]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_231 + floor32(mem[_232]) + 128] = mem[_232 + floor32(mem[_232]) + -(mem[_232] % 32) + 64 len mem[_232] % 32] or Mask(8 * -(mem[_232] % 32) + 32, -(8 * -(mem[_232] % 32) + 32) + 256, mem[_231 + floor32(mem[_232]) + 128])\n                  _275 = mem[64]\n                  mem[mem[64]] = _233 + _231 + -mem[64] + 96\n                  mem[64] = _233 + _231 + 128\n                  idx = idx + 32\n                  s = _66 + -idx + 32 / 32\n                  s = sha3(mem[_275 + 32 len mem[_275]])\n                  t = _65\n                  t = (var23007 / 2) + 1\n                  continue \n              _234 = mem[64]\n              mem[mem[64] + 32] = _65\n              mem[mem[64] + 64] = s\n              _235 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _236 = mem[_235]\n              t = _235 + 32\n              u = _234 + 128\n              s = mem[_235]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[_234 + floor32(mem[_235]) + 128] = mem[_235 + floor32(mem[_235]) + -(mem[_235] % 32) + 64 len mem[_235] % 32] or Mask(8 * -(mem[_235] % 32) + 32, -(8 * -(mem[_235] % 32) + 32) + 256, mem[_234 + floor32(mem[_235]) + 128])\n              _281 = mem[64]\n              mem[mem[64]] = _236 + _234 + -mem[64] + 96\n              mem[64] = _236 + _234 + 128\n              idx = idx + 32\n              s = _66 + -idx + 32 / 32\n              s = sha3(mem[_281 + 32 len mem[_281]])\n              t = _65\n              t = var23007 / 2\n              continue \n          if var23007 % 2:\n              _225 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _65\n              _226 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _227 = mem[_226]\n              t = _226 + 32\n              u = _225 + 128\n              s = mem[_226]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[_225 + floor32(mem[_226]) + 128] = mem[_226 + floor32(mem[_226]) + -(mem[_226] % 32) + 64 len mem[_226] % 32] or Mask(8 * -(mem[_226] % 32) + 32, -(8 * -(mem[_226] % 32) + 32) + 256, mem[_225 + floor32(mem[_226]) + 128])\n              _263 = mem[64]\n              mem[mem[64]] = _227 + _225 + -mem[64] + 96\n              mem[64] = _227 + _225 + 128\n              idx = idx + 32\n              s = _66 + -idx + 32 / 32\n              s = sha3(mem[_263 + 32 len mem[_263]])\n              t = _65\n              t = (var23007 / 2) + 1\n              continue \n          _228 = mem[64]\n          mem[mem[64] + 32] = _65\n          mem[mem[64] + 64] = s\n          _229 = mem[64]\n          mem[mem[64]] = 64\n          mem[64] = mem[64] + 96\n          _230 = mem[_229]\n          t = _229 + 32\n          u = _228 + 128\n          s = mem[_229]\n          while s >= 32:\n              mem[u] = mem[t]\n              t = t + 32\n              u = u + 32\n              s = s - 32\n              continue \n          mem[_228 + floor32(mem[_229]) + 128] = mem[_229 + floor32(mem[_229]) + -(mem[_229] % 32) + 64 len mem[_229] % 32] or Mask(8 * -(mem[_229] % 32) + 32, -(8 * -(mem[_229] % 32) + 32) + 256, mem[_228 + floor32(mem[_229]) + 128])\n          _269 = mem[64]\n          mem[mem[64]] = _230 + _228 + -mem[64] + 96\n          mem[64] = _230 + _228 + 128\n          idx = idx + 32\n          s = _66 + -idx + 32 / 32\n          s = sha3(mem[_269 + 32 len mem[_269]])\n          t = _65\n          t = var23007 / 2\n          continue \n      return (root == s)\n  mem[ceil32(proof.length) + 128] = 0\n  return Mask(8 * -ceil32(proof.length) + proof.length + 32, 0, 0), \n         mem[proof.length + 160 len -proof.length + ceil32(proof.length)]\n\ndef exit(bytes32 entryHash, bytes proof, bytes32 root): # not payable\n  require calldata.size - 4 >= 96\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  if not stor0:\n      revert with 0, 'smust be on'\n  mem[512] = 0\n  mem[544] = 0\n  mem[576] = 0\n  mem[608] = 0\n  mem[640] = 0\n  mem[672] = 0\n  mem[704] = 0\n  mem[736] = 0\n  mem[768] = 0\n  mem[800] = 96\n  mem[832] = 96\n  mem[864] = 0\n  mem[96] = 512\n  mem[128] = 0\n  require uint8(stor11[entryHash].field_0) <= 6\n  mem[960] = uint8(stor11[entryHash].field_0)\n  mem[992] = uint256(stor11[entryHash].field_256)\n  mem[1024] = uint256(stor11[entryHash].field_512)\n  mem[1056] = uint256(stor11[entryHash].field_768)\n  mem[1088] = address(stor11[entryHash].field_1024)\n  mem[1120] = address(stor11[entryHash].field_1280)\n  mem[1152] = uint256(stor11[entryHash].field_1536)\n  mem[1184] = uint256(stor11[entryHash].field_1792)\n  mem[1216] = uint256(stor11[entryHash].field_2048)\n  mem[1344] = uint256(stor11[entryHash].field_2304)\n  if not uint256(stor11[entryHash].field_2304):\n      mem[1248] = 1344\n      mem[(32 * uint256(stor11[entryHash].field_2304)) + 1376] = uint256(stor11[entryHash].field_2560)\n      if not uint256(stor11[entryHash].field_2560):\n          mem[1280] = (32 * uint256(stor11[entryHash].field_2304)) + 1376\n          mem[1312] = uint256(stor11[entryHash].field_2816)\n          mem[896] = 960\n          mem[928] = uint256(stor11[entryHash].field_3072)\n          if not uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          if currentGblockNumber < uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          mem[64] = (32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + ceil32(proof.length) + 1440\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1408] = proof.length\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1440 len proof.length] = proof[all]\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + proof.length + 1440] = 0\n          mem[0] = currentGblockNumber\n          mem[32] = 14\n          if root != uint256(gblocksByNumber[stor13].field_768):\n              revert with 0, 'invalid balance proof'\n          if proof.length % 32:\n              revert with 0, 'invalid balance proof'\n          idx = 32\n          s = entryHash\n          t = 0\n          while idx <= proof.length:\n              _87 = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              if s < mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]:\n                  _88 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _87\n                  _89 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _93 = mem[_89]\n                  t = _89 + 32\n                  u = mem[64] + 32\n                  s = mem[_89]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[mem[64] + floor32(mem[_89]) + 32] = mem[_89 + floor32(mem[_89]) + -(mem[_89] % 32) + 64 len mem[_89] % 32] or Mask(8 * -(mem[_89] % 32) + 32, -(8 * -(mem[_89] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_89]) + 32])\n                  _149 = mem[64]\n                  mem[mem[64]] = _93 + _88 + -mem[64] + 96\n                  mem[64] = _93 + _88 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_149 + 32 len mem[_149]])\n                  t = _87\n                  continue \n              _90 = mem[64]\n              mem[mem[64] + 32] = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              mem[mem[64] + 64] = s\n              _91 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _95 = mem[_91]\n              t = _91 + 32\n              u = mem[64] + 32\n              s = mem[_91]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_91]) + 32] = mem[_91 + floor32(mem[_91]) + -(mem[_91] % 32) + 64 len mem[_91] % 32] or Mask(8 * -(mem[_91] % 32) + 32, -(8 * -(mem[_91] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_91]) + 32])\n              _155 = mem[64]\n              mem[mem[64]] = _95 + _90 + -mem[64] + 96\n              mem[64] = _95 + _90 + 128\n              idx = idx + 32\n              s = sha3(mem[_155 + 32 len mem[_155]])\n              t = _87\n              continue \n          if root != s:\n              revert with 0, 'invalid balance proof'\n          uint8(stor11[entryHash].field_0) = 0\n          uint256(stor11[entryHash].field_256) = 0\n          uint256(stor11[entryHash].field_512) = 0\n          uint256(stor11[entryHash].field_768) = 0\n          address(stor11[entryHash].field_1024) = 0\n          address(stor11[entryHash].field_1280) = 0\n          uint256(stor11[entryHash].field_1536) = 0\n          uint256(stor11[entryHash].field_1792) = 0\n          uint256(stor11[entryHash].field_2048) = 0\n          uint256(stor11[entryHash].field_2304) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2304) > idx:\n              uint256(stor11[entryHash][idx + 9].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2560) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2560) > idx:\n              uint256(stor11[entryHash][idx + 10].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2816) = 0\n          uint256(stor11[entryHash].field_3072) = 0\n          _360 = mem[896]\n          if stor12[mem[mem[896] + 140 len 20]][address(mem[mem[896] + 160])]:\n              revert with 0, 'previously exited'\n          stor12[mem[mem[896] + 140 len 20]][mem[mem[896] + 172 len 20]] = 1\n          _401 = mem[mem[896] + 224]\n          _402 = mem[mem[896] + 160]\n          if not mem[mem[896] + 172 len 20]:\n              call mem[mem[896] + 140 len 20] with:\n                 value mem[mem[896] + 224] wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with 0, 'failed to transfer ether'\n              _411 = mem[mem[896] + 160]\n              _412 = mem[mem[896] + 128]\n              mem[mem[64]] = mem[mem[896] + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_412),\n                    uint256 quantity=address(_411))\n          else:\n              mem[mem[64] + 4] = mem[mem[896] + 140 len 20]\n              mem[mem[64] + 36] = _401\n              require ext_code.size(address(_402))\n              call address(_402).transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args mem[mem[64] + 4], _401\n              mem[mem[64]] = ext_call.return_data[0]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if not ext_call.return_data[0]:\n                  revert with 0, 'failed to transfer token'\n              _422 = mem[_360 + 160]\n              _423 = mem[_360 + 128]\n              mem[mem[64]] = mem[_360 + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_423),\n                    uint256 quantity=address(_422))\n      else:\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + 1408] = uint256(stor11[entryHash][10].field_0)\n          idx = (32 * uint256(stor11[entryHash].field_2304)) + 1408\n          s = 0\n          while (32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1376 > idx:\n              mem[idx + 32] = uint256(stor11[entryHash][s + 10].field_256)\n              idx = idx + 32\n              s = s + 1\n              continue \n          mem[1280] = (32 * uint256(stor11[entryHash].field_2304)) + 1376\n          mem[1312] = uint256(stor11[entryHash].field_2816)\n          mem[896] = 960\n          mem[928] = uint256(stor11[entryHash].field_3072)\n          if not uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          if currentGblockNumber < uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          mem[64] = (32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + ceil32(proof.length) + 1440\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1408] = proof.length\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1440 len proof.length] = proof[all]\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + proof.length + 1440] = 0\n          mem[0] = currentGblockNumber\n          mem[32] = 14\n          if root != uint256(gblocksByNumber[stor13].field_768):\n              revert with 0, 'invalid balance proof'\n          if proof.length % 32:\n              revert with 0, 'invalid balance proof'\n          idx = 32\n          s = entryHash\n          t = 0\n          while idx <= proof.length:\n              _342 = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              if s >= mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]:\n                  _346 = mem[64]\n                  mem[mem[64] + 32] = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n                  mem[mem[64] + 64] = s\n                  _347 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _355 = mem[_347]\n                  t = _347 + 32\n                  u = _346 + 128\n                  s = mem[_347]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[_346 + floor32(mem[_347]) + 128] = mem[_347 + -(mem[_347] % 32) + floor32(mem[_347]) + 64 len mem[_347] % 32] or Mask(8 * -(mem[_347] % 32) + 32, -(8 * -(mem[_347] % 32) + 32) + 256, mem[_346 + floor32(mem[_347]) + 128])\n                  mem[_346 + 96] = _355\n                  mem[64] = _355 + _346 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_346 + 128 len _355])\n                  t = _342\n                  continue \n              _344 = mem[64]\n              mem[mem[64] + 32] = s\n              mem[mem[64] + 64] = _342\n              _345 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _353 = mem[_345]\n              t = _345 + 32\n              u = mem[64] + 32\n              s = mem[_345]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_345]) + 32] = mem[_345 + floor32(mem[_345]) + -(mem[_345] % 32) + 64 len mem[_345] % 32] or Mask(8 * -(mem[_345] % 32) + 32, -(8 * -(mem[_345] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_345]) + 32])\n              _495 = mem[64]\n              mem[mem[64]] = _353 + _344 + -mem[64] + 96\n              mem[64] = _353 + _344 + 128\n              idx = idx + 32\n              s = sha3(mem[_495 + 32 len mem[_495]])\n              t = _342\n              continue \n          if root != s:\n              revert with 0, 'invalid balance proof'\n          uint8(stor11[entryHash].field_0) = 0\n          uint256(stor11[entryHash].field_256) = 0\n          uint256(stor11[entryHash].field_512) = 0\n          uint256(stor11[entryHash].field_768) = 0\n          address(stor11[entryHash].field_1024) = 0\n          address(stor11[entryHash].field_1280) = 0\n          uint256(stor11[entryHash].field_1536) = 0\n          uint256(stor11[entryHash].field_1792) = 0\n          uint256(stor11[entryHash].field_2048) = 0\n          uint256(stor11[entryHash].field_2304) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2304) > idx:\n              uint256(stor11[entryHash][idx + 9].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2560) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2560) > idx:\n              uint256(stor11[entryHash][idx + 10].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2816) = 0\n          uint256(stor11[entryHash].field_3072) = 0\n          _668 = mem[896]\n          if stor12[mem[mem[896] + 140 len 20]][address(mem[mem[896] + 160])]:\n              revert with 0, 'previously exited'\n          stor12[mem[mem[896] + 140 len 20]][mem[mem[896] + 172 len 20]] = 1\n          _698 = mem[mem[896] + 224]\n          _699 = mem[mem[896] + 160]\n          if not mem[mem[896] + 172 len 20]:\n              call mem[mem[896] + 140 len 20] with:\n                 value mem[mem[896] + 224] wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with 0, 'failed to transfer ether'\n              _722 = mem[mem[896] + 160]\n              _723 = mem[mem[896] + 128]\n              mem[mem[64]] = mem[mem[896] + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_723),\n                    uint256 quantity=address(_722))\n          else:\n              mem[mem[64] + 4] = mem[mem[896] + 140 len 20]\n              mem[mem[64] + 36] = _698\n              require ext_code.size(address(_699))\n              call address(_699).transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args mem[mem[64] + 4], _698\n              mem[mem[64]] = ext_call.return_data[0]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if not ext_call.return_data[0]:\n                  revert with 0, 'failed to transfer token'\n              _741 = mem[_668 + 160]\n              _742 = mem[_668 + 128]\n              mem[mem[64]] = mem[_668 + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_742),\n                    uint256 quantity=address(_741))\n  else:\n      mem[1376] = address(stor11[entryHash][9].field_0)\n      idx = 1376\n      s = 0\n      while (32 * uint256(stor11[entryHash].field_2304)) + 1344 > idx:\n          mem[idx + 32] = address(stor11[entryHash][s + 9].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n      mem[1248] = 1344\n      mem[(32 * uint256(stor11[entryHash].field_2304)) + 1376] = uint256(stor11[entryHash].field_2560)\n      if not uint256(stor11[entryHash].field_2560):\n          mem[1280] = (32 * uint256(stor11[entryHash].field_2304)) + 1376\n          mem[1312] = uint256(stor11[entryHash].field_2816)\n          mem[896] = 960\n          mem[928] = uint256(stor11[entryHash].field_3072)\n          if not uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          if currentGblockNumber < uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          mem[64] = (32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + ceil32(proof.length) + 1440\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1408] = proof.length\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1440 len proof.length] = proof[all]\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + proof.length + 1440] = 0\n          mem[0] = currentGblockNumber\n          mem[32] = 14\n          if root != uint256(gblocksByNumber[stor13].field_768):\n              revert with 0, 'invalid balance proof'\n          if proof.length % 32:\n              revert with 0, 'invalid balance proof'\n          idx = 32\n          s = entryHash\n          t = 0\n          while idx <= proof.length:\n              _343 = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              if s < mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]:\n                  _348 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _343\n                  _349 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _357 = mem[_349]\n                  t = _349 + 32\n                  u = mem[64] + 32\n                  s = mem[_349]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[mem[64] + floor32(mem[_349]) + 32] = mem[_349 + floor32(mem[_349]) + -(mem[_349] % 32) + 64 len mem[_349] % 32] or Mask(8 * -(mem[_349] % 32) + 32, -(8 * -(mem[_349] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_349]) + 32])\n                  _507 = mem[64]\n                  mem[mem[64]] = _357 + _348 + -mem[64] + 96\n                  mem[64] = _357 + _348 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_507 + 32 len mem[_507]])\n                  t = _343\n                  continue \n              _350 = mem[64]\n              mem[mem[64] + 32] = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              mem[mem[64] + 64] = s\n              _351 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _359 = mem[_351]\n              t = _351 + 32\n              u = mem[64] + 32\n              s = mem[_351]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_351]) + 32] = mem[_351 + floor32(mem[_351]) + -(mem[_351] % 32) + 64 len mem[_351] % 32] or Mask(8 * -(mem[_351] % 32) + 32, -(8 * -(mem[_351] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_351]) + 32])\n              _513 = mem[64]\n              mem[mem[64]] = _359 + _350 + -mem[64] + 96\n              mem[64] = _359 + _350 + 128\n              idx = idx + 32\n              s = sha3(mem[_513 + 32 len mem[_513]])\n              t = _343\n              continue \n          if root != s:\n              revert with 0, 'invalid balance proof'\n          uint8(stor11[entryHash].field_0) = 0\n          uint256(stor11[entryHash].field_256) = 0\n          uint256(stor11[entryHash].field_512) = 0\n          uint256(stor11[entryHash].field_768) = 0\n          address(stor11[entryHash].field_1024) = 0\n          address(stor11[entryHash].field_1280) = 0\n          uint256(stor11[entryHash].field_1536) = 0\n          uint256(stor11[entryHash].field_1792) = 0\n          uint256(stor11[entryHash].field_2048) = 0\n          uint256(stor11[entryHash].field_2304) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2304) > idx:\n              uint256(stor11[entryHash][idx + 9].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2560) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2560) > idx:\n              uint256(stor11[entryHash][idx + 10].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2816) = 0\n          uint256(stor11[entryHash].field_3072) = 0\n          _669 = mem[896]\n          if stor12[mem[mem[896] + 140 len 20]][address(mem[mem[896] + 160])]:\n              revert with 0, 'previously exited'\n          stor12[mem[mem[896] + 140 len 20]][mem[mem[896] + 172 len 20]] = 1\n          _707 = mem[mem[896] + 224]\n          _708 = mem[mem[896] + 160]\n          if not mem[mem[896] + 172 len 20]:\n              call mem[mem[896] + 140 len 20] with:\n                 value mem[mem[896] + 224] wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with 0, 'failed to transfer ether'\n              _728 = mem[mem[896] + 160]\n              _729 = mem[mem[896] + 128]\n              mem[mem[64]] = mem[mem[896] + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_729),\n                    uint256 quantity=address(_728))\n          else:\n              mem[mem[64] + 4] = mem[mem[896] + 140 len 20]\n              mem[mem[64] + 36] = _707\n              require ext_code.size(address(_708))\n              call address(_708).transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args mem[mem[64] + 4], _707\n              mem[mem[64]] = ext_call.return_data[0]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if not ext_call.return_data[0]:\n                  revert with 0, 'failed to transfer token'\n              _746 = mem[_669 + 160]\n              _747 = mem[_669 + 128]\n              mem[mem[64]] = mem[_669 + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_747),\n                    uint256 quantity=address(_746))\n      else:\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + 1408] = uint256(stor11[entryHash][10].field_0)\n          idx = (32 * uint256(stor11[entryHash].field_2304)) + 1408\n          s = 0\n          while (32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1376 > idx:\n              mem[idx + 32] = uint256(stor11[entryHash][s + 10].field_256)\n              idx = idx + 32\n              s = s + 1\n              continue \n          mem[1280] = (32 * uint256(stor11[entryHash].field_2304)) + 1376\n          mem[1312] = uint256(stor11[entryHash].field_2816)\n          mem[896] = 960\n          mem[928] = uint256(stor11[entryHash].field_3072)\n          if not uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          if currentGblockNumber < uint256(stor11[entryHash].field_3072):\n              revert with 0, \n                          32,\n                          68,\n                          0xfe6e6f207072696f7220636c61696d20666f756e6420746f207769746864726177204f522062616c616e636573206172652079657420746f20626520636f6e6669726d65,\n                          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1544 len 28]\n          mem[64] = (32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + ceil32(proof.length) + 1440\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1408] = proof.length\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + 1440 len proof.length] = proof[all]\n          mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + proof.length + 1440] = 0\n          mem[0] = currentGblockNumber\n          mem[32] = 14\n          if root != uint256(gblocksByNumber[stor13].field_768):\n              revert with 0, 'invalid balance proof'\n          if proof.length % 32:\n              revert with 0, 'invalid balance proof'\n          idx = 32\n          s = entryHash\n          t = 0\n          while idx <= proof.length:\n              _659 = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              if s < mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]:\n                  _660 = mem[64]\n                  mem[mem[64] + 32] = s\n                  mem[mem[64] + 64] = _659\n                  _661 = mem[64]\n                  mem[mem[64]] = 64\n                  mem[64] = mem[64] + 96\n                  _665 = mem[_661]\n                  t = _661 + 32\n                  u = mem[64] + 32\n                  s = mem[_661]\n                  while s >= 32:\n                      mem[u] = mem[t]\n                      t = t + 32\n                      u = u + 32\n                      s = s - 32\n                      continue \n                  mem[mem[64] + floor32(mem[_661]) + 32] = mem[_661 + floor32(mem[_661]) + -(mem[_661] % 32) + 64 len mem[_661] % 32] or Mask(8 * -(mem[_661] % 32) + 32, -(8 * -(mem[_661] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_661]) + 32])\n                  _786 = mem[64]\n                  mem[mem[64]] = _665 + _660 + -mem[64] + 96\n                  mem[64] = _665 + _660 + 128\n                  idx = idx + 32\n                  s = sha3(mem[_786 + 32 len mem[_786]])\n                  t = _659\n                  continue \n              _662 = mem[64]\n              mem[mem[64] + 32] = mem[(32 * uint256(stor11[entryHash].field_2304)) + (32 * uint256(stor11[entryHash].field_2560)) + idx + 1408]\n              mem[mem[64] + 64] = s\n              _663 = mem[64]\n              mem[mem[64]] = 64\n              mem[64] = mem[64] + 96\n              _667 = mem[_663]\n              t = _663 + 32\n              u = mem[64] + 32\n              s = mem[_663]\n              while s >= 32:\n                  mem[u] = mem[t]\n                  t = t + 32\n                  u = u + 32\n                  s = s - 32\n                  continue \n              mem[mem[64] + floor32(mem[_663]) + 32] = mem[_663 + floor32(mem[_663]) + -(mem[_663] % 32) + 64 len mem[_663] % 32] or Mask(8 * -(mem[_663] % 32) + 32, -(8 * -(mem[_663] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_663]) + 32])\n              _792 = mem[64]\n              mem[mem[64]] = _667 + _662 + -mem[64] + 96\n              mem[64] = _667 + _662 + 128\n              idx = idx + 32\n              s = sha3(mem[_792 + 32 len mem[_792]])\n              t = _659\n              continue \n          if root != s:\n              revert with 0, 'invalid balance proof'\n          uint8(stor11[entryHash].field_0) = 0\n          uint256(stor11[entryHash].field_256) = 0\n          uint256(stor11[entryHash].field_512) = 0\n          uint256(stor11[entryHash].field_768) = 0\n          address(stor11[entryHash].field_1024) = 0\n          address(stor11[entryHash].field_1280) = 0\n          uint256(stor11[entryHash].field_1536) = 0\n          uint256(stor11[entryHash].field_1792) = 0\n          uint256(stor11[entryHash].field_2048) = 0\n          uint256(stor11[entryHash].field_2304) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2304) > idx:\n              uint256(stor11[entryHash][idx + 9].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2560) = 0\n          idx = 0\n          while uint256(stor11[entryHash].field_2560) > idx:\n              uint256(stor11[entryHash][idx + 10].field_0) = 0\n              idx = idx + 1\n              continue \n          uint256(stor11[entryHash].field_2816) = 0\n          uint256(stor11[entryHash].field_3072) = 0\n          _830 = mem[896]\n          if stor12[mem[mem[896] + 140 len 20]][address(mem[mem[896] + 160])]:\n              revert with 0, 'previously exited'\n          stor12[mem[mem[896] + 140 len 20]][mem[mem[896] + 172 len 20]] = 1\n          _839 = mem[mem[896] + 224]\n          _840 = mem[mem[896] + 160]\n          if not mem[mem[896] + 172 len 20]:\n              call mem[mem[896] + 140 len 20] with:\n                 value mem[mem[896] + 224] wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with 0, 'failed to transfer ether'\n              _849 = mem[mem[896] + 160]\n              _850 = mem[mem[896] + 128]\n              mem[mem[64]] = mem[mem[896] + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_850),\n                    uint256 quantity=address(_849))\n          else:\n              mem[mem[64] + 4] = mem[mem[896] + 140 len 20]\n              mem[mem[64] + 36] = _839\n              require ext_code.size(address(_840))\n              call address(_840).transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args mem[mem[64] + 4], _839\n              mem[mem[64]] = ext_call.return_data[0]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if not ext_call.return_data[0]:\n                  revert with 0, 'failed to transfer token'\n              _858 = mem[_830 + 160]\n              _859 = mem[_830 + 128]\n              mem[mem[64]] = mem[_830 + 224]\n              log Exited(\n                    address account=mem[mem[64]],\n                    address asset=address(_859),\n                    uint256 quantity=address(_858))\n\ndef claimExit(address[] addresses, uint256[] uints, bytes signature, bytes proof, bytes32 root): # not payable\n  require calldata.size - 4 >= 160\n  require addresses <= unknown10000000()\n  require addresses + 36 <= calldata.size\n  require addresses.length <= unknown10000000() and addresses + (32 * addresses.length) + 36 <= calldata.size\n  require uints <= unknown10000000()\n  require uints + 36 <= calldata.size\n  require uints.length <= unknown10000000() and uints + (32 * uints.length) + 36 <= calldata.size\n  require signature <= unknown10000000()\n  require signature + 36 <= calldata.size\n  require signature.length <= unknown10000000() and signature + signature.length + 36 <= calldata.size\n  require proof <= unknown10000000()\n  require proof + 36 <= calldata.size\n  require proof.length <= unknown10000000() and proof + proof.length + 36 <= calldata.size\n  if not stor0:\n      revert with 0, 'smust be on'\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = 0\n  mem[192] = 0\n  mem[224] = 0\n  mem[256] = 0\n  mem[288] = 0\n  mem[320] = 0\n  mem[352] = 0\n  mem[384] = 96\n  mem[416] = 96\n  mem[448] = 0\n  mem[480] = addresses.length\n  mem[512 len 32 * addresses.length] = call.data[addresses + 36 len 32 * addresses.length]\n  mem[(32 * addresses.length) + 512] = uints.length\n  mem[(32 * addresses.length) + 544 len 32 * uints.length] = call.data[uints + 36 len 32 * uints.length]\n  mem[(32 * uints.length) + (32 * addresses.length) + 544] = 0\n  mem[(32 * uints.length) + (32 * addresses.length) + 576] = 0\n  mem[(32 * uints.length) + (32 * addresses.length) + 608] = 0\n  mem[(32 * uints.length) + (32 * addresses.length) + 640] = 0\n  mem[(32 * uints.length) + (32 * addresses.length) + 896] = 0\n  require 0 < addresses.length\n  mem[512] = this.address\n  require 1 < addresses.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 672] = mem[556 len 20]\n  require 2 < addresses.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 704] = mem[588 len 20]\n  require 0 < uints.length\n  require mem[(32 * addresses.length) + 544] <= 6\n  mem[(32 * uints.length) + (32 * addresses.length) + 544] = mem[(32 * addresses.length) + 544]\n  require 1 < uints.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 576] = mem[(32 * addresses.length) + 576]\n  require 2 < uints.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 608] = mem[(32 * addresses.length) + 608]\n  require 3 < uints.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 640] = mem[(32 * addresses.length) + 640]\n  require 4 < uints.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 736] = mem[(32 * addresses.length) + 672]\n  require 5 < uints.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 768] = mem[(32 * addresses.length) + 704]\n  require 6 < uints.length\n  mem[(32 * uints.length) + (32 * addresses.length) + 800] = mem[(32 * addresses.length) + 736]\n  mem[(32 * uints.length) + (32 * addresses.length) + 832] = 480\n  mem[(32 * uints.length) + (32 * addresses.length) + 864] = (32 * addresses.length) + 512\n  _28 = mem[(32 * uints.length) + (32 * addresses.length) + 544]\n  require 0 < addresses.length\n  require 1 < addresses.length\n  require 2 < addresses.length\n  _34 = mem[576]\n  require 0 < uints.length\n  _36 = mem[(32 * addresses.length) + 544]\n  require 1 < uints.length\n  _38 = mem[(32 * addresses.length) + 576]\n  require 2 < uints.length\n  _40 = mem[(32 * addresses.length) + 608]\n  require 3 < uints.length\n  _42 = mem[(32 * addresses.length) + 640]\n  require 4 < uints.length\n  _44 = mem[(32 * addresses.length) + 672]\n  require 5 < uints.length\n  _46 = mem[(32 * addresses.length) + 704]\n  require 6 < uints.length\n  _48 = mem[(32 * addresses.length) + 736]\n  mem[(32 * uints.length) + (32 * addresses.length) + 960] = address(this.address)\n  mem[(32 * uints.length) + (32 * addresses.length) + 980] = address(mem[544])\n  mem[(32 * uints.length) + (32 * addresses.length) + 1000] = address(_34)\n  mem[(32 * uints.length) + (32 * addresses.length) + 1020] = _36\n  mem[(32 * uints.length) + (32 * addresses.length) + 1052] = _38\n  mem[(32 * uints.length) + (32 * addresses.length) + 1084] = _40\n  mem[(32 * uints.length) + (32 * addresses.length) + 1116] = _42\n  mem[(32 * uints.length) + (32 * addresses.length) + 1148] = _44\n  mem[(32 * uints.length) + (32 * addresses.length) + 1180] = _46\n  mem[(32 * uints.length) + (32 * addresses.length) + 1212] = _48\n  mem[(32 * uints.length) + (32 * addresses.length) + 928] = 284\n  _52 = sha3(this.address, mem[556 len 20], address(_34), _36, _38, _40, _42, _44, _46, _48)\n  require _28 <= 6\n  if _28 == 2:\n      require uint8(stor4.field_8) < uints.length\n      require uint8(uint8(stor4.field_8) + 1) < uints.length\n      mem[(32 * uints.length) + (32 * addresses.length) + 1276] = mem[(32 * addresses.length) + (32 * uint8(stor4.field_8)) + 544]\n      mem[(32 * uints.length) + (32 * addresses.length) + 1308] = mem[(32 * uint8(uint8(stor4.field_8) + 1)) + (32 * addresses.length) + 544]\n      mem[(32 * uints.length) + (32 * addresses.length) + 1244] = 64\n      _61 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1276], mem[(32 * uint8(uint8(stor4.field_8) + 1)) + (32 * addresses.length) + 544])\n      mem[(32 * uints.length) + (32 * addresses.length) + 1372] = _52\n      mem[(32 * uints.length) + (32 * addresses.length) + 1404] = _61\n      mem[(32 * uints.length) + (32 * addresses.length) + 1340] = 64\n      _71 = 64\n      mem[(32 * uints.length) + (32 * addresses.length) + 1468 len 64] = _52, _61\n      var60001 = (32 * uints.length) + (32 * addresses.length) + 1436\n      var60002 = (32 * uints.length) + (32 * addresses.length) + 1532\n      var60003 = 0\n      mem[(32 * uints.length) + (32 * addresses.length) + 1532] = None or mem[(32 * uints.length) + (32 * addresses.length) + 1532]\n      _2429 = (32 * uints.length) + (32 * addresses.length) + 1436\n      mem[(32 * uints.length) + (32 * addresses.length) + 1436] = _71\n      mem[64] = _71 + (32 * uints.length) + (32 * addresses.length) + 1468\n      mem[(32 * uints.length) + (32 * addresses.length) + 896] = sha3(mem[_2429 + 32 len mem[_2429]])\n      _2443 = mem[(32 * uints.length) + (32 * addresses.length) + 896]\n      _2444 = _71 + (32 * uints.length) + (32 * addresses.length) + 1468\n      mem[_71 + (32 * uints.length) + (32 * addresses.length) + 1500 len signature.length] = signature[all]\n      mem[_71 + (32 * uints.length) + (32 * addresses.length) + signature.length + 1500] = 0\n      if signature.length != 65:\n          if operatorAddress:\n              _2479 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n              revert with 0, 'failed to verify signature'\n          if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n              _2523 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n              revert with 0, 'claimant must be entry's account'\n          _2522 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n          _2541 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n          if uint8(stor[_2541][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n              _2604 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n              revert with 0, 'previously exited'\n          _2602 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n          if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n              _2758 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1532\n          else:\n              if not proof.length % 32:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              _2970 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1532\n      else:\n          _2466 = mem[_71 + (32 * uints.length) + (32 * addresses.length) + 1500]\n          _2467 = mem[_71 + (32 * uints.length) + (32 * addresses.length) + 1532]\n          _2468 = mem[_71 + (32 * uints.length) + (32 * addresses.length) + 1564]\n          if 27 == uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 1564, ('var', '_71'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 1564, ('var', '_71'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) - 256) + 27):\n              _2490 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n              signer = erecover(_2443, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2468')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2468')), 0) - 256) + 27 << 248, _2466, _2467) # precompiled\n              if not erecover.result:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if address(signer) != operatorAddress:\n                  _2566 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                  revert with 0, 'failed to verify signature'\n              if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                  _2638 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                  revert with 0, 'claimant must be entry's account'\n              _2637 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n              _2674 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n              if uint8(stor[_2674][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                  _2752 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                  revert with 0, 'previously exited'\n              _2750 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n              if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                  _2873 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1564\n              else:\n                  if not proof.length % 32:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  _3352 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1564\n          else:\n              if uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 1564, ('var', '_71'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 1564, ('var', '_71'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) - 256) + 27) != 28:\n                  if operatorAddress:\n                      _2568 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n                      revert with 0, 'failed to verify signature'\n                  if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                      _2642 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n                      revert with 0, 'claimant must be entry's account'\n                  _2641 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                  _2676 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                  if uint8(stor[_2676][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                      _2756 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n                      revert with 0, 'previously exited'\n                  _2754 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n                  if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                      _2875 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1532\n                  else:\n                      if not proof.length % 32:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      _3354 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1532\n              else:\n                  _2519 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1500\n                  signer = erecover(_2443, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2468')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2468')), 0) - 256) + 27 << 248, _2466, _2467) # precompiled\n                  if not erecover.result:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  if address(signer) != operatorAddress:\n                      _2600 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                      revert with 0, 'failed to verify signature'\n                  if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                      _2680 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                      revert with 0, 'claimant must be entry's account'\n                  _2679 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                  _2696 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                  if uint8(stor[_2696][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                      _2787 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                      revert with 0, 'previously exited'\n                  _2785 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1532\n                  if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                      _2932 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1564\n                  else:\n                      if not proof.length % 32:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      _3438 = _71 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1564\n  else:\n      require _28 <= 6\n      if _28 == 3:\n          require uint8(stor3.field_8) < addresses.length\n          require uint8(uint8(stor3.field_8) + 1) < addresses.length\n          require uint8(stor4.field_8) < uints.length\n          _66 = mem[(32 * addresses.length) + (32 * uint8(stor4.field_8)) + 544]\n          require uint8(uint8(stor4.field_8) + 1) < uints.length\n          _77 = mem[(32 * uint8(uint8(stor4.field_8) + 1)) + (32 * addresses.length) + 544]\n          mem[(32 * uints.length) + (32 * addresses.length) + 1276] = address(mem[(32 * uint8(stor3.field_8)) + 512])\n          mem[(32 * uints.length) + (32 * addresses.length) + 1296] = address(mem[(32 * uint8(uint8(stor3.field_8) + 1)) + 512])\n          mem[(32 * uints.length) + (32 * addresses.length) + 1316] = _66\n          mem[(32 * uints.length) + (32 * addresses.length) + 1348] = _77\n          mem[(32 * uints.length) + (32 * addresses.length) + 1244] = 104\n          _81 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1276 len 20], mem[(32 * uint8(uint8(stor3.field_8) + 1)) + 524 len 20], _66, _77)\n          mem[(32 * uints.length) + (32 * addresses.length) + 1412] = _52\n          mem[(32 * uints.length) + (32 * addresses.length) + 1444] = _81\n          mem[(32 * uints.length) + (32 * addresses.length) + 1380] = 64\n          _110 = 64\n          mem[(32 * uints.length) + (32 * addresses.length) + 1508 len 64] = _52, _81\n          var64001 = (32 * uints.length) + (32 * addresses.length) + 1476\n          var64002 = (32 * uints.length) + (32 * addresses.length) + 1572\n          var64003 = 0\n          mem[(32 * uints.length) + (32 * addresses.length) + 1604 len 0] = None\n          _2423 = (32 * uints.length) + (32 * addresses.length) + 1476\n          mem[(32 * uints.length) + (32 * addresses.length) + 1476] = 64\n          mem[(32 * uints.length) + (32 * addresses.length) + 896] = sha3(_52, _81)\n          _2441 = sha3(_52, _81)\n          _2442 = (32 * uints.length) + (32 * addresses.length) + 1572\n          mem[64] = (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1604\n          mem[(32 * uints.length) + (32 * addresses.length) + 1572] = signature.length\n          mem[_2442 + 32 len signature.length] = signature[all]\n          mem[_2442 + signature.length + 32] = 0\n          if signature.length != 65:\n              if operatorAddress:\n                  _2477 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                  revert with 0, 'failed to verify signature'\n              if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                  _2515 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                  revert with 0, 'claimant must be entry's account'\n              _2514 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n              _2537 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n              if uint8(stor[_2537][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                  _2596 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                  revert with 0, 'previously exited'\n              _2594 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n              if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                  _2748 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1572\n              else:\n                  if not proof.length % 32:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  _2965 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1572\n          else:\n              _2463 = mem[_2442 + 32]\n              _2464 = mem[_2442 + 64]\n              _2465 = mem[_2442 + 96]\n              if 27 == uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2442')), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2442')), 32))), 0) - 256) + 27):\n                  _2487 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                  signer = erecover(_2441, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2465')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2465')), 0) - 256) + 27 << 248, _2463, _2464) # precompiled\n                  if not erecover.result:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  if address(signer) != operatorAddress:\n                      _2562 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                      revert with 0, 'failed to verify signature'\n                  if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                      _2628 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                      revert with 0, 'claimant must be entry's account'\n                  _2627 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                  _2666 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                  if uint8(stor[_2666][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                      _2742 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                      revert with 0, 'previously exited'\n                  _2740 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                  if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                      _2868 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1604\n                  else:\n                      if not proof.length % 32:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      _3336 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1604\n              else:\n                  if uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2442')), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2442')), 32))), 0) - 256) + 27) != 28:\n                      if operatorAddress:\n                          _2564 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                          revert with 0, 'failed to verify signature'\n                      if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                          _2632 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                          revert with 0, 'claimant must be entry's account'\n                      _2631 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                      _2668 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                      if uint8(stor[_2668][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                          _2746 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                          revert with 0, 'previously exited'\n                      _2744 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                      if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                          _2870 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1572\n                      else:\n                          if not proof.length % 32:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          _3338 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1572\n                  else:\n                      _2511 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1540\n                      signer = erecover(_2441, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2465')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2465')), 0) - 256) + 27 << 248, _2463, _2464) # precompiled\n                      if not erecover.result:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      if address(signer) != operatorAddress:\n                          _2592 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                          revert with 0, 'failed to verify signature'\n                      if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                          _2672 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                          revert with 0, 'claimant must be entry's account'\n                      _2671 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                      _2694 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                      if uint8(stor[_2694][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                          _2780 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                          revert with 0, 'previously exited'\n                      _2778 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 1572\n                      if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                          _2916 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1604\n                      else:\n                          if not proof.length % 32:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          _3421 = _110 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 1604\n      else:\n          require _28 <= 6\n          if _28 == 5:\n              require uint8(stor3.field_8) < addresses.length\n              require uint8(stor4.field_8) < uints.length\n              _90 = mem[(32 * uint8(stor4.field_8)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_8) + 1) < uints.length\n              _99 = mem[(32 * uint8(uint8(stor4.field_8) + 1)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_8) + 2) < uints.length\n              _113 = mem[(32 * uint8(uint8(stor4.field_8) + 2)) + (32 * addresses.length) + 544]\n              mem[(32 * uints.length) + (32 * addresses.length) + 1276] = address(mem[(32 * uint8(stor3.field_8)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1296] = _90\n              mem[(32 * uints.length) + (32 * addresses.length) + 1328] = _99\n              mem[(32 * uints.length) + (32 * addresses.length) + 1360] = _113\n              mem[(32 * uints.length) + (32 * addresses.length) + 1244] = 116\n              _117 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1276 len 20], _90, _99, _113)\n              require uint8(stor3.field_16) < addresses.length\n              require uint8(uint8(stor3.field_16) + 1) < addresses.length\n              require uint8(stor4.field_16) < uints.length\n              _153 = mem[(32 * uint8(stor4.field_16)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 1) < uints.length\n              _161 = mem[(32 * uint8(uint8(stor4.field_16) + 1)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 2) < uints.length\n              _174 = mem[(32 * uint8(uint8(stor4.field_16) + 2)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 3) < uints.length\n              _186 = mem[(32 * uint8(uint8(stor4.field_16) + 3)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 4) < uints.length\n              _194 = mem[(32 * uint8(uint8(stor4.field_16) + 4)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 5) < uints.length\n              _202 = mem[(32 * uint8(uint8(stor4.field_16) + 5)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 6) < uints.length\n              _216 = mem[(32 * uint8(uint8(stor4.field_16) + 6)) + (32 * addresses.length) + 544]\n              mem[(32 * uints.length) + (32 * addresses.length) + 1424] = address(mem[(32 * uint8(stor3.field_16)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1444] = address(mem[(32 * uint8(uint8(stor3.field_16) + 1)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1464] = _153\n              mem[(32 * uints.length) + (32 * addresses.length) + 1496] = _161\n              mem[(32 * uints.length) + (32 * addresses.length) + 1528] = _174\n              mem[(32 * uints.length) + (32 * addresses.length) + 1560] = _186\n              mem[(32 * uints.length) + (32 * addresses.length) + 1592] = _194\n              mem[(32 * uints.length) + (32 * addresses.length) + 1624] = _202\n              mem[(32 * uints.length) + (32 * addresses.length) + 1656] = _216\n              mem[(32 * uints.length) + (32 * addresses.length) + 1392] = 264\n              _220 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1424 len 20], mem[(32 * uint8(uint8(stor3.field_16) + 1)) + 524 len 20], _153, _161, _174, _186, _194, _202, _216)\n              require uint8(stor3.field_24) < addresses.length\n              require uint8(uint8(stor3.field_24) + 1) < addresses.length\n              require uint8(stor4.field_24) < uints.length\n              _313 = mem[(32 * uint8(stor4.field_24)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 1) < uints.length\n              _347 = mem[(32 * uint8(uint8(stor4.field_24) + 1)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 2) < uints.length\n              _374 = mem[(32 * uint8(uint8(stor4.field_24) + 2)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 3) < uints.length\n              _384 = mem[(32 * uint8(uint8(stor4.field_24) + 3)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 4) < uints.length\n              _394 = mem[(32 * uint8(uint8(stor4.field_24) + 4)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 5) < uints.length\n              _424 = mem[(32 * uint8(uint8(stor4.field_24) + 5)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 6) < uints.length\n              _447 = mem[(32 * uint8(uint8(stor4.field_24) + 6)) + (32 * addresses.length) + 544]\n              mem[(32 * uints.length) + (32 * addresses.length) + 1720] = address(mem[(32 * uint8(stor3.field_24)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1740] = address(mem[(32 * uint8(uint8(stor3.field_24) + 1)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1760] = _313\n              mem[(32 * uints.length) + (32 * addresses.length) + 1792] = _347\n              mem[(32 * uints.length) + (32 * addresses.length) + 1824] = _374\n              mem[(32 * uints.length) + (32 * addresses.length) + 1856] = _384\n              mem[(32 * uints.length) + (32 * addresses.length) + 1888] = _394\n              mem[(32 * uints.length) + (32 * addresses.length) + 1920] = _424\n              mem[(32 * uints.length) + (32 * addresses.length) + 1952] = _447\n              mem[(32 * uints.length) + (32 * addresses.length) + 1688] = 264\n              _451 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1720 len 20], mem[(32 * uint8(uint8(stor3.field_24) + 1)) + 524 len 20], _313, _347, _374, _384, _394, _424, _447)\n              mem[(32 * uints.length) + (32 * addresses.length) + 2016] = _117\n              mem[(32 * uints.length) + (32 * addresses.length) + 2048] = _220\n              mem[(32 * uints.length) + (32 * addresses.length) + 2080] = _451\n              mem[(32 * uints.length) + (32 * addresses.length) + 1984] = 96\n              _477 = sha3(_117, _220, _451)\n              mem[(32 * uints.length) + (32 * addresses.length) + 2144] = _52\n              mem[(32 * uints.length) + (32 * addresses.length) + 2176] = _477\n              mem[(32 * uints.length) + (32 * addresses.length) + 2112] = 64\n              _565 = 64\n              mem[(32 * uints.length) + (32 * addresses.length) + 2240 len 64] = _52, _477\n              var91001 = (32 * uints.length) + (32 * addresses.length) + 2208\n              var91002 = (32 * uints.length) + (32 * addresses.length) + 2304\n              var91003 = 0\n              mem[(32 * uints.length) + (32 * addresses.length) + 2304] = None or mem[(32 * uints.length) + (32 * addresses.length) + 2304]\n              _2405 = (32 * uints.length) + (32 * addresses.length) + 2208\n              mem[(32 * uints.length) + (32 * addresses.length) + 2208] = _565\n              mem[64] = _565 + (32 * uints.length) + (32 * addresses.length) + 2240\n              mem[(32 * uints.length) + (32 * addresses.length) + 896] = sha3(mem[_2405 + 32 len mem[_2405]])\n              _2437 = mem[(32 * uints.length) + (32 * addresses.length) + 896]\n              _2438 = _565 + (32 * uints.length) + (32 * addresses.length) + 2240\n              mem[_565 + (32 * uints.length) + (32 * addresses.length) + 2272 len signature.length] = signature[all]\n              mem[_565 + (32 * uints.length) + (32 * addresses.length) + signature.length + 2272] = 0\n              if signature.length != 65:\n                  if operatorAddress:\n                      _2470 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      revert with 0, 'failed to verify signature'\n                  if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                      _2499 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      revert with 0, 'claimant must be entry's account'\n                  _2498 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                  _2527 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                  if uint8(stor[_2527][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                      _2576 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      revert with 0, 'previously exited'\n                  _2574 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                  if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                      _2720 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n                  else:\n                      if not proof.length % 32:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      _2949 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n              else:\n                  _2455 = mem[_565 + (32 * uints.length) + (32 * addresses.length) + 2272]\n                  _2456 = mem[_565 + (32 * uints.length) + (32 * addresses.length) + 2304]\n                  _2457 = mem[_565 + (32 * uints.length) + (32 * addresses.length) + 2336]\n                  if 27 == uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 2336, ('var', '_565'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 2336, ('var', '_565'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) - 256) + 27):\n                      _2481 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      signer = erecover(_2437, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2457')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2457')), 0) - 256) + 27 << 248, _2455, _2456) # precompiled\n                      if not erecover.result:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      if address(signer) != operatorAddress:\n                          _2546 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          revert with 0, 'failed to verify signature'\n                      if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                          _2608 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          revert with 0, 'claimant must be entry's account'\n                      _2607 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                      _2646 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                      if uint8(stor[_2646][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                          _2714 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          revert with 0, 'previously exited'\n                      _2712 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                      if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                          _2856 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n                      else:\n                          if not proof.length % 32:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          _3282 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n                  else:\n                      if uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 2336, ('var', '_565'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 2336, ('var', '_565'), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'uints')))), ('mask_shl', 251, 0, 5, ('cd', ('add', 4, ('param', 'addresses'))))), 32))), 0) - 256) + 27) != 28:\n                          if operatorAddress:\n                              _2548 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                              revert with 0, 'failed to verify signature'\n                          if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                              _2612 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                              revert with 0, 'claimant must be entry's account'\n                          _2611 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                          _2648 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                          if uint8(stor[_2648][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                              _2718 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                              revert with 0, 'previously exited'\n                          _2716 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                          if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                              _2858 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n                          else:\n                              if not proof.length % 32:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              _3284 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n                      else:\n                          _2495 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                          signer = erecover(_2437, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2457')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2457')), 0) - 256) + 27 << 248, _2455, _2456) # precompiled\n                          if not erecover.result:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          if address(signer) != operatorAddress:\n                              _2572 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                              revert with 0, 'failed to verify signature'\n                          if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                              _2652 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                              revert with 0, 'claimant must be entry's account'\n                          _2651 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                          _2682 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                          if uint8(stor[_2682][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                              _2764 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                              revert with 0, 'previously exited'\n                          _2762 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                              _2880 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n                          else:\n                              if not proof.length % 32:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              _3382 = _565 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n          else:\n              require _28 <= 6\n              if _28 != 6:\n                  _76 = 32\n                  var61001 = (32 * uints.length) + (32 * addresses.length) + 1308\n                  var61002 = (32 * uints.length) + (32 * addresses.length) + 1372\n                  var61003 = 0\n                  _2411 = (32 * uints.length) + (32 * addresses.length) + 1308\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require uint8(stor3.field_8) < addresses.length\n              require uint8(stor4.field_8) < uints.length\n              _118 = mem[(32 * uint8(stor4.field_8)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_8) + 1) < uints.length\n              _126 = mem[(32 * uint8(uint8(stor4.field_8) + 1)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_8) + 2) < uints.length\n              _136 = mem[(32 * uint8(uint8(stor4.field_8) + 2)) + (32 * addresses.length) + 544]\n              mem[(32 * uints.length) + (32 * addresses.length) + 1276] = address(mem[(32 * uint8(stor3.field_8)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1296] = _118\n              mem[(32 * uints.length) + (32 * addresses.length) + 1328] = _126\n              mem[(32 * uints.length) + (32 * addresses.length) + 1360] = _136\n              mem[(32 * uints.length) + (32 * addresses.length) + 1244] = 116\n              _140 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1276 len 20], _118, _126, _136)\n              require uint8(stor3.field_16) < addresses.length\n              require uint8(uint8(stor3.field_16) + 1) < addresses.length\n              require uint8(stor4.field_16) < uints.length\n              _176 = mem[(32 * uint8(stor4.field_16)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 1) < uints.length\n              _188 = mem[(32 * uint8(uint8(stor4.field_16) + 1)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 2) < uints.length\n              _198 = mem[(32 * uint8(uint8(stor4.field_16) + 2)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 3) < uints.length\n              _207 = mem[(32 * uint8(uint8(stor4.field_16) + 3)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 4) < uints.length\n              _229 = mem[(32 * uint8(uint8(stor4.field_16) + 4)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 5) < uints.length\n              _251 = mem[(32 * uint8(uint8(stor4.field_16) + 5)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_16) + 6) < uints.length\n              _268 = mem[(32 * uint8(uint8(stor4.field_16) + 6)) + (32 * addresses.length) + 544]\n              mem[(32 * uints.length) + (32 * addresses.length) + 1424] = address(mem[(32 * uint8(stor3.field_16)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1444] = address(mem[(32 * uint8(uint8(stor3.field_16) + 1)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1464] = _176\n              mem[(32 * uints.length) + (32 * addresses.length) + 1496] = _188\n              mem[(32 * uints.length) + (32 * addresses.length) + 1528] = _198\n              mem[(32 * uints.length) + (32 * addresses.length) + 1560] = _207\n              mem[(32 * uints.length) + (32 * addresses.length) + 1592] = _229\n              mem[(32 * uints.length) + (32 * addresses.length) + 1624] = _251\n              mem[(32 * uints.length) + (32 * addresses.length) + 1656] = _268\n              mem[(32 * uints.length) + (32 * addresses.length) + 1392] = 264\n              _272 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1424 len 20], mem[(32 * uint8(uint8(stor3.field_16) + 1)) + 524 len 20], _176, _188, _198, _207, _229, _251, _268)\n              require uint8(stor3.field_24) < addresses.length\n              require uint8(uint8(stor3.field_24) + 1) < addresses.length\n              require uint8(stor4.field_24) < uints.length\n              _378 = mem[(32 * uint8(stor4.field_24)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 1) < uints.length\n              _387 = mem[(32 * uint8(uint8(stor4.field_24) + 1)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 2) < uints.length\n              _406 = mem[(32 * uint8(uint8(stor4.field_24) + 2)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 3) < uints.length\n              _433 = mem[(32 * uint8(uint8(stor4.field_24) + 3)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 4) < uints.length\n              _454 = mem[(32 * uint8(uint8(stor4.field_24) + 4)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 5) < uints.length\n              _482 = mem[(32 * uint8(uint8(stor4.field_24) + 5)) + (32 * addresses.length) + 544]\n              require uint8(uint8(stor4.field_24) + 6) < uints.length\n              _499 = mem[(32 * uint8(uint8(stor4.field_24) + 6)) + (32 * addresses.length) + 544]\n              mem[(32 * uints.length) + (32 * addresses.length) + 1720] = address(mem[(32 * uint8(stor3.field_24)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1740] = address(mem[(32 * uint8(uint8(stor3.field_24) + 1)) + 512])\n              mem[(32 * uints.length) + (32 * addresses.length) + 1760] = _378\n              mem[(32 * uints.length) + (32 * addresses.length) + 1792] = _387\n              mem[(32 * uints.length) + (32 * addresses.length) + 1824] = _406\n              mem[(32 * uints.length) + (32 * addresses.length) + 1856] = _433\n              mem[(32 * uints.length) + (32 * addresses.length) + 1888] = _454\n              mem[(32 * uints.length) + (32 * addresses.length) + 1920] = _482\n              mem[(32 * uints.length) + (32 * addresses.length) + 1952] = _499\n              mem[(32 * uints.length) + (32 * addresses.length) + 1688] = 264\n              _503 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 1720 len 20], mem[(32 * uint8(uint8(stor3.field_24) + 1)) + 524 len 20], _378, _387, _406, _433, _454, _482, _499)\n              mem[(32 * uints.length) + (32 * addresses.length) + 2016] = _140\n              mem[(32 * uints.length) + (32 * addresses.length) + 2048] = _272\n              mem[(32 * uints.length) + (32 * addresses.length) + 2080] = _503\n              mem[(32 * uints.length) + (32 * addresses.length) + 1984] = 96\n              _534 = sha3(_140, _272, _503)\n              mem[(32 * uints.length) + (32 * addresses.length) + 2144] = _52\n              mem[(32 * uints.length) + (32 * addresses.length) + 2176] = _534\n              mem[(32 * uints.length) + (32 * addresses.length) + 2112] = 64\n              _662 = 64\n              mem[(32 * uints.length) + (32 * addresses.length) + 2240 len 64] = _52, _534\n              var93001 = (32 * uints.length) + (32 * addresses.length) + 2208\n              var93002 = (32 * uints.length) + (32 * addresses.length) + 2304\n              var93003 = 0\n              mem[(32 * uints.length) + (32 * addresses.length) + 2336 len 0] = None\n              _2417 = (32 * uints.length) + (32 * addresses.length) + 2208\n              mem[(32 * uints.length) + (32 * addresses.length) + 2208] = 64\n              mem[(32 * uints.length) + (32 * addresses.length) + 896] = sha3(_52, _534)\n              _2439 = sha3(_52, _534)\n              _2440 = (32 * uints.length) + (32 * addresses.length) + 2304\n              mem[64] = (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2336\n              mem[(32 * uints.length) + (32 * addresses.length) + 2304] = signature.length\n              mem[_2440 + 32 len signature.length] = signature[all]\n              mem[_2440 + signature.length + 32] = 0\n              if signature.length != 65:\n                  if operatorAddress:\n                      _2475 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      revert with 0, 'failed to verify signature'\n                  if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                      _2507 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      revert with 0, 'claimant must be entry's account'\n                  _2506 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                  _2533 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                  if uint8(stor[_2533][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                      _2588 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      revert with 0, 'previously exited'\n                  _2586 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                  if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                      _2738 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n                  else:\n                      if not proof.length % 32:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      _2960 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n              else:\n                  _2460 = mem[_2440 + 32]\n                  _2461 = mem[_2440 + 64]\n                  _2462 = mem[_2440 + 96]\n                  if 27 == uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2440')), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2440')), 32))), 0) - 256) + 27):\n                      _2484 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                      signer = erecover(_2439, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2462')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2462')), 0) - 256) + 27 << 248, _2460, _2461) # precompiled\n                      if not erecover.result:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      if address(signer) != operatorAddress:\n                          _2558 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          revert with 0, 'failed to verify signature'\n                      if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                          _2618 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          revert with 0, 'claimant must be entry's account'\n                      _2617 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                      _2658 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                      if uint8(stor[_2658][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                          _2732 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          revert with 0, 'previously exited'\n                      _2730 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                      if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                          _2863 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n                      else:\n                          if not proof.length % 32:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          _3320 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n                  else:\n                      if uint8((Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2440')), 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', ('add', 96, ('var', '_2440')), 32))), 0) - 256) + 27) != 28:\n                          if operatorAddress:\n                              _2560 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                              revert with 0, 'failed to verify signature'\n                          if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                              _2622 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                              revert with 0, 'claimant must be entry's account'\n                          _2621 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                          _2660 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                          if uint8(stor[_2660][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                              _2736 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                              revert with 0, 'previously exited'\n                          _2734 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                          if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                              _2865 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n                          else:\n                              if not proof.length % 32:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              _3322 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2304\n                      else:\n                          _2503 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2272\n                          signer = erecover(_2439, (Mask(8, -(('mask_shl', 256, 0, -3, ('var', '_2462')), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('var', '_2462')), 0) - 256) + 27 << 248, _2460, _2461) # precompiled\n                          if not erecover.result:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          if address(signer) != operatorAddress:\n                              _2584 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                              revert with 0, 'failed to verify signature'\n                          if mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20] != caller:\n                              _2664 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                              revert with 0, 'claimant must be entry's account'\n                          _2663 = mem[(32 * uints.length) + (32 * addresses.length) + 704]\n                          _2692 = sha3(mem[(32 * uints.length) + (32 * addresses.length) + 684 len 20], 12)\n                          if uint8(stor[_2692][address(mem[(32 * uints.length) + (32 * addresses.length) + 704])]):\n                              _2773 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                              revert with 0, 'previously exited'\n                          _2771 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + 2304\n                          if root != uint256(gblocksByNumber[stor13 - 1].field_768):\n                              _2900 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n                          else:\n                              if not proof.length % 32:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              _3404 = _662 + (32 * uints.length) + (32 * addresses.length) + ceil32(signature.length) + ceil32(proof.length) + 2336\n  revert with 0, 'invalid balance proof'\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 41599 tokens. Please reduce the length of the messages."
}