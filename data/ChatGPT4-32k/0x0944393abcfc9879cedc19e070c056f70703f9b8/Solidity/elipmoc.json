{
	"address": "0x0944393abcfc9879cedc19e070c056f70703f9b8",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity smart contract interpretation of the provided decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) public _balances;\n    mapping (address => mapping (address => uint256)) public _allowance;\n    uint256 public _totalSupply;\n    uint256 public _sellPrice;\n    uint256 public _buyPrice;\n    address public _owner;\n    \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\n        require(msg.sender == _owner);\n        _sellPrice = newSellPrice;\n        _buyPrice = newBuyPrice;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _allowance[_from][msg.sender]); \n        require(_value <= _balances[_from]);\n        _balances[_from] -= _value; \n        _balances[_to] += _value;\n        _allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n        _allowance[msg.sender][_spender] += _addedValue;\n        emit Approval(msg.sender, _spender, _allowance[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n        uint256 oldValue = _allowance[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            _allowance[msg.sender][_spender] = 0;\n        } else {\n            _allowance[msg.sender][_spender] = oldValue - _subtractedValue;\n        }\n        emit Approval(msg.sender, _spender, _allowance[msg.sender][_spender]);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n```\n\nPlease note that this is a simplified version of the contract and it doesn't cover all the functionality of the original decompiled code. It only covers the basic ERC20 token contract operations such as transfer, approve, allowance, and setting prices, as well as ownership transfer. The actual code should be adjusted according to the specific requirements and business logic.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465356,
	"id": "chatcmpl-8R59Y6oPxPJxmObF9vBtJhenb51WS",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 01:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _sellPrice; // STORAGE[0x4]\nuint256 _buyPrice; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & '4ArtCoin';\n    }\n    return v0;\n}\n\nfunction 0x1b79(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg0);\n    require(varg2 <= _balances[v0]);\n    require(_balances[v0] - varg2 >= varg1);\n    return 1;\n}\n\nfunction 0x1c43(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balances[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balances[v2] + varg0 > _balances[v1]);\n    v3 = address(varg2);\n    _balances[v3] = _balances[v3] - varg0;\n    v4 = address(varg1);\n    _balances[v4] = _balances[v4] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    if (msg.sender != _owner) {\n        require(block.timestamp > 0x5b678f80);\n    }\n    if (0xff & owner_6[varg0]) {\n        require(block.timestamp > 0x5c007d80);\n        v0 = v1 = block.timestamp > 0x5c007d80;\n        if (v1) {\n            v0 = v2 = block.timestamp < 0x5d8ea280;\n        }\n        if (v0) {\n            v3 = 0x1b79(varg0, 0x147904303e4ff950c00000, varg2);\n        }\n        v4 = v5 = block.timestamp > 0x5d8ea280;\n        if (v5) {\n            v4 = v6 = block.timestamp < 0x5f712780;\n        }\n        if (v4) {\n            v7 = 0x1b79(varg0, 0xb5facfe5b81c365c00000, varg2);\n        }\n    }\n    if (0xff & owner_7[varg0]) {\n        require(block.timestamp > 0x5c007d80);\n        v8 = v9 = block.timestamp > 0x5c007d80;\n        if (v9) {\n            v8 = v10 = block.timestamp < 0x5d8ea280;\n        }\n        if (v8) {\n            v11 = 0x1b79(varg0, 0x1b6bc919d43c9232c00000, varg2);\n        }\n        v12 = v13 = block.timestamp > 0x5d8ea280;\n        if (v13) {\n            v12 = v14 = block.timestamp < 0x5f712780;\n        }\n        if (v12) {\n            v15 = 0x1b79(varg0, 0x135b248ab3ee8551000000, varg2);\n        }\n    }\n    require(varg1 != 0);\n    require(varg2 <= _balances[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    require(varg2 <= _balances[varg0]);\n    _balances[varg0] = _balances[varg0] - varg2;\n    require(_balances[varg1] + varg2 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        require(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x3441727400000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction buy() public payable { \n    require(block.timestamp > 0x5c007d80);\n    assert(_buyPrice);\n    0x1c43(msg.value / _buyPrice, msg.sender, _owner);\n}\n\nfunction transferTokens(address varg0, uint256 varg1) public nonPayable { \n    if (msg.sender != _owner) {\n        require(block.timestamp > 0x5b678f80);\n    }\n    if (0xff & owner_6[msg.sender]) {\n        require(block.timestamp > 0x5c007d80);\n        v0 = v1 = block.timestamp > 0x5c007d80;\n        if (v1) {\n            v0 = block.timestamp < 0x5d8ea280;\n        }\n        if (v0) {\n            v2 = 0x1b79(msg.sender, 0x147904303e4ff950c00000, varg1);\n        }\n        v3 = v4 = block.timestamp > 0x5d8ea280;\n        if (v4) {\n            v3 = block.timestamp < 0x5f712780;\n        }\n        if (v3) {\n            v5 = 0x1b79(msg.sender, 0xb5facfe5b81c365c00000, varg1);\n        }\n    }\n    if (0xff & owner_7[msg.sender]) {\n        require(block.timestamp > 0x5c007d80);\n        v6 = v7 = block.timestamp > 0x5c007d80;\n        if (v7) {\n            v6 = block.timestamp < 0x5d8ea280;\n        }\n        if (v6) {\n            v8 = 0x1b79(msg.sender, 0x1b6bc919d43c9232c00000, varg1);\n        }\n        v9 = v10 = block.timestamp > 0x5d8ea280;\n        if (v10) {\n            v9 = block.timestamp < 0x5f712780;\n        }\n        if (v9) {\n            v11 = 0x1b79(msg.sender, 0x135b248ab3ee8551000000, varg1);\n        }\n    }\n    0x1c43(varg1, varg0, msg.sender);\n}\n\nfunction transferBalanceToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 <= (address(this)).balance);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(block.timestamp > 0x5c007d80);\n    require(varg0 > 0);\n    require(_balances[msg.sender] >= varg0);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        assert(varg0);\n        v0 = varg0 * _sellPrice / varg0 == _sellPrice;\n    }\n    require(v0);\n    require((address(this)).balance >= varg0 * _sellPrice);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _balances[_owner] = _balances[_owner] + varg0;\n    emit Transfer(msg.sender, _owner, varg0);\n    v2 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xbec3fa17 == function_selector) {\n            transferTokens(address,uint256);\n        } else if (0xcbcdc2e4 == function_selector) {\n            transferBalanceToOwner(uint256);\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 01:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _sellPrice; // STORAGE[0x4]\nuint256 _buyPrice; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & '4ArtCoin';\n    }\n    return v0;\n}\n\nfunction 0x1b79(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg0);\n    require(varg2 <= _balances[v0]);\n    require(_balances[v0] - varg2 >= varg1);\n    return 1;\n}\n\nfunction 0x1c43(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balances[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balances[v2] + varg0 > _balances[v1]);\n    v3 = address(varg2);\n    _balances[v3] = _balances[v3] - varg0;\n    v4 = address(varg1);\n    _balances[v4] = _balances[v4] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    if (msg.sender != _owner) {\n        require(block.timestamp > 0x5b678f80);\n    }\n    if (0xff & owner_6[varg0]) {\n        require(block.timestamp > 0x5c007d80);\n        v0 = v1 = block.timestamp > 0x5c007d80;\n        if (v1) {\n            v0 = v2 = block.timestamp < 0x5d8ea280;\n        }\n        if (v0) {\n            v3 = 0x1b79(varg0, 0x147904303e4ff950c00000, varg2);\n        }\n        v4 = v5 = block.timestamp > 0x5d8ea280;\n        if (v5) {\n            v4 = v6 = block.timestamp < 0x5f712780;\n        }\n        if (v4) {\n            v7 = 0x1b79(varg0, 0xb5facfe5b81c365c00000, varg2);\n        }\n    }\n    if (0xff & owner_7[varg0]) {\n        require(block.timestamp > 0x5c007d80);\n        v8 = v9 = block.timestamp > 0x5c007d80;\n        if (v9) {\n            v8 = v10 = block.timestamp < 0x5d8ea280;\n        }\n        if (v8) {\n            v11 = 0x1b79(varg0, 0x1b6bc919d43c9232c00000, varg2);\n        }\n        v12 = v13 = block.timestamp > 0x5d8ea280;\n        if (v13) {\n            v12 = v14 = block.timestamp < 0x5f712780;\n        }\n        if (v12) {\n            v15 = 0x1b79(varg0, 0x135b248ab3ee8551000000, varg2);\n        }\n    }\n    require(varg1 != 0);\n    require(varg2 <= _balances[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    require(varg2 <= _balances[varg0]);\n    _balances[varg0] = _balances[varg0] - varg2;\n    require(_balances[varg1] + varg2 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        require(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x3441727400000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction buy() public payable { \n    require(block.timestamp > 0x5c007d80);\n    assert(_buyPrice);\n    0x1c43(msg.value / _buyPrice, msg.sender, _owner);\n}\n\nfunction transferTokens(address varg0, uint256 varg1) public nonPayable { \n    if (msg.sender != _owner) {\n        require(block.timestamp > 0x5b678f80);\n    }\n    if (0xff & owner_6[msg.sender]) {\n        require(block.timestamp > 0x5c007d80);\n        v0 = v1 = block.timestamp > 0x5c007d80;\n        if (v1) {\n            v0 = block.timestamp < 0x5d8ea280;\n        }\n        if (v0) {\n            v2 = 0x1b79(msg.sender, 0x147904303e4ff950c00000, varg1);\n        }\n        v3 = v4 = block.timestamp > 0x5d8ea280;\n        if (v4) {\n            v3 = block.timestamp < 0x5f712780;\n        }\n        if (v3) {\n            v5 = 0x1b79(msg.sender, 0xb5facfe5b81c365c00000, varg1);\n        }\n    }\n    if (0xff & owner_7[msg.sender]) {\n        require(block.timestamp > 0x5c007d80);\n        v6 = v7 = block.timestamp > 0x5c007d80;\n        if (v7) {\n            v6 = block.timestamp < 0x5d8ea280;\n        }\n        if (v6) {\n            v8 = 0x1b79(msg.sender, 0x1b6bc919d43c9232c00000, varg1);\n        }\n        v9 = v10 = block.timestamp > 0x5d8ea280;\n        if (v10) {\n            v9 = block.timestamp < 0x5f712780;\n        }\n        if (v9) {\n            v11 = 0x1b79(msg.sender, 0x135b248ab3ee8551000000, varg1);\n        }\n    }\n    0x1c43(varg1, varg0, msg.sender);\n}\n\nfunction transferBalanceToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 <= (address(this)).balance);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(block.timestamp > 0x5c007d80);\n    require(varg0 > 0);\n    require(_balances[msg.sender] >= varg0);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        assert(varg0);\n        v0 = varg0 * _sellPrice / varg0 == _sellPrice;\n    }\n    require(v0);\n    require((address(this)).balance >= varg0 * _sellPrice);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _balances[_owner] = _balances[_owner] + varg0;\n    emit Transfer(msg.sender, _owner, varg0);\n    v2 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xbec3fa17 == function_selector) {\n            transferTokens(address,uint256);\n        } else if (0xcbcdc2e4 == function_selector) {\n            transferBalanceToOwner(uint256);\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 01:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _sellPrice; // STORAGE[0x4]\nuint256 _buyPrice; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & '4ArtCoin';\n    }\n    return v0;\n}\n\nfunction 0x1b79(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg0);\n    require(varg2 <= _balances[v0]);\n    require(_balances[v0] - varg2 >= varg1);\n    return 1;\n}\n\nfunction 0x1c43(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balances[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balances[v2] + varg0 > _balances[v1]);\n    v3 = address(varg2);\n    _balances[v3] = _balances[v3] - varg0;\n    v4 = address(varg1);\n    _balances[v4] = _balances[v4] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    if (msg.sender != _owner) {\n        require(block.timestamp > 0x5b678f80);\n    }\n    if (0xff & owner_6[varg0]) {\n        require(block.timestamp > 0x5c007d80);\n        v0 = v1 = block.timestamp > 0x5c007d80;\n        if (v1) {\n            v0 = v2 = block.timestamp < 0x5d8ea280;\n        }\n        if (v0) {\n            v3 = 0x1b79(varg0, 0x147904303e4ff950c00000, varg2);\n        }\n        v4 = v5 = block.timestamp > 0x5d8ea280;\n        if (v5) {\n            v4 = v6 = block.timestamp < 0x5f712780;\n        }\n        if (v4) {\n            v7 = 0x1b79(varg0, 0xb5facfe5b81c365c00000, varg2);\n        }\n    }\n    if (0xff & owner_7[varg0]) {\n        require(block.timestamp > 0x5c007d80);\n        v8 = v9 = block.timestamp > 0x5c007d80;\n        if (v9) {\n            v8 = v10 = block.timestamp < 0x5d8ea280;\n        }\n        if (v8) {\n            v11 = 0x1b79(varg0, 0x1b6bc919d43c9232c00000, varg2);\n        }\n        v12 = v13 = block.timestamp > 0x5d8ea280;\n        if (v13) {\n            v12 = v14 = block.timestamp < 0x5f712780;\n        }\n        if (v12) {\n            v15 = 0x1b79(varg0, 0x135b248ab3ee8551000000, varg2);\n        }\n    }\n    require(varg1 != 0);\n    require(varg2 <= _balances[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    require(varg2 <= _balances[varg0]);\n    _balances[varg0] = _balances[varg0] - varg2;\n    require(_balances[varg1] + varg2 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        require(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x3441727400000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction buy() public payable { \n    require(block.timestamp > 0x5c007d80);\n    assert(_buyPrice);\n    0x1c43(msg.value / _buyPrice, msg.sender, _owner);\n}\n\nfunction transferTokens(address varg0, uint256 varg1) public nonPayable { \n    if (msg.sender != _owner) {\n        require(block.timestamp > 0x5b678f80);\n    }\n    if (0xff & owner_6[msg.sender]) {\n        require(block.timestamp > 0x5c007d80);\n        v0 = v1 = block.timestamp > 0x5c007d80;\n        if (v1) {\n            v0 = block.timestamp < 0x5d8ea280;\n        }\n        if (v0) {\n            v2 = 0x1b79(msg.sender, 0x147904303e4ff950c00000, varg1);\n        }\n        v3 = v4 = block.timestamp > 0x5d8ea280;\n        if (v4) {\n            v3 = block.timestamp < 0x5f712780;\n        }\n        if (v3) {\n            v5 = 0x1b79(msg.sender, 0xb5facfe5b81c365c00000, varg1);\n        }\n    }\n    if (0xff & owner_7[msg.sender]) {\n        require(block.timestamp > 0x5c007d80);\n        v6 = v7 = block.timestamp > 0x5c007d80;\n        if (v7) {\n            v6 = block.timestamp < 0x5d8ea280;\n        }\n        if (v6) {\n            v8 = 0x1b79(msg.sender, 0x1b6bc919d43c9232c00000, varg1);\n        }\n        v9 = v10 = block.timestamp > 0x5d8ea280;\n        if (v10) {\n            v9 = block.timestamp < 0x5f712780;\n        }\n        if (v9) {\n            v11 = 0x1b79(msg.sender, 0x135b248ab3ee8551000000, varg1);\n        }\n    }\n    0x1c43(varg1, varg0, msg.sender);\n}\n\nfunction transferBalanceToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 <= (address(this)).balance);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(block.timestamp > 0x5c007d80);\n    require(varg0 > 0);\n    require(_balances[msg.sender] >= varg0);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        assert(varg0);\n        v0 = varg0 * _sellPrice / varg0 == _sellPrice;\n    }\n    require(v0);\n    require((address(this)).balance >= varg0 * _sellPrice);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _balances[_owner] = _balances[_owner] + varg0;\n    emit Transfer(msg.sender, _owner, varg0);\n    v2 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xbec3fa17 == function_selector) {\n            transferTokens(address,uint256);\n        } else if (0xcbcdc2e4 == function_selector) {\n            transferBalanceToOwner(uint256);\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 30.18027687072754,
	"usage": {
		"completion_tokens": 656,
		"prompt_tokens": 3141,
		"total_tokens": 3797
	}
}