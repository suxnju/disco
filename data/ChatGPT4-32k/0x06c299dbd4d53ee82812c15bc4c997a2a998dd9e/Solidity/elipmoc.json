{
	"address": "0x06c299dbd4d53ee82812c15bc4c997a2a998dd9e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract based on the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Token {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    string private _name;\n    string private _symbol;\n    uint256 private _totalSupply;\n    uint8 private _decimals;\n    address private _owner;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_, uint256 initialSupply) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _totalSupply = initialSupply * 10**uint256(_decimals);\n        _balances[msg.sender] = _totalSupply;\n        _owner = msg.sender;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(_balances[msg.sender] >= value);\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(_balances[from] >= value);\n        require(_allowed[from][msg.sender] >= value);\n        _balances[from] -= value;\n        _balances[to] += value;\n        _allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n```\n\nPlease note that this is a simplified version of the original contract and might not exactly match the original one, especially in the handling of dynamic byte arrays (like name and symbol). Also, the original contract seems to have some kind of fallback function that modifies balances, but it's not clear from the decompiled code how exactly it should work, so it was omitted here. Finally, the `__function_selector__` function was also omitted because it's not a part of a typical Solidity contract and it's not clear what it's supposed to do.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468744,
	"id": "chatcmpl-8R62CsLI3zKBpj1VLSuS9puTVAeac",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 06:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x6]\nuint256 _totalSupply; // STORAGE[0x7]\nuint256 _tokenDecimal; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(_fallback[varg0] >= varg2);\n    _fallback[varg1] = _fallback[varg1] + varg2;\n    _fallback[varg0] = _fallback[varg0] - varg2;\n    _allowed[msg.sender] = _allowed[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction tokenDecimal() public nonPayable { \n    return _tokenDecimal;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_fallback[msg.sender] >= varg1);\n    _fallback[msg.sender] = _fallback[msg.sender] - varg1;\n    _fallback[varg0] = _fallback[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x5c658165 == function_selector) {\n            allowed(address,address);\n        } else if (0x5caed029 == function_selector) {\n            tokenDecimal();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 06:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x6]\nuint256 _totalSupply; // STORAGE[0x7]\nuint256 _tokenDecimal; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(_fallback[varg0] >= varg2);\n    _fallback[varg1] = _fallback[varg1] + varg2;\n    _fallback[varg0] = _fallback[varg0] - varg2;\n    _allowed[msg.sender] = _allowed[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction tokenDecimal() public nonPayable { \n    return _tokenDecimal;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_fallback[msg.sender] >= varg1);\n    _fallback[msg.sender] = _fallback[msg.sender] - varg1;\n    _fallback[varg0] = _fallback[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x5c658165 == function_selector) {\n            allowed(address,address);\n        } else if (0x5caed029 == function_selector) {\n            tokenDecimal();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 06:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _fallback; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x6]\nuint256 _totalSupply; // STORAGE[0x7]\nuint256 _tokenDecimal; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(_fallback[varg0] >= varg2);\n    _fallback[varg1] = _fallback[varg1] + varg2;\n    _fallback[varg0] = _fallback[varg0] - varg2;\n    _allowed[msg.sender] = _allowed[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction tokenDecimal() public nonPayable { \n    return _tokenDecimal;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _fallback[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_fallback[msg.sender] >= varg1);\n    _fallback[msg.sender] = _fallback[msg.sender] - varg1;\n    _fallback[varg0] = _fallback[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    _fallback[msg.sender] = _fallback[msg.sender] + msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x5c658165 == function_selector) {\n            allowed(address,address);\n        } else if (0x5caed029 == function_selector) {\n            tokenDecimal();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 31.031099319458008,
	"usage": {
		"completion_tokens": 723,
		"prompt_tokens": 1626,
		"total_tokens": 2349
	}
}