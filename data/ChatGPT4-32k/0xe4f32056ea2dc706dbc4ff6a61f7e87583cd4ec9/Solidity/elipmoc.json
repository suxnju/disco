{
	"address": "0xe4f32056ea2dc706dbc4ff6a61f7e87583cd4ec9",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Sure, here's a Solidity contract that should correspond to the decompiled EVM bytecode. I've made some assumptions about the types and logic based on the given bytecode. For instance, I have assumed that `_admins`, `_formulaContract`, `_collectedFees`, `_virtualReserveBalance`, `_depositEther`, `_enabled`, and `_tokenContract` are state variables. \n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping(address => bool) private _admins;\n    address private _formulaContract;\n    uint256 private _collectedFees;\n    uint256 private _virtualReserveBalance;\n    address payable private _depositEther;\n    bool private _enabled;\n    address private _tokenContract;\n\n    event Sell(address indexed seller, uint256 amount, uint256 value);\n    event Buy(address indexed buyer, uint256 amount, uint256 value);\n\n    modifier onlyAdmin() {\n        require(_admins[msg.sender] || msg.sender == _depositEther);\n        _;\n    }\n\n    function creator() public view returns (address) {\n        return _depositEther;\n    }\n\n    function enabled() public view returns (bool) {\n        return _enabled;\n    }\n\n    function disable() public onlyAdmin {\n        _enabled = false;\n    }\n\n    function withdrawTokens(uint256 amount) public {\n        require(msg.sender == _depositEther);\n        require(_tokenContract != address(0));\n        // Call to ERC20 token contract's `transfer` function\n    }\n\n    function grantAdmin(address admin) public {\n        require(msg.sender == _depositEther);\n        _admins[admin] = true;\n    }\n    \n    // More functions based on the decompiled EVM Bytecode...\n}\n```\n\nPlease note that this is only a basic structure. You will need to fill in the details according to your exact requirements, and you may need to adjust the code based on the specifics of the EVM bytecode. This code does not include the ERC20 token interactions, as those would require knowing the specific interface of the token contract(s) in question.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711535901,
	"id": "chatcmpl-97Kxhovh8mFZl93anRazZLVAN6IBK",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.05 10:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x1]\nuint256 _formulaContract; // STORAGE[0x3]\nuint256 _collectedFees; // STORAGE[0x4]\nuint256 _virtualReserveBalance; // STORAGE[0x5]\nuint256 _depositEther; // STORAGE[0x0] bytes 0 to 19\nuint256 _enabled; // STORAGE[0x2] bytes 0 to 0\nuint256 _tokenContract; // STORAGE[0x2] bytes 1 to 20\n\n// Events\nSell(address, uint256, uint256);\nBuy(address, uint256, uint256);\n\nfunction () public payable { \n    revert();\n}\n\nfunction creator() public nonPayable { \n    return _depositEther;\n}\n\nfunction enabled() public nonPayable { \n    return _enabled;\n}\n\nfunction disable() public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _enabled = 0;\n}\n\nfunction withdrawTokens(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    require(_tokenContract.code.size);\n    v0 = _tokenContract.transfer(msg.sender, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction grantAdmin(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _admins[varg0] = 0x1 | ~0xff & _admins[varg0];\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction tokenContract() public nonPayable { \n    return _tokenContract;\n}\n\nfunction formulaContract() public nonPayable { \n    return address(_formulaContract);\n}\n\nfunction sellOneStep(uint256 varg0, uint256 varg1, address varg2) public nonPayable { \n    0xc21(varg2, varg1, varg0);\n}\n\nfunction setFee(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    v3 = v4 = varg0 >= 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 0xf4240;\n    }\n    require(v3);\n    _formulaContract = uint32(varg0) << 192 | ~0xffffffff000000000000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction getReserveBalances() public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1, (address(this)).balance + _virtualReserveBalance;\n}\n\nfunction virtualReserveBalance() public nonPayable { \n    return _virtualReserveBalance;\n}\n\nfunction receiveApproval(address varg0, uint256 varg1, address varg2, bytes varg3) public nonPayable { \n    0xc21(varg0, 0, varg1);\n}\n\nfunction collectedFees() public nonPayable { \n    return _collectedFees;\n}\n\nfunction depositEther() public payable { \n    require(_depositEther == msg.sender);\n}\n\nfunction weight() public nonPayable { \n    return uint32(_formulaContract >> 160);\n}\n\nfunction enable() public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _enabled = 1;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _depositEther = varg0;\n}\n\nfunction extractFees(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = _depositEther == msg.sender;\n    }\n    require(v0);\n    require(varg0 <= _collectedFees);\n    v2 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction setVirtualReserveBalance(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _virtualReserveBalance = varg0;\n}\n\nfunction issuedSupplyRatio() public nonPayable { \n    return uint32(_formulaContract >> 224);\n}\n\nfunction getPurchasePrice(uint256 varg0) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculatePurchaseReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v7 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_tokenContract.code.size);\n    v8, v9 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v7 > v9) {\n        require(_tokenContract.code.size);\n        v10, v6 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    return v6;\n}\n\nfunction setissuedSupplyRatio(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    _formulaContract = uint32(varg0) << 224 | ~0xffffffff00000000000000000000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction sell(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg1);\n    require(v6 <= (address(this)).balance);\n    require(_tokenContract.code.size);\n    v7, v8 = _tokenContract.transferFrom(msg.sender, address(this), varg0).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v8);\n    _collectedFees = _collectedFees + v6 * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Sell(msg.sender, varg0, v6);\n    v9 = msg.sender.call().value(v6).gas(!v6 * 2300);\n    require(v9); // checks call status, propagates error data on error\n}\n\nfunction buy(uint256 varg0) public payable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculatePurchaseReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance - msg.value, uint32(_formulaContract >> 160), msg.value).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg0);\n    require(_tokenContract.code.size);\n    v7, v8 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v8 >= v6);\n    _collectedFees = _collectedFees + msg.value * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Buy(msg.sender, msg.value, v6);\n    require(_tokenContract.code.size);\n    v9 = _tokenContract.transfer(msg.sender, v6).gas(msg.gas);\n    require(v9); // checks call status, propagates error data on error\n}\n\nfunction depositTokens(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.transferFrom(msg.sender, address(this), varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction fee() public nonPayable { \n    return uint32(_formulaContract >> 192);\n}\n\nfunction setReserveWeight(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    v3 = v4 = varg0 > 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 0xf4240;\n    }\n    require(v3);\n    _formulaContract = uint32(varg0) << 160 | ~0xffffffff0000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction getSalePrice(uint256 varg0) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v7 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    if (v7 > (address(this)).balance) {\n        v6 = v8 = (address(this)).balance;\n    }\n    return v6;\n}\n\nfunction revokeAdminStatus(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _admins[varg0] = 0x0 | ~0xff & _admins[varg0];\n}\n\nfunction 0xc21(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg1);\n    require(v6 <= (address(this)).balance);\n    v7 = address(varg0);\n    require(_tokenContract.code.size);\n    v8, v9 = _tokenContract.transferFrom(v7, address(this), varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    _collectedFees = _collectedFees + v6 * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Sell(address(varg0), varg2, v6);\n    v10 = address(varg0).call().value(v6).gas(!v6 * 2300);\n    require(v10); // checks call status, propagates error data on error\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (0x2d05d3f == v0) {\n            creator();\n        } else if (0x238dafe0 == v0) {\n            enabled();\n        } else if (0x2f2770db == v0) {\n            disable();\n        } else if (0x315a095d == v0) {\n            withdrawTokens(uint256);\n        } else if (0x35bb3e16 == v0) {\n            grantAdmin(address);\n        } else if (0x3bed33ce == v0) {\n            withdrawEther(uint256);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x55a373d6 == v0) {\n            tokenContract();\n        } else if (0x5cc5ca50 == v0) {\n            formulaContract();\n        } else if (0x63f8a211 == v0) {\n            sellOneStep(uint256,uint256,address);\n        } else if (0x69fe0e2d == v0) {\n            setFee(uint256);\n        } else if (0x77d56a04 == v0) {\n            getReserveBalances();\n        } else if (0x8e068b11 == v0) {\n            virtualReserveBalance();\n        } else if (0x8f4ffcb1 == v0) {\n            receiveApproval(address,uint256,address,bytes);\n        } else if (0x9003adfe == v0) {\n            collectedFees();\n        } else if (0x98ea5fca == v0) {\n            depositEther();\n        } else if (0xa1aab33f == v0) {\n            weight();\n        } else if (0xa3907d71 == v0) {\n            enable();\n        } else if (0xa6f9dae1 == v0) {\n            changeOwner(address);\n        } else if (0xb9c8464d == v0) {\n            extractFees(uint256);\n        } else if (0xbd8caabf == v0) {\n            setVirtualReserveBalance(uint256);\n        } else if (0xc24e1fc1 == v0) {\n            issuedSupplyRatio();\n        } else if (0xc59d5633 == v0) {\n            getPurchasePrice(uint256);\n        } else if (0xcee96f49 == v0) {\n            setissuedSupplyRatio(uint256);\n        } else if (0xd79875eb == v0) {\n            sell(uint256,uint256);\n        } else if (0xd96a094a == v0) {\n            buy(uint256);\n        } else if (0xdd49756e == v0) {\n            depositTokens(uint256);\n        } else if (0xddca3f43 == v0) {\n            fee();\n        } else if (0xeff841d1 == v0) {\n            setReserveWeight(uint256);\n        } else if (0xf8eb5fc5 == v0) {\n            getSalePrice(uint256);\n        } else if (0xfa62a1ff == v0) {\n            revokeAdminStatus(address);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.05 10:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x1]\nuint256 _formulaContract; // STORAGE[0x3]\nuint256 _collectedFees; // STORAGE[0x4]\nuint256 _virtualReserveBalance; // STORAGE[0x5]\nuint256 _depositEther; // STORAGE[0x0] bytes 0 to 19\nuint256 _enabled; // STORAGE[0x2] bytes 0 to 0\nuint256 _tokenContract; // STORAGE[0x2] bytes 1 to 20\n\n// Events\nSell(address, uint256, uint256);\nBuy(address, uint256, uint256);\n\nfunction () public payable { \n    revert();\n}\n\nfunction creator() public nonPayable { \n    return _depositEther;\n}\n\nfunction enabled() public nonPayable { \n    return _enabled;\n}\n\nfunction disable() public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _enabled = 0;\n}\n\nfunction withdrawTokens(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    require(_tokenContract.code.size);\n    v0 = _tokenContract.transfer(msg.sender, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction grantAdmin(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _admins[varg0] = 0x1 | ~0xff & _admins[varg0];\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction tokenContract() public nonPayable { \n    return _tokenContract;\n}\n\nfunction formulaContract() public nonPayable { \n    return address(_formulaContract);\n}\n\nfunction sellOneStep(uint256 varg0, uint256 varg1, address varg2) public nonPayable { \n    0xc21(varg2, varg1, varg0);\n}\n\nfunction setFee(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    v3 = v4 = varg0 >= 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 0xf4240;\n    }\n    require(v3);\n    _formulaContract = uint32(varg0) << 192 | ~0xffffffff000000000000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction getReserveBalances() public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1, (address(this)).balance + _virtualReserveBalance;\n}\n\nfunction virtualReserveBalance() public nonPayable { \n    return _virtualReserveBalance;\n}\n\nfunction receiveApproval(address varg0, uint256 varg1, address varg2, bytes varg3) public nonPayable { \n    0xc21(varg0, 0, varg1);\n}\n\nfunction collectedFees() public nonPayable { \n    return _collectedFees;\n}\n\nfunction depositEther() public payable { \n    require(_depositEther == msg.sender);\n}\n\nfunction weight() public nonPayable { \n    return uint32(_formulaContract >> 160);\n}\n\nfunction enable() public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _enabled = 1;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _depositEther = varg0;\n}\n\nfunction extractFees(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = _depositEther == msg.sender;\n    }\n    require(v0);\n    require(varg0 <= _collectedFees);\n    v2 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction setVirtualReserveBalance(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _virtualReserveBalance = varg0;\n}\n\nfunction issuedSupplyRatio() public nonPayable { \n    return uint32(_formulaContract >> 224);\n}\n\nfunction getPurchasePrice(uint256 varg0) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculatePurchaseReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v7 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_tokenContract.code.size);\n    v8, v9 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v7 > v9) {\n        require(_tokenContract.code.size);\n        v10, v6 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    return v6;\n}\n\nfunction setissuedSupplyRatio(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    _formulaContract = uint32(varg0) << 224 | ~0xffffffff00000000000000000000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction sell(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg1);\n    require(v6 <= (address(this)).balance);\n    require(_tokenContract.code.size);\n    v7, v8 = _tokenContract.transferFrom(msg.sender, address(this), varg0).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v8);\n    _collectedFees = _collectedFees + v6 * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Sell(msg.sender, varg0, v6);\n    v9 = msg.sender.call().value(v6).gas(!v6 * 2300);\n    require(v9); // checks call status, propagates error data on error\n}\n\nfunction buy(uint256 varg0) public payable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculatePurchaseReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance - msg.value, uint32(_formulaContract >> 160), msg.value).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg0);\n    require(_tokenContract.code.size);\n    v7, v8 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v8 >= v6);\n    _collectedFees = _collectedFees + msg.value * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Buy(msg.sender, msg.value, v6);\n    require(_tokenContract.code.size);\n    v9 = _tokenContract.transfer(msg.sender, v6).gas(msg.gas);\n    require(v9); // checks call status, propagates error data on error\n}\n\nfunction depositTokens(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.transferFrom(msg.sender, address(this), varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction fee() public nonPayable { \n    return uint32(_formulaContract >> 192);\n}\n\nfunction setReserveWeight(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    v3 = v4 = varg0 > 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 0xf4240;\n    }\n    require(v3);\n    _formulaContract = uint32(varg0) << 160 | ~0xffffffff0000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction getSalePrice(uint256 varg0) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v7 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    if (v7 > (address(this)).balance) {\n        v6 = v8 = (address(this)).balance;\n    }\n    return v6;\n}\n\nfunction revokeAdminStatus(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _admins[varg0] = 0x0 | ~0xff & _admins[varg0];\n}\n\nfunction 0xc21(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg1);\n    require(v6 <= (address(this)).balance);\n    v7 = address(varg0);\n    require(_tokenContract.code.size);\n    v8, v9 = _tokenContract.transferFrom(v7, address(this), varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    _collectedFees = _collectedFees + v6 * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Sell(address(varg0), varg2, v6);\n    v10 = address(varg0).call().value(v6).gas(!v6 * 2300);\n    require(v10); // checks call status, propagates error data on error\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (0x2d05d3f == v0) {\n            creator();\n        } else if (0x238dafe0 == v0) {\n            enabled();\n        } else if (0x2f2770db == v0) {\n            disable();\n        } else if (0x315a095d == v0) {\n            withdrawTokens(uint256);\n        } else if (0x35bb3e16 == v0) {\n            grantAdmin(address);\n        } else if (0x3bed33ce == v0) {\n            withdrawEther(uint256);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x55a373d6 == v0) {\n            tokenContract();\n        } else if (0x5cc5ca50 == v0) {\n            formulaContract();\n        } else if (0x63f8a211 == v0) {\n            sellOneStep(uint256,uint256,address);\n        } else if (0x69fe0e2d == v0) {\n            setFee(uint256);\n        } else if (0x77d56a04 == v0) {\n            getReserveBalances();\n        } else if (0x8e068b11 == v0) {\n            virtualReserveBalance();\n        } else if (0x8f4ffcb1 == v0) {\n            receiveApproval(address,uint256,address,bytes);\n        } else if (0x9003adfe == v0) {\n            collectedFees();\n        } else if (0x98ea5fca == v0) {\n            depositEther();\n        } else if (0xa1aab33f == v0) {\n            weight();\n        } else if (0xa3907d71 == v0) {\n            enable();\n        } else if (0xa6f9dae1 == v0) {\n            changeOwner(address);\n        } else if (0xb9c8464d == v0) {\n            extractFees(uint256);\n        } else if (0xbd8caabf == v0) {\n            setVirtualReserveBalance(uint256);\n        } else if (0xc24e1fc1 == v0) {\n            issuedSupplyRatio();\n        } else if (0xc59d5633 == v0) {\n            getPurchasePrice(uint256);\n        } else if (0xcee96f49 == v0) {\n            setissuedSupplyRatio(uint256);\n        } else if (0xd79875eb == v0) {\n            sell(uint256,uint256);\n        } else if (0xd96a094a == v0) {\n            buy(uint256);\n        } else if (0xdd49756e == v0) {\n            depositTokens(uint256);\n        } else if (0xddca3f43 == v0) {\n            fee();\n        } else if (0xeff841d1 == v0) {\n            setReserveWeight(uint256);\n        } else if (0xf8eb5fc5 == v0) {\n            getSalePrice(uint256);\n        } else if (0xfa62a1ff == v0) {\n            revokeAdminStatus(address);\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.05 10:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x1]\nuint256 _formulaContract; // STORAGE[0x3]\nuint256 _collectedFees; // STORAGE[0x4]\nuint256 _virtualReserveBalance; // STORAGE[0x5]\nuint256 _depositEther; // STORAGE[0x0] bytes 0 to 19\nuint256 _enabled; // STORAGE[0x2] bytes 0 to 0\nuint256 _tokenContract; // STORAGE[0x2] bytes 1 to 20\n\n// Events\nSell(address, uint256, uint256);\nBuy(address, uint256, uint256);\n\nfunction () public payable { \n    revert();\n}\n\nfunction creator() public nonPayable { \n    return _depositEther;\n}\n\nfunction enabled() public nonPayable { \n    return _enabled;\n}\n\nfunction disable() public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _enabled = 0;\n}\n\nfunction withdrawTokens(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    require(_tokenContract.code.size);\n    v0 = _tokenContract.transfer(msg.sender, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction grantAdmin(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _admins[varg0] = 0x1 | ~0xff & _admins[varg0];\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction tokenContract() public nonPayable { \n    return _tokenContract;\n}\n\nfunction formulaContract() public nonPayable { \n    return address(_formulaContract);\n}\n\nfunction sellOneStep(uint256 varg0, uint256 varg1, address varg2) public nonPayable { \n    0xc21(varg2, varg1, varg0);\n}\n\nfunction setFee(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    v3 = v4 = varg0 >= 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 0xf4240;\n    }\n    require(v3);\n    _formulaContract = uint32(varg0) << 192 | ~0xffffffff000000000000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction getReserveBalances() public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1, (address(this)).balance + _virtualReserveBalance;\n}\n\nfunction virtualReserveBalance() public nonPayable { \n    return _virtualReserveBalance;\n}\n\nfunction receiveApproval(address varg0, uint256 varg1, address varg2, bytes varg3) public nonPayable { \n    0xc21(varg0, 0, varg1);\n}\n\nfunction collectedFees() public nonPayable { \n    return _collectedFees;\n}\n\nfunction depositEther() public payable { \n    require(_depositEther == msg.sender);\n}\n\nfunction weight() public nonPayable { \n    return uint32(_formulaContract >> 160);\n}\n\nfunction enable() public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _enabled = 1;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _depositEther = varg0;\n}\n\nfunction extractFees(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = _depositEther == msg.sender;\n    }\n    require(v0);\n    require(varg0 <= _collectedFees);\n    v2 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction setVirtualReserveBalance(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    _virtualReserveBalance = varg0;\n}\n\nfunction issuedSupplyRatio() public nonPayable { \n    return uint32(_formulaContract >> 224);\n}\n\nfunction getPurchasePrice(uint256 varg0) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculatePurchaseReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v7 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_tokenContract.code.size);\n    v8, v9 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v7 > v9) {\n        require(_tokenContract.code.size);\n        v10, v6 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    return v6;\n}\n\nfunction setissuedSupplyRatio(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    require(varg0 > 0);\n    _formulaContract = uint32(varg0) << 224 | ~0xffffffff00000000000000000000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction sell(uint256 varg0, uint256 varg1) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg1);\n    require(v6 <= (address(this)).balance);\n    require(_tokenContract.code.size);\n    v7, v8 = _tokenContract.transferFrom(msg.sender, address(this), varg0).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v8);\n    _collectedFees = _collectedFees + v6 * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Sell(msg.sender, varg0, v6);\n    v9 = msg.sender.call().value(v6).gas(!v6 * 2300);\n    require(v9); // checks call status, propagates error data on error\n}\n\nfunction buy(uint256 varg0) public payable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculatePurchaseReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance - msg.value, uint32(_formulaContract >> 160), msg.value).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg0);\n    require(_tokenContract.code.size);\n    v7, v8 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v8 >= v6);\n    _collectedFees = _collectedFees + msg.value * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Buy(msg.sender, msg.value, v6);\n    require(_tokenContract.code.size);\n    v9 = _tokenContract.transfer(msg.sender, v6).gas(msg.gas);\n    require(v9); // checks call status, propagates error data on error\n}\n\nfunction depositTokens(uint256 varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.transferFrom(msg.sender, address(this), varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction fee() public nonPayable { \n    return uint32(_formulaContract >> 192);\n}\n\nfunction setReserveWeight(uint256 varg0) public nonPayable { \n    v0 = v1 = 0xff & _admins[msg.sender];\n    if (!v1) {\n        v0 = v2 = _depositEther == msg.sender;\n    }\n    require(v0);\n    v3 = v4 = varg0 > 0;\n    if (v4) {\n        v3 = v5 = varg0 <= 0xf4240;\n    }\n    require(v3);\n    _formulaContract = uint32(varg0) << 160 | ~0xffffffff0000000000000000000000000000000000000000 & _formulaContract;\n}\n\nfunction getSalePrice(uint256 varg0) public nonPayable { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v7 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    if (v7 > (address(this)).balance) {\n        v6 = v8 = (address(this)).balance;\n    }\n    return v6;\n}\n\nfunction revokeAdminStatus(address varg0) public nonPayable { \n    require(_depositEther == msg.sender);\n    _admins[varg0] = 0x0 | ~0xff & _admins[varg0];\n}\n\nfunction 0xc21(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(_tokenContract.code.size);\n    v0, v1 = _tokenContract.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_tokenContract.code.size);\n    v2, v3 = _tokenContract.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(uint32(_formulaContract >> 224));\n    require((address(_formulaContract)).code.size);\n    v4, v5 = address(_formulaContract).calculateSaleReturn(v3 / uint32(_formulaContract >> 224) - v1, (address(this)).balance + _virtualReserveBalance, uint32(_formulaContract >> 160), varg2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = v5 - v5 * uint32(_formulaContract >> 192) / 0xf4240;\n    require(_enabled);\n    require(v6 >= varg1);\n    require(v6 <= (address(this)).balance);\n    v7 = address(varg0);\n    require(_tokenContract.code.size);\n    v8, v9 = _tokenContract.transferFrom(v7, address(this), varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    _collectedFees = _collectedFees + v6 * uint32(_formulaContract >> 192) / 0xf4240;\n    emit Sell(address(varg0), varg2, v6);\n    v10 = address(varg0).call().value(v6).gas(!v6 * 2300);\n    require(v10); // checks call status, propagates error data on error\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (0x2d05d3f == v0) {\n            creator();\n        } else if (0x238dafe0 == v0) {\n            enabled();\n        } else if (0x2f2770db == v0) {\n            disable();\n        } else if (0x315a095d == v0) {\n            withdrawTokens(uint256);\n        } else if (0x35bb3e16 == v0) {\n            grantAdmin(address);\n        } else if (0x3bed33ce == v0) {\n            withdrawEther(uint256);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x55a373d6 == v0) {\n            tokenContract();\n        } else if (0x5cc5ca50 == v0) {\n            formulaContract();\n        } else if (0x63f8a211 == v0) {\n            sellOneStep(uint256,uint256,address);\n        } else if (0x69fe0e2d == v0) {\n            setFee(uint256);\n        } else if (0x77d56a04 == v0) {\n            getReserveBalances();\n        } else if (0x8e068b11 == v0) {\n            virtualReserveBalance();\n        } else if (0x8f4ffcb1 == v0) {\n            receiveApproval(address,uint256,address,bytes);\n        } else if (0x9003adfe == v0) {\n            collectedFees();\n        } else if (0x98ea5fca == v0) {\n            depositEther();\n        } else if (0xa1aab33f == v0) {\n            weight();\n        } else if (0xa3907d71 == v0) {\n            enable();\n        } else if (0xa6f9dae1 == v0) {\n            changeOwner(address);\n        } else if (0xb9c8464d == v0) {\n            extractFees(uint256);\n        } else if (0xbd8caabf == v0) {\n            setVirtualReserveBalance(uint256);\n        } else if (0xc24e1fc1 == v0) {\n            issuedSupplyRatio();\n        } else if (0xc59d5633 == v0) {\n            getPurchasePrice(uint256);\n        } else if (0xcee96f49 == v0) {\n            setissuedSupplyRatio(uint256);\n        } else if (0xd79875eb == v0) {\n            sell(uint256,uint256);\n        } else if (0xd96a094a == v0) {\n            buy(uint256);\n        } else if (0xdd49756e == v0) {\n            depositTokens(uint256);\n        } else if (0xddca3f43 == v0) {\n            fee();\n        } else if (0xeff841d1 == v0) {\n            setReserveWeight(uint256);\n        } else if (0xf8eb5fc5 == v0) {\n            getSalePrice(uint256);\n        } else if (0xfa62a1ff == v0) {\n            revokeAdminStatus(address);\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 108.75773859024048,
	"usage": {
		"completion_tokens": 424,
		"prompt_tokens": 4562,
		"total_tokens": 4986
	}
}