{
	"address": "0x39fbd1140cd1fc298f00c3ea64b3591de94c67e7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2024.03.26 09:39 UTC\n// Compiled using the solidity compiler version 0.4.7<=v<0.5.9\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => mapping (uint256 => uint256)) owner_0; // STORAGE[0x0]\nmapping (uint256 => uint256) map_1; // STORAGE[0x1]\nmapping (uint256 => uint256) map_2; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_5; // STORAGE[0x5]\nmapping (uint256 => uint256) map_6; // STORAGE[0x6]\nmapping (uint256 => uint256) owner_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint8 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nmapping (uint256 => uint256) owner_c; // STORAGE[0xc]\nmapping (uint256 => uint256) map_e; // STORAGE[0xe]\nuint256 stor_a_0_0; // STORAGE[0xa] bytes 0 to 0\nuint256 stor_d_0_0; // STORAGE[0xd] bytes 0 to 0\nuint256 stor_f_0_0; // STORAGE[0xf] bytes 0 to 0\nuint256 ___function_selector__; // STORAGE[0x3] bytes 0 to 19\nuint256 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\nuint256 stor_d_0_19; // STORAGE[0xd] bytes 0 to 19\nmapping (uint256 => uint256) owner_ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5; // STORAGE[0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5]\n\n\n// Events\nDeposit(address, address, uint256, uint256);\nTrade(address, address, uint256, uint256, uint256, address, address);\nCancel(address, bytes32, uint256);\nClaim(address, uint256);\nWithdraw(address, address, uint256, uint256);\n\nfunction 0x1914(address varg0) private { \n    v0 = map_e[varg0];\n    if (stor_b <= 0x19d971e4fe8401e74000000) {\n        v1 = v2 = stor_b > 0x14adf4b7320334b90000000;\n        if (v2) {\n            v1 = v3 = stor_b <= 0x19d971e4fe8401e74000000;\n        }\n        if (!v1) {\n            v4 = v5 = stor_b > 0xf8277896582678ac000000;\n            if (v5) {\n                v4 = v6 = stor_b <= 0x14adf4b7320334b90000000;\n            }\n            if (!v4) {\n                v7 = v8 = stor_b > 0xa56fa5b99019a5c8000000;\n                if (v8) {\n                    v7 = v9 = stor_b <= 0xf8277896582678ac000000;\n                }\n                if (!v7) {\n                    v10 = v11 = stor_b > 10 ** 26;\n                    if (v11) {\n                        v10 = v12 = stor_b <= 0xa56fa5b99019a5c8000000;\n                    }\n                    if (!v10) {\n                        if (stor_b > 10 ** 26) {\n                            return 0;\n                        } else {\n                            v13 = v14 = 10 ** 18;\n                            v15 = v16 = v0 * 0x6f05b59d3b20000;\n                        }\n                    } else {\n                        v13 = v17 = 10 ** 18;\n                        v15 = v18 = v0 * 0x853a0d2313c0000;\n                    }\n                } else {\n                    v13 = v19 = 10 ** 18;\n                    v15 = v20 = v0 * 0x9b6e64a8ec60000;\n                }\n            } else {\n                v13 = v21 = 10 ** 18;\n                v15 = v22 = v0 * 0xb1a2bc2ec500000;\n            }\n        } else {\n            v13 = v23 = 10 ** 18;\n            v15 = v24 = v0 * 0xc7d713b49da0000;\n        }\n        return v15 / v13;\n    } else {\n        return v0;\n    }\n}\n\nfunction function_selector() public nonPayable { \n    revert();\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = !varg1;\n    if (varg1) {\n        assert(bool(varg1));\n        v0 = varg0 * varg1 / varg1 == varg0;\n    }\n    assert(bool(v0));\n    return varg0 * varg1;\n}\n\nfunction 0xada(uint256 varg0, struct(6) varg1, uint256 varg2, uint8 varg3, uint256 varg4, address varg5) private { \n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v0, /* address */ v1 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', varg4), varg3, varg2, MEM[(varg0 << 5) + varg1]);\n    require(bool(v0));\n    return varg5 == address(v1);\n}\n\nfunction 0xe9b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    assert(varg0 / varg1 <= varg2);\n    return varg2 - varg0 / varg1;\n}\n\nfunction 0xff2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1 + varg2;\n    assert(v0 >= varg2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector(bytes4 function_selector, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x58fe7d9) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            map_e[address(varg1)] = varg2;\n            exit;\n        } else if (0xe316ab7 == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            owner_5[address(varg1)] = bytes31(owner_5[address(address(varg1))]);\n            exit;\n        } else if (0x1077666e == v0) {\n            require(!msg.value);\n            return stor_b;\n        } else if (0x16c38b3c == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            stor_f_0_0 = varg1;\n            stor_f_0_0 = varg1;\n            exit;\n        } else if (0x2f334652 == v0) {\n            require(!msg.value);\n            return stor_9;\n        } else if (0x338b5dea == v0) {\n            require(!msg.value);\n            assert(varg2 + owner_0[address(varg1)][msg.sender] >= owner_0[address(varg1)][msg.sender]);\n            owner_0[address(varg1)][msg.sender] += varg2;\n            MEM[32 + MEM[64]] = 0;\n            require(bool((address(address(varg1))).code.size));\n            v1, /* bool */ v2 = address(varg1).transferFrom(msg.sender, address(this), varg2).gas(msg.gas - 710);\n            require(bool(v1));\n            require(bool(v2));\n            emit Deposit(address(varg1), msg.sender, varg2, owner_0[address(varg1)][msg.sender]);\n            exit;\n        } else if (0x3f392b42 == v0) {\n            require(!msg.value);\n            v3 = MEM[64];\n            CALLDATACOPY(v3, 4, 160);\n            v4 = MEM[64];\n            CALLDATACOPY(v4, 164, 352);\n            CALLDATACOPY(MEM[64], 516, 96);\n            v5 = new struct(6);\n            CALLDATACOPY(v5, 612, 192);\n            require(!stor_f_0_0);\n            require(bool(owner_5[address(MEM[v3 + 128])]));\n            require(map_6[address(MEM[v3 + 64])] < MEM[v4 + 64]);\n            require(map_6[address(MEM[v3 + 96])] < MEM[v4 + 160]);\n            v6 = v7 = MEM[v4 + 192] > 0;\n            if (v7) {\n                v6 = v8 = MEM[v4 + 224] > 0;\n            }\n            if (v6) {\n                v6 = v9 = MEM[v4 + 256] > 0;\n            }\n            require(bool(v6));\n            v10 = v11 = MEM[v4 + 32] >= MEM[v4 + 224];\n            if (MEM[v4 + 32] >= MEM[v4 + 224]) {\n                v10 = v12 = MEM[v4 + 128] >= MEM[v4 + 224];\n            }\n            require(bool(v10));\n            v13 = v14 = msg.sender == address(MEM[v3 + 64]);\n            if (msg.sender != address(MEM[v3 + 64])) {\n                v13 = v15 = msg.sender == address(MEM[v3 + 96]);\n            }\n            if (!v13) {\n                v13 = v16 = msg.sender == address(MEM[v3 + 128]);\n            }\n            require(bool(v13));\n            v17 = keccak256(address(this), address(MEM[v3]), address(MEM[v3 + 32]), address(MEM[v3 + 64]), MEM[v4], MEM[v4 + 32], MEM[v4 + 64]);\n            v18 = keccak256(address(this), address(MEM[v3]), address(MEM[v3 + 32]), address(MEM[v3 + 96]), MEM[v4 + 96], MEM[v4 + 128], MEM[v4 + 160]);\n            v19 = 0xada(1, v5, v5.word0, MEM[MEM[64]], v17, MEM[v3 + 64]);\n            require(bool(v19));\n            v20 = 0xada(3, v5, v5.word2, MEM[MEM[64] + 32], v18, MEM[v3 + 96]);\n            require(bool(v20));\n            v21 = keccak256(address(this), v17, v18, address(MEM[v3 + 128]), MEM[v4 + 192], MEM[v4 + 224], MEM[v4 + 256], MEM[v4 + 288], MEM[320 + v4]);\n            v22 = 0xada(5, v5, v5.word4, MEM[MEM[64] + 64], v21, MEM[v3 + 128]);\n            require(bool(v22));\n            require(!uint8(map_1[v21]));\n            map_1[v21] = 0x1 | bytes31(map_1[v21]);\n            assert(MEM[192 + v4] + map_2[v17] >= map_2[v17]);\n            require(MEM[192 + v4] + map_2[v17] <= MEM[v4]);\n            assert(MEM[192 + v4] + map_2[v18] >= map_2[v18]);\n            require(MEM[192 + v4] + map_2[v18] <= MEM[v4 + 96]);\n            require(owner_0[address(MEM[v3 + 32])][address(MEM[v3 + 64])] >= MEM[v4 + 224]);\n            assert(MEM[224 + v4] <= owner_0[address(MEM[v3 + 32])][address(MEM[v3 + 64])]);\n            owner_0[address(MEM[v3 + 32])][address(MEM[v3 + 64])] = owner_0[address(MEM[v3 + 32])][address(MEM[v3 + 64])] - MEM[224 + v4];\n            require(owner_0[address(MEM[v3])][address(MEM[v3 + 96])] >= MEM[v4 + 192]);\n            assert(MEM[192 + v4] <= owner_0[address(MEM[v3])][address(MEM[v3 + 96])]);\n            owner_0[address(MEM[v3])][address(MEM[v3 + 96])] = owner_0[address(MEM[v3])][address(MEM[v3 + 96])] - MEM[192 + v4];\n            v23 = v24 = 3750;\n            v25 = v26 = owner_0[address(MEM[v3])][address(MEM[v3 + 64])];\n            v27 = v28 = 18010;\n            v29 = v30 = MEM[v4 + 192];\n            v31 = v32 = 10 ** 18;\n            v33 = v34 = MEM[288 + v4] * MEM[v4 + 192];\n            v35 = v36 = !MEM[v4 + 192];\n            if (MEM[v4 + 192]) {\n                assert(bool(MEM[v4 + 192]));\n                v35 = v37 = v34 / MEM[v4 + 192] == MEM[288 + v4];\n            }\n            assert(bool(v35));\n            while (!bool(v31)) {\n                assert(v33 / v31 <= v29);\n                v38 = v39 = v29 - v33 / v31;\n                // Unknown jump to Block {'0x467e', '0x465a'}. Refer to 3-address code (TAC);\n                while (v38 + v25 < v25) {\n                    // Unknown jump to Block {'0xea6', '0x1080', '0xf54', '0xff8'}. Refer to 3-address code (TAC);\n                    owner_0[address(MEM[v3 + 32])][address(MEM[v3 + 96])] = v38 + v25;\n                    v23 = v40 = 4088;\n                    v25 = v41 = owner_0[address(MEM[v3])][stor_4_0_19];\n                    v42 = v43 = 10 ** 18;\n                    v44 = v45 = MEM[288 + v4] * MEM[v4 + 192];\n                    v46 = v47 = !MEM[v4 + 192];\n                    if (MEM[v4 + 192]) {\n                        assert(bool(MEM[v4 + 192]));\n                        v46 = v48 = v45 / MEM[v4 + 192] == MEM[288 + v4];\n                    }\n                    assert(bool(v46));\n                    assert(bool(v42));\n                    v38 = v44 / v42;\n                    owner_0[address(MEM[v3])][stor_4_0_19] = v38 + v25;\n                    v23 = v49 = 4224;\n                    v25 = v50 = owner_0[address(MEM[32 + v3])][stor_4_0_19];\n                    v42 = v51 = 10 ** 18;\n                    v44 = MEM[320 + v4] * MEM[v4 + 224];\n                    v52 = v53 = !MEM[v4 + 224];\n                    if (MEM[v4 + 224]) {\n                        assert(bool(MEM[v4 + 224]));\n                        v52 = v54 = v44 / MEM[v4 + 224] == MEM[320 + v4];\n                    }\n                    assert(bool(v52));\n                }\n                throw();\n                owner_0[address(MEM[v3])][address(MEM[v3 + 64])] = v38 + v25;\n                v23 = v55 = 3924;\n                v25 = v56 = owner_0[address(MEM[32 + v3])][address(MEM[v3 + 96])];\n                v27 = v57 = 18046;\n                v29 = v58 = MEM[v4 + 224];\n                v31 = v59 = 10 ** 18;\n                v33 = MEM[320 + v4] * MEM[v4 + 224];\n                v60 = v61 = !MEM[v4 + 224];\n                if (MEM[v4 + 224]) {\n                    assert(bool(MEM[v4 + 224]));\n                    v60 = v62 = v33 / MEM[v4 + 224] == MEM[320 + v4];\n                }\n                assert(bool(v60));\n                owner_0[address(MEM[v3 + 32])][stor_4_0_19] = v38 + v25;\n                assert(MEM[192 + v4] + map_2[v17] >= map_2[v17]);\n                map_2[v17] += MEM[192 + v4];\n                assert(MEM[192 + v4] + map_2[v18] >= map_2[v18]);\n                map_2[v18] += MEM[192 + v4];\n                emit Trade(address(MEM[v3]), address(MEM[v3 + 32]), MEM[v4 + 192], MEM[v4 + 224], MEM[v4 + 256], address(MEM[v3 + 64]), address(MEM[96 + v3]));\n                if (stor_b > 0) {\n                    if (map_e[address(MEM[v3 + 32])] > 0) {\n                        v63 = 0x1914(MEM[v3 + 32]);\n                        v64 = _SafeMul(v63, MEM[v4 + 224]);\n                        v65 = _SafeMul(2, v64);\n                        assert(bool(10 ** 18));\n                        if (stor_b <= v65 / 10 ** 18) {\n                            v66 = 0xe9b(stor_b, 2, stor_b);\n                            assert(v66 + owner_c[address(MEM[v3 + 64])] >= owner_c[address(MEM[v3 + 64])]);\n                            owner_c[address(MEM[v3 + 64])] += v66;\n                            v67 = 0xff2(stor_b, 2, owner_c[address(MEM[v3 + 96])]);\n                            owner_c[address(MEM[v3 + 96])] = v67;\n                            stor_b = 0;\n                        } else {\n                            v68 = 0xe9b(v65 / 10 ** 18, 2, v65 / 10 ** 18);\n                            assert(v68 + owner_c[address(MEM[v3 + 64])] >= owner_c[address(MEM[v3 + 64])]);\n                            owner_c[address(MEM[v3 + 64])] += v68;\n                            v69 = 0xff2(v65 / 10 ** 18, 2, owner_c[address(MEM[v3 + 96])]);\n                            owner_c[address(MEM[v3 + 96])] = v69;\n                            assert(v65 / 10 ** 18 <= stor_b);\n                            stor_b = stor_b - v65 / 10 ** 18;\n                        }\n                    }\n                }\n                return True;\n                // Unknown jump to Block 0x1fa50x0. Refer to 3-address code (TAC);\n            }\n            throw();\n        } else if (0x432607fc == v0) {\n            require(!msg.value);\n            require(bool(owner_5[address(msg.sender)]));\n            v70 = keccak256(address(this), address(varg1), address(varg2), address(varg3), varg4, varg5, varg6);\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            v71, /* address */ v72 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v70), uint8(varg7), varg8, varg9);\n            require(bool(v71));\n            require(address(varg3) == address(v72));\n            map_2[v70] = varg4;\n            emit Cancel(address(varg3), v70, varg6);\n            return True;\n        } else if (0x4574f327 == v0) {\n            require(!msg.value);\n            return owner_c[address(varg1)];\n        } else if (0x4b023cf8 == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            stor_4_0_19 = address(varg1);\n            exit;\n        } else if (0x4e71d92d == v0) {\n            require(!msg.value);\n            require(owner_c[msg.sender] > 0);\n            require(stor_d_0_0);\n            owner_c[msg.sender] = 0;\n            MEM[32 + MEM[64]] = 0;\n            require(bool(stor_d_0_19.code.size));\n            v73, /* bool */ v74 = stor_d_0_19.transfer(msg.sender, owner_c[msg.sender]).gas(msg.gas - 710);\n            require(bool(v73));\n            require(bool(v74));\n            emit Claim(msg.sender, owner_c[msg.sender]);\n            return True;\n        } else if (0x5c975abb == v0) {\n            require(!msg.value);\n            return stor_f_0_0;\n        } else if (0x635e2cdb == v0) {\n            require(!msg.value);\n            return map_6[address(varg1)];\n        } else if (0x65e17c9d == v0) {\n            require(!msg.value);\n            return stor_4_0_19;\n        } else if (0x6e0ca71a == v0) {\n            require(!msg.value);\n            return map_e[address(varg1)];\n        } else if (0x7039dcdc == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            stor_d_0_19 = address(varg1);\n            exit;\n        } else if (0x736c0d5b == v0) {\n            require(!msg.value);\n            return bool(owner_5[address(varg1)]);\n        } else if (0x8163681e == v0) {\n            require(!msg.value);\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            v75, /* address */ v76 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', varg2), uint8(varg3), varg4, varg5);\n            require(bool(v75));\n            return address(varg1) == address(v76);\n        } else if (0x89e96773 == v0) {\n            require(!msg.value);\n            return stor_d_0_19;\n        } else if (0x8da5cb5b == v0) {\n            require(!msg.value);\n            return ___function_selector__;\n        } else if (0x99ccbec6 == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            assert(stor_b <= stor_a);\n            require(stor_a - stor_b > 0);\n            v77 = _SafeMul(stor_a - stor_b, stor_8);\n            assert(stor_a_0_0);\n            assert(stor_9 <= v77 / stor_a);\n            require(v77 / stor_a - stor_9 > 0);\n            stor_9 = v77 / stor_a;\n            MEM[32 + MEM[64]] = 0;\n            require(bool(stor_d_0_19.code.size));\n            v78, /* bool */ v79 = stor_d_0_19.transfer(msg.sender, v77 / stor_a - stor_9).gas(msg.gas - 710);\n            require(bool(v78));\n            require(bool(v79));\n            emit Claim(msg.sender, v77 / stor_a - stor_9);\n            return True;\n        } else if (0xa85d3179 == v0) {\n            require(!msg.value);\n            v80 = 0x1914(address(varg1));\n            return v80;\n        } else if (0xae82fcf4 == v0) {\n            require(!msg.value);\n            return stor_8;\n        } else if (0xbce4d041 == v0) {\n            require(!msg.value);\n            require(bool(owner_5[address(msg.sender)]));\n            require(varg2 > map_6[address(varg1)]);\n            map_6[address(varg1)] = varg2;\n            exit;\n        } else if (0xc23f001f == v0) {\n            require(!msg.value);\n            return owner_0[address(varg1)][address(varg2)];\n        } else if (0xcaaacb12 == v0) {\n            require(!msg.value);\n            return stor_a;\n        } else if (0xd0e30db0 == v0) {\n            assert(msg.value + owner_ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5[msg.sender] >= owner_ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5[msg.sender]);\n            owner_ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5[msg.sender] += msg.value;\n            emit Deposit(address(0x0), msg.sender, msg.value, msg.value + owner_ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5[msg.sender]);\n            exit;\n        } else if (0xd5813323 == v0) {\n            require(!msg.value);\n            return bool(map_1[varg1]);\n        } else if (0xd5ca35bc == v0) {\n            require(!msg.value);\n            require(owner_0[address(varg1)][msg.sender] >= varg2);\n            require(bool(owner_5[address(address(varg4))]));\n            v81 = keccak256(address(this), msg.sender, address(varg1), varg2, varg3);\n            MEM[MEM[64]] = 0;\n            MEM[32 + MEM[64]] = 0;\n            v82, /* address */ v83 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v81), uint8(varg5), varg6, varg7);\n            require(bool(v82));\n            require(address(varg4) == address(v83));\n            require(!uint8(owner_7[v81]));\n            owner_7[v81] = 0x1 | bytes31(owner_7[v81]);\n            assert(varg2 <= owner_0[address(varg1)][msg.sender]);\n            owner_0[address(varg1)][msg.sender] = owner_0[address(varg1)][msg.sender] - varg2;\n            if (bool(address(address(varg1)))) {\n                MEM[32 + MEM[64]] = 0;\n                require(bool((address(address(varg1))).code.size));\n                v84, /* bool */ v85 = address(varg1).transfer(msg.sender, varg2).gas(msg.gas - 710);\n                require(bool(v84));\n                require(bool(v85));\n            } else {\n                v86 = msg.sender.call().value(varg2).gas(2300 * !varg2);\n                require(bool(v86));\n            }\n            emit Withdraw(address(varg1), msg.sender, varg2, owner_0[address(varg1)][msg.sender]);\n            exit;\n        } else if (0xe09ab428 == v0) {\n            require(!msg.value);\n            return bool(owner_7[varg1]);\n        } else if (0xeb12d61e == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            owner_5[address(varg1)] = 0x1 | bytes31(owner_5[address(address(varg1))]);\n            exit;\n        } else if (0xf2fde38b == v0) {\n            require(!msg.value);\n            require(___function_selector__ == msg.sender);\n            if (address(varg1)) {\n                ___function_selector__ = address(varg1);\n            }\n            exit;\n        } else if (0xf7213db6 == v0) {\n            require(!msg.value);\n            return map_2[varg1];\n        } else if (0xf7888aec == v0) {\n            require(!msg.value);\n            return owner_0[address(varg1)][address(varg2)];\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}