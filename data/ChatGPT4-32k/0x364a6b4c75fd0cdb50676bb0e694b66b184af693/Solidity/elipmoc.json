{
	"address": "0x364a6b4c75fd0cdb50676bb0e694b66b184af693",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the recompiled Solidity code based on the decompiled code provided:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balanceOf;\n    string private _name;\n    string private _symbol;\n    string private _standard;\n    address private _owner;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(string memory name, string memory symbol, string memory standard, uint8 decimals, uint256 totalSupply) {\n        _name = name;\n        _symbol = symbol;\n        _standard = standard;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        _balanceOf[msg.sender] = totalSupply;\n        _owner = msg.sender;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function withdraw() public {\n        require(_owner == msg.sender);\n        payable(_owner).transfer(address(this).balance);\n    }\n\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function changeOwner(address newOwner) public {\n        require(_owner == msg.sender);\n        _owner = newOwner;\n    }\n\n    function transfer(address recipient, uint256 amount) public {\n        require(_balanceOf[msg.sender] >= amount);\n        _balanceOf[msg.sender] -= amount;\n        _balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n    }\n\n    function killMe() public {\n        require(_owner == msg.sender);\n        selfdestruct(payable(_owner));\n    }\n\n    fallback() external payable {\n        require(_balanceOf[address(this)] > 0);\n        uint256 v0 = 0x152d02c7e14af6800000 * msg.value / 0xde0b6b3a7640000;\n        if (v0 > _balanceOf[address(this)]) {\n            v0 = _balanceOf[address(this)];\n            assert(0x152d02c7e14af6800000 != 0);\n            payable(msg.sender).transfer(msg.value - v0 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000);\n        }\n        require(v0 > 0);\n        _balanceOf[msg.sender] += v0;\n        _balanceOf[address(this)] -= v0;\n        emit Transfer(address(this), msg.sender, v0);\n    }\n}\n```\nPlease note that some parts of the decompiled code were not fully clear, and thus some assumptions had to be made during recompilation. The original contract might have had additional functionality or checks that are not included in this version.",
				"role": "assistant"
			}
		}
	],
	"created": 1701467103,
	"id": "chatcmpl-8R5bjoEF7MnwWbx3ggMgCH96Qih1h",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 19:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256[] _standard; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction standard() public nonPayable { \n    v0 = new bytes[](_standard.length);\n    v1 = v2 = v0.data;\n    if (_standard.length) {\n        if (31 < _standard.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _standard.length <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction killMe() public nonPayable { \n    require(_owner == msg.sender);\n    selfdestruct(_owner);\n}\n\nfunction fallback() public payable { \n    require(_balanceOf[address(this)] > 0);\n    v0 = v1 = 0x152d02c7e14af6800000 * msg.value / 0xde0b6b3a7640000;\n    if (v1 > _balanceOf[address(this)]) {\n        v0 = v2 = _balanceOf[address(this)];\n        assert(0x152d02c7e14af6800000);\n        v3 = msg.sender.call().value(msg.value - v2 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000).gas(!(msg.value - v2 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000) * 2300);\n        require(v3);\n    }\n    require(v0 > 0);\n    _balanceOf[msg.sender] += v0;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    emit Transfer(address(this), msg.sender, v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb603cd80 == function_selector) {\n            killMe();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 19:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256[] _standard; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction standard() public nonPayable { \n    v0 = new bytes[](_standard.length);\n    v1 = v2 = v0.data;\n    if (_standard.length) {\n        if (31 < _standard.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _standard.length <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction killMe() public nonPayable { \n    require(_owner == msg.sender);\n    selfdestruct(_owner);\n}\n\nfunction fallback() public payable { \n    require(_balanceOf[address(this)] > 0);\n    v0 = v1 = 0x152d02c7e14af6800000 * msg.value / 0xde0b6b3a7640000;\n    if (v1 > _balanceOf[address(this)]) {\n        v0 = v2 = _balanceOf[address(this)];\n        assert(0x152d02c7e14af6800000);\n        v3 = msg.sender.call().value(msg.value - v2 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000).gas(!(msg.value - v2 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000) * 2300);\n        require(v3);\n    }\n    require(v0 > 0);\n    _balanceOf[msg.sender] += v0;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    emit Transfer(address(this), msg.sender, v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb603cd80 == function_selector) {\n            killMe();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 19:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256[] _standard; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction standard() public nonPayable { \n    v0 = new bytes[](_standard.length);\n    v1 = v2 = v0.data;\n    if (_standard.length) {\n        if (31 < _standard.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _standard.length <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction killMe() public nonPayable { \n    require(_owner == msg.sender);\n    selfdestruct(_owner);\n}\n\nfunction fallback() public payable { \n    require(_balanceOf[address(this)] > 0);\n    v0 = v1 = 0x152d02c7e14af6800000 * msg.value / 0xde0b6b3a7640000;\n    if (v1 > _balanceOf[address(this)]) {\n        v0 = v2 = _balanceOf[address(this)];\n        assert(0x152d02c7e14af6800000);\n        v3 = msg.sender.call().value(msg.value - v2 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000).gas(!(msg.value - v2 * 0xde0b6b3a7640000 / 0x152d02c7e14af6800000) * 2300);\n        require(v3);\n    }\n    require(v0 > 0);\n    _balanceOf[msg.sender] += v0;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    emit Transfer(address(this), msg.sender, v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb603cd80 == function_selector) {\n            killMe();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 24.839666604995728,
	"usage": {
		"completion_tokens": 697,
		"prompt_tokens": 1780,
		"total_tokens": 2477
	}
}