{
	"address": "0xc5fd320ef9b3047872dd089f6b4c026cc8c5b617",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code corresponding to the provided decompiled EVM Bytecode:\n\n```Solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _founderTokenCount;\n    uint256 private _reserveTokenCount;\n    uint256 private _shpExchangeRate;\n    mapping(uint256 => uint256[]) private _approvedAddresses;\n    uint256 private _etherPaid;\n    uint256 private _totalContributions;\n    uint256 private _minPresaleContributionEther;\n    uint256 private _maxPresaleContributionEther;\n    uint256 private _minDiscountEther;\n    uint256 private _firstTierDiscountUpperLimitEther;\n    uint256 private _secondTierDiscountUpperLimitEther;\n    uint256 private _thirdTierDiscountUpperLimitEther;\n    address private _setShpExchangeRate;\n    bool private _paused;\n    bool private _closed;\n    bool private _allowTransfer;\n    address private _newOwner;\n    address private _shp;\n    address private _trustee;\n    address private _etherEscrowAddress;\n    address private _bountyAddress;\n    address private _trusteeAddress;\n\n    event SaleClosed(uint256 timestamp);\n    event DiscountApplied(uint256 value, uint256 v19, uint256 v20);\n    event CountersUpdated(uint256 _etherPaid, uint256 value);\n    event NewSale(address sender, uint256 value, uint256 v43);\n\n    // assuming that all functions are public and non-payable\n    // and the contract has functions that correspond to the function selectors\n    function safeMul(uint256 a, uint256 b) public pure returns (uint256) {\n        uint256 c = a * b;\n        require(b == 0 || c / a == b, \"SafeMul: multiplication overflow\");\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) public pure returns (uint256) {\n        require(b > 0, \"SafeDiv: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeAdd: addition overflow\");\n        return c;\n    }\n\n    // other functions should be here.\n\n    function setShpExchangeRate(uint256 varg0) public { \n        require(_setShpExchangeRate == msg.sender, \"Only owner can call this function.\");\n        _shpExchangeRate = varg0;\n    }\n\n    // other functions should be here.\n}\n```\nPlease note that this is just a part of the contract as the decompiled code provided is incomplete and doesn't provide the full context of the contract. The actual smart contract could be more complex and have many more functions and conditions. Also, some of the variables and functions in the decompiled code may not be accurately translated to Solidity due to ambiguity and lack of context in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701458178,
	"id": "chatcmpl-8R3HmSAA3cbuSuAxwBo5V22CrHIPM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 18:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _founderTokenCount; // STORAGE[0x7]\nuint256 _reserveTokenCount; // STORAGE[0x8]\nuint256 _shpExchangeRate; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _approvedAddresses; // STORAGE[0xb]\nuint256 _etherPaid; // STORAGE[0xc]\nuint256 _totalContributions; // STORAGE[0xd]\nuint256 _minPresaleContributionEther; // STORAGE[0xe]\nuint256 _maxPresaleContributionEther; // STORAGE[0xf]\nuint256 _minDiscountEther; // STORAGE[0x10]\nuint256 _firstTierDiscountUpperLimitEther; // STORAGE[0x11]\nuint256 _secondTierDiscountUpperLimitEther; // STORAGE[0x12]\nuint256 _thirdTierDiscountUpperLimitEther; // STORAGE[0x13]\naddress _setShpExchangeRate; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0xa] bytes 0 to 0\nuint8 _closed; // STORAGE[0xa] bytes 1 to 1\nuint8 _allowTransfer; // STORAGE[0xa] bytes 2 to 2\nuint160 _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _shp; // STORAGE[0x2] bytes 0 to 19\naddress _trustee; // STORAGE[0x3] bytes 0 to 19\naddress _etherEscrowAddress; // STORAGE[0x4] bytes 0 to 19\nuint160 _bountyAddress; // STORAGE[0x5] bytes 0 to 19\nuint160 _trusteeAddress; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nSaleClosed(uint256);\nDiscountApplied(uint256, uint256, uint256);\nCountersUpdated(uint256, uint256);\nNewSale(address, uint256, uint256);\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction setAllowTransfer(bool varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _allowTransfer = varg0;\n}\n\nfunction mintTokens(uint256 varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v0, v1 = _shp.generateTokens(varg1, varg0).gas(msg.gas - 710);\n    require(v0);\n    emit NewSale(varg1, 0, varg0);\n}\n\nfunction FOURTH_TIER_DISCOUNT() public nonPayable { \n    return 30;\n}\n\nfunction totalContributions() public nonPayable { \n    return _totalContributions;\n}\n\nfunction etherEscrowAddress() public nonPayable { \n    return _etherEscrowAddress;\n}\n\nfunction trusteeAddress() public nonPayable { \n    return _trusteeAddress;\n}\n\nfunction onApprove(address varg0, address varg1, uint256 varg2) public nonPayable { \n    return _allowTransfer;\n}\n\nfunction pauseContribution() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _paused = 1;\n}\n\nfunction firstTierDiscountUpperLimitEther() public nonPayable { \n    return _firstTierDiscountUpperLimitEther;\n}\n\nfunction THIRD_TIER_DISCOUNT() public nonPayable { \n    return 20;\n}\n\nfunction closed() public nonPayable { \n    return _closed;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction setShpExchangeRate(uint256 varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _shpExchangeRate = varg0;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    require(_closed);\n    require(varg0);\n    require(varg1);\n    require(_shp.code.size);\n    v0 = _shp.changeController(varg0).gas(msg.gas - 710);\n    require(v0);\n    require(_trustee.code.size);\n    v1 = _trustee.changeOwner(varg1).gas(msg.gas - 710);\n    require(v1);\n}\n\nfunction founderTokenCount() public nonPayable { \n    return _founderTokenCount;\n}\n\nfunction shpExchangeRate() public nonPayable { \n    return _shpExchangeRate;\n}\n\nfunction shp() public nonPayable { \n    return _shp;\n}\n\nfunction CALLER_EXCHANGE_SHARE() public nonPayable { \n    return 40;\n}\n\nfunction pegEtherValues(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _minDiscountEther = varg0;\n    _firstTierDiscountUpperLimitEther = varg1;\n    _secondTierDiscountUpperLimitEther = varg2;\n    _thirdTierDiscountUpperLimitEther = varg3;\n    _minPresaleContributionEther = varg4;\n    _maxPresaleContributionEther = varg5;\n}\n\nfunction SECOND_TIER_DISCOUNT() public nonPayable { \n    return 10;\n}\n\nfunction minDiscountEther() public nonPayable { \n    return _minDiscountEther;\n}\n\nfunction owner() public nonPayable { \n    return _setShpExchangeRate;\n}\n\nfunction thirdTierDiscountUpperLimitEther() public nonPayable { \n    return _thirdTierDiscountUpperLimitEther;\n}\n\nfunction allowTransfer() public nonPayable { \n    return _allowTransfer;\n}\n\nfunction reserveTokenCount() public nonPayable { \n    return _reserveTokenCount;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    if (_setShpExchangeRate == msg.sender) {\n        _setShpExchangeRate = varg0;\n        goto 0x28e0x69b;\n    }\n}\n\nfunction secondTierDiscountUpperLimitEther() public nonPayable { \n    return _secondTierDiscountUpperLimitEther;\n}\n\nfunction maxPresaleContributionEther() public nonPayable { \n    return _maxPresaleContributionEther;\n}\n\nfunction resumeContribution() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _paused = 0;\n}\n\nfunction minPresaleContributionEther() public nonPayable { \n    return _minPresaleContributionEther;\n}\n\nfunction etherPaid() public nonPayable { \n    return _etherPaid;\n}\n\nfunction bountyAddress() public nonPayable { \n    return _bountyAddress;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction destroyTokens(uint256 varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v0, v1 = _shp.destroyTokens(varg1, varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction MAX_GAS_PRICE() public nonPayable { \n    return 0x48c27395000;\n}\n\nfunction FIRST_TIER_DISCOUNT() public nonPayable { \n    return 5;\n}\n\nfunction closeSale() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _closed = 1;\n    emit SaleClosed(block.timestamp);\n}\n\nfunction approvedAddresses(address varg0) public nonPayable { \n    return 0xff & _approvedAddresses[varg0];\n}\n\nfunction proxyPayment(address varg0) public payable { \n    return _allowTransfer;\n}\n\nfunction setShp(address varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _shp = varg0;\n}\n\nfunction trustee() public nonPayable { \n    return _trustee;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xb81e216) {\n            setAllowTransfer(bool);\n        } else if (0x10c5b328 == v0) {\n            mintTokens(uint256,address);\n        } else {\n            if (0x1cc8092f != v0) {\n                if (0x37c08923 == v0) {\n                    totalContributions();\n                } else if (0x495e1b3d == v0) {\n                    etherEscrowAddress();\n                } else if (0x49c1d54d == v0) {\n                    trusteeAddress();\n                } else {\n                    if (0x4a393149 != v0) {\n                        if (0x4b8adcf7 == v0) {\n                            pauseContribution();\n                        } else if (0x4ecb02aa == v0) {\n                            firstTierDiscountUpperLimitEther();\n                        } else {\n                            if (0x53f95cc6 != v0) {\n                                if (0x597e1fb5 == v0) {\n                                    closed();\n                                } else if (0x5bb0fa46 != v0) {\n                                    if (0x5c975abb == v0) {\n                                        paused();\n                                    } else if (0x5f596681 == v0) {\n                                        setShpExchangeRate(uint256);\n                                    } else if (0x6d435421 == v0) {\n                                        transferOwnership(address,address);\n                                    } else if (0x73a1f366 == v0) {\n                                        founderTokenCount();\n                                    } else if (0x788e0760 == v0) {\n                                        shpExchangeRate();\n                                    } else if (0x81d92ed4 == v0) {\n                                        shp();\n                                    } else if (0x845ec8de != v0) {\n                                        if (0x85f07a2b == v0) {\n                                            CALLER_EXCHANGE_SHARE();\n                                        } else if (0x86bb1b24 == v0) {\n                                            pegEtherValues(uint256,uint256,uint256,uint256,uint256,uint256);\n                                        } else {\n                                            if (0x87369c4b != v0) {\n                                                if (0x88df31f0 == v0) {\n                                                    minDiscountEther();\n                                                } else if (0x8da5cb5b == v0) {\n                                                    owner();\n                                                } else if (0x95c26d93 == v0) {\n                                                    thirdTierDiscountUpperLimitEther();\n                                                } else if (0x9b08a22f == v0) {\n                                                    allowTransfer();\n                                                } else if (0x9b99a8e2 == v0) {\n                                                    reserveTokenCount();\n                                                } else if (0xa6f9dae1 == v0) {\n                                                    changeOwner(address);\n                                                } else if (0xa78f0489 == v0) {\n                                                    secondTierDiscountUpperLimitEther();\n                                                } else if (0xb3e53d8a == v0) {\n                                                    maxPresaleContributionEther();\n                                                } else if (0xb681f9f6 == v0) {\n                                                    resumeContribution();\n                                                } else if (0xc1e74d71 == v0) {\n                                                    minPresaleContributionEther();\n                                                } else if (0xc257eabb == v0) {\n                                                    etherPaid();\n                                                } else if (0xc516358f == v0) {\n                                                    bountyAddress();\n                                                } else if (0xd4ee1d90 == v0) {\n                                                    newOwner();\n                                                } else if (0xda682aeb != v0) {\n                                                    if (0xe16385fc == v0) {\n                                                        destroyTokens(uint256,address);\n                                                    } else if (0xe3bbb4f1 == v0) {\n                                                        MAX_GAS_PRICE();\n                                                    } else if (0xe3d7f159 == v0) {\n                                                        FIRST_TIER_DISCOUNT();\n                                                    } else if (0xed4dd2ab != v0) {\n                                                        if (0xee55efee == v0) {\n                                                            closeSale();\n                                                        } else if (0xf136a874 == v0) {\n                                                            approvedAddresses(address);\n                                                        } else if (0xf48c3054 == v0) {\n                                                            proxyPayment(address);\n                                                        } else if (0xfa9df423 == v0) {\n                                                            setShp(address);\n                                                        } else if (0xfdf97cb2 == v0) {\n                                                            trustee();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            SECOND_TIER_DISCOUNT();\n                                        }\n                                    }\n                                }\n                            }\n                            THIRD_TIER_DISCOUNT();\n                        }\n                    }\n                    onApprove(address,address,uint256);\n                }\n            }\n            FOURTH_TIER_DISCOUNT();\n        }\n    }\n    require(msg.sender);\n    require(msg.value > 0);\n    require(msg.sender.code.size <= 0);\n    require(msg.gas <= 0x48c27395000);\n    require(!_closed);\n    require(!_paused);\n    require(msg.value > 0);\n    v1 = v2 = 0;\n    v1 = v3 = 0;\n    emit 0x4e75fda068b8e114d7658bdff74280a0fd65586b7e026a034eae29dd5a9e68b(msg.value, msg.sender);\n    v4 = v5 = 2522;\n    v6 = v7 = 100;\n    v8 = v9 = _SafeMul(40, _shpExchangeRate);\n    while (1) {\n        v1 = _SafeDiv(v6, v8);\n        v4 = v10 = 2563;\n        v6 = v11 = 100;\n        v8 = v12 = _SafeMul(30, _shpExchangeRate);\n        v4 = v13 = 2604;\n        v6 = v14 = 100;\n        v8 = v15 = _SafeMul(20, _shpExchangeRate);\n        v4 = v16 = 2645;\n        v6 = v17 = 100;\n        v8 = v18 = _SafeMul(10, _shpExchangeRate);\n    }\n    v19 = _SafeMul(v1, msg.value);\n    v20 = v21 = 0;\n    v22 = v23 = msg.value > _minDiscountEther;\n    if (v23) {\n        v22 = msg.value <= _firstTierDiscountUpperLimitEther;\n    }\n    if (!v22) {\n        v24 = v25 = msg.value > _firstTierDiscountUpperLimitEther;\n        if (v25) {\n            v24 = msg.value <= _secondTierDiscountUpperLimitEther;\n        }\n        if (!v24) {\n            v26 = v27 = msg.value > _secondTierDiscountUpperLimitEther;\n            if (v27) {\n                v26 = msg.value <= _thirdTierDiscountUpperLimitEther;\n            }\n            if (!v26) {\n                if (msg.value > _thirdTierDiscountUpperLimitEther) {\n                    v28 = v29 = 5226;\n                    v30 = v31 = 100;\n                    v32 = v33 = _SafeMul(30, v19);\n                }\n            } else {\n                v28 = v34 = 5045;\n                v30 = v35 = 100;\n                v32 = v36 = _SafeMul(20, v19);\n            }\n        } else {\n            v28 = v37 = 5045;\n            v30 = v38 = 100;\n            v32 = v39 = _SafeMul(10, v19);\n        }\n    } else {\n        v28 = v40 = 5045;\n        v30 = v41 = 100;\n        v32 = v42 = _SafeMul(5, v19);\n    }\n    v20 = _SafeDiv(v30, v32);\n    emit DiscountApplied(msg.value, v19, v20);\n    v43 = _SafeAdd(v19, v20);\n    v44 = _SafeMul(v1, msg.value);\n    v45 = _SafeMul(v1, msg.value);\n    v46 = _SafeMul(v1, msg.value);\n    v47 = _SafeAdd(v44, v45);\n    v48 = _SafeAdd(v45, _founderTokenCount);\n    _founderTokenCount = v48;\n    v49 = _SafeAdd(v44, _reserveTokenCount);\n    _reserveTokenCount = v49;\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v50, v51 = _shp.generateTokens(msg.sender, v43).gas(msg.gas - 710);\n    require(v50);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v52, v53 = _shp.generateTokens(_bountyAddress, v46).gas(msg.gas - 710);\n    require(v52);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v54, v55 = _shp.generateTokens(_trusteeAddress, v47).gas(msg.gas - 710);\n    require(v54);\n    emit NewSale(msg.sender, msg.value, v43);\n    emit NewSale(_trusteeAddress, msg.value, v47);\n    emit NewSale(_bountyAddress, msg.value, v46);\n    v56 = _etherEscrowAddress.call().value(msg.value).gas(2300 * !msg.value);\n    require(v56);\n    v57 = _SafeAdd(msg.value, _etherPaid);\n    _etherPaid = v57;\n    v58 = _SafeAdd(1, _totalContributions);\n    _totalContributions = v58;\n    emit CountersUpdated(_etherPaid, msg.value);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 18:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _founderTokenCount; // STORAGE[0x7]\nuint256 _reserveTokenCount; // STORAGE[0x8]\nuint256 _shpExchangeRate; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _approvedAddresses; // STORAGE[0xb]\nuint256 _etherPaid; // STORAGE[0xc]\nuint256 _totalContributions; // STORAGE[0xd]\nuint256 _minPresaleContributionEther; // STORAGE[0xe]\nuint256 _maxPresaleContributionEther; // STORAGE[0xf]\nuint256 _minDiscountEther; // STORAGE[0x10]\nuint256 _firstTierDiscountUpperLimitEther; // STORAGE[0x11]\nuint256 _secondTierDiscountUpperLimitEther; // STORAGE[0x12]\nuint256 _thirdTierDiscountUpperLimitEther; // STORAGE[0x13]\naddress _setShpExchangeRate; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0xa] bytes 0 to 0\nuint8 _closed; // STORAGE[0xa] bytes 1 to 1\nuint8 _allowTransfer; // STORAGE[0xa] bytes 2 to 2\nuint160 _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _shp; // STORAGE[0x2] bytes 0 to 19\naddress _trustee; // STORAGE[0x3] bytes 0 to 19\naddress _etherEscrowAddress; // STORAGE[0x4] bytes 0 to 19\nuint160 _bountyAddress; // STORAGE[0x5] bytes 0 to 19\nuint160 _trusteeAddress; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nSaleClosed(uint256);\nDiscountApplied(uint256, uint256, uint256);\nCountersUpdated(uint256, uint256);\nNewSale(address, uint256, uint256);\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction setAllowTransfer(bool varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _allowTransfer = varg0;\n}\n\nfunction mintTokens(uint256 varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v0, v1 = _shp.generateTokens(varg1, varg0).gas(msg.gas - 710);\n    require(v0);\n    emit NewSale(varg1, 0, varg0);\n}\n\nfunction FOURTH_TIER_DISCOUNT() public nonPayable { \n    return 30;\n}\n\nfunction totalContributions() public nonPayable { \n    return _totalContributions;\n}\n\nfunction etherEscrowAddress() public nonPayable { \n    return _etherEscrowAddress;\n}\n\nfunction trusteeAddress() public nonPayable { \n    return _trusteeAddress;\n}\n\nfunction onApprove(address varg0, address varg1, uint256 varg2) public nonPayable { \n    return _allowTransfer;\n}\n\nfunction pauseContribution() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _paused = 1;\n}\n\nfunction firstTierDiscountUpperLimitEther() public nonPayable { \n    return _firstTierDiscountUpperLimitEther;\n}\n\nfunction THIRD_TIER_DISCOUNT() public nonPayable { \n    return 20;\n}\n\nfunction closed() public nonPayable { \n    return _closed;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction setShpExchangeRate(uint256 varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _shpExchangeRate = varg0;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    require(_closed);\n    require(varg0);\n    require(varg1);\n    require(_shp.code.size);\n    v0 = _shp.changeController(varg0).gas(msg.gas - 710);\n    require(v0);\n    require(_trustee.code.size);\n    v1 = _trustee.changeOwner(varg1).gas(msg.gas - 710);\n    require(v1);\n}\n\nfunction founderTokenCount() public nonPayable { \n    return _founderTokenCount;\n}\n\nfunction shpExchangeRate() public nonPayable { \n    return _shpExchangeRate;\n}\n\nfunction shp() public nonPayable { \n    return _shp;\n}\n\nfunction CALLER_EXCHANGE_SHARE() public nonPayable { \n    return 40;\n}\n\nfunction pegEtherValues(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _minDiscountEther = varg0;\n    _firstTierDiscountUpperLimitEther = varg1;\n    _secondTierDiscountUpperLimitEther = varg2;\n    _thirdTierDiscountUpperLimitEther = varg3;\n    _minPresaleContributionEther = varg4;\n    _maxPresaleContributionEther = varg5;\n}\n\nfunction SECOND_TIER_DISCOUNT() public nonPayable { \n    return 10;\n}\n\nfunction minDiscountEther() public nonPayable { \n    return _minDiscountEther;\n}\n\nfunction owner() public nonPayable { \n    return _setShpExchangeRate;\n}\n\nfunction thirdTierDiscountUpperLimitEther() public nonPayable { \n    return _thirdTierDiscountUpperLimitEther;\n}\n\nfunction allowTransfer() public nonPayable { \n    return _allowTransfer;\n}\n\nfunction reserveTokenCount() public nonPayable { \n    return _reserveTokenCount;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    if (_setShpExchangeRate == msg.sender) {\n        _setShpExchangeRate = varg0;\n        goto 0x28e0x69b;\n    }\n}\n\nfunction secondTierDiscountUpperLimitEther() public nonPayable { \n    return _secondTierDiscountUpperLimitEther;\n}\n\nfunction maxPresaleContributionEther() public nonPayable { \n    return _maxPresaleContributionEther;\n}\n\nfunction resumeContribution() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _paused = 0;\n}\n\nfunction minPresaleContributionEther() public nonPayable { \n    return _minPresaleContributionEther;\n}\n\nfunction etherPaid() public nonPayable { \n    return _etherPaid;\n}\n\nfunction bountyAddress() public nonPayable { \n    return _bountyAddress;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction destroyTokens(uint256 varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v0, v1 = _shp.destroyTokens(varg1, varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction MAX_GAS_PRICE() public nonPayable { \n    return 0x48c27395000;\n}\n\nfunction FIRST_TIER_DISCOUNT() public nonPayable { \n    return 5;\n}\n\nfunction closeSale() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _closed = 1;\n    emit SaleClosed(block.timestamp);\n}\n\nfunction approvedAddresses(address varg0) public nonPayable { \n    return 0xff & _approvedAddresses[varg0];\n}\n\nfunction proxyPayment(address varg0) public payable { \n    return _allowTransfer;\n}\n\nfunction setShp(address varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _shp = varg0;\n}\n\nfunction trustee() public nonPayable { \n    return _trustee;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xb81e216) {\n            setAllowTransfer(bool);\n        } else if (0x10c5b328 == v0) {\n            mintTokens(uint256,address);\n        } else {\n            if (0x1cc8092f != v0) {\n                if (0x37c08923 == v0) {\n                    totalContributions();\n                } else if (0x495e1b3d == v0) {\n                    etherEscrowAddress();\n                } else if (0x49c1d54d == v0) {\n                    trusteeAddress();\n                } else {\n                    if (0x4a393149 != v0) {\n                        if (0x4b8adcf7 == v0) {\n                            pauseContribution();\n                        } else if (0x4ecb02aa == v0) {\n                            firstTierDiscountUpperLimitEther();\n                        } else {\n                            if (0x53f95cc6 != v0) {\n                                if (0x597e1fb5 == v0) {\n                                    closed();\n                                } else if (0x5bb0fa46 != v0) {\n                                    if (0x5c975abb == v0) {\n                                        paused();\n                                    } else if (0x5f596681 == v0) {\n                                        setShpExchangeRate(uint256);\n                                    } else if (0x6d435421 == v0) {\n                                        transferOwnership(address,address);\n                                    } else if (0x73a1f366 == v0) {\n                                        founderTokenCount();\n                                    } else if (0x788e0760 == v0) {\n                                        shpExchangeRate();\n                                    } else if (0x81d92ed4 == v0) {\n                                        shp();\n                                    } else if (0x845ec8de != v0) {\n                                        if (0x85f07a2b == v0) {\n                                            CALLER_EXCHANGE_SHARE();\n                                        } else if (0x86bb1b24 == v0) {\n                                            pegEtherValues(uint256,uint256,uint256,uint256,uint256,uint256);\n                                        } else {\n                                            if (0x87369c4b != v0) {\n                                                if (0x88df31f0 == v0) {\n                                                    minDiscountEther();\n                                                } else if (0x8da5cb5b == v0) {\n                                                    owner();\n                                                } else if (0x95c26d93 == v0) {\n                                                    thirdTierDiscountUpperLimitEther();\n                                                } else if (0x9b08a22f == v0) {\n                                                    allowTransfer();\n                                                } else if (0x9b99a8e2 == v0) {\n                                                    reserveTokenCount();\n                                                } else if (0xa6f9dae1 == v0) {\n                                                    changeOwner(address);\n                                                } else if (0xa78f0489 == v0) {\n                                                    secondTierDiscountUpperLimitEther();\n                                                } else if (0xb3e53d8a == v0) {\n                                                    maxPresaleContributionEther();\n                                                } else if (0xb681f9f6 == v0) {\n                                                    resumeContribution();\n                                                } else if (0xc1e74d71 == v0) {\n                                                    minPresaleContributionEther();\n                                                } else if (0xc257eabb == v0) {\n                                                    etherPaid();\n                                                } else if (0xc516358f == v0) {\n                                                    bountyAddress();\n                                                } else if (0xd4ee1d90 == v0) {\n                                                    newOwner();\n                                                } else if (0xda682aeb != v0) {\n                                                    if (0xe16385fc == v0) {\n                                                        destroyTokens(uint256,address);\n                                                    } else if (0xe3bbb4f1 == v0) {\n                                                        MAX_GAS_PRICE();\n                                                    } else if (0xe3d7f159 == v0) {\n                                                        FIRST_TIER_DISCOUNT();\n                                                    } else if (0xed4dd2ab != v0) {\n                                                        if (0xee55efee == v0) {\n                                                            closeSale();\n                                                        } else if (0xf136a874 == v0) {\n                                                            approvedAddresses(address);\n                                                        } else if (0xf48c3054 == v0) {\n                                                            proxyPayment(address);\n                                                        } else if (0xfa9df423 == v0) {\n                                                            setShp(address);\n                                                        } else if (0xfdf97cb2 == v0) {\n                                                            trustee();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            SECOND_TIER_DISCOUNT();\n                                        }\n                                    }\n                                }\n                            }\n                            THIRD_TIER_DISCOUNT();\n                        }\n                    }\n                    onApprove(address,address,uint256);\n                }\n            }\n            FOURTH_TIER_DISCOUNT();\n        }\n    }\n    require(msg.sender);\n    require(msg.value > 0);\n    require(msg.sender.code.size <= 0);\n    require(msg.gas <= 0x48c27395000);\n    require(!_closed);\n    require(!_paused);\n    require(msg.value > 0);\n    v1 = v2 = 0;\n    v1 = v3 = 0;\n    emit 0x4e75fda068b8e114d7658bdff74280a0fd65586b7e026a034eae29dd5a9e68b(msg.value, msg.sender);\n    v4 = v5 = 2522;\n    v6 = v7 = 100;\n    v8 = v9 = _SafeMul(40, _shpExchangeRate);\n    while (1) {\n        v1 = _SafeDiv(v6, v8);\n        v4 = v10 = 2563;\n        v6 = v11 = 100;\n        v8 = v12 = _SafeMul(30, _shpExchangeRate);\n        v4 = v13 = 2604;\n        v6 = v14 = 100;\n        v8 = v15 = _SafeMul(20, _shpExchangeRate);\n        v4 = v16 = 2645;\n        v6 = v17 = 100;\n        v8 = v18 = _SafeMul(10, _shpExchangeRate);\n    }\n    v19 = _SafeMul(v1, msg.value);\n    v20 = v21 = 0;\n    v22 = v23 = msg.value > _minDiscountEther;\n    if (v23) {\n        v22 = msg.value <= _firstTierDiscountUpperLimitEther;\n    }\n    if (!v22) {\n        v24 = v25 = msg.value > _firstTierDiscountUpperLimitEther;\n        if (v25) {\n            v24 = msg.value <= _secondTierDiscountUpperLimitEther;\n        }\n        if (!v24) {\n            v26 = v27 = msg.value > _secondTierDiscountUpperLimitEther;\n            if (v27) {\n                v26 = msg.value <= _thirdTierDiscountUpperLimitEther;\n            }\n            if (!v26) {\n                if (msg.value > _thirdTierDiscountUpperLimitEther) {\n                    v28 = v29 = 5226;\n                    v30 = v31 = 100;\n                    v32 = v33 = _SafeMul(30, v19);\n                }\n            } else {\n                v28 = v34 = 5045;\n                v30 = v35 = 100;\n                v32 = v36 = _SafeMul(20, v19);\n            }\n        } else {\n            v28 = v37 = 5045;\n            v30 = v38 = 100;\n            v32 = v39 = _SafeMul(10, v19);\n        }\n    } else {\n        v28 = v40 = 5045;\n        v30 = v41 = 100;\n        v32 = v42 = _SafeMul(5, v19);\n    }\n    v20 = _SafeDiv(v30, v32);\n    emit DiscountApplied(msg.value, v19, v20);\n    v43 = _SafeAdd(v19, v20);\n    v44 = _SafeMul(v1, msg.value);\n    v45 = _SafeMul(v1, msg.value);\n    v46 = _SafeMul(v1, msg.value);\n    v47 = _SafeAdd(v44, v45);\n    v48 = _SafeAdd(v45, _founderTokenCount);\n    _founderTokenCount = v48;\n    v49 = _SafeAdd(v44, _reserveTokenCount);\n    _reserveTokenCount = v49;\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v50, v51 = _shp.generateTokens(msg.sender, v43).gas(msg.gas - 710);\n    require(v50);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v52, v53 = _shp.generateTokens(_bountyAddress, v46).gas(msg.gas - 710);\n    require(v52);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v54, v55 = _shp.generateTokens(_trusteeAddress, v47).gas(msg.gas - 710);\n    require(v54);\n    emit NewSale(msg.sender, msg.value, v43);\n    emit NewSale(_trusteeAddress, msg.value, v47);\n    emit NewSale(_bountyAddress, msg.value, v46);\n    v56 = _etherEscrowAddress.call().value(msg.value).gas(2300 * !msg.value);\n    require(v56);\n    v57 = _SafeAdd(msg.value, _etherPaid);\n    _etherPaid = v57;\n    v58 = _SafeAdd(1, _totalContributions);\n    _totalContributions = v58;\n    emit CountersUpdated(_etherPaid, msg.value);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 18:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _founderTokenCount; // STORAGE[0x7]\nuint256 _reserveTokenCount; // STORAGE[0x8]\nuint256 _shpExchangeRate; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _approvedAddresses; // STORAGE[0xb]\nuint256 _etherPaid; // STORAGE[0xc]\nuint256 _totalContributions; // STORAGE[0xd]\nuint256 _minPresaleContributionEther; // STORAGE[0xe]\nuint256 _maxPresaleContributionEther; // STORAGE[0xf]\nuint256 _minDiscountEther; // STORAGE[0x10]\nuint256 _firstTierDiscountUpperLimitEther; // STORAGE[0x11]\nuint256 _secondTierDiscountUpperLimitEther; // STORAGE[0x12]\nuint256 _thirdTierDiscountUpperLimitEther; // STORAGE[0x13]\naddress _setShpExchangeRate; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0xa] bytes 0 to 0\nuint8 _closed; // STORAGE[0xa] bytes 1 to 1\nuint8 _allowTransfer; // STORAGE[0xa] bytes 2 to 2\nuint160 _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _shp; // STORAGE[0x2] bytes 0 to 19\naddress _trustee; // STORAGE[0x3] bytes 0 to 19\naddress _etherEscrowAddress; // STORAGE[0x4] bytes 0 to 19\nuint160 _bountyAddress; // STORAGE[0x5] bytes 0 to 19\nuint160 _trusteeAddress; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nSaleClosed(uint256);\nDiscountApplied(uint256, uint256, uint256);\nCountersUpdated(uint256, uint256);\nNewSale(address, uint256, uint256);\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction setAllowTransfer(bool varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _allowTransfer = varg0;\n}\n\nfunction mintTokens(uint256 varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v0, v1 = _shp.generateTokens(varg1, varg0).gas(msg.gas - 710);\n    require(v0);\n    emit NewSale(varg1, 0, varg0);\n}\n\nfunction FOURTH_TIER_DISCOUNT() public nonPayable { \n    return 30;\n}\n\nfunction totalContributions() public nonPayable { \n    return _totalContributions;\n}\n\nfunction etherEscrowAddress() public nonPayable { \n    return _etherEscrowAddress;\n}\n\nfunction trusteeAddress() public nonPayable { \n    return _trusteeAddress;\n}\n\nfunction onApprove(address varg0, address varg1, uint256 varg2) public nonPayable { \n    return _allowTransfer;\n}\n\nfunction pauseContribution() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _paused = 1;\n}\n\nfunction firstTierDiscountUpperLimitEther() public nonPayable { \n    return _firstTierDiscountUpperLimitEther;\n}\n\nfunction THIRD_TIER_DISCOUNT() public nonPayable { \n    return 20;\n}\n\nfunction closed() public nonPayable { \n    return _closed;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction setShpExchangeRate(uint256 varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _shpExchangeRate = varg0;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    require(_closed);\n    require(varg0);\n    require(varg1);\n    require(_shp.code.size);\n    v0 = _shp.changeController(varg0).gas(msg.gas - 710);\n    require(v0);\n    require(_trustee.code.size);\n    v1 = _trustee.changeOwner(varg1).gas(msg.gas - 710);\n    require(v1);\n}\n\nfunction founderTokenCount() public nonPayable { \n    return _founderTokenCount;\n}\n\nfunction shpExchangeRate() public nonPayable { \n    return _shpExchangeRate;\n}\n\nfunction shp() public nonPayable { \n    return _shp;\n}\n\nfunction CALLER_EXCHANGE_SHARE() public nonPayable { \n    return 40;\n}\n\nfunction pegEtherValues(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _minDiscountEther = varg0;\n    _firstTierDiscountUpperLimitEther = varg1;\n    _secondTierDiscountUpperLimitEther = varg2;\n    _thirdTierDiscountUpperLimitEther = varg3;\n    _minPresaleContributionEther = varg4;\n    _maxPresaleContributionEther = varg5;\n}\n\nfunction SECOND_TIER_DISCOUNT() public nonPayable { \n    return 10;\n}\n\nfunction minDiscountEther() public nonPayable { \n    return _minDiscountEther;\n}\n\nfunction owner() public nonPayable { \n    return _setShpExchangeRate;\n}\n\nfunction thirdTierDiscountUpperLimitEther() public nonPayable { \n    return _thirdTierDiscountUpperLimitEther;\n}\n\nfunction allowTransfer() public nonPayable { \n    return _allowTransfer;\n}\n\nfunction reserveTokenCount() public nonPayable { \n    return _reserveTokenCount;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    if (_setShpExchangeRate == msg.sender) {\n        _setShpExchangeRate = varg0;\n        goto 0x28e0x69b;\n    }\n}\n\nfunction secondTierDiscountUpperLimitEther() public nonPayable { \n    return _secondTierDiscountUpperLimitEther;\n}\n\nfunction maxPresaleContributionEther() public nonPayable { \n    return _maxPresaleContributionEther;\n}\n\nfunction resumeContribution() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _paused = 0;\n}\n\nfunction minPresaleContributionEther() public nonPayable { \n    return _minPresaleContributionEther;\n}\n\nfunction etherPaid() public nonPayable { \n    return _etherPaid;\n}\n\nfunction bountyAddress() public nonPayable { \n    return _bountyAddress;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction destroyTokens(uint256 varg0, address varg1) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v0, v1 = _shp.destroyTokens(varg1, varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction MAX_GAS_PRICE() public nonPayable { \n    return 0x48c27395000;\n}\n\nfunction FIRST_TIER_DISCOUNT() public nonPayable { \n    return 5;\n}\n\nfunction closeSale() public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _closed = 1;\n    emit SaleClosed(block.timestamp);\n}\n\nfunction approvedAddresses(address varg0) public nonPayable { \n    return 0xff & _approvedAddresses[varg0];\n}\n\nfunction proxyPayment(address varg0) public payable { \n    return _allowTransfer;\n}\n\nfunction setShp(address varg0) public nonPayable { \n    require(_setShpExchangeRate == msg.sender);\n    _shp = varg0;\n}\n\nfunction trustee() public nonPayable { \n    return _trustee;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xb81e216) {\n            setAllowTransfer(bool);\n        } else if (0x10c5b328 == v0) {\n            mintTokens(uint256,address);\n        } else {\n            if (0x1cc8092f != v0) {\n                if (0x37c08923 == v0) {\n                    totalContributions();\n                } else if (0x495e1b3d == v0) {\n                    etherEscrowAddress();\n                } else if (0x49c1d54d == v0) {\n                    trusteeAddress();\n                } else {\n                    if (0x4a393149 != v0) {\n                        if (0x4b8adcf7 == v0) {\n                            pauseContribution();\n                        } else if (0x4ecb02aa == v0) {\n                            firstTierDiscountUpperLimitEther();\n                        } else {\n                            if (0x53f95cc6 != v0) {\n                                if (0x597e1fb5 == v0) {\n                                    closed();\n                                } else if (0x5bb0fa46 != v0) {\n                                    if (0x5c975abb == v0) {\n                                        paused();\n                                    } else if (0x5f596681 == v0) {\n                                        setShpExchangeRate(uint256);\n                                    } else if (0x6d435421 == v0) {\n                                        transferOwnership(address,address);\n                                    } else if (0x73a1f366 == v0) {\n                                        founderTokenCount();\n                                    } else if (0x788e0760 == v0) {\n                                        shpExchangeRate();\n                                    } else if (0x81d92ed4 == v0) {\n                                        shp();\n                                    } else if (0x845ec8de != v0) {\n                                        if (0x85f07a2b == v0) {\n                                            CALLER_EXCHANGE_SHARE();\n                                        } else if (0x86bb1b24 == v0) {\n                                            pegEtherValues(uint256,uint256,uint256,uint256,uint256,uint256);\n                                        } else {\n                                            if (0x87369c4b != v0) {\n                                                if (0x88df31f0 == v0) {\n                                                    minDiscountEther();\n                                                } else if (0x8da5cb5b == v0) {\n                                                    owner();\n                                                } else if (0x95c26d93 == v0) {\n                                                    thirdTierDiscountUpperLimitEther();\n                                                } else if (0x9b08a22f == v0) {\n                                                    allowTransfer();\n                                                } else if (0x9b99a8e2 == v0) {\n                                                    reserveTokenCount();\n                                                } else if (0xa6f9dae1 == v0) {\n                                                    changeOwner(address);\n                                                } else if (0xa78f0489 == v0) {\n                                                    secondTierDiscountUpperLimitEther();\n                                                } else if (0xb3e53d8a == v0) {\n                                                    maxPresaleContributionEther();\n                                                } else if (0xb681f9f6 == v0) {\n                                                    resumeContribution();\n                                                } else if (0xc1e74d71 == v0) {\n                                                    minPresaleContributionEther();\n                                                } else if (0xc257eabb == v0) {\n                                                    etherPaid();\n                                                } else if (0xc516358f == v0) {\n                                                    bountyAddress();\n                                                } else if (0xd4ee1d90 == v0) {\n                                                    newOwner();\n                                                } else if (0xda682aeb != v0) {\n                                                    if (0xe16385fc == v0) {\n                                                        destroyTokens(uint256,address);\n                                                    } else if (0xe3bbb4f1 == v0) {\n                                                        MAX_GAS_PRICE();\n                                                    } else if (0xe3d7f159 == v0) {\n                                                        FIRST_TIER_DISCOUNT();\n                                                    } else if (0xed4dd2ab != v0) {\n                                                        if (0xee55efee == v0) {\n                                                            closeSale();\n                                                        } else if (0xf136a874 == v0) {\n                                                            approvedAddresses(address);\n                                                        } else if (0xf48c3054 == v0) {\n                                                            proxyPayment(address);\n                                                        } else if (0xfa9df423 == v0) {\n                                                            setShp(address);\n                                                        } else if (0xfdf97cb2 == v0) {\n                                                            trustee();\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            SECOND_TIER_DISCOUNT();\n                                        }\n                                    }\n                                }\n                            }\n                            THIRD_TIER_DISCOUNT();\n                        }\n                    }\n                    onApprove(address,address,uint256);\n                }\n            }\n            FOURTH_TIER_DISCOUNT();\n        }\n    }\n    require(msg.sender);\n    require(msg.value > 0);\n    require(msg.sender.code.size <= 0);\n    require(msg.gas <= 0x48c27395000);\n    require(!_closed);\n    require(!_paused);\n    require(msg.value > 0);\n    v1 = v2 = 0;\n    v1 = v3 = 0;\n    emit 0x4e75fda068b8e114d7658bdff74280a0fd65586b7e026a034eae29dd5a9e68b(msg.value, msg.sender);\n    v4 = v5 = 2522;\n    v6 = v7 = 100;\n    v8 = v9 = _SafeMul(40, _shpExchangeRate);\n    while (1) {\n        v1 = _SafeDiv(v6, v8);\n        v4 = v10 = 2563;\n        v6 = v11 = 100;\n        v8 = v12 = _SafeMul(30, _shpExchangeRate);\n        v4 = v13 = 2604;\n        v6 = v14 = 100;\n        v8 = v15 = _SafeMul(20, _shpExchangeRate);\n        v4 = v16 = 2645;\n        v6 = v17 = 100;\n        v8 = v18 = _SafeMul(10, _shpExchangeRate);\n    }\n    v19 = _SafeMul(v1, msg.value);\n    v20 = v21 = 0;\n    v22 = v23 = msg.value > _minDiscountEther;\n    if (v23) {\n        v22 = msg.value <= _firstTierDiscountUpperLimitEther;\n    }\n    if (!v22) {\n        v24 = v25 = msg.value > _firstTierDiscountUpperLimitEther;\n        if (v25) {\n            v24 = msg.value <= _secondTierDiscountUpperLimitEther;\n        }\n        if (!v24) {\n            v26 = v27 = msg.value > _secondTierDiscountUpperLimitEther;\n            if (v27) {\n                v26 = msg.value <= _thirdTierDiscountUpperLimitEther;\n            }\n            if (!v26) {\n                if (msg.value > _thirdTierDiscountUpperLimitEther) {\n                    v28 = v29 = 5226;\n                    v30 = v31 = 100;\n                    v32 = v33 = _SafeMul(30, v19);\n                }\n            } else {\n                v28 = v34 = 5045;\n                v30 = v35 = 100;\n                v32 = v36 = _SafeMul(20, v19);\n            }\n        } else {\n            v28 = v37 = 5045;\n            v30 = v38 = 100;\n            v32 = v39 = _SafeMul(10, v19);\n        }\n    } else {\n        v28 = v40 = 5045;\n        v30 = v41 = 100;\n        v32 = v42 = _SafeMul(5, v19);\n    }\n    v20 = _SafeDiv(v30, v32);\n    emit DiscountApplied(msg.value, v19, v20);\n    v43 = _SafeAdd(v19, v20);\n    v44 = _SafeMul(v1, msg.value);\n    v45 = _SafeMul(v1, msg.value);\n    v46 = _SafeMul(v1, msg.value);\n    v47 = _SafeAdd(v44, v45);\n    v48 = _SafeAdd(v45, _founderTokenCount);\n    _founderTokenCount = v48;\n    v49 = _SafeAdd(v44, _reserveTokenCount);\n    _reserveTokenCount = v49;\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v50, v51 = _shp.generateTokens(msg.sender, v43).gas(msg.gas - 710);\n    require(v50);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v52, v53 = _shp.generateTokens(_bountyAddress, v46).gas(msg.gas - 710);\n    require(v52);\n    MEM[32 + MEM[64]] = 0;\n    require(_shp.code.size);\n    v54, v55 = _shp.generateTokens(_trusteeAddress, v47).gas(msg.gas - 710);\n    require(v54);\n    emit NewSale(msg.sender, msg.value, v43);\n    emit NewSale(_trusteeAddress, msg.value, v47);\n    emit NewSale(_bountyAddress, msg.value, v46);\n    v56 = _etherEscrowAddress.call().value(msg.value).gas(2300 * !msg.value);\n    require(v56);\n    v57 = _SafeAdd(msg.value, _etherPaid);\n    _etherPaid = v57;\n    v58 = _SafeAdd(1, _totalContributions);\n    _totalContributions = v58;\n    emit CountersUpdated(_etherPaid, msg.value);\n}\n.",
	"status": "1",
	"time_cost": 52.777909994125366,
	"usage": {
		"completion_tokens": 630,
		"prompt_tokens": 4184,
		"total_tokens": 4814
	}
}