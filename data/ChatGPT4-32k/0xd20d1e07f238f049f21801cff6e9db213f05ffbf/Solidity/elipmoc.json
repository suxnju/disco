{
	"address": "0xd20d1e07f238f049f21801cff6e9db213f05ffbf",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here's a Solidity contract that mirrors the functionality described by the given decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (bytes32 => address) private _getAddressByName;\n    mapping (address => bytes32) private _m_addrToName;\n    address private _owner;\n    bool private _isLock;\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'only owner can call this function');\n        _;\n    }\n\n    function updateLock(bool newLock) public onlyOwner {\n        require(newLock != _isLock, 'updateLock new status == old status');\n        _isLock = newLock;\n    }\n\n    function GetAddressByName(bytes32 name) public view returns (address) {\n        return _getAddressByName[name];\n    }\n\n    function checkUp(address addr, bytes32 name) public view returns (uint8) {\n        return (addr == _getAddressByName[name]) ? 1 : 0;\n    }\n\n    function m_nameToAddr(bytes32 name) public view returns (address) {\n        return _getAddressByName[name];\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), 'newOwner cannot be null');\n        _owner = newOwner;\n    }\n\n    function m_addrToName(address addr) public view returns (bytes32) {\n        return _m_addrToName[addr];\n    }\n\n    function isLock() public view returns (bool) {\n        return _isLock;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function createInviteName(bytes32 name) public payable {\n        require(!_isLock, 'contract current is lock status');\n        require(msg.sender == tx.origin, 'msg.sender must equipt tx.origin');\n        require(_getAddressByName[name] == address(0), 'name already used');\n        require(_m_addrToName[msg.sender] == bytes32(0), 'address has already one name');\n        _getAddressByName[name] = msg.sender;\n        _m_addrToName[msg.sender] = name;\n    }\n\n    receive() external payable {\n        revert();\n    }\n}\n```\n\nA few notes:\n- The original decompiled code provided seems to have some errors and inconsistencies, so I made some assumptions to make it work in Solidity.\n- The function `0x589` has been changed to a `checkUp` function, based on its usage in the contract.\n- The `__function_selector__` part is not necessary in Solidity, so I didn't include it.\n- I added a `receive()` function to handle any incoming ether and immediately revert the transaction.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464648,
	"id": "chatcmpl-8R4y8Bejyc1AFFbiJOt9r7wSPSBha",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getAddressByName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _m_addrToName; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _isLock; // STORAGE[0x0] bytes 20 to 20\n\n\nfunction updateLock(bool varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(varg0 != _isLock, ' updateLock new status == old status', ' updateLock new status == old status');\n    _isLock = varg0;\n}\n\nfunction GetAddressByName(bytes32 varg0) public nonPayable { \n    return address(_getAddressByName[varg0]);\n}\n\nfunction checkUp(address varg0, bytes32 varg1) public nonPayable { \n    v0 = 0x589(varg1, varg0);\n    return v0 & 0xff;\n}\n\nfunction m_nameToAddr(bytes32 varg0) public nonPayable { \n    return address(_getAddressByName[varg0]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    if (varg0) {\n        _owner = varg0;\n    }\n}\n\nfunction m_addrToName(address varg0) public nonPayable { \n    return _m_addrToName[varg0];\n}\n\nfunction 0x589(uint256 varg0, uint256 varg1) private { \n    if (!address(_getAddressByName[varg0])) {\n        v0 = address(varg1);\n        if (!_m_addrToName[v0]) {\n            v1 = v2 = 0;\n        } else {\n            v1 = v3 = 2;\n        }\n    } else {\n        v1 = v4 = 1;\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isLock() public nonPayable { \n    return _isLock;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction createInviteName(bytes32 varg0) public payable { \n    require(!_isLock, 'contract current is lock status');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    require(msg.value == stor_2);\n    v0 = 0x589(varg0, msg.sender);\n    require(!(0xff & v0), 'current name has been used or current address has been one name');\n    _getAddressByName[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getAddressByName[varg0];\n    _getAddressByName[msg.sender] = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9d8da2e) {\n            isLock();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x93e7d6c6 == function_selector) {\n            createInviteName(bytes32);\n        } else if (0xa1f91057 == function_selector) {\n            updateLock(bool);\n        } else if (0xba9d407a == function_selector) {\n            GetAddressByName(bytes32);\n        } else if (0xc9af2418 == function_selector) {\n            checkUp(address,bytes32);\n        } else if (0xd9af3da0 == function_selector) {\n            m_nameToAddr(bytes32);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf6b06d75 == function_selector) {\n            m_addrToName(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getAddressByName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _m_addrToName; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _isLock; // STORAGE[0x0] bytes 20 to 20\n\n\nfunction updateLock(bool varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(varg0 != _isLock, ' updateLock new status == old status', ' updateLock new status == old status');\n    _isLock = varg0;\n}\n\nfunction GetAddressByName(bytes32 varg0) public nonPayable { \n    return address(_getAddressByName[varg0]);\n}\n\nfunction checkUp(address varg0, bytes32 varg1) public nonPayable { \n    v0 = 0x589(varg1, varg0);\n    return v0 & 0xff;\n}\n\nfunction m_nameToAddr(bytes32 varg0) public nonPayable { \n    return address(_getAddressByName[varg0]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    if (varg0) {\n        _owner = varg0;\n    }\n}\n\nfunction m_addrToName(address varg0) public nonPayable { \n    return _m_addrToName[varg0];\n}\n\nfunction 0x589(uint256 varg0, uint256 varg1) private { \n    if (!address(_getAddressByName[varg0])) {\n        v0 = address(varg1);\n        if (!_m_addrToName[v0]) {\n            v1 = v2 = 0;\n        } else {\n            v1 = v3 = 2;\n        }\n    } else {\n        v1 = v4 = 1;\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isLock() public nonPayable { \n    return _isLock;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction createInviteName(bytes32 varg0) public payable { \n    require(!_isLock, 'contract current is lock status');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    require(msg.value == stor_2);\n    v0 = 0x589(varg0, msg.sender);\n    require(!(0xff & v0), 'current name has been used or current address has been one name');\n    _getAddressByName[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getAddressByName[varg0];\n    _getAddressByName[msg.sender] = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9d8da2e) {\n            isLock();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x93e7d6c6 == function_selector) {\n            createInviteName(bytes32);\n        } else if (0xa1f91057 == function_selector) {\n            updateLock(bool);\n        } else if (0xba9d407a == function_selector) {\n            GetAddressByName(bytes32);\n        } else if (0xc9af2418 == function_selector) {\n            checkUp(address,bytes32);\n        } else if (0xd9af3da0 == function_selector) {\n            m_nameToAddr(bytes32);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf6b06d75 == function_selector) {\n            m_addrToName(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getAddressByName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _m_addrToName; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _isLock; // STORAGE[0x0] bytes 20 to 20\n\n\nfunction updateLock(bool varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    require(varg0 != _isLock, ' updateLock new status == old status', ' updateLock new status == old status');\n    _isLock = varg0;\n}\n\nfunction GetAddressByName(bytes32 varg0) public nonPayable { \n    return address(_getAddressByName[varg0]);\n}\n\nfunction checkUp(address varg0, bytes32 varg1) public nonPayable { \n    v0 = 0x589(varg1, varg0);\n    return v0 & 0xff;\n}\n\nfunction m_nameToAddr(bytes32 varg0) public nonPayable { \n    return address(_getAddressByName[varg0]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'only owner can call this function');\n    if (varg0) {\n        _owner = varg0;\n    }\n}\n\nfunction m_addrToName(address varg0) public nonPayable { \n    return _m_addrToName[varg0];\n}\n\nfunction 0x589(uint256 varg0, uint256 varg1) private { \n    if (!address(_getAddressByName[varg0])) {\n        v0 = address(varg1);\n        if (!_m_addrToName[v0]) {\n            v1 = v2 = 0;\n        } else {\n            v1 = v3 = 2;\n        }\n    } else {\n        v1 = v4 = 1;\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isLock() public nonPayable { \n    return _isLock;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction createInviteName(bytes32 varg0) public payable { \n    require(!_isLock, 'contract current is lock status');\n    require(msg.sender.code.size <= 0, 'address must is not contract');\n    require(tx.origin == msg.sender, 'msg.sender must equipt tx.origin');\n    require(msg.value == stor_2);\n    v0 = 0x589(varg0, msg.sender);\n    require(!(0xff & v0), 'current name has been used or current address has been one name');\n    _getAddressByName[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getAddressByName[varg0];\n    _getAddressByName[msg.sender] = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x9d8da2e) {\n            isLock();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x93e7d6c6 == function_selector) {\n            createInviteName(bytes32);\n        } else if (0xa1f91057 == function_selector) {\n            updateLock(bool);\n        } else if (0xba9d407a == function_selector) {\n            GetAddressByName(bytes32);\n        } else if (0xc9af2418 == function_selector) {\n            checkUp(address,bytes32);\n        } else if (0xd9af3da0 == function_selector) {\n            m_nameToAddr(bytes32);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf6b06d75 == function_selector) {\n            m_addrToName(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 36.0342013835907,
	"usage": {
		"completion_tokens": 578,
		"prompt_tokens": 1002,
		"total_tokens": 1580
	}
}