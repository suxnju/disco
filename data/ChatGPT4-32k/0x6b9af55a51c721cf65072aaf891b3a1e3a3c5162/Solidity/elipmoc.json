{
	"address": "0x6b9af55a51c721cf65072aaf891b3a1e3a3c5162",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the decompiled code, the corresponding Solidity code might look similar to the following:\n\n```solidity\npragma solidity ^0.8.21;\n\ncontract MyContract {\n    mapping (uint256 => uint256) private _isAuthorized;\n    uint256[] private _name;\n    uint256[] private _symbol;\n    uint256[] private _aboutMe;\n    uint256[] private _array;\n    uint256 private _totalSupply;\n    uint256 private _maxWalletToken;\n    uint256 private _swapThreshold;\n    uint256 private _operaTax;\n    uint256 private _marketingBuyTax;\n    uint256 private _marketingSellTax;\n    uint256 private _devBuyTax;\n    uint256 private _devSellTax;\n    uint256 private _liquidityBuyTax;\n    uint256 private _liquiditySellTax;\n    mapping (uint256 => uint256) private _balanceOf;\n    mapping (uint256 => mapping (uint256 => uint256)) private _allowance;\n    mapping (uint256 => uint256) private _takeFee;\n    uint256 private _getOwner;\n    uint256 private _pair;\n    uint256 private _routerAddress;\n    uint256 private _devAddress;\n    uint256 private _marketingAddress;\n    uint256 private _operaRevenueAddress;\n    uint256 private _operaFactoryAddress;\n    uint256 private _wETHAddress;\n    uint256 private _router;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event AutoLiquify(uint256 tokensSwapped, uint256 ethReceived);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        // Initialize contract state\n    }\n\n    // Implement contract methods based on the decompiled code\n}\n```\n\nPlease note that the decompiled code doesn't provide the exact implementation details of each function, so the actual implementation of the contract methods are not included in the above code snippet.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495486,
	"id": "chatcmpl-8VP8YhsQE0XOXd1TEgzeq4KIJVYlq",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.17 05:37 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _isAuthorized; // STORAGE[0x1]\nuint256[] _@name_2169; // STORAGE[0x2]\nuint256[] _@symbol_2160; // STORAGE[0x3]\nuint256[] _@aboutMe_3219; // STORAGE[0x4]\nuint256[] array_5; // STORAGE[0x5]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 __maxWalletToken; // STORAGE[0x7]\nuint256 __swapThreshold; // STORAGE[0x8]\nuint256 __operaTax; // STORAGE[0x9]\nuint256 __marketingBuyTax; // STORAGE[0xa]\nuint256 __marketingSellTax; // STORAGE[0xb]\nuint256 __devBuyTax; // STORAGE[0xc]\nuint256 __devSellTax; // STORAGE[0xd]\nuint256 __liquidityBuyTax; // STORAGE[0xe]\nuint256 __liquiditySellTax; // STORAGE[0xf]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x10]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x11]\nmapping (uint256 => uint256) _@takeFee_2600; // STORAGE[0x12]\nuint256 _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_15_0_0; // STORAGE[0x15] bytes 0 to 0\nuint256 stor_16_0_0; // STORAGE[0x16] bytes 0 to 0\nuint256 _pair; // STORAGE[0x13] bytes 0 to 19\nuint256 _routerAddress; // STORAGE[0x14] bytes 0 to 19\nuint256 __devAddress; // STORAGE[0x15] bytes 0 to 19\nuint256 __marketingAddress; // STORAGE[0x16] bytes 0 to 19\nuint256 _operaRevenueAddress; // STORAGE[0x17] bytes 0 to 19\nuint256 _operaFactoryAddress; // STORAGE[0x18] bytes 0 to 19\nuint256 _wETHAddress; // STORAGE[0x19] bytes 0 to 19\nuint256 _router; // STORAGE[0x1a] bytes 0 to 19\nuint256 stor_1a_20_20; // STORAGE[0x1a] bytes 20 to 20\nuint256 stor_1a_21_21; // STORAGE[0x1a] bytes 21 to 21\nuint256 stor_1a_22_22; // STORAGE[0x1a] bytes 22 to 22\n\n\n// Events\nApproval(address, address, uint256);\nAutoLiquify(uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction @getSellTax_2628() private { \n    require(__liquiditySellTax <= __devSellTax + __liquiditySellTax, Panic(17)); // arithmetic overflow or underflow\n    require(__devSellTax + __liquiditySellTax <= __marketingSellTax + (__devSellTax + __liquiditySellTax), Panic(17)); // arithmetic overflow or underflow\n    require(__marketingSellTax + (__devSellTax + __liquiditySellTax) <= __operaTax + (__marketingSellTax + (__devSellTax + __liquiditySellTax)), Panic(17)); // arithmetic overflow or underflow\n    return __operaTax + (__marketingSellTax + (__devSellTax + __liquiditySellTax));\n}\n\nfunction @aboutMe_3219() private { \n    v0 = v1 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v6) {\n        if (31 < v6) {\n            v9 = v10 = _@aboutMe_3219.data;\n            do {\n                MEM[v4] = STORAGE[v9];\n                v9 += 1;\n                v4 += 32;\n            } while (v5 + v6 <= v4);\n        } else {\n            MEM[v5] = _@aboutMe_3219.length >> 8 << 8;\n        }\n    }\n    v11 = v12 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v11 = v13 = v12 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v11 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v14 = new bytes[](v11);\n    v15 = v16 = v14.data;\n    v17 = v18 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v17 = v19 = v18 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v17 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v17) {\n        return v14, v3;\n    } else if (31 < v17) {\n        v20 = v21 = array_5.data;\n        do {\n            MEM[v15] = STORAGE[v20];\n            v20 += 1;\n            v15 += 32;\n        } while (v16 + v17 <= v15);\n        return v14, v3;\n    } else {\n        MEM[v16] = array_5.length >> 8 << 8;\n        return v14, v3;\n    }\n}\n\nfunction @tokenSwap_3028() private { \n    stor_1a_20_20 = 1;\n    v0 = v1 = _balanceOf[this];\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__liquiditySellTax + __liquidityBuyTax > 0) {\n        v2 = @getTotalTax_2640();\n        require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v3 = _SafeMul(__liquiditySellTax + __liquidityBuyTax, v1);\n        v4 = _SafeDiv(v2, v3);\n        v0 = v5 = _SafeDiv(2, v4);\n    } else {\n        v0 = v6 = 0;\n    }\n    v0 = v7 = _SafeSub('SafeMath: subtraction overflow', v0, v1);\n    v0 = v8 = new address[](2);\n    CALLDATACOPY(v8.data, msg.data.length, 64);\n    require(0 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v9 = v8.data;\n    v8[0] = address(this);\n    require(1 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v8[1] = _wETHAddress;\n    v0 = v10 = this.balance;\n    v11 = new address[](v8.length);\n    v12 = v13 = v11.data;\n    v14 = v15 = v8.data;\n    v16 = v17 = 0;\n    while (v16 < v8.length) {\n        MEM[v12] = address(MEM[v14]);\n        v14 += 32;\n        v12 += 32;\n        v16 += 1;\n    }\n    require(bool(_router.code.size));\n    v18 = _router.swapExactTokensForETHSupportingFeeOnTransferTokens(v7, 0, v11, address(this), block.timestamp, v19, address(this)).gas(msg.gas);\n    require(bool(v18), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v0 = v20 = 0;\n    v0 = v21 = _SafeSub('SafeMath: subtraction overflow', v10, this.balance);\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__liquiditySellTax + __liquidityBuyTax > 0) {\n        require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v22 = _SafeDiv(2, __liquiditySellTax + __liquidityBuyTax);\n        v23 = @getTotalTax_2640();\n        v0 = _SafeSub('SafeMath: subtraction overflow', v22, v23);\n        // Unknown jump to Block 0x15d0. Refer to 3-address code (TAC);\n    } else {\n        v0 = v24 = @getTotalTax_2640();\n    }\n    v0 = v25 = 0;\n    v0 = v26 = 5623;\n    v0 = v27 = 2;\n    v0 = v28 = 12942;\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    v29 = v30 = _SafeMul(__liquiditySellTax + __liquidityBuyTax, v21);\n    while (1) {\n        v29 = _SafeDiv(v0, v29);\n    }\n    require(__devBuyTax <= __devSellTax + __devBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__devSellTax + __devBuyTax > 0) {\n        require(__devBuyTax <= __devSellTax + __devBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v31 = _SafeMul(__devSellTax + __devBuyTax, v0);\n        v32 = _SafeDiv(v0, v31);\n        v33, /* uint256 */ v34 = __devAddress.call().value(v32).gas(0x186a0);\n        if (RETURNDATASIZE() != 0) {\n            v35 = new bytes[](RETURNDATASIZE());\n            v34 = v35.data;\n            RETURNDATACOPY(v34, 0, RETURNDATASIZE());\n        }\n    }\n    require(__marketingBuyTax <= __marketingSellTax + __marketingBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__marketingSellTax + __marketingBuyTax > 0) {\n        require(__marketingBuyTax <= __marketingSellTax + __marketingBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v36 = _SafeMul(__marketingSellTax + __marketingBuyTax, v0);\n        v37 = _SafeDiv(v0, v36);\n        v38, /* uint256 */ v39 = __marketingAddress.call().value(v37).gas(0x186a0);\n        if (RETURNDATASIZE() != 0) {\n            v40 = new bytes[](RETURNDATASIZE());\n            v39 = v40.data;\n            RETURNDATACOPY(v39, 0, RETURNDATASIZE());\n        }\n    }\n    if (v0) {\n        if (stor_1a_22_22) {\n            v41 = v42 = _operaFactoryAddress;\n        } else {\n            v41 = v43 = __marketingAddress;\n        }\n        v44, /* uint256 */ v45, /* uint256 */ v46, /* uint256 */ v47 = _router.addLiquidityETH(this, v0, 0, 0, address(v41), block.timestamp).value(v29).gas(msg.gas);\n        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n        emit AutoLiquify(v29, v0);\n    }\n    v48 = _SafeMul(2, __operaTax);\n    v49 = _SafeMul(v48, v0);\n    v50 = _SafeDiv(v0, v49);\n    require(bool(_operaRevenueAddress.code.size));\n    v51 = _operaRevenueAddress.recieveRewards().value(v50).gas(msg.gas);\n    require(bool(v51), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    stor_1a_20_20 = 0;\n    return v1;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @_transferFrom_2514(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = 0;\n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    v2 = v3 = uint8(_isAuthorized[address(varg2)]);\n    if (!v3) {\n        v2 = v4 = uint8(_isAuthorized[address(varg1)]);\n    }\n    if (!v2) {\n        if (!stor_1a_20_20) {\n            v5 = v6 = !uint8(_isAuthorized[address(varg2)]);\n            if (!bool(uint8(_isAuthorized[address(varg2)]))) {\n                v5 = v7 = !uint8(_isAuthorized[address(varg1)]);\n            }\n            if (v5) {\n                v5 = v8 = this != address(varg1);\n            }\n            if (v5) {\n                v5 = v9 = this != address(varg2);\n            }\n            if (v5) {\n                v5 = v10 = address(varg1) != 57005;\n            }\n            if (v5) {\n                v5 = v11 = _pair != address(varg1);\n            }\n            if (v5) {\n                v5 = v12 = __marketingAddress != address(varg1);\n            }\n            if (v5) {\n                v5 = v13 = __devAddress != address(varg1);\n            }\n            if (v5) {\n                v5 = _operaFactoryAddress != address(varg1);\n            }\n            if (v5) {\n                require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                require(varg0 + _balanceOf[address(varg1)] <= __maxWalletToken, Error('Total Holding is currently limited, you can not buy that much.'));\n                // Unknown jump to Block 0x19d9. Refer to 3-address code (TAC);\n            }\n            v14 = @shouldTokenSwap_3056(varg1);\n            if (v14) {\n                varg0 = v15 = 6639;\n                v16 = @tokenSwap_3028();\n            }\n            v17 = address(varg0);\n            v18 = _SafeSub('Insufficient Balance', varg0, _balanceOf[v17]);\n            v19 = address(varg0);\n            _balanceOf[v19] = v18;\n            v20 = v21 = stor_1a_21_21;\n            if (v21) {\n                v20 = v22 = _pair == address(v0);\n                if (_pair != address(v0)) {\n                    v20 = v23 = _pair == address(varg0);\n                }\n            }\n            if (v20) {\n                varg0 = v24 = @takeFee_2600(varg0, v0, varg0);\n            }\n            v25 = _SafeAdd(varg0, _balanceOf[address(v0)]);\n            _balanceOf[address(v0)] = v25;\n            emit Transfer(address(varg0), address(v0), varg0);\n            return 1;\n        } else {\n            v26 = v27 = @_basicTransfer_2325(varg0, varg1, varg2);\n        }\n    } else {\n        v26 = v28 = @_basicTransfer_2325(varg0, varg1, varg2);\n    }\n    return v26;\n}\n\nfunction @_basicTransfer_2325(uint256 varg0, address varg1, address varg2) private { \n    v0 = _SafeSub('Insufficient Balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (0 - varg1) {\n        v0 = varg0 * varg1;\n        require((varg0 == v0 / varg1) | !varg1, Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(v0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @shouldTokenSwap_3056(address varg0) private { \n    v0 = v1 = _pair == varg0;\n    if (v1) {\n        v0 = v2 = stor_1a_21_21;\n    }\n    if (v0) {\n        v0 = v3 = !stor_1a_20_20;\n    }\n    if (!v0) {\n        return v0;\n    } else {\n        return _balanceOf[this] >= __swapThreshold;\n    }\n}\n\nfunction @takeFee_2600(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = uint8(_@takeFee_2600[address(varg2)]);\n    if (!v1) {\n        v0 = v2 = uint8(_@takeFee_2600[address(varg1)]);\n    }\n    if (!v0) {\n        if (varg1 - _operaFactoryAddress) {\n            if (_pair == varg1) {\n                v3 = v4 = @getSellTax_2628();\n            } else {\n                v3 = v5 = @getBuyTax_2614();\n            }\n            v6 = _SafeMul(v3, varg0);\n            v7 = _SafeDiv(1000, v6);\n            v8 = _SafeAdd(v7, _balanceOf[this]);\n            _balanceOf[this] = v8;\n            emit Transfer(varg2, this, v7);\n            v9 = _SafeSub('SafeMath: subtraction overflow', v7, varg0);\n            return v9;\n        } else {\n            return varg0;\n        }\n    } else {\n        return varg0;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _devSellTax() public nonPayable { \n    return __devSellTax;\n}\n\nfunction setTaxes(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    v0 = v1 = _balanceOf[this];\n    if (!(20 - __operaTax)) {\n        if (v1) {\n            v2 = v3 = 2255;\n            v4 = @tokenSwap_3028();\n        }\n        __operaTax = 4;\n    }\n    __marketingBuyTax = varg2;\n    __liquidityBuyTax = v0;\n    __devBuyTax = v0;\n    __marketingSellTax = v2;\n    __liquiditySellTax = v2;\n    __devSellTax = v2;\n    if (stor_1a_22_22) {\n        v5 = v6 = 100;\n    } else {\n        v5 = v7 = 500;\n    }\n    v8 = @getBuyTax_2614();\n    if (v8 <= uint16(v5)) {\n        if (stor_1a_22_22) {\n            v9 = v10 = 100;\n        } else {\n            v9 = v11 = 500;\n        }\n        v12 = @getSellTax_2628();\n        require(v12 <= uint16(v9), Error(\"Sell tax can't be greater than 10% if borrowed lp and 50% if not.\"));\n        exit;\n    } else {\n        v13 = new uint256[](\"Buy tax can't be greater than 10\");\n        revert(Error(\"Buy tax can't be greater than 10% if borrowed lp and 50% if not.\", v13));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = @name_2169();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    _allowance[msg.sender][varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return bool(1);\n}\n\nfunction WETHAddress() public nonPayable { \n    return _wETHAddress;\n}\n\nfunction _swapThreshold() public nonPayable { \n    return __swapThreshold;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction _marketingSellTax() public nonPayable { \n    return __marketingSellTax;\n}\n\nfunction () public payable { \n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg0, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    if (_allowance[varg0][msg.sender] != _totalSupply) {\n        v0 = _SafeSub('Insufficient Allowance', varg2, _allowance[varg0][msg.sender]);\n        _allowance[varg0][msg.sender] = v0;\n    }\n    v1 = @_transferFrom_2514(varg2, varg1, varg0);\n    return bool(v1);\n}\n\nfunction getBuyTax() public nonPayable { \n    v0 = @getBuyTax_2614();\n    return v0;\n}\n\nfunction getTotalTax() public nonPayable { \n    v0 = @getTotalTax_2640();\n    return v0;\n}\n\nfunction _operaTax() public nonPayable { \n    return __operaTax;\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(_getOwner == address(varg0));\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction routerAddress() public nonPayable { \n    return _routerAddress;\n}\n\nfunction clearStuckBalance() public nonPayable { \n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction _totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction _liquiditySellTax() public nonPayable { \n    return __liquiditySellTax;\n}\n\nfunction approveMax(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    _allowance[msg.sender][varg0] = _totalSupply;\n    emit Approval(msg.sender, varg0, _totalSupply);\n    return bool(1);\n}\n\nfunction OperaFactoryAddress() public nonPayable { \n    return _operaFactoryAddress;\n}\n\nfunction setMaxWallet(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    __maxWalletToken = varg0 * _totalSupply / 1000;\n    require(500, Panic(18)); // division by zero\n    require(__maxWalletToken >= _totalSupply / 500, Error('Max Wallet must be greater than 0.2%.'));\n}\n\nfunction updateAboutMe(string varg0, string varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new bytes[](varg0.length);\n    require(!((v0 + (63 + (~0x1f & varg0.length + 31) & ~0x1f) < v0) | (v0 + (63 + (~0x1f & varg0.length + 31) & ~0x1f) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)\n    require(4 + varg0 + varg0.length + 32 <= msg.data.length);\n    CALLDATACOPY(v0.data, varg0.data, varg0.length);\n    v0[varg0.length] = 0;\n    require(varg1 <= uint64.max);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v1 = new bytes[](varg1.length);\n    require(!((v1 + (63 + (~0x1f & varg1.length + 31) & ~0x1f) < v1) | (v1 + (63 + (~0x1f & varg1.length + 31) & ~0x1f) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)\n    require(4 + varg1 + varg1.length + 32 <= msg.data.length);\n    CALLDATACOPY(v1.data, varg1.data, varg1.length);\n    v1[varg1.length] = 0;\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(v0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v2 = v3 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v2 = v4 = v3 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v2 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v2 > 31) {\n        v5 = v6 = _@aboutMe_3219.data;\n        v5 = v7 = v6 + (v0.length + 31 >> 5);\n        while (v5 < v6 + (v2 + 31 >> 5)) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        // Unknown jump to Block 0x2618B0xe33B0x51f. Refer to 3-address code (TAC);\n    }\n    v8 = v9 = 32;\n    if (v0.length > 31 == 1) {\n        v10 = v11 = 0;\n        v12 = v13 = _@aboutMe_3219.data;\n        while (v10 < v0.length & ~0x1f) {\n            STORAGE[v12] = MEM[v8 + v0];\n            v8 += v9;\n            v12 = v12 + 1;\n            v10 += v9;\n        }\n        if (v0.length & ~0x1f < v0.length) {\n            STORAGE[v12] = ~(~0 >> (0xf8 & v0.length << 3)) & MEM[v8 + v0];\n        }\n        _@aboutMe_3219 = (v0.length << 1) + 1;\n        // Unknown jump to Block 0xe3fB0x51f. Refer to 3-address code (TAC);\n    } else {\n        v14 = v15 = 0;\n        if (v0.length) {\n            v14 = MEM[v0.data];\n        }\n        _@aboutMe_3219 = v0.length << 1 | ~(~0 >> (v0.length << 3)) & v14;\n    }\n    require(v1.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v16 = v17 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v16 = v18 = v17 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v16 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v16 > 31) {\n        v19 = v20 = array_5.data;\n        v19 = v21 = v20 + (v1.length + 31 >> 5);\n        while (v19 < v20 + (v16 + 31 >> 5)) {\n            STORAGE[v19] = 0;\n            v19 += 1;\n        }\n        // Unknown jump to Block 0x2618B0xe3fB0x51f. Refer to 3-address code (TAC);\n    }\n    v22 = v23 = 32;\n    if (v1.length > 31 == 1) {\n        v24 = v25 = 0;\n        v26 = v27 = array_5.data;\n        while (v24 < v1.length & ~0x1f) {\n            STORAGE[v26] = MEM[v22 + v1];\n            v22 += v23;\n            v26 = v26 + 1;\n            v24 += v23;\n        }\n        if (v1.length & ~0x1f < v1.length) {\n            STORAGE[v26] = ~(~0 >> (0xf8 & v1.length << 3)) & MEM[v22 + v1];\n        }\n        array_5 = (v1.length << 1) + 1;\n        // Unknown jump to Block 0x2f57B0x51f. Refer to 3-address code (TAC);\n    } else {\n        v28 = v29 = 0;\n        if (v1.length) {\n            v28 = MEM[v1.data];\n        }\n        array_5 = v1.length << 1 | ~(~0 >> (v1.length << 3)) & v28;\n    }\n}\n\nfunction _devAddress() public nonPayable { \n    return __devAddress;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction setFeeExemption(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _@takeFee_2600[varg0] = varg1 | bytes31(_@takeFee_2600[address(varg0)]);\n}\n\nfunction _maxWalletToken() public nonPayable { \n    return __maxWalletToken;\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction setAddresses(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    if (varg0) {\n        __marketingAddress = varg0;\n    }\n    if (varg1) {\n        __devAddress = varg1;\n    }\n    v0 = v1 = stor_15_0_0;\n    if (__devAddress) {\n        v0 = stor_16_0_0;\n    }\n    require(v0, Error(\"Reciever wallets can't be Zero address.\"));\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_2160();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    if (_getOwner - msg.sender) {\n        v0 = v1 = @_transferFrom_2514(varg1, varg0, msg.sender);\n    } else {\n        v0 = v2 = @_basicTransfer_2325(varg1, varg0, msg.sender);\n    }\n    return bool(v0);\n}\n\nfunction getSellTax() public nonPayable { \n    v0 = @getSellTax_2628();\n    return v0;\n}\n\nfunction authorize(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _isAuthorized[varg0] = 0x1 | bytes31(_isAuthorized[address(varg0)]);\n}\n\nfunction aboutMe() public nonPayable { \n    v0, v1 = @aboutMe_3219();\n    v2 = new bytes[](v1.length);\n    v3 = 0;\n    while (v3 < v1.length) {\n        v2[v3] = v1[v3];\n        v3 += 32;\n    }\n    v2[v1.length] = 0;\n    v4 = new bytes[](v0.length);\n    v2[v1.length + 31 & ~0x1f] = v0.length;\n    v5 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v4[v0.length] = 0;\n    return v2, v4;\n}\n\nfunction _marketingAddress() public nonPayable { \n    return __marketingAddress;\n}\n\nfunction OperaRevenueAddress() public nonPayable { \n    return _operaRevenueAddress;\n}\n\nfunction _devBuyTax() public nonPayable { \n    return __devBuyTax;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction _liquidityBuyTax() public nonPayable { \n    return __liquidityBuyTax;\n}\n\nfunction setTokenSwapSettings(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    __swapThreshold = varg0 * _totalSupply / 1000;\n    require(20, Panic(18)); // division by zero\n    v0 = v1 = __swapThreshold <= _totalSupply / 20;\n    if (!bool(__swapThreshold > _totalSupply / 20)) {\n        require(500, Panic(18)); // division by zero\n        v0 = __swapThreshold >= _totalSupply / 500;\n    }\n    require(v0, Error('Swap Threshold must be less than 5% of total supply, or greater than 0.2%.'));\n}\n\nfunction unauthorize(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _isAuthorized[varg0] = bytes31(_isAuthorized[address(varg0)]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _getOwner = varg0;\n    _isAuthorized[varg0] = 0x1 | bytes31(_isAuthorized[address(varg0)]);\n    emit 0x4dba622d284ed0014ee4b9a6a68386be1a4c08a4913ae272de89199cc686163(varg0);\n}\n\nfunction router() public nonPayable { \n    return _router;\n}\n\nfunction _marketingBuyTax() public nonPayable { \n    return __marketingBuyTax;\n}\n\nfunction isAuthorized(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isAuthorized[address(varg0)]));\n}\n\nfunction @name_2169() private { \n    v0 = v1 = _@name_2169.length >> 1;\n    if (!(_@name_2169.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_2169.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_2169.length >> 1;\n    if (!(_@name_2169.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_2169.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_2169.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_2169.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @getBuyTax_2614() private { \n    require(__liquidityBuyTax <= __devBuyTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    require(__devBuyTax + __liquidityBuyTax <= __marketingBuyTax + (__devBuyTax + __liquidityBuyTax), Panic(17)); // arithmetic overflow or underflow\n    require(__marketingBuyTax + (__devBuyTax + __liquidityBuyTax) <= __operaTax + (__marketingBuyTax + (__devBuyTax + __liquidityBuyTax)), Panic(17)); // arithmetic overflow or underflow\n    return __operaTax + (__marketingBuyTax + (__devBuyTax + __liquidityBuyTax));\n}\n\nfunction @getTotalTax_2640() private { \n    v0 = @getBuyTax_2614();\n    v1 = @getSellTax_2628();\n    require(v1 <= v0 + v1, Panic(17)); // arithmetic overflow or underflow\n    return v0 + v1;\n}\n\nfunction @symbol_2160() private { \n    v0 = v1 = _@symbol_2160.length >> 1;\n    if (!(_@symbol_2160.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_2160.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_2160.length >> 1;\n    if (!(_@symbol_2160.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_2160.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_2160.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_2160.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x6af65929 > v0) {\n            if (0x2d2fe717 > v0) {\n                if (0xe5a9231 > v0) {\n                    if (0x10cf559 == v0) {\n                        _devSellTax();\n                    } else if (0x4d4c990 == v0) {\n                        setTaxes(uint256,uint256,uint256,uint256,uint256,uint256);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else {\n                        require(0xaf88b24 == v0);\n                        WETHAddress();\n                    }\n                } else if (0xe5a9231 == v0) {\n                    _swapThreshold();\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1f1b845b == v0) {\n                    _marketingSellTax();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x252d723a == v0) {\n                    getBuyTax();\n                } else {\n                    require(0x276ef2d5 == v0);\n                    getTotalTax();\n                }\n            } else if (0x3eaaf86b > v0) {\n                if (0x2d2fe717 == v0) {\n                    _operaTax();\n                } else if (0x2f54bf6e == v0) {\n                    isOwner(address);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x3268cc56 == v0) {\n                    routerAddress();\n                } else {\n                    require(0x364333f4 == v0);\n                    clearStuckBalance();\n                }\n            } else if (0x3eaaf86b == v0) {\n                _totalSupply();\n            } else if (0x43e67270 == v0) {\n                _liquiditySellTax();\n            } else if (0x571ac8b0 == v0) {\n                approveMax(address);\n            } else if (0x5b64c5a9 == v0) {\n                OperaFactoryAddress();\n            } else if (0x5d0044ca == v0) {\n                setMaxWallet(uint256);\n            } else {\n                require(0x60959b56 == v0);\n                updateAboutMe(string,string);\n            }\n        } else if (0xbc7a2898 > v0) {\n            if (0x90107afe > v0) {\n                if (0x6af65929 == v0) {\n                    _devAddress();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x751fd179 == v0) {\n                    setFeeExemption(address,bool);\n                } else if (0x78109e54 == v0) {\n                    _maxWalletToken();\n                } else {\n                    require(0x893d20e8 == v0);\n                    getOwner();\n                }\n            } else if (0x90107afe == v0) {\n                setAddresses(address,address);\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else if (0xa8aa1b31 == v0) {\n                pair();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xb0bc85de == v0) {\n                getSellTax();\n            } else {\n                require(0xb6a5d7de == v0);\n                authorize(address);\n            }\n        } else if (0xe5f2758f > v0) {\n            if (0xbc7a2898 == v0) {\n                aboutMe();\n            } else if (0xcaac7934 == v0) {\n                _marketingAddress();\n            } else if (0xd9d9666c == v0) {\n                OperaRevenueAddress();\n            } else if (0xdd03bf86 == v0) {\n                _devBuyTax();\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else {\n                require(0xe4202954 == v0);\n                _liquidityBuyTax();\n            }\n        } else if (0xe5f2758f == v0) {\n            setTokenSwapSettings(uint256);\n        } else if (0xf0b37c04 == v0) {\n            unauthorize(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf887ea40 == v0) {\n            router();\n        } else if (0xfb4aa585 == v0) {\n            _marketingBuyTax();\n        } else {\n            require(0xfe9fbb80 == v0);\n            isAuthorized(address);\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.17 05:37 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _isAuthorized; // STORAGE[0x1]\nuint256[] _@name_2169; // STORAGE[0x2]\nuint256[] _@symbol_2160; // STORAGE[0x3]\nuint256[] _@aboutMe_3219; // STORAGE[0x4]\nuint256[] array_5; // STORAGE[0x5]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 __maxWalletToken; // STORAGE[0x7]\nuint256 __swapThreshold; // STORAGE[0x8]\nuint256 __operaTax; // STORAGE[0x9]\nuint256 __marketingBuyTax; // STORAGE[0xa]\nuint256 __marketingSellTax; // STORAGE[0xb]\nuint256 __devBuyTax; // STORAGE[0xc]\nuint256 __devSellTax; // STORAGE[0xd]\nuint256 __liquidityBuyTax; // STORAGE[0xe]\nuint256 __liquiditySellTax; // STORAGE[0xf]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x10]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x11]\nmapping (uint256 => uint256) _@takeFee_2600; // STORAGE[0x12]\nuint256 _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_15_0_0; // STORAGE[0x15] bytes 0 to 0\nuint256 stor_16_0_0; // STORAGE[0x16] bytes 0 to 0\nuint256 _pair; // STORAGE[0x13] bytes 0 to 19\nuint256 _routerAddress; // STORAGE[0x14] bytes 0 to 19\nuint256 __devAddress; // STORAGE[0x15] bytes 0 to 19\nuint256 __marketingAddress; // STORAGE[0x16] bytes 0 to 19\nuint256 _operaRevenueAddress; // STORAGE[0x17] bytes 0 to 19\nuint256 _operaFactoryAddress; // STORAGE[0x18] bytes 0 to 19\nuint256 _wETHAddress; // STORAGE[0x19] bytes 0 to 19\nuint256 _router; // STORAGE[0x1a] bytes 0 to 19\nuint256 stor_1a_20_20; // STORAGE[0x1a] bytes 20 to 20\nuint256 stor_1a_21_21; // STORAGE[0x1a] bytes 21 to 21\nuint256 stor_1a_22_22; // STORAGE[0x1a] bytes 22 to 22\n\n\n// Events\nApproval(address, address, uint256);\nAutoLiquify(uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction @getSellTax_2628() private { \n    require(__liquiditySellTax <= __devSellTax + __liquiditySellTax, Panic(17)); // arithmetic overflow or underflow\n    require(__devSellTax + __liquiditySellTax <= __marketingSellTax + (__devSellTax + __liquiditySellTax), Panic(17)); // arithmetic overflow or underflow\n    require(__marketingSellTax + (__devSellTax + __liquiditySellTax) <= __operaTax + (__marketingSellTax + (__devSellTax + __liquiditySellTax)), Panic(17)); // arithmetic overflow or underflow\n    return __operaTax + (__marketingSellTax + (__devSellTax + __liquiditySellTax));\n}\n\nfunction @aboutMe_3219() private { \n    v0 = v1 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v6) {\n        if (31 < v6) {\n            v9 = v10 = _@aboutMe_3219.data;\n            do {\n                MEM[v4] = STORAGE[v9];\n                v9 += 1;\n                v4 += 32;\n            } while (v5 + v6 <= v4);\n        } else {\n            MEM[v5] = _@aboutMe_3219.length >> 8 << 8;\n        }\n    }\n    v11 = v12 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v11 = v13 = v12 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v11 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v14 = new bytes[](v11);\n    v15 = v16 = v14.data;\n    v17 = v18 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v17 = v19 = v18 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v17 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v17) {\n        return v14, v3;\n    } else if (31 < v17) {\n        v20 = v21 = array_5.data;\n        do {\n            MEM[v15] = STORAGE[v20];\n            v20 += 1;\n            v15 += 32;\n        } while (v16 + v17 <= v15);\n        return v14, v3;\n    } else {\n        MEM[v16] = array_5.length >> 8 << 8;\n        return v14, v3;\n    }\n}\n\nfunction @tokenSwap_3028() private { \n    stor_1a_20_20 = 1;\n    v0 = v1 = _balanceOf[this];\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__liquiditySellTax + __liquidityBuyTax > 0) {\n        v2 = @getTotalTax_2640();\n        require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v3 = _SafeMul(__liquiditySellTax + __liquidityBuyTax, v1);\n        v4 = _SafeDiv(v2, v3);\n        v0 = v5 = _SafeDiv(2, v4);\n    } else {\n        v0 = v6 = 0;\n    }\n    v0 = v7 = _SafeSub('SafeMath: subtraction overflow', v0, v1);\n    v0 = v8 = new address[](2);\n    CALLDATACOPY(v8.data, msg.data.length, 64);\n    require(0 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v9 = v8.data;\n    v8[0] = address(this);\n    require(1 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v8[1] = _wETHAddress;\n    v0 = v10 = this.balance;\n    v11 = new address[](v8.length);\n    v12 = v13 = v11.data;\n    v14 = v15 = v8.data;\n    v16 = v17 = 0;\n    while (v16 < v8.length) {\n        MEM[v12] = address(MEM[v14]);\n        v14 += 32;\n        v12 += 32;\n        v16 += 1;\n    }\n    require(bool(_router.code.size));\n    v18 = _router.swapExactTokensForETHSupportingFeeOnTransferTokens(v7, 0, v11, address(this), block.timestamp, v19, address(this)).gas(msg.gas);\n    require(bool(v18), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v0 = v20 = 0;\n    v0 = v21 = _SafeSub('SafeMath: subtraction overflow', v10, this.balance);\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__liquiditySellTax + __liquidityBuyTax > 0) {\n        require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v22 = _SafeDiv(2, __liquiditySellTax + __liquidityBuyTax);\n        v23 = @getTotalTax_2640();\n        v0 = _SafeSub('SafeMath: subtraction overflow', v22, v23);\n        // Unknown jump to Block 0x15d0. Refer to 3-address code (TAC);\n    } else {\n        v0 = v24 = @getTotalTax_2640();\n    }\n    v0 = v25 = 0;\n    v0 = v26 = 5623;\n    v0 = v27 = 2;\n    v0 = v28 = 12942;\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    v29 = v30 = _SafeMul(__liquiditySellTax + __liquidityBuyTax, v21);\n    while (1) {\n        v29 = _SafeDiv(v0, v29);\n    }\n    require(__devBuyTax <= __devSellTax + __devBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__devSellTax + __devBuyTax > 0) {\n        require(__devBuyTax <= __devSellTax + __devBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v31 = _SafeMul(__devSellTax + __devBuyTax, v0);\n        v32 = _SafeDiv(v0, v31);\n        v33, /* uint256 */ v34 = __devAddress.call().value(v32).gas(0x186a0);\n        if (RETURNDATASIZE() != 0) {\n            v35 = new bytes[](RETURNDATASIZE());\n            v34 = v35.data;\n            RETURNDATACOPY(v34, 0, RETURNDATASIZE());\n        }\n    }\n    require(__marketingBuyTax <= __marketingSellTax + __marketingBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__marketingSellTax + __marketingBuyTax > 0) {\n        require(__marketingBuyTax <= __marketingSellTax + __marketingBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v36 = _SafeMul(__marketingSellTax + __marketingBuyTax, v0);\n        v37 = _SafeDiv(v0, v36);\n        v38, /* uint256 */ v39 = __marketingAddress.call().value(v37).gas(0x186a0);\n        if (RETURNDATASIZE() != 0) {\n            v40 = new bytes[](RETURNDATASIZE());\n            v39 = v40.data;\n            RETURNDATACOPY(v39, 0, RETURNDATASIZE());\n        }\n    }\n    if (v0) {\n        if (stor_1a_22_22) {\n            v41 = v42 = _operaFactoryAddress;\n        } else {\n            v41 = v43 = __marketingAddress;\n        }\n        v44, /* uint256 */ v45, /* uint256 */ v46, /* uint256 */ v47 = _router.addLiquidityETH(this, v0, 0, 0, address(v41), block.timestamp).value(v29).gas(msg.gas);\n        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n        emit AutoLiquify(v29, v0);\n    }\n    v48 = _SafeMul(2, __operaTax);\n    v49 = _SafeMul(v48, v0);\n    v50 = _SafeDiv(v0, v49);\n    require(bool(_operaRevenueAddress.code.size));\n    v51 = _operaRevenueAddress.recieveRewards().value(v50).gas(msg.gas);\n    require(bool(v51), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    stor_1a_20_20 = 0;\n    return v1;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @_transferFrom_2514(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = 0;\n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    v2 = v3 = uint8(_isAuthorized[address(varg2)]);\n    if (!v3) {\n        v2 = v4 = uint8(_isAuthorized[address(varg1)]);\n    }\n    if (!v2) {\n        if (!stor_1a_20_20) {\n            v5 = v6 = !uint8(_isAuthorized[address(varg2)]);\n            if (!bool(uint8(_isAuthorized[address(varg2)]))) {\n                v5 = v7 = !uint8(_isAuthorized[address(varg1)]);\n            }\n            if (v5) {\n                v5 = v8 = this != address(varg1);\n            }\n            if (v5) {\n                v5 = v9 = this != address(varg2);\n            }\n            if (v5) {\n                v5 = v10 = address(varg1) != 57005;\n            }\n            if (v5) {\n                v5 = v11 = _pair != address(varg1);\n            }\n            if (v5) {\n                v5 = v12 = __marketingAddress != address(varg1);\n            }\n            if (v5) {\n                v5 = v13 = __devAddress != address(varg1);\n            }\n            if (v5) {\n                v5 = _operaFactoryAddress != address(varg1);\n            }\n            if (v5) {\n                require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                require(varg0 + _balanceOf[address(varg1)] <= __maxWalletToken, Error('Total Holding is currently limited, you can not buy that much.'));\n                // Unknown jump to Block 0x19d9. Refer to 3-address code (TAC);\n            }\n            v14 = @shouldTokenSwap_3056(varg1);\n            if (v14) {\n                varg0 = v15 = 6639;\n                v16 = @tokenSwap_3028();\n            }\n            v17 = address(varg0);\n            v18 = _SafeSub('Insufficient Balance', varg0, _balanceOf[v17]);\n            v19 = address(varg0);\n            _balanceOf[v19] = v18;\n            v20 = v21 = stor_1a_21_21;\n            if (v21) {\n                v20 = v22 = _pair == address(v0);\n                if (_pair != address(v0)) {\n                    v20 = v23 = _pair == address(varg0);\n                }\n            }\n            if (v20) {\n                varg0 = v24 = @takeFee_2600(varg0, v0, varg0);\n            }\n            v25 = _SafeAdd(varg0, _balanceOf[address(v0)]);\n            _balanceOf[address(v0)] = v25;\n            emit Transfer(address(varg0), address(v0), varg0);\n            return 1;\n        } else {\n            v26 = v27 = @_basicTransfer_2325(varg0, varg1, varg2);\n        }\n    } else {\n        v26 = v28 = @_basicTransfer_2325(varg0, varg1, varg2);\n    }\n    return v26;\n}\n\nfunction @_basicTransfer_2325(uint256 varg0, address varg1, address varg2) private { \n    v0 = _SafeSub('Insufficient Balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (0 - varg1) {\n        v0 = varg0 * varg1;\n        require((varg0 == v0 / varg1) | !varg1, Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(v0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @shouldTokenSwap_3056(address varg0) private { \n    v0 = v1 = _pair == varg0;\n    if (v1) {\n        v0 = v2 = stor_1a_21_21;\n    }\n    if (v0) {\n        v0 = v3 = !stor_1a_20_20;\n    }\n    if (!v0) {\n        return v0;\n    } else {\n        return _balanceOf[this] >= __swapThreshold;\n    }\n}\n\nfunction @takeFee_2600(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = uint8(_@takeFee_2600[address(varg2)]);\n    if (!v1) {\n        v0 = v2 = uint8(_@takeFee_2600[address(varg1)]);\n    }\n    if (!v0) {\n        if (varg1 - _operaFactoryAddress) {\n            if (_pair == varg1) {\n                v3 = v4 = @getSellTax_2628();\n            } else {\n                v3 = v5 = @getBuyTax_2614();\n            }\n            v6 = _SafeMul(v3, varg0);\n            v7 = _SafeDiv(1000, v6);\n            v8 = _SafeAdd(v7, _balanceOf[this]);\n            _balanceOf[this] = v8;\n            emit Transfer(varg2, this, v7);\n            v9 = _SafeSub('SafeMath: subtraction overflow', v7, varg0);\n            return v9;\n        } else {\n            return varg0;\n        }\n    } else {\n        return varg0;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _devSellTax() public nonPayable { \n    return __devSellTax;\n}\n\nfunction setTaxes(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    v0 = v1 = _balanceOf[this];\n    if (!(20 - __operaTax)) {\n        if (v1) {\n            v2 = v3 = 2255;\n            v4 = @tokenSwap_3028();\n        }\n        __operaTax = 4;\n    }\n    __marketingBuyTax = varg2;\n    __liquidityBuyTax = v0;\n    __devBuyTax = v0;\n    __marketingSellTax = v2;\n    __liquiditySellTax = v2;\n    __devSellTax = v2;\n    if (stor_1a_22_22) {\n        v5 = v6 = 100;\n    } else {\n        v5 = v7 = 500;\n    }\n    v8 = @getBuyTax_2614();\n    if (v8 <= uint16(v5)) {\n        if (stor_1a_22_22) {\n            v9 = v10 = 100;\n        } else {\n            v9 = v11 = 500;\n        }\n        v12 = @getSellTax_2628();\n        require(v12 <= uint16(v9), Error(\"Sell tax can't be greater than 10% if borrowed lp and 50% if not.\"));\n        exit;\n    } else {\n        v13 = new uint256[](\"Buy tax can't be greater than 10\");\n        revert(Error(\"Buy tax can't be greater than 10% if borrowed lp and 50% if not.\", v13));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = @name_2169();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    _allowance[msg.sender][varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return bool(1);\n}\n\nfunction WETHAddress() public nonPayable { \n    return _wETHAddress;\n}\n\nfunction _swapThreshold() public nonPayable { \n    return __swapThreshold;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction _marketingSellTax() public nonPayable { \n    return __marketingSellTax;\n}\n\nfunction () public payable { \n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg0, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    if (_allowance[varg0][msg.sender] != _totalSupply) {\n        v0 = _SafeSub('Insufficient Allowance', varg2, _allowance[varg0][msg.sender]);\n        _allowance[varg0][msg.sender] = v0;\n    }\n    v1 = @_transferFrom_2514(varg2, varg1, varg0);\n    return bool(v1);\n}\n\nfunction getBuyTax() public nonPayable { \n    v0 = @getBuyTax_2614();\n    return v0;\n}\n\nfunction getTotalTax() public nonPayable { \n    v0 = @getTotalTax_2640();\n    return v0;\n}\n\nfunction _operaTax() public nonPayable { \n    return __operaTax;\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(_getOwner == address(varg0));\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction routerAddress() public nonPayable { \n    return _routerAddress;\n}\n\nfunction clearStuckBalance() public nonPayable { \n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction _totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction _liquiditySellTax() public nonPayable { \n    return __liquiditySellTax;\n}\n\nfunction approveMax(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    _allowance[msg.sender][varg0] = _totalSupply;\n    emit Approval(msg.sender, varg0, _totalSupply);\n    return bool(1);\n}\n\nfunction OperaFactoryAddress() public nonPayable { \n    return _operaFactoryAddress;\n}\n\nfunction setMaxWallet(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    __maxWalletToken = varg0 * _totalSupply / 1000;\n    require(500, Panic(18)); // division by zero\n    require(__maxWalletToken >= _totalSupply / 500, Error('Max Wallet must be greater than 0.2%.'));\n}\n\nfunction updateAboutMe(string varg0, string varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new bytes[](varg0.length);\n    require(!((v0 + (63 + (~0x1f & varg0.length + 31) & ~0x1f) < v0) | (v0 + (63 + (~0x1f & varg0.length + 31) & ~0x1f) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)\n    require(4 + varg0 + varg0.length + 32 <= msg.data.length);\n    CALLDATACOPY(v0.data, varg0.data, varg0.length);\n    v0[varg0.length] = 0;\n    require(varg1 <= uint64.max);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v1 = new bytes[](varg1.length);\n    require(!((v1 + (63 + (~0x1f & varg1.length + 31) & ~0x1f) < v1) | (v1 + (63 + (~0x1f & varg1.length + 31) & ~0x1f) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)\n    require(4 + varg1 + varg1.length + 32 <= msg.data.length);\n    CALLDATACOPY(v1.data, varg1.data, varg1.length);\n    v1[varg1.length] = 0;\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(v0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v2 = v3 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v2 = v4 = v3 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v2 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v2 > 31) {\n        v5 = v6 = _@aboutMe_3219.data;\n        v5 = v7 = v6 + (v0.length + 31 >> 5);\n        while (v5 < v6 + (v2 + 31 >> 5)) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        // Unknown jump to Block 0x2618B0xe33B0x51f. Refer to 3-address code (TAC);\n    }\n    v8 = v9 = 32;\n    if (v0.length > 31 == 1) {\n        v10 = v11 = 0;\n        v12 = v13 = _@aboutMe_3219.data;\n        while (v10 < v0.length & ~0x1f) {\n            STORAGE[v12] = MEM[v8 + v0];\n            v8 += v9;\n            v12 = v12 + 1;\n            v10 += v9;\n        }\n        if (v0.length & ~0x1f < v0.length) {\n            STORAGE[v12] = ~(~0 >> (0xf8 & v0.length << 3)) & MEM[v8 + v0];\n        }\n        _@aboutMe_3219 = (v0.length << 1) + 1;\n        // Unknown jump to Block 0xe3fB0x51f. Refer to 3-address code (TAC);\n    } else {\n        v14 = v15 = 0;\n        if (v0.length) {\n            v14 = MEM[v0.data];\n        }\n        _@aboutMe_3219 = v0.length << 1 | ~(~0 >> (v0.length << 3)) & v14;\n    }\n    require(v1.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v16 = v17 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v16 = v18 = v17 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v16 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v16 > 31) {\n        v19 = v20 = array_5.data;\n        v19 = v21 = v20 + (v1.length + 31 >> 5);\n        while (v19 < v20 + (v16 + 31 >> 5)) {\n            STORAGE[v19] = 0;\n            v19 += 1;\n        }\n        // Unknown jump to Block 0x2618B0xe3fB0x51f. Refer to 3-address code (TAC);\n    }\n    v22 = v23 = 32;\n    if (v1.length > 31 == 1) {\n        v24 = v25 = 0;\n        v26 = v27 = array_5.data;\n        while (v24 < v1.length & ~0x1f) {\n            STORAGE[v26] = MEM[v22 + v1];\n            v22 += v23;\n            v26 = v26 + 1;\n            v24 += v23;\n        }\n        if (v1.length & ~0x1f < v1.length) {\n            STORAGE[v26] = ~(~0 >> (0xf8 & v1.length << 3)) & MEM[v22 + v1];\n        }\n        array_5 = (v1.length << 1) + 1;\n        // Unknown jump to Block 0x2f57B0x51f. Refer to 3-address code (TAC);\n    } else {\n        v28 = v29 = 0;\n        if (v1.length) {\n            v28 = MEM[v1.data];\n        }\n        array_5 = v1.length << 1 | ~(~0 >> (v1.length << 3)) & v28;\n    }\n}\n\nfunction _devAddress() public nonPayable { \n    return __devAddress;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction setFeeExemption(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _@takeFee_2600[varg0] = varg1 | bytes31(_@takeFee_2600[address(varg0)]);\n}\n\nfunction _maxWalletToken() public nonPayable { \n    return __maxWalletToken;\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction setAddresses(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    if (varg0) {\n        __marketingAddress = varg0;\n    }\n    if (varg1) {\n        __devAddress = varg1;\n    }\n    v0 = v1 = stor_15_0_0;\n    if (__devAddress) {\n        v0 = stor_16_0_0;\n    }\n    require(v0, Error(\"Reciever wallets can't be Zero address.\"));\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_2160();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    if (_getOwner - msg.sender) {\n        v0 = v1 = @_transferFrom_2514(varg1, varg0, msg.sender);\n    } else {\n        v0 = v2 = @_basicTransfer_2325(varg1, varg0, msg.sender);\n    }\n    return bool(v0);\n}\n\nfunction getSellTax() public nonPayable { \n    v0 = @getSellTax_2628();\n    return v0;\n}\n\nfunction authorize(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _isAuthorized[varg0] = 0x1 | bytes31(_isAuthorized[address(varg0)]);\n}\n\nfunction aboutMe() public nonPayable { \n    v0, v1 = @aboutMe_3219();\n    v2 = new bytes[](v1.length);\n    v3 = 0;\n    while (v3 < v1.length) {\n        v2[v3] = v1[v3];\n        v3 += 32;\n    }\n    v2[v1.length] = 0;\n    v4 = new bytes[](v0.length);\n    v2[v1.length + 31 & ~0x1f] = v0.length;\n    v5 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v4[v0.length] = 0;\n    return v2, v4;\n}\n\nfunction _marketingAddress() public nonPayable { \n    return __marketingAddress;\n}\n\nfunction OperaRevenueAddress() public nonPayable { \n    return _operaRevenueAddress;\n}\n\nfunction _devBuyTax() public nonPayable { \n    return __devBuyTax;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction _liquidityBuyTax() public nonPayable { \n    return __liquidityBuyTax;\n}\n\nfunction setTokenSwapSettings(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    __swapThreshold = varg0 * _totalSupply / 1000;\n    require(20, Panic(18)); // division by zero\n    v0 = v1 = __swapThreshold <= _totalSupply / 20;\n    if (!bool(__swapThreshold > _totalSupply / 20)) {\n        require(500, Panic(18)); // division by zero\n        v0 = __swapThreshold >= _totalSupply / 500;\n    }\n    require(v0, Error('Swap Threshold must be less than 5% of total supply, or greater than 0.2%.'));\n}\n\nfunction unauthorize(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _isAuthorized[varg0] = bytes31(_isAuthorized[address(varg0)]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _getOwner = varg0;\n    _isAuthorized[varg0] = 0x1 | bytes31(_isAuthorized[address(varg0)]);\n    emit 0x4dba622d284ed0014ee4b9a6a68386be1a4c08a4913ae272de89199cc686163(varg0);\n}\n\nfunction router() public nonPayable { \n    return _router;\n}\n\nfunction _marketingBuyTax() public nonPayable { \n    return __marketingBuyTax;\n}\n\nfunction isAuthorized(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isAuthorized[address(varg0)]));\n}\n\nfunction @name_2169() private { \n    v0 = v1 = _@name_2169.length >> 1;\n    if (!(_@name_2169.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_2169.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_2169.length >> 1;\n    if (!(_@name_2169.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_2169.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_2169.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_2169.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @getBuyTax_2614() private { \n    require(__liquidityBuyTax <= __devBuyTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    require(__devBuyTax + __liquidityBuyTax <= __marketingBuyTax + (__devBuyTax + __liquidityBuyTax), Panic(17)); // arithmetic overflow or underflow\n    require(__marketingBuyTax + (__devBuyTax + __liquidityBuyTax) <= __operaTax + (__marketingBuyTax + (__devBuyTax + __liquidityBuyTax)), Panic(17)); // arithmetic overflow or underflow\n    return __operaTax + (__marketingBuyTax + (__devBuyTax + __liquidityBuyTax));\n}\n\nfunction @getTotalTax_2640() private { \n    v0 = @getBuyTax_2614();\n    v1 = @getSellTax_2628();\n    require(v1 <= v0 + v1, Panic(17)); // arithmetic overflow or underflow\n    return v0 + v1;\n}\n\nfunction @symbol_2160() private { \n    v0 = v1 = _@symbol_2160.length >> 1;\n    if (!(_@symbol_2160.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_2160.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_2160.length >> 1;\n    if (!(_@symbol_2160.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_2160.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_2160.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_2160.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x6af65929 > v0) {\n            if (0x2d2fe717 > v0) {\n                if (0xe5a9231 > v0) {\n                    if (0x10cf559 == v0) {\n                        _devSellTax();\n                    } else if (0x4d4c990 == v0) {\n                        setTaxes(uint256,uint256,uint256,uint256,uint256,uint256);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else {\n                        require(0xaf88b24 == v0);\n                        WETHAddress();\n                    }\n                } else if (0xe5a9231 == v0) {\n                    _swapThreshold();\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1f1b845b == v0) {\n                    _marketingSellTax();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x252d723a == v0) {\n                    getBuyTax();\n                } else {\n                    require(0x276ef2d5 == v0);\n                    getTotalTax();\n                }\n            } else if (0x3eaaf86b > v0) {\n                if (0x2d2fe717 == v0) {\n                    _operaTax();\n                } else if (0x2f54bf6e == v0) {\n                    isOwner(address);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x3268cc56 == v0) {\n                    routerAddress();\n                } else {\n                    require(0x364333f4 == v0);\n                    clearStuckBalance();\n                }\n            } else if (0x3eaaf86b == v0) {\n                _totalSupply();\n            } else if (0x43e67270 == v0) {\n                _liquiditySellTax();\n            } else if (0x571ac8b0 == v0) {\n                approveMax(address);\n            } else if (0x5b64c5a9 == v0) {\n                OperaFactoryAddress();\n            } else if (0x5d0044ca == v0) {\n                setMaxWallet(uint256);\n            } else {\n                require(0x60959b56 == v0);\n                updateAboutMe(string,string);\n            }\n        } else if (0xbc7a2898 > v0) {\n            if (0x90107afe > v0) {\n                if (0x6af65929 == v0) {\n                    _devAddress();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x751fd179 == v0) {\n                    setFeeExemption(address,bool);\n                } else if (0x78109e54 == v0) {\n                    _maxWalletToken();\n                } else {\n                    require(0x893d20e8 == v0);\n                    getOwner();\n                }\n            } else if (0x90107afe == v0) {\n                setAddresses(address,address);\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else if (0xa8aa1b31 == v0) {\n                pair();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xb0bc85de == v0) {\n                getSellTax();\n            } else {\n                require(0xb6a5d7de == v0);\n                authorize(address);\n            }\n        } else if (0xe5f2758f > v0) {\n            if (0xbc7a2898 == v0) {\n                aboutMe();\n            } else if (0xcaac7934 == v0) {\n                _marketingAddress();\n            } else if (0xd9d9666c == v0) {\n                OperaRevenueAddress();\n            } else if (0xdd03bf86 == v0) {\n                _devBuyTax();\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else {\n                require(0xe4202954 == v0);\n                _liquidityBuyTax();\n            }\n        } else if (0xe5f2758f == v0) {\n            setTokenSwapSettings(uint256);\n        } else if (0xf0b37c04 == v0) {\n            unauthorize(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf887ea40 == v0) {\n            router();\n        } else if (0xfb4aa585 == v0) {\n            _marketingBuyTax();\n        } else {\n            require(0xfe9fbb80 == v0);\n            isAuthorized(address);\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.17 05:37 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _isAuthorized; // STORAGE[0x1]\nuint256[] _@name_2169; // STORAGE[0x2]\nuint256[] _@symbol_2160; // STORAGE[0x3]\nuint256[] _@aboutMe_3219; // STORAGE[0x4]\nuint256[] array_5; // STORAGE[0x5]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 __maxWalletToken; // STORAGE[0x7]\nuint256 __swapThreshold; // STORAGE[0x8]\nuint256 __operaTax; // STORAGE[0x9]\nuint256 __marketingBuyTax; // STORAGE[0xa]\nuint256 __marketingSellTax; // STORAGE[0xb]\nuint256 __devBuyTax; // STORAGE[0xc]\nuint256 __devSellTax; // STORAGE[0xd]\nuint256 __liquidityBuyTax; // STORAGE[0xe]\nuint256 __liquiditySellTax; // STORAGE[0xf]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x10]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x11]\nmapping (uint256 => uint256) _@takeFee_2600; // STORAGE[0x12]\nuint256 _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_15_0_0; // STORAGE[0x15] bytes 0 to 0\nuint256 stor_16_0_0; // STORAGE[0x16] bytes 0 to 0\nuint256 _pair; // STORAGE[0x13] bytes 0 to 19\nuint256 _routerAddress; // STORAGE[0x14] bytes 0 to 19\nuint256 __devAddress; // STORAGE[0x15] bytes 0 to 19\nuint256 __marketingAddress; // STORAGE[0x16] bytes 0 to 19\nuint256 _operaRevenueAddress; // STORAGE[0x17] bytes 0 to 19\nuint256 _operaFactoryAddress; // STORAGE[0x18] bytes 0 to 19\nuint256 _wETHAddress; // STORAGE[0x19] bytes 0 to 19\nuint256 _router; // STORAGE[0x1a] bytes 0 to 19\nuint256 stor_1a_20_20; // STORAGE[0x1a] bytes 20 to 20\nuint256 stor_1a_21_21; // STORAGE[0x1a] bytes 21 to 21\nuint256 stor_1a_22_22; // STORAGE[0x1a] bytes 22 to 22\n\n\n// Events\nApproval(address, address, uint256);\nAutoLiquify(uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction @getSellTax_2628() private { \n    require(__liquiditySellTax <= __devSellTax + __liquiditySellTax, Panic(17)); // arithmetic overflow or underflow\n    require(__devSellTax + __liquiditySellTax <= __marketingSellTax + (__devSellTax + __liquiditySellTax), Panic(17)); // arithmetic overflow or underflow\n    require(__marketingSellTax + (__devSellTax + __liquiditySellTax) <= __operaTax + (__marketingSellTax + (__devSellTax + __liquiditySellTax)), Panic(17)); // arithmetic overflow or underflow\n    return __operaTax + (__marketingSellTax + (__devSellTax + __liquiditySellTax));\n}\n\nfunction @aboutMe_3219() private { \n    v0 = v1 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v6) {\n        if (31 < v6) {\n            v9 = v10 = _@aboutMe_3219.data;\n            do {\n                MEM[v4] = STORAGE[v9];\n                v9 += 1;\n                v4 += 32;\n            } while (v5 + v6 <= v4);\n        } else {\n            MEM[v5] = _@aboutMe_3219.length >> 8 << 8;\n        }\n    }\n    v11 = v12 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v11 = v13 = v12 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v11 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v14 = new bytes[](v11);\n    v15 = v16 = v14.data;\n    v17 = v18 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v17 = v19 = v18 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v17 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v17) {\n        return v14, v3;\n    } else if (31 < v17) {\n        v20 = v21 = array_5.data;\n        do {\n            MEM[v15] = STORAGE[v20];\n            v20 += 1;\n            v15 += 32;\n        } while (v16 + v17 <= v15);\n        return v14, v3;\n    } else {\n        MEM[v16] = array_5.length >> 8 << 8;\n        return v14, v3;\n    }\n}\n\nfunction @tokenSwap_3028() private { \n    stor_1a_20_20 = 1;\n    v0 = v1 = _balanceOf[this];\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__liquiditySellTax + __liquidityBuyTax > 0) {\n        v2 = @getTotalTax_2640();\n        require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v3 = _SafeMul(__liquiditySellTax + __liquidityBuyTax, v1);\n        v4 = _SafeDiv(v2, v3);\n        v0 = v5 = _SafeDiv(2, v4);\n    } else {\n        v0 = v6 = 0;\n    }\n    v0 = v7 = _SafeSub('SafeMath: subtraction overflow', v0, v1);\n    v0 = v8 = new address[](2);\n    CALLDATACOPY(v8.data, msg.data.length, 64);\n    require(0 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v9 = v8.data;\n    v8[0] = address(this);\n    require(1 < v8.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v8[1] = _wETHAddress;\n    v0 = v10 = this.balance;\n    v11 = new address[](v8.length);\n    v12 = v13 = v11.data;\n    v14 = v15 = v8.data;\n    v16 = v17 = 0;\n    while (v16 < v8.length) {\n        MEM[v12] = address(MEM[v14]);\n        v14 += 32;\n        v12 += 32;\n        v16 += 1;\n    }\n    require(bool(_router.code.size));\n    v18 = _router.swapExactTokensForETHSupportingFeeOnTransferTokens(v7, 0, v11, address(this), block.timestamp, v19, address(this)).gas(msg.gas);\n    require(bool(v18), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v0 = v20 = 0;\n    v0 = v21 = _SafeSub('SafeMath: subtraction overflow', v10, this.balance);\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__liquiditySellTax + __liquidityBuyTax > 0) {\n        require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v22 = _SafeDiv(2, __liquiditySellTax + __liquidityBuyTax);\n        v23 = @getTotalTax_2640();\n        v0 = _SafeSub('SafeMath: subtraction overflow', v22, v23);\n        // Unknown jump to Block 0x15d0. Refer to 3-address code (TAC);\n    } else {\n        v0 = v24 = @getTotalTax_2640();\n    }\n    v0 = v25 = 0;\n    v0 = v26 = 5623;\n    v0 = v27 = 2;\n    v0 = v28 = 12942;\n    require(__liquidityBuyTax <= __liquiditySellTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    v29 = v30 = _SafeMul(__liquiditySellTax + __liquidityBuyTax, v21);\n    while (1) {\n        v29 = _SafeDiv(v0, v29);\n    }\n    require(__devBuyTax <= __devSellTax + __devBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__devSellTax + __devBuyTax > 0) {\n        require(__devBuyTax <= __devSellTax + __devBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v31 = _SafeMul(__devSellTax + __devBuyTax, v0);\n        v32 = _SafeDiv(v0, v31);\n        v33, /* uint256 */ v34 = __devAddress.call().value(v32).gas(0x186a0);\n        if (RETURNDATASIZE() != 0) {\n            v35 = new bytes[](RETURNDATASIZE());\n            v34 = v35.data;\n            RETURNDATACOPY(v34, 0, RETURNDATASIZE());\n        }\n    }\n    require(__marketingBuyTax <= __marketingSellTax + __marketingBuyTax, Panic(17)); // arithmetic overflow or underflow\n    if (__marketingSellTax + __marketingBuyTax > 0) {\n        require(__marketingBuyTax <= __marketingSellTax + __marketingBuyTax, Panic(17)); // arithmetic overflow or underflow\n        v36 = _SafeMul(__marketingSellTax + __marketingBuyTax, v0);\n        v37 = _SafeDiv(v0, v36);\n        v38, /* uint256 */ v39 = __marketingAddress.call().value(v37).gas(0x186a0);\n        if (RETURNDATASIZE() != 0) {\n            v40 = new bytes[](RETURNDATASIZE());\n            v39 = v40.data;\n            RETURNDATACOPY(v39, 0, RETURNDATASIZE());\n        }\n    }\n    if (v0) {\n        if (stor_1a_22_22) {\n            v41 = v42 = _operaFactoryAddress;\n        } else {\n            v41 = v43 = __marketingAddress;\n        }\n        v44, /* uint256 */ v45, /* uint256 */ v46, /* uint256 */ v47 = _router.addLiquidityETH(this, v0, 0, 0, address(v41), block.timestamp).value(v29).gas(msg.gas);\n        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n        emit AutoLiquify(v29, v0);\n    }\n    v48 = _SafeMul(2, __operaTax);\n    v49 = _SafeMul(v48, v0);\n    v50 = _SafeDiv(v0, v49);\n    require(bool(_operaRevenueAddress.code.size));\n    v51 = _operaRevenueAddress.recieveRewards().value(v50).gas(msg.gas);\n    require(bool(v51), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    stor_1a_20_20 = 0;\n    return v1;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @_transferFrom_2514(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = 0;\n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    v2 = v3 = uint8(_isAuthorized[address(varg2)]);\n    if (!v3) {\n        v2 = v4 = uint8(_isAuthorized[address(varg1)]);\n    }\n    if (!v2) {\n        if (!stor_1a_20_20) {\n            v5 = v6 = !uint8(_isAuthorized[address(varg2)]);\n            if (!bool(uint8(_isAuthorized[address(varg2)]))) {\n                v5 = v7 = !uint8(_isAuthorized[address(varg1)]);\n            }\n            if (v5) {\n                v5 = v8 = this != address(varg1);\n            }\n            if (v5) {\n                v5 = v9 = this != address(varg2);\n            }\n            if (v5) {\n                v5 = v10 = address(varg1) != 57005;\n            }\n            if (v5) {\n                v5 = v11 = _pair != address(varg1);\n            }\n            if (v5) {\n                v5 = v12 = __marketingAddress != address(varg1);\n            }\n            if (v5) {\n                v5 = v13 = __devAddress != address(varg1);\n            }\n            if (v5) {\n                v5 = _operaFactoryAddress != address(varg1);\n            }\n            if (v5) {\n                require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                require(varg0 + _balanceOf[address(varg1)] <= __maxWalletToken, Error('Total Holding is currently limited, you can not buy that much.'));\n                // Unknown jump to Block 0x19d9. Refer to 3-address code (TAC);\n            }\n            v14 = @shouldTokenSwap_3056(varg1);\n            if (v14) {\n                varg0 = v15 = 6639;\n                v16 = @tokenSwap_3028();\n            }\n            v17 = address(varg0);\n            v18 = _SafeSub('Insufficient Balance', varg0, _balanceOf[v17]);\n            v19 = address(varg0);\n            _balanceOf[v19] = v18;\n            v20 = v21 = stor_1a_21_21;\n            if (v21) {\n                v20 = v22 = _pair == address(v0);\n                if (_pair != address(v0)) {\n                    v20 = v23 = _pair == address(varg0);\n                }\n            }\n            if (v20) {\n                varg0 = v24 = @takeFee_2600(varg0, v0, varg0);\n            }\n            v25 = _SafeAdd(varg0, _balanceOf[address(v0)]);\n            _balanceOf[address(v0)] = v25;\n            emit Transfer(address(varg0), address(v0), varg0);\n            return 1;\n        } else {\n            v26 = v27 = @_basicTransfer_2325(varg0, varg1, varg2);\n        }\n    } else {\n        v26 = v28 = @_basicTransfer_2325(varg0, varg1, varg2);\n    }\n    return v26;\n}\n\nfunction @_basicTransfer_2325(uint256 varg0, address varg1, address varg2) private { \n    v0 = _SafeSub('Insufficient Balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (0 - varg1) {\n        v0 = varg0 * varg1;\n        require((varg0 == v0 / varg1) | !varg1, Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(v0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @shouldTokenSwap_3056(address varg0) private { \n    v0 = v1 = _pair == varg0;\n    if (v1) {\n        v0 = v2 = stor_1a_21_21;\n    }\n    if (v0) {\n        v0 = v3 = !stor_1a_20_20;\n    }\n    if (!v0) {\n        return v0;\n    } else {\n        return _balanceOf[this] >= __swapThreshold;\n    }\n}\n\nfunction @takeFee_2600(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = uint8(_@takeFee_2600[address(varg2)]);\n    if (!v1) {\n        v0 = v2 = uint8(_@takeFee_2600[address(varg1)]);\n    }\n    if (!v0) {\n        if (varg1 - _operaFactoryAddress) {\n            if (_pair == varg1) {\n                v3 = v4 = @getSellTax_2628();\n            } else {\n                v3 = v5 = @getBuyTax_2614();\n            }\n            v6 = _SafeMul(v3, varg0);\n            v7 = _SafeDiv(1000, v6);\n            v8 = _SafeAdd(v7, _balanceOf[this]);\n            _balanceOf[this] = v8;\n            emit Transfer(varg2, this, v7);\n            v9 = _SafeSub('SafeMath: subtraction overflow', v7, varg0);\n            return v9;\n        } else {\n            return varg0;\n        }\n    } else {\n        return varg0;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _devSellTax() public nonPayable { \n    return __devSellTax;\n}\n\nfunction setTaxes(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    v0 = v1 = _balanceOf[this];\n    if (!(20 - __operaTax)) {\n        if (v1) {\n            v2 = v3 = 2255;\n            v4 = @tokenSwap_3028();\n        }\n        __operaTax = 4;\n    }\n    __marketingBuyTax = varg2;\n    __liquidityBuyTax = v0;\n    __devBuyTax = v0;\n    __marketingSellTax = v2;\n    __liquiditySellTax = v2;\n    __devSellTax = v2;\n    if (stor_1a_22_22) {\n        v5 = v6 = 100;\n    } else {\n        v5 = v7 = 500;\n    }\n    v8 = @getBuyTax_2614();\n    if (v8 <= uint16(v5)) {\n        if (stor_1a_22_22) {\n            v9 = v10 = 100;\n        } else {\n            v9 = v11 = 500;\n        }\n        v12 = @getSellTax_2628();\n        require(v12 <= uint16(v9), Error(\"Sell tax can't be greater than 10% if borrowed lp and 50% if not.\"));\n        exit;\n    } else {\n        v13 = new uint256[](\"Buy tax can't be greater than 10\");\n        revert(Error(\"Buy tax can't be greater than 10% if borrowed lp and 50% if not.\", v13));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = @name_2169();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    _allowance[msg.sender][varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return bool(1);\n}\n\nfunction WETHAddress() public nonPayable { \n    return _wETHAddress;\n}\n\nfunction _swapThreshold() public nonPayable { \n    return __swapThreshold;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction _marketingSellTax() public nonPayable { \n    return __marketingSellTax;\n}\n\nfunction () public payable { \n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg0, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    if (_allowance[varg0][msg.sender] != _totalSupply) {\n        v0 = _SafeSub('Insufficient Allowance', varg2, _allowance[varg0][msg.sender]);\n        _allowance[varg0][msg.sender] = v0;\n    }\n    v1 = @_transferFrom_2514(varg2, varg1, varg0);\n    return bool(v1);\n}\n\nfunction getBuyTax() public nonPayable { \n    v0 = @getBuyTax_2614();\n    return v0;\n}\n\nfunction getTotalTax() public nonPayable { \n    v0 = @getTotalTax_2640();\n    return v0;\n}\n\nfunction _operaTax() public nonPayable { \n    return __operaTax;\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(_getOwner == address(varg0));\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction routerAddress() public nonPayable { \n    return _routerAddress;\n}\n\nfunction clearStuckBalance() public nonPayable { \n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction _totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction _liquiditySellTax() public nonPayable { \n    return __liquiditySellTax;\n}\n\nfunction approveMax(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    _allowance[msg.sender][varg0] = _totalSupply;\n    emit Approval(msg.sender, varg0, _totalSupply);\n    return bool(1);\n}\n\nfunction OperaFactoryAddress() public nonPayable { \n    return _operaFactoryAddress;\n}\n\nfunction setMaxWallet(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    __maxWalletToken = varg0 * _totalSupply / 1000;\n    require(500, Panic(18)); // division by zero\n    require(__maxWalletToken >= _totalSupply / 500, Error('Max Wallet must be greater than 0.2%.'));\n}\n\nfunction updateAboutMe(string varg0, string varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new bytes[](varg0.length);\n    require(!((v0 + (63 + (~0x1f & varg0.length + 31) & ~0x1f) < v0) | (v0 + (63 + (~0x1f & varg0.length + 31) & ~0x1f) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)\n    require(4 + varg0 + varg0.length + 32 <= msg.data.length);\n    CALLDATACOPY(v0.data, varg0.data, varg0.length);\n    v0[varg0.length] = 0;\n    require(varg1 <= uint64.max);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v1 = new bytes[](varg1.length);\n    require(!((v1 + (63 + (~0x1f & varg1.length + 31) & ~0x1f) < v1) | (v1 + (63 + (~0x1f & varg1.length + 31) & ~0x1f) > uint64.max)), Panic(65)); // failed memory allocation (too much memory)\n    require(4 + varg1 + varg1.length + 32 <= msg.data.length);\n    CALLDATACOPY(v1.data, varg1.data, varg1.length);\n    v1[varg1.length] = 0;\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(v0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v2 = v3 = _@aboutMe_3219.length >> 1;\n    if (!(_@aboutMe_3219.length & 0x1)) {\n        v2 = v4 = v3 & 0x7f;\n    }\n    require((_@aboutMe_3219.length & 0x1) - (v2 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v2 > 31) {\n        v5 = v6 = _@aboutMe_3219.data;\n        v5 = v7 = v6 + (v0.length + 31 >> 5);\n        while (v5 < v6 + (v2 + 31 >> 5)) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        // Unknown jump to Block 0x2618B0xe33B0x51f. Refer to 3-address code (TAC);\n    }\n    v8 = v9 = 32;\n    if (v0.length > 31 == 1) {\n        v10 = v11 = 0;\n        v12 = v13 = _@aboutMe_3219.data;\n        while (v10 < v0.length & ~0x1f) {\n            STORAGE[v12] = MEM[v8 + v0];\n            v8 += v9;\n            v12 = v12 + 1;\n            v10 += v9;\n        }\n        if (v0.length & ~0x1f < v0.length) {\n            STORAGE[v12] = ~(~0 >> (0xf8 & v0.length << 3)) & MEM[v8 + v0];\n        }\n        _@aboutMe_3219 = (v0.length << 1) + 1;\n        // Unknown jump to Block 0xe3fB0x51f. Refer to 3-address code (TAC);\n    } else {\n        v14 = v15 = 0;\n        if (v0.length) {\n            v14 = MEM[v0.data];\n        }\n        _@aboutMe_3219 = v0.length << 1 | ~(~0 >> (v0.length << 3)) & v14;\n    }\n    require(v1.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v16 = v17 = array_5.length >> 1;\n    if (!(array_5.length & 0x1)) {\n        v16 = v18 = v17 & 0x7f;\n    }\n    require((array_5.length & 0x1) - (v16 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (v16 > 31) {\n        v19 = v20 = array_5.data;\n        v19 = v21 = v20 + (v1.length + 31 >> 5);\n        while (v19 < v20 + (v16 + 31 >> 5)) {\n            STORAGE[v19] = 0;\n            v19 += 1;\n        }\n        // Unknown jump to Block 0x2618B0xe3fB0x51f. Refer to 3-address code (TAC);\n    }\n    v22 = v23 = 32;\n    if (v1.length > 31 == 1) {\n        v24 = v25 = 0;\n        v26 = v27 = array_5.data;\n        while (v24 < v1.length & ~0x1f) {\n            STORAGE[v26] = MEM[v22 + v1];\n            v22 += v23;\n            v26 = v26 + 1;\n            v24 += v23;\n        }\n        if (v1.length & ~0x1f < v1.length) {\n            STORAGE[v26] = ~(~0 >> (0xf8 & v1.length << 3)) & MEM[v22 + v1];\n        }\n        array_5 = (v1.length << 1) + 1;\n        // Unknown jump to Block 0x2f57B0x51f. Refer to 3-address code (TAC);\n    } else {\n        v28 = v29 = 0;\n        if (v1.length) {\n            v28 = MEM[v1.data];\n        }\n        array_5 = v1.length << 1 | ~(~0 >> (v1.length << 3)) & v28;\n    }\n}\n\nfunction _devAddress() public nonPayable { \n    return __devAddress;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction setFeeExemption(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _@takeFee_2600[varg0] = varg1 | bytes31(_@takeFee_2600[address(varg0)]);\n}\n\nfunction _maxWalletToken() public nonPayable { \n    return __maxWalletToken;\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction setAddresses(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    if (varg0) {\n        __marketingAddress = varg0;\n    }\n    if (varg1) {\n        __devAddress = varg1;\n    }\n    v0 = v1 = stor_15_0_0;\n    if (__devAddress) {\n        v0 = stor_16_0_0;\n    }\n    require(v0, Error(\"Reciever wallets can't be Zero address.\"));\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_2160();\n    v1 = new bytes[](v0.length);\n    v2 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    if (_getOwner - msg.sender) {\n        v0 = v1 = @_transferFrom_2514(varg1, varg0, msg.sender);\n    } else {\n        v0 = v2 = @_basicTransfer_2325(varg1, varg0, msg.sender);\n    }\n    return bool(v0);\n}\n\nfunction getSellTax() public nonPayable { \n    v0 = @getSellTax_2628();\n    return v0;\n}\n\nfunction authorize(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _isAuthorized[varg0] = 0x1 | bytes31(_isAuthorized[address(varg0)]);\n}\n\nfunction aboutMe() public nonPayable { \n    v0, v1 = @aboutMe_3219();\n    v2 = new bytes[](v1.length);\n    v3 = 0;\n    while (v3 < v1.length) {\n        v2[v3] = v1[v3];\n        v3 += 32;\n    }\n    v2[v1.length] = 0;\n    v4 = new bytes[](v0.length);\n    v2[v1.length + 31 & ~0x1f] = v0.length;\n    v5 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v4[v0.length] = 0;\n    return v2, v4;\n}\n\nfunction _marketingAddress() public nonPayable { \n    return __marketingAddress;\n}\n\nfunction OperaRevenueAddress() public nonPayable { \n    return _operaRevenueAddress;\n}\n\nfunction _devBuyTax() public nonPayable { \n    return __devBuyTax;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction _liquidityBuyTax() public nonPayable { \n    return __liquidityBuyTax;\n}\n\nfunction setTokenSwapSettings(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_isAuthorized[msg.sender]), Error('!AUTHORIZED'));\n    require(!stor_1a_20_20, Error('Cannot call when in swap'));\n    require(stor_1a_21_21, Error('This token has no taxes.'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    __swapThreshold = varg0 * _totalSupply / 1000;\n    require(20, Panic(18)); // division by zero\n    v0 = v1 = __swapThreshold <= _totalSupply / 20;\n    if (!bool(__swapThreshold > _totalSupply / 20)) {\n        require(500, Panic(18)); // division by zero\n        v0 = __swapThreshold >= _totalSupply / 500;\n    }\n    require(v0, Error('Swap Threshold must be less than 5% of total supply, or greater than 0.2%.'));\n}\n\nfunction unauthorize(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _isAuthorized[varg0] = bytes31(_isAuthorized[address(varg0)]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _getOwner, Error('!OWNER'));\n    _getOwner = varg0;\n    _isAuthorized[varg0] = 0x1 | bytes31(_isAuthorized[address(varg0)]);\n    emit 0x4dba622d284ed0014ee4b9a6a68386be1a4c08a4913ae272de89199cc686163(varg0);\n}\n\nfunction router() public nonPayable { \n    return _router;\n}\n\nfunction _marketingBuyTax() public nonPayable { \n    return __marketingBuyTax;\n}\n\nfunction isAuthorized(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isAuthorized[address(varg0)]));\n}\n\nfunction @name_2169() private { \n    v0 = v1 = _@name_2169.length >> 1;\n    if (!(_@name_2169.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_2169.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_2169.length >> 1;\n    if (!(_@name_2169.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_2169.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_2169.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_2169.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @getBuyTax_2614() private { \n    require(__liquidityBuyTax <= __devBuyTax + __liquidityBuyTax, Panic(17)); // arithmetic overflow or underflow\n    require(__devBuyTax + __liquidityBuyTax <= __marketingBuyTax + (__devBuyTax + __liquidityBuyTax), Panic(17)); // arithmetic overflow or underflow\n    require(__marketingBuyTax + (__devBuyTax + __liquidityBuyTax) <= __operaTax + (__marketingBuyTax + (__devBuyTax + __liquidityBuyTax)), Panic(17)); // arithmetic overflow or underflow\n    return __operaTax + (__marketingBuyTax + (__devBuyTax + __liquidityBuyTax));\n}\n\nfunction @getTotalTax_2640() private { \n    v0 = @getBuyTax_2614();\n    v1 = @getSellTax_2628();\n    require(v1 <= v0 + v1, Panic(17)); // arithmetic overflow or underflow\n    return v0 + v1;\n}\n\nfunction @symbol_2160() private { \n    v0 = v1 = _@symbol_2160.length >> 1;\n    if (!(_@symbol_2160.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_2160.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_2160.length >> 1;\n    if (!(_@symbol_2160.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_2160.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_2160.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_2160.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x6af65929 > v0) {\n            if (0x2d2fe717 > v0) {\n                if (0xe5a9231 > v0) {\n                    if (0x10cf559 == v0) {\n                        _devSellTax();\n                    } else if (0x4d4c990 == v0) {\n                        setTaxes(uint256,uint256,uint256,uint256,uint256,uint256);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else {\n                        require(0xaf88b24 == v0);\n                        WETHAddress();\n                    }\n                } else if (0xe5a9231 == v0) {\n                    _swapThreshold();\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1f1b845b == v0) {\n                    _marketingSellTax();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x252d723a == v0) {\n                    getBuyTax();\n                } else {\n                    require(0x276ef2d5 == v0);\n                    getTotalTax();\n                }\n            } else if (0x3eaaf86b > v0) {\n                if (0x2d2fe717 == v0) {\n                    _operaTax();\n                } else if (0x2f54bf6e == v0) {\n                    isOwner(address);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x3268cc56 == v0) {\n                    routerAddress();\n                } else {\n                    require(0x364333f4 == v0);\n                    clearStuckBalance();\n                }\n            } else if (0x3eaaf86b == v0) {\n                _totalSupply();\n            } else if (0x43e67270 == v0) {\n                _liquiditySellTax();\n            } else if (0x571ac8b0 == v0) {\n                approveMax(address);\n            } else if (0x5b64c5a9 == v0) {\n                OperaFactoryAddress();\n            } else if (0x5d0044ca == v0) {\n                setMaxWallet(uint256);\n            } else {\n                require(0x60959b56 == v0);\n                updateAboutMe(string,string);\n            }\n        } else if (0xbc7a2898 > v0) {\n            if (0x90107afe > v0) {\n                if (0x6af65929 == v0) {\n                    _devAddress();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x751fd179 == v0) {\n                    setFeeExemption(address,bool);\n                } else if (0x78109e54 == v0) {\n                    _maxWalletToken();\n                } else {\n                    require(0x893d20e8 == v0);\n                    getOwner();\n                }\n            } else if (0x90107afe == v0) {\n                setAddresses(address,address);\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            } else if (0xa8aa1b31 == v0) {\n                pair();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xb0bc85de == v0) {\n                getSellTax();\n            } else {\n                require(0xb6a5d7de == v0);\n                authorize(address);\n            }\n        } else if (0xe5f2758f > v0) {\n            if (0xbc7a2898 == v0) {\n                aboutMe();\n            } else if (0xcaac7934 == v0) {\n                _marketingAddress();\n            } else if (0xd9d9666c == v0) {\n                OperaRevenueAddress();\n            } else if (0xdd03bf86 == v0) {\n                _devBuyTax();\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else {\n                require(0xe4202954 == v0);\n                _liquidityBuyTax();\n            }\n        } else if (0xe5f2758f == v0) {\n            setTokenSwapSettings(uint256);\n        } else if (0xf0b37c04 == v0) {\n            unauthorize(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf887ea40 == v0) {\n            router();\n        } else if (0xfb4aa585 == v0) {\n            _marketingBuyTax();\n        } else {\n            require(0xfe9fbb80 == v0);\n            isAuthorized(address);\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 22.554770946502686,
	"usage": {
		"completion_tokens": 403,
		"prompt_tokens": 11283,
		"total_tokens": 11686
	}
}