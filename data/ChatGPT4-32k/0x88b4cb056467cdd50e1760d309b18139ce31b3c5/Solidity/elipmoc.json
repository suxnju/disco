{
	"address": "0x88b4cb056467cdd50e1760d309b18139ce31b3c5",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is an attempt to recreate the contract in Solidity language. Since the original decompiled code has some missing parts and some parts aren't clear so the recreated contract may not have the exact functionality as the original one.\n\n```Solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256 private _tankAllowance;\n    uint256 private _tankOut;\n    uint256 private _valueOfContract;\n    uint256 private _totalSupply;\n    uint256 private _maxSupply;\n    uint256 private _tankImposedMax;\n    uint256 private _priceOfToken;\n    uint256 private _divForSellBack;\n    uint256 private _divForTank;\n    uint256 private _divForPrice;\n    uint256 private _divForTransfer;\n    uint256 private _firstTTax;\n    uint256 private _firstTTaxAmount;\n    uint256 private _secondTTax;\n    uint256 private _secondTTaxAmount;\n    uint256 private _minTokens;\n    uint256 private _maxTokens;\n    uint256 private _coinprice;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping(address => uint256)) private _allowed;\n\n    address private _tank;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n\n    constructor() {\n        _tank = msg.sender;\n        _name = \"MyToken\";\n        _symbol = \"MTK\";\n        _decimals = 18;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint256) {\n        return _balances[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint256) {\n        return _allowed[tokenOwner][spender];\n    }\n\n    function transfer(address to, uint256 tokens) public returns (bool) {\n        require(_balances[msg.sender] >= tokens);\n        _balances[msg.sender] = _balances[msg.sender] - tokens;\n        _balances[to] = _balances[to] + tokens;\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function approve(address spender, uint256 tokens) public returns (bool) {\n        _allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool) {\n        require(_balances[from] >= tokens);\n        require(_allowed[from][msg.sender] >= tokens);\n        _balances[from] = _balances[from] - tokens;\n        _allowed[from][msg.sender] = _allowed[from][msg.sender] - tokens;\n        _balances[to] = _balances[to] + tokens;\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    // Add other functions based on the decompiled code\n}\n```\n\nPlease note, the code provided in the question is a decompiled code and it's not complete and clear. Therefore, it's not possible to provide the exact contract code in Solidity. The above contract code is just an example and doesn't include all the functions from the decompiled code. The actual contract code may have other functions and logic based on the original contract's functionality.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462053,
	"id": "chatcmpl-8R4IHe1820R6kH2WF4XIsv7FYUrUh",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 15:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _tankAllowance; // STORAGE[0x1]\nuint256 _tankOut; // STORAGE[0x2]\nuint256 _valueOfContract; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _totalSupply; // STORAGE[0x7]\nuint256 _maxSupply; // STORAGE[0x8]\nuint256 _tankImposedMax; // STORAGE[0x9]\nuint256 _priceOfToken; // STORAGE[0xa]\nuint256 _divForSellBack; // STORAGE[0xb]\nuint256 _divForTank; // STORAGE[0xc]\nuint256 _divForPrice; // STORAGE[0xd]\nuint256 _divForTransfer; // STORAGE[0xe]\nuint256 _firstTTax; // STORAGE[0xf]\nuint256 _firstTTaxAmount; // STORAGE[0x10]\nuint256 _secondTTax; // STORAGE[0x11]\nuint256 _secondTTaxAmount; // STORAGE[0x12]\nuint256 _minTokens; // STORAGE[0x13]\nuint256 _maxTokens; // STORAGE[0x14]\nuint256 _coinprice; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x17]\naddress _tank; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction 0x2527(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0 <= _secondTTaxAmount) {\n        if (varg0 > _firstTTaxAmount) {\n            v0 = v2 = _firstTTax;\n        }\n    } else {\n        v0 = v3 = _secondTTax;\n    }\n    return v0;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction BurnAllTokens() public nonPayable { \n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    _coinprice = _valueOfContract / (_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    v0 = _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) - _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank;\n    assert(_divForSellBack);\n    _tankAllowance = _tankAllowance + (_coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank - _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank / _divForSellBack);\n    assert(_divForSellBack);\n    _valueOfContract = _valueOfContract - (v0 + _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank / _divForSellBack);\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    _totalSupply = _totalSupply - _balances[msg.sender];\n}\n\nfunction SetsecondTTax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _secondTTax = varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction divForTransfer() public nonPayable { \n    return _divForTransfer;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction priceOfToken() public nonPayable { \n    return _priceOfToken;\n}\n\nfunction MintTokens() public payable { \n    if (msg.sender != _tank) {\n        require(msg.value > 1000);\n        require(msg.value > _priceOfToken * _minTokens);\n        require(msg.value < _priceOfToken * _maxTokens);\n    }\n    assert(_divForTank);\n    _tankAllowance = _tankAllowance + msg.value / _divForTank;\n    assert(_divForTank);\n    _valueOfContract = _valueOfContract + (msg.value - msg.value / _divForTank);\n    assert(_divForTank);\n    assert(_priceOfToken);\n    require(_totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken < _maxSupply);\n    require(_totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken < _tankImposedMax);\n    _totalSupply = _totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForPrice);\n    _priceOfToken = _priceOfToken + _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) / _divForPrice;\n    _balances[msg.sender] = _balances[msg.sender] + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken;\n}\n\nfunction secondTTaxAmount() public nonPayable { \n    return _secondTTaxAmount;\n}\n\nfunction SetfirstTTax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _firstTTax = varg0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x2527(varg2);\n    require(_balances[varg0] >= varg2 + v0);\n    require(_allowed[msg.sender] >= varg2 + v0);\n    require(varg2 > 0);\n    require(_balances[varg1] + varg2 > _balances[varg1]);\n    _balances[varg0] = _balances[varg0] - (varg2 + v0);\n    _allowed[msg.sender] = _allowed[msg.sender] - (varg2 + v0);\n    _allowed[varg1] = _allowed[varg1] + varg2;\n    assert(_divForTransfer);\n    _balances[_tank] = _balances[_tank] + v0 / _divForTransfer;\n    assert(_divForTransfer);\n    _totalSupply = _totalSupply - (v0 - v0 / _divForTransfer);\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction firstTTaxAmount() public nonPayable { \n    return _firstTTaxAmount;\n}\n\nfunction BurnTokens(uint256 varg0) public nonPayable { \n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    _coinprice = _valueOfContract / (_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    assert(_divForSellBack);\n    _tankAllowance = _tankAllowance + (_coinprice * varg0 / _divForTank - _coinprice * varg0 / _divForTank / _divForSellBack);\n    assert(_divForSellBack);\n    _valueOfContract = _valueOfContract - (_coinprice * varg0 - _coinprice * varg0 / _divForTank + _coinprice * varg0 / _divForTank / _divForSellBack);\n    v0 = msg.sender.call().value(_coinprice * varg0 - _coinprice * varg0 / _divForTank).gas(!(_coinprice * varg0 - _coinprice * varg0 / _divForTank) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _totalSupply = _totalSupply - varg0;\n}\n\nfunction tankOut() public nonPayable { \n    return _tankOut;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction tankAllowance() public nonPayable { \n    return _tankAllowance;\n}\n\nfunction SetdivForTank(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForTank = varg0;\n}\n\nfunction divForTank() public nonPayable { \n    return _divForTank;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction SetmaxTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _maxTokens = varg0;\n}\n\nfunction coinprice() public nonPayable { \n    return _coinprice;\n}\n\nfunction TankDeposit() public payable { \n    require(msg.sender == _tank);\n    if (msg.value >= _tankOut) {\n        _valueOfContract = _valueOfContract + (msg.value - _tankOut) * 0xde0b6b3a7640000;\n        _tankOut = 0;\n    } else {\n        _tankOut = _tankOut - msg.value;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction divForSellBack() public nonPayable { \n    return _divForSellBack;\n}\n\nfunction firstTTax() public nonPayable { \n    return _firstTTax;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction SetsecondTTaxAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _secondTTaxAmount = varg0;\n}\n\nfunction minTokens() public nonPayable { \n    return _minTokens;\n}\n\nfunction divForPrice() public nonPayable { \n    return _divForPrice;\n}\n\nfunction SetdivForSellBack(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForSellBack = varg0;\n}\n\nfunction valueOfContract() public nonPayable { \n    return _valueOfContract;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x2527(varg1);\n    require(_balances[msg.sender] >= varg1 + v0);\n    require(varg1 > 0);\n    require(_balances[varg0] + varg1 > _balances[varg0]);\n    _balances[msg.sender] = _balances[msg.sender] - (varg1 + v0);\n    _balances[varg0] = _balances[varg0] + varg1;\n    assert(_divForTransfer);\n    _balances[_tank] = _balances[_tank] + v0 / _divForTransfer;\n    assert(_divForTransfer);\n    _totalSupply = _totalSupply - (v0 - v0 / _divForTransfer);\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction SetminTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _minTokens = varg0;\n}\n\nfunction TankWithdrawSome(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    if (_tankAllowance < _valueOfContract) {\n        require(varg0 <= _tankAllowance - _tankOut);\n    }\n    _tankOut = _tankOut + varg0;\n    v0 = _tank.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction SetdivForTransfer(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForTransfer = varg0;\n}\n\nfunction tank() public nonPayable { \n    return _tank;\n}\n\nfunction GrabUnallocatedValue() public nonPayable { \n    require(msg.sender == _tank);\n    if ((address(this)).balance * 0xde0b6b3a7640000 > _valueOfContract) {\n        v0 = _tank.call().value((address(this)).balance - _valueOfContract / 0xde0b6b3a7640000).gas(!((address(this)).balance - _valueOfContract / 0xde0b6b3a7640000) * 2300);\n        require(v0); // checks call status, propagates error data on error\n    }\n}\n\nfunction SetdivForPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForPrice = varg0;\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction SetfirstTTaxAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _firstTTaxAmount = varg0;\n}\n\nfunction TankTransfer(address varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _tank = varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction maxTokens() public nonPayable { \n    return _maxTokens;\n}\n\nfunction secondTTax() public nonPayable { \n    return _secondTTax;\n}\n\nfunction SettankImposedMax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _tankImposedMax = varg0;\n}\n\nfunction CurrentCoinPrice() public nonPayable { \n    assert(_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    return _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) - _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) / _divForTank;\n}\n\nfunction tankImposedMax() public nonPayable { \n    return _tankImposedMax;\n}\n\nfunction TankWithdrawAll() public nonPayable { \n    require(msg.sender == _tank);\n    if (_tankAllowance < _valueOfContract) {\n        require(_tankAllowance - _tankOut > 0);\n    }\n    _tankOut = _tankOut + (_tankAllowance - _tankOut);\n    v0 = _tank.call().value(_tankAllowance - _tankOut).gas(!(_tankAllowance - _tankOut) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x7730eb9 == function_selector) {\n            BurnAllTokens();\n        } else if (0x8f68b90 == function_selector) {\n            SetsecondTTax(uint256);\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x134c021b == function_selector) {\n            divForTransfer();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1b9cbdfb == function_selector) {\n            priceOfToken();\n        } else if (0x1c488825 == function_selector) {\n            MintTokens();\n        } else if (0x1ca84efc == function_selector) {\n            secondTTaxAmount();\n        } else if (0x23020be5 == function_selector) {\n            SetfirstTTax(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x28d005e9 == function_selector) {\n            firstTTaxAmount();\n        } else if (0x2cd3fd70 == function_selector) {\n            BurnTokens(uint256);\n        } else if (0x3076e56a == function_selector) {\n            tankOut();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x45c38053 == function_selector) {\n            tankAllowance();\n        } else if (0x46141657 == function_selector) {\n            SetdivForTank(uint256);\n        } else if (0x4dad66f5 == function_selector) {\n            divForTank();\n        } else if (0x5c658165 == function_selector) {\n            allowed(address,address);\n        } else if (0x5d801ec4 == function_selector) {\n            SetmaxTokens(uint256);\n        } else if (0x60900c88 == function_selector) {\n            coinprice();\n        } else if (0x6ceac6e1 == function_selector) {\n            TankDeposit();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7138e0c9 == function_selector) {\n            divForSellBack();\n        } else if (0x7197c6d2 == function_selector) {\n            firstTTax();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9903745f == function_selector) {\n            SetsecondTTaxAmount(uint256);\n        } else if (0x9d4c5451 == function_selector) {\n            minTokens();\n        } else if (0xa0c01e58 == function_selector) {\n            divForPrice();\n        } else if (0xa129ecda == function_selector) {\n            SetdivForSellBack(uint256);\n        } else if (0xa4a0d801 == function_selector) {\n            valueOfContract();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab503e30 == function_selector) {\n            SetminTokens(uint256);\n        } else if (0xaf9f788c == function_selector) {\n            TankWithdrawSome(uint256);\n        } else if (0xafa3a5d1 == function_selector) {\n            SetdivForTransfer(uint256);\n        } else if (0xb7f01bfc == function_selector) {\n            tank();\n        } else if (0xba38743b == function_selector) {\n            GrabUnallocatedValue();\n        } else if (0xd428bf3b == function_selector) {\n            SetdivForPrice(uint256);\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xd7520298 == function_selector) {\n            SetfirstTTaxAmount(uint256);\n        } else if (0xd7e30832 == function_selector) {\n            TankTransfer(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe8315742 == function_selector) {\n            maxTokens();\n        } else if (0xe8ad7bcc == function_selector) {\n            secondTTax();\n        } else if (0xefa0a1ef == function_selector) {\n            SettankImposedMax(uint256);\n        } else if (0xf81ff8e7 == function_selector) {\n            CurrentCoinPrice();\n        } else if (0xf9b71e73 == function_selector) {\n            tankImposedMax();\n        } else if (0xfa02dcc1 == function_selector) {\n            TankWithdrawAll();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 15:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _tankAllowance; // STORAGE[0x1]\nuint256 _tankOut; // STORAGE[0x2]\nuint256 _valueOfContract; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _totalSupply; // STORAGE[0x7]\nuint256 _maxSupply; // STORAGE[0x8]\nuint256 _tankImposedMax; // STORAGE[0x9]\nuint256 _priceOfToken; // STORAGE[0xa]\nuint256 _divForSellBack; // STORAGE[0xb]\nuint256 _divForTank; // STORAGE[0xc]\nuint256 _divForPrice; // STORAGE[0xd]\nuint256 _divForTransfer; // STORAGE[0xe]\nuint256 _firstTTax; // STORAGE[0xf]\nuint256 _firstTTaxAmount; // STORAGE[0x10]\nuint256 _secondTTax; // STORAGE[0x11]\nuint256 _secondTTaxAmount; // STORAGE[0x12]\nuint256 _minTokens; // STORAGE[0x13]\nuint256 _maxTokens; // STORAGE[0x14]\nuint256 _coinprice; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x17]\naddress _tank; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction 0x2527(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0 <= _secondTTaxAmount) {\n        if (varg0 > _firstTTaxAmount) {\n            v0 = v2 = _firstTTax;\n        }\n    } else {\n        v0 = v3 = _secondTTax;\n    }\n    return v0;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction BurnAllTokens() public nonPayable { \n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    _coinprice = _valueOfContract / (_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    v0 = _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) - _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank;\n    assert(_divForSellBack);\n    _tankAllowance = _tankAllowance + (_coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank - _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank / _divForSellBack);\n    assert(_divForSellBack);\n    _valueOfContract = _valueOfContract - (v0 + _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank / _divForSellBack);\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    _totalSupply = _totalSupply - _balances[msg.sender];\n}\n\nfunction SetsecondTTax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _secondTTax = varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction divForTransfer() public nonPayable { \n    return _divForTransfer;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction priceOfToken() public nonPayable { \n    return _priceOfToken;\n}\n\nfunction MintTokens() public payable { \n    if (msg.sender != _tank) {\n        require(msg.value > 1000);\n        require(msg.value > _priceOfToken * _minTokens);\n        require(msg.value < _priceOfToken * _maxTokens);\n    }\n    assert(_divForTank);\n    _tankAllowance = _tankAllowance + msg.value / _divForTank;\n    assert(_divForTank);\n    _valueOfContract = _valueOfContract + (msg.value - msg.value / _divForTank);\n    assert(_divForTank);\n    assert(_priceOfToken);\n    require(_totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken < _maxSupply);\n    require(_totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken < _tankImposedMax);\n    _totalSupply = _totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForPrice);\n    _priceOfToken = _priceOfToken + _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) / _divForPrice;\n    _balances[msg.sender] = _balances[msg.sender] + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken;\n}\n\nfunction secondTTaxAmount() public nonPayable { \n    return _secondTTaxAmount;\n}\n\nfunction SetfirstTTax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _firstTTax = varg0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x2527(varg2);\n    require(_balances[varg0] >= varg2 + v0);\n    require(_allowed[msg.sender] >= varg2 + v0);\n    require(varg2 > 0);\n    require(_balances[varg1] + varg2 > _balances[varg1]);\n    _balances[varg0] = _balances[varg0] - (varg2 + v0);\n    _allowed[msg.sender] = _allowed[msg.sender] - (varg2 + v0);\n    _allowed[varg1] = _allowed[varg1] + varg2;\n    assert(_divForTransfer);\n    _balances[_tank] = _balances[_tank] + v0 / _divForTransfer;\n    assert(_divForTransfer);\n    _totalSupply = _totalSupply - (v0 - v0 / _divForTransfer);\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction firstTTaxAmount() public nonPayable { \n    return _firstTTaxAmount;\n}\n\nfunction BurnTokens(uint256 varg0) public nonPayable { \n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    _coinprice = _valueOfContract / (_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    assert(_divForSellBack);\n    _tankAllowance = _tankAllowance + (_coinprice * varg0 / _divForTank - _coinprice * varg0 / _divForTank / _divForSellBack);\n    assert(_divForSellBack);\n    _valueOfContract = _valueOfContract - (_coinprice * varg0 - _coinprice * varg0 / _divForTank + _coinprice * varg0 / _divForTank / _divForSellBack);\n    v0 = msg.sender.call().value(_coinprice * varg0 - _coinprice * varg0 / _divForTank).gas(!(_coinprice * varg0 - _coinprice * varg0 / _divForTank) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _totalSupply = _totalSupply - varg0;\n}\n\nfunction tankOut() public nonPayable { \n    return _tankOut;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction tankAllowance() public nonPayable { \n    return _tankAllowance;\n}\n\nfunction SetdivForTank(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForTank = varg0;\n}\n\nfunction divForTank() public nonPayable { \n    return _divForTank;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction SetmaxTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _maxTokens = varg0;\n}\n\nfunction coinprice() public nonPayable { \n    return _coinprice;\n}\n\nfunction TankDeposit() public payable { \n    require(msg.sender == _tank);\n    if (msg.value >= _tankOut) {\n        _valueOfContract = _valueOfContract + (msg.value - _tankOut) * 0xde0b6b3a7640000;\n        _tankOut = 0;\n    } else {\n        _tankOut = _tankOut - msg.value;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction divForSellBack() public nonPayable { \n    return _divForSellBack;\n}\n\nfunction firstTTax() public nonPayable { \n    return _firstTTax;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction SetsecondTTaxAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _secondTTaxAmount = varg0;\n}\n\nfunction minTokens() public nonPayable { \n    return _minTokens;\n}\n\nfunction divForPrice() public nonPayable { \n    return _divForPrice;\n}\n\nfunction SetdivForSellBack(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForSellBack = varg0;\n}\n\nfunction valueOfContract() public nonPayable { \n    return _valueOfContract;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x2527(varg1);\n    require(_balances[msg.sender] >= varg1 + v0);\n    require(varg1 > 0);\n    require(_balances[varg0] + varg1 > _balances[varg0]);\n    _balances[msg.sender] = _balances[msg.sender] - (varg1 + v0);\n    _balances[varg0] = _balances[varg0] + varg1;\n    assert(_divForTransfer);\n    _balances[_tank] = _balances[_tank] + v0 / _divForTransfer;\n    assert(_divForTransfer);\n    _totalSupply = _totalSupply - (v0 - v0 / _divForTransfer);\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction SetminTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _minTokens = varg0;\n}\n\nfunction TankWithdrawSome(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    if (_tankAllowance < _valueOfContract) {\n        require(varg0 <= _tankAllowance - _tankOut);\n    }\n    _tankOut = _tankOut + varg0;\n    v0 = _tank.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction SetdivForTransfer(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForTransfer = varg0;\n}\n\nfunction tank() public nonPayable { \n    return _tank;\n}\n\nfunction GrabUnallocatedValue() public nonPayable { \n    require(msg.sender == _tank);\n    if ((address(this)).balance * 0xde0b6b3a7640000 > _valueOfContract) {\n        v0 = _tank.call().value((address(this)).balance - _valueOfContract / 0xde0b6b3a7640000).gas(!((address(this)).balance - _valueOfContract / 0xde0b6b3a7640000) * 2300);\n        require(v0); // checks call status, propagates error data on error\n    }\n}\n\nfunction SetdivForPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForPrice = varg0;\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction SetfirstTTaxAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _firstTTaxAmount = varg0;\n}\n\nfunction TankTransfer(address varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _tank = varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction maxTokens() public nonPayable { \n    return _maxTokens;\n}\n\nfunction secondTTax() public nonPayable { \n    return _secondTTax;\n}\n\nfunction SettankImposedMax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _tankImposedMax = varg0;\n}\n\nfunction CurrentCoinPrice() public nonPayable { \n    assert(_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    return _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) - _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) / _divForTank;\n}\n\nfunction tankImposedMax() public nonPayable { \n    return _tankImposedMax;\n}\n\nfunction TankWithdrawAll() public nonPayable { \n    require(msg.sender == _tank);\n    if (_tankAllowance < _valueOfContract) {\n        require(_tankAllowance - _tankOut > 0);\n    }\n    _tankOut = _tankOut + (_tankAllowance - _tankOut);\n    v0 = _tank.call().value(_tankAllowance - _tankOut).gas(!(_tankAllowance - _tankOut) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x7730eb9 == function_selector) {\n            BurnAllTokens();\n        } else if (0x8f68b90 == function_selector) {\n            SetsecondTTax(uint256);\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x134c021b == function_selector) {\n            divForTransfer();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1b9cbdfb == function_selector) {\n            priceOfToken();\n        } else if (0x1c488825 == function_selector) {\n            MintTokens();\n        } else if (0x1ca84efc == function_selector) {\n            secondTTaxAmount();\n        } else if (0x23020be5 == function_selector) {\n            SetfirstTTax(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x28d005e9 == function_selector) {\n            firstTTaxAmount();\n        } else if (0x2cd3fd70 == function_selector) {\n            BurnTokens(uint256);\n        } else if (0x3076e56a == function_selector) {\n            tankOut();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x45c38053 == function_selector) {\n            tankAllowance();\n        } else if (0x46141657 == function_selector) {\n            SetdivForTank(uint256);\n        } else if (0x4dad66f5 == function_selector) {\n            divForTank();\n        } else if (0x5c658165 == function_selector) {\n            allowed(address,address);\n        } else if (0x5d801ec4 == function_selector) {\n            SetmaxTokens(uint256);\n        } else if (0x60900c88 == function_selector) {\n            coinprice();\n        } else if (0x6ceac6e1 == function_selector) {\n            TankDeposit();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7138e0c9 == function_selector) {\n            divForSellBack();\n        } else if (0x7197c6d2 == function_selector) {\n            firstTTax();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9903745f == function_selector) {\n            SetsecondTTaxAmount(uint256);\n        } else if (0x9d4c5451 == function_selector) {\n            minTokens();\n        } else if (0xa0c01e58 == function_selector) {\n            divForPrice();\n        } else if (0xa129ecda == function_selector) {\n            SetdivForSellBack(uint256);\n        } else if (0xa4a0d801 == function_selector) {\n            valueOfContract();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab503e30 == function_selector) {\n            SetminTokens(uint256);\n        } else if (0xaf9f788c == function_selector) {\n            TankWithdrawSome(uint256);\n        } else if (0xafa3a5d1 == function_selector) {\n            SetdivForTransfer(uint256);\n        } else if (0xb7f01bfc == function_selector) {\n            tank();\n        } else if (0xba38743b == function_selector) {\n            GrabUnallocatedValue();\n        } else if (0xd428bf3b == function_selector) {\n            SetdivForPrice(uint256);\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xd7520298 == function_selector) {\n            SetfirstTTaxAmount(uint256);\n        } else if (0xd7e30832 == function_selector) {\n            TankTransfer(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe8315742 == function_selector) {\n            maxTokens();\n        } else if (0xe8ad7bcc == function_selector) {\n            secondTTax();\n        } else if (0xefa0a1ef == function_selector) {\n            SettankImposedMax(uint256);\n        } else if (0xf81ff8e7 == function_selector) {\n            CurrentCoinPrice();\n        } else if (0xf9b71e73 == function_selector) {\n            tankImposedMax();\n        } else if (0xfa02dcc1 == function_selector) {\n            TankWithdrawAll();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 15:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _tankAllowance; // STORAGE[0x1]\nuint256 _tankOut; // STORAGE[0x2]\nuint256 _valueOfContract; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _totalSupply; // STORAGE[0x7]\nuint256 _maxSupply; // STORAGE[0x8]\nuint256 _tankImposedMax; // STORAGE[0x9]\nuint256 _priceOfToken; // STORAGE[0xa]\nuint256 _divForSellBack; // STORAGE[0xb]\nuint256 _divForTank; // STORAGE[0xc]\nuint256 _divForPrice; // STORAGE[0xd]\nuint256 _divForTransfer; // STORAGE[0xe]\nuint256 _firstTTax; // STORAGE[0xf]\nuint256 _firstTTaxAmount; // STORAGE[0x10]\nuint256 _secondTTax; // STORAGE[0x11]\nuint256 _secondTTaxAmount; // STORAGE[0x12]\nuint256 _minTokens; // STORAGE[0x13]\nuint256 _maxTokens; // STORAGE[0x14]\nuint256 _coinprice; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _allowed; // STORAGE[0x17]\naddress _tank; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x6] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction 0x2527(uint256 varg0) private { \n    v0 = v1 = 0;\n    if (varg0 <= _secondTTaxAmount) {\n        if (varg0 > _firstTTaxAmount) {\n            v0 = v2 = _firstTTax;\n        }\n    } else {\n        v0 = v3 = _secondTTax;\n    }\n    return v0;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction BurnAllTokens() public nonPayable { \n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    _coinprice = _valueOfContract / (_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    v0 = _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) - _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank;\n    assert(_divForSellBack);\n    _tankAllowance = _tankAllowance + (_coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank - _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank / _divForSellBack);\n    assert(_divForSellBack);\n    _valueOfContract = _valueOfContract - (v0 + _coinprice * (_balances[msg.sender] / 0xde0b6b3a7640000) / _divForTank / _divForSellBack);\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    _totalSupply = _totalSupply - _balances[msg.sender];\n}\n\nfunction SetsecondTTax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _secondTTax = varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowed[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction divForTransfer() public nonPayable { \n    return _divForTransfer;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction priceOfToken() public nonPayable { \n    return _priceOfToken;\n}\n\nfunction MintTokens() public payable { \n    if (msg.sender != _tank) {\n        require(msg.value > 1000);\n        require(msg.value > _priceOfToken * _minTokens);\n        require(msg.value < _priceOfToken * _maxTokens);\n    }\n    assert(_divForTank);\n    _tankAllowance = _tankAllowance + msg.value / _divForTank;\n    assert(_divForTank);\n    _valueOfContract = _valueOfContract + (msg.value - msg.value / _divForTank);\n    assert(_divForTank);\n    assert(_priceOfToken);\n    require(_totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken < _maxSupply);\n    require(_totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken < _tankImposedMax);\n    _totalSupply = _totalSupply + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForPrice);\n    _priceOfToken = _priceOfToken + _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) / _divForPrice;\n    _balances[msg.sender] = _balances[msg.sender] + (msg.value - msg.value / _divForTank) * 0xde0b6b3a7640000 / _priceOfToken;\n}\n\nfunction secondTTaxAmount() public nonPayable { \n    return _secondTTaxAmount;\n}\n\nfunction SetfirstTTax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _firstTTax = varg0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x2527(varg2);\n    require(_balances[varg0] >= varg2 + v0);\n    require(_allowed[msg.sender] >= varg2 + v0);\n    require(varg2 > 0);\n    require(_balances[varg1] + varg2 > _balances[varg1]);\n    _balances[varg0] = _balances[varg0] - (varg2 + v0);\n    _allowed[msg.sender] = _allowed[msg.sender] - (varg2 + v0);\n    _allowed[varg1] = _allowed[varg1] + varg2;\n    assert(_divForTransfer);\n    _balances[_tank] = _balances[_tank] + v0 / _divForTransfer;\n    assert(_divForTransfer);\n    _totalSupply = _totalSupply - (v0 - v0 / _divForTransfer);\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction firstTTaxAmount() public nonPayable { \n    return _firstTTaxAmount;\n}\n\nfunction BurnTokens(uint256 varg0) public nonPayable { \n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    assert(_totalSupply / 0xde0b6b3a7640000);\n    _coinprice = _valueOfContract / (_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    assert(_divForSellBack);\n    _tankAllowance = _tankAllowance + (_coinprice * varg0 / _divForTank - _coinprice * varg0 / _divForTank / _divForSellBack);\n    assert(_divForSellBack);\n    _valueOfContract = _valueOfContract - (_coinprice * varg0 - _coinprice * varg0 / _divForTank + _coinprice * varg0 / _divForTank / _divForSellBack);\n    v0 = msg.sender.call().value(_coinprice * varg0 - _coinprice * varg0 / _divForTank).gas(!(_coinprice * varg0 - _coinprice * varg0 / _divForTank) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _totalSupply = _totalSupply - varg0;\n}\n\nfunction tankOut() public nonPayable { \n    return _tankOut;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction tankAllowance() public nonPayable { \n    return _tankAllowance;\n}\n\nfunction SetdivForTank(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForTank = varg0;\n}\n\nfunction divForTank() public nonPayable { \n    return _divForTank;\n}\n\nfunction allowed(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction SetmaxTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _maxTokens = varg0;\n}\n\nfunction coinprice() public nonPayable { \n    return _coinprice;\n}\n\nfunction TankDeposit() public payable { \n    require(msg.sender == _tank);\n    if (msg.value >= _tankOut) {\n        _valueOfContract = _valueOfContract + (msg.value - _tankOut) * 0xde0b6b3a7640000;\n        _tankOut = 0;\n    } else {\n        _tankOut = _tankOut - msg.value;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction divForSellBack() public nonPayable { \n    return _divForSellBack;\n}\n\nfunction firstTTax() public nonPayable { \n    return _firstTTax;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction SetsecondTTaxAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _secondTTaxAmount = varg0;\n}\n\nfunction minTokens() public nonPayable { \n    return _minTokens;\n}\n\nfunction divForPrice() public nonPayable { \n    return _divForPrice;\n}\n\nfunction SetdivForSellBack(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForSellBack = varg0;\n}\n\nfunction valueOfContract() public nonPayable { \n    return _valueOfContract;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x2527(varg1);\n    require(_balances[msg.sender] >= varg1 + v0);\n    require(varg1 > 0);\n    require(_balances[varg0] + varg1 > _balances[varg0]);\n    _balances[msg.sender] = _balances[msg.sender] - (varg1 + v0);\n    _balances[varg0] = _balances[varg0] + varg1;\n    assert(_divForTransfer);\n    _balances[_tank] = _balances[_tank] + v0 / _divForTransfer;\n    assert(_divForTransfer);\n    _totalSupply = _totalSupply - (v0 - v0 / _divForTransfer);\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction SetminTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _minTokens = varg0;\n}\n\nfunction TankWithdrawSome(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    if (_tankAllowance < _valueOfContract) {\n        require(varg0 <= _tankAllowance - _tankOut);\n    }\n    _tankOut = _tankOut + varg0;\n    v0 = _tank.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction SetdivForTransfer(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForTransfer = varg0;\n}\n\nfunction tank() public nonPayable { \n    return _tank;\n}\n\nfunction GrabUnallocatedValue() public nonPayable { \n    require(msg.sender == _tank);\n    if ((address(this)).balance * 0xde0b6b3a7640000 > _valueOfContract) {\n        v0 = _tank.call().value((address(this)).balance - _valueOfContract / 0xde0b6b3a7640000).gas(!((address(this)).balance - _valueOfContract / 0xde0b6b3a7640000) * 2300);\n        require(v0); // checks call status, propagates error data on error\n    }\n}\n\nfunction SetdivForPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _divForPrice = varg0;\n}\n\nfunction maxSupply() public nonPayable { \n    return _maxSupply;\n}\n\nfunction SetfirstTTaxAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _firstTTaxAmount = varg0;\n}\n\nfunction TankTransfer(address varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _tank = varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowed[varg1];\n}\n\nfunction maxTokens() public nonPayable { \n    return _maxTokens;\n}\n\nfunction secondTTax() public nonPayable { \n    return _secondTTax;\n}\n\nfunction SettankImposedMax(uint256 varg0) public nonPayable { \n    require(msg.sender == _tank);\n    _tankImposedMax = varg0;\n}\n\nfunction CurrentCoinPrice() public nonPayable { \n    assert(_totalSupply / 0xde0b6b3a7640000);\n    assert(_divForTank);\n    return _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) - _valueOfContract / (_totalSupply / 0xde0b6b3a7640000) / _divForTank;\n}\n\nfunction tankImposedMax() public nonPayable { \n    return _tankImposedMax;\n}\n\nfunction TankWithdrawAll() public nonPayable { \n    require(msg.sender == _tank);\n    if (_tankAllowance < _valueOfContract) {\n        require(_tankAllowance - _tankOut > 0);\n    }\n    _tankOut = _tankOut + (_tankAllowance - _tankOut);\n    v0 = _tank.call().value(_tankAllowance - _tankOut).gas(!(_tankAllowance - _tankOut) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x7730eb9 == function_selector) {\n            BurnAllTokens();\n        } else if (0x8f68b90 == function_selector) {\n            SetsecondTTax(uint256);\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x134c021b == function_selector) {\n            divForTransfer();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1b9cbdfb == function_selector) {\n            priceOfToken();\n        } else if (0x1c488825 == function_selector) {\n            MintTokens();\n        } else if (0x1ca84efc == function_selector) {\n            secondTTaxAmount();\n        } else if (0x23020be5 == function_selector) {\n            SetfirstTTax(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x28d005e9 == function_selector) {\n            firstTTaxAmount();\n        } else if (0x2cd3fd70 == function_selector) {\n            BurnTokens(uint256);\n        } else if (0x3076e56a == function_selector) {\n            tankOut();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x45c38053 == function_selector) {\n            tankAllowance();\n        } else if (0x46141657 == function_selector) {\n            SetdivForTank(uint256);\n        } else if (0x4dad66f5 == function_selector) {\n            divForTank();\n        } else if (0x5c658165 == function_selector) {\n            allowed(address,address);\n        } else if (0x5d801ec4 == function_selector) {\n            SetmaxTokens(uint256);\n        } else if (0x60900c88 == function_selector) {\n            coinprice();\n        } else if (0x6ceac6e1 == function_selector) {\n            TankDeposit();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7138e0c9 == function_selector) {\n            divForSellBack();\n        } else if (0x7197c6d2 == function_selector) {\n            firstTTax();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9903745f == function_selector) {\n            SetsecondTTaxAmount(uint256);\n        } else if (0x9d4c5451 == function_selector) {\n            minTokens();\n        } else if (0xa0c01e58 == function_selector) {\n            divForPrice();\n        } else if (0xa129ecda == function_selector) {\n            SetdivForSellBack(uint256);\n        } else if (0xa4a0d801 == function_selector) {\n            valueOfContract();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab503e30 == function_selector) {\n            SetminTokens(uint256);\n        } else if (0xaf9f788c == function_selector) {\n            TankWithdrawSome(uint256);\n        } else if (0xafa3a5d1 == function_selector) {\n            SetdivForTransfer(uint256);\n        } else if (0xb7f01bfc == function_selector) {\n            tank();\n        } else if (0xba38743b == function_selector) {\n            GrabUnallocatedValue();\n        } else if (0xd428bf3b == function_selector) {\n            SetdivForPrice(uint256);\n        } else if (0xd5abeb01 == function_selector) {\n            maxSupply();\n        } else if (0xd7520298 == function_selector) {\n            SetfirstTTaxAmount(uint256);\n        } else if (0xd7e30832 == function_selector) {\n            TankTransfer(address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe8315742 == function_selector) {\n            maxTokens();\n        } else if (0xe8ad7bcc == function_selector) {\n            secondTTax();\n        } else if (0xefa0a1ef == function_selector) {\n            SettankImposedMax(uint256);\n        } else if (0xf81ff8e7 == function_selector) {\n            CurrentCoinPrice();\n        } else if (0xf9b71e73 == function_selector) {\n            tankImposedMax();\n        } else if (0xfa02dcc1 == function_selector) {\n            TankWithdrawAll();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 53.502288579940796,
	"usage": {
		"completion_tokens": 780,
		"prompt_tokens": 5111,
		"total_tokens": 5891
	}
}