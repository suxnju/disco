{
	"address": "0x9fa8fa61a10ff892e4ebceb7f4e0fc684c2ce0a9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code for the provided decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Contract {\n    uint256 public _isInTestMode;\n    uint256 public _closingTime;\n    uint256 public _weiPerInitialHONG;\n    uint256[] public _name;\n    uint256[] public _symbol;\n    uint256 public _maxBountyTokens;\n    uint256 public _closingTimeExtensionPeriod;\n    uint256 public _minTokensToCreate;\n    uint256 public _maxTokensToCreate;\n    uint256 public _tokensPerTier;\n    uint256 public _lastKickoffDateBuffer;\n    uint256 public _mgmtRewardPercentage;\n    uint256 public _mgmtFeePercentage;\n    uint256 public _harvestQuorumPercent;\n    uint256 public _freezeQuorumPercent;\n    uint256 public _kickoffQuorumPercent;\n    mapping (uint256 => uint256[]) public _votedKickoff;\n    mapping (uint256 => uint256[]) public _votedFreeze;\n    mapping (uint256 => uint256[]) public _votedHarvest;\n    mapping (uint256 => uint256[]) public _supportKickoffQuorum;\n    uint256 public _supportFreezeQuorum;\n    uint256 public _supportHarvestQuorum;\n    uint256 public _totalInitialBalance;\n    uint256 public _annualManagementFee;\n    mapping (uint256 => uint256[]) public owner_1c;\n    mapping (uint256 => uint256[]) public _taxPaid;\n    mapping (uint256 => uint256[]) public _balanceOf;\n    uint256 public _tokensCreated;\n    uint256 public _isFundLocked;\n    uint256 public _bountyTokensCreated;\n    uint256 public _currentFiscalYear;\n    uint256 public _lastKickoffDate;\n    mapping (uint256 => uint256[]) public _isKickoffEnabled;\n    uint256 public _isFreezeEnabled;\n    uint256 public _decimals;\n    uint256 public _managementBodyAddress;\n    uint256 public _extraBalanceWallet;\n    uint256 public _rewardWallet;\n    uint256 public _managementFeeWallet;\n    uint256 public stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0;\n\n    event evRecord(address indexed, uint256 indexed, string);\n    event evCreatedToken(address indexed, uint256 indexed, address, uint256);\n    event evMinTokensReached(address indexed, uint256 indexed, uint256);\n    event evLockFund(address indexed, uint256 indexed);\n    event evReleaseFund(address indexed, uint256 indexed);\n    event evHarvest(address indexed, uint256 indexed);\n    event evMgmtInvestProject(address indexed, uint256 indexed, address, uint256, bool);\n    event evKickoff(address indexed, uint256 indexed, uint256);\n    event evIssueManagementFee(address indexed, uint256 indexed, uint256, bool);\n    event evFreeze(address indexed, uint256 indexed);\n    event evRefund(address indexed, uint256 indexed, address, uint256, bool);\n    event evMgmtIssueBountyToken(address indexed, uint256 indexed, address, uint256, bool);\n    event evMgmtDistributed(address indexed, uint256 indexed, uint256, bool);\n    event evTransfer(address indexed, uint256 indexed, address, address, uint256);\n\n    // The function declarations are omitted for brevity.\n}\n```\n\nPlease note that due to the inherent complexity and ambiguity involved in decompiling bytecode, the provided Solidity code is a best-effort recreation of the original code and may not be entirely accurate or complete.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038711,
	"id": "chatcmpl-8Chj5FIHggeUGIqzKFBYQd6VnHPzC",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.06 04:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _isInTestMode; // STORAGE[0x0] bytes 0 to 0\nuint256 _closingTime; // STORAGE[0x1]\nuint256 _weiPerInitialHONG; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _maxBountyTokens; // STORAGE[0x6]\nuint256 _closingTimeExtensionPeriod; // STORAGE[0x7]\nuint256 _minTokensToCreate; // STORAGE[0x8]\nuint256 _maxTokensToCreate; // STORAGE[0x9]\nuint256 _tokensPerTier; // STORAGE[0xa]\nuint256 _lastKickoffDateBuffer; // STORAGE[0xb]\nuint256 _mgmtRewardPercentage; // STORAGE[0xc]\nuint256 _mgmtFeePercentage; // STORAGE[0xd]\nuint256 _harvestQuorumPercent; // STORAGE[0xe]\nuint256 _freezeQuorumPercent; // STORAGE[0xf]\nuint256 _kickoffQuorumPercent; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _votedKickoff; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _votedFreeze; // STORAGE[0x13]\nmapping (uint256 => [uint256]) _votedHarvest; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _supportKickoffQuorum; // STORAGE[0x15]\nuint256 _supportFreezeQuorum; // STORAGE[0x16]\nuint256 _supportHarvestQuorum; // STORAGE[0x17]\nuint256 _totalInitialBalance; // STORAGE[0x18]\nuint256 _annualManagementFee; // STORAGE[0x19]\nmapping (uint256 => [uint256]) owner_1c; // STORAGE[0x1c]\nmapping (uint256 => [uint256]) _taxPaid; // STORAGE[0x1d]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1e]\nuint256 _tokensCreated; // STORAGE[0x20]\nuint256 _isFundLocked; // STORAGE[0x21]\nuint256 _bountyTokensCreated; // STORAGE[0x22]\nuint256 _currentFiscalYear; // STORAGE[0x23]\nuint256 _lastKickoffDate; // STORAGE[0x24]\nmapping (uint256 => [uint256]) _isKickoffEnabled; // STORAGE[0x25]\nuint256 _isFreezeEnabled; // STORAGE[0x26]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint256 _managementBodyAddress; // STORAGE[0x1a] bytes 0 to 19\nuint256 _extraBalanceWallet; // STORAGE[0x1b] bytes 0 to 19\nuint256 _rewardWallet; // STORAGE[0x27] bytes 0 to 19\nuint256 _managementFeeWallet; // STORAGE[0x28] bytes 0 to 19\nuint256 stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0; // STORAGE[0x20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26] bytes 0 to 0\n\n// Events\nevRecord(address, uint256, string);\nevCreatedToken(address, uint256, address, uint256);\nevMinTokensReached(address, uint256, uint256);\nevLockFund(address, uint256);\nevReleaseFund(address, uint256);\nevHarvest(address, uint256);\nevMgmtInvestProject(address, uint256, address, uint256, bool);\nevKickoff(address, uint256, uint256);\nevIssueManagementFee(address, uint256, uint256, bool);\nevFreeze(address, uint256);\nevRefund(address, uint256, address, uint256, bool);\nevMgmtIssueBountyToken(address, uint256, address, uint256, bool);\nevMgmtDistributed(address, uint256, uint256, bool);\nevTransfer(address, uint256, address, address, uint256);\n\nfunction isFundReleased() public payable { \n    return 0xff & _isFundLocked >> 8;\n}\n\nfunction mgmtDistribute() public payable { \n    if (msg.sender == _managementBodyAddress) {\n        if (msg.value > 0) {\n            if (0xff & _isFreezeEnabled >> 8) {\n                if (!(0xff & _isFreezeEnabled >> 24)) {\n                    if (!(0xff & _isFreezeEnabled >> 16)) {\n                        _isFreezeEnabled = 0x1000000 | (0x10000 | _isFreezeEnabled & ~0xff0000) & ~0xff000000;\n                        v0 = address(_isFreezeEnabled >> 32).call().value((address(this)).balance);\n                        if (!v0) {\n                            v1 = new array[](v2.length);\n                            v3 = v2.data;\n                            v4 = v5 = v2.length + v1.data;\n                            if (3) {\n                                MEM[v5 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v6;\n                            }\n                            emit evRecord(msg.sender, msg.value, v1);\n                            assert(_isInTestMode);\n                        }\n                        v7 = _managementFeeWallet.call(0xfc44fd28).gas(msg.gas - 25050);\n                        assert(v7);\n                        v8 = _rewardWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                        assert(v8);\n                        v9 = _extraBalanceWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                        assert(v9);\n                        if (_mgmtRewardPercentage > 0) {\n                            v10 = address(_isFreezeEnabled >> 32).call(0xb8b27765, _mgmtRewardPercentage).gas(msg.gas - 25050);\n                            assert(v10);\n                        }\n                        v11 = address(_isFreezeEnabled >> 32).call(0x2033d9ae00000000000000000000000000000000000000000000000000000000, _bountyTokensCreated + _tokensCreated).gas(msg.gas - 25050);\n                        assert(v11);\n                        emit evMgmtDistributed(msg.sender, msg.value, (address(_isFreezeEnabled >> 32)).balance, 1);\n                        _isFreezeEnabled = 0x0 | ~0xff0000 & _isFreezeEnabled;\n                    } else {\n                        v12 = new array[](v13.length);\n                        v14 = v13.data;\n                        v15, v16 = dataCopy('onlyDistributionNotInProgress');\n                        if (29) {\n                            MEM[v12.data] = ~0xffffff & v16;\n                        }\n                        emit evRecord(msg.sender, msg.value, v12);\n                        assert(_isInTestMode);\n                    }\n                } else {\n                    v17 = new array[](v18.length);\n                    v19 = v18.data;\n                    v20, v21 = dataCopy('onlyDistributionNotReady');\n                    if (24) {\n                        MEM[v17.data] = ~0xffffffffffffffff & v21;\n                    }\n                    emit evRecord(msg.sender, msg.value, v17);\n                    assert(_isInTestMode);\n                }\n            } else {\n                v22 = new array[](v23.length);\n                v24 = v23.data;\n                v25, v26 = dataCopy('onlyHarvestEnabled');\n                if (18) {\n                    MEM[v22.data] = ~0xffffffffffffffffffffffffffff & v26;\n                }\n                emit evRecord(msg.sender, msg.value, v22);\n                assert(_isInTestMode);\n            }\n        } else {\n            v27 = new array[](v28.length);\n            v29 = v28.data;\n            v30, v31 = dataCopy();\n            if (8) {\n                MEM[v27.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v31;\n            }\n            emit evRecord(msg.sender, msg.value, v27);\n            assert(_isInTestMode);\n        }\n    } else {\n        v32 = new array[](v33.length);\n        v34 = v33.data;\n        v35, v36 = dataCopy('onlyManagementBody');\n        if (18) {\n            MEM[v32.data] = ~0xffffffffffffffffffffffffffff & v36;\n        }\n        emit evRecord(msg.sender, msg.value, v32);\n        assert(_isInTestMode);\n    }\n}\n\nfunction name() public payable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v0.length;\n    v4 = v0.data;\n    v5 = dataCopy(_name.length >> 8 << 8);\n    v6 = v0.length + (64 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n        v6 = v7 = 32 + (v6 - (0x1f & v0.length));\n    }\n    return MEM[(MEM[64]) len (v6 - MEM[64])];\n}\n\nfunction weiPerInitialHONG() public payable { \n    return _weiPerInitialHONG;\n}\n\nfunction votedHarvest(address varg0) public payable { \n    return _votedHarvest[varg0];\n}\n\nfunction minTokensToCreate() public payable { \n    return _minTokensToCreate;\n}\n\nfunction supportHarvestQuorum() public payable { \n    return _supportHarvestQuorum;\n}\n\nfunction extraBalanceWallet() public payable { \n    return _extraBalanceWallet;\n}\n\nfunction totalInitialBalance() public payable { \n    return _totalInitialBalance;\n}\n\nfunction divisor() public payable { \n    v0 = 0x591();\n    return 0xff & 100 + 5 * v0;\n}\n\nfunction voteToHarvestFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                if (_currentFiscalYear >= 4) {\n                    _supportHarvestQuorum = _supportHarvestQuorum - _votedHarvest[msg.sender];\n                    _supportHarvestQuorum = _balanceOf[msg.sender] + (_supportHarvestQuorum - _votedHarvest[msg.sender]);\n                    MEM[32] = 20;\n                    _votedHarvest[msg.sender] = _balanceOf[msg.sender];\n                    if (_supportHarvestQuorum > (_bountyTokensCreated + _tokensCreated) * _harvestQuorumPercent / 100) {\n                        _isFreezeEnabled = 0x100 | ~0xff00 & _isFreezeEnabled;\n                        emit evHarvest(msg.sender, msg.value);\n                    }\n                } else {\n                    v0 = new array[](v1.length);\n                    v2 = v1.data;\n                    v3, v4 = dataCopy('currentFiscalYear<4');\n                    if (19) {\n                        MEM[v0.data] = ~0xffffffffffffffffffffffffff & v4;\n                    }\n                    emit evRecord(msg.sender, msg.value, v0);\n                    assert(_isInTestMode);\n                    goto 0x118f0x459;\n                }\n            } else {\n                v5 = new array[](v6.length);\n                v7 = v6.data;\n                v8, v9 = dataCopy();\n                if (10) {\n                    MEM[v5.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v9;\n                }\n                emit evRecord(msg.sender, msg.value, v5);\n                assert(_isInTestMode);\n                goto 0x118f0x459;\n            }\n        } else {\n            v10 = new array[](v11.length);\n            v12 = v11.data;\n            v13, v14 = dataCopy();\n            if (7) {\n                MEM[v10.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v14;\n            }\n            emit evRecord(msg.sender, msg.value, v10);\n            assert(_isInTestMode);\n            goto 0x118f0x459;\n        }\n    } else {\n        v15 = new array[](v16.length);\n        v17 = v16.data;\n        v18, v19 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v15.data] = ~0xffffffffffffffffffffffffffffffff & v19;\n        }\n        emit evRecord(msg.sender, msg.value, v15);\n        assert(_isInTestMode);\n    }\n}\n\nfunction decimals() public payable { \n    return _decimals;\n}\n\nfunction pricePerTokenAtCurrentTier() public payable { \n    v0 = 0x591();\n    return _weiPerInitialHONG * (0xff & 100 + 5 * v0) / 100;\n}\n\nfunction mgmtFeePercentage() public payable { \n    return _mgmtFeePercentage;\n}\n\nfunction tokensCreated() public payable { \n    return _tokensCreated;\n}\n\nfunction isDistributionReady() public payable { \n    return 0xff & _isFreezeEnabled >> 24;\n}\n\nfunction closingTimeExtensionPeriod() public payable { \n    return _closingTimeExtensionPeriod;\n}\n\nfunction votedKickoff(uint256 varg0, address varg1) public payable { \n    return _votedKickoff[varg1];\n}\n\nfunction closingTime() public payable { \n    return _closingTime;\n}\n\nfunction lastKickoffDateBuffer() public payable { \n    return _lastKickoffDateBuffer;\n}\n\nfunction isDayThirtyChecked() public payable { \n    return 0xff & _isFundLocked >> 16;\n}\n\nfunction isFreezeEnabled() public payable { \n    return 0xff & _isFreezeEnabled;\n}\n\nfunction collectMyReturn() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFreezeEnabled >> 24) {\n                _balanceOf[msg.sender] = 0;\n                v0 = address(_isFreezeEnabled >> 32).call(0x9f3ef43000000000000000000000000000000000000000000000000000000000, msg.sender, _balanceOf[msg.sender]).gas(msg.gas - 25050);\n                assert(v0);\n            } else {\n                v1 = new array[](v2.length);\n                v3 = v2.data;\n                v4, v5 = dataCopy('onlyDistributionReady');\n                if (21) {\n                    MEM[v1.data] = ~0xffffffffffffffffffffff & v5;\n                }\n                emit evRecord(msg.sender, msg.value, v1);\n                assert(_isInTestMode);\n                goto 0x118f0x505;\n            }\n        } else {\n            v6 = new array[](v7.length);\n            v8 = v7.data;\n            v9, v10 = dataCopy();\n            if (7) {\n                MEM[v6.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v10;\n            }\n            emit evRecord(msg.sender, msg.value, v6);\n            assert(_isInTestMode);\n            goto 0x118f0x505;\n        }\n    } else {\n        v11 = new array[](v12.length);\n        v13 = v12.data;\n        v14, v15 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v11.data] = ~0xffffffffffffffffffffffffffffffff & v15;\n        }\n        emit evRecord(msg.sender, msg.value, v11);\n        assert(_isInTestMode);\n    }\n    goto 0x2ac4;\n}\n\nfunction isMinTokensReached() public payable { \n    return _tokensCreated >= _minTokensToCreate;\n}\n\nfunction isDistributionInProgress() public payable { \n    return 0xff & _isFreezeEnabled >> 16;\n}\n\nfunction lastKickoffDate() public payable { \n    return _lastKickoffDate;\n}\n\nfunction managementFeeWallet() public payable { \n    return _managementFeeWallet;\n}\n\nfunction supportFreezeQuorum() public payable { \n    return _supportFreezeQuorum;\n}\n\nfunction balanceOf(address varg0) public payable { \n    return _balanceOf[varg0];\n}\n\nfunction tokensAvailableAtCurrentTier() public payable { \n    v0 = 0x591();\n    v1 = 0x81f(_tokensCreated, _tokensPerTier, v0);\n    return v1;\n}\n\nfunction 0x580() private { \n    v0 = 0x591();\n    v1 = 0x81f(_tokensCreated, _tokensPerTier, v0);\n    return v1;\n}\n\nfunction getCurrentTier() public payable { \n    v0 = _tokensCreated / _tokensPerTier;\n    if (v0 & 0xff > 4) {\n        v0 = v1 = 4;\n    }\n    return 0xff & v0;\n}\n\nfunction 0x591() private { \n    v0 = v1 = _tokensCreated / _tokensPerTier;\n    if (v1 & 0xff > 4) {\n        v0 = v2 = 4;\n    }\n    return v0;\n}\n\nfunction isFundLocked() public payable { \n    return 0xff & _isFundLocked;\n}\n\nfunction votedFreeze(address varg0) public payable { \n    return _votedFreeze[varg0];\n}\n\nfunction returnWallet() public payable { \n    return address(_isFreezeEnabled >> 32);\n}\n\nfunction kickoffQuorumPercent() public payable { \n    return _kickoffQuorumPercent;\n}\n\nfunction isMaxTokensReached() public payable { \n    return _tokensCreated >= _maxTokensToCreate;\n}\n\nfunction freezeQuorumPercent() public payable { \n    return _freezeQuorumPercent;\n}\n\nfunction symbol() public payable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v0.length;\n    v4 = v0.data;\n    v5 = dataCopy(_symbol.length >> 8 << 8);\n    v6 = v0.length + (64 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n        v6 = v7 = 32 + (v6 - (0x1f & v0.length));\n    }\n    return MEM[(MEM[64]) len (v6 - MEM[64])];\n}\n\nfunction maxTokensToCreate() public payable { \n    return _maxTokensToCreate;\n}\n\nfunction mgmtInvestProject(address varg0, uint256 varg1) public payable { \n    if (msg.sender == _managementBodyAddress) {\n        if (msg.value > 0) {\n            v0 = v1 = !(0xff & _isKickoffEnabled[_currentFiscalYear]);\n            if (0xff & _isKickoffEnabled[_currentFiscalYear]) {\n                v0 = v2 = 0xff & _isFreezeEnabled;\n            }\n            if (!v0) {\n                v0 = v3 = 0xff & _isFreezeEnabled >> 8;\n            }\n            if (!v0) {\n                if (varg1 < (address(this)).balance) {\n                    v4 = varg0.call().value(varg1).gas(msg.gas - 34050);\n                    if (v4) {\n                        emit evMgmtInvestProject(msg.sender, msg.value, varg0, varg1, 1);\n                    } else {\n                        v5 = new array[](v6.length);\n                        v7 = v6.data;\n                        v8 = v9 = v6.length + v5.data;\n                        if (23) {\n                            MEM[v9 - 23] = ~0xffffffffffffffffff & v10;\n                        }\n                        emit evRecord(msg.sender, msg.value, v5);\n                        assert(_isInTestMode);\n                        goto 0x14680x676;\n                    }\n                } else {\n                    v11 = new array[](v12.length);\n                    v13 = v12.data;\n                    v14 = v15 = v12.length + v11.data;\n                    if (17) {\n                        MEM[v15 - 17] = ~0xffffffffffffffffffffffffffffff & v16;\n                    }\n                    emit evRecord(msg.sender, msg.value, v11);\n                    assert(_isInTestMode);\n                    goto 0x14680x676;\n                }\n            } else {\n                emit evMgmtInvestProject(msg.sender, msg.value, varg0, varg1, 0);\n            }\n        } else {\n            v17 = new array[](v18.length);\n            v19 = v18.data;\n            v20, v21 = dataCopy();\n            if (8) {\n                MEM[v17.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v21;\n            }\n            emit evRecord(msg.sender, msg.value, v17);\n            assert(_isInTestMode);\n            goto 0x14680x676;\n        }\n    } else {\n        v22 = new array[](v23.length);\n        v24 = v23.data;\n        v25, v26 = dataCopy('onlyManagementBody');\n        if (18) {\n            MEM[v22.data] = ~0xffffffffffffffffffffffffffff & v26;\n        }\n        emit evRecord(msg.sender, msg.value, v22);\n        assert(_isInTestMode);\n    }\n    return 0;\n}\n\nfunction isHarvestEnabled() public payable { \n    return 0xff & _isFreezeEnabled >> 8;\n}\n\nfunction tokensPerTier() public payable { \n    return _tokensPerTier;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    v0 = v1 = 11433;\n    v2 = v3 = 0;\n    if (_currentFiscalYear < 4) {\n        if (_votedKickoff[msg.sender] <= varg1) {\n            _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender];\n            _supportKickoffQuorum[1 + _currentFiscalYear] = 0;\n        } else {\n            STORAGE[keccak256(msg.sender, keccak256(1 + _currentFiscalYear, 18))] = STORAGE[keccak256(msg.sender, keccak256(1 + _currentFiscalYear, 18))] - varg1;\n            _supportKickoffQuorum[1 + _currentFiscalYear] = _supportKickoffQuorum[1 + _currentFiscalYear] - varg1;\n        }\n    }\n    if (_votedFreeze[msg.sender] <= varg1) {\n        _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n        _votedFreeze[msg.sender] = 0;\n    } else {\n        STORAGE[keccak256(msg.sender, 19)] = STORAGE[keccak256(msg.sender, 19)] - varg1;\n        _supportFreezeQuorum = _supportFreezeQuorum - varg1;\n    }\n    if (_votedHarvest[msg.sender] <= varg1) {\n        _supportHarvestQuorum = _supportHarvestQuorum - _votedHarvest[msg.sender];\n        _votedHarvest[msg.sender] = 0;\n    } else {\n        STORAGE[keccak256(msg.sender, 20)] = STORAGE[keccak256(msg.sender, 20)] - varg1;\n        _supportHarvestQuorum = _supportHarvestQuorum - varg1;\n    }\n    v2 = v4 = 0xff & _isFundLocked;\n    if (v4) {\n        v0 = v5 = 6089;\n        v2 = v6 = 0;\n        if (msg.value <= 0) {\n            if (varg1 > 0) {\n                if (_balanceOf[msg.sender] >= varg1) {\n                    if (varg1 + _balanceOf[varg0] >= _balanceOf[varg0]) {\n                        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n                        _balanceOf[varg0] += varg1;\n                        emit evTransfer(msg.sender, varg0, msg.sender, msg.value, varg1);\n                        v2 = v7 = 1;\n                    } else {\n                        v2 = v8 = 0;\n                    }\n                } else {\n                    v2 = v9 = 0;\n                }\n            } else {\n                v2 = v10 = 0;\n            }\n        } else {\n            v11 = new array[](v12.length);\n            v13 = v12.data;\n            v14, v15 = dataCopy();\n            if (7) {\n                MEM[v11.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v15;\n            }\n            emit evRecord(msg.sender, msg.value, v11);\n            assert(_isInTestMode);\n        }\n    }\n    goto {'0x2ca9', '0x17c9'};\n    if (!v2) {\n        if (0xff & _isFundLocked) {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v16.length;\n            v17, v18, v19 = dataCopy(MEM[(v16.data) len (v16.length)], MEM[(128 + MEM[64]) len (v16.length)]);\n            v20 = v16.length + (128 + MEM[64]);\n            if (19) {\n                MEM[v20 - 19] = ~0xffffffffffffffffffffffffff & MEM[v20 - 19];\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n        } else {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v21.length;\n            v22, v18, v23 = dataCopy(MEM[(v21.data) len (v21.length)], MEM[(128 + MEM[64]) len (v21.length)]);\n            v24 = v25 = v21.length + (128 + MEM[64]);\n            if (6) {\n                MEM[v25 - 6] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & v23;\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n            goto 0x14680x6f0;\n        }\n    } else {\n        v2 = v26 = 1;\n    }\n    return v2;\n}\n\nfunction taxPaid(address varg0) public payable { \n    return _taxPaid[varg0];\n}\n\nfunction maxBountyTokens() public payable { \n    return _maxBountyTokens;\n}\n\nfunction voteToKickoffNewFiscalYear() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                MEM[0] = 1;\n                MEM[32] = 37;\n                if (stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0) {\n                    if (_currentFiscalYear > 3) {\n                        v0 = new array[](v1.length);\n                        v2 = v1.data;\n                        v3, v4 = dataCopy('kickOff:4thYear');\n                        if (15) {\n                            MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & v4;\n                        }\n                        emit evRecord(msg.sender, msg.value, v0);\n                        assert(_isInTestMode);\n                        goto 0x18b0;\n                    } else if (_lastKickoffDateBuffer + _lastKickoffDate >= block.timestamp) {\n                        v5 = new array[](v6.length);\n                        v7 = v6.data;\n                        v8, v9 = dataCopy('kickOff:tooEarly');\n                        if (16) {\n                            MEM[v5.data] = ~0xffffffffffffffffffffffffffffffff & v9;\n                        }\n                        emit evRecord(msg.sender, msg.value, v5);\n                        assert(_isInTestMode);\n                        goto 0x18b0;\n                    }\n                }\n                _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender];\n                _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender] + _balanceOf[msg.sender];\n                _votedKickoff[msg.sender] = _balanceOf[msg.sender];\n                MEM[0] = _currentFiscalYear + 1;\n                MEM[32] = 21;\n                if (_supportKickoffQuorum[msg.sender] > _kickoffQuorumPercent * (_bountyTokensCreated + _tokensCreated) / 100) {\n                    if (1 == _currentFiscalYear + 1) {\n                        v10 = _extraBalanceWallet.call(0xb1a8b25a).gas(msg.gas - 25050);\n                        assert(v10);\n                        _totalInitialBalance = (address(this)).balance;\n                        _annualManagementFee = _mgmtFeePercentage * (address(this)).balance / 100 >> 2;\n                        v11 = _managementFeeWallet.call().value(_mgmtFeePercentage * (address(this)).balance / 100);\n                        if (!v11) {\n                            v12 = new array[](v13.length);\n                            v14 = v13.data;\n                            v15 = v16 = v13.length + v12.data;\n                            if (3) {\n                                MEM[v16 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v17;\n                            }\n                            emit evRecord(msg.sender, msg.value, v12);\n                            assert(_isInTestMode);\n                            goto 0x18b0;\n                        }\n                    }\n                    _isKickoffEnabled[_currentFiscalYear + 1] = 0x1 | ~0xff & _isKickoffEnabled[_currentFiscalYear + 1];\n                    _currentFiscalYear = _currentFiscalYear + 1;\n                    _lastKickoffDate = block.timestamp;\n                    v18 = _managementFeeWallet.call(0xa8bcbf3c00000000000000000000000000000000000000000000000000000000, _annualManagementFee).gas(msg.gas - 25050);\n                    assert(v18);\n                    emit evKickoff(msg.sender, msg.value, _currentFiscalYear + 1);\n                    emit evIssueManagementFee(msg.sender, msg.value, _annualManagementFee, 1);\n                }\n            } else {\n                v19 = new array[](v20.length);\n                v21 = v20.data;\n                v22, v23 = dataCopy();\n                if (10) {\n                    MEM[v19.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v23;\n                }\n                emit evRecord(msg.sender, msg.value, v19);\n                assert(_isInTestMode);\n                goto 0x18b0;\n            }\n        } else {\n            v24 = new array[](v25.length);\n            v26 = v25.data;\n            v27, v28 = dataCopy();\n            if (7) {\n                MEM[v24.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v28;\n            }\n            emit evRecord(msg.sender, msg.value, v24);\n            assert(_isInTestMode);\n            goto 0x18b0;\n        }\n    } else {\n        v29 = new array[](v30.length);\n        v31 = v30.data;\n        v32, v33 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v29.data] = ~0xffffffffffffffffffffffffffffffff & v33;\n        }\n        emit evRecord(msg.sender, msg.value, v29);\n        assert(_isInTestMode);\n    }\n}\n\nfunction supportKickoffQuorum(uint256 varg0) public payable { \n    return _supportKickoffQuorum[varg0];\n}\n\nfunction isInTestMode() public payable { \n    return _isInTestMode;\n}\n\nfunction managementBodyAddress() public payable { \n    return _managementBodyAddress;\n}\n\nfunction harvestQuorumPercent() public payable { \n    return _harvestQuorumPercent;\n}\n\nfunction isKickoffEnabled(uint256 varg0) public payable { \n    return 0xff & _isKickoffEnabled[varg0];\n}\n\nfunction mgmtRewardPercentage() public payable { \n    return _mgmtRewardPercentage;\n}\n\nfunction recallVoteToFreezeFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (!(0xff & _isFreezeEnabled)) {\n            if (msg.value <= 0) {\n                _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n                _votedFreeze[msg.sender] = 0;\n            } else {\n                v0 = new array[](v1.length);\n                v2 = v1.data;\n                v3, v4 = dataCopy();\n                if (7) {\n                    MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v4;\n                }\n                emit evRecord(msg.sender, msg.value, v0);\n                assert(_isInTestMode);\n            }\n        } else {\n            v5 = new array[](v6.length);\n            v7 = v6.data;\n            v8, v9 = dataCopy('onlyNotFrozen');\n            if (13) {\n                MEM[v5.data] = ~0xffffffffffffffffffffffffffffffffffffff & v9;\n            }\n            emit evRecord(msg.sender, msg.value, v5);\n            assert(_isInTestMode);\n        }\n    } else {\n        v10 = new array[](v11.length);\n        v12 = v11.data;\n        v13, v14 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v10.data] = ~0xffffffffffffffffffffffffffffffff & v14;\n        }\n        emit evRecord(msg.sender, msg.value, v10);\n        assert(_isInTestMode);\n    }\n}\n\nfunction bountyTokensCreated() public payable { \n    return _bountyTokensCreated;\n}\n\nfunction annualManagementFee() public payable { \n    return _annualManagementFee;\n}\n\nfunction tokensAvailableAtTierInternal(uint8 varg0, uint256 varg1, uint256 varg2) public payable { \n    v0 = varg1 * (0xff & varg0 + 1);\n    if (v0 > _maxTokensToCreate) {\n        v0 = v1 = _maxTokensToCreate;\n    }\n    if (varg2 <= v0) {\n        v2 = v0 - varg2;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction 0x81f(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = varg1 * (0xff & varg2 + 1);\n    if (v1 > _maxTokensToCreate) {\n        v0 = _maxTokensToCreate;\n    }\n    if (varg0 <= v0) {\n        v2 = v0 - varg0;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction isDaySixtyChecked() public payable { \n    return 0xff & _isFundLocked >> 24;\n}\n\nfunction voteToFreezeFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                if (_currentFiscalYear < 4) {\n                    if (!(0xff & _isFreezeEnabled >> 16)) {\n                        _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n                        _supportFreezeQuorum = _balanceOf[msg.sender] + (_supportFreezeQuorum - _votedFreeze[msg.sender]);\n                        MEM[32] = 19;\n                        _votedFreeze[msg.sender] = _balanceOf[msg.sender];\n                        if (_supportFreezeQuorum > (_bountyTokensCreated + _tokensCreated) * _freezeQuorumPercent / 100) {\n                            _isFreezeEnabled = 0x1 | ~0xff & _isFreezeEnabled;\n                            if (!(0xff & _isFreezeEnabled >> 16)) {\n                                _isFreezeEnabled = 0x1000000 | (0x10000 | _isFreezeEnabled & ~0xff0000) & ~0xff000000;\n                                v0 = address(_isFreezeEnabled >> 32).call().value((address(this)).balance);\n                                if (!v0) {\n                                    v1 = new array[](v2.length);\n                                    v3 = v2.data;\n                                    v4 = v5 = v2.length + v1.data;\n                                    if (3) {\n                                        MEM[v5 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v6;\n                                    }\n                                    emit evRecord(msg.sender, msg.value, v1);\n                                    assert(_isInTestMode);\n                                }\n                                v7 = _managementFeeWallet.call(0xfc44fd28).gas(msg.gas - 25050);\n                                assert(v7);\n                                v8 = _rewardWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                                assert(v8);\n                                v9 = _extraBalanceWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                                assert(v9);\n                                if (0 > 0) {\n                                    v10 = address(_isFreezeEnabled >> 32).call(0xb8b27765, 0).gas(msg.gas - 25050);\n                                    assert(v10);\n                                }\n                                v11 = address(_isFreezeEnabled >> 32).call(0x2033d9ae00000000000000000000000000000000000000000000000000000000, _bountyTokensCreated + _tokensCreated).gas(msg.gas - 25050);\n                                assert(v11);\n                                emit evMgmtDistributed(msg.sender, msg.value, (address(_isFreezeEnabled >> 32)).balance, 1);\n                                _isFreezeEnabled = 0x0 | ~0xff0000 & _isFreezeEnabled;\n                                goto 0x1efe;\n                            } else {\n                                v12 = new array[](v13.length);\n                                v14 = v13.data;\n                                v15, v16 = dataCopy('onlyDistributionNotInProgress');\n                                if (29) {\n                                    MEM[v12.data] = ~0xffffff & v16;\n                                }\n                                emit evRecord(msg.sender, msg.value, v12);\n                                assert(_isInTestMode);\n                            }\n                            emit evFreeze(msg.sender, msg.value);\n                        }\n                    } else {\n                        v17 = new array[](v18.length);\n                        v19 = v18.data;\n                        v20, v21 = dataCopy('onlyDistributionNotInProgress');\n                        if (29) {\n                            MEM[v17.data] = ~0xffffff & v21;\n                        }\n                        emit evRecord(msg.sender, msg.value, v17);\n                        assert(_isInTestMode);\n                        goto 0x118f0x85f;\n                    }\n                } else {\n                    v22 = new array[](v23.length);\n                    v24 = v23.data;\n                    v25, v26 = dataCopy('currentFiscalYear>=4');\n                    if (20) {\n                        MEM[v22.data] = ~0xffffffffffffffffffffffff & v26;\n                    }\n                    emit evRecord(msg.sender, msg.value, v22);\n                    assert(_isInTestMode);\n                    goto 0x118f0x85f;\n                }\n            } else {\n                v27 = new array[](v28.length);\n                v29 = v28.data;\n                v30, v31 = dataCopy();\n                if (10) {\n                    MEM[v27.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v31;\n                }\n                emit evRecord(msg.sender, msg.value, v27);\n                assert(_isInTestMode);\n                goto 0x118f0x85f;\n            }\n        } else {\n            v32 = new array[](v33.length);\n            v34 = v33.data;\n            v35, v36 = dataCopy();\n            if (7) {\n                MEM[v32.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v36;\n            }\n            emit evRecord(msg.sender, msg.value, v32);\n            assert(_isInTestMode);\n            goto 0x118f0x85f;\n        }\n    } else {\n        v37 = new array[](v38.length);\n        v39 = v38.data;\n        v40, v41 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v37.data] = ~0xffffffffffffffffffffffffffffffff & v41;\n        }\n        emit evRecord(msg.sender, msg.value, v37);\n        assert(_isInTestMode);\n    }\n}\n\nfunction refundMyIcoInvestment() public payable { \n    if (msg.value <= 0) {\n        if (!(0xff & _isFundLocked)) {\n            if (0 != _balanceOf[msg.sender]) {\n                if (owner_1c[msg.sender] != 0) {\n                    if (_balanceOf[msg.sender] <= _tokensCreated) {\n                        _balanceOf[msg.sender] = 0;\n                        owner_1c[msg.sender] = 0;\n                        MEM[32] = 29;\n                        owner_1c[msg.sender] = 0;\n                        _tokensCreated = _tokensCreated - _balanceOf[msg.sender];\n                        v0 = _extraBalanceWallet.call(0x51fa7efd00000000000000000000000000000000000000000000000000000000, owner_1c[msg.sender]).gas(msg.gas - 25050);\n                        assert(v0);\n                        v1 = msg.sender.call().value(owner_1c[msg.sender]);\n                        if (v1) {\n                            emit evRefund(msg.sender, msg.sender, msg.value, owner_1c[msg.sender], 1);\n                            v2 = v3 = _tokensCreated < _minTokensToCreate;\n                            if (v3) {\n                                v2 = _tokensCreated >= _minTokensToCreate;\n                            }\n                            if (v2) {\n                                emit evMinTokensReached(msg.sender, msg.value, _tokensCreated);\n                            }\n                        } else {\n                            MEM[64 + MEM[64]] = owner_1c[msg.sender];\n                            emit evRefund(msg.sender, msg.sender, msg.value, owner_1c[msg.sender], 0);\n                            v4 = new array[](v5.length);\n                            v6 = v5.data;\n                            v7, v8 = dataCopy('refund:SendFailed');\n                            if (17) {\n                                MEM[v4.data] = ~0xffffffffffffffffffffffffffffff & v8;\n                            }\n                            emit evRecord(msg.sender, msg.value, v4);\n                            assert(_isInTestMode);\n                            goto 0x1f7b;\n                        }\n                    } else {\n                        v9 = new array[](v10.length);\n                        v11 = v10.data;\n                        v12, v13 = dataCopy('invalidTokenCount');\n                        if (17) {\n                            MEM[v9.data] = ~0xffffffffffffffffffffffffffffff & v13;\n                        }\n                        emit evRecord(msg.sender, msg.value, v9);\n                        assert(_isInTestMode);\n                        goto 0x1f7b;\n                    }\n                } else {\n                    v14 = new array[](v15.length);\n                    v16 = v15.data;\n                    v17, v18 = dataCopy('noWeiGiven');\n                    if (10) {\n                        MEM[v14.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v18;\n                    }\n                    emit evRecord(msg.sender, msg.value, v14);\n                    assert(_isInTestMode);\n                    goto 0x1f7b;\n                }\n            } else {\n                v19 = new array[](v20.length);\n                v21 = v20.data;\n                v22, v23 = dataCopy('onlyTokenHolders');\n                if (16) {\n                    MEM[v19.data] = ~0xffffffffffffffffffffffffffffffff & v23;\n                }\n                emit evRecord(msg.sender, msg.value, v19);\n                assert(_isInTestMode);\n                goto 0x1f7b;\n            }\n        } else {\n            v24 = new array[](v25.length);\n            v26 = v25.data;\n            v27, v28 = dataCopy();\n            if (9) {\n                MEM[v24.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & v28;\n            }\n            emit evRecord(msg.sender, msg.value, v24);\n            assert(_isInTestMode);\n            goto 0x1f7b;\n        }\n    } else {\n        v29 = new array[](v30.length);\n        v31 = v30.data;\n        v32, v33 = dataCopy();\n        if (7) {\n            MEM[v29.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v33;\n        }\n        emit evRecord(msg.sender, msg.value, v29);\n        assert(_isInTestMode);\n    }\n}\n\nfunction rewardWallet() public payable { \n    return _rewardWallet;\n}\n\nfunction mgmtIssueBountyToken(address varg0, uint256 varg1) public payable { \n    if (msg.value <= 0) {\n        if (msg.sender == _managementBodyAddress) {\n            if (varg1 + _bountyTokensCreated <= _maxBountyTokens) {\n                _balanceOf[varg0] += varg1;\n                _bountyTokensCreated += varg1;\n                emit evMgmtIssueBountyToken(msg.sender, msg.value, varg0, varg1, 1);\n            } else {\n                v0 = new array[](v1.length);\n                v2 = v1.data;\n                v3, v4 = dataCopy('hitMaxBounty');\n                if (12) {\n                    MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffff & v4;\n                }\n                emit evRecord(msg.sender, msg.value, v0);\n                assert(_isInTestMode);\n            }\n        } else {\n            v5 = new array[](v6.length);\n            v7 = v6.data;\n            v8, v9 = dataCopy('onlyManagementBody');\n            if (18) {\n                MEM[v5.data] = ~0xffffffffffffffffffffffffffff & v9;\n            }\n            emit evRecord(msg.sender, msg.value, v5);\n            assert(_isInTestMode);\n            goto 0x14680x8bf;\n        }\n    } else {\n        v10 = new array[](v11.length);\n        v12 = v11.data;\n        v13, v14 = dataCopy();\n        if (7) {\n            MEM[v10.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v14;\n        }\n        emit evRecord(msg.sender, msg.value, v10);\n        assert(_isInTestMode);\n    }\n    goto 0x2df9;\n    return 0;\n}\n\nfunction currentFiscalYear() public payable { \n    return _currentFiscalYear;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = function_selector >> 224;\n        if (v0 == 0x2410cf6) {\n            isFundReleased();\n        } else if (0x44a5f97 == v0) {\n            mgmtDistribute();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x89aa819 == v0) {\n            weiPerInitialHONG();\n        } else if (0xc103837 == v0) {\n            votedHarvest(address);\n        } else if (0xc3b7b96 == v0) {\n            minTokensToCreate();\n        } else if (0xd40e8d6 == v0) {\n            supportHarvestQuorum();\n        } else if (0x14841164 == v0) {\n            extraBalanceWallet();\n        } else if (0x1d107603 == v0) {\n            totalInitialBalance();\n        } else if (0x1f2dc5ef == v0) {\n            divisor();\n        } else if (0x21d3523c == v0) {\n            voteToHarvestFund();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x342d9185 == v0) {\n            pricePerTokenAtCurrentTier();\n        } else if (0x35d37dbb == v0) {\n            mgmtFeePercentage();\n        } else if (0x42750020 == v0) {\n            tokensCreated();\n        } else if (0x44440a59 == v0) {\n            isDistributionReady();\n        } else if (0x4845d3f8 == v0) {\n            closingTimeExtensionPeriod();\n        } else if (0x490fc399 == v0) {\n            votedKickoff(uint256,address);\n        } else if (0x4b6753bc == v0) {\n            closingTime();\n        } else if (0x53bc147e == v0) {\n            lastKickoffDateBuffer();\n        } else if (0x5474fbd3 == v0) {\n            isDayThirtyChecked();\n        } else if (0x558305f9 == v0) {\n            isFreezeEnabled();\n        } else if (0x56a3f4ef == v0) {\n            collectMyReturn();\n        } else if (0x5b6aa3c2 == v0) {\n            isMinTokensReached();\n        } else if (0x60d3e4c5 == v0) {\n            isDistributionInProgress();\n        } else if (0x67cf91c9 == v0) {\n            lastKickoffDate();\n        } else if (0x6b9c1d22 == v0) {\n            managementFeeWallet();\n        } else if (0x70606cda == v0) {\n            supportFreezeQuorum();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x73f5f8ee == v0) {\n            tokensAvailableAtCurrentTier();\n        } else if (0x7412c223 == v0) {\n            getCurrentTier();\n        } else if (0x7895f853 == v0) {\n            isFundLocked();\n        } else if (0x7c2b8d0a == v0) {\n            votedFreeze(address);\n        } else if (0x7e4a1731 == v0) {\n            returnWallet();\n        } else if (0x81dd70db == v0) {\n            kickoffQuorumPercent();\n        } else if (0x8c32e774 == v0) {\n            isMaxTokensReached();\n        } else if (0x9496df3f == v0) {\n            freezeQuorumPercent();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x9bd90aae == v0) {\n            maxTokensToCreate();\n        } else if (0x9cb74ab6 == v0) {\n            mgmtInvestProject(address,uint256);\n        } else if (0x9e47214a == v0) {\n            isHarvestEnabled();\n        } else if (0xa8d5652e == v0) {\n            tokensPerTier();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xa988e371 == v0) {\n            taxPaid(address);\n        } else if (0xab71b8ac == v0) {\n            maxBountyTokens();\n        } else if (0xadbda5a8 == v0) {\n            voteToKickoffNewFiscalYear();\n        } else if (0xaea3ad8c == v0) {\n            supportKickoffQuorum(uint256);\n        } else if (0xb656e9f4 == v0) {\n            isInTestMode();\n        } else if (0xba0bface == v0) {\n            managementBodyAddress();\n        } else if (0xbf53e3ba == v0) {\n            harvestQuorumPercent();\n        } else if (0xc86a9dea == v0) {\n            isKickoffEnabled(uint256);\n        } else if (0xcdd8d4e8 == v0) {\n            mgmtRewardPercentage();\n        } else if (0xcfebb88b == v0) {\n            recallVoteToFreezeFund();\n        } else if (0xda228f9c == v0) {\n            bountyTokensCreated();\n        } else if (0xdc7049bf == v0) {\n            annualManagementFee();\n        } else if (0xdf234815 == v0) {\n            tokensAvailableAtTierInternal(uint8,uint256,uint256);\n        } else if (0xe0e32504 == v0) {\n            isDaySixtyChecked();\n        } else if (0xe2649caf == v0) {\n            voteToFreezeFund();\n        } else if (0xe84f7054 == v0) {\n            refundMyIcoInvestment();\n        } else if (0xfb75b2c7 == v0) {\n            rewardWallet();\n        } else if (0xfea5d7b1 == v0) {\n            mgmtIssueBountyToken(address,uint256);\n        } else if (0xffa309e4 == v0) {\n            currentFiscalYear();\n        }\n    }\n    v1 = v2 = 10482;\n    v1 = v3 = 2330;\n    v4 = v5 = _extraBalanceWallet == msg.sender;\n    if (_extraBalanceWallet != msg.sender) {\n        v4 = v6 = msg.sender == address(_isFreezeEnabled >> 32);\n    }\n    if (!v4) {\n        v4 = v7 = msg.sender == _rewardWallet;\n    }\n    if (!v4) {\n        v4 = v8 = msg.sender == _managementFeeWallet;\n    }\n    if (v4) {\n        emit evRecord(msg.sender, msg.value, 'Recevied ether from ManagedAccount');\n        v4 = v9 = 1;\n        goto 0x28f2;\n    } else {\n        v4 = v10 = 0;\n        if (!(0xff & _isFundLocked)) {\n            if (!(0xff & _isFundLocked >> 8)) {\n                if (msg.value > 0) {\n                    v11 = v12 = 0;\n                    v13 = v14 = 0;\n                    v15 = 0x591();\n                    v16 = v17 = _weiPerInitialHONG * (0xff & 100 + 5 * v15) / 100;\n                    v18 = v19 = msg.value;\n                    v20 = v21 = 0x580();\n                    if (0 != v21) {\n                        while (v18 >= v16) {\n                            v20 = v18 / v16;\n                            if (v20 >= v20) {\n                            }\n                            v22 = v23 = 0 == v20;\n                            if (v23) {\n                                v22 = v24 = _maxTokensToCreate == _tokensCreated;\n                            }\n                            _balanceOf[msg.sender] += v20;\n                            _tokensCreated += v20;\n                            _balanceOf[msg.sender] += v20 * v16;\n                            v11 += v20;\n                            v13 += v20 * v16;\n                            v25 = 0x591();\n                            v16 = v26 = _weiPerInitialHONG * (0xff & 100 + 5 * v25) / 100;\n                            v18 = msg.value - v13;\n                            v20 = v27 = 0x580();\n                        }\n                        owner_1c[msg.sender] += v18;\n                        owner_1c[msg.sender] += v13 - v11 * _weiPerInitialHONG;\n                        if (!(0xff & _isFundLocked >> 8)) {\n                            _isFundLocked = (_tokensCreated >= _maxTokensToCreate) | ~0xff & _isFundLocked;\n                            v28 = v29 = !(0xff & ((_tokensCreated >= _maxTokensToCreate) | ~0xff & _isFundLocked));\n                            if (v29) {\n                                v28 = v30 = !(0xff & _isFundLocked >> 16);\n                            }\n                            if (v28) {\n                                v28 = v31 = block.timestamp >= _closingTime;\n                            }\n                            if (v28) {\n                                if (_tokensCreated >= _minTokensToCreate) {\n                                    _isFundLocked = 0x1 | ~0xff & _isFundLocked;\n                                }\n                                _isFundLocked = 0x10000 | ~0xff0000 & _isFundLocked;\n                            }\n                            v32 = v33 = !(0xff & _isFundLocked);\n                            if (v33) {\n                                v32 = v34 = !(0xff & _isFundLocked >> 24);\n                            }\n                            if (v32) {\n                                v32 = v35 = block.timestamp >= _closingTime + _closingTimeExtensionPeriod;\n                            }\n                            if (v32) {\n                                if (_tokensCreated >= _minTokensToCreate) {\n                                    _isFundLocked = 0x1 | ~0xff & _isFundLocked;\n                                }\n                                _isFundLocked = 0x1000000 | ~0xff000000 & _isFundLocked;\n                            }\n                            v36 = v37 = 0xff & _isFundLocked >> 24;\n                            if (v37) {\n                                v36 = v38 = _tokensCreated < _minTokensToCreate;\n                            }\n                            if (v36) {\n                                _isFundLocked = 0x100 | ~0xff00 & _isFundLocked;\n                            }\n                        }\n                        if (v13 - v11 * _weiPerInitialHONG > 0) {\n                            v39 = _extraBalanceWallet.call().value(v13 - v11 * _weiPerInitialHONG);\n                            if (!v39) {\n                                MEM[MEM[64]] = msg.sender;\n                                MEM[32 + MEM[64]] = msg.value;\n                                MEM[64 + MEM[64]] = 96;\n                                MEM[96 + MEM[64]] = v40.length;\n                                v41 = v40.data;\n                                v42, v43 = dataCopy('extraBalance:sendFail');\n                                v44 = v45 = v40.length + (128 + MEM[64]);\n                                if (21) {\n                                    MEM[v45 - 21] = ~0xffffffffffffffffffffff & v43;\n                                }\n                                emit evRecord();\n                                assert(_isInTestMode);\n                            }\n                        }\n                        emit evCreatedToken(msg.sender, msg.sender, msg.value, v11);\n                        v46 = v47 = _tokensCreated < _minTokensToCreate;\n                        if (v47) {\n                            v46 = _tokensCreated >= _minTokensToCreate;\n                        }\n                        if (v46) {\n                            emit evMinTokensReached(msg.sender, msg.value, _tokensCreated);\n                        }\n                        if (0xff & _isFundLocked) {\n                            emit evLockFund(msg.sender, msg.value);\n                        }\n                        if (0xff & _isFundLocked >> 8) {\n                            emit evReleaseFund(msg.sender, msg.value);\n                        }\n                        v4 = v48 = 1;\n                    } else {\n                        MEM[MEM[64]] = msg.sender;\n                        MEM[32 + MEM[64]] = msg.value;\n                        MEM[64 + MEM[64]] = 96;\n                        MEM[96 + MEM[64]] = v49.length;\n                        v50 = v49.data;\n                        v51, v52 = dataCopy('noTokensToSell');\n                        v53 = v54 = v49.length + (128 + MEM[64]);\n                        if (14) {\n                            MEM[v54 - 14] = ~0xffffffffffffffffffffffffffffffffffff & v52;\n                        }\n                        emit evRecord();\n                        assert(_isInTestMode);\n                        v4 = v55 = 0;\n                    }\n                } else {\n                    MEM[MEM[64]] = msg.sender;\n                    MEM[32 + MEM[64]] = msg.value;\n                    MEM[64 + MEM[64]] = 96;\n                    MEM[96 + MEM[64]] = v56.length;\n                    v57 = v56.data;\n                    v58, v59 = dataCopy();\n                    v60 = v61 = v56.length + (128 + MEM[64]);\n                    if (8) {\n                        MEM[v61 - 8] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v59;\n                    }\n                    emit evRecord();\n                    assert(_isInTestMode);\n                }\n            } else {\n                MEM[MEM[64]] = msg.sender;\n                MEM[32 + MEM[64]] = msg.value;\n                MEM[64 + MEM[64]] = 96;\n                MEM[96 + MEM[64]] = v62.length;\n                v63 = v62.data;\n                v64, v65 = dataCopy('notReleased');\n                v66 = v67 = v62.length + (128 + MEM[64]);\n                if (11) {\n                    MEM[v67 - 11] = ~0xffffffffffffffffffffffffffffffffffffffffff & v65;\n                }\n                emit evRecord();\n                assert(_isInTestMode);\n            }\n        } else {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v68.length;\n            v69 = v68.data;\n            v70, v71 = dataCopy();\n            v72 = v73 = v68.length + (128 + MEM[64]);\n            if (9) {\n                MEM[v73 - 9] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & v71;\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n        }\n    }\n    goto {'0x91a', '0x28f2'};\n    return v4;\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.06 04:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _isInTestMode; // STORAGE[0x0] bytes 0 to 0\nuint256 _closingTime; // STORAGE[0x1]\nuint256 _weiPerInitialHONG; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _maxBountyTokens; // STORAGE[0x6]\nuint256 _closingTimeExtensionPeriod; // STORAGE[0x7]\nuint256 _minTokensToCreate; // STORAGE[0x8]\nuint256 _maxTokensToCreate; // STORAGE[0x9]\nuint256 _tokensPerTier; // STORAGE[0xa]\nuint256 _lastKickoffDateBuffer; // STORAGE[0xb]\nuint256 _mgmtRewardPercentage; // STORAGE[0xc]\nuint256 _mgmtFeePercentage; // STORAGE[0xd]\nuint256 _harvestQuorumPercent; // STORAGE[0xe]\nuint256 _freezeQuorumPercent; // STORAGE[0xf]\nuint256 _kickoffQuorumPercent; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _votedKickoff; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _votedFreeze; // STORAGE[0x13]\nmapping (uint256 => [uint256]) _votedHarvest; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _supportKickoffQuorum; // STORAGE[0x15]\nuint256 _supportFreezeQuorum; // STORAGE[0x16]\nuint256 _supportHarvestQuorum; // STORAGE[0x17]\nuint256 _totalInitialBalance; // STORAGE[0x18]\nuint256 _annualManagementFee; // STORAGE[0x19]\nmapping (uint256 => [uint256]) owner_1c; // STORAGE[0x1c]\nmapping (uint256 => [uint256]) _taxPaid; // STORAGE[0x1d]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1e]\nuint256 _tokensCreated; // STORAGE[0x20]\nuint256 _isFundLocked; // STORAGE[0x21]\nuint256 _bountyTokensCreated; // STORAGE[0x22]\nuint256 _currentFiscalYear; // STORAGE[0x23]\nuint256 _lastKickoffDate; // STORAGE[0x24]\nmapping (uint256 => [uint256]) _isKickoffEnabled; // STORAGE[0x25]\nuint256 _isFreezeEnabled; // STORAGE[0x26]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint256 _managementBodyAddress; // STORAGE[0x1a] bytes 0 to 19\nuint256 _extraBalanceWallet; // STORAGE[0x1b] bytes 0 to 19\nuint256 _rewardWallet; // STORAGE[0x27] bytes 0 to 19\nuint256 _managementFeeWallet; // STORAGE[0x28] bytes 0 to 19\nuint256 stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0; // STORAGE[0x20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26] bytes 0 to 0\n\n// Events\nevRecord(address, uint256, string);\nevCreatedToken(address, uint256, address, uint256);\nevMinTokensReached(address, uint256, uint256);\nevLockFund(address, uint256);\nevReleaseFund(address, uint256);\nevHarvest(address, uint256);\nevMgmtInvestProject(address, uint256, address, uint256, bool);\nevKickoff(address, uint256, uint256);\nevIssueManagementFee(address, uint256, uint256, bool);\nevFreeze(address, uint256);\nevRefund(address, uint256, address, uint256, bool);\nevMgmtIssueBountyToken(address, uint256, address, uint256, bool);\nevMgmtDistributed(address, uint256, uint256, bool);\nevTransfer(address, uint256, address, address, uint256);\n\nfunction isFundReleased() public payable { \n    return 0xff & _isFundLocked >> 8;\n}\n\nfunction mgmtDistribute() public payable { \n    if (msg.sender == _managementBodyAddress) {\n        if (msg.value > 0) {\n            if (0xff & _isFreezeEnabled >> 8) {\n                if (!(0xff & _isFreezeEnabled >> 24)) {\n                    if (!(0xff & _isFreezeEnabled >> 16)) {\n                        _isFreezeEnabled = 0x1000000 | (0x10000 | _isFreezeEnabled & ~0xff0000) & ~0xff000000;\n                        v0 = address(_isFreezeEnabled >> 32).call().value((address(this)).balance);\n                        if (!v0) {\n                            v1 = new array[](v2.length);\n                            v3 = v2.data;\n                            v4 = v5 = v2.length + v1.data;\n                            if (3) {\n                                MEM[v5 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v6;\n                            }\n                            emit evRecord(msg.sender, msg.value, v1);\n                            assert(_isInTestMode);\n                        }\n                        v7 = _managementFeeWallet.call(0xfc44fd28).gas(msg.gas - 25050);\n                        assert(v7);\n                        v8 = _rewardWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                        assert(v8);\n                        v9 = _extraBalanceWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                        assert(v9);\n                        if (_mgmtRewardPercentage > 0) {\n                            v10 = address(_isFreezeEnabled >> 32).call(0xb8b27765, _mgmtRewardPercentage).gas(msg.gas - 25050);\n                            assert(v10);\n                        }\n                        v11 = address(_isFreezeEnabled >> 32).call(0x2033d9ae00000000000000000000000000000000000000000000000000000000, _bountyTokensCreated + _tokensCreated).gas(msg.gas - 25050);\n                        assert(v11);\n                        emit evMgmtDistributed(msg.sender, msg.value, (address(_isFreezeEnabled >> 32)).balance, 1);\n                        _isFreezeEnabled = 0x0 | ~0xff0000 & _isFreezeEnabled;\n                    } else {\n                        v12 = new array[](v13.length);\n                        v14 = v13.data;\n                        v15, v16 = dataCopy('onlyDistributionNotInProgress');\n                        if (29) {\n                            MEM[v12.data] = ~0xffffff & v16;\n                        }\n                        emit evRecord(msg.sender, msg.value, v12);\n                        assert(_isInTestMode);\n                    }\n                } else {\n                    v17 = new array[](v18.length);\n                    v19 = v18.data;\n                    v20, v21 = dataCopy('onlyDistributionNotReady');\n                    if (24) {\n                        MEM[v17.data] = ~0xffffffffffffffff & v21;\n                    }\n                    emit evRecord(msg.sender, msg.value, v17);\n                    assert(_isInTestMode);\n                }\n            } else {\n                v22 = new array[](v23.length);\n                v24 = v23.data;\n                v25, v26 = dataCopy('onlyHarvestEnabled');\n                if (18) {\n                    MEM[v22.data] = ~0xffffffffffffffffffffffffffff & v26;\n                }\n                emit evRecord(msg.sender, msg.value, v22);\n                assert(_isInTestMode);\n            }\n        } else {\n            v27 = new array[](v28.length);\n            v29 = v28.data;\n            v30, v31 = dataCopy();\n            if (8) {\n                MEM[v27.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v31;\n            }\n            emit evRecord(msg.sender, msg.value, v27);\n            assert(_isInTestMode);\n        }\n    } else {\n        v32 = new array[](v33.length);\n        v34 = v33.data;\n        v35, v36 = dataCopy('onlyManagementBody');\n        if (18) {\n            MEM[v32.data] = ~0xffffffffffffffffffffffffffff & v36;\n        }\n        emit evRecord(msg.sender, msg.value, v32);\n        assert(_isInTestMode);\n    }\n}\n\nfunction name() public payable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v0.length;\n    v4 = v0.data;\n    v5 = dataCopy(_name.length >> 8 << 8);\n    v6 = v0.length + (64 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n        v6 = v7 = 32 + (v6 - (0x1f & v0.length));\n    }\n    return MEM[(MEM[64]) len (v6 - MEM[64])];\n}\n\nfunction weiPerInitialHONG() public payable { \n    return _weiPerInitialHONG;\n}\n\nfunction votedHarvest(address varg0) public payable { \n    return _votedHarvest[varg0];\n}\n\nfunction minTokensToCreate() public payable { \n    return _minTokensToCreate;\n}\n\nfunction supportHarvestQuorum() public payable { \n    return _supportHarvestQuorum;\n}\n\nfunction extraBalanceWallet() public payable { \n    return _extraBalanceWallet;\n}\n\nfunction totalInitialBalance() public payable { \n    return _totalInitialBalance;\n}\n\nfunction divisor() public payable { \n    v0 = 0x591();\n    return 0xff & 100 + 5 * v0;\n}\n\nfunction voteToHarvestFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                if (_currentFiscalYear >= 4) {\n                    _supportHarvestQuorum = _supportHarvestQuorum - _votedHarvest[msg.sender];\n                    _supportHarvestQuorum = _balanceOf[msg.sender] + (_supportHarvestQuorum - _votedHarvest[msg.sender]);\n                    MEM[32] = 20;\n                    _votedHarvest[msg.sender] = _balanceOf[msg.sender];\n                    if (_supportHarvestQuorum > (_bountyTokensCreated + _tokensCreated) * _harvestQuorumPercent / 100) {\n                        _isFreezeEnabled = 0x100 | ~0xff00 & _isFreezeEnabled;\n                        emit evHarvest(msg.sender, msg.value);\n                    }\n                } else {\n                    v0 = new array[](v1.length);\n                    v2 = v1.data;\n                    v3, v4 = dataCopy('currentFiscalYear<4');\n                    if (19) {\n                        MEM[v0.data] = ~0xffffffffffffffffffffffffff & v4;\n                    }\n                    emit evRecord(msg.sender, msg.value, v0);\n                    assert(_isInTestMode);\n                    goto 0x118f0x459;\n                }\n            } else {\n                v5 = new array[](v6.length);\n                v7 = v6.data;\n                v8, v9 = dataCopy();\n                if (10) {\n                    MEM[v5.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v9;\n                }\n                emit evRecord(msg.sender, msg.value, v5);\n                assert(_isInTestMode);\n                goto 0x118f0x459;\n            }\n        } else {\n            v10 = new array[](v11.length);\n            v12 = v11.data;\n            v13, v14 = dataCopy();\n            if (7) {\n                MEM[v10.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v14;\n            }\n            emit evRecord(msg.sender, msg.value, v10);\n            assert(_isInTestMode);\n            goto 0x118f0x459;\n        }\n    } else {\n        v15 = new array[](v16.length);\n        v17 = v16.data;\n        v18, v19 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v15.data] = ~0xffffffffffffffffffffffffffffffff & v19;\n        }\n        emit evRecord(msg.sender, msg.value, v15);\n        assert(_isInTestMode);\n    }\n}\n\nfunction decimals() public payable { \n    return _decimals;\n}\n\nfunction pricePerTokenAtCurrentTier() public payable { \n    v0 = 0x591();\n    return _weiPerInitialHONG * (0xff & 100 + 5 * v0) / 100;\n}\n\nfunction mgmtFeePercentage() public payable { \n    return _mgmtFeePercentage;\n}\n\nfunction tokensCreated() public payable { \n    return _tokensCreated;\n}\n\nfunction isDistributionReady() public payable { \n    return 0xff & _isFreezeEnabled >> 24;\n}\n\nfunction closingTimeExtensionPeriod() public payable { \n    return _closingTimeExtensionPeriod;\n}\n\nfunction votedKickoff(uint256 varg0, address varg1) public payable { \n    return _votedKickoff[varg1];\n}\n\nfunction closingTime() public payable { \n    return _closingTime;\n}\n\nfunction lastKickoffDateBuffer() public payable { \n    return _lastKickoffDateBuffer;\n}\n\nfunction isDayThirtyChecked() public payable { \n    return 0xff & _isFundLocked >> 16;\n}\n\nfunction isFreezeEnabled() public payable { \n    return 0xff & _isFreezeEnabled;\n}\n\nfunction collectMyReturn() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFreezeEnabled >> 24) {\n                _balanceOf[msg.sender] = 0;\n                v0 = address(_isFreezeEnabled >> 32).call(0x9f3ef43000000000000000000000000000000000000000000000000000000000, msg.sender, _balanceOf[msg.sender]).gas(msg.gas - 25050);\n                assert(v0);\n            } else {\n                v1 = new array[](v2.length);\n                v3 = v2.data;\n                v4, v5 = dataCopy('onlyDistributionReady');\n                if (21) {\n                    MEM[v1.data] = ~0xffffffffffffffffffffff & v5;\n                }\n                emit evRecord(msg.sender, msg.value, v1);\n                assert(_isInTestMode);\n                goto 0x118f0x505;\n            }\n        } else {\n            v6 = new array[](v7.length);\n            v8 = v7.data;\n            v9, v10 = dataCopy();\n            if (7) {\n                MEM[v6.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v10;\n            }\n            emit evRecord(msg.sender, msg.value, v6);\n            assert(_isInTestMode);\n            goto 0x118f0x505;\n        }\n    } else {\n        v11 = new array[](v12.length);\n        v13 = v12.data;\n        v14, v15 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v11.data] = ~0xffffffffffffffffffffffffffffffff & v15;\n        }\n        emit evRecord(msg.sender, msg.value, v11);\n        assert(_isInTestMode);\n    }\n    goto 0x2ac4;\n}\n\nfunction isMinTokensReached() public payable { \n    return _tokensCreated >= _minTokensToCreate;\n}\n\nfunction isDistributionInProgress() public payable { \n    return 0xff & _isFreezeEnabled >> 16;\n}\n\nfunction lastKickoffDate() public payable { \n    return _lastKickoffDate;\n}\n\nfunction managementFeeWallet() public payable { \n    return _managementFeeWallet;\n}\n\nfunction supportFreezeQuorum() public payable { \n    return _supportFreezeQuorum;\n}\n\nfunction balanceOf(address varg0) public payable { \n    return _balanceOf[varg0];\n}\n\nfunction tokensAvailableAtCurrentTier() public payable { \n    v0 = 0x591();\n    v1 = 0x81f(_tokensCreated, _tokensPerTier, v0);\n    return v1;\n}\n\nfunction 0x580() private { \n    v0 = 0x591();\n    v1 = 0x81f(_tokensCreated, _tokensPerTier, v0);\n    return v1;\n}\n\nfunction getCurrentTier() public payable { \n    v0 = _tokensCreated / _tokensPerTier;\n    if (v0 & 0xff > 4) {\n        v0 = v1 = 4;\n    }\n    return 0xff & v0;\n}\n\nfunction 0x591() private { \n    v0 = v1 = _tokensCreated / _tokensPerTier;\n    if (v1 & 0xff > 4) {\n        v0 = v2 = 4;\n    }\n    return v0;\n}\n\nfunction isFundLocked() public payable { \n    return 0xff & _isFundLocked;\n}\n\nfunction votedFreeze(address varg0) public payable { \n    return _votedFreeze[varg0];\n}\n\nfunction returnWallet() public payable { \n    return address(_isFreezeEnabled >> 32);\n}\n\nfunction kickoffQuorumPercent() public payable { \n    return _kickoffQuorumPercent;\n}\n\nfunction isMaxTokensReached() public payable { \n    return _tokensCreated >= _maxTokensToCreate;\n}\n\nfunction freezeQuorumPercent() public payable { \n    return _freezeQuorumPercent;\n}\n\nfunction symbol() public payable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v0.length;\n    v4 = v0.data;\n    v5 = dataCopy(_symbol.length >> 8 << 8);\n    v6 = v0.length + (64 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n        v6 = v7 = 32 + (v6 - (0x1f & v0.length));\n    }\n    return MEM[(MEM[64]) len (v6 - MEM[64])];\n}\n\nfunction maxTokensToCreate() public payable { \n    return _maxTokensToCreate;\n}\n\nfunction mgmtInvestProject(address varg0, uint256 varg1) public payable { \n    if (msg.sender == _managementBodyAddress) {\n        if (msg.value > 0) {\n            v0 = v1 = !(0xff & _isKickoffEnabled[_currentFiscalYear]);\n            if (0xff & _isKickoffEnabled[_currentFiscalYear]) {\n                v0 = v2 = 0xff & _isFreezeEnabled;\n            }\n            if (!v0) {\n                v0 = v3 = 0xff & _isFreezeEnabled >> 8;\n            }\n            if (!v0) {\n                if (varg1 < (address(this)).balance) {\n                    v4 = varg0.call().value(varg1).gas(msg.gas - 34050);\n                    if (v4) {\n                        emit evMgmtInvestProject(msg.sender, msg.value, varg0, varg1, 1);\n                    } else {\n                        v5 = new array[](v6.length);\n                        v7 = v6.data;\n                        v8 = v9 = v6.length + v5.data;\n                        if (23) {\n                            MEM[v9 - 23] = ~0xffffffffffffffffff & v10;\n                        }\n                        emit evRecord(msg.sender, msg.value, v5);\n                        assert(_isInTestMode);\n                        goto 0x14680x676;\n                    }\n                } else {\n                    v11 = new array[](v12.length);\n                    v13 = v12.data;\n                    v14 = v15 = v12.length + v11.data;\n                    if (17) {\n                        MEM[v15 - 17] = ~0xffffffffffffffffffffffffffffff & v16;\n                    }\n                    emit evRecord(msg.sender, msg.value, v11);\n                    assert(_isInTestMode);\n                    goto 0x14680x676;\n                }\n            } else {\n                emit evMgmtInvestProject(msg.sender, msg.value, varg0, varg1, 0);\n            }\n        } else {\n            v17 = new array[](v18.length);\n            v19 = v18.data;\n            v20, v21 = dataCopy();\n            if (8) {\n                MEM[v17.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v21;\n            }\n            emit evRecord(msg.sender, msg.value, v17);\n            assert(_isInTestMode);\n            goto 0x14680x676;\n        }\n    } else {\n        v22 = new array[](v23.length);\n        v24 = v23.data;\n        v25, v26 = dataCopy('onlyManagementBody');\n        if (18) {\n            MEM[v22.data] = ~0xffffffffffffffffffffffffffff & v26;\n        }\n        emit evRecord(msg.sender, msg.value, v22);\n        assert(_isInTestMode);\n    }\n    return 0;\n}\n\nfunction isHarvestEnabled() public payable { \n    return 0xff & _isFreezeEnabled >> 8;\n}\n\nfunction tokensPerTier() public payable { \n    return _tokensPerTier;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    v0 = v1 = 11433;\n    v2 = v3 = 0;\n    if (_currentFiscalYear < 4) {\n        if (_votedKickoff[msg.sender] <= varg1) {\n            _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender];\n            _supportKickoffQuorum[1 + _currentFiscalYear] = 0;\n        } else {\n            STORAGE[keccak256(msg.sender, keccak256(1 + _currentFiscalYear, 18))] = STORAGE[keccak256(msg.sender, keccak256(1 + _currentFiscalYear, 18))] - varg1;\n            _supportKickoffQuorum[1 + _currentFiscalYear] = _supportKickoffQuorum[1 + _currentFiscalYear] - varg1;\n        }\n    }\n    if (_votedFreeze[msg.sender] <= varg1) {\n        _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n        _votedFreeze[msg.sender] = 0;\n    } else {\n        STORAGE[keccak256(msg.sender, 19)] = STORAGE[keccak256(msg.sender, 19)] - varg1;\n        _supportFreezeQuorum = _supportFreezeQuorum - varg1;\n    }\n    if (_votedHarvest[msg.sender] <= varg1) {\n        _supportHarvestQuorum = _supportHarvestQuorum - _votedHarvest[msg.sender];\n        _votedHarvest[msg.sender] = 0;\n    } else {\n        STORAGE[keccak256(msg.sender, 20)] = STORAGE[keccak256(msg.sender, 20)] - varg1;\n        _supportHarvestQuorum = _supportHarvestQuorum - varg1;\n    }\n    v2 = v4 = 0xff & _isFundLocked;\n    if (v4) {\n        v0 = v5 = 6089;\n        v2 = v6 = 0;\n        if (msg.value <= 0) {\n            if (varg1 > 0) {\n                if (_balanceOf[msg.sender] >= varg1) {\n                    if (varg1 + _balanceOf[varg0] >= _balanceOf[varg0]) {\n                        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n                        _balanceOf[varg0] += varg1;\n                        emit evTransfer(msg.sender, varg0, msg.sender, msg.value, varg1);\n                        v2 = v7 = 1;\n                    } else {\n                        v2 = v8 = 0;\n                    }\n                } else {\n                    v2 = v9 = 0;\n                }\n            } else {\n                v2 = v10 = 0;\n            }\n        } else {\n            v11 = new array[](v12.length);\n            v13 = v12.data;\n            v14, v15 = dataCopy();\n            if (7) {\n                MEM[v11.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v15;\n            }\n            emit evRecord(msg.sender, msg.value, v11);\n            assert(_isInTestMode);\n        }\n    }\n    goto {'0x2ca9', '0x17c9'};\n    if (!v2) {\n        if (0xff & _isFundLocked) {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v16.length;\n            v17, v18, v19 = dataCopy(MEM[(v16.data) len (v16.length)], MEM[(128 + MEM[64]) len (v16.length)]);\n            v20 = v16.length + (128 + MEM[64]);\n            if (19) {\n                MEM[v20 - 19] = ~0xffffffffffffffffffffffffff & MEM[v20 - 19];\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n        } else {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v21.length;\n            v22, v18, v23 = dataCopy(MEM[(v21.data) len (v21.length)], MEM[(128 + MEM[64]) len (v21.length)]);\n            v24 = v25 = v21.length + (128 + MEM[64]);\n            if (6) {\n                MEM[v25 - 6] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & v23;\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n            goto 0x14680x6f0;\n        }\n    } else {\n        v2 = v26 = 1;\n    }\n    return v2;\n}\n\nfunction taxPaid(address varg0) public payable { \n    return _taxPaid[varg0];\n}\n\nfunction maxBountyTokens() public payable { \n    return _maxBountyTokens;\n}\n\nfunction voteToKickoffNewFiscalYear() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                MEM[0] = 1;\n                MEM[32] = 37;\n                if (stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0) {\n                    if (_currentFiscalYear > 3) {\n                        v0 = new array[](v1.length);\n                        v2 = v1.data;\n                        v3, v4 = dataCopy('kickOff:4thYear');\n                        if (15) {\n                            MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & v4;\n                        }\n                        emit evRecord(msg.sender, msg.value, v0);\n                        assert(_isInTestMode);\n                        goto 0x18b0;\n                    } else if (_lastKickoffDateBuffer + _lastKickoffDate >= block.timestamp) {\n                        v5 = new array[](v6.length);\n                        v7 = v6.data;\n                        v8, v9 = dataCopy('kickOff:tooEarly');\n                        if (16) {\n                            MEM[v5.data] = ~0xffffffffffffffffffffffffffffffff & v9;\n                        }\n                        emit evRecord(msg.sender, msg.value, v5);\n                        assert(_isInTestMode);\n                        goto 0x18b0;\n                    }\n                }\n                _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender];\n                _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender] + _balanceOf[msg.sender];\n                _votedKickoff[msg.sender] = _balanceOf[msg.sender];\n                MEM[0] = _currentFiscalYear + 1;\n                MEM[32] = 21;\n                if (_supportKickoffQuorum[msg.sender] > _kickoffQuorumPercent * (_bountyTokensCreated + _tokensCreated) / 100) {\n                    if (1 == _currentFiscalYear + 1) {\n                        v10 = _extraBalanceWallet.call(0xb1a8b25a).gas(msg.gas - 25050);\n                        assert(v10);\n                        _totalInitialBalance = (address(this)).balance;\n                        _annualManagementFee = _mgmtFeePercentage * (address(this)).balance / 100 >> 2;\n                        v11 = _managementFeeWallet.call().value(_mgmtFeePercentage * (address(this)).balance / 100);\n                        if (!v11) {\n                            v12 = new array[](v13.length);\n                            v14 = v13.data;\n                            v15 = v16 = v13.length + v12.data;\n                            if (3) {\n                                MEM[v16 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v17;\n                            }\n                            emit evRecord(msg.sender, msg.value, v12);\n                            assert(_isInTestMode);\n                            goto 0x18b0;\n                        }\n                    }\n                    _isKickoffEnabled[_currentFiscalYear + 1] = 0x1 | ~0xff & _isKickoffEnabled[_currentFiscalYear + 1];\n                    _currentFiscalYear = _currentFiscalYear + 1;\n                    _lastKickoffDate = block.timestamp;\n                    v18 = _managementFeeWallet.call(0xa8bcbf3c00000000000000000000000000000000000000000000000000000000, _annualManagementFee).gas(msg.gas - 25050);\n                    assert(v18);\n                    emit evKickoff(msg.sender, msg.value, _currentFiscalYear + 1);\n                    emit evIssueManagementFee(msg.sender, msg.value, _annualManagementFee, 1);\n                }\n            } else {\n                v19 = new array[](v20.length);\n                v21 = v20.data;\n                v22, v23 = dataCopy();\n                if (10) {\n                    MEM[v19.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v23;\n                }\n                emit evRecord(msg.sender, msg.value, v19);\n                assert(_isInTestMode);\n                goto 0x18b0;\n            }\n        } else {\n            v24 = new array[](v25.length);\n            v26 = v25.data;\n            v27, v28 = dataCopy();\n            if (7) {\n                MEM[v24.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v28;\n            }\n            emit evRecord(msg.sender, msg.value, v24);\n            assert(_isInTestMode);\n            goto 0x18b0;\n        }\n    } else {\n        v29 = new array[](v30.length);\n        v31 = v30.data;\n        v32, v33 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v29.data] = ~0xffffffffffffffffffffffffffffffff & v33;\n        }\n        emit evRecord(msg.sender, msg.value, v29);\n        assert(_isInTestMode);\n    }\n}\n\nfunction supportKickoffQuorum(uint256 varg0) public payable { \n    return _supportKickoffQuorum[varg0];\n}\n\nfunction isInTestMode() public payable { \n    return _isInTestMode;\n}\n\nfunction managementBodyAddress() public payable { \n    return _managementBodyAddress;\n}\n\nfunction harvestQuorumPercent() public payable { \n    return _harvestQuorumPercent;\n}\n\nfunction isKickoffEnabled(uint256 varg0) public payable { \n    return 0xff & _isKickoffEnabled[varg0];\n}\n\nfunction mgmtRewardPercentage() public payable { \n    return _mgmtRewardPercentage;\n}\n\nfunction recallVoteToFreezeFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (!(0xff & _isFreezeEnabled)) {\n            if (msg.value <= 0) {\n                _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n                _votedFreeze[msg.sender] = 0;\n            } else {\n                v0 = new array[](v1.length);\n                v2 = v1.data;\n                v3, v4 = dataCopy();\n                if (7) {\n                    MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v4;\n                }\n                emit evRecord(msg.sender, msg.value, v0);\n                assert(_isInTestMode);\n            }\n        } else {\n            v5 = new array[](v6.length);\n            v7 = v6.data;\n            v8, v9 = dataCopy('onlyNotFrozen');\n            if (13) {\n                MEM[v5.data] = ~0xffffffffffffffffffffffffffffffffffffff & v9;\n            }\n            emit evRecord(msg.sender, msg.value, v5);\n            assert(_isInTestMode);\n        }\n    } else {\n        v10 = new array[](v11.length);\n        v12 = v11.data;\n        v13, v14 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v10.data] = ~0xffffffffffffffffffffffffffffffff & v14;\n        }\n        emit evRecord(msg.sender, msg.value, v10);\n        assert(_isInTestMode);\n    }\n}\n\nfunction bountyTokensCreated() public payable { \n    return _bountyTokensCreated;\n}\n\nfunction annualManagementFee() public payable { \n    return _annualManagementFee;\n}\n\nfunction tokensAvailableAtTierInternal(uint8 varg0, uint256 varg1, uint256 varg2) public payable { \n    v0 = varg1 * (0xff & varg0 + 1);\n    if (v0 > _maxTokensToCreate) {\n        v0 = v1 = _maxTokensToCreate;\n    }\n    if (varg2 <= v0) {\n        v2 = v0 - varg2;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction 0x81f(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = varg1 * (0xff & varg2 + 1);\n    if (v1 > _maxTokensToCreate) {\n        v0 = _maxTokensToCreate;\n    }\n    if (varg0 <= v0) {\n        v2 = v0 - varg0;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction isDaySixtyChecked() public payable { \n    return 0xff & _isFundLocked >> 24;\n}\n\nfunction voteToFreezeFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                if (_currentFiscalYear < 4) {\n                    if (!(0xff & _isFreezeEnabled >> 16)) {\n                        _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n                        _supportFreezeQuorum = _balanceOf[msg.sender] + (_supportFreezeQuorum - _votedFreeze[msg.sender]);\n                        MEM[32] = 19;\n                        _votedFreeze[msg.sender] = _balanceOf[msg.sender];\n                        if (_supportFreezeQuorum > (_bountyTokensCreated + _tokensCreated) * _freezeQuorumPercent / 100) {\n                            _isFreezeEnabled = 0x1 | ~0xff & _isFreezeEnabled;\n                            if (!(0xff & _isFreezeEnabled >> 16)) {\n                                _isFreezeEnabled = 0x1000000 | (0x10000 | _isFreezeEnabled & ~0xff0000) & ~0xff000000;\n                                v0 = address(_isFreezeEnabled >> 32).call().value((address(this)).balance);\n                                if (!v0) {\n                                    v1 = new array[](v2.length);\n                                    v3 = v2.data;\n                                    v4 = v5 = v2.length + v1.data;\n                                    if (3) {\n                                        MEM[v5 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v6;\n                                    }\n                                    emit evRecord(msg.sender, msg.value, v1);\n                                    assert(_isInTestMode);\n                                }\n                                v7 = _managementFeeWallet.call(0xfc44fd28).gas(msg.gas - 25050);\n                                assert(v7);\n                                v8 = _rewardWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                                assert(v8);\n                                v9 = _extraBalanceWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                                assert(v9);\n                                if (0 > 0) {\n                                    v10 = address(_isFreezeEnabled >> 32).call(0xb8b27765, 0).gas(msg.gas - 25050);\n                                    assert(v10);\n                                }\n                                v11 = address(_isFreezeEnabled >> 32).call(0x2033d9ae00000000000000000000000000000000000000000000000000000000, _bountyTokensCreated + _tokensCreated).gas(msg.gas - 25050);\n                                assert(v11);\n                                emit evMgmtDistributed(msg.sender, msg.value, (address(_isFreezeEnabled >> 32)).balance, 1);\n                                _isFreezeEnabled = 0x0 | ~0xff0000 & _isFreezeEnabled;\n                                goto 0x1efe;\n                            } else {\n                                v12 = new array[](v13.length);\n                                v14 = v13.data;\n                                v15, v16 = dataCopy('onlyDistributionNotInProgress');\n                                if (29) {\n                                    MEM[v12.data] = ~0xffffff & v16;\n                                }\n                                emit evRecord(msg.sender, msg.value, v12);\n                                assert(_isInTestMode);\n                            }\n                            emit evFreeze(msg.sender, msg.value);\n                        }\n                    } else {\n                        v17 = new array[](v18.length);\n                        v19 = v18.data;\n                        v20, v21 = dataCopy('onlyDistributionNotInProgress');\n                        if (29) {\n                            MEM[v17.data] = ~0xffffff & v21;\n                        }\n                        emit evRecord(msg.sender, msg.value, v17);\n                        assert(_isInTestMode);\n                        goto 0x118f0x85f;\n                    }\n                } else {\n                    v22 = new array[](v23.length);\n                    v24 = v23.data;\n                    v25, v26 = dataCopy('currentFiscalYear>=4');\n                    if (20) {\n                        MEM[v22.data] = ~0xffffffffffffffffffffffff & v26;\n                    }\n                    emit evRecord(msg.sender, msg.value, v22);\n                    assert(_isInTestMode);\n                    goto 0x118f0x85f;\n                }\n            } else {\n                v27 = new array[](v28.length);\n                v29 = v28.data;\n                v30, v31 = dataCopy();\n                if (10) {\n                    MEM[v27.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v31;\n                }\n                emit evRecord(msg.sender, msg.value, v27);\n                assert(_isInTestMode);\n                goto 0x118f0x85f;\n            }\n        } else {\n            v32 = new array[](v33.length);\n            v34 = v33.data;\n            v35, v36 = dataCopy();\n            if (7) {\n                MEM[v32.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v36;\n            }\n            emit evRecord(msg.sender, msg.value, v32);\n            assert(_isInTestMode);\n            goto 0x118f0x85f;\n        }\n    } else {\n        v37 = new array[](v38.length);\n        v39 = v38.data;\n        v40, v41 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v37.data] = ~0xffffffffffffffffffffffffffffffff & v41;\n        }\n        emit evRecord(msg.sender, msg.value, v37);\n        assert(_isInTestMode);\n    }\n}\n\nfunction refundMyIcoInvestment() public payable { \n    if (msg.value <= 0) {\n        if (!(0xff & _isFundLocked)) {\n            if (0 != _balanceOf[msg.sender]) {\n                if (owner_1c[msg.sender] != 0) {\n                    if (_balanceOf[msg.sender] <= _tokensCreated) {\n                        _balanceOf[msg.sender] = 0;\n                        owner_1c[msg.sender] = 0;\n                        MEM[32] = 29;\n                        owner_1c[msg.sender] = 0;\n                        _tokensCreated = _tokensCreated - _balanceOf[msg.sender];\n                        v0 = _extraBalanceWallet.call(0x51fa7efd00000000000000000000000000000000000000000000000000000000, owner_1c[msg.sender]).gas(msg.gas - 25050);\n                        assert(v0);\n                        v1 = msg.sender.call().value(owner_1c[msg.sender]);\n                        if (v1) {\n                            emit evRefund(msg.sender, msg.sender, msg.value, owner_1c[msg.sender], 1);\n                            v2 = v3 = _tokensCreated < _minTokensToCreate;\n                            if (v3) {\n                                v2 = _tokensCreated >= _minTokensToCreate;\n                            }\n                            if (v2) {\n                                emit evMinTokensReached(msg.sender, msg.value, _tokensCreated);\n                            }\n                        } else {\n                            MEM[64 + MEM[64]] = owner_1c[msg.sender];\n                            emit evRefund(msg.sender, msg.sender, msg.value, owner_1c[msg.sender], 0);\n                            v4 = new array[](v5.length);\n                            v6 = v5.data;\n                            v7, v8 = dataCopy('refund:SendFailed');\n                            if (17) {\n                                MEM[v4.data] = ~0xffffffffffffffffffffffffffffff & v8;\n                            }\n                            emit evRecord(msg.sender, msg.value, v4);\n                            assert(_isInTestMode);\n                            goto 0x1f7b;\n                        }\n                    } else {\n                        v9 = new array[](v10.length);\n                        v11 = v10.data;\n                        v12, v13 = dataCopy('invalidTokenCount');\n                        if (17) {\n                            MEM[v9.data] = ~0xffffffffffffffffffffffffffffff & v13;\n                        }\n                        emit evRecord(msg.sender, msg.value, v9);\n                        assert(_isInTestMode);\n                        goto 0x1f7b;\n                    }\n                } else {\n                    v14 = new array[](v15.length);\n                    v16 = v15.data;\n                    v17, v18 = dataCopy('noWeiGiven');\n                    if (10) {\n                        MEM[v14.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v18;\n                    }\n                    emit evRecord(msg.sender, msg.value, v14);\n                    assert(_isInTestMode);\n                    goto 0x1f7b;\n                }\n            } else {\n                v19 = new array[](v20.length);\n                v21 = v20.data;\n                v22, v23 = dataCopy('onlyTokenHolders');\n                if (16) {\n                    MEM[v19.data] = ~0xffffffffffffffffffffffffffffffff & v23;\n                }\n                emit evRecord(msg.sender, msg.value, v19);\n                assert(_isInTestMode);\n                goto 0x1f7b;\n            }\n        } else {\n            v24 = new array[](v25.length);\n            v26 = v25.data;\n            v27, v28 = dataCopy();\n            if (9) {\n                MEM[v24.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & v28;\n            }\n            emit evRecord(msg.sender, msg.value, v24);\n            assert(_isInTestMode);\n            goto 0x1f7b;\n        }\n    } else {\n        v29 = new array[](v30.length);\n        v31 = v30.data;\n        v32, v33 = dataCopy();\n        if (7) {\n            MEM[v29.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v33;\n        }\n        emit evRecord(msg.sender, msg.value, v29);\n        assert(_isInTestMode);\n    }\n}\n\nfunction rewardWallet() public payable { \n    return _rewardWallet;\n}\n\nfunction mgmtIssueBountyToken(address varg0, uint256 varg1) public payable { \n    if (msg.value <= 0) {\n        if (msg.sender == _managementBodyAddress) {\n            if (varg1 + _bountyTokensCreated <= _maxBountyTokens) {\n                _balanceOf[varg0] += varg1;\n                _bountyTokensCreated += varg1;\n                emit evMgmtIssueBountyToken(msg.sender, msg.value, varg0, varg1, 1);\n            } else {\n                v0 = new array[](v1.length);\n                v2 = v1.data;\n                v3, v4 = dataCopy('hitMaxBounty');\n                if (12) {\n                    MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffff & v4;\n                }\n                emit evRecord(msg.sender, msg.value, v0);\n                assert(_isInTestMode);\n            }\n        } else {\n            v5 = new array[](v6.length);\n            v7 = v6.data;\n            v8, v9 = dataCopy('onlyManagementBody');\n            if (18) {\n                MEM[v5.data] = ~0xffffffffffffffffffffffffffff & v9;\n            }\n            emit evRecord(msg.sender, msg.value, v5);\n            assert(_isInTestMode);\n            goto 0x14680x8bf;\n        }\n    } else {\n        v10 = new array[](v11.length);\n        v12 = v11.data;\n        v13, v14 = dataCopy();\n        if (7) {\n            MEM[v10.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v14;\n        }\n        emit evRecord(msg.sender, msg.value, v10);\n        assert(_isInTestMode);\n    }\n    goto 0x2df9;\n    return 0;\n}\n\nfunction currentFiscalYear() public payable { \n    return _currentFiscalYear;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = function_selector >> 224;\n        if (v0 == 0x2410cf6) {\n            isFundReleased();\n        } else if (0x44a5f97 == v0) {\n            mgmtDistribute();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x89aa819 == v0) {\n            weiPerInitialHONG();\n        } else if (0xc103837 == v0) {\n            votedHarvest(address);\n        } else if (0xc3b7b96 == v0) {\n            minTokensToCreate();\n        } else if (0xd40e8d6 == v0) {\n            supportHarvestQuorum();\n        } else if (0x14841164 == v0) {\n            extraBalanceWallet();\n        } else if (0x1d107603 == v0) {\n            totalInitialBalance();\n        } else if (0x1f2dc5ef == v0) {\n            divisor();\n        } else if (0x21d3523c == v0) {\n            voteToHarvestFund();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x342d9185 == v0) {\n            pricePerTokenAtCurrentTier();\n        } else if (0x35d37dbb == v0) {\n            mgmtFeePercentage();\n        } else if (0x42750020 == v0) {\n            tokensCreated();\n        } else if (0x44440a59 == v0) {\n            isDistributionReady();\n        } else if (0x4845d3f8 == v0) {\n            closingTimeExtensionPeriod();\n        } else if (0x490fc399 == v0) {\n            votedKickoff(uint256,address);\n        } else if (0x4b6753bc == v0) {\n            closingTime();\n        } else if (0x53bc147e == v0) {\n            lastKickoffDateBuffer();\n        } else if (0x5474fbd3 == v0) {\n            isDayThirtyChecked();\n        } else if (0x558305f9 == v0) {\n            isFreezeEnabled();\n        } else if (0x56a3f4ef == v0) {\n            collectMyReturn();\n        } else if (0x5b6aa3c2 == v0) {\n            isMinTokensReached();\n        } else if (0x60d3e4c5 == v0) {\n            isDistributionInProgress();\n        } else if (0x67cf91c9 == v0) {\n            lastKickoffDate();\n        } else if (0x6b9c1d22 == v0) {\n            managementFeeWallet();\n        } else if (0x70606cda == v0) {\n            supportFreezeQuorum();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x73f5f8ee == v0) {\n            tokensAvailableAtCurrentTier();\n        } else if (0x7412c223 == v0) {\n            getCurrentTier();\n        } else if (0x7895f853 == v0) {\n            isFundLocked();\n        } else if (0x7c2b8d0a == v0) {\n            votedFreeze(address);\n        } else if (0x7e4a1731 == v0) {\n            returnWallet();\n        } else if (0x81dd70db == v0) {\n            kickoffQuorumPercent();\n        } else if (0x8c32e774 == v0) {\n            isMaxTokensReached();\n        } else if (0x9496df3f == v0) {\n            freezeQuorumPercent();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x9bd90aae == v0) {\n            maxTokensToCreate();\n        } else if (0x9cb74ab6 == v0) {\n            mgmtInvestProject(address,uint256);\n        } else if (0x9e47214a == v0) {\n            isHarvestEnabled();\n        } else if (0xa8d5652e == v0) {\n            tokensPerTier();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xa988e371 == v0) {\n            taxPaid(address);\n        } else if (0xab71b8ac == v0) {\n            maxBountyTokens();\n        } else if (0xadbda5a8 == v0) {\n            voteToKickoffNewFiscalYear();\n        } else if (0xaea3ad8c == v0) {\n            supportKickoffQuorum(uint256);\n        } else if (0xb656e9f4 == v0) {\n            isInTestMode();\n        } else if (0xba0bface == v0) {\n            managementBodyAddress();\n        } else if (0xbf53e3ba == v0) {\n            harvestQuorumPercent();\n        } else if (0xc86a9dea == v0) {\n            isKickoffEnabled(uint256);\n        } else if (0xcdd8d4e8 == v0) {\n            mgmtRewardPercentage();\n        } else if (0xcfebb88b == v0) {\n            recallVoteToFreezeFund();\n        } else if (0xda228f9c == v0) {\n            bountyTokensCreated();\n        } else if (0xdc7049bf == v0) {\n            annualManagementFee();\n        } else if (0xdf234815 == v0) {\n            tokensAvailableAtTierInternal(uint8,uint256,uint256);\n        } else if (0xe0e32504 == v0) {\n            isDaySixtyChecked();\n        } else if (0xe2649caf == v0) {\n            voteToFreezeFund();\n        } else if (0xe84f7054 == v0) {\n            refundMyIcoInvestment();\n        } else if (0xfb75b2c7 == v0) {\n            rewardWallet();\n        } else if (0xfea5d7b1 == v0) {\n            mgmtIssueBountyToken(address,uint256);\n        } else if (0xffa309e4 == v0) {\n            currentFiscalYear();\n        }\n    }\n    v1 = v2 = 10482;\n    v1 = v3 = 2330;\n    v4 = v5 = _extraBalanceWallet == msg.sender;\n    if (_extraBalanceWallet != msg.sender) {\n        v4 = v6 = msg.sender == address(_isFreezeEnabled >> 32);\n    }\n    if (!v4) {\n        v4 = v7 = msg.sender == _rewardWallet;\n    }\n    if (!v4) {\n        v4 = v8 = msg.sender == _managementFeeWallet;\n    }\n    if (v4) {\n        emit evRecord(msg.sender, msg.value, 'Recevied ether from ManagedAccount');\n        v4 = v9 = 1;\n        goto 0x28f2;\n    } else {\n        v4 = v10 = 0;\n        if (!(0xff & _isFundLocked)) {\n            if (!(0xff & _isFundLocked >> 8)) {\n                if (msg.value > 0) {\n                    v11 = v12 = 0;\n                    v13 = v14 = 0;\n                    v15 = 0x591();\n                    v16 = v17 = _weiPerInitialHONG * (0xff & 100 + 5 * v15) / 100;\n                    v18 = v19 = msg.value;\n                    v20 = v21 = 0x580();\n                    if (0 != v21) {\n                        while (v18 >= v16) {\n                            v20 = v18 / v16;\n                            if (v20 >= v20) {\n                            }\n                            v22 = v23 = 0 == v20;\n                            if (v23) {\n                                v22 = v24 = _maxTokensToCreate == _tokensCreated;\n                            }\n                            _balanceOf[msg.sender] += v20;\n                            _tokensCreated += v20;\n                            _balanceOf[msg.sender] += v20 * v16;\n                            v11 += v20;\n                            v13 += v20 * v16;\n                            v25 = 0x591();\n                            v16 = v26 = _weiPerInitialHONG * (0xff & 100 + 5 * v25) / 100;\n                            v18 = msg.value - v13;\n                            v20 = v27 = 0x580();\n                        }\n                        owner_1c[msg.sender] += v18;\n                        owner_1c[msg.sender] += v13 - v11 * _weiPerInitialHONG;\n                        if (!(0xff & _isFundLocked >> 8)) {\n                            _isFundLocked = (_tokensCreated >= _maxTokensToCreate) | ~0xff & _isFundLocked;\n                            v28 = v29 = !(0xff & ((_tokensCreated >= _maxTokensToCreate) | ~0xff & _isFundLocked));\n                            if (v29) {\n                                v28 = v30 = !(0xff & _isFundLocked >> 16);\n                            }\n                            if (v28) {\n                                v28 = v31 = block.timestamp >= _closingTime;\n                            }\n                            if (v28) {\n                                if (_tokensCreated >= _minTokensToCreate) {\n                                    _isFundLocked = 0x1 | ~0xff & _isFundLocked;\n                                }\n                                _isFundLocked = 0x10000 | ~0xff0000 & _isFundLocked;\n                            }\n                            v32 = v33 = !(0xff & _isFundLocked);\n                            if (v33) {\n                                v32 = v34 = !(0xff & _isFundLocked >> 24);\n                            }\n                            if (v32) {\n                                v32 = v35 = block.timestamp >= _closingTime + _closingTimeExtensionPeriod;\n                            }\n                            if (v32) {\n                                if (_tokensCreated >= _minTokensToCreate) {\n                                    _isFundLocked = 0x1 | ~0xff & _isFundLocked;\n                                }\n                                _isFundLocked = 0x1000000 | ~0xff000000 & _isFundLocked;\n                            }\n                            v36 = v37 = 0xff & _isFundLocked >> 24;\n                            if (v37) {\n                                v36 = v38 = _tokensCreated < _minTokensToCreate;\n                            }\n                            if (v36) {\n                                _isFundLocked = 0x100 | ~0xff00 & _isFundLocked;\n                            }\n                        }\n                        if (v13 - v11 * _weiPerInitialHONG > 0) {\n                            v39 = _extraBalanceWallet.call().value(v13 - v11 * _weiPerInitialHONG);\n                            if (!v39) {\n                                MEM[MEM[64]] = msg.sender;\n                                MEM[32 + MEM[64]] = msg.value;\n                                MEM[64 + MEM[64]] = 96;\n                                MEM[96 + MEM[64]] = v40.length;\n                                v41 = v40.data;\n                                v42, v43 = dataCopy('extraBalance:sendFail');\n                                v44 = v45 = v40.length + (128 + MEM[64]);\n                                if (21) {\n                                    MEM[v45 - 21] = ~0xffffffffffffffffffffff & v43;\n                                }\n                                emit evRecord();\n                                assert(_isInTestMode);\n                            }\n                        }\n                        emit evCreatedToken(msg.sender, msg.sender, msg.value, v11);\n                        v46 = v47 = _tokensCreated < _minTokensToCreate;\n                        if (v47) {\n                            v46 = _tokensCreated >= _minTokensToCreate;\n                        }\n                        if (v46) {\n                            emit evMinTokensReached(msg.sender, msg.value, _tokensCreated);\n                        }\n                        if (0xff & _isFundLocked) {\n                            emit evLockFund(msg.sender, msg.value);\n                        }\n                        if (0xff & _isFundLocked >> 8) {\n                            emit evReleaseFund(msg.sender, msg.value);\n                        }\n                        v4 = v48 = 1;\n                    } else {\n                        MEM[MEM[64]] = msg.sender;\n                        MEM[32 + MEM[64]] = msg.value;\n                        MEM[64 + MEM[64]] = 96;\n                        MEM[96 + MEM[64]] = v49.length;\n                        v50 = v49.data;\n                        v51, v52 = dataCopy('noTokensToSell');\n                        v53 = v54 = v49.length + (128 + MEM[64]);\n                        if (14) {\n                            MEM[v54 - 14] = ~0xffffffffffffffffffffffffffffffffffff & v52;\n                        }\n                        emit evRecord();\n                        assert(_isInTestMode);\n                        v4 = v55 = 0;\n                    }\n                } else {\n                    MEM[MEM[64]] = msg.sender;\n                    MEM[32 + MEM[64]] = msg.value;\n                    MEM[64 + MEM[64]] = 96;\n                    MEM[96 + MEM[64]] = v56.length;\n                    v57 = v56.data;\n                    v58, v59 = dataCopy();\n                    v60 = v61 = v56.length + (128 + MEM[64]);\n                    if (8) {\n                        MEM[v61 - 8] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v59;\n                    }\n                    emit evRecord();\n                    assert(_isInTestMode);\n                }\n            } else {\n                MEM[MEM[64]] = msg.sender;\n                MEM[32 + MEM[64]] = msg.value;\n                MEM[64 + MEM[64]] = 96;\n                MEM[96 + MEM[64]] = v62.length;\n                v63 = v62.data;\n                v64, v65 = dataCopy('notReleased');\n                v66 = v67 = v62.length + (128 + MEM[64]);\n                if (11) {\n                    MEM[v67 - 11] = ~0xffffffffffffffffffffffffffffffffffffffffff & v65;\n                }\n                emit evRecord();\n                assert(_isInTestMode);\n            }\n        } else {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v68.length;\n            v69 = v68.data;\n            v70, v71 = dataCopy();\n            v72 = v73 = v68.length + (128 + MEM[64]);\n            if (9) {\n                MEM[v73 - 9] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & v71;\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n        }\n    }\n    goto {'0x91a', '0x28f2'};\n    return v4;\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.06 04:47 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _isInTestMode; // STORAGE[0x0] bytes 0 to 0\nuint256 _closingTime; // STORAGE[0x1]\nuint256 _weiPerInitialHONG; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _maxBountyTokens; // STORAGE[0x6]\nuint256 _closingTimeExtensionPeriod; // STORAGE[0x7]\nuint256 _minTokensToCreate; // STORAGE[0x8]\nuint256 _maxTokensToCreate; // STORAGE[0x9]\nuint256 _tokensPerTier; // STORAGE[0xa]\nuint256 _lastKickoffDateBuffer; // STORAGE[0xb]\nuint256 _mgmtRewardPercentage; // STORAGE[0xc]\nuint256 _mgmtFeePercentage; // STORAGE[0xd]\nuint256 _harvestQuorumPercent; // STORAGE[0xe]\nuint256 _freezeQuorumPercent; // STORAGE[0xf]\nuint256 _kickoffQuorumPercent; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _votedKickoff; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _votedFreeze; // STORAGE[0x13]\nmapping (uint256 => [uint256]) _votedHarvest; // STORAGE[0x14]\nmapping (uint256 => [uint256]) _supportKickoffQuorum; // STORAGE[0x15]\nuint256 _supportFreezeQuorum; // STORAGE[0x16]\nuint256 _supportHarvestQuorum; // STORAGE[0x17]\nuint256 _totalInitialBalance; // STORAGE[0x18]\nuint256 _annualManagementFee; // STORAGE[0x19]\nmapping (uint256 => [uint256]) owner_1c; // STORAGE[0x1c]\nmapping (uint256 => [uint256]) _taxPaid; // STORAGE[0x1d]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1e]\nuint256 _tokensCreated; // STORAGE[0x20]\nuint256 _isFundLocked; // STORAGE[0x21]\nuint256 _bountyTokensCreated; // STORAGE[0x22]\nuint256 _currentFiscalYear; // STORAGE[0x23]\nuint256 _lastKickoffDate; // STORAGE[0x24]\nmapping (uint256 => [uint256]) _isKickoffEnabled; // STORAGE[0x25]\nuint256 _isFreezeEnabled; // STORAGE[0x26]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint256 _managementBodyAddress; // STORAGE[0x1a] bytes 0 to 19\nuint256 _extraBalanceWallet; // STORAGE[0x1b] bytes 0 to 19\nuint256 _rewardWallet; // STORAGE[0x27] bytes 0 to 19\nuint256 _managementFeeWallet; // STORAGE[0x28] bytes 0 to 19\nuint256 stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0; // STORAGE[0x20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26] bytes 0 to 0\n\n// Events\nevRecord(address, uint256, string);\nevCreatedToken(address, uint256, address, uint256);\nevMinTokensReached(address, uint256, uint256);\nevLockFund(address, uint256);\nevReleaseFund(address, uint256);\nevHarvest(address, uint256);\nevMgmtInvestProject(address, uint256, address, uint256, bool);\nevKickoff(address, uint256, uint256);\nevIssueManagementFee(address, uint256, uint256, bool);\nevFreeze(address, uint256);\nevRefund(address, uint256, address, uint256, bool);\nevMgmtIssueBountyToken(address, uint256, address, uint256, bool);\nevMgmtDistributed(address, uint256, uint256, bool);\nevTransfer(address, uint256, address, address, uint256);\n\nfunction isFundReleased() public payable { \n    return 0xff & _isFundLocked >> 8;\n}\n\nfunction mgmtDistribute() public payable { \n    if (msg.sender == _managementBodyAddress) {\n        if (msg.value > 0) {\n            if (0xff & _isFreezeEnabled >> 8) {\n                if (!(0xff & _isFreezeEnabled >> 24)) {\n                    if (!(0xff & _isFreezeEnabled >> 16)) {\n                        _isFreezeEnabled = 0x1000000 | (0x10000 | _isFreezeEnabled & ~0xff0000) & ~0xff000000;\n                        v0 = address(_isFreezeEnabled >> 32).call().value((address(this)).balance);\n                        if (!v0) {\n                            v1 = new array[](v2.length);\n                            v3 = v2.data;\n                            v4 = v5 = v2.length + v1.data;\n                            if (3) {\n                                MEM[v5 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v6;\n                            }\n                            emit evRecord(msg.sender, msg.value, v1);\n                            assert(_isInTestMode);\n                        }\n                        v7 = _managementFeeWallet.call(0xfc44fd28).gas(msg.gas - 25050);\n                        assert(v7);\n                        v8 = _rewardWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                        assert(v8);\n                        v9 = _extraBalanceWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                        assert(v9);\n                        if (_mgmtRewardPercentage > 0) {\n                            v10 = address(_isFreezeEnabled >> 32).call(0xb8b27765, _mgmtRewardPercentage).gas(msg.gas - 25050);\n                            assert(v10);\n                        }\n                        v11 = address(_isFreezeEnabled >> 32).call(0x2033d9ae00000000000000000000000000000000000000000000000000000000, _bountyTokensCreated + _tokensCreated).gas(msg.gas - 25050);\n                        assert(v11);\n                        emit evMgmtDistributed(msg.sender, msg.value, (address(_isFreezeEnabled >> 32)).balance, 1);\n                        _isFreezeEnabled = 0x0 | ~0xff0000 & _isFreezeEnabled;\n                    } else {\n                        v12 = new array[](v13.length);\n                        v14 = v13.data;\n                        v15, v16 = dataCopy('onlyDistributionNotInProgress');\n                        if (29) {\n                            MEM[v12.data] = ~0xffffff & v16;\n                        }\n                        emit evRecord(msg.sender, msg.value, v12);\n                        assert(_isInTestMode);\n                    }\n                } else {\n                    v17 = new array[](v18.length);\n                    v19 = v18.data;\n                    v20, v21 = dataCopy('onlyDistributionNotReady');\n                    if (24) {\n                        MEM[v17.data] = ~0xffffffffffffffff & v21;\n                    }\n                    emit evRecord(msg.sender, msg.value, v17);\n                    assert(_isInTestMode);\n                }\n            } else {\n                v22 = new array[](v23.length);\n                v24 = v23.data;\n                v25, v26 = dataCopy('onlyHarvestEnabled');\n                if (18) {\n                    MEM[v22.data] = ~0xffffffffffffffffffffffffffff & v26;\n                }\n                emit evRecord(msg.sender, msg.value, v22);\n                assert(_isInTestMode);\n            }\n        } else {\n            v27 = new array[](v28.length);\n            v29 = v28.data;\n            v30, v31 = dataCopy();\n            if (8) {\n                MEM[v27.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v31;\n            }\n            emit evRecord(msg.sender, msg.value, v27);\n            assert(_isInTestMode);\n        }\n    } else {\n        v32 = new array[](v33.length);\n        v34 = v33.data;\n        v35, v36 = dataCopy('onlyManagementBody');\n        if (18) {\n            MEM[v32.data] = ~0xffffffffffffffffffffffffffff & v36;\n        }\n        emit evRecord(msg.sender, msg.value, v32);\n        assert(_isInTestMode);\n    }\n}\n\nfunction name() public payable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v0.length;\n    v4 = v0.data;\n    v5 = dataCopy(_name.length >> 8 << 8);\n    v6 = v0.length + (64 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n        v6 = v7 = 32 + (v6 - (0x1f & v0.length));\n    }\n    return MEM[(MEM[64]) len (v6 - MEM[64])];\n}\n\nfunction weiPerInitialHONG() public payable { \n    return _weiPerInitialHONG;\n}\n\nfunction votedHarvest(address varg0) public payable { \n    return _votedHarvest[varg0];\n}\n\nfunction minTokensToCreate() public payable { \n    return _minTokensToCreate;\n}\n\nfunction supportHarvestQuorum() public payable { \n    return _supportHarvestQuorum;\n}\n\nfunction extraBalanceWallet() public payable { \n    return _extraBalanceWallet;\n}\n\nfunction totalInitialBalance() public payable { \n    return _totalInitialBalance;\n}\n\nfunction divisor() public payable { \n    v0 = 0x591();\n    return 0xff & 100 + 5 * v0;\n}\n\nfunction voteToHarvestFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                if (_currentFiscalYear >= 4) {\n                    _supportHarvestQuorum = _supportHarvestQuorum - _votedHarvest[msg.sender];\n                    _supportHarvestQuorum = _balanceOf[msg.sender] + (_supportHarvestQuorum - _votedHarvest[msg.sender]);\n                    MEM[32] = 20;\n                    _votedHarvest[msg.sender] = _balanceOf[msg.sender];\n                    if (_supportHarvestQuorum > (_bountyTokensCreated + _tokensCreated) * _harvestQuorumPercent / 100) {\n                        _isFreezeEnabled = 0x100 | ~0xff00 & _isFreezeEnabled;\n                        emit evHarvest(msg.sender, msg.value);\n                    }\n                } else {\n                    v0 = new array[](v1.length);\n                    v2 = v1.data;\n                    v3, v4 = dataCopy('currentFiscalYear<4');\n                    if (19) {\n                        MEM[v0.data] = ~0xffffffffffffffffffffffffff & v4;\n                    }\n                    emit evRecord(msg.sender, msg.value, v0);\n                    assert(_isInTestMode);\n                    goto 0x118f0x459;\n                }\n            } else {\n                v5 = new array[](v6.length);\n                v7 = v6.data;\n                v8, v9 = dataCopy();\n                if (10) {\n                    MEM[v5.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v9;\n                }\n                emit evRecord(msg.sender, msg.value, v5);\n                assert(_isInTestMode);\n                goto 0x118f0x459;\n            }\n        } else {\n            v10 = new array[](v11.length);\n            v12 = v11.data;\n            v13, v14 = dataCopy();\n            if (7) {\n                MEM[v10.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v14;\n            }\n            emit evRecord(msg.sender, msg.value, v10);\n            assert(_isInTestMode);\n            goto 0x118f0x459;\n        }\n    } else {\n        v15 = new array[](v16.length);\n        v17 = v16.data;\n        v18, v19 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v15.data] = ~0xffffffffffffffffffffffffffffffff & v19;\n        }\n        emit evRecord(msg.sender, msg.value, v15);\n        assert(_isInTestMode);\n    }\n}\n\nfunction decimals() public payable { \n    return _decimals;\n}\n\nfunction pricePerTokenAtCurrentTier() public payable { \n    v0 = 0x591();\n    return _weiPerInitialHONG * (0xff & 100 + 5 * v0) / 100;\n}\n\nfunction mgmtFeePercentage() public payable { \n    return _mgmtFeePercentage;\n}\n\nfunction tokensCreated() public payable { \n    return _tokensCreated;\n}\n\nfunction isDistributionReady() public payable { \n    return 0xff & _isFreezeEnabled >> 24;\n}\n\nfunction closingTimeExtensionPeriod() public payable { \n    return _closingTimeExtensionPeriod;\n}\n\nfunction votedKickoff(uint256 varg0, address varg1) public payable { \n    return _votedKickoff[varg1];\n}\n\nfunction closingTime() public payable { \n    return _closingTime;\n}\n\nfunction lastKickoffDateBuffer() public payable { \n    return _lastKickoffDateBuffer;\n}\n\nfunction isDayThirtyChecked() public payable { \n    return 0xff & _isFundLocked >> 16;\n}\n\nfunction isFreezeEnabled() public payable { \n    return 0xff & _isFreezeEnabled;\n}\n\nfunction collectMyReturn() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFreezeEnabled >> 24) {\n                _balanceOf[msg.sender] = 0;\n                v0 = address(_isFreezeEnabled >> 32).call(0x9f3ef43000000000000000000000000000000000000000000000000000000000, msg.sender, _balanceOf[msg.sender]).gas(msg.gas - 25050);\n                assert(v0);\n            } else {\n                v1 = new array[](v2.length);\n                v3 = v2.data;\n                v4, v5 = dataCopy('onlyDistributionReady');\n                if (21) {\n                    MEM[v1.data] = ~0xffffffffffffffffffffff & v5;\n                }\n                emit evRecord(msg.sender, msg.value, v1);\n                assert(_isInTestMode);\n                goto 0x118f0x505;\n            }\n        } else {\n            v6 = new array[](v7.length);\n            v8 = v7.data;\n            v9, v10 = dataCopy();\n            if (7) {\n                MEM[v6.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v10;\n            }\n            emit evRecord(msg.sender, msg.value, v6);\n            assert(_isInTestMode);\n            goto 0x118f0x505;\n        }\n    } else {\n        v11 = new array[](v12.length);\n        v13 = v12.data;\n        v14, v15 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v11.data] = ~0xffffffffffffffffffffffffffffffff & v15;\n        }\n        emit evRecord(msg.sender, msg.value, v11);\n        assert(_isInTestMode);\n    }\n    goto 0x2ac4;\n}\n\nfunction isMinTokensReached() public payable { \n    return _tokensCreated >= _minTokensToCreate;\n}\n\nfunction isDistributionInProgress() public payable { \n    return 0xff & _isFreezeEnabled >> 16;\n}\n\nfunction lastKickoffDate() public payable { \n    return _lastKickoffDate;\n}\n\nfunction managementFeeWallet() public payable { \n    return _managementFeeWallet;\n}\n\nfunction supportFreezeQuorum() public payable { \n    return _supportFreezeQuorum;\n}\n\nfunction balanceOf(address varg0) public payable { \n    return _balanceOf[varg0];\n}\n\nfunction tokensAvailableAtCurrentTier() public payable { \n    v0 = 0x591();\n    v1 = 0x81f(_tokensCreated, _tokensPerTier, v0);\n    return v1;\n}\n\nfunction 0x580() private { \n    v0 = 0x591();\n    v1 = 0x81f(_tokensCreated, _tokensPerTier, v0);\n    return v1;\n}\n\nfunction getCurrentTier() public payable { \n    v0 = _tokensCreated / _tokensPerTier;\n    if (v0 & 0xff > 4) {\n        v0 = v1 = 4;\n    }\n    return 0xff & v0;\n}\n\nfunction 0x591() private { \n    v0 = v1 = _tokensCreated / _tokensPerTier;\n    if (v1 & 0xff > 4) {\n        v0 = v2 = 4;\n    }\n    return v0;\n}\n\nfunction isFundLocked() public payable { \n    return 0xff & _isFundLocked;\n}\n\nfunction votedFreeze(address varg0) public payable { \n    return _votedFreeze[varg0];\n}\n\nfunction returnWallet() public payable { \n    return address(_isFreezeEnabled >> 32);\n}\n\nfunction kickoffQuorumPercent() public payable { \n    return _kickoffQuorumPercent;\n}\n\nfunction isMaxTokensReached() public payable { \n    return _tokensCreated >= _maxTokensToCreate;\n}\n\nfunction freezeQuorumPercent() public payable { \n    return _freezeQuorumPercent;\n}\n\nfunction symbol() public payable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    MEM[MEM[64]] = 32;\n    MEM[32 + MEM[64]] = v0.length;\n    v4 = v0.data;\n    v5 = dataCopy(_symbol.length >> 8 << 8);\n    v6 = v0.length + (64 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n        v6 = v7 = 32 + (v6 - (0x1f & v0.length));\n    }\n    return MEM[(MEM[64]) len (v6 - MEM[64])];\n}\n\nfunction maxTokensToCreate() public payable { \n    return _maxTokensToCreate;\n}\n\nfunction mgmtInvestProject(address varg0, uint256 varg1) public payable { \n    if (msg.sender == _managementBodyAddress) {\n        if (msg.value > 0) {\n            v0 = v1 = !(0xff & _isKickoffEnabled[_currentFiscalYear]);\n            if (0xff & _isKickoffEnabled[_currentFiscalYear]) {\n                v0 = v2 = 0xff & _isFreezeEnabled;\n            }\n            if (!v0) {\n                v0 = v3 = 0xff & _isFreezeEnabled >> 8;\n            }\n            if (!v0) {\n                if (varg1 < (address(this)).balance) {\n                    v4 = varg0.call().value(varg1).gas(msg.gas - 34050);\n                    if (v4) {\n                        emit evMgmtInvestProject(msg.sender, msg.value, varg0, varg1, 1);\n                    } else {\n                        v5 = new array[](v6.length);\n                        v7 = v6.data;\n                        v8 = v9 = v6.length + v5.data;\n                        if (23) {\n                            MEM[v9 - 23] = ~0xffffffffffffffffff & v10;\n                        }\n                        emit evRecord(msg.sender, msg.value, v5);\n                        assert(_isInTestMode);\n                        goto 0x14680x676;\n                    }\n                } else {\n                    v11 = new array[](v12.length);\n                    v13 = v12.data;\n                    v14 = v15 = v12.length + v11.data;\n                    if (17) {\n                        MEM[v15 - 17] = ~0xffffffffffffffffffffffffffffff & v16;\n                    }\n                    emit evRecord(msg.sender, msg.value, v11);\n                    assert(_isInTestMode);\n                    goto 0x14680x676;\n                }\n            } else {\n                emit evMgmtInvestProject(msg.sender, msg.value, varg0, varg1, 0);\n            }\n        } else {\n            v17 = new array[](v18.length);\n            v19 = v18.data;\n            v20, v21 = dataCopy();\n            if (8) {\n                MEM[v17.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v21;\n            }\n            emit evRecord(msg.sender, msg.value, v17);\n            assert(_isInTestMode);\n            goto 0x14680x676;\n        }\n    } else {\n        v22 = new array[](v23.length);\n        v24 = v23.data;\n        v25, v26 = dataCopy('onlyManagementBody');\n        if (18) {\n            MEM[v22.data] = ~0xffffffffffffffffffffffffffff & v26;\n        }\n        emit evRecord(msg.sender, msg.value, v22);\n        assert(_isInTestMode);\n    }\n    return 0;\n}\n\nfunction isHarvestEnabled() public payable { \n    return 0xff & _isFreezeEnabled >> 8;\n}\n\nfunction tokensPerTier() public payable { \n    return _tokensPerTier;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    v0 = v1 = 11433;\n    v2 = v3 = 0;\n    if (_currentFiscalYear < 4) {\n        if (_votedKickoff[msg.sender] <= varg1) {\n            _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender];\n            _supportKickoffQuorum[1 + _currentFiscalYear] = 0;\n        } else {\n            STORAGE[keccak256(msg.sender, keccak256(1 + _currentFiscalYear, 18))] = STORAGE[keccak256(msg.sender, keccak256(1 + _currentFiscalYear, 18))] - varg1;\n            _supportKickoffQuorum[1 + _currentFiscalYear] = _supportKickoffQuorum[1 + _currentFiscalYear] - varg1;\n        }\n    }\n    if (_votedFreeze[msg.sender] <= varg1) {\n        _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n        _votedFreeze[msg.sender] = 0;\n    } else {\n        STORAGE[keccak256(msg.sender, 19)] = STORAGE[keccak256(msg.sender, 19)] - varg1;\n        _supportFreezeQuorum = _supportFreezeQuorum - varg1;\n    }\n    if (_votedHarvest[msg.sender] <= varg1) {\n        _supportHarvestQuorum = _supportHarvestQuorum - _votedHarvest[msg.sender];\n        _votedHarvest[msg.sender] = 0;\n    } else {\n        STORAGE[keccak256(msg.sender, 20)] = STORAGE[keccak256(msg.sender, 20)] - varg1;\n        _supportHarvestQuorum = _supportHarvestQuorum - varg1;\n    }\n    v2 = v4 = 0xff & _isFundLocked;\n    if (v4) {\n        v0 = v5 = 6089;\n        v2 = v6 = 0;\n        if (msg.value <= 0) {\n            if (varg1 > 0) {\n                if (_balanceOf[msg.sender] >= varg1) {\n                    if (varg1 + _balanceOf[varg0] >= _balanceOf[varg0]) {\n                        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n                        _balanceOf[varg0] += varg1;\n                        emit evTransfer(msg.sender, varg0, msg.sender, msg.value, varg1);\n                        v2 = v7 = 1;\n                    } else {\n                        v2 = v8 = 0;\n                    }\n                } else {\n                    v2 = v9 = 0;\n                }\n            } else {\n                v2 = v10 = 0;\n            }\n        } else {\n            v11 = new array[](v12.length);\n            v13 = v12.data;\n            v14, v15 = dataCopy();\n            if (7) {\n                MEM[v11.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v15;\n            }\n            emit evRecord(msg.sender, msg.value, v11);\n            assert(_isInTestMode);\n        }\n    }\n    goto {'0x2ca9', '0x17c9'};\n    if (!v2) {\n        if (0xff & _isFundLocked) {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v16.length;\n            v17, v18, v19 = dataCopy(MEM[(v16.data) len (v16.length)], MEM[(128 + MEM[64]) len (v16.length)]);\n            v20 = v16.length + (128 + MEM[64]);\n            if (19) {\n                MEM[v20 - 19] = ~0xffffffffffffffffffffffffff & MEM[v20 - 19];\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n        } else {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v21.length;\n            v22, v18, v23 = dataCopy(MEM[(v21.data) len (v21.length)], MEM[(128 + MEM[64]) len (v21.length)]);\n            v24 = v25 = v21.length + (128 + MEM[64]);\n            if (6) {\n                MEM[v25 - 6] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & v23;\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n            goto 0x14680x6f0;\n        }\n    } else {\n        v2 = v26 = 1;\n    }\n    return v2;\n}\n\nfunction taxPaid(address varg0) public payable { \n    return _taxPaid[varg0];\n}\n\nfunction maxBountyTokens() public payable { \n    return _maxBountyTokens;\n}\n\nfunction voteToKickoffNewFiscalYear() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                MEM[0] = 1;\n                MEM[32] = 37;\n                if (stor_20a3e2dd35f58e582c5288344c035e137cace924bb9daf3762b8ef5a58327e26_0_0) {\n                    if (_currentFiscalYear > 3) {\n                        v0 = new array[](v1.length);\n                        v2 = v1.data;\n                        v3, v4 = dataCopy('kickOff:4thYear');\n                        if (15) {\n                            MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & v4;\n                        }\n                        emit evRecord(msg.sender, msg.value, v0);\n                        assert(_isInTestMode);\n                        goto 0x18b0;\n                    } else if (_lastKickoffDateBuffer + _lastKickoffDate >= block.timestamp) {\n                        v5 = new array[](v6.length);\n                        v7 = v6.data;\n                        v8, v9 = dataCopy('kickOff:tooEarly');\n                        if (16) {\n                            MEM[v5.data] = ~0xffffffffffffffffffffffffffffffff & v9;\n                        }\n                        emit evRecord(msg.sender, msg.value, v5);\n                        assert(_isInTestMode);\n                        goto 0x18b0;\n                    }\n                }\n                _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender];\n                _supportKickoffQuorum[msg.sender] = _supportKickoffQuorum[msg.sender] - _votedKickoff[msg.sender] + _balanceOf[msg.sender];\n                _votedKickoff[msg.sender] = _balanceOf[msg.sender];\n                MEM[0] = _currentFiscalYear + 1;\n                MEM[32] = 21;\n                if (_supportKickoffQuorum[msg.sender] > _kickoffQuorumPercent * (_bountyTokensCreated + _tokensCreated) / 100) {\n                    if (1 == _currentFiscalYear + 1) {\n                        v10 = _extraBalanceWallet.call(0xb1a8b25a).gas(msg.gas - 25050);\n                        assert(v10);\n                        _totalInitialBalance = (address(this)).balance;\n                        _annualManagementFee = _mgmtFeePercentage * (address(this)).balance / 100 >> 2;\n                        v11 = _managementFeeWallet.call().value(_mgmtFeePercentage * (address(this)).balance / 100);\n                        if (!v11) {\n                            v12 = new array[](v13.length);\n                            v14 = v13.data;\n                            v15 = v16 = v13.length + v12.data;\n                            if (3) {\n                                MEM[v16 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v17;\n                            }\n                            emit evRecord(msg.sender, msg.value, v12);\n                            assert(_isInTestMode);\n                            goto 0x18b0;\n                        }\n                    }\n                    _isKickoffEnabled[_currentFiscalYear + 1] = 0x1 | ~0xff & _isKickoffEnabled[_currentFiscalYear + 1];\n                    _currentFiscalYear = _currentFiscalYear + 1;\n                    _lastKickoffDate = block.timestamp;\n                    v18 = _managementFeeWallet.call(0xa8bcbf3c00000000000000000000000000000000000000000000000000000000, _annualManagementFee).gas(msg.gas - 25050);\n                    assert(v18);\n                    emit evKickoff(msg.sender, msg.value, _currentFiscalYear + 1);\n                    emit evIssueManagementFee(msg.sender, msg.value, _annualManagementFee, 1);\n                }\n            } else {\n                v19 = new array[](v20.length);\n                v21 = v20.data;\n                v22, v23 = dataCopy();\n                if (10) {\n                    MEM[v19.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v23;\n                }\n                emit evRecord(msg.sender, msg.value, v19);\n                assert(_isInTestMode);\n                goto 0x18b0;\n            }\n        } else {\n            v24 = new array[](v25.length);\n            v26 = v25.data;\n            v27, v28 = dataCopy();\n            if (7) {\n                MEM[v24.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v28;\n            }\n            emit evRecord(msg.sender, msg.value, v24);\n            assert(_isInTestMode);\n            goto 0x18b0;\n        }\n    } else {\n        v29 = new array[](v30.length);\n        v31 = v30.data;\n        v32, v33 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v29.data] = ~0xffffffffffffffffffffffffffffffff & v33;\n        }\n        emit evRecord(msg.sender, msg.value, v29);\n        assert(_isInTestMode);\n    }\n}\n\nfunction supportKickoffQuorum(uint256 varg0) public payable { \n    return _supportKickoffQuorum[varg0];\n}\n\nfunction isInTestMode() public payable { \n    return _isInTestMode;\n}\n\nfunction managementBodyAddress() public payable { \n    return _managementBodyAddress;\n}\n\nfunction harvestQuorumPercent() public payable { \n    return _harvestQuorumPercent;\n}\n\nfunction isKickoffEnabled(uint256 varg0) public payable { \n    return 0xff & _isKickoffEnabled[varg0];\n}\n\nfunction mgmtRewardPercentage() public payable { \n    return _mgmtRewardPercentage;\n}\n\nfunction recallVoteToFreezeFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (!(0xff & _isFreezeEnabled)) {\n            if (msg.value <= 0) {\n                _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n                _votedFreeze[msg.sender] = 0;\n            } else {\n                v0 = new array[](v1.length);\n                v2 = v1.data;\n                v3, v4 = dataCopy();\n                if (7) {\n                    MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v4;\n                }\n                emit evRecord(msg.sender, msg.value, v0);\n                assert(_isInTestMode);\n            }\n        } else {\n            v5 = new array[](v6.length);\n            v7 = v6.data;\n            v8, v9 = dataCopy('onlyNotFrozen');\n            if (13) {\n                MEM[v5.data] = ~0xffffffffffffffffffffffffffffffffffffff & v9;\n            }\n            emit evRecord(msg.sender, msg.value, v5);\n            assert(_isInTestMode);\n        }\n    } else {\n        v10 = new array[](v11.length);\n        v12 = v11.data;\n        v13, v14 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v10.data] = ~0xffffffffffffffffffffffffffffffff & v14;\n        }\n        emit evRecord(msg.sender, msg.value, v10);\n        assert(_isInTestMode);\n    }\n}\n\nfunction bountyTokensCreated() public payable { \n    return _bountyTokensCreated;\n}\n\nfunction annualManagementFee() public payable { \n    return _annualManagementFee;\n}\n\nfunction tokensAvailableAtTierInternal(uint8 varg0, uint256 varg1, uint256 varg2) public payable { \n    v0 = varg1 * (0xff & varg0 + 1);\n    if (v0 > _maxTokensToCreate) {\n        v0 = v1 = _maxTokensToCreate;\n    }\n    if (varg2 <= v0) {\n        v2 = v0 - varg2;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction 0x81f(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = varg1 * (0xff & varg2 + 1);\n    if (v1 > _maxTokensToCreate) {\n        v0 = _maxTokensToCreate;\n    }\n    if (varg0 <= v0) {\n        v2 = v0 - varg0;\n    } else {\n        v2 = v3 = 0;\n    }\n    return v2;\n}\n\nfunction isDaySixtyChecked() public payable { \n    return 0xff & _isFundLocked >> 24;\n}\n\nfunction voteToFreezeFund() public payable { \n    if (0 != _balanceOf[msg.sender]) {\n        if (msg.value <= 0) {\n            if (0xff & _isFundLocked) {\n                if (_currentFiscalYear < 4) {\n                    if (!(0xff & _isFreezeEnabled >> 16)) {\n                        _supportFreezeQuorum = _supportFreezeQuorum - _votedFreeze[msg.sender];\n                        _supportFreezeQuorum = _balanceOf[msg.sender] + (_supportFreezeQuorum - _votedFreeze[msg.sender]);\n                        MEM[32] = 19;\n                        _votedFreeze[msg.sender] = _balanceOf[msg.sender];\n                        if (_supportFreezeQuorum > (_bountyTokensCreated + _tokensCreated) * _freezeQuorumPercent / 100) {\n                            _isFreezeEnabled = 0x1 | ~0xff & _isFreezeEnabled;\n                            if (!(0xff & _isFreezeEnabled >> 16)) {\n                                _isFreezeEnabled = 0x1000000 | (0x10000 | _isFreezeEnabled & ~0xff0000) & ~0xff000000;\n                                v0 = address(_isFreezeEnabled >> 32).call().value((address(this)).balance);\n                                if (!v0) {\n                                    v1 = new array[](v2.length);\n                                    v3 = v2.data;\n                                    v4 = v5 = v2.length + v1.data;\n                                    if (3) {\n                                        MEM[v5 - 3] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & v6;\n                                    }\n                                    emit evRecord(msg.sender, msg.value, v1);\n                                    assert(_isInTestMode);\n                                }\n                                v7 = _managementFeeWallet.call(0xfc44fd28).gas(msg.gas - 25050);\n                                assert(v7);\n                                v8 = _rewardWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                                assert(v8);\n                                v9 = _extraBalanceWallet.wipeBlockchain_EkJWPe().gas(msg.gas - 25050);\n                                assert(v9);\n                                if (0 > 0) {\n                                    v10 = address(_isFreezeEnabled >> 32).call(0xb8b27765, 0).gas(msg.gas - 25050);\n                                    assert(v10);\n                                }\n                                v11 = address(_isFreezeEnabled >> 32).call(0x2033d9ae00000000000000000000000000000000000000000000000000000000, _bountyTokensCreated + _tokensCreated).gas(msg.gas - 25050);\n                                assert(v11);\n                                emit evMgmtDistributed(msg.sender, msg.value, (address(_isFreezeEnabled >> 32)).balance, 1);\n                                _isFreezeEnabled = 0x0 | ~0xff0000 & _isFreezeEnabled;\n                                goto 0x1efe;\n                            } else {\n                                v12 = new array[](v13.length);\n                                v14 = v13.data;\n                                v15, v16 = dataCopy('onlyDistributionNotInProgress');\n                                if (29) {\n                                    MEM[v12.data] = ~0xffffff & v16;\n                                }\n                                emit evRecord(msg.sender, msg.value, v12);\n                                assert(_isInTestMode);\n                            }\n                            emit evFreeze(msg.sender, msg.value);\n                        }\n                    } else {\n                        v17 = new array[](v18.length);\n                        v19 = v18.data;\n                        v20, v21 = dataCopy('onlyDistributionNotInProgress');\n                        if (29) {\n                            MEM[v17.data] = ~0xffffff & v21;\n                        }\n                        emit evRecord(msg.sender, msg.value, v17);\n                        assert(_isInTestMode);\n                        goto 0x118f0x85f;\n                    }\n                } else {\n                    v22 = new array[](v23.length);\n                    v24 = v23.data;\n                    v25, v26 = dataCopy('currentFiscalYear>=4');\n                    if (20) {\n                        MEM[v22.data] = ~0xffffffffffffffffffffffff & v26;\n                    }\n                    emit evRecord(msg.sender, msg.value, v22);\n                    assert(_isInTestMode);\n                    goto 0x118f0x85f;\n                }\n            } else {\n                v27 = new array[](v28.length);\n                v29 = v28.data;\n                v30, v31 = dataCopy();\n                if (10) {\n                    MEM[v27.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v31;\n                }\n                emit evRecord(msg.sender, msg.value, v27);\n                assert(_isInTestMode);\n                goto 0x118f0x85f;\n            }\n        } else {\n            v32 = new array[](v33.length);\n            v34 = v33.data;\n            v35, v36 = dataCopy();\n            if (7) {\n                MEM[v32.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v36;\n            }\n            emit evRecord(msg.sender, msg.value, v32);\n            assert(_isInTestMode);\n            goto 0x118f0x85f;\n        }\n    } else {\n        v37 = new array[](v38.length);\n        v39 = v38.data;\n        v40, v41 = dataCopy('onlyTokenHolders');\n        if (16) {\n            MEM[v37.data] = ~0xffffffffffffffffffffffffffffffff & v41;\n        }\n        emit evRecord(msg.sender, msg.value, v37);\n        assert(_isInTestMode);\n    }\n}\n\nfunction refundMyIcoInvestment() public payable { \n    if (msg.value <= 0) {\n        if (!(0xff & _isFundLocked)) {\n            if (0 != _balanceOf[msg.sender]) {\n                if (owner_1c[msg.sender] != 0) {\n                    if (_balanceOf[msg.sender] <= _tokensCreated) {\n                        _balanceOf[msg.sender] = 0;\n                        owner_1c[msg.sender] = 0;\n                        MEM[32] = 29;\n                        owner_1c[msg.sender] = 0;\n                        _tokensCreated = _tokensCreated - _balanceOf[msg.sender];\n                        v0 = _extraBalanceWallet.call(0x51fa7efd00000000000000000000000000000000000000000000000000000000, owner_1c[msg.sender]).gas(msg.gas - 25050);\n                        assert(v0);\n                        v1 = msg.sender.call().value(owner_1c[msg.sender]);\n                        if (v1) {\n                            emit evRefund(msg.sender, msg.sender, msg.value, owner_1c[msg.sender], 1);\n                            v2 = v3 = _tokensCreated < _minTokensToCreate;\n                            if (v3) {\n                                v2 = _tokensCreated >= _minTokensToCreate;\n                            }\n                            if (v2) {\n                                emit evMinTokensReached(msg.sender, msg.value, _tokensCreated);\n                            }\n                        } else {\n                            MEM[64 + MEM[64]] = owner_1c[msg.sender];\n                            emit evRefund(msg.sender, msg.sender, msg.value, owner_1c[msg.sender], 0);\n                            v4 = new array[](v5.length);\n                            v6 = v5.data;\n                            v7, v8 = dataCopy('refund:SendFailed');\n                            if (17) {\n                                MEM[v4.data] = ~0xffffffffffffffffffffffffffffff & v8;\n                            }\n                            emit evRecord(msg.sender, msg.value, v4);\n                            assert(_isInTestMode);\n                            goto 0x1f7b;\n                        }\n                    } else {\n                        v9 = new array[](v10.length);\n                        v11 = v10.data;\n                        v12, v13 = dataCopy('invalidTokenCount');\n                        if (17) {\n                            MEM[v9.data] = ~0xffffffffffffffffffffffffffffff & v13;\n                        }\n                        emit evRecord(msg.sender, msg.value, v9);\n                        assert(_isInTestMode);\n                        goto 0x1f7b;\n                    }\n                } else {\n                    v14 = new array[](v15.length);\n                    v16 = v15.data;\n                    v17, v18 = dataCopy('noWeiGiven');\n                    if (10) {\n                        MEM[v14.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & v18;\n                    }\n                    emit evRecord(msg.sender, msg.value, v14);\n                    assert(_isInTestMode);\n                    goto 0x1f7b;\n                }\n            } else {\n                v19 = new array[](v20.length);\n                v21 = v20.data;\n                v22, v23 = dataCopy('onlyTokenHolders');\n                if (16) {\n                    MEM[v19.data] = ~0xffffffffffffffffffffffffffffffff & v23;\n                }\n                emit evRecord(msg.sender, msg.value, v19);\n                assert(_isInTestMode);\n                goto 0x1f7b;\n            }\n        } else {\n            v24 = new array[](v25.length);\n            v26 = v25.data;\n            v27, v28 = dataCopy();\n            if (9) {\n                MEM[v24.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & v28;\n            }\n            emit evRecord(msg.sender, msg.value, v24);\n            assert(_isInTestMode);\n            goto 0x1f7b;\n        }\n    } else {\n        v29 = new array[](v30.length);\n        v31 = v30.data;\n        v32, v33 = dataCopy();\n        if (7) {\n            MEM[v29.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v33;\n        }\n        emit evRecord(msg.sender, msg.value, v29);\n        assert(_isInTestMode);\n    }\n}\n\nfunction rewardWallet() public payable { \n    return _rewardWallet;\n}\n\nfunction mgmtIssueBountyToken(address varg0, uint256 varg1) public payable { \n    if (msg.value <= 0) {\n        if (msg.sender == _managementBodyAddress) {\n            if (varg1 + _bountyTokensCreated <= _maxBountyTokens) {\n                _balanceOf[varg0] += varg1;\n                _bountyTokensCreated += varg1;\n                emit evMgmtIssueBountyToken(msg.sender, msg.value, varg0, varg1, 1);\n            } else {\n                v0 = new array[](v1.length);\n                v2 = v1.data;\n                v3, v4 = dataCopy('hitMaxBounty');\n                if (12) {\n                    MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffff & v4;\n                }\n                emit evRecord(msg.sender, msg.value, v0);\n                assert(_isInTestMode);\n            }\n        } else {\n            v5 = new array[](v6.length);\n            v7 = v6.data;\n            v8, v9 = dataCopy('onlyManagementBody');\n            if (18) {\n                MEM[v5.data] = ~0xffffffffffffffffffffffffffff & v9;\n            }\n            emit evRecord(msg.sender, msg.value, v5);\n            assert(_isInTestMode);\n            goto 0x14680x8bf;\n        }\n    } else {\n        v10 = new array[](v11.length);\n        v12 = v11.data;\n        v13, v14 = dataCopy();\n        if (7) {\n            MEM[v10.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & v14;\n        }\n        emit evRecord(msg.sender, msg.value, v10);\n        assert(_isInTestMode);\n    }\n    goto 0x2df9;\n    return 0;\n}\n\nfunction currentFiscalYear() public payable { \n    return _currentFiscalYear;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = function_selector >> 224;\n        if (v0 == 0x2410cf6) {\n            isFundReleased();\n        } else if (0x44a5f97 == v0) {\n            mgmtDistribute();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x89aa819 == v0) {\n            weiPerInitialHONG();\n        } else if (0xc103837 == v0) {\n            votedHarvest(address);\n        } else if (0xc3b7b96 == v0) {\n            minTokensToCreate();\n        } else if (0xd40e8d6 == v0) {\n            supportHarvestQuorum();\n        } else if (0x14841164 == v0) {\n            extraBalanceWallet();\n        } else if (0x1d107603 == v0) {\n            totalInitialBalance();\n        } else if (0x1f2dc5ef == v0) {\n            divisor();\n        } else if (0x21d3523c == v0) {\n            voteToHarvestFund();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x342d9185 == v0) {\n            pricePerTokenAtCurrentTier();\n        } else if (0x35d37dbb == v0) {\n            mgmtFeePercentage();\n        } else if (0x42750020 == v0) {\n            tokensCreated();\n        } else if (0x44440a59 == v0) {\n            isDistributionReady();\n        } else if (0x4845d3f8 == v0) {\n            closingTimeExtensionPeriod();\n        } else if (0x490fc399 == v0) {\n            votedKickoff(uint256,address);\n        } else if (0x4b6753bc == v0) {\n            closingTime();\n        } else if (0x53bc147e == v0) {\n            lastKickoffDateBuffer();\n        } else if (0x5474fbd3 == v0) {\n            isDayThirtyChecked();\n        } else if (0x558305f9 == v0) {\n            isFreezeEnabled();\n        } else if (0x56a3f4ef == v0) {\n            collectMyReturn();\n        } else if (0x5b6aa3c2 == v0) {\n            isMinTokensReached();\n        } else if (0x60d3e4c5 == v0) {\n            isDistributionInProgress();\n        } else if (0x67cf91c9 == v0) {\n            lastKickoffDate();\n        } else if (0x6b9c1d22 == v0) {\n            managementFeeWallet();\n        } else if (0x70606cda == v0) {\n            supportFreezeQuorum();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x73f5f8ee == v0) {\n            tokensAvailableAtCurrentTier();\n        } else if (0x7412c223 == v0) {\n            getCurrentTier();\n        } else if (0x7895f853 == v0) {\n            isFundLocked();\n        } else if (0x7c2b8d0a == v0) {\n            votedFreeze(address);\n        } else if (0x7e4a1731 == v0) {\n            returnWallet();\n        } else if (0x81dd70db == v0) {\n            kickoffQuorumPercent();\n        } else if (0x8c32e774 == v0) {\n            isMaxTokensReached();\n        } else if (0x9496df3f == v0) {\n            freezeQuorumPercent();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x9bd90aae == v0) {\n            maxTokensToCreate();\n        } else if (0x9cb74ab6 == v0) {\n            mgmtInvestProject(address,uint256);\n        } else if (0x9e47214a == v0) {\n            isHarvestEnabled();\n        } else if (0xa8d5652e == v0) {\n            tokensPerTier();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xa988e371 == v0) {\n            taxPaid(address);\n        } else if (0xab71b8ac == v0) {\n            maxBountyTokens();\n        } else if (0xadbda5a8 == v0) {\n            voteToKickoffNewFiscalYear();\n        } else if (0xaea3ad8c == v0) {\n            supportKickoffQuorum(uint256);\n        } else if (0xb656e9f4 == v0) {\n            isInTestMode();\n        } else if (0xba0bface == v0) {\n            managementBodyAddress();\n        } else if (0xbf53e3ba == v0) {\n            harvestQuorumPercent();\n        } else if (0xc86a9dea == v0) {\n            isKickoffEnabled(uint256);\n        } else if (0xcdd8d4e8 == v0) {\n            mgmtRewardPercentage();\n        } else if (0xcfebb88b == v0) {\n            recallVoteToFreezeFund();\n        } else if (0xda228f9c == v0) {\n            bountyTokensCreated();\n        } else if (0xdc7049bf == v0) {\n            annualManagementFee();\n        } else if (0xdf234815 == v0) {\n            tokensAvailableAtTierInternal(uint8,uint256,uint256);\n        } else if (0xe0e32504 == v0) {\n            isDaySixtyChecked();\n        } else if (0xe2649caf == v0) {\n            voteToFreezeFund();\n        } else if (0xe84f7054 == v0) {\n            refundMyIcoInvestment();\n        } else if (0xfb75b2c7 == v0) {\n            rewardWallet();\n        } else if (0xfea5d7b1 == v0) {\n            mgmtIssueBountyToken(address,uint256);\n        } else if (0xffa309e4 == v0) {\n            currentFiscalYear();\n        }\n    }\n    v1 = v2 = 10482;\n    v1 = v3 = 2330;\n    v4 = v5 = _extraBalanceWallet == msg.sender;\n    if (_extraBalanceWallet != msg.sender) {\n        v4 = v6 = msg.sender == address(_isFreezeEnabled >> 32);\n    }\n    if (!v4) {\n        v4 = v7 = msg.sender == _rewardWallet;\n    }\n    if (!v4) {\n        v4 = v8 = msg.sender == _managementFeeWallet;\n    }\n    if (v4) {\n        emit evRecord(msg.sender, msg.value, 'Recevied ether from ManagedAccount');\n        v4 = v9 = 1;\n        goto 0x28f2;\n    } else {\n        v4 = v10 = 0;\n        if (!(0xff & _isFundLocked)) {\n            if (!(0xff & _isFundLocked >> 8)) {\n                if (msg.value > 0) {\n                    v11 = v12 = 0;\n                    v13 = v14 = 0;\n                    v15 = 0x591();\n                    v16 = v17 = _weiPerInitialHONG * (0xff & 100 + 5 * v15) / 100;\n                    v18 = v19 = msg.value;\n                    v20 = v21 = 0x580();\n                    if (0 != v21) {\n                        while (v18 >= v16) {\n                            v20 = v18 / v16;\n                            if (v20 >= v20) {\n                            }\n                            v22 = v23 = 0 == v20;\n                            if (v23) {\n                                v22 = v24 = _maxTokensToCreate == _tokensCreated;\n                            }\n                            _balanceOf[msg.sender] += v20;\n                            _tokensCreated += v20;\n                            _balanceOf[msg.sender] += v20 * v16;\n                            v11 += v20;\n                            v13 += v20 * v16;\n                            v25 = 0x591();\n                            v16 = v26 = _weiPerInitialHONG * (0xff & 100 + 5 * v25) / 100;\n                            v18 = msg.value - v13;\n                            v20 = v27 = 0x580();\n                        }\n                        owner_1c[msg.sender] += v18;\n                        owner_1c[msg.sender] += v13 - v11 * _weiPerInitialHONG;\n                        if (!(0xff & _isFundLocked >> 8)) {\n                            _isFundLocked = (_tokensCreated >= _maxTokensToCreate) | ~0xff & _isFundLocked;\n                            v28 = v29 = !(0xff & ((_tokensCreated >= _maxTokensToCreate) | ~0xff & _isFundLocked));\n                            if (v29) {\n                                v28 = v30 = !(0xff & _isFundLocked >> 16);\n                            }\n                            if (v28) {\n                                v28 = v31 = block.timestamp >= _closingTime;\n                            }\n                            if (v28) {\n                                if (_tokensCreated >= _minTokensToCreate) {\n                                    _isFundLocked = 0x1 | ~0xff & _isFundLocked;\n                                }\n                                _isFundLocked = 0x10000 | ~0xff0000 & _isFundLocked;\n                            }\n                            v32 = v33 = !(0xff & _isFundLocked);\n                            if (v33) {\n                                v32 = v34 = !(0xff & _isFundLocked >> 24);\n                            }\n                            if (v32) {\n                                v32 = v35 = block.timestamp >= _closingTime + _closingTimeExtensionPeriod;\n                            }\n                            if (v32) {\n                                if (_tokensCreated >= _minTokensToCreate) {\n                                    _isFundLocked = 0x1 | ~0xff & _isFundLocked;\n                                }\n                                _isFundLocked = 0x1000000 | ~0xff000000 & _isFundLocked;\n                            }\n                            v36 = v37 = 0xff & _isFundLocked >> 24;\n                            if (v37) {\n                                v36 = v38 = _tokensCreated < _minTokensToCreate;\n                            }\n                            if (v36) {\n                                _isFundLocked = 0x100 | ~0xff00 & _isFundLocked;\n                            }\n                        }\n                        if (v13 - v11 * _weiPerInitialHONG > 0) {\n                            v39 = _extraBalanceWallet.call().value(v13 - v11 * _weiPerInitialHONG);\n                            if (!v39) {\n                                MEM[MEM[64]] = msg.sender;\n                                MEM[32 + MEM[64]] = msg.value;\n                                MEM[64 + MEM[64]] = 96;\n                                MEM[96 + MEM[64]] = v40.length;\n                                v41 = v40.data;\n                                v42, v43 = dataCopy('extraBalance:sendFail');\n                                v44 = v45 = v40.length + (128 + MEM[64]);\n                                if (21) {\n                                    MEM[v45 - 21] = ~0xffffffffffffffffffffff & v43;\n                                }\n                                emit evRecord();\n                                assert(_isInTestMode);\n                            }\n                        }\n                        emit evCreatedToken(msg.sender, msg.sender, msg.value, v11);\n                        v46 = v47 = _tokensCreated < _minTokensToCreate;\n                        if (v47) {\n                            v46 = _tokensCreated >= _minTokensToCreate;\n                        }\n                        if (v46) {\n                            emit evMinTokensReached(msg.sender, msg.value, _tokensCreated);\n                        }\n                        if (0xff & _isFundLocked) {\n                            emit evLockFund(msg.sender, msg.value);\n                        }\n                        if (0xff & _isFundLocked >> 8) {\n                            emit evReleaseFund(msg.sender, msg.value);\n                        }\n                        v4 = v48 = 1;\n                    } else {\n                        MEM[MEM[64]] = msg.sender;\n                        MEM[32 + MEM[64]] = msg.value;\n                        MEM[64 + MEM[64]] = 96;\n                        MEM[96 + MEM[64]] = v49.length;\n                        v50 = v49.data;\n                        v51, v52 = dataCopy('noTokensToSell');\n                        v53 = v54 = v49.length + (128 + MEM[64]);\n                        if (14) {\n                            MEM[v54 - 14] = ~0xffffffffffffffffffffffffffffffffffff & v52;\n                        }\n                        emit evRecord();\n                        assert(_isInTestMode);\n                        v4 = v55 = 0;\n                    }\n                } else {\n                    MEM[MEM[64]] = msg.sender;\n                    MEM[32 + MEM[64]] = msg.value;\n                    MEM[64 + MEM[64]] = 96;\n                    MEM[96 + MEM[64]] = v56.length;\n                    v57 = v56.data;\n                    v58, v59 = dataCopy();\n                    v60 = v61 = v56.length + (128 + MEM[64]);\n                    if (8) {\n                        MEM[v61 - 8] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & v59;\n                    }\n                    emit evRecord();\n                    assert(_isInTestMode);\n                }\n            } else {\n                MEM[MEM[64]] = msg.sender;\n                MEM[32 + MEM[64]] = msg.value;\n                MEM[64 + MEM[64]] = 96;\n                MEM[96 + MEM[64]] = v62.length;\n                v63 = v62.data;\n                v64, v65 = dataCopy('notReleased');\n                v66 = v67 = v62.length + (128 + MEM[64]);\n                if (11) {\n                    MEM[v67 - 11] = ~0xffffffffffffffffffffffffffffffffffffffffff & v65;\n                }\n                emit evRecord();\n                assert(_isInTestMode);\n            }\n        } else {\n            MEM[MEM[64]] = msg.sender;\n            MEM[32 + MEM[64]] = msg.value;\n            MEM[64 + MEM[64]] = 96;\n            MEM[96 + MEM[64]] = v68.length;\n            v69 = v68.data;\n            v70, v71 = dataCopy();\n            v72 = v73 = v68.length + (128 + MEM[64]);\n            if (9) {\n                MEM[v73 - 9] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & v71;\n            }\n            emit evRecord();\n            assert(_isInTestMode);\n        }\n    }\n    goto {'0x91a', '0x28f2'};\n    return v4;\n}\n.",
	"status": "1",
	"time_cost": 68.65145611763,
	"usage": {
		"completion_tokens": 780,
		"prompt_tokens": 14140,
		"total_tokens": 14920
	}
}