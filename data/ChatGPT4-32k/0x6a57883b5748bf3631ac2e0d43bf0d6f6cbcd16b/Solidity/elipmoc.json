{
	"address": "0x6a57883b5748bf3631ac2e0d43bf0d6f6cbcd16b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity smart contract that is inferred from the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract MyContract {\n    uint256 private _ethPrice; \n    uint256 private _bonus; \n    uint256 private _amountRaised; \n    address private _changeEthPrice; \n    address private _coldWallet; \n    IERC20 private _tokenReward; \n\n    constructor(address tokenReward, address coldWallet, address changeEthPrice) public {\n        _tokenReward = IERC20(tokenReward);\n        _coldWallet = coldWallet;\n        _changeEthPrice = changeEthPrice;\n    }\n\n    function withdrawTokens(uint256 amount) public { \n        require(_changeEthPrice == msg.sender);\n        require(_tokenReward.balanceOf(address(this)) >= amount);\n        bool success = _tokenReward.transfer(_coldWallet, amount);\n        require(success);\n    }\n\n    function beneficiary() public view returns (address) { \n        return _changeEthPrice;\n    }\n\n    function changeEthPrice(uint256 newPrice) public { \n        require(_changeEthPrice == msg.sender);\n        _ethPrice = newPrice;\n    }\n\n    function coldWallet() public view returns (address) { \n        return _coldWallet;\n    }\n\n    function tokenReward() public view returns (address) { \n        return address(_tokenReward);\n    }\n\n    function bonus() public view returns (uint256) { \n        return _bonus;\n    }\n\n    function amountRaised() public view returns (uint256) { \n        return _amountRaised;\n    }\n\n    function transferTokens(address recipient, uint256 amount) public { \n        require(_changeEthPrice == msg.sender);\n        require(_tokenReward.balanceOf(address(this)) >= amount);\n        bool success = _tokenReward.transfer(recipient, amount);\n        require(success);\n    }\n\n    function withdrawETH(uint256 amount) public { \n        require(_changeEthPrice == msg.sender);\n        payable(_coldWallet).transfer(amount);\n    }\n\n    function price() public pure returns (uint256) { \n        return 50;\n    }\n\n    function changeBonus(uint256 newBonus) public { \n        require(_changeEthPrice == msg.sender);\n        _bonus = newBonus;\n    }\n\n    function minSaleAmount() public pure returns (uint256) { \n        return 10000;\n    }\n\n    function ethPrice() public view returns (uint256) { \n        return _ethPrice;\n    }\n\n    receive() external payable {\n        _amountRaised += msg.value;\n        uint256 tokens = msg.value * _ethPrice / 50 * (100 + _bonus) / 100;\n        bool success = _tokenReward.transfer(msg.sender, tokens);\n        require(success);\n    }\n}\n```\n\nPlease note that there are assumptions made in the conversion. The tokenReward has been assumed to be an ERC20 token and also the contract lacks the function selector logic seen in the decompiled code, as it is not commonly used in Solidity.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457364,
	"id": "chatcmpl-8R34eFBKKdTupjY9iFtofJpMapW9n",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 18:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _ethPrice; // STORAGE[0x2]\nuint256 _bonus; // STORAGE[0x3]\nuint256 _amountRaised; // STORAGE[0x4]\naddress _changeEthPrice; // STORAGE[0x0] bytes 0 to 19\naddress _coldWallet; // STORAGE[0x1] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n\nfunction WithdrawTokens(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(_coldWallet, varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction beneficiary() public nonPayable { \n    return _changeEthPrice;\n}\n\nfunction ChangeEthPrice(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    _ethPrice = varg0;\n}\n\nfunction coldWallet() public nonPayable { \n    return _coldWallet;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction TransferTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction WithdrawETH(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    v0 = _coldWallet.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction price() public nonPayable { \n    return 50;\n}\n\nfunction ChangeBonus(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    _bonus = varg0;\n}\n\nfunction minSaleAmount() public nonPayable { \n    return 10000;\n}\n\nfunction ethPrice() public nonPayable { \n    return _ethPrice;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (uint32(function_selector >> 224) == 0x162bc80c) {\n            WithdrawTokens(uint256);\n        } else if (0x38af3eed == uint32(function_selector >> 224)) {\n            beneficiary();\n        } else if (0x38b59359 == uint32(function_selector >> 224)) {\n            ChangeEthPrice(uint256);\n        } else if (0x6be13c92 == uint32(function_selector >> 224)) {\n            coldWallet();\n        } else if (0x6e66f6e9 == uint32(function_selector >> 224)) {\n            tokenReward();\n        } else if (0x75b4d78c == uint32(function_selector >> 224)) {\n            bonus();\n        } else if (0x7b3e5e7b == uint32(function_selector >> 224)) {\n            amountRaised();\n        } else if (0x7cbfb8a5 == uint32(function_selector >> 224)) {\n            TransferTokens(address,uint256);\n        } else if (0x94effa14 == uint32(function_selector >> 224)) {\n            WithdrawETH(uint256);\n        } else if (0xa035b1fe == uint32(function_selector >> 224)) {\n            price();\n        } else if (0xa1837d21 == uint32(function_selector >> 224)) {\n            ChangeBonus(uint256);\n        } else if (0xfd085b41 == uint32(function_selector >> 224)) {\n            minSaleAmount();\n        } else if (0xff186b2e == uint32(function_selector >> 224)) {\n            ethPrice();\n        }\n    }\n    assert(0xe8d4a51000);\n    require(msg.value * _ethPrice / 50 / 0xe8d4a51000 >= 10000);\n    _amountRaised += msg.value;\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(msg.sender, msg.value * _ethPrice / 50 / 0xe8d4a51000 * (100 + _bonus) / 100).gas(msg.gas - 710);\n    require(v0);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 18:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _ethPrice; // STORAGE[0x2]\nuint256 _bonus; // STORAGE[0x3]\nuint256 _amountRaised; // STORAGE[0x4]\naddress _changeEthPrice; // STORAGE[0x0] bytes 0 to 19\naddress _coldWallet; // STORAGE[0x1] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n\nfunction WithdrawTokens(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(_coldWallet, varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction beneficiary() public nonPayable { \n    return _changeEthPrice;\n}\n\nfunction ChangeEthPrice(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    _ethPrice = varg0;\n}\n\nfunction coldWallet() public nonPayable { \n    return _coldWallet;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction TransferTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction WithdrawETH(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    v0 = _coldWallet.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction price() public nonPayable { \n    return 50;\n}\n\nfunction ChangeBonus(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    _bonus = varg0;\n}\n\nfunction minSaleAmount() public nonPayable { \n    return 10000;\n}\n\nfunction ethPrice() public nonPayable { \n    return _ethPrice;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (uint32(function_selector >> 224) == 0x162bc80c) {\n            WithdrawTokens(uint256);\n        } else if (0x38af3eed == uint32(function_selector >> 224)) {\n            beneficiary();\n        } else if (0x38b59359 == uint32(function_selector >> 224)) {\n            ChangeEthPrice(uint256);\n        } else if (0x6be13c92 == uint32(function_selector >> 224)) {\n            coldWallet();\n        } else if (0x6e66f6e9 == uint32(function_selector >> 224)) {\n            tokenReward();\n        } else if (0x75b4d78c == uint32(function_selector >> 224)) {\n            bonus();\n        } else if (0x7b3e5e7b == uint32(function_selector >> 224)) {\n            amountRaised();\n        } else if (0x7cbfb8a5 == uint32(function_selector >> 224)) {\n            TransferTokens(address,uint256);\n        } else if (0x94effa14 == uint32(function_selector >> 224)) {\n            WithdrawETH(uint256);\n        } else if (0xa035b1fe == uint32(function_selector >> 224)) {\n            price();\n        } else if (0xa1837d21 == uint32(function_selector >> 224)) {\n            ChangeBonus(uint256);\n        } else if (0xfd085b41 == uint32(function_selector >> 224)) {\n            minSaleAmount();\n        } else if (0xff186b2e == uint32(function_selector >> 224)) {\n            ethPrice();\n        }\n    }\n    assert(0xe8d4a51000);\n    require(msg.value * _ethPrice / 50 / 0xe8d4a51000 >= 10000);\n    _amountRaised += msg.value;\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(msg.sender, msg.value * _ethPrice / 50 / 0xe8d4a51000 * (100 + _bonus) / 100).gas(msg.gas - 710);\n    require(v0);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 18:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _ethPrice; // STORAGE[0x2]\nuint256 _bonus; // STORAGE[0x3]\nuint256 _amountRaised; // STORAGE[0x4]\naddress _changeEthPrice; // STORAGE[0x0] bytes 0 to 19\naddress _coldWallet; // STORAGE[0x1] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n\nfunction WithdrawTokens(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(_coldWallet, varg0).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction beneficiary() public nonPayable { \n    return _changeEthPrice;\n}\n\nfunction ChangeEthPrice(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    _ethPrice = varg0;\n}\n\nfunction coldWallet() public nonPayable { \n    return _coldWallet;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction TransferTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v0);\n}\n\nfunction WithdrawETH(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    v0 = _coldWallet.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction price() public nonPayable { \n    return 50;\n}\n\nfunction ChangeBonus(uint256 varg0) public nonPayable { \n    require(_changeEthPrice == msg.sender);\n    _bonus = varg0;\n}\n\nfunction minSaleAmount() public nonPayable { \n    return 10000;\n}\n\nfunction ethPrice() public nonPayable { \n    return _ethPrice;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (uint32(function_selector >> 224) == 0x162bc80c) {\n            WithdrawTokens(uint256);\n        } else if (0x38af3eed == uint32(function_selector >> 224)) {\n            beneficiary();\n        } else if (0x38b59359 == uint32(function_selector >> 224)) {\n            ChangeEthPrice(uint256);\n        } else if (0x6be13c92 == uint32(function_selector >> 224)) {\n            coldWallet();\n        } else if (0x6e66f6e9 == uint32(function_selector >> 224)) {\n            tokenReward();\n        } else if (0x75b4d78c == uint32(function_selector >> 224)) {\n            bonus();\n        } else if (0x7b3e5e7b == uint32(function_selector >> 224)) {\n            amountRaised();\n        } else if (0x7cbfb8a5 == uint32(function_selector >> 224)) {\n            TransferTokens(address,uint256);\n        } else if (0x94effa14 == uint32(function_selector >> 224)) {\n            WithdrawETH(uint256);\n        } else if (0xa035b1fe == uint32(function_selector >> 224)) {\n            price();\n        } else if (0xa1837d21 == uint32(function_selector >> 224)) {\n            ChangeBonus(uint256);\n        } else if (0xfd085b41 == uint32(function_selector >> 224)) {\n            minSaleAmount();\n        } else if (0xff186b2e == uint32(function_selector >> 224)) {\n            ethPrice();\n        }\n    }\n    assert(0xe8d4a51000);\n    require(msg.value * _ethPrice / 50 / 0xe8d4a51000 >= 10000);\n    _amountRaised += msg.value;\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.transfer(msg.sender, msg.value * _ethPrice / 50 / 0xe8d4a51000 * (100 + _bonus) / 100).gas(msg.gas - 710);\n    require(v0);\n}\n.",
	"status": "1",
	"time_cost": 28.38724184036255,
	"usage": {
		"completion_tokens": 659,
		"prompt_tokens": 1139,
		"total_tokens": 1798
	}
}