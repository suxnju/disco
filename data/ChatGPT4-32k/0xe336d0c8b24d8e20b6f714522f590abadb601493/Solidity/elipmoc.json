{
	"address": "0xe336d0c8b24d8e20b6f714522f590abadb601493",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the contract code based on the provided decompiled code:\n\n```solidity\npragma solidity 0.8.0;\n\ncontract Fomo3D {\n    uint256 public _activated_;\n    uint256 public _airDropPot_;\n    uint256 public _airDropTracker_;\n    uint256 public _rID_;\n    uint256 public _getTimeLeft;\n    uint256 public _ourTEAM;\n    uint256 private stor_0_0_0;\n    uint256 private stor_1;\n    uint256 private stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1;\n    uint256 private stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3;\n    address public _setOtherFomo;\n    mapping (uint256 => uint256[]) public _pIDxAddr_;\n    mapping (uint256 => uint256[]) public _pIDxName_;\n    mapping (uint256 => uint256[]) public _plyr_;\n    mapping (uint256 => uint256[]) public _plyrRnds_;\n    mapping (uint256 => uint256) public _plyrNames_;\n    mapping (uint256 => uint256[]) public _round_;\n    mapping (uint256 => uint256[]) public _rndTmEth_;\n    mapping (uint256 => uint256[]) public _fees_;\n    mapping (uint256 => uint256[]) public _potSplit_;\n    mapping (uint256 => uint256[]) public _myFounder_;\n    mapping (uint256 => uint256) public _myFounder_PID;\n\n    event onBuyAndDistribute(address indexed playerAddress, bytes32 playerName, uint256 ethereumSpent, \n        uint256 timeStamp, uint256 roundID, address winnerAddr, bytes32 winnerName, \n        uint256 amountWon, uint256 newPot, uint256 genAmount, uint256 potAmount);\n\n    event onWithdraw(uint256 roundID, address indexed playerAddress, bytes32 playerName, uint256 ethereumWithdrawn, uint256 timeStamp);\n\n    event onNewName(uint256 playerID, address indexed playerAddress, bytes32 playerName, bool isNewName, \n        uint256 affiliateID, address indexed affiliateAddress, bytes32 affiliateName, \n        uint256 amountPaid, uint256 timeStamp);\n\n    event onPotSwapDeposit(uint256 roundID, uint256 amountAdded);\n\n    event onReLoadAndDistribute(address indexed playerAddress, bytes32 playerName, uint256 ethereumReinvested, \n        uint256 timeStamp, address winnerAddr, bytes32 winnerName, uint256 amountWon, \n        uint256 newPot, uint256 genAmount, uint256 potAmount);\n\n    event onAffiliatePayout(uint256 affiliateID, address indexed affiliateAddress, bytes32 affiliateName, \n        uint256 amountPaid, uint256 timeStamp, uint256 roundID);\n\n    event onEndTx(uint256 roundID, uint256 roundEnded, bytes32 playerName, address winnerAddr, \n        uint256 amountWon, uint256 newPot, address playerAddress, bytes32 playerName, \n        uint256 ethereumIn, uint256 keysBought, uint256 timeStamp, \n        uint256 genAmount, uint256 potAmount, uint256 airDropPot);\n\n    // Other functions and mappings here\n    // ...\n}\n```\n\nPlease note, the actual contract would have additional code within the functions, this code provides only the overall contract structure. The decompiled code does not provide enough information to fully recreate the original Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040674,
	"id": "chatcmpl-8CiEkStR3at64Kt67iFXYrmf0i0dM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.03 01:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_1; // STORAGE[0x1]\nuint256 _getTimeLeft; // STORAGE[0x2]\nuint256 _airDropPot_; // STORAGE[0x3]\nuint256 _airDropTracker_; // STORAGE[0x4]\nuint256 _rID_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyr_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _myFounder_; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _myFounder_PID; // STORAGE[0x11]\nuint256 _setOtherFomo; // STORAGE[0x0] bytes 0 to 19\nuint256 _activated_; // STORAGE[0x12] bytes 0 to 0\nuint256 _ourTEAM; // STORAGE[0xf] bytes 0 to 19\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1]\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3]\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonPotSwapDeposit(uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonAffiliatePayout(uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256, uint256);\n\nfunction () public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = _pIDxAddr_[_pIDxAddr_[msg.sender]][6];\n    0xd6d();\n}\n\nfunction 0x339a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg1 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        varg1 = v2 = 13261;\n        v3 = new struct(9);\n        v3.word0 = 0;\n        v3.word1 = 0;\n        v3.word2 = 0;\n        v3.word3 = 0;\n        v3.word4 = 0;\n        v3.word5 = 0;\n        v3.word6 = 0;\n        v3.word7 = 0;\n        v3.word8 = 0;\n        if (_plyr_[varg4][5]) {\n            v4, varg1 = v5, varg1 = v6 = 0x5163(_plyr_[varg4][5]);\n        }\n        _plyr_[varg1][5] = _rID_;\n        MEM[v7] += 10;\n    }\n    v8 = v9 = 0x56bc75e2d63100000 > _round_[varg1][6];\n    if (v9) {\n        v10 = _SafeAdd(varg1, _plyrRnds_[varg1]);\n        v8 = v11 = v10 > 0xde0b6b3a7640000;\n    }\n    if (v8) {\n        varg1 = v12 = _SafeSub(_plyrRnds_[varg1], 0xde0b6b3a7640000);\n        varg1 = v13 = _SafeSub(v12, varg1);\n        v14 = _SafeAdd(v13, _plyr_[varg1][3]);\n        _plyr_[varg1][3] = v14;\n    }\n    if (varg1 > 0x3b9aca00) {\n        varg1 = v15 = 13535;\n        v16 = v17, v18 = v19, v20, v21, v22, varg1 = v23, varg1 = v24 = 0x4ad2(varg1);\n        if (v17 >= 0xde0b6b3a7640000) {\n            v18 = v25, v16 = v26, v27 = 0x4c37(varg1, v17, 13562, v19, v17, v21, v22, v23, v24, v15, varg1);\n            if (varg1 != _round_[varg1]) {\n                _round_[varg1] = varg1;\n            }\n            if (varg1 != _round_[varg1][1]) {\n                _round_[varg1][1] = varg1;\n            }\n            MEM[varg1] += 100;\n        }\n        if (varg1 >= 0x16345785d8a0000) {\n            _airDropTracker_ += 1;\n            v28 = v29 = 10000 == _airDropTracker_;\n            if (10000 != _airDropTracker_) {\n                v28 = v30 = 0x186a0 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v31 = 0xf4240 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v32 = 0x989680 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v33 = 0x5f5e100 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = 0x3b9aca00 == _airDropTracker_;\n            }\n            if (!v28) {\n                v34 = v35 = 0;\n            } else {\n                v34 = 1;\n            }\n            if (1 == v34) {\n                if (varg1 < 0x8ac7230489e80000) {\n                    v36 = v37 = varg1 >= 0xde0b6b3a7640000;\n                    if (v37) {\n                        v36 = v38 = varg1 < 0x8ac7230489e80000;\n                    }\n                    if (!v36) {\n                        v39 = v40 = varg1 >= 0x16345785d8a0000;\n                        if (v40) {\n                            v39 = v41 = varg1 < 0xde0b6b3a7640000;\n                        }\n                        if (v39) {\n                            v42 = 0x48d0(25, _airDropPot_);\n                            assert(100);\n                            v18 = v43 = v42 / 100;\n                            v44 = _SafeAdd(v43, _plyr_[varg1][2]);\n                            _plyr_[varg1][2] = v44;\n                            v45 = _SafeSub(v43, _airDropPot_);\n                            _airDropPot_ = v45;\n                            MEM[varg1] += 0xeca8847c4129106ce8300000000;\n                        }\n                    } else {\n                        v46 = 0x48d0(50, _airDropPot_);\n                        assert(100);\n                        v18 = v47 = v46 / 100;\n                        v48 = _SafeAdd(v47, _plyr_[varg1][2]);\n                        _plyr_[varg1][2] = v48;\n                        v49 = _SafeSub(v47, _airDropPot_);\n                        _airDropPot_ = v49;\n                        MEM[varg1] += 0x9dc5ada82b70b59df0200000000;\n                    }\n                } else {\n                    v50 = 0x48d0(75, _airDropPot_);\n                    assert(100);\n                    v18 = v51 = v50 / 100;\n                    v52 = _SafeAdd(v51, _plyr_[varg1][2]);\n                    _plyr_[varg1][2] = v52;\n                    v53 = _SafeSub(v51, _airDropPot_);\n                    _airDropPot_ = v53;\n                    MEM[varg1] += 0xeca8847c4129106ce8300000000;\n                }\n                MEM[varg1] = 0x7e37be2022c0914b2680000000 + (v18 * 0x314dc6448d9338c15b0a00000000 + MEM[varg1]);\n            }\n        }\n        MEM[varg1] += _airDropTracker_ * 1000;\n        if (_myFounder_PID[varg1] > 0) {\n            v54 = _SafeAdd(_plyrRnds_[varg1][1], _plyrRnds_[varg1]);\n            _plyrRnds_[varg1][1] = v54;\n            v55 = _SafeAdd(_plyrRnds_[varg1][5], _plyrRnds_[varg1]);\n            _round_[varg1][5] = v55;\n            _round_[varg1] = 0;\n        }\n        v56 = _SafeAdd(_plyrRnds_[varg1][1], v16);\n        _plyrRnds_[varg1][1] = v56;\n        v57 = _SafeAdd(_plyrRnds_[varg1], varg1);\n        _plyrRnds_[varg1] = v57;\n        v58 = _SafeAdd(_plyrRnds_[varg1][5], v16);\n        _round_[varg1][5] = v58;\n        v59 = _SafeAdd(_round_[varg1][6], varg1);\n        _round_[varg1][6] = v59;\n        v60 = _SafeAdd(_rndTmEth_[varg1], varg1);\n        _rndTmEth_[varg1] = v60;\n        v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80 = 0x4d7f(varg1, varg1, varg1, varg1, varg1, varg1, 14785);\n        v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, varg1 = v92, v93, v94, v95, v96, v97, v98, v99, v100 = 0x4ef3(v66, v63, v67, v61, v70);\n        MEM[0 + v81] = MEM[0 + v81] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * v87;\n        MEM[32 + v81] = MEM[32 + v81] + v90 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + v81], MEM[32 + v81], ~0x0 & (~0x0 & _plyr_[v90][0x1]), msg.sender, v89, v83, address(MEM[64 + v81]), ~0x0 & (~0x0 & MEM[96 + v81]), MEM[128 + v81], MEM[160 + v81], MEM[192 + v81], MEM[224 + v81], MEM[256 + v81], _airDropPot_);\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x44364c5bb000;\n    } else {\n        v6 = _SafeAdd(0xde0b6b3a7640000, _round_[_rID_][5]);\n        v4 = v7, v8, v9, v10, v11, v12, v13, v14 = 0x3dc8(0xde0b6b3a7640000);\n        goto 0x10670xfa7B0x3a2;\n    }\n    return v4;\n}\n\nfunction 0x39ec() private { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    v0 = v1 = _rID_;\n    v0 = v2 = 0;\n    v0 = v3 = _round_[v1];\n    v0 = v4 = _round_[v1][1];\n    v0 = v5 = _round_[v1][7];\n    v6 = 0x48d0(40, v5);\n    assert(100);\n    v0 = v7 = v6 / 100;\n    v0 = v8 = v5 / 10;\n    v9 = 0x48d0(_potSplit_[v4], v5);\n    assert(100);\n    v0 = v10 = v9 / 100;\n    v0 = v11 = 0;\n    v0 = v12 = 14988;\n    v0 = v13 = 8125;\n    v0 = v14 = _SafeSub(v7, v5);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v15 = 20336;\n        v0, v16, v0 = v17, v0, v0, v0 = v18, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v19 = _round_[v0][7];\n        v0 = v20 = 20404;\n        v0 = v21 = _SafeAdd(v0, v17);\n        v19 = _SafeAdd(v19, v21);\n        v0, v0 = v22, v0 = v23, v0, v0 = v24 = 0x51fa(v19);\n        0x4cb7(v19, v0, v0, v0);\n    }\n    v25 = _ourTEAM.call().value(v0).gas(2300 * !v0);\n    require(v25); // checks call status, propagates error data on error\n    v26 = 0x48d0(0xde0b6b3a7640000, v0);\n    assert(_round_[v0][5]);\n    v27 = 0x48d0(_round_[v0][5], v26 / _round_[v0][5]);\n    assert(0xde0b6b3a7640000);\n    require(v27 / 0xde0b6b3a7640000 <= v0, Error('SafeMath sub failed'));\n    return v0 - v27 / 0xde0b6b3a7640000, v0, v26 / _round_[v0][5], v0, v0, v0, v0, v0, v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v19;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v19 + v0 >= v0, Error('SafeMath add failed'));\n    return v19 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    if (v19 > 0) {\n        _plyr_[v0][2] = 0;\n        _plyr_[v0][3] = 0;\n        _plyr_[v0][4] = 0;\n    }\n    return v19, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v28 = _SafeAdd(v0, 0x15180);\n    if (v19 >= v28) {\n        v29 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v29;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v19;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v19;\n    v30 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v30;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction myFounder_PID(address varg0) public nonPayable { \n    return _myFounder_PID[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, Error('SafeMath add failed'));\n    return v0;\n}\n\nfunction 0x3dc8(uint256 varg0) private { \n    v0 = _SafeSub(varg0, v1);\n    v2, v3, v4, v5 = 0x4b6b();\n    v6, v7, v8, v9 = 0x4b6b();\n    v10 = _SafeSub(v7, v6);\n    return v10, v4, v5, 15845, 15854, 0, varg0, v1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'FoMoKiller long';\n    }\n    return v0;\n}\n\nfunction 0x3df5(uint256 varg0) private { \n    v0 = v1 = varg0 < 0;\n    if (varg0 >= 0) {\n        v0 = v2 = varg0 > 3;\n    }\n    if (v0) {\n        varg0 = v3 = 2;\n    }\n    return varg0;\n}\n\nfunction 0x3e1a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = v1 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32 = 0x39ec();\n            MEM[0 + v8] = MEM[0 + v8] + 0xde0b6b3a7640000 * v9;\n            MEM[32 + v8] = MEM[32 + v8] + v15;\n            emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v15][0x1]), MEM[0 + v8], MEM[32 + v8], address(MEM[64 + v8]), ~0x0 & (~0x0 & MEM[96 + v8]), MEM[128 + v8], MEM[160 + v8], MEM[192 + v8], MEM[224 + v8]);\n            return v17, v18, v19;\n        }\n    } else {\n        v33, v34, v35, v36 = 0x4036(v37, 8125, varg1, 16023, block.timestamp, _rID_, varg0);\n        v38 = _SafeSub(v34, v33);\n        STORAGE[3 + keccak256(_rID_, 8)] = v38;\n        0x339a(varg3, v39, v39, v37, v39);\n        goto 0x1af50x3e1a;\n    }\n    return;\n}\n\nfunction 0x4036(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0, v1, v2 = 0x5163(_plyr_[varg0][5]);\n    v3 = _SafeAdd(_plyr_[v2][3], _plyr_[v2][2]);\n    v4 = _SafeAdd(_plyr_[v2][4], v3);\n    _round_[varg4][2] = v4;\n    _round_[varg4][7] = v2;\n    _airDropTracker_ = 0;\n    if (v4 > 0) {\n        _plyr_[v2][2] = 0;\n        _plyr_[v2][3] = 0;\n        _plyr_[v2][4] = 0;\n    }\n    return v4, 0, 0, varg0;\n}\n\nfunction 0x40bd(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, Error('string must be between 1 and 32 characters'));\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[varg0.length - 1] >> 248 << 248;\n    }\n    require(v5, Error('string cannot start or end with space'));\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248, Error('string cannot start with 0x'));\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248, Error('string cannot start with 0X'));\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, Error('string contains invalid characters'));\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1 + v8] >> 248 << 248, Error('string cannot contain consecutive spaces'));\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (varg0[v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, Error('string cannot be only numbers'));\n    return MEM[varg0.data];\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v1) {\n        v3 = v4 = _pIDxName_[varg0];\n        if (v4 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v4;\n        }\n    } else {\n        v3 = v5 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v6 = 0x3df5(varg1);\n    v7, v8, v9 = 0x3e1a(v0, varg2, v6, v3);\n}\n\nfunction activate() public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    require(stor_0_0_0, Error('must link to other FoMo3D first'));\n    require(!_activated_, Error('fomo3d already activated'));\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 11;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3 = stor_1 + block.timestamp - _getTimeLeft;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1 = 0x15180 + (stor_1 + block.timestamp);\n}\n\nfunction 0x48d0(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, Error('SafeMath mul failed'));\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0x4947(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[v0][1];\n    varg0 = v3 = _plyrRnds_[v0][5];\n    v4 = _plyrRnds_[v0][1];\n    MEM[v1] = varg0;\n    MEM[32] = 11;\n    varg0 = v5 = 0xde0b6b3a7640000;\n    v0 = v6 = 18948;\n    v0 = v7 = 18936;\n    v0 = v8 = 18895;\n    v9 = 0x48d0(_plyrRnds_[v0], _plyrRnds_[v0][7]);\n    assert(100);\n    v10 = v11 = v9 / 100;\n    while (1) {\n        if (v10) {\n            goto 0x48e10x4947;\n        }\n        v10 = v12 = 0;\n        while (1) {\n            goto {'0x49f80x4947', '0x49cf', '0x4a04'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v13 = _round_[varg0][8];\n            v10 = v10 / varg0 + v13;\n            require(v10 >= v13, Error('SafeMath add failed'));\n        }\n        continue;\n        v10 *= varg0;\n        assert(v10);\n        require(v10 / v10 == varg0, Error('SafeMath mul failed'));\n    }\n    assert(varg0);\n    return v10 / varg0, v0, varg0, v0;\n}\n\nfunction 0x49c2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    if (v0) {\n        v1 = varg2 * v0;\n        assert(v0);\n        require(v1 / v0 == varg2, Error('SafeMath mul failed'));\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, Error('SafeMath sub failed'));\n    return varg1 - varg0;\n}\n\nfunction 0x4a75(uint256 varg0) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = 0x48d0(_plyrRnds_[varg0][1], _plyrRnds_[varg0][8]);\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v1 / 0xde0b6b3a7640000, Error('SafeMath sub failed'));\n    return v1 / 0xde0b6b3a7640000 - v0, 0, varg0, v2;\n}\n\nfunction 0x4ad2(uint256 varg0) private { \n    v0, v1, v2, v3, v4 = 0x4af3(v5, 19168, 15854, 0, varg0, v5);\n    require(v3 + v4 >= v4, Error('SafeMath add failed'));\n    return v3 + v4, 8125, v0, v1, v2, v3, v4;\n}\n\nfunction 0x4af3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0x9502f90;\n    v0 = v3 = 19291;\n    v0 = v4 = 0x3b2a1d15167e7c5699bfde00000;\n    v0 = v5 = 8125;\n    v0 = v6 = 19286;\n    v7 = v8 = 0xdac7055469777a6122ee4310dd6c14410500f2904840000000000;\n    v9 = 0x48d0(0xde0b6b3a7640000, varg0);\n    v0 = v10 = 0x48d0(0x1027e72f1f1281308800000, v9);\n    while (1) {\n        v7 = _SafeAdd(v7, v0);\n        v0, v0 = v11, v0 = v12, v0, v0 = 0x51fa(v7);\n        v0 = _SafeSub(v0, v0);\n        v0 = v13 = 20336;\n        v0, v14, v0 = v15, v0, v0, v0 = v16, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v7 = _round_[v0][7];\n        v0 = v17 = 20404;\n        v0 = _SafeAdd(v0, v15);\n        0x4cb7(v7, v0, v0, v0);\n    }\n    _round_[v0][2] = v7;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0;\n    require(v7 + v0 >= v0, Error('SafeMath add failed'));\n    return v7 + v0, v0, v0, v0, v0;\n    require(v0 <= v0, Error('SafeMath sub failed'));\n    return v0 - v0, v0, v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0;\n    v18 = _SafeAdd(v0, 0x15180);\n    if (v7 >= v18) {\n        v19 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v19;\n        return v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v7;\n        return v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v7;\n    v20 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v20;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0;\n}\n\nfunction 0x4b6b() private { \n    v0 = 0x524d(0xde0b6b3a7640000);\n    v1 = 0x48d0(0xde0b6b3a7640000, v2);\n    v3 = 0x48d0(v1, 0x886c8f673070);\n    assert(2);\n    v4 = 0x524d(v2);\n    v5 = 0x48d0(v4, 0x4a817c8);\n    require((v3 >> 1) + v5 >= v5, Error('SafeMath add failed'));\n    return (v3 >> 1) + v5, v0, 0, v2;\n}\n\nfunction airDropTracker_() public nonPayable { \n    return _airDropTracker_;\n}\n\nfunction 0x4c37(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10) private { \n    v0 = v1 = 0;\n    v0 = v2 = block.timestamp;\n    v3 = v4 = v2 > _round_[varg0][2];\n    if (v4) {\n        v3 = v5 = !_round_[varg0];\n    }\n    if (!v3) {\n        v0 = v6 = _round_[varg0][2];\n        v0 = v7 = 19636;\n        v0 = v8 = 0x49c2(varg1, 0xde0b6b3a7640000, 30);\n    } else {\n        v0 = v9 = 19587;\n        v0 = v10 = 0x49c2(varg1, 0xde0b6b3a7640000, 30);\n    }\n    while (1) {\n        v0 = _SafeAdd(v0, v0);\n        v0, v0 = v11, v0 = v12, v0, v13 = 0x51fa(v0);\n        v0 = _SafeSub(v0, v0);\n        v0 = v14 = 20336;\n        v0, v15, v0 = v16, v0, v0, v0 = v17, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v0 = v18 = _round_[v0][7];\n        v0 = v19 = 20404;\n        v0 = _SafeAdd(v0, v16);\n        0x4cb7(v0, v0, v0, v0);\n    }\n    _round_[v0][2] = v0;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0;\n    require(v0 + v0 >= v0, Error('SafeMath add failed'));\n    return v0 + v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0;\n    return v0, v0, v0;\n    v20 = _SafeAdd(v0, 0x15180);\n    if (v0 >= v20) {\n        v21 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v21;\n        return v0, v0, v0;\n    } else {\n        _round_[v0][2] = v0;\n        return v0, v0, v0;\n    }\n    _round_[v0][7] = v0;\n    v22 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v22;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0;\n}\n\nfunction 0x4cb7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = _SafeAdd(varg1, 0x15180);\n    if (varg0 >= v0) {\n        v1 = _SafeAdd(varg1, 0x15180);\n        _round_[varg2][2] = v1;\n        return ;\n    } else {\n        _round_[varg2][2] = varg0;\n        return ;\n    }\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    return _round_[varg0], _round_[varg0][1], _round_[varg0][2], _round_[varg0][0x3] & 0xff, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10], _round_[varg0][11];\n}\n\nfunction 0x4d7f(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = v1 = 0;\n    v2 = 0x48d0(3, varg3);\n    assert(100);\n    v3 = _ourTEAM.call().value(v2 / 100).gas(2300 * !(v2 / 100));\n    require(v3); // checks call status, propagates error data on error\n    v0 = v4 = varg3 / 10;\n    v5 = varg4 == varg2;\n    v6 = v7 = varg4 != varg2;\n    if (varg4 != varg2) {\n        v6 = v8 = _plyr_[varg2][1];\n    }\n    if (v6) {\n        v9 = address(_plyr_[varg2]);\n        if (0xff & _myFounder_[varg2]) {\n            v0 = v10 = varg3 / 5;\n        }\n        v11 = _SafeAdd(_plyr_[varg2][4], v0);\n        _plyr_[varg2][4] = v11;\n        v12 = _plyr_[varg2][1];\n        v13 = address(_plyr_[varg2]);\n        emit onAffiliatePayout(varg2, varg5, varg4, v13, v12, v0, block.timestamp);\n    }\n    v0 = v14 = 20198;\n    v0 = v15 = _SafeSub(v2 / 100, varg3);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v16 = 20336;\n        v0, v17, v0 = v18, v0, v0, v0 = v19, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v20 = _round_[v0][7];\n        v0 = v21 = 20404;\n        v0 = v22 = _SafeAdd(v0, v18);\n        v20 = _SafeAdd(v20, v22);\n        v0, v0 = v23, v0 = v24, v0, v25 = 0x51fa(v20);\n        0x4cb7(v20, v0, v0, v0);\n    }\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v20;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v20 + v0 >= v0, Error('SafeMath add failed'));\n    return v20 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v26 = _SafeAdd(v0, 0x15180);\n    if (v20 >= v26) {\n        v27 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v27;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v20;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v20;\n    v28 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v28;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction 0x4ef3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    v0 = v2 = 0;\n    v3 = 0x48d0(_fees_[varg2], varg3);\n    assert(100);\n    v0 = v4 = v3 / 100;\n    v0 = v5 = varg3 / 100;\n    v6 = _SafeAdd(v5, _airDropPot_);\n    _airDropPot_ = v6;\n    v0 = v7 = 20322;\n    v0 = v8 = _SafeSub(v4, varg3);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v9 = 20336;\n        v0, v10, v0 = v11, v0, v0, v0 = v12, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v13 = _round_[v0][7];\n        v0 = v14 = 20404;\n        v0 = v15 = _SafeAdd(v0, v11);\n        v13 = _SafeAdd(v13, v15);\n        v0, v0 = v16, v0 = v17, v0, v18 = 0x51fa(v13);\n        0x4cb7(v13, v0, v0, v0);\n    }\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v13;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v13 + v0 >= v0, Error('SafeMath add failed'));\n    return v13 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v19 = _SafeAdd(v0, 0x15180);\n    if (v13 >= v19) {\n        v20 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v20;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v13;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v13;\n    v21 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v21;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction 0x5163(uint256 varg0) private { \n    v0, v1, v2, v3 = 0x4a75(varg0);\n    if (v0 > 0) {\n        v4 = _SafeAdd(_plyr_[v3][3], v0);\n        _plyr_[v3][3] = v4;\n        v5 = _SafeAdd(_plyrRnds_[v3][2], v0);\n        _plyrRnds_[v3][2] = v5;\n    }\n    return 0, varg0, v6;\n}\n\nfunction 0x51fa(uint256 varg0) private { \n    v0 = _SafeAdd(1, varg0);\n    assert(2);\n    if (v0 >> 1 >= varg0) {\n        return varg0;\n    } else {\n        assert(v0 >> 1);\n        v1 = varg0 / (v0 >> 1);\n        require((v0 >> 1) + v1 >= v1, Error('SafeMath add failed'));\n        return (v0 >> 1) + v1, 2, v0 >> 1, v0 >> 1, varg0;\n    }\n}\n\nfunction 0x524d(uint256 varg0) private { \n    v0 = 0x48d0(varg0, varg0);\n    return v0;\n}\n\nfunction 0x5259(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = _round_[v1][5];\n    v2 = 0x48d0(0xde0b6b3a7640000, varg1);\n    assert(v0);\n    v3 = _SafeAdd(_round_[v1][8], v2 / v0);\n    _round_[v1][8] = v3;\n    v4 = 0x48d0(varg0, v2 / v0);\n    assert(0xde0b6b3a7640000);\n    v5 = 0x48d0(varg0, _plyrRnds_[varg2][8]);\n    assert(0xde0b6b3a7640000);\n    require(v4 / 0xde0b6b3a7640000 <= v5 / 0xde0b6b3a7640000, Error('SafeMath sub failed'));\n    return v5 / 0xde0b6b3a7640000 - v4 / 0xde0b6b3a7640000, _plyrRnds_[varg2][2], 21311, v4 / 0xde0b6b3a7640000, v2 / v0, 0, varg0, varg1, varg2, v1;\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction myFounder_(address varg0) public nonPayable { \n    return 0xff & _myFounder_[varg0];\n}\n\nfunction reLoadXid(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v1) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v3 = v4 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = 0x3df5(varg1);\n    v6, v7, v8 = 0x3e1a(v0, varg2, v5, v3);\n}\n\nfunction withdraw() public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v1 = v2 = block.timestamp > _round_[msg.sender][2];\n    if (v2) {\n        v1 = v3 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v1) {\n        v1 = _round_[_rID_];\n    }\n    if (!v1) {\n        v4, v5, v6, v7 = 0x4036(_pIDxAddr_[msg.sender], 6728, msg.sender.code.size, msg.sender, v0, 0, _pIDxAddr_[msg.sender]);\n        if (v4 > 0) {\n            v8 = address(STORAGE[keccak256(_rID_, 0x8)]).call().value(v4).gas(2300 * !v4);\n            require(v8); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(v9, msg.sender, STORAGE[1 + keccak256(_rID_, 8)], v4);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34 = 0x39ec();\n        v35, v36, v37, v38 = 0x4036(v15, 6350, v11, v12, v10, v14, v15);\n        if (v35 > 0) {\n            v39 = address(_plyr_[v18]).call().value(v35).gas(2300 * !v35);\n            require(v39); // checks call status, propagates error data on error\n        }\n        MEM[0 + v38] = MEM[0 + v38] + 0xde0b6b3a7640000 * v19;\n        MEM[32 + v38] = MEM[32 + v38] + v18;\n        emit 0xbd0dba8ab932212fa78150cdb7b0275da72e255875967b5cad11464cf71bedc(msg.sender, ~0x0 & (~0x0 & _plyr_[v18][0x1]), v35, MEM[0 + v38], MEM[32 + v38], address(MEM[64 + v38]), ~0x0 & (~0x0 & MEM[96 + v38]), MEM[128 + v38], MEM[160 + v38], MEM[192 + v38], MEM[224 + v38]);\n    }\n}\n\nfunction registerNameXaddr(string varg0, address varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXaddrFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction receivePlayerInfo(uint256 varg0, address varg1, bytes32 varg2, uint256 varg3) public nonPayable { \n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811 == msg.sender, Error('your not playerNames contract... hmmm..'));\n    if (varg0 != _pIDxAddr_[varg1]) {\n        _pIDxAddr_[varg1] = varg0;\n    }\n    if (varg0 != _pIDxName_[varg2]) {\n        _pIDxName_[varg2] = varg0;\n    }\n    if (address(_plyr_[varg0]) != varg1) {\n        _plyr_[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _plyr_[varg0];\n    }\n    if (varg2 != _plyr_[varg0][1]) {\n        _plyr_[varg0][1] = varg2;\n    }\n    if (varg3 != _plyr_[varg0][6]) {\n        _plyr_[varg0][6] = varg3;\n    }\n    if (!(0xff & _plyrNames_[varg2])) {\n        _plyrNames_[varg2] = 0x1 | ~0xff & _plyrNames_[varg2];\n    }\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 varg0) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][2];\n    if (v1) {\n        v0 = v2 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v0) {\n        v0 = _round_[_rID_];\n    }\n    if (!v0) {\n        v3 = _plyr_[varg0][2];\n        v4 = v5, v6 = v7, v8 = v9, v10 = 0x4a75(_plyr_[varg0][5]);\n    } else {\n        if (varg0 != _round_[_rID_]) {\n            v11 = _plyr_[varg0][2];\n            v12 = _plyrRnds_[_rID_][2];\n            v8 = v13 = 8125;\n            v14 = v15, v16 = v17, v18 = v19, v6 = v20 = 0x4947(_rID_);\n        } else {\n            v21 = 0x48d0(40, _round_[_rID_][7]);\n            assert(100);\n            require(v21 / 100 + _plyr_[varg0][2] >= _plyr_[varg0][2], Error('SafeMath add failed'));\n            v22 = _plyrRnds_[_rID_][2];\n            v8 = v23 = 8125;\n            v14 = v24, v16 = v25, v18 = v26, v6 = v27 = 0x4947(_rID_);\n        }\n        v4 = _SafeSub(v16, v14);\n    }\n    v28 = _SafeAdd(v4, _plyr_[_rID_][3]);\n    return v8, v28, _plyr_[_rID_][4];\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXnameFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction ourTEAM() public nonPayable { \n    return _ourTEAM;\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    v0 = _rID_;\n    return _round_[v0][9], v0, _round_[v0][5], _round_[v0][2], _round_[v0][4], _round_[v0][7], _round_[v0][1] + 10 * _round_[v0][0], address(_round_[_round_[v0][0]][0]), _round_[_round_[_round_[v0][0]][0]][1], _rndTmEth_[0], _rndTmEth_[1], _rndTmEth_[2], _rndTmEth_[3], _airDropTracker_ + 1000 * _airDropPot_;\n}\n\nfunction reLoadXaddr(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = msg.sender == varg0;\n    }\n    if (!v1) {\n        v3 = v4 = _pIDxAddr_[varg0];\n        if (v4 != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v4;\n            v5 = v6 = 0x3df5(varg1);\n        }\n    } else {\n        v3 = v7 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = v8 = 0x3df5(varg1);\n    v9, v10, v11 = 0x3e1a(v0, varg2, v5, v3);\n}\n\nfunction setOtherFounder(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    _myFounder_[varg0] = 0x1 | ~0xff & _myFounder_[varg0];\n    v5 = 0x48d0(0xde0b6b3a7640000, varg1);\n    _myFounder_PID[varg0] = v5;\n}\n\nfunction buyXid(uint256 varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v10) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction receivePlayerNameList(uint256 varg0, bytes32 varg1) public nonPayable { \n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811 == msg.sender, Error('your not playerNames contract... hmmm..'));\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n}\n\nfunction registerNameXID(string varg0, uint256 varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXIDFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'FoMoKiller';\n    }\n    return v0;\n}\n\nfunction buyXaddr(address varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = msg.sender == varg0;\n    }\n    if (!v10) {\n        if (_pIDxAddr_[varg0] != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxAddr_[varg0];\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1], _plyrRnds_[varg1][2], _plyrRnds_[varg1][3];\n}\n\nfunction buyXname(bytes32 varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v10) {\n        if (_pIDxName_[varg0] != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxName_[varg0];\n            v12 = 0x3df5(varg1);\n        }\n    } else {\n        v13 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v14 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction setOtherFomo(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    require(!_setOtherFomo, Error('silly dev, you already did that'));\n    _setOtherFomo = varg0;\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + _getTimeLeft) {\n            v0 = v2 = _SafeSub(block.timestamp, _getTimeLeft + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0x10670x3009B0x998;\n    }\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[varg0][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[varg0][2];\n        if (block.timestamp > _round_[varg0][2]) {\n            v0 = v3 = block.timestamp > _round_[varg0][2];\n            if (v3) {\n                v0 = !_round_[varg0];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5, v6, v7, v8, v9 = 0x4af3(varg1, 12585, block.timestamp, 0, varg1, varg0);\n    } else {\n        v4 = v10, v11, v12, v13, v14, v15, v16 = 0x4ad2(varg1);\n    }\n    return v4;\n}\n\nfunction iWantXKeys(uint256 varg0) public nonPayable { \n    v0 = v1 = _rID_;\n    v2 = v3 = 0;\n    v4 = v5 = block.timestamp;\n    v6 = v7 = v5 > _round_[v1][4] + _getTimeLeft;\n    if (v7) {\n        v6 = v8 = v5 <= _round_[v1][2];\n        if (v5 > _round_[v1][2]) {\n            v6 = v9 = v5 > _round_[v1][2];\n            if (v9) {\n                v6 = !_round_[v1];\n            }\n        }\n    }\n    if (!v6) {\n        v10 = v11, v12, v13, v14 = 0x4b6b();\n    } else {\n        v15 = _SafeAdd(varg0, _round_[v1][5]);\n        v10 = v16, v17, v18, v19, v20, v4 = v21, v0 = v22, v2 = v23 = 0x3dc8(varg0);\n    }\n    return v10;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction airDropPot_() public nonPayable { \n    return _airDropPot_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    return address(_plyr_[varg0]), _plyr_[varg0][1], _plyr_[varg0][2], _plyr_[varg0][3], _plyr_[varg0][4], _plyr_[varg0][5], _plyr_[varg0][6];\n}\n\nfunction potSwap() public payable { \n    v0 = _SafeAdd(msg.value, _round_[1 + _rID_][7]);\n    _round_[1 + _rID_][7] = v0;\n    emit onPotSwapDeposit(1 + _rID_, msg.value);\n}\n\nfunction getPlayerInfoByAddress(address varg0) public nonPayable { \n    v0 = _pIDxAddr_[varg0];\n    v1 = _pIDxAddr_[v0][1];\n    MEM[0] = v0;\n    MEM[32] = 8;\n    v2, v3, v4, v5 = 0x4a75(_pIDxAddr_[v0][5]);\n    v6 = _SafeAdd(v2, _plyr_[_pIDxAddr_[v0][2]][3]);\n    return 13147, 13117, v5, v4, v6, _plyr_[_pIDxAddr_[v0][2]][4], _plyrRnds_[_pIDxAddr_[v0][2]];\n}\n\nfunction 0xd6d() private { \n    v0 = v1 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32 = 0x39ec();\n            MEM[0 + v8] = MEM[0 + v8] + 0xde0b6b3a7640000 * v9;\n            MEM[32 + v8] = MEM[32 + v8] + v14;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v14][0x1]), msg.value, MEM[0 + v8], MEM[32 + v8], address(MEM[64 + v8]), ~0x0 & (~0x0 & MEM[96 + v8]), MEM[128 + v8], MEM[160 + v8], MEM[192 + v8], MEM[224 + v8]);\n        }\n        v33 = _SafeAdd(msg.value, _plyr_[v14][3]);\n        _plyr_[v14][3] = v33;\n    } else {\n        0x339a(v34, v35, v35, msg.value, v35);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x2186fa4 == v0) {\n            myFounder_PID(address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x11a09ae7 == v0) {\n            airDropTracker_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x3393bc43 == v0) {\n            myFounder_(address);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3ddd4698 == v0) {\n            registerNameXaddr(string,address,bool);\n        } else if (0x49cc635d == v0) {\n            receivePlayerInfo(uint256,address,bytes32,uint256);\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x685ffd83 == v0) {\n            registerNameXname(string,bytes32,bool);\n        } else if (0x6d510a64 == v0) {\n            ourTEAM();\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x88dfee60 == v0) {\n            setOtherFounder(address,uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x8f7140ea == v0) {\n            receivePlayerNameList(uint256,bytes32);\n        } else if (0x921dec21 == v0) {\n            registerNameXID(string,uint256,bool);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xb483c054 == v0) {\n            setOtherFomo(address);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xd87574e0 == v0) {\n            airDropPot_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xed78cf4a == v0) {\n            potSwap();\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.03 01:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_1; // STORAGE[0x1]\nuint256 _getTimeLeft; // STORAGE[0x2]\nuint256 _airDropPot_; // STORAGE[0x3]\nuint256 _airDropTracker_; // STORAGE[0x4]\nuint256 _rID_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyr_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _myFounder_; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _myFounder_PID; // STORAGE[0x11]\nuint256 _setOtherFomo; // STORAGE[0x0] bytes 0 to 19\nuint256 _activated_; // STORAGE[0x12] bytes 0 to 0\nuint256 _ourTEAM; // STORAGE[0xf] bytes 0 to 19\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1]\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3]\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonPotSwapDeposit(uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonAffiliatePayout(uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256, uint256);\n\nfunction () public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = _pIDxAddr_[_pIDxAddr_[msg.sender]][6];\n    0xd6d();\n}\n\nfunction 0x339a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg1 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        varg1 = v2 = 13261;\n        v3 = new struct(9);\n        v3.word0 = 0;\n        v3.word1 = 0;\n        v3.word2 = 0;\n        v3.word3 = 0;\n        v3.word4 = 0;\n        v3.word5 = 0;\n        v3.word6 = 0;\n        v3.word7 = 0;\n        v3.word8 = 0;\n        if (_plyr_[varg4][5]) {\n            v4, varg1 = v5, varg1 = v6 = 0x5163(_plyr_[varg4][5]);\n        }\n        _plyr_[varg1][5] = _rID_;\n        MEM[v7] += 10;\n    }\n    v8 = v9 = 0x56bc75e2d63100000 > _round_[varg1][6];\n    if (v9) {\n        v10 = _SafeAdd(varg1, _plyrRnds_[varg1]);\n        v8 = v11 = v10 > 0xde0b6b3a7640000;\n    }\n    if (v8) {\n        varg1 = v12 = _SafeSub(_plyrRnds_[varg1], 0xde0b6b3a7640000);\n        varg1 = v13 = _SafeSub(v12, varg1);\n        v14 = _SafeAdd(v13, _plyr_[varg1][3]);\n        _plyr_[varg1][3] = v14;\n    }\n    if (varg1 > 0x3b9aca00) {\n        varg1 = v15 = 13535;\n        v16 = v17, v18 = v19, v20, v21, v22, varg1 = v23, varg1 = v24 = 0x4ad2(varg1);\n        if (v17 >= 0xde0b6b3a7640000) {\n            v18 = v25, v16 = v26, v27 = 0x4c37(varg1, v17, 13562, v19, v17, v21, v22, v23, v24, v15, varg1);\n            if (varg1 != _round_[varg1]) {\n                _round_[varg1] = varg1;\n            }\n            if (varg1 != _round_[varg1][1]) {\n                _round_[varg1][1] = varg1;\n            }\n            MEM[varg1] += 100;\n        }\n        if (varg1 >= 0x16345785d8a0000) {\n            _airDropTracker_ += 1;\n            v28 = v29 = 10000 == _airDropTracker_;\n            if (10000 != _airDropTracker_) {\n                v28 = v30 = 0x186a0 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v31 = 0xf4240 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v32 = 0x989680 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v33 = 0x5f5e100 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = 0x3b9aca00 == _airDropTracker_;\n            }\n            if (!v28) {\n                v34 = v35 = 0;\n            } else {\n                v34 = 1;\n            }\n            if (1 == v34) {\n                if (varg1 < 0x8ac7230489e80000) {\n                    v36 = v37 = varg1 >= 0xde0b6b3a7640000;\n                    if (v37) {\n                        v36 = v38 = varg1 < 0x8ac7230489e80000;\n                    }\n                    if (!v36) {\n                        v39 = v40 = varg1 >= 0x16345785d8a0000;\n                        if (v40) {\n                            v39 = v41 = varg1 < 0xde0b6b3a7640000;\n                        }\n                        if (v39) {\n                            v42 = 0x48d0(25, _airDropPot_);\n                            assert(100);\n                            v18 = v43 = v42 / 100;\n                            v44 = _SafeAdd(v43, _plyr_[varg1][2]);\n                            _plyr_[varg1][2] = v44;\n                            v45 = _SafeSub(v43, _airDropPot_);\n                            _airDropPot_ = v45;\n                            MEM[varg1] += 0xeca8847c4129106ce8300000000;\n                        }\n                    } else {\n                        v46 = 0x48d0(50, _airDropPot_);\n                        assert(100);\n                        v18 = v47 = v46 / 100;\n                        v48 = _SafeAdd(v47, _plyr_[varg1][2]);\n                        _plyr_[varg1][2] = v48;\n                        v49 = _SafeSub(v47, _airDropPot_);\n                        _airDropPot_ = v49;\n                        MEM[varg1] += 0x9dc5ada82b70b59df0200000000;\n                    }\n                } else {\n                    v50 = 0x48d0(75, _airDropPot_);\n                    assert(100);\n                    v18 = v51 = v50 / 100;\n                    v52 = _SafeAdd(v51, _plyr_[varg1][2]);\n                    _plyr_[varg1][2] = v52;\n                    v53 = _SafeSub(v51, _airDropPot_);\n                    _airDropPot_ = v53;\n                    MEM[varg1] += 0xeca8847c4129106ce8300000000;\n                }\n                MEM[varg1] = 0x7e37be2022c0914b2680000000 + (v18 * 0x314dc6448d9338c15b0a00000000 + MEM[varg1]);\n            }\n        }\n        MEM[varg1] += _airDropTracker_ * 1000;\n        if (_myFounder_PID[varg1] > 0) {\n            v54 = _SafeAdd(_plyrRnds_[varg1][1], _plyrRnds_[varg1]);\n            _plyrRnds_[varg1][1] = v54;\n            v55 = _SafeAdd(_plyrRnds_[varg1][5], _plyrRnds_[varg1]);\n            _round_[varg1][5] = v55;\n            _round_[varg1] = 0;\n        }\n        v56 = _SafeAdd(_plyrRnds_[varg1][1], v16);\n        _plyrRnds_[varg1][1] = v56;\n        v57 = _SafeAdd(_plyrRnds_[varg1], varg1);\n        _plyrRnds_[varg1] = v57;\n        v58 = _SafeAdd(_plyrRnds_[varg1][5], v16);\n        _round_[varg1][5] = v58;\n        v59 = _SafeAdd(_round_[varg1][6], varg1);\n        _round_[varg1][6] = v59;\n        v60 = _SafeAdd(_rndTmEth_[varg1], varg1);\n        _rndTmEth_[varg1] = v60;\n        v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80 = 0x4d7f(varg1, varg1, varg1, varg1, varg1, varg1, 14785);\n        v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, varg1 = v92, v93, v94, v95, v96, v97, v98, v99, v100 = 0x4ef3(v66, v63, v67, v61, v70);\n        MEM[0 + v81] = MEM[0 + v81] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * v87;\n        MEM[32 + v81] = MEM[32 + v81] + v90 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + v81], MEM[32 + v81], ~0x0 & (~0x0 & _plyr_[v90][0x1]), msg.sender, v89, v83, address(MEM[64 + v81]), ~0x0 & (~0x0 & MEM[96 + v81]), MEM[128 + v81], MEM[160 + v81], MEM[192 + v81], MEM[224 + v81], MEM[256 + v81], _airDropPot_);\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x44364c5bb000;\n    } else {\n        v6 = _SafeAdd(0xde0b6b3a7640000, _round_[_rID_][5]);\n        v4 = v7, v8, v9, v10, v11, v12, v13, v14 = 0x3dc8(0xde0b6b3a7640000);\n        goto 0x10670xfa7B0x3a2;\n    }\n    return v4;\n}\n\nfunction 0x39ec() private { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    v0 = v1 = _rID_;\n    v0 = v2 = 0;\n    v0 = v3 = _round_[v1];\n    v0 = v4 = _round_[v1][1];\n    v0 = v5 = _round_[v1][7];\n    v6 = 0x48d0(40, v5);\n    assert(100);\n    v0 = v7 = v6 / 100;\n    v0 = v8 = v5 / 10;\n    v9 = 0x48d0(_potSplit_[v4], v5);\n    assert(100);\n    v0 = v10 = v9 / 100;\n    v0 = v11 = 0;\n    v0 = v12 = 14988;\n    v0 = v13 = 8125;\n    v0 = v14 = _SafeSub(v7, v5);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v15 = 20336;\n        v0, v16, v0 = v17, v0, v0, v0 = v18, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v19 = _round_[v0][7];\n        v0 = v20 = 20404;\n        v0 = v21 = _SafeAdd(v0, v17);\n        v19 = _SafeAdd(v19, v21);\n        v0, v0 = v22, v0 = v23, v0, v0 = v24 = 0x51fa(v19);\n        0x4cb7(v19, v0, v0, v0);\n    }\n    v25 = _ourTEAM.call().value(v0).gas(2300 * !v0);\n    require(v25); // checks call status, propagates error data on error\n    v26 = 0x48d0(0xde0b6b3a7640000, v0);\n    assert(_round_[v0][5]);\n    v27 = 0x48d0(_round_[v0][5], v26 / _round_[v0][5]);\n    assert(0xde0b6b3a7640000);\n    require(v27 / 0xde0b6b3a7640000 <= v0, Error('SafeMath sub failed'));\n    return v0 - v27 / 0xde0b6b3a7640000, v0, v26 / _round_[v0][5], v0, v0, v0, v0, v0, v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v19;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v19 + v0 >= v0, Error('SafeMath add failed'));\n    return v19 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    if (v19 > 0) {\n        _plyr_[v0][2] = 0;\n        _plyr_[v0][3] = 0;\n        _plyr_[v0][4] = 0;\n    }\n    return v19, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v28 = _SafeAdd(v0, 0x15180);\n    if (v19 >= v28) {\n        v29 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v29;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v19;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v19;\n    v30 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v30;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction myFounder_PID(address varg0) public nonPayable { \n    return _myFounder_PID[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, Error('SafeMath add failed'));\n    return v0;\n}\n\nfunction 0x3dc8(uint256 varg0) private { \n    v0 = _SafeSub(varg0, v1);\n    v2, v3, v4, v5 = 0x4b6b();\n    v6, v7, v8, v9 = 0x4b6b();\n    v10 = _SafeSub(v7, v6);\n    return v10, v4, v5, 15845, 15854, 0, varg0, v1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'FoMoKiller long';\n    }\n    return v0;\n}\n\nfunction 0x3df5(uint256 varg0) private { \n    v0 = v1 = varg0 < 0;\n    if (varg0 >= 0) {\n        v0 = v2 = varg0 > 3;\n    }\n    if (v0) {\n        varg0 = v3 = 2;\n    }\n    return varg0;\n}\n\nfunction 0x3e1a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = v1 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32 = 0x39ec();\n            MEM[0 + v8] = MEM[0 + v8] + 0xde0b6b3a7640000 * v9;\n            MEM[32 + v8] = MEM[32 + v8] + v15;\n            emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v15][0x1]), MEM[0 + v8], MEM[32 + v8], address(MEM[64 + v8]), ~0x0 & (~0x0 & MEM[96 + v8]), MEM[128 + v8], MEM[160 + v8], MEM[192 + v8], MEM[224 + v8]);\n            return v17, v18, v19;\n        }\n    } else {\n        v33, v34, v35, v36 = 0x4036(v37, 8125, varg1, 16023, block.timestamp, _rID_, varg0);\n        v38 = _SafeSub(v34, v33);\n        STORAGE[3 + keccak256(_rID_, 8)] = v38;\n        0x339a(varg3, v39, v39, v37, v39);\n        goto 0x1af50x3e1a;\n    }\n    return;\n}\n\nfunction 0x4036(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0, v1, v2 = 0x5163(_plyr_[varg0][5]);\n    v3 = _SafeAdd(_plyr_[v2][3], _plyr_[v2][2]);\n    v4 = _SafeAdd(_plyr_[v2][4], v3);\n    _round_[varg4][2] = v4;\n    _round_[varg4][7] = v2;\n    _airDropTracker_ = 0;\n    if (v4 > 0) {\n        _plyr_[v2][2] = 0;\n        _plyr_[v2][3] = 0;\n        _plyr_[v2][4] = 0;\n    }\n    return v4, 0, 0, varg0;\n}\n\nfunction 0x40bd(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, Error('string must be between 1 and 32 characters'));\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[varg0.length - 1] >> 248 << 248;\n    }\n    require(v5, Error('string cannot start or end with space'));\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248, Error('string cannot start with 0x'));\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248, Error('string cannot start with 0X'));\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, Error('string contains invalid characters'));\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1 + v8] >> 248 << 248, Error('string cannot contain consecutive spaces'));\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (varg0[v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, Error('string cannot be only numbers'));\n    return MEM[varg0.data];\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v1) {\n        v3 = v4 = _pIDxName_[varg0];\n        if (v4 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v4;\n        }\n    } else {\n        v3 = v5 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v6 = 0x3df5(varg1);\n    v7, v8, v9 = 0x3e1a(v0, varg2, v6, v3);\n}\n\nfunction activate() public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    require(stor_0_0_0, Error('must link to other FoMo3D first'));\n    require(!_activated_, Error('fomo3d already activated'));\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 11;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3 = stor_1 + block.timestamp - _getTimeLeft;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1 = 0x15180 + (stor_1 + block.timestamp);\n}\n\nfunction 0x48d0(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, Error('SafeMath mul failed'));\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0x4947(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[v0][1];\n    varg0 = v3 = _plyrRnds_[v0][5];\n    v4 = _plyrRnds_[v0][1];\n    MEM[v1] = varg0;\n    MEM[32] = 11;\n    varg0 = v5 = 0xde0b6b3a7640000;\n    v0 = v6 = 18948;\n    v0 = v7 = 18936;\n    v0 = v8 = 18895;\n    v9 = 0x48d0(_plyrRnds_[v0], _plyrRnds_[v0][7]);\n    assert(100);\n    v10 = v11 = v9 / 100;\n    while (1) {\n        if (v10) {\n            goto 0x48e10x4947;\n        }\n        v10 = v12 = 0;\n        while (1) {\n            goto {'0x49f80x4947', '0x49cf', '0x4a04'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v13 = _round_[varg0][8];\n            v10 = v10 / varg0 + v13;\n            require(v10 >= v13, Error('SafeMath add failed'));\n        }\n        continue;\n        v10 *= varg0;\n        assert(v10);\n        require(v10 / v10 == varg0, Error('SafeMath mul failed'));\n    }\n    assert(varg0);\n    return v10 / varg0, v0, varg0, v0;\n}\n\nfunction 0x49c2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    if (v0) {\n        v1 = varg2 * v0;\n        assert(v0);\n        require(v1 / v0 == varg2, Error('SafeMath mul failed'));\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, Error('SafeMath sub failed'));\n    return varg1 - varg0;\n}\n\nfunction 0x4a75(uint256 varg0) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = 0x48d0(_plyrRnds_[varg0][1], _plyrRnds_[varg0][8]);\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v1 / 0xde0b6b3a7640000, Error('SafeMath sub failed'));\n    return v1 / 0xde0b6b3a7640000 - v0, 0, varg0, v2;\n}\n\nfunction 0x4ad2(uint256 varg0) private { \n    v0, v1, v2, v3, v4 = 0x4af3(v5, 19168, 15854, 0, varg0, v5);\n    require(v3 + v4 >= v4, Error('SafeMath add failed'));\n    return v3 + v4, 8125, v0, v1, v2, v3, v4;\n}\n\nfunction 0x4af3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0x9502f90;\n    v0 = v3 = 19291;\n    v0 = v4 = 0x3b2a1d15167e7c5699bfde00000;\n    v0 = v5 = 8125;\n    v0 = v6 = 19286;\n    v7 = v8 = 0xdac7055469777a6122ee4310dd6c14410500f2904840000000000;\n    v9 = 0x48d0(0xde0b6b3a7640000, varg0);\n    v0 = v10 = 0x48d0(0x1027e72f1f1281308800000, v9);\n    while (1) {\n        v7 = _SafeAdd(v7, v0);\n        v0, v0 = v11, v0 = v12, v0, v0 = 0x51fa(v7);\n        v0 = _SafeSub(v0, v0);\n        v0 = v13 = 20336;\n        v0, v14, v0 = v15, v0, v0, v0 = v16, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v7 = _round_[v0][7];\n        v0 = v17 = 20404;\n        v0 = _SafeAdd(v0, v15);\n        0x4cb7(v7, v0, v0, v0);\n    }\n    _round_[v0][2] = v7;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0;\n    require(v7 + v0 >= v0, Error('SafeMath add failed'));\n    return v7 + v0, v0, v0, v0, v0;\n    require(v0 <= v0, Error('SafeMath sub failed'));\n    return v0 - v0, v0, v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0;\n    v18 = _SafeAdd(v0, 0x15180);\n    if (v7 >= v18) {\n        v19 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v19;\n        return v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v7;\n        return v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v7;\n    v20 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v20;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0;\n}\n\nfunction 0x4b6b() private { \n    v0 = 0x524d(0xde0b6b3a7640000);\n    v1 = 0x48d0(0xde0b6b3a7640000, v2);\n    v3 = 0x48d0(v1, 0x886c8f673070);\n    assert(2);\n    v4 = 0x524d(v2);\n    v5 = 0x48d0(v4, 0x4a817c8);\n    require((v3 >> 1) + v5 >= v5, Error('SafeMath add failed'));\n    return (v3 >> 1) + v5, v0, 0, v2;\n}\n\nfunction airDropTracker_() public nonPayable { \n    return _airDropTracker_;\n}\n\nfunction 0x4c37(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10) private { \n    v0 = v1 = 0;\n    v0 = v2 = block.timestamp;\n    v3 = v4 = v2 > _round_[varg0][2];\n    if (v4) {\n        v3 = v5 = !_round_[varg0];\n    }\n    if (!v3) {\n        v0 = v6 = _round_[varg0][2];\n        v0 = v7 = 19636;\n        v0 = v8 = 0x49c2(varg1, 0xde0b6b3a7640000, 30);\n    } else {\n        v0 = v9 = 19587;\n        v0 = v10 = 0x49c2(varg1, 0xde0b6b3a7640000, 30);\n    }\n    while (1) {\n        v0 = _SafeAdd(v0, v0);\n        v0, v0 = v11, v0 = v12, v0, v13 = 0x51fa(v0);\n        v0 = _SafeSub(v0, v0);\n        v0 = v14 = 20336;\n        v0, v15, v0 = v16, v0, v0, v0 = v17, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v0 = v18 = _round_[v0][7];\n        v0 = v19 = 20404;\n        v0 = _SafeAdd(v0, v16);\n        0x4cb7(v0, v0, v0, v0);\n    }\n    _round_[v0][2] = v0;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0;\n    require(v0 + v0 >= v0, Error('SafeMath add failed'));\n    return v0 + v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0;\n    return v0, v0, v0;\n    v20 = _SafeAdd(v0, 0x15180);\n    if (v0 >= v20) {\n        v21 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v21;\n        return v0, v0, v0;\n    } else {\n        _round_[v0][2] = v0;\n        return v0, v0, v0;\n    }\n    _round_[v0][7] = v0;\n    v22 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v22;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0;\n}\n\nfunction 0x4cb7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = _SafeAdd(varg1, 0x15180);\n    if (varg0 >= v0) {\n        v1 = _SafeAdd(varg1, 0x15180);\n        _round_[varg2][2] = v1;\n        return ;\n    } else {\n        _round_[varg2][2] = varg0;\n        return ;\n    }\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    return _round_[varg0], _round_[varg0][1], _round_[varg0][2], _round_[varg0][0x3] & 0xff, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10], _round_[varg0][11];\n}\n\nfunction 0x4d7f(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = v1 = 0;\n    v2 = 0x48d0(3, varg3);\n    assert(100);\n    v3 = _ourTEAM.call().value(v2 / 100).gas(2300 * !(v2 / 100));\n    require(v3); // checks call status, propagates error data on error\n    v0 = v4 = varg3 / 10;\n    v5 = varg4 == varg2;\n    v6 = v7 = varg4 != varg2;\n    if (varg4 != varg2) {\n        v6 = v8 = _plyr_[varg2][1];\n    }\n    if (v6) {\n        v9 = address(_plyr_[varg2]);\n        if (0xff & _myFounder_[varg2]) {\n            v0 = v10 = varg3 / 5;\n        }\n        v11 = _SafeAdd(_plyr_[varg2][4], v0);\n        _plyr_[varg2][4] = v11;\n        v12 = _plyr_[varg2][1];\n        v13 = address(_plyr_[varg2]);\n        emit onAffiliatePayout(varg2, varg5, varg4, v13, v12, v0, block.timestamp);\n    }\n    v0 = v14 = 20198;\n    v0 = v15 = _SafeSub(v2 / 100, varg3);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v16 = 20336;\n        v0, v17, v0 = v18, v0, v0, v0 = v19, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v20 = _round_[v0][7];\n        v0 = v21 = 20404;\n        v0 = v22 = _SafeAdd(v0, v18);\n        v20 = _SafeAdd(v20, v22);\n        v0, v0 = v23, v0 = v24, v0, v25 = 0x51fa(v20);\n        0x4cb7(v20, v0, v0, v0);\n    }\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v20;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v20 + v0 >= v0, Error('SafeMath add failed'));\n    return v20 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v26 = _SafeAdd(v0, 0x15180);\n    if (v20 >= v26) {\n        v27 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v27;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v20;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v20;\n    v28 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v28;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction 0x4ef3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    v0 = v2 = 0;\n    v3 = 0x48d0(_fees_[varg2], varg3);\n    assert(100);\n    v0 = v4 = v3 / 100;\n    v0 = v5 = varg3 / 100;\n    v6 = _SafeAdd(v5, _airDropPot_);\n    _airDropPot_ = v6;\n    v0 = v7 = 20322;\n    v0 = v8 = _SafeSub(v4, varg3);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v9 = 20336;\n        v0, v10, v0 = v11, v0, v0, v0 = v12, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v13 = _round_[v0][7];\n        v0 = v14 = 20404;\n        v0 = v15 = _SafeAdd(v0, v11);\n        v13 = _SafeAdd(v13, v15);\n        v0, v0 = v16, v0 = v17, v0, v18 = 0x51fa(v13);\n        0x4cb7(v13, v0, v0, v0);\n    }\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v13;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v13 + v0 >= v0, Error('SafeMath add failed'));\n    return v13 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v19 = _SafeAdd(v0, 0x15180);\n    if (v13 >= v19) {\n        v20 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v20;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v13;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v13;\n    v21 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v21;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction 0x5163(uint256 varg0) private { \n    v0, v1, v2, v3 = 0x4a75(varg0);\n    if (v0 > 0) {\n        v4 = _SafeAdd(_plyr_[v3][3], v0);\n        _plyr_[v3][3] = v4;\n        v5 = _SafeAdd(_plyrRnds_[v3][2], v0);\n        _plyrRnds_[v3][2] = v5;\n    }\n    return 0, varg0, v6;\n}\n\nfunction 0x51fa(uint256 varg0) private { \n    v0 = _SafeAdd(1, varg0);\n    assert(2);\n    if (v0 >> 1 >= varg0) {\n        return varg0;\n    } else {\n        assert(v0 >> 1);\n        v1 = varg0 / (v0 >> 1);\n        require((v0 >> 1) + v1 >= v1, Error('SafeMath add failed'));\n        return (v0 >> 1) + v1, 2, v0 >> 1, v0 >> 1, varg0;\n    }\n}\n\nfunction 0x524d(uint256 varg0) private { \n    v0 = 0x48d0(varg0, varg0);\n    return v0;\n}\n\nfunction 0x5259(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = _round_[v1][5];\n    v2 = 0x48d0(0xde0b6b3a7640000, varg1);\n    assert(v0);\n    v3 = _SafeAdd(_round_[v1][8], v2 / v0);\n    _round_[v1][8] = v3;\n    v4 = 0x48d0(varg0, v2 / v0);\n    assert(0xde0b6b3a7640000);\n    v5 = 0x48d0(varg0, _plyrRnds_[varg2][8]);\n    assert(0xde0b6b3a7640000);\n    require(v4 / 0xde0b6b3a7640000 <= v5 / 0xde0b6b3a7640000, Error('SafeMath sub failed'));\n    return v5 / 0xde0b6b3a7640000 - v4 / 0xde0b6b3a7640000, _plyrRnds_[varg2][2], 21311, v4 / 0xde0b6b3a7640000, v2 / v0, 0, varg0, varg1, varg2, v1;\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction myFounder_(address varg0) public nonPayable { \n    return 0xff & _myFounder_[varg0];\n}\n\nfunction reLoadXid(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v1) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v3 = v4 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = 0x3df5(varg1);\n    v6, v7, v8 = 0x3e1a(v0, varg2, v5, v3);\n}\n\nfunction withdraw() public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v1 = v2 = block.timestamp > _round_[msg.sender][2];\n    if (v2) {\n        v1 = v3 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v1) {\n        v1 = _round_[_rID_];\n    }\n    if (!v1) {\n        v4, v5, v6, v7 = 0x4036(_pIDxAddr_[msg.sender], 6728, msg.sender.code.size, msg.sender, v0, 0, _pIDxAddr_[msg.sender]);\n        if (v4 > 0) {\n            v8 = address(STORAGE[keccak256(_rID_, 0x8)]).call().value(v4).gas(2300 * !v4);\n            require(v8); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(v9, msg.sender, STORAGE[1 + keccak256(_rID_, 8)], v4);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34 = 0x39ec();\n        v35, v36, v37, v38 = 0x4036(v15, 6350, v11, v12, v10, v14, v15);\n        if (v35 > 0) {\n            v39 = address(_plyr_[v18]).call().value(v35).gas(2300 * !v35);\n            require(v39); // checks call status, propagates error data on error\n        }\n        MEM[0 + v38] = MEM[0 + v38] + 0xde0b6b3a7640000 * v19;\n        MEM[32 + v38] = MEM[32 + v38] + v18;\n        emit 0xbd0dba8ab932212fa78150cdb7b0275da72e255875967b5cad11464cf71bedc(msg.sender, ~0x0 & (~0x0 & _plyr_[v18][0x1]), v35, MEM[0 + v38], MEM[32 + v38], address(MEM[64 + v38]), ~0x0 & (~0x0 & MEM[96 + v38]), MEM[128 + v38], MEM[160 + v38], MEM[192 + v38], MEM[224 + v38]);\n    }\n}\n\nfunction registerNameXaddr(string varg0, address varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXaddrFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction receivePlayerInfo(uint256 varg0, address varg1, bytes32 varg2, uint256 varg3) public nonPayable { \n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811 == msg.sender, Error('your not playerNames contract... hmmm..'));\n    if (varg0 != _pIDxAddr_[varg1]) {\n        _pIDxAddr_[varg1] = varg0;\n    }\n    if (varg0 != _pIDxName_[varg2]) {\n        _pIDxName_[varg2] = varg0;\n    }\n    if (address(_plyr_[varg0]) != varg1) {\n        _plyr_[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _plyr_[varg0];\n    }\n    if (varg2 != _plyr_[varg0][1]) {\n        _plyr_[varg0][1] = varg2;\n    }\n    if (varg3 != _plyr_[varg0][6]) {\n        _plyr_[varg0][6] = varg3;\n    }\n    if (!(0xff & _plyrNames_[varg2])) {\n        _plyrNames_[varg2] = 0x1 | ~0xff & _plyrNames_[varg2];\n    }\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 varg0) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][2];\n    if (v1) {\n        v0 = v2 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v0) {\n        v0 = _round_[_rID_];\n    }\n    if (!v0) {\n        v3 = _plyr_[varg0][2];\n        v4 = v5, v6 = v7, v8 = v9, v10 = 0x4a75(_plyr_[varg0][5]);\n    } else {\n        if (varg0 != _round_[_rID_]) {\n            v11 = _plyr_[varg0][2];\n            v12 = _plyrRnds_[_rID_][2];\n            v8 = v13 = 8125;\n            v14 = v15, v16 = v17, v18 = v19, v6 = v20 = 0x4947(_rID_);\n        } else {\n            v21 = 0x48d0(40, _round_[_rID_][7]);\n            assert(100);\n            require(v21 / 100 + _plyr_[varg0][2] >= _plyr_[varg0][2], Error('SafeMath add failed'));\n            v22 = _plyrRnds_[_rID_][2];\n            v8 = v23 = 8125;\n            v14 = v24, v16 = v25, v18 = v26, v6 = v27 = 0x4947(_rID_);\n        }\n        v4 = _SafeSub(v16, v14);\n    }\n    v28 = _SafeAdd(v4, _plyr_[_rID_][3]);\n    return v8, v28, _plyr_[_rID_][4];\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXnameFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction ourTEAM() public nonPayable { \n    return _ourTEAM;\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    v0 = _rID_;\n    return _round_[v0][9], v0, _round_[v0][5], _round_[v0][2], _round_[v0][4], _round_[v0][7], _round_[v0][1] + 10 * _round_[v0][0], address(_round_[_round_[v0][0]][0]), _round_[_round_[_round_[v0][0]][0]][1], _rndTmEth_[0], _rndTmEth_[1], _rndTmEth_[2], _rndTmEth_[3], _airDropTracker_ + 1000 * _airDropPot_;\n}\n\nfunction reLoadXaddr(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = msg.sender == varg0;\n    }\n    if (!v1) {\n        v3 = v4 = _pIDxAddr_[varg0];\n        if (v4 != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v4;\n            v5 = v6 = 0x3df5(varg1);\n        }\n    } else {\n        v3 = v7 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = v8 = 0x3df5(varg1);\n    v9, v10, v11 = 0x3e1a(v0, varg2, v5, v3);\n}\n\nfunction setOtherFounder(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    _myFounder_[varg0] = 0x1 | ~0xff & _myFounder_[varg0];\n    v5 = 0x48d0(0xde0b6b3a7640000, varg1);\n    _myFounder_PID[varg0] = v5;\n}\n\nfunction buyXid(uint256 varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v10) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction receivePlayerNameList(uint256 varg0, bytes32 varg1) public nonPayable { \n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811 == msg.sender, Error('your not playerNames contract... hmmm..'));\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n}\n\nfunction registerNameXID(string varg0, uint256 varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXIDFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'FoMoKiller';\n    }\n    return v0;\n}\n\nfunction buyXaddr(address varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = msg.sender == varg0;\n    }\n    if (!v10) {\n        if (_pIDxAddr_[varg0] != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxAddr_[varg0];\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1], _plyrRnds_[varg1][2], _plyrRnds_[varg1][3];\n}\n\nfunction buyXname(bytes32 varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v10) {\n        if (_pIDxName_[varg0] != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxName_[varg0];\n            v12 = 0x3df5(varg1);\n        }\n    } else {\n        v13 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v14 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction setOtherFomo(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    require(!_setOtherFomo, Error('silly dev, you already did that'));\n    _setOtherFomo = varg0;\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + _getTimeLeft) {\n            v0 = v2 = _SafeSub(block.timestamp, _getTimeLeft + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0x10670x3009B0x998;\n    }\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[varg0][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[varg0][2];\n        if (block.timestamp > _round_[varg0][2]) {\n            v0 = v3 = block.timestamp > _round_[varg0][2];\n            if (v3) {\n                v0 = !_round_[varg0];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5, v6, v7, v8, v9 = 0x4af3(varg1, 12585, block.timestamp, 0, varg1, varg0);\n    } else {\n        v4 = v10, v11, v12, v13, v14, v15, v16 = 0x4ad2(varg1);\n    }\n    return v4;\n}\n\nfunction iWantXKeys(uint256 varg0) public nonPayable { \n    v0 = v1 = _rID_;\n    v2 = v3 = 0;\n    v4 = v5 = block.timestamp;\n    v6 = v7 = v5 > _round_[v1][4] + _getTimeLeft;\n    if (v7) {\n        v6 = v8 = v5 <= _round_[v1][2];\n        if (v5 > _round_[v1][2]) {\n            v6 = v9 = v5 > _round_[v1][2];\n            if (v9) {\n                v6 = !_round_[v1];\n            }\n        }\n    }\n    if (!v6) {\n        v10 = v11, v12, v13, v14 = 0x4b6b();\n    } else {\n        v15 = _SafeAdd(varg0, _round_[v1][5]);\n        v10 = v16, v17, v18, v19, v20, v4 = v21, v0 = v22, v2 = v23 = 0x3dc8(varg0);\n    }\n    return v10;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction airDropPot_() public nonPayable { \n    return _airDropPot_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    return address(_plyr_[varg0]), _plyr_[varg0][1], _plyr_[varg0][2], _plyr_[varg0][3], _plyr_[varg0][4], _plyr_[varg0][5], _plyr_[varg0][6];\n}\n\nfunction potSwap() public payable { \n    v0 = _SafeAdd(msg.value, _round_[1 + _rID_][7]);\n    _round_[1 + _rID_][7] = v0;\n    emit onPotSwapDeposit(1 + _rID_, msg.value);\n}\n\nfunction getPlayerInfoByAddress(address varg0) public nonPayable { \n    v0 = _pIDxAddr_[varg0];\n    v1 = _pIDxAddr_[v0][1];\n    MEM[0] = v0;\n    MEM[32] = 8;\n    v2, v3, v4, v5 = 0x4a75(_pIDxAddr_[v0][5]);\n    v6 = _SafeAdd(v2, _plyr_[_pIDxAddr_[v0][2]][3]);\n    return 13147, 13117, v5, v4, v6, _plyr_[_pIDxAddr_[v0][2]][4], _plyrRnds_[_pIDxAddr_[v0][2]];\n}\n\nfunction 0xd6d() private { \n    v0 = v1 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32 = 0x39ec();\n            MEM[0 + v8] = MEM[0 + v8] + 0xde0b6b3a7640000 * v9;\n            MEM[32 + v8] = MEM[32 + v8] + v14;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v14][0x1]), msg.value, MEM[0 + v8], MEM[32 + v8], address(MEM[64 + v8]), ~0x0 & (~0x0 & MEM[96 + v8]), MEM[128 + v8], MEM[160 + v8], MEM[192 + v8], MEM[224 + v8]);\n        }\n        v33 = _SafeAdd(msg.value, _plyr_[v14][3]);\n        _plyr_[v14][3] = v33;\n    } else {\n        0x339a(v34, v35, v35, msg.value, v35);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x2186fa4 == v0) {\n            myFounder_PID(address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x11a09ae7 == v0) {\n            airDropTracker_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x3393bc43 == v0) {\n            myFounder_(address);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3ddd4698 == v0) {\n            registerNameXaddr(string,address,bool);\n        } else if (0x49cc635d == v0) {\n            receivePlayerInfo(uint256,address,bytes32,uint256);\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x685ffd83 == v0) {\n            registerNameXname(string,bytes32,bool);\n        } else if (0x6d510a64 == v0) {\n            ourTEAM();\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x88dfee60 == v0) {\n            setOtherFounder(address,uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x8f7140ea == v0) {\n            receivePlayerNameList(uint256,bytes32);\n        } else if (0x921dec21 == v0) {\n            registerNameXID(string,uint256,bool);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xb483c054 == v0) {\n            setOtherFomo(address);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xd87574e0 == v0) {\n            airDropPot_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xed78cf4a == v0) {\n            potSwap();\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.03 01:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_1; // STORAGE[0x1]\nuint256 _getTimeLeft; // STORAGE[0x2]\nuint256 _airDropPot_; // STORAGE[0x3]\nuint256 _airDropTracker_; // STORAGE[0x4]\nuint256 _rID_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyr_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _myFounder_; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _myFounder_PID; // STORAGE[0x11]\nuint256 _setOtherFomo; // STORAGE[0x0] bytes 0 to 19\nuint256 _activated_; // STORAGE[0x12] bytes 0 to 0\nuint256 _ourTEAM; // STORAGE[0xf] bytes 0 to 19\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1]\nuint256 stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3; // STORAGE[0x72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3]\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonPotSwapDeposit(uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonAffiliatePayout(uint256, address, bytes32, uint256, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256, uint256);\n\nfunction () public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = _pIDxAddr_[_pIDxAddr_[msg.sender]][6];\n    0xd6d();\n}\n\nfunction 0x339a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg1 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        varg1 = v2 = 13261;\n        v3 = new struct(9);\n        v3.word0 = 0;\n        v3.word1 = 0;\n        v3.word2 = 0;\n        v3.word3 = 0;\n        v3.word4 = 0;\n        v3.word5 = 0;\n        v3.word6 = 0;\n        v3.word7 = 0;\n        v3.word8 = 0;\n        if (_plyr_[varg4][5]) {\n            v4, varg1 = v5, varg1 = v6 = 0x5163(_plyr_[varg4][5]);\n        }\n        _plyr_[varg1][5] = _rID_;\n        MEM[v7] += 10;\n    }\n    v8 = v9 = 0x56bc75e2d63100000 > _round_[varg1][6];\n    if (v9) {\n        v10 = _SafeAdd(varg1, _plyrRnds_[varg1]);\n        v8 = v11 = v10 > 0xde0b6b3a7640000;\n    }\n    if (v8) {\n        varg1 = v12 = _SafeSub(_plyrRnds_[varg1], 0xde0b6b3a7640000);\n        varg1 = v13 = _SafeSub(v12, varg1);\n        v14 = _SafeAdd(v13, _plyr_[varg1][3]);\n        _plyr_[varg1][3] = v14;\n    }\n    if (varg1 > 0x3b9aca00) {\n        varg1 = v15 = 13535;\n        v16 = v17, v18 = v19, v20, v21, v22, varg1 = v23, varg1 = v24 = 0x4ad2(varg1);\n        if (v17 >= 0xde0b6b3a7640000) {\n            v18 = v25, v16 = v26, v27 = 0x4c37(varg1, v17, 13562, v19, v17, v21, v22, v23, v24, v15, varg1);\n            if (varg1 != _round_[varg1]) {\n                _round_[varg1] = varg1;\n            }\n            if (varg1 != _round_[varg1][1]) {\n                _round_[varg1][1] = varg1;\n            }\n            MEM[varg1] += 100;\n        }\n        if (varg1 >= 0x16345785d8a0000) {\n            _airDropTracker_ += 1;\n            v28 = v29 = 10000 == _airDropTracker_;\n            if (10000 != _airDropTracker_) {\n                v28 = v30 = 0x186a0 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v31 = 0xf4240 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v32 = 0x989680 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = v33 = 0x5f5e100 == _airDropTracker_;\n            }\n            if (!v28) {\n                v28 = 0x3b9aca00 == _airDropTracker_;\n            }\n            if (!v28) {\n                v34 = v35 = 0;\n            } else {\n                v34 = 1;\n            }\n            if (1 == v34) {\n                if (varg1 < 0x8ac7230489e80000) {\n                    v36 = v37 = varg1 >= 0xde0b6b3a7640000;\n                    if (v37) {\n                        v36 = v38 = varg1 < 0x8ac7230489e80000;\n                    }\n                    if (!v36) {\n                        v39 = v40 = varg1 >= 0x16345785d8a0000;\n                        if (v40) {\n                            v39 = v41 = varg1 < 0xde0b6b3a7640000;\n                        }\n                        if (v39) {\n                            v42 = 0x48d0(25, _airDropPot_);\n                            assert(100);\n                            v18 = v43 = v42 / 100;\n                            v44 = _SafeAdd(v43, _plyr_[varg1][2]);\n                            _plyr_[varg1][2] = v44;\n                            v45 = _SafeSub(v43, _airDropPot_);\n                            _airDropPot_ = v45;\n                            MEM[varg1] += 0xeca8847c4129106ce8300000000;\n                        }\n                    } else {\n                        v46 = 0x48d0(50, _airDropPot_);\n                        assert(100);\n                        v18 = v47 = v46 / 100;\n                        v48 = _SafeAdd(v47, _plyr_[varg1][2]);\n                        _plyr_[varg1][2] = v48;\n                        v49 = _SafeSub(v47, _airDropPot_);\n                        _airDropPot_ = v49;\n                        MEM[varg1] += 0x9dc5ada82b70b59df0200000000;\n                    }\n                } else {\n                    v50 = 0x48d0(75, _airDropPot_);\n                    assert(100);\n                    v18 = v51 = v50 / 100;\n                    v52 = _SafeAdd(v51, _plyr_[varg1][2]);\n                    _plyr_[varg1][2] = v52;\n                    v53 = _SafeSub(v51, _airDropPot_);\n                    _airDropPot_ = v53;\n                    MEM[varg1] += 0xeca8847c4129106ce8300000000;\n                }\n                MEM[varg1] = 0x7e37be2022c0914b2680000000 + (v18 * 0x314dc6448d9338c15b0a00000000 + MEM[varg1]);\n            }\n        }\n        MEM[varg1] += _airDropTracker_ * 1000;\n        if (_myFounder_PID[varg1] > 0) {\n            v54 = _SafeAdd(_plyrRnds_[varg1][1], _plyrRnds_[varg1]);\n            _plyrRnds_[varg1][1] = v54;\n            v55 = _SafeAdd(_plyrRnds_[varg1][5], _plyrRnds_[varg1]);\n            _round_[varg1][5] = v55;\n            _round_[varg1] = 0;\n        }\n        v56 = _SafeAdd(_plyrRnds_[varg1][1], v16);\n        _plyrRnds_[varg1][1] = v56;\n        v57 = _SafeAdd(_plyrRnds_[varg1], varg1);\n        _plyrRnds_[varg1] = v57;\n        v58 = _SafeAdd(_plyrRnds_[varg1][5], v16);\n        _round_[varg1][5] = v58;\n        v59 = _SafeAdd(_round_[varg1][6], varg1);\n        _round_[varg1][6] = v59;\n        v60 = _SafeAdd(_rndTmEth_[varg1], varg1);\n        _rndTmEth_[varg1] = v60;\n        v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80 = 0x4d7f(varg1, varg1, varg1, varg1, varg1, varg1, 14785);\n        v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, varg1 = v92, v93, v94, v95, v96, v97, v98, v99, v100 = 0x4ef3(v66, v63, v67, v61, v70);\n        MEM[0 + v81] = MEM[0 + v81] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * v87;\n        MEM[32 + v81] = MEM[32 + v81] + v90 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + v81], MEM[32 + v81], ~0x0 & (~0x0 & _plyr_[v90][0x1]), msg.sender, v89, v83, address(MEM[64 + v81]), ~0x0 & (~0x0 & MEM[96 + v81]), MEM[128 + v81], MEM[160 + v81], MEM[192 + v81], MEM[224 + v81], MEM[256 + v81], _airDropPot_);\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5 = 0x44364c5bb000;\n    } else {\n        v6 = _SafeAdd(0xde0b6b3a7640000, _round_[_rID_][5]);\n        v4 = v7, v8, v9, v10, v11, v12, v13, v14 = 0x3dc8(0xde0b6b3a7640000);\n        goto 0x10670xfa7B0x3a2;\n    }\n    return v4;\n}\n\nfunction 0x39ec() private { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    v0 = v1 = _rID_;\n    v0 = v2 = 0;\n    v0 = v3 = _round_[v1];\n    v0 = v4 = _round_[v1][1];\n    v0 = v5 = _round_[v1][7];\n    v6 = 0x48d0(40, v5);\n    assert(100);\n    v0 = v7 = v6 / 100;\n    v0 = v8 = v5 / 10;\n    v9 = 0x48d0(_potSplit_[v4], v5);\n    assert(100);\n    v0 = v10 = v9 / 100;\n    v0 = v11 = 0;\n    v0 = v12 = 14988;\n    v0 = v13 = 8125;\n    v0 = v14 = _SafeSub(v7, v5);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v15 = 20336;\n        v0, v16, v0 = v17, v0, v0, v0 = v18, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v19 = _round_[v0][7];\n        v0 = v20 = 20404;\n        v0 = v21 = _SafeAdd(v0, v17);\n        v19 = _SafeAdd(v19, v21);\n        v0, v0 = v22, v0 = v23, v0, v0 = v24 = 0x51fa(v19);\n        0x4cb7(v19, v0, v0, v0);\n    }\n    v25 = _ourTEAM.call().value(v0).gas(2300 * !v0);\n    require(v25); // checks call status, propagates error data on error\n    v26 = 0x48d0(0xde0b6b3a7640000, v0);\n    assert(_round_[v0][5]);\n    v27 = 0x48d0(_round_[v0][5], v26 / _round_[v0][5]);\n    assert(0xde0b6b3a7640000);\n    require(v27 / 0xde0b6b3a7640000 <= v0, Error('SafeMath sub failed'));\n    return v0 - v27 / 0xde0b6b3a7640000, v0, v26 / _round_[v0][5], v0, v0, v0, v0, v0, v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v19;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v19 + v0 >= v0, Error('SafeMath add failed'));\n    return v19 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    if (v19 > 0) {\n        _plyr_[v0][2] = 0;\n        _plyr_[v0][3] = 0;\n        _plyr_[v0][4] = 0;\n    }\n    return v19, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v28 = _SafeAdd(v0, 0x15180);\n    if (v19 >= v28) {\n        v29 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v29;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v19;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v19;\n    v30 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v30;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction myFounder_PID(address varg0) public nonPayable { \n    return _myFounder_PID[varg0];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, Error('SafeMath add failed'));\n    return v0;\n}\n\nfunction 0x3dc8(uint256 varg0) private { \n    v0 = _SafeSub(varg0, v1);\n    v2, v3, v4, v5 = 0x4b6b();\n    v6, v7, v8, v9 = 0x4b6b();\n    v10 = _SafeSub(v7, v6);\n    return v10, v4, v5, 15845, 15854, 0, varg0, v1;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'FoMoKiller long';\n    }\n    return v0;\n}\n\nfunction 0x3df5(uint256 varg0) private { \n    v0 = v1 = varg0 < 0;\n    if (varg0 >= 0) {\n        v0 = v2 = varg0 > 3;\n    }\n    if (v0) {\n        varg0 = v3 = 2;\n    }\n    return varg0;\n}\n\nfunction 0x3e1a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = v1 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32 = 0x39ec();\n            MEM[0 + v8] = MEM[0 + v8] + 0xde0b6b3a7640000 * v9;\n            MEM[32 + v8] = MEM[32 + v8] + v15;\n            emit onReLoadAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v15][0x1]), MEM[0 + v8], MEM[32 + v8], address(MEM[64 + v8]), ~0x0 & (~0x0 & MEM[96 + v8]), MEM[128 + v8], MEM[160 + v8], MEM[192 + v8], MEM[224 + v8]);\n            return v17, v18, v19;\n        }\n    } else {\n        v33, v34, v35, v36 = 0x4036(v37, 8125, varg1, 16023, block.timestamp, _rID_, varg0);\n        v38 = _SafeSub(v34, v33);\n        STORAGE[3 + keccak256(_rID_, 8)] = v38;\n        0x339a(varg3, v39, v39, v37, v39);\n        goto 0x1af50x3e1a;\n    }\n    return;\n}\n\nfunction 0x4036(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0, v1, v2 = 0x5163(_plyr_[varg0][5]);\n    v3 = _SafeAdd(_plyr_[v2][3], _plyr_[v2][2]);\n    v4 = _SafeAdd(_plyr_[v2][4], v3);\n    _round_[varg4][2] = v4;\n    _round_[varg4][7] = v2;\n    _airDropTracker_ = 0;\n    if (v4 > 0) {\n        _plyr_[v2][2] = 0;\n        _plyr_[v2][3] = 0;\n        _plyr_[v2][4] = 0;\n    }\n    return v4, 0, 0, varg0;\n}\n\nfunction 0x40bd(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, Error('string must be between 1 and 32 characters'));\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[varg0.length - 1] >> 248 << 248;\n    }\n    require(v5, Error('string cannot start or end with space'));\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248, Error('string cannot start with 0x'));\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1] >> 248 << 248, Error('string cannot start with 0X'));\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, Error('string contains invalid characters'));\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[1 + v8] >> 248 << 248, Error('string cannot contain consecutive spaces'));\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0[v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (varg0[v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, Error('string cannot be only numbers'));\n    return MEM[varg0.data];\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v1) {\n        v3 = v4 = _pIDxName_[varg0];\n        if (v4 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v4;\n        }\n    } else {\n        v3 = v5 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v6 = 0x3df5(varg1);\n    v7, v8, v9 = 0x3e1a(v0, varg2, v6, v3);\n}\n\nfunction activate() public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    require(stor_0_0_0, Error('must link to other FoMo3D first'));\n    require(!_activated_, Error('fomo3d already activated'));\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 11;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d3 = stor_1 + block.timestamp - _getTimeLeft;\n    stor_72c6bfb7988af3a1efa6568f02a999bc52252641c659d85961ca3d372b57d5d1 = 0x15180 + (stor_1 + block.timestamp);\n}\n\nfunction 0x48d0(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, Error('SafeMath mul failed'));\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0x4947(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[v0][1];\n    varg0 = v3 = _plyrRnds_[v0][5];\n    v4 = _plyrRnds_[v0][1];\n    MEM[v1] = varg0;\n    MEM[32] = 11;\n    varg0 = v5 = 0xde0b6b3a7640000;\n    v0 = v6 = 18948;\n    v0 = v7 = 18936;\n    v0 = v8 = 18895;\n    v9 = 0x48d0(_plyrRnds_[v0], _plyrRnds_[v0][7]);\n    assert(100);\n    v10 = v11 = v9 / 100;\n    while (1) {\n        if (v10) {\n            goto 0x48e10x4947;\n        }\n        v10 = v12 = 0;\n        while (1) {\n            goto {'0x49f80x4947', '0x49cf', '0x4a04'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v13 = _round_[varg0][8];\n            v10 = v10 / varg0 + v13;\n            require(v10 >= v13, Error('SafeMath add failed'));\n        }\n        continue;\n        v10 *= varg0;\n        assert(v10);\n        require(v10 / v10 == varg0, Error('SafeMath mul failed'));\n    }\n    assert(varg0);\n    return v10 / varg0, v0, varg0, v0;\n}\n\nfunction 0x49c2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    if (v0) {\n        v1 = varg2 * v0;\n        assert(v0);\n        require(v1 / v0 == varg2, Error('SafeMath mul failed'));\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, Error('SafeMath sub failed'));\n    return varg1 - varg0;\n}\n\nfunction 0x4a75(uint256 varg0) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = 0x48d0(_plyrRnds_[varg0][1], _plyrRnds_[varg0][8]);\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v1 / 0xde0b6b3a7640000, Error('SafeMath sub failed'));\n    return v1 / 0xde0b6b3a7640000 - v0, 0, varg0, v2;\n}\n\nfunction 0x4ad2(uint256 varg0) private { \n    v0, v1, v2, v3, v4 = 0x4af3(v5, 19168, 15854, 0, varg0, v5);\n    require(v3 + v4 >= v4, Error('SafeMath add failed'));\n    return v3 + v4, 8125, v0, v1, v2, v3, v4;\n}\n\nfunction 0x4af3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7) private { \n    v0 = v1 = 0;\n    v0 = v2 = 0x9502f90;\n    v0 = v3 = 19291;\n    v0 = v4 = 0x3b2a1d15167e7c5699bfde00000;\n    v0 = v5 = 8125;\n    v0 = v6 = 19286;\n    v7 = v8 = 0xdac7055469777a6122ee4310dd6c14410500f2904840000000000;\n    v9 = 0x48d0(0xde0b6b3a7640000, varg0);\n    v0 = v10 = 0x48d0(0x1027e72f1f1281308800000, v9);\n    while (1) {\n        v7 = _SafeAdd(v7, v0);\n        v0, v0 = v11, v0 = v12, v0, v0 = 0x51fa(v7);\n        v0 = _SafeSub(v0, v0);\n        v0 = v13 = 20336;\n        v0, v14, v0 = v15, v0, v0, v0 = v16, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v7 = _round_[v0][7];\n        v0 = v17 = 20404;\n        v0 = _SafeAdd(v0, v15);\n        0x4cb7(v7, v0, v0, v0);\n    }\n    _round_[v0][2] = v7;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0;\n    require(v7 + v0 >= v0, Error('SafeMath add failed'));\n    return v7 + v0, v0, v0, v0, v0;\n    require(v0 <= v0, Error('SafeMath sub failed'));\n    return v0 - v0, v0, v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0;\n    v18 = _SafeAdd(v0, 0x15180);\n    if (v7 >= v18) {\n        v19 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v19;\n        return v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v7;\n        return v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v7;\n    v20 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v20;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0;\n}\n\nfunction 0x4b6b() private { \n    v0 = 0x524d(0xde0b6b3a7640000);\n    v1 = 0x48d0(0xde0b6b3a7640000, v2);\n    v3 = 0x48d0(v1, 0x886c8f673070);\n    assert(2);\n    v4 = 0x524d(v2);\n    v5 = 0x48d0(v4, 0x4a817c8);\n    require((v3 >> 1) + v5 >= v5, Error('SafeMath add failed'));\n    return (v3 >> 1) + v5, v0, 0, v2;\n}\n\nfunction airDropTracker_() public nonPayable { \n    return _airDropTracker_;\n}\n\nfunction 0x4c37(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10) private { \n    v0 = v1 = 0;\n    v0 = v2 = block.timestamp;\n    v3 = v4 = v2 > _round_[varg0][2];\n    if (v4) {\n        v3 = v5 = !_round_[varg0];\n    }\n    if (!v3) {\n        v0 = v6 = _round_[varg0][2];\n        v0 = v7 = 19636;\n        v0 = v8 = 0x49c2(varg1, 0xde0b6b3a7640000, 30);\n    } else {\n        v0 = v9 = 19587;\n        v0 = v10 = 0x49c2(varg1, 0xde0b6b3a7640000, 30);\n    }\n    while (1) {\n        v0 = _SafeAdd(v0, v0);\n        v0, v0 = v11, v0 = v12, v0, v13 = 0x51fa(v0);\n        v0 = _SafeSub(v0, v0);\n        v0 = v14 = 20336;\n        v0, v15, v0 = v16, v0, v0, v0 = v17, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v0 = v18 = _round_[v0][7];\n        v0 = v19 = 20404;\n        v0 = _SafeAdd(v0, v16);\n        0x4cb7(v0, v0, v0, v0);\n    }\n    _round_[v0][2] = v0;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0;\n    require(v0 + v0 >= v0, Error('SafeMath add failed'));\n    return v0 + v0, v0, v0;\n    assert(v0);\n    return v0 / v0, v0, v0;\n    return v0, v0, v0;\n    v20 = _SafeAdd(v0, 0x15180);\n    if (v0 >= v20) {\n        v21 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v21;\n        return v0, v0, v0;\n    } else {\n        _round_[v0][2] = v0;\n        return v0, v0, v0;\n    }\n    _round_[v0][7] = v0;\n    v22 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v22;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0;\n}\n\nfunction 0x4cb7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = _SafeAdd(varg1, 0x15180);\n    if (varg0 >= v0) {\n        v1 = _SafeAdd(varg1, 0x15180);\n        _round_[varg2][2] = v1;\n        return ;\n    } else {\n        _round_[varg2][2] = varg0;\n        return ;\n    }\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    return _round_[varg0], _round_[varg0][1], _round_[varg0][2], _round_[varg0][0x3] & 0xff, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10], _round_[varg0][11];\n}\n\nfunction 0x4d7f(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    v0 = v1 = 0;\n    v2 = 0x48d0(3, varg3);\n    assert(100);\n    v3 = _ourTEAM.call().value(v2 / 100).gas(2300 * !(v2 / 100));\n    require(v3); // checks call status, propagates error data on error\n    v0 = v4 = varg3 / 10;\n    v5 = varg4 == varg2;\n    v6 = v7 = varg4 != varg2;\n    if (varg4 != varg2) {\n        v6 = v8 = _plyr_[varg2][1];\n    }\n    if (v6) {\n        v9 = address(_plyr_[varg2]);\n        if (0xff & _myFounder_[varg2]) {\n            v0 = v10 = varg3 / 5;\n        }\n        v11 = _SafeAdd(_plyr_[varg2][4], v0);\n        _plyr_[varg2][4] = v11;\n        v12 = _plyr_[varg2][1];\n        v13 = address(_plyr_[varg2]);\n        emit onAffiliatePayout(varg2, varg5, varg4, v13, v12, v0, block.timestamp);\n    }\n    v0 = v14 = 20198;\n    v0 = v15 = _SafeSub(v2 / 100, varg3);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v16 = 20336;\n        v0, v17, v0 = v18, v0, v0, v0 = v19, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v20 = _round_[v0][7];\n        v0 = v21 = 20404;\n        v0 = v22 = _SafeAdd(v0, v18);\n        v20 = _SafeAdd(v20, v22);\n        v0, v0 = v23, v0 = v24, v0, v25 = 0x51fa(v20);\n        0x4cb7(v20, v0, v0, v0);\n    }\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v20;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v20 + v0 >= v0, Error('SafeMath add failed'));\n    return v20 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v26 = _SafeAdd(v0, 0x15180);\n    if (v20 >= v26) {\n        v27 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v27;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v20;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v20;\n    v28 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v28;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction 0x4ef3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    v0 = v2 = 0;\n    v3 = 0x48d0(_fees_[varg2], varg3);\n    assert(100);\n    v0 = v4 = v3 / 100;\n    v0 = v5 = varg3 / 100;\n    v6 = _SafeAdd(v5, _airDropPot_);\n    _airDropPot_ = v6;\n    v0 = v7 = 20322;\n    v0 = v8 = _SafeSub(v4, varg3);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        v0 = v9 = 20336;\n        v0, v10, v0 = v11, v0, v0, v0 = v12, v0, v0, v0, v0 = 0x5259(v0, v0, v0);\n        if (v0 > 0) {\n            v0 = _SafeSub(v0, v0);\n        }\n        v13 = _round_[v0][7];\n        v0 = v14 = 20404;\n        v0 = v15 = _SafeAdd(v0, v11);\n        v13 = _SafeAdd(v13, v15);\n        v0, v0 = v16, v0 = v17, v0, v18 = 0x51fa(v13);\n        0x4cb7(v13, v0, v0, v0);\n    }\n    assert(v0);\n    return v0 / v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    _round_[v0][2] = v13;\n    _round_[v0][7] = v0;\n    _airDropTracker_ = 0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    require(v13 + v0 >= v0, Error('SafeMath add failed'));\n    return v13 + v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    v19 = _SafeAdd(v0, 0x15180);\n    if (v13 >= v19) {\n        v20 = _SafeAdd(v0, 0x15180);\n        _round_[v0][2] = v20;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    } else {\n        _round_[v0][2] = v13;\n        return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n    }\n    _round_[v0][7] = v13;\n    v21 = _SafeAdd(MEM[v0 + 224], v0);\n    MEM[v0 + 224] = v21;\n    MEM[v0 + 256] = v0;\n    return v0, v0, v0, v0, v0, v0, v0, v0, v0, v0, v0;\n}\n\nfunction 0x5163(uint256 varg0) private { \n    v0, v1, v2, v3 = 0x4a75(varg0);\n    if (v0 > 0) {\n        v4 = _SafeAdd(_plyr_[v3][3], v0);\n        _plyr_[v3][3] = v4;\n        v5 = _SafeAdd(_plyrRnds_[v3][2], v0);\n        _plyrRnds_[v3][2] = v5;\n    }\n    return 0, varg0, v6;\n}\n\nfunction 0x51fa(uint256 varg0) private { \n    v0 = _SafeAdd(1, varg0);\n    assert(2);\n    if (v0 >> 1 >= varg0) {\n        return varg0;\n    } else {\n        assert(v0 >> 1);\n        v1 = varg0 / (v0 >> 1);\n        require((v0 >> 1) + v1 >= v1, Error('SafeMath add failed'));\n        return (v0 >> 1) + v1, 2, v0 >> 1, v0 >> 1, varg0;\n    }\n}\n\nfunction 0x524d(uint256 varg0) private { \n    v0 = 0x48d0(varg0, varg0);\n    return v0;\n}\n\nfunction 0x5259(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = _round_[v1][5];\n    v2 = 0x48d0(0xde0b6b3a7640000, varg1);\n    assert(v0);\n    v3 = _SafeAdd(_round_[v1][8], v2 / v0);\n    _round_[v1][8] = v3;\n    v4 = 0x48d0(varg0, v2 / v0);\n    assert(0xde0b6b3a7640000);\n    v5 = 0x48d0(varg0, _plyrRnds_[varg2][8]);\n    assert(0xde0b6b3a7640000);\n    require(v4 / 0xde0b6b3a7640000 <= v5 / 0xde0b6b3a7640000, Error('SafeMath sub failed'));\n    return v5 / 0xde0b6b3a7640000 - v4 / 0xde0b6b3a7640000, _plyrRnds_[varg2][2], 21311, v4 / 0xde0b6b3a7640000, v2 / v0, 0, varg0, varg1, varg2, v1;\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction myFounder_(address varg0) public nonPayable { \n    return 0xff & _myFounder_[varg0];\n}\n\nfunction reLoadXid(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v1) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v3 = v4 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = 0x3df5(varg1);\n    v6, v7, v8 = 0x3e1a(v0, varg2, v5, v3);\n}\n\nfunction withdraw() public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v1 = v2 = block.timestamp > _round_[msg.sender][2];\n    if (v2) {\n        v1 = v3 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v1) {\n        v1 = _round_[_rID_];\n    }\n    if (!v1) {\n        v4, v5, v6, v7 = 0x4036(_pIDxAddr_[msg.sender], 6728, msg.sender.code.size, msg.sender, v0, 0, _pIDxAddr_[msg.sender]);\n        if (v4 > 0) {\n            v8 = address(STORAGE[keccak256(_rID_, 0x8)]).call().value(v4).gas(2300 * !v4);\n            require(v8); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(v9, msg.sender, STORAGE[1 + keccak256(_rID_, 8)], v4);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34 = 0x39ec();\n        v35, v36, v37, v38 = 0x4036(v15, 6350, v11, v12, v10, v14, v15);\n        if (v35 > 0) {\n            v39 = address(_plyr_[v18]).call().value(v35).gas(2300 * !v35);\n            require(v39); // checks call status, propagates error data on error\n        }\n        MEM[0 + v38] = MEM[0 + v38] + 0xde0b6b3a7640000 * v19;\n        MEM[32 + v38] = MEM[32 + v38] + v18;\n        emit 0xbd0dba8ab932212fa78150cdb7b0275da72e255875967b5cad11464cf71bedc(msg.sender, ~0x0 & (~0x0 & _plyr_[v18][0x1]), v35, MEM[0 + v38], MEM[32 + v38], address(MEM[64 + v38]), ~0x0 & (~0x0 & MEM[96 + v38]), MEM[128 + v38], MEM[160 + v38], MEM[192 + v38], MEM[224 + v38]);\n    }\n}\n\nfunction registerNameXaddr(string varg0, address varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXaddrFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction receivePlayerInfo(uint256 varg0, address varg1, bytes32 varg2, uint256 varg3) public nonPayable { \n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811 == msg.sender, Error('your not playerNames contract... hmmm..'));\n    if (varg0 != _pIDxAddr_[varg1]) {\n        _pIDxAddr_[varg1] = varg0;\n    }\n    if (varg0 != _pIDxName_[varg2]) {\n        _pIDxName_[varg2] = varg0;\n    }\n    if (address(_plyr_[varg0]) != varg1) {\n        _plyr_[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _plyr_[varg0];\n    }\n    if (varg2 != _plyr_[varg0][1]) {\n        _plyr_[varg0][1] = varg2;\n    }\n    if (varg3 != _plyr_[varg0][6]) {\n        _plyr_[varg0][6] = varg3;\n    }\n    if (!(0xff & _plyrNames_[varg2])) {\n        _plyrNames_[varg2] = 0x1 | ~0xff & _plyrNames_[varg2];\n    }\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 varg0) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[_rID_][2];\n    if (v1) {\n        v0 = v2 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v0) {\n        v0 = _round_[_rID_];\n    }\n    if (!v0) {\n        v3 = _plyr_[varg0][2];\n        v4 = v5, v6 = v7, v8 = v9, v10 = 0x4a75(_plyr_[varg0][5]);\n    } else {\n        if (varg0 != _round_[_rID_]) {\n            v11 = _plyr_[varg0][2];\n            v12 = _plyrRnds_[_rID_][2];\n            v8 = v13 = 8125;\n            v14 = v15, v16 = v17, v18 = v19, v6 = v20 = 0x4947(_rID_);\n        } else {\n            v21 = 0x48d0(40, _round_[_rID_][7]);\n            assert(100);\n            require(v21 / 100 + _plyr_[varg0][2] >= _plyr_[varg0][2], Error('SafeMath add failed'));\n            v22 = _plyrRnds_[_rID_][2];\n            v8 = v23 = 8125;\n            v14 = v24, v16 = v25, v18 = v26, v6 = v27 = 0x4947(_rID_);\n        }\n        v4 = _SafeSub(v16, v14);\n    }\n    v28 = _SafeAdd(v4, _plyr_[_rID_][3]);\n    return v8, v28, _plyr_[_rID_][4];\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXnameFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction ourTEAM() public nonPayable { \n    return _ourTEAM;\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    v0 = _rID_;\n    return _round_[v0][9], v0, _round_[v0][5], _round_[v0][2], _round_[v0][4], _round_[v0][7], _round_[v0][1] + 10 * _round_[v0][0], address(_round_[_round_[v0][0]][0]), _round_[_round_[_round_[v0][0]][0]][1], _rndTmEth_[0], _rndTmEth_[1], _rndTmEth_[2], _rndTmEth_[3], _airDropTracker_ + 1000 * _airDropPot_;\n}\n\nfunction reLoadXaddr(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(varg2 >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(varg2 <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = v2 = !varg0;\n    if (varg0) {\n        v1 = msg.sender == varg0;\n    }\n    if (!v1) {\n        v3 = v4 = _pIDxAddr_[varg0];\n        if (v4 != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = v4;\n            v5 = v6 = 0x3df5(varg1);\n        }\n    } else {\n        v3 = v7 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v5 = v8 = 0x3df5(varg1);\n    v9, v10, v11 = 0x3e1a(v0, varg2, v5, v3);\n}\n\nfunction setOtherFounder(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    _myFounder_[varg0] = 0x1 | ~0xff & _myFounder_[varg0];\n    v5 = 0x48d0(0xde0b6b3a7640000, varg1);\n    _myFounder_PID[varg0] = v5;\n}\n\nfunction buyXid(uint256 varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = varg0 == _pIDxAddr_[msg.sender];\n    }\n    if (!v10) {\n        if (varg0 != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = varg0;\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction receivePlayerNameList(uint256 varg0, bytes32 varg1) public nonPayable { \n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811 == msg.sender, Error('your not playerNames contract... hmmm..'));\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n}\n\nfunction registerNameXID(string varg0, uint256 varg1, bool varg2) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    v2 = 0x40bd(v0);\n    require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n    v3, v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.registerNameXIDFromDapp(msg.sender, v2, varg1, varg2).value(msg.value).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 64);\n    emit onNewName(_pIDxAddr_[msg.sender], msg.sender, v2, v4, v5, address(_pIDxAddr_[v5]), _pIDxAddr_[v5][1], msg.value, block.timestamp);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & 'FoMoKiller';\n    }\n    return v0;\n}\n\nfunction buyXaddr(address varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = msg.sender == varg0;\n    }\n    if (!v10) {\n        if (_pIDxAddr_[varg0] != _pIDxAddr_[varg0][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxAddr_[varg0];\n        }\n    } else {\n        v12 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v13 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1], _plyrRnds_[varg1][2], _plyrRnds_[varg1][3];\n}\n\nfunction buyXname(bytes32 varg0, uint256 varg1) public payable { \n    v0 = new struct(9);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = 0;\n    v0.word6 = 0;\n    v0.word7 = 0;\n    v0.word8 = 0;\n    require(1 == _activated_, Error('its not ready yet.  check ?eta in discord'));\n    require(!msg.sender.code.size, Error('sorry humans only'));\n    require(msg.value >= 0x3b9aca00, Error('pocket lint: not a valid currency'));\n    require(msg.value <= 0x152d02c7e14af6800000, Error('no vitalik, no'));\n    v1 = new struct(9);\n    v1.word0 = 0;\n    v1.word1 = 0;\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v1.word4 = 0;\n    v1.word5 = 0;\n    v1.word6 = 0;\n    v1.word7 = 0;\n    v1.word8 = 0;\n    if (!_pIDxAddr_[msg.sender]) {\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v2, v3 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerID(msg.sender).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v4, v5 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerName(v3).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(0x8727455a941d4f95e20a4c76ec3aef019fe73811.code.size);\n        v6, v7 = 0x8727455a941d4f95e20a4c76ec3aef019fe73811.getPlayerLAff(v3).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        _pIDxAddr_[msg.sender] = v3;\n        _pIDxAddr_[msg.sender] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pIDxAddr_[msg.sender];\n        if (v5) {\n            _pIDxName_[v5] = v3;\n            _plyr_[v5][1] = v5;\n            _plyrNames_[v5] = 0x1 | ~0xff & _plyrNames_[v5];\n        }\n        v8 = v9 = v7;\n        if (v7) {\n            v8 = v7 != v3;\n        }\n        if (v8) {\n            _plyr_[v3][6] = v7;\n        }\n        v0.word0 += 1;\n    }\n    v10 = v11 = !varg0;\n    if (varg0) {\n        v10 = varg0 == _plyr_[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v10) {\n        if (_pIDxName_[varg0] != _plyr_[_pIDxAddr_[msg.sender]][6]) {\n            _plyr_[_pIDxAddr_[msg.sender]][6] = _pIDxName_[varg0];\n            v12 = 0x3df5(varg1);\n        }\n    } else {\n        v13 = _plyr_[_pIDxAddr_[msg.sender]][6];\n    }\n    v14 = 0x3df5(varg1);\n    0xd6d();\n}\n\nfunction setOtherFomo(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93;\n    if (msg.sender != 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93) {\n        v0 = v2 = msg.sender == 0xfb31eb7b96e413bebee61f5e3880938b937c2ef0;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == 0xea8a4f09c45967dfcfda180fa80ad44eefab52be;\n    }\n    if (!v0) {\n        v0 = v4 = msg.sender == 0xf1e32a3eaa5d6c360af6aa2c45a97e377be183bd;\n    }\n    require(v0, Error('only team just can activate'));\n    require(!_setOtherFomo, Error('silly dev, you already did that'));\n    _setOtherFomo = varg0;\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + _getTimeLeft) {\n            v0 = v2 = _SafeSub(block.timestamp, _getTimeLeft + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0x10670x3009B0x998;\n    }\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = block.timestamp > _round_[varg0][4] + _getTimeLeft;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[varg0][2];\n        if (block.timestamp > _round_[varg0][2]) {\n            v0 = v3 = block.timestamp > _round_[varg0][2];\n            if (v3) {\n                v0 = !_round_[varg0];\n            }\n        }\n    }\n    if (!v0) {\n        v4 = v5, v6, v7, v8, v9 = 0x4af3(varg1, 12585, block.timestamp, 0, varg1, varg0);\n    } else {\n        v4 = v10, v11, v12, v13, v14, v15, v16 = 0x4ad2(varg1);\n    }\n    return v4;\n}\n\nfunction iWantXKeys(uint256 varg0) public nonPayable { \n    v0 = v1 = _rID_;\n    v2 = v3 = 0;\n    v4 = v5 = block.timestamp;\n    v6 = v7 = v5 > _round_[v1][4] + _getTimeLeft;\n    if (v7) {\n        v6 = v8 = v5 <= _round_[v1][2];\n        if (v5 > _round_[v1][2]) {\n            v6 = v9 = v5 > _round_[v1][2];\n            if (v9) {\n                v6 = !_round_[v1];\n            }\n        }\n    }\n    if (!v6) {\n        v10 = v11, v12, v13, v14 = 0x4b6b();\n    } else {\n        v15 = _SafeAdd(varg0, _round_[v1][5]);\n        v10 = v16, v17, v18, v19, v20, v4 = v21, v0 = v22, v2 = v23 = 0x3dc8(varg0);\n    }\n    return v10;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction airDropPot_() public nonPayable { \n    return _airDropPot_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    return address(_plyr_[varg0]), _plyr_[varg0][1], _plyr_[varg0][2], _plyr_[varg0][3], _plyr_[varg0][4], _plyr_[varg0][5], _plyr_[varg0][6];\n}\n\nfunction potSwap() public payable { \n    v0 = _SafeAdd(msg.value, _round_[1 + _rID_][7]);\n    _round_[1 + _rID_][7] = v0;\n    emit onPotSwapDeposit(1 + _rID_, msg.value);\n}\n\nfunction getPlayerInfoByAddress(address varg0) public nonPayable { \n    v0 = _pIDxAddr_[varg0];\n    v1 = _pIDxAddr_[v0][1];\n    MEM[0] = v0;\n    MEM[32] = 8;\n    v2, v3, v4, v5 = 0x4a75(_pIDxAddr_[v0][5]);\n    v6 = _SafeAdd(v2, _plyr_[_pIDxAddr_[v0][2]][3]);\n    return 13147, 13117, v5, v4, v6, _plyr_[_pIDxAddr_[v0][2]][4], _plyrRnds_[_pIDxAddr_[v0][2]];\n}\n\nfunction 0xd6d() private { \n    v0 = v1 = block.timestamp > _getTimeLeft + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32 = 0x39ec();\n            MEM[0 + v8] = MEM[0 + v8] + 0xde0b6b3a7640000 * v9;\n            MEM[32 + v8] = MEM[32 + v8] + v14;\n            emit onBuyAndDistribute(msg.sender, ~0x0 & (~0x0 & _plyr_[v14][0x1]), msg.value, MEM[0 + v8], MEM[32 + v8], address(MEM[64 + v8]), ~0x0 & (~0x0 & MEM[96 + v8]), MEM[128 + v8], MEM[160 + v8], MEM[192 + v8], MEM[224 + v8]);\n        }\n        v33 = _SafeAdd(msg.value, _plyr_[v14][3]);\n        _plyr_[v14][3] = v33;\n    } else {\n        0x339a(v34, v35, v35, msg.value, v35);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x2186fa4 == v0) {\n            myFounder_PID(address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x11a09ae7 == v0) {\n            airDropTracker_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x3393bc43 == v0) {\n            myFounder_(address);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3ddd4698 == v0) {\n            registerNameXaddr(string,address,bool);\n        } else if (0x49cc635d == v0) {\n            receivePlayerInfo(uint256,address,bytes32,uint256);\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x685ffd83 == v0) {\n            registerNameXname(string,bytes32,bool);\n        } else if (0x6d510a64 == v0) {\n            ourTEAM();\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x88dfee60 == v0) {\n            setOtherFounder(address,uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x8f7140ea == v0) {\n            receivePlayerNameList(uint256,bytes32);\n        } else if (0x921dec21 == v0) {\n            registerNameXID(string,uint256,bool);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xb483c054 == v0) {\n            setOtherFomo(address);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xd87574e0 == v0) {\n            airDropPot_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xed78cf4a == v0) {\n            potSwap();\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 63.16232919692993,
	"usage": {
		"completion_tokens": 752,
		"prompt_tokens": 24092,
		"total_tokens": 24844
	}
}