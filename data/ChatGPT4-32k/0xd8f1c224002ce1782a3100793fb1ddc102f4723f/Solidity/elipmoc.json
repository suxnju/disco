{
	"address": "0xd8f1c224002ce1782a3100793fb1ddc102f4723f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity contract that corresponds to the provided decompiled code:\n\n```solidity\npragma solidity ^0.8.4;\n\ncontract Investment {\n    mapping (address => uint256) private _balances;\n    mapping (address => bool) private _invest;\n    address private _disableInvestTarget;\n\n    event OnWithdraw(address indexed account, uint256 amount, uint256 timestamp);\n    event OnCustomerFunded(address indexed payer, address indexed customer, uint8 flag, uint256 timestamp);\n    event OnInvestTargetDisabled(address indexed target, uint256 timestamp);\n    event OnInvest(address indexed investor, address indexed investee, uint256 amount, uint8 flag, uint256 timestamp);\n    event OnInvestTargetEnabled(address indexed target, uint256 timestamp);\n\n    function invest(address investor, address investee, uint256 amount, uint8 flag) public {\n        require(_invest[investee], \"Investee is not allowed to receive investments.\");\n        require(_balances[investor] >= amount, \"Insufficient balance.\");\n\n        _balances[investor] -= amount;\n        _balances[investee] += amount;\n\n        emit OnInvest(investor, investee, amount, flag, block.timestamp);\n    }\n\n    function enableInvestTarget(address target) public {\n        require(msg.sender == _disableInvestTarget, \"Only the disableInvestTarget can enable a new target.\");\n\n        _invest[target] = true;\n\n        emit OnInvestTargetEnabled(target, block.timestamp);\n    }\n\n    function balances(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"Insufficient balance.\");\n\n        _balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n\n        emit OnWithdraw(msg.sender, amount, block.timestamp);\n    }\n\n    function fundCustomer(address customer, uint8 flag) public payable {\n        _balances[customer] += msg.value;\n\n        emit OnCustomerFunded(msg.sender, customer, flag, block.timestamp);\n    }\n\n    function disableInvestTarget(address target) public {\n        require(msg.sender == _disableInvestTarget, \"Only the disableInvestTarget can disable a target.\");\n\n        _invest[target] = false;\n\n        emit OnInvestTargetDisabled(target, block.timestamp);\n    }\n\n    fallback () external payable {\n        revert(\"Fallback function called.\");\n    }\n}\n```\n\nPlease note that this is a basic interpretation based on the provided decompiled code. Some features such as access control, error messages, and safety checks are inferred and may not exactly match the original contract's intent. Also, the contract doesn't seem to have a function to set the `_disableInvestTarget` address, you may want to add a function or constructor for that.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457854,
	"id": "chatcmpl-8R3CYAl5b1ZerBQ6qM6dUkAfcsT3S",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 03:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _invest; // STORAGE[0x2]\naddress _disableInvestTarget; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nOnWithdraw(address, uint256, uint256);\nOnCustomerFunded(address, address, uint8, uint256);\nOnInvestTargetDisabled(address, uint256);\nOnInvest(address, address, uint256, uint8, uint256);\nOnInvestTargetEnabled(address, uint256);\n\nfunction invest(address varg0, address varg1, uint256 varg2, uint8 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0xff & _invest[varg1]);\n    if (varg2 <= _balances[varg0]) {\n        _balances[varg0] = _balances[varg0] - varg2;\n        require(varg1.code.size);\n        v0 = varg1.fund().value(varg2).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        emit OnInvest(varg0, varg1, varg2, 0xff & varg3 & 0xff, block.timestamp);\n        v1 = v2 = 1;\n    } else {\n        v1 = v3 = 0;\n    }\n    return v1;\n}\n\nfunction enableInvestTarget(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _disableInvestTarget);\n    _invest[varg0] = 0x1 | ~0xff & _invest[varg0];\n    emit OnInvestTargetEnabled(varg0, block.timestamp);\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction balances(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balances[varg0];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (!varg0) {\n        v0 = v1 = _balances[msg.sender];\n    }\n    require(v0 > 0);\n    require(v0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - v0;\n    v2 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v2); // checks call status, propagates error data on error\n    emit OnWithdraw(msg.sender, varg0, block.timestamp);\n}\n\nfunction fundCustomer(address varg0, uint8 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    _balances[varg0] += msg.value;\n    emit OnCustomerFunded(msg.sender, varg0, 0xff & varg1 & 0xff, block.timestamp);\n}\n\nfunction disableInvestTarget(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _disableInvestTarget);\n    _invest[varg0] = 0x1 | ~0xff & _invest[varg0];\n    emit OnInvestTargetDisabled(varg0, block.timestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector >> 224) {\n            balances(address);\n        } else if (0x2e1a7d4d == function_selector >> 224) {\n            withdraw(uint256);\n        } else if (0x55810e0e == function_selector >> 224) {\n            fundCustomer(address,uint8);\n        } else if (0xb55f8afb == function_selector >> 224) {\n            disableInvestTarget(address);\n        } else if (0xbe1317dd == function_selector >> 224) {\n            invest(address,address,uint256,uint8);\n        } else if (0xe0ad29cc == function_selector >> 224) {\n            enableInvestTarget(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 03:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _invest; // STORAGE[0x2]\naddress _disableInvestTarget; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nOnWithdraw(address, uint256, uint256);\nOnCustomerFunded(address, address, uint8, uint256);\nOnInvestTargetDisabled(address, uint256);\nOnInvest(address, address, uint256, uint8, uint256);\nOnInvestTargetEnabled(address, uint256);\n\nfunction invest(address varg0, address varg1, uint256 varg2, uint8 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0xff & _invest[varg1]);\n    if (varg2 <= _balances[varg0]) {\n        _balances[varg0] = _balances[varg0] - varg2;\n        require(varg1.code.size);\n        v0 = varg1.fund().value(varg2).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        emit OnInvest(varg0, varg1, varg2, 0xff & varg3 & 0xff, block.timestamp);\n        v1 = v2 = 1;\n    } else {\n        v1 = v3 = 0;\n    }\n    return v1;\n}\n\nfunction enableInvestTarget(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _disableInvestTarget);\n    _invest[varg0] = 0x1 | ~0xff & _invest[varg0];\n    emit OnInvestTargetEnabled(varg0, block.timestamp);\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction balances(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balances[varg0];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (!varg0) {\n        v0 = v1 = _balances[msg.sender];\n    }\n    require(v0 > 0);\n    require(v0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - v0;\n    v2 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v2); // checks call status, propagates error data on error\n    emit OnWithdraw(msg.sender, varg0, block.timestamp);\n}\n\nfunction fundCustomer(address varg0, uint8 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    _balances[varg0] += msg.value;\n    emit OnCustomerFunded(msg.sender, varg0, 0xff & varg1 & 0xff, block.timestamp);\n}\n\nfunction disableInvestTarget(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _disableInvestTarget);\n    _invest[varg0] = 0x1 | ~0xff & _invest[varg0];\n    emit OnInvestTargetDisabled(varg0, block.timestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector >> 224) {\n            balances(address);\n        } else if (0x2e1a7d4d == function_selector >> 224) {\n            withdraw(uint256);\n        } else if (0x55810e0e == function_selector >> 224) {\n            fundCustomer(address,uint8);\n        } else if (0xb55f8afb == function_selector >> 224) {\n            disableInvestTarget(address);\n        } else if (0xbe1317dd == function_selector >> 224) {\n            invest(address,address,uint256,uint8);\n        } else if (0xe0ad29cc == function_selector >> 224) {\n            enableInvestTarget(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 03:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _invest; // STORAGE[0x2]\naddress _disableInvestTarget; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nOnWithdraw(address, uint256, uint256);\nOnCustomerFunded(address, address, uint8, uint256);\nOnInvestTargetDisabled(address, uint256);\nOnInvest(address, address, uint256, uint8, uint256);\nOnInvestTargetEnabled(address, uint256);\n\nfunction invest(address varg0, address varg1, uint256 varg2, uint8 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0xff & _invest[varg1]);\n    if (varg2 <= _balances[varg0]) {\n        _balances[varg0] = _balances[varg0] - varg2;\n        require(varg1.code.size);\n        v0 = varg1.fund().value(varg2).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        emit OnInvest(varg0, varg1, varg2, 0xff & varg3 & 0xff, block.timestamp);\n        v1 = v2 = 1;\n    } else {\n        v1 = v3 = 0;\n    }\n    return v1;\n}\n\nfunction enableInvestTarget(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _disableInvestTarget);\n    _invest[varg0] = 0x1 | ~0xff & _invest[varg0];\n    emit OnInvestTargetEnabled(varg0, block.timestamp);\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction balances(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balances[varg0];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (!varg0) {\n        v0 = v1 = _balances[msg.sender];\n    }\n    require(v0 > 0);\n    require(v0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - v0;\n    v2 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v2); // checks call status, propagates error data on error\n    emit OnWithdraw(msg.sender, varg0, block.timestamp);\n}\n\nfunction fundCustomer(address varg0, uint8 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    _balances[varg0] += msg.value;\n    emit OnCustomerFunded(msg.sender, varg0, 0xff & varg1 & 0xff, block.timestamp);\n}\n\nfunction disableInvestTarget(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _disableInvestTarget);\n    _invest[varg0] = 0x1 | ~0xff & _invest[varg0];\n    emit OnInvestTargetDisabled(varg0, block.timestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector >> 224) {\n            balances(address);\n        } else if (0x2e1a7d4d == function_selector >> 224) {\n            withdraw(uint256);\n        } else if (0x55810e0e == function_selector >> 224) {\n            fundCustomer(address,uint8);\n        } else if (0xb55f8afb == function_selector >> 224) {\n            disableInvestTarget(address);\n        } else if (0xbe1317dd == function_selector >> 224) {\n            invest(address,address,uint256,uint8);\n        } else if (0xe0ad29cc == function_selector >> 224) {\n            enableInvestTarget(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 34.21371078491211,
	"usage": {
		"completion_tokens": 565,
		"prompt_tokens": 1025,
		"total_tokens": 1590
	}
}