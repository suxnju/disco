{
	"address": "0xb1439dd624a8aea767917684cc408f1895de2348",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code in the EVM Bytecode, here is a Solidity contract code which replicates the functionality of the original code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyToken {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    address public owner;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        totalSupply = 1000000 * (10 ** uint256(decimals));\n        balanceOf[msg.sender] = totalSupply;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n```\n\nPlease note that this Solidity code is a simplified representation of the decompiled code and does not include all the conditions and computations defined in the provided bytecode. It's just a basic ERC20 token contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1700632424,
	"id": "chatcmpl-8NaTABahgdWQmY7gLb7ms896D9733",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  totalSupply is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is address at storage 3\n  stor4 is mapping of uint8 at storage 4\n  stor5 is uint256 at storage 5\n  stor6 is array of struct at storage 6\n  stor7 is address at storage 7\n  allowance is mapping of uint256 at storage 9\n  owner is address at storage 10\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef increaseAllowance(address spender, uint256 addedValue) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if allowance[caller][address(spender)] > addedValue + allowance[caller][address(spender)]:\n      revert with 0, 17\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] += addedValue\n  log Approval(\n        address owner=(addedValue + allowance[caller][address(spender)]),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef decreaseAllowance(address spender, uint256 subtractedValue) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if allowance[caller][address(spender)] < subtractedValue:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: decreased allowance below zero'\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] -= subtractedValue\n  log Approval(\n        address owner=(allowance[caller][address(spender)] - subtractedValue),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if balanceOf[caller] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  if balanceOf[caller] - amount > balanceOf[caller]:\n      revert with 0, 17\n  balanceOf[caller] -= amount\n  if 1 == bool(stor4[caller]):\n      if 0 / amount and amount:\n          revert with 0, 17\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      if tx.origin == recipient:\n          if 0 / amount and amount:\n              revert with 0, 17\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          log Transfer(\n                address from=amount,\n                address to=caller,\n                uint256 value=recipient)\n      else:\n          if stor5 != stor5 * amount / amount and amount:\n              revert with 0, 17\n          if 0 > stor5 * amount / 100:\n              revert with 0, 17\n          if stor5 * amount / 100:\n              if balanceOf[stor7] > (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              if (stor5 * amount / 100) + balanceOf[stor7] != (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              balanceOf[stor7] += stor5 * amount / 100\n              log Transfer(\n                    address from=(stor5 * amount / 100),\n                    address to=caller,\n                    uint256 value=stor7)\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount - (stor5 * amount / 100) + balanceOf[address(recipient)] != amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] = amount - (stor5 * amount / 100) + balanceOf[address(recipient)]\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          log Transfer(\n                address from=(amount - (stor5 * amount / 100)),\n                address to=caller,\n                uint256 value=recipient)\n  if not recipient - stor3:\n      stor5 = 98\n  return 1\n\ndef name() payable: \n  if bool(stor2.length):\n      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n          revert with 0, 34\n      if bool(stor2.length):\n          if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n              revert with 0, 34\n          if Mask(256, -1, stor2.length):\n              if 31 < uint255(stor2.length) * 0.5:\n                  mem[128] = uint256(stor2.field_0)\n                  idx = 128\n                  s = 0\n                  while (uint255(stor2.length) * 0.5) + 96 > idx:\n                      mem[idx + 32] = stor2[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])\n              mem[128] = 256 * stor2.length.field_8\n      else:\n          if not bool(stor2.length) - (stor2.length.field_1 < 32):\n              revert with 0, 34\n          if stor2.length.field_1:\n              if 31 < stor2.length.field_1:\n                  mem[128] = uint256(stor2.field_0)\n                  idx = 128\n                  s = 0\n                  while stor2.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor2[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])\n              mem[128] = 256 * stor2.length.field_8\n      mem[ceil32(uint255(stor2.length) * 0.5) + 192 len ceil32(uint255(stor2.length) * 0.5)] = mem[128 len ceil32(uint255(stor2.length) * 0.5)]\n      mem[ceil32(uint255(stor2.length) * 0.5) + (uint255(stor2.length) * 0.5) + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)], mem[(2 * ceil32(uint255(stor2.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor2.length) * 0.5)]), \n  if not bool(stor2.length) - (stor2.length.field_1 < 32):\n      revert with 0, 34\n  if bool(stor2.length):\n      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n          revert with 0, 34\n      if Mask(256, -1, stor2.length):\n          if 31 < uint255(stor2.length) * 0.5:\n              mem[128] = uint256(stor2.field_0)\n              idx = 128\n              s = 0\n              while (uint255(stor2.length) * 0.5) + 96 > idx:\n                  mem[idx + 32] = stor2[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])\n          mem[128] = 256 * stor2.length.field_8\n  else:\n      if not bool(stor2.length) - (stor2.length.field_1 < 32):\n          revert with 0, 34\n      if stor2.length.field_1:\n          if 31 < stor2.length.field_1:\n              mem[128] = uint256(stor2.field_0)\n              idx = 128\n              s = 0\n              while stor2.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor2[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])\n          mem[128] = 256 * stor2.length.field_8\n  mem[ceil32(stor2.length.field_1) + 192 len ceil32(stor2.length.field_1)] = mem[128 len ceil32(stor2.length.field_1)]\n  mem[ceil32(stor2.length.field_1) + stor2.length.field_1 + 192] = 0\n  return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)], mem[(2 * ceil32(stor2.length.field_1)) + 192 len 2 * ceil32(stor2.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor6.length):\n      if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n          revert with 0, 34\n      if bool(stor6.length):\n          if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n              revert with 0, 34\n          if Mask(256, -1, stor6.length):\n              if 31 < uint255(stor6.length) * 0.5:\n                  mem[128] = uint256(stor6.field_0)\n                  idx = 128\n                  s = 0\n                  while (uint255(stor6.length) * 0.5) + 96 > idx:\n                      mem[idx + 32] = stor6[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])\n              mem[128] = 256 * stor6.length.field_8\n      else:\n          if not bool(stor6.length) - (stor6.length.field_1 < 32):\n              revert with 0, 34\n          if stor6.length.field_1:\n              if 31 < stor6.length.field_1:\n                  mem[128] = uint256(stor6.field_0)\n                  idx = 128\n                  s = 0\n                  while stor6.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor6[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])\n              mem[128] = 256 * stor6.length.field_8\n      mem[ceil32(uint255(stor6.length) * 0.5) + 192 len ceil32(uint255(stor6.length) * 0.5)] = mem[128 len ceil32(uint255(stor6.length) * 0.5)]\n      mem[ceil32(uint255(stor6.length) * 0.5) + (uint255(stor6.length) * 0.5) + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)], mem[(2 * ceil32(uint255(stor6.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor6.length) * 0.5)]), \n  if not bool(stor6.length) - (stor6.length.field_1 < 32):\n      revert with 0, 34\n  if bool(stor6.length):\n      if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n          revert with 0, 34\n      if Mask(256, -1, stor6.length):\n          if 31 < uint255(stor6.length) * 0.5:\n              mem[128] = uint256(stor6.field_0)\n              idx = 128\n              s = 0\n              while (uint255(stor6.length) * 0.5) + 96 > idx:\n                  mem[idx + 32] = stor6[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])\n          mem[128] = 256 * stor6.length.field_8\n  else:\n      if not bool(stor6.length) - (stor6.length.field_1 < 32):\n          revert with 0, 34\n      if stor6.length.field_1:\n          if 31 < stor6.length.field_1:\n              mem[128] = uint256(stor6.field_0)\n              idx = 128\n              s = 0\n              while stor6.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor6[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])\n          mem[128] = 256 * stor6.length.field_8\n  mem[ceil32(stor6.length.field_1) + 192 len ceil32(stor6.length.field_1)] = mem[128 len ceil32(stor6.length.field_1)]\n  mem[ceil32(stor6.length.field_1) + stor6.length.field_1 + 192] = 0\n  return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)], mem[(2 * ceil32(stor6.length.field_1)) + 192 len 2 * ceil32(stor6.length.field_1)]), \n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if balanceOf[address(sender)] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:\n      revert with 0, 17\n  balanceOf[address(sender)] -= amount\n  if 1 == bool(stor4[address(sender)]):\n      if 0 / amount and amount:\n          revert with 0, 17\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      log Transfer(\n            address from=amount,\n            address to=sender,\n            uint256 value=recipient)\n  else:\n      if tx.origin == recipient:\n          if 0 / amount and amount:\n              revert with 0, 17\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          log Transfer(\n                address from=amount,\n                address to=sender,\n                uint256 value=recipient)\n      else:\n          if stor5 != stor5 * amount / amount and amount:\n              revert with 0, 17\n          if 0 > stor5 * amount / 100:\n              revert with 0, 17\n          if stor5 * amount / 100:\n              if balanceOf[stor7] > (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              if (stor5 * amount / 100) + balanceOf[stor7] != (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              balanceOf[stor7] += stor5 * amount / 100\n              log Transfer(\n                    address from=(stor5 * amount / 100),\n                    address to=sender,\n                    uint256 value=stor7)\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount - (stor5 * amount / 100) + balanceOf[address(recipient)] != amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] = amount - (stor5 * amount / 100) + balanceOf[address(recipient)]\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          log Transfer(\n                address from=(amount - (stor5 * amount / 100)),\n                address to=sender,\n                uint256 value=recipient)\n  if not recipient - stor3:\n      stor5 = 98\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  totalSupply is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is address at storage 3\n  stor4 is mapping of uint8 at storage 4\n  stor5 is uint256 at storage 5\n  stor6 is array of struct at storage 6\n  stor7 is address at storage 7\n  allowance is mapping of uint256 at storage 9\n  owner is address at storage 10\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef increaseAllowance(address spender, uint256 addedValue) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if allowance[caller][address(spender)] > addedValue + allowance[caller][address(spender)]:\n      revert with 0, 17\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] += addedValue\n  log Approval(\n        address owner=(addedValue + allowance[caller][address(spender)]),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef decreaseAllowance(address spender, uint256 subtractedValue) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if allowance[caller][address(spender)] < subtractedValue:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: decreased allowance below zero'\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] -= subtractedValue\n  log Approval(\n        address owner=(allowance[caller][address(spender)] - subtractedValue),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if balanceOf[caller] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  if balanceOf[caller] - amount > balanceOf[caller]:\n      revert with 0, 17\n  balanceOf[caller] -= amount\n  if 1 == bool(stor4[caller]):\n      if 0 / amount and amount:\n          revert with 0, 17\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      if tx.origin == recipient:\n          if 0 / amount and amount:\n              revert with 0, 17\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          log Transfer(\n                address from=amount,\n                address to=caller,\n                uint256 value=recipient)\n      else:\n          if stor5 != stor5 * amount / amount and amount:\n              revert with 0, 17\n          if 0 > stor5 * amount / 100:\n              revert with 0, 17\n          if stor5 * amount / 100:\n              if balanceOf[stor7] > (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              if (stor5 * amount / 100) + balanceOf[stor7] != (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              balanceOf[stor7] += stor5 * amount / 100\n              log Transfer(\n                    address from=(stor5 * amount / 100),\n                    address to=caller,\n                    uint256 value=stor7)\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount - (stor5 * amount / 100) + balanceOf[address(recipient)] != amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] = amount - (stor5 * amount / 100) + balanceOf[address(recipient)]\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          log Transfer(\n                address from=(amount - (stor5 * amount / 100)),\n                address to=caller,\n                uint256 value=recipient)\n  if not recipient - stor3:\n      stor5 = 98\n  return 1\n\ndef name() payable: \n  if bool(stor2.length):\n      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n          revert with 0, 34\n      if bool(stor2.length):\n          if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n              revert with 0, 34\n          if Mask(256, -1, stor2.length):\n              if 31 < uint255(stor2.length) * 0.5:\n                  mem[128] = uint256(stor2.field_0)\n                  idx = 128\n                  s = 0\n                  while (uint255(stor2.length) * 0.5) + 96 > idx:\n                      mem[idx + 32] = stor2[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])\n              mem[128] = 256 * stor2.length.field_8\n      else:\n          if not bool(stor2.length) - (stor2.length.field_1 < 32):\n              revert with 0, 34\n          if stor2.length.field_1:\n              if 31 < stor2.length.field_1:\n                  mem[128] = uint256(stor2.field_0)\n                  idx = 128\n                  s = 0\n                  while stor2.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor2[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])\n              mem[128] = 256 * stor2.length.field_8\n      mem[ceil32(uint255(stor2.length) * 0.5) + 192 len ceil32(uint255(stor2.length) * 0.5)] = mem[128 len ceil32(uint255(stor2.length) * 0.5)]\n      mem[ceil32(uint255(stor2.length) * 0.5) + (uint255(stor2.length) * 0.5) + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)], mem[(2 * ceil32(uint255(stor2.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor2.length) * 0.5)]), \n  if not bool(stor2.length) - (stor2.length.field_1 < 32):\n      revert with 0, 34\n  if bool(stor2.length):\n      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n          revert with 0, 34\n      if Mask(256, -1, stor2.length):\n          if 31 < uint255(stor2.length) * 0.5:\n              mem[128] = uint256(stor2.field_0)\n              idx = 128\n              s = 0\n              while (uint255(stor2.length) * 0.5) + 96 > idx:\n                  mem[idx + 32] = stor2[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])\n          mem[128] = 256 * stor2.length.field_8\n  else:\n      if not bool(stor2.length) - (stor2.length.field_1 < 32):\n          revert with 0, 34\n      if stor2.length.field_1:\n          if 31 < stor2.length.field_1:\n              mem[128] = uint256(stor2.field_0)\n              idx = 128\n              s = 0\n              while stor2.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor2[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])\n          mem[128] = 256 * stor2.length.field_8\n  mem[ceil32(stor2.length.field_1) + 192 len ceil32(stor2.length.field_1)] = mem[128 len ceil32(stor2.length.field_1)]\n  mem[ceil32(stor2.length.field_1) + stor2.length.field_1 + 192] = 0\n  return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)], mem[(2 * ceil32(stor2.length.field_1)) + 192 len 2 * ceil32(stor2.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor6.length):\n      if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n          revert with 0, 34\n      if bool(stor6.length):\n          if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n              revert with 0, 34\n          if Mask(256, -1, stor6.length):\n              if 31 < uint255(stor6.length) * 0.5:\n                  mem[128] = uint256(stor6.field_0)\n                  idx = 128\n                  s = 0\n                  while (uint255(stor6.length) * 0.5) + 96 > idx:\n                      mem[idx + 32] = stor6[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])\n              mem[128] = 256 * stor6.length.field_8\n      else:\n          if not bool(stor6.length) - (stor6.length.field_1 < 32):\n              revert with 0, 34\n          if stor6.length.field_1:\n              if 31 < stor6.length.field_1:\n                  mem[128] = uint256(stor6.field_0)\n                  idx = 128\n                  s = 0\n                  while stor6.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor6[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])\n              mem[128] = 256 * stor6.length.field_8\n      mem[ceil32(uint255(stor6.length) * 0.5) + 192 len ceil32(uint255(stor6.length) * 0.5)] = mem[128 len ceil32(uint255(stor6.length) * 0.5)]\n      mem[ceil32(uint255(stor6.length) * 0.5) + (uint255(stor6.length) * 0.5) + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)], mem[(2 * ceil32(uint255(stor6.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor6.length) * 0.5)]), \n  if not bool(stor6.length) - (stor6.length.field_1 < 32):\n      revert with 0, 34\n  if bool(stor6.length):\n      if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n          revert with 0, 34\n      if Mask(256, -1, stor6.length):\n          if 31 < uint255(stor6.length) * 0.5:\n              mem[128] = uint256(stor6.field_0)\n              idx = 128\n              s = 0\n              while (uint255(stor6.length) * 0.5) + 96 > idx:\n                  mem[idx + 32] = stor6[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])\n          mem[128] = 256 * stor6.length.field_8\n  else:\n      if not bool(stor6.length) - (stor6.length.field_1 < 32):\n          revert with 0, 34\n      if stor6.length.field_1:\n          if 31 < stor6.length.field_1:\n              mem[128] = uint256(stor6.field_0)\n              idx = 128\n              s = 0\n              while stor6.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor6[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])\n          mem[128] = 256 * stor6.length.field_8\n  mem[ceil32(stor6.length.field_1) + 192 len ceil32(stor6.length.field_1)] = mem[128 len ceil32(stor6.length.field_1)]\n  mem[ceil32(stor6.length.field_1) + stor6.length.field_1 + 192] = 0\n  return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)], mem[(2 * ceil32(stor6.length.field_1)) + 192 len 2 * ceil32(stor6.length.field_1)]), \n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if balanceOf[address(sender)] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:\n      revert with 0, 17\n  balanceOf[address(sender)] -= amount\n  if 1 == bool(stor4[address(sender)]):\n      if 0 / amount and amount:\n          revert with 0, 17\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      log Transfer(\n            address from=amount,\n            address to=sender,\n            uint256 value=recipient)\n  else:\n      if tx.origin == recipient:\n          if 0 / amount and amount:\n              revert with 0, 17\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          log Transfer(\n                address from=amount,\n                address to=sender,\n                uint256 value=recipient)\n      else:\n          if stor5 != stor5 * amount / amount and amount:\n              revert with 0, 17\n          if 0 > stor5 * amount / 100:\n              revert with 0, 17\n          if stor5 * amount / 100:\n              if balanceOf[stor7] > (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              if (stor5 * amount / 100) + balanceOf[stor7] != (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              balanceOf[stor7] += stor5 * amount / 100\n              log Transfer(\n                    address from=(stor5 * amount / 100),\n                    address to=sender,\n                    uint256 value=stor7)\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount - (stor5 * amount / 100) + balanceOf[address(recipient)] != amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] = amount - (stor5 * amount / 100) + balanceOf[address(recipient)]\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          log Transfer(\n                address from=(amount - (stor5 * amount / 100)),\n                address to=sender,\n                uint256 value=recipient)\n  if not recipient - stor3:\n      stor5 = 98\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  totalSupply is uint256 at storage 1\n  stor2 is array of struct at storage 2\n  stor3 is address at storage 3\n  stor4 is mapping of uint8 at storage 4\n  stor5 is uint256 at storage 5\n  stor6 is array of struct at storage 6\n  stor7 is address at storage 7\n  allowance is mapping of uint256 at storage 9\n  owner is address at storage 10\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef increaseAllowance(address spender, uint256 addedValue) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if allowance[caller][address(spender)] > addedValue + allowance[caller][address(spender)]:\n      revert with 0, 17\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] += addedValue\n  log Approval(\n        address owner=(addedValue + allowance[caller][address(spender)]),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef decreaseAllowance(address spender, uint256 subtractedValue) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if allowance[caller][address(spender)] < subtractedValue:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: decreased allowance below zero'\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] -= subtractedValue\n  log Approval(\n        address owner=(allowance[caller][address(spender)] - subtractedValue),\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if balanceOf[caller] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  if balanceOf[caller] - amount > balanceOf[caller]:\n      revert with 0, 17\n  balanceOf[caller] -= amount\n  if 1 == bool(stor4[caller]):\n      if 0 / amount and amount:\n          revert with 0, 17\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      if tx.origin == recipient:\n          if 0 / amount and amount:\n              revert with 0, 17\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          log Transfer(\n                address from=amount,\n                address to=caller,\n                uint256 value=recipient)\n      else:\n          if stor5 != stor5 * amount / amount and amount:\n              revert with 0, 17\n          if 0 > stor5 * amount / 100:\n              revert with 0, 17\n          if stor5 * amount / 100:\n              if balanceOf[stor7] > (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              if (stor5 * amount / 100) + balanceOf[stor7] != (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              balanceOf[stor7] += stor5 * amount / 100\n              log Transfer(\n                    address from=(stor5 * amount / 100),\n                    address to=caller,\n                    uint256 value=stor7)\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount - (stor5 * amount / 100) + balanceOf[address(recipient)] != amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] = amount - (stor5 * amount / 100) + balanceOf[address(recipient)]\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          log Transfer(\n                address from=(amount - (stor5 * amount / 100)),\n                address to=caller,\n                uint256 value=recipient)\n  if not recipient - stor3:\n      stor5 = 98\n  return 1\n\ndef name() payable: \n  if bool(stor2.length):\n      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n          revert with 0, 34\n      if bool(stor2.length):\n          if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n              revert with 0, 34\n          if Mask(256, -1, stor2.length):\n              if 31 < uint255(stor2.length) * 0.5:\n                  mem[128] = uint256(stor2.field_0)\n                  idx = 128\n                  s = 0\n                  while (uint255(stor2.length) * 0.5) + 96 > idx:\n                      mem[idx + 32] = stor2[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])\n              mem[128] = 256 * stor2.length.field_8\n      else:\n          if not bool(stor2.length) - (stor2.length.field_1 < 32):\n              revert with 0, 34\n          if stor2.length.field_1:\n              if 31 < stor2.length.field_1:\n                  mem[128] = uint256(stor2.field_0)\n                  idx = 128\n                  s = 0\n                  while stor2.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor2[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])\n              mem[128] = 256 * stor2.length.field_8\n      mem[ceil32(uint255(stor2.length) * 0.5) + 192 len ceil32(uint255(stor2.length) * 0.5)] = mem[128 len ceil32(uint255(stor2.length) * 0.5)]\n      mem[ceil32(uint255(stor2.length) * 0.5) + (uint255(stor2.length) * 0.5) + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)], mem[(2 * ceil32(uint255(stor2.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor2.length) * 0.5)]), \n  if not bool(stor2.length) - (stor2.length.field_1 < 32):\n      revert with 0, 34\n  if bool(stor2.length):\n      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):\n          revert with 0, 34\n      if Mask(256, -1, stor2.length):\n          if 31 < uint255(stor2.length) * 0.5:\n              mem[128] = uint256(stor2.field_0)\n              idx = 128\n              s = 0\n              while (uint255(stor2.length) * 0.5) + 96 > idx:\n                  mem[idx + 32] = stor2[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])\n          mem[128] = 256 * stor2.length.field_8\n  else:\n      if not bool(stor2.length) - (stor2.length.field_1 < 32):\n          revert with 0, 34\n      if stor2.length.field_1:\n          if 31 < stor2.length.field_1:\n              mem[128] = uint256(stor2.field_0)\n              idx = 128\n              s = 0\n              while stor2.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor2[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])\n          mem[128] = 256 * stor2.length.field_8\n  mem[ceil32(stor2.length.field_1) + 192 len ceil32(stor2.length.field_1)] = mem[128 len ceil32(stor2.length.field_1)]\n  mem[ceil32(stor2.length.field_1) + stor2.length.field_1 + 192] = 0\n  return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)], mem[(2 * ceil32(stor2.length.field_1)) + 192 len 2 * ceil32(stor2.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor6.length):\n      if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n          revert with 0, 34\n      if bool(stor6.length):\n          if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n              revert with 0, 34\n          if Mask(256, -1, stor6.length):\n              if 31 < uint255(stor6.length) * 0.5:\n                  mem[128] = uint256(stor6.field_0)\n                  idx = 128\n                  s = 0\n                  while (uint255(stor6.length) * 0.5) + 96 > idx:\n                      mem[idx + 32] = stor6[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])\n              mem[128] = 256 * stor6.length.field_8\n      else:\n          if not bool(stor6.length) - (stor6.length.field_1 < 32):\n              revert with 0, 34\n          if stor6.length.field_1:\n              if 31 < stor6.length.field_1:\n                  mem[128] = uint256(stor6.field_0)\n                  idx = 128\n                  s = 0\n                  while stor6.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor6[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])\n              mem[128] = 256 * stor6.length.field_8\n      mem[ceil32(uint255(stor6.length) * 0.5) + 192 len ceil32(uint255(stor6.length) * 0.5)] = mem[128 len ceil32(uint255(stor6.length) * 0.5)]\n      mem[ceil32(uint255(stor6.length) * 0.5) + (uint255(stor6.length) * 0.5) + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)], mem[(2 * ceil32(uint255(stor6.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor6.length) * 0.5)]), \n  if not bool(stor6.length) - (stor6.length.field_1 < 32):\n      revert with 0, 34\n  if bool(stor6.length):\n      if not bool(stor6.length) - (uint255(stor6.length) * 0.5 < 32):\n          revert with 0, 34\n      if Mask(256, -1, stor6.length):\n          if 31 < uint255(stor6.length) * 0.5:\n              mem[128] = uint256(stor6.field_0)\n              idx = 128\n              s = 0\n              while (uint255(stor6.length) * 0.5) + 96 > idx:\n                  mem[idx + 32] = stor6[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])\n          mem[128] = 256 * stor6.length.field_8\n  else:\n      if not bool(stor6.length) - (stor6.length.field_1 < 32):\n          revert with 0, 34\n      if stor6.length.field_1:\n          if 31 < stor6.length.field_1:\n              mem[128] = uint256(stor6.field_0)\n              idx = 128\n              s = 0\n              while stor6.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor6[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])\n          mem[128] = 256 * stor6.length.field_8\n  mem[ceil32(stor6.length.field_1) + 192 len ceil32(stor6.length.field_1)] = mem[128 len ceil32(stor6.length.field_1)]\n  mem[ceil32(stor6.length.field_1) + stor6.length.field_1 + 192] = 0\n  return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)], mem[(2 * ceil32(stor6.length.field_1)) + 192 len 2 * ceil32(stor6.length.field_1)]), \n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if not recipient:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'\n  if balanceOf[address(sender)] < amount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer amount exceeds balance'\n  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:\n      revert with 0, 17\n  balanceOf[address(sender)] -= amount\n  if 1 == bool(stor4[address(sender)]):\n      if 0 / amount and amount:\n          revert with 0, 17\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      if amount > amount:\n          revert with 0, 17\n      if 0 > amount:\n          revert with 0, 17\n      log Transfer(\n            address from=amount,\n            address to=sender,\n            uint256 value=recipient)\n  else:\n      if tx.origin == recipient:\n          if 0 / amount and amount:\n              revert with 0, 17\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount + balanceOf[address(recipient)] != amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          if amount > amount:\n              revert with 0, 17\n          if 0 > amount:\n              revert with 0, 17\n          log Transfer(\n                address from=amount,\n                address to=sender,\n                uint256 value=recipient)\n      else:\n          if stor5 != stor5 * amount / amount and amount:\n              revert with 0, 17\n          if 0 > stor5 * amount / 100:\n              revert with 0, 17\n          if stor5 * amount / 100:\n              if balanceOf[stor7] > (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              if (stor5 * amount / 100) + balanceOf[stor7] != (stor5 * amount / 100) + balanceOf[stor7]:\n                  revert with 0, 17\n              balanceOf[stor7] += stor5 * amount / 100\n              log Transfer(\n                    address from=(stor5 * amount / 100),\n                    address to=sender,\n                    uint256 value=stor7)\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          if balanceOf[address(recipient)] > amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          if amount - (stor5 * amount / 100) + balanceOf[address(recipient)] != amount - (stor5 * amount / 100) + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] = amount - (stor5 * amount / 100) + balanceOf[address(recipient)]\n          if amount - (stor5 * amount / 100) > amount:\n              revert with 0, 17\n          if 0 > amount - (stor5 * amount / 100):\n              revert with 0, 17\n          log Transfer(\n                address from=(amount - (stor5 * amount / 100)),\n                address to=sender,\n                uint256 value=recipient)\n  if not recipient - stor3:\n      stor5 = 98\n  return 1\n\n.",
	"status": "1",
	"time_cost": 22.312905311584473,
	"usage": {
		"completion_tokens": 431,
		"prompt_tokens": 5666,
		"total_tokens": 6097
	}
}