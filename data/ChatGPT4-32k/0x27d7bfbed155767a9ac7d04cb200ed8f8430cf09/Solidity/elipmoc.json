{
	"address": "0x27d7bfbed155767a9ac7d04cb200ed8f8430cf09",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.16 07:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _rate; // STORAGE[0x2]\nuint256 _startTime; // STORAGE[0x3]\nuint256 _endTime; // STORAGE[0x4]\nuint256 _weiRaised; // STORAGE[0x5]\nuint256 _tokensSent; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _tokenBalanceOf; // STORAGE[0x8]\nuint256 _commission; // STORAGE[0xa]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_2_0_0; // STORAGE[0x2] bytes 0 to 0\nuint256 _token; // STORAGE[0x1] bytes 0 to 19\nuint256 _hasHalted; // STORAGE[0x0] bytes 20 to 20\nuint256 _hasApproval; // STORAGE[0x0] bytes 21 to 21\nuint256 _iconemy_wallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nBeneficiaryWithdrawal(address, uint256, uint256);\nSaleStopped(address, uint256);\nCommissionCollected(address, uint256, uint256);\nTokenPurchase(address, uint256, uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction () public payable { \n    revert();\n}\n\nfunction receiveApproval() public nonPayable { \n    require(_owner == address(tx.origin));\n    _hasApproval = 1;\n    v0 = 0x834();\n    _commission = v0 / 100;\n}\n\nfunction tokensSent() public nonPayable { \n    return _tokensSent;\n}\n\nfunction collectRefund() public nonPayable { \n    require(_hasHalted);\n    require(_balanceOf[msg.sender] > 0);\n    _balanceOf[msg.sender] = 0;\n    v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n    require(v0);\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction hasHalted() public nonPayable { \n    return _hasHalted;\n}\n\nfunction collectInvestment() public nonPayable { \n    require(_owner == address(tx.origin));\n    require(!_hasHalted);\n    v0 = 0x8d5();\n    require(v0);\n    v1 = _owner.call().value(_weiRaised).gas(2300 * !_weiRaised);\n    require(v1);\n    emit BeneficiaryWithdrawal(_owner, _weiRaised, block.timestamp);\n    return 0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction hasApproval() public nonPayable { \n    return _hasApproval;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction getPrice() public nonPayable { \n    return _rate;\n}\n\nfunction checkAllowance(uint256 varg0) public nonPayable { \n    0x5d9(varg0);\n}\n\nfunction halted() public nonPayable { \n    return _hasHalted;\n}\n\nfunction iconemy_wallet() public nonPayable { \n    return _iconemy_wallet;\n}\n\nfunction refundAvailable() public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] > 0;\n    if (v1) {\n        v0 = _hasHalted;\n        goto 0x6450x61aB0x2cd;\n    }\n    return v0;\n}\n\nfunction stopICO() public nonPayable { \n    require(_owner == address(tx.origin));\n    _hasHalted = 1;\n    emit SaleStopped(msg.sender, block.timestamp);\n}\n\nfunction collectCommission() public nonPayable { \n    require(!_hasHalted);\n    require(_iconemy_wallet == msg.sender);\n    v0 = 0x8d5();\n    require(v0);\n    0x99d(_tokensSent / 100, 0, _iconemy_wallet);\n    emit CommissionCollected(_iconemy_wallet, _tokensSent / 100, block.timestamp);\n    return 0;\n}\n\nfunction buyTokens() public payable { \n    require(!_hasHalted);\n    assert(stor_2_0_0);\n    v0 = 0x8d5();\n    require(!v0);\n    0x5d9(msg.value / _rate);\n    v1 = v2 = block.timestamp >= _startTime;\n    if (v2) {\n        v1 = block.timestamp <= _endTime;\n    }\n    v1 = v3 = msg.value;\n    require(v1);\n    0x99d(msg.value / _rate, msg.value, msg.sender);\n    emit TokenPurchase(msg.sender, msg.value, msg.value / _rate, block.timestamp);\n}\n\nfunction allowanceOf() public nonPayable { \n    v0 = 0x834();\n    return v0;\n}\n\nfunction commission() public nonPayable { \n    return _commission;\n}\n\nfunction tokenBalanceOf(address varg0) public nonPayable { \n    return _tokenBalanceOf[varg0];\n}\n\nfunction hasEnded() public nonPayable { \n    v0 = 0x8d5();\n    return v0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == address(tx.origin));\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x5d9(uint256 varg0) private { \n    v0 = 0x834();\n    require(v0 - _commission >= varg0);\n    return ;\n}\n\nfunction 0x834() private { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.allowanceOf(_owner, address(this)).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction 0x8d5() private { \n    if (block.timestamp > _endTime) {\n        return block.timestamp > _endTime;\n    } else {\n        return _hasHalted;\n    }\n}\n\nfunction 0x99d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[32 + MEM[64]] = 0;\n    v0 = address(varg2);\n    require(_token.code.size);\n    v1, v2 = _token.transferFrom(_owner, v0, varg0).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    v3 = address(varg2);\n    v4 = varg1 + _balanceOf[v3];\n    assert(v4 >= _balanceOf[v3]);\n    v5 = address(varg2);\n    _balanceOf[v5] = v4;\n    v6 = varg0 + _tokenBalanceOf[v5];\n    assert(v6 >= _tokenBalanceOf[v5]);\n    v7 = address(varg2);\n    _tokenBalanceOf[v7] = v6;\n    v8 = varg1 + _weiRaised;\n    assert(v8 >= _weiRaised);\n    _weiRaised = v8;\n    v9 = varg0 + _tokensSent;\n    assert(v9 >= _tokensSent);\n    _tokensSent = v9;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x176bacb0) {\n            receiveApproval();\n        } else if (0x1f130761 == v0) {\n            tokensSent();\n        } else if (0x26ce3da0 == v0) {\n            collectRefund();\n        } else if (0x2c4e722e == v0) {\n            rate();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x4042b66f == v0) {\n            weiRaised();\n        } else if (0x46d73def == v0) {\n            hasHalted();\n        } else if (0x537f80c8 == v0) {\n            collectInvestment();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x895aaebf == v0) {\n            hasApproval();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x98d5fdca == v0) {\n            getPrice();\n        } else if (0xa86de694 == v0) {\n            checkAllowance(uint256);\n        } else if (0xb9b8af0b == v0) {\n            halted();\n        } else if (0xbb8da11d == v0) {\n            iconemy_wallet();\n        } else if (0xbd62ab5f == v0) {\n            refundAvailable();\n        } else if (0xc8e569a8 == v0) {\n            stopICO();\n        } else if (0xcb3f5290 == v0) {\n            collectCommission();\n        } else if (0xd0febe4c == v0) {\n            buyTokens();\n        } else if (0xd3b864ec == v0) {\n            allowanceOf();\n        } else if (0xe1489191 == v0) {\n            commission();\n        } else if (0xe42c08f2 == v0) {\n            tokenBalanceOf(address);\n        } else if (0xecb70fb7 == v0) {\n            hasEnded();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}