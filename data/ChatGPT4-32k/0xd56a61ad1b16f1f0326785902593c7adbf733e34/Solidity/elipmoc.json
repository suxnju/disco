{
	"address": "0xd56a61ad1b16f1f0326785902593c7adbf733e34",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, the Solidity smart contract may look something like this:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract DepositorContract {\n    uint256 private _initialized; \n    uint256 private _releaseTimestamp; \n    mapping (address => uint256) private _canWithdraw; \n    uint256 private stor_5; \n    uint256 private stor_6; \n    address private _slasher; \n    address private _depositorsProxy; \n\n    event DepositorRegistered(address indexed _from, uint256 _value);\n    event Withdraw(address indexed _from, uint256 _value);\n    event Deposit(uint256 _value, uint256 _perDepositor, uint256 _numDepositors);\n    event Slash(address indexed _from, uint256 _value);\n\n    function canWithdraw(address _address) public view returns (uint256) {\n        return _canWithdraw[_address];\n    }\n\n    function registerDepositor(address _address) public {\n        require(msg.sender == _depositorsProxy);\n        require(_canWithdraw[_address] == 0);\n        _canWithdraw[_address] = 1;\n        stor_5 += 1;\n        emit DepositorRegistered(_address, stor_5 + 1);\n    }\n\n    function withdraw() public {\n        require(block.timestamp >= _releaseTimestamp);\n        require(_canWithdraw[msg.sender] != 0);\n        _canWithdraw[msg.sender] = 0;\n        (bool success, ) = msg.sender.call{value: stor_6, gas: 2300}(\"\");\n        require(success);\n        emit Withdraw(msg.sender, stor_6);\n    }\n\n    function init(uint256 _time, address _slasherAddress, address _depositorsProxyAddress) public {\n        require(msg.sender == address(_initialized));\n        require(_time > block.timestamp);\n        _releaseTimestamp = _time;\n        _slasher = _slasherAddress;\n        _depositorsProxy = _depositorsProxyAddress;\n        _initialized = 1;\n    }\n\n    function owner() public view returns (address) {\n        return address(_initialized);\n    }\n\n    function slasher() public view returns (address) {\n        return _slasher;\n    }\n\n    function deposit(uint256 _value) public payable {\n        require(msg.sender == _depositorsProxy);\n        require(_value > 0);\n        require(msg.value == _value * stor_5);\n        stor_6 = _value;\n        _initialized = 1;\n        emit Deposit(msg.value, _value, stor_5);\n    }\n\n    function slash(address _address) public {\n        require(msg.sender == _slasher);\n        require(_canWithdraw[_address] != 0);\n        _canWithdraw[_address] = 0;\n        (bool success, ) = address(0).call{value: stor_6, gas: 2300}(\"\");\n        require(success);\n        emit Slash(_address, stor_6);\n    }\n\n    function depositorsProxy() public view returns (address) {\n        return _depositorsProxy;\n    }\n\n    function deposited() public view returns (uint256) {\n        return _initialized;\n    }\n\n    function transferOwnership(address _address) public {\n        require(msg.sender == address(_initialized));\n        if (_address != address(0)) {\n            _initialized = uint256(_address);\n        }\n    }\n\n    function fallback() public {\n    }\n\n    function releaseTimestamp() public view returns (uint256) {\n        return _releaseTimestamp;\n    }\n\n    function initialized() public view returns (uint256) {\n        return _initialized;\n    }\n}\n```\nPlease note that the provided decompiled code lacks clarity in some places, so some assumptions had to be made in this conversion. For example, the fallback function is left empty as the original function is not clear from the decompiled code. Also, the \"__function_selector__\" function is not represented in the Solidity code as it is not a standard Solidity function and appears to be specific to EVM Bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456064,
	"id": "chatcmpl-8R2jgS38KLJ1Ev3HFRAREtWNz0UTw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 12:12 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _initialized; // STORAGE[0x0]\nuint256 _releaseTimestamp; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _canWithdraw; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\naddress _slasher; // STORAGE[0x1] bytes 0 to 19\naddress _depositorsProxy; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nDepositorRegistered(address, uint256);\nWithdraw(address, uint256);\nDeposit(uint256, uint256, uint256);\nSlash(address, uint256);\n\nfunction canWithdraw(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _canWithdraw[varg0];\n}\n\nfunction registerDepositor(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(!(0xff & _initialized >> 168), 'already deposited');\n    require(msg.sender == _depositorsProxy, 'Only the depositorsProxy can call this function.');\n    require(!(0xff & _canWithdraw[varg0]), 'can only register Depositor once');\n    _canWithdraw[varg0] = 0x1 | ~0xff & _canWithdraw[varg0];\n    stor_5 += 1;\n    emit DepositorRegistered(varg0, 1 + stor_5);\n}\n\nfunction withdraw() public nonPayable { \n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(0xff & _initialized >> 168, 'no deposits yet');\n    require(block.timestamp >= _releaseTimestamp, 'The deposit cannot be withdrawn yet.');\n    require(0xff & _canWithdraw[msg.sender], 'cannot withdraw from sender');\n    _canWithdraw[msg.sender] = ~0xff & _canWithdraw[msg.sender];\n    v0 = msg.sender.call().value(stor_6).gas(2300 * !stor_6);\n    require(v0); // checks call status, propagates error data on error\n    emit Withdraw(msg.sender, stor_6);\n}\n\nfunction init(uint256 varg0, address varg1, address varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == address(_initialized), 'The function can only be called by the owner');\n    require(!(0xff & _initialized >> 160), 'The contract is already initialised.');\n    require(varg0 > block.timestamp, 'The release timestamp must be in the future');\n    _releaseTimestamp = varg0;\n    _slasher = varg1;\n    _depositorsProxy = varg2;\n    _initialized = ~0xffffffffffffffffffffffffffffffffffffffff & (0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _initialized);\n}\n\nfunction owner() public nonPayable { \n    return address(_initialized);\n}\n\nfunction slasher() public nonPayable { \n    return _slasher;\n}\n\nfunction deposit(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(!(0xff & _initialized >> 168), 'already deposited');\n    require(msg.sender == _depositorsProxy, 'Only the depositorsProxy can call this function.');\n    require(stor_5 > 0, 'no depositors');\n    require(varg0 > 0, '_valuePerDepositor must be positive');\n    assert(stor_5);\n    require(varg0 == varg0 * stor_5 / stor_5, 'Overflow in depositAmount calculation');\n    require(msg.value == varg0 * stor_5, 'the deposit does not match the required value');\n    stor_6 = varg0;\n    _initialized = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & _initialized;\n    emit Deposit(msg.value, varg0, stor_5);\n}\n\nfunction slash(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(0xff & _initialized >> 168, 'no deposits yet');\n    require(msg.sender == _slasher, 'Only the slasher can call this function.');\n    require(0xff & _canWithdraw[varg0], 'cannot slash address');\n    _canWithdraw[varg0] = ~0xff & _canWithdraw[varg0];\n    v0 = 0x0.call().value(stor_6).gas(2300 * !stor_6);\n    require(v0); // checks call status, propagates error data on error\n    emit Slash(varg0, stor_6);\n}\n\nfunction depositorsProxy() public nonPayable { \n    return _depositorsProxy;\n}\n\nfunction deposited() public nonPayable { \n    return 0xff & _initialized >> 168;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(_initialized), 'The function can only be called by the owner');\n    if (varg0) {\n        _initialized = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _initialized;\n    }\n}\n\nfunction fallback() public nonPayable { \n}\n\nfunction releaseTimestamp() public nonPayable { \n    return _releaseTimestamp;\n}\n\nfunction initialized() public nonPayable { \n    return 0xff & _initialized >> 160;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8da5cb5b > function_selector >> 224) {\n            if (0xa3f013f == function_selector >> 224) {\n                releaseTimestamp();\n            } else if (0x158ef93e == function_selector >> 224) {\n                initialized();\n            } else if (0x19262d30 == function_selector >> 224) {\n                canWithdraw(address);\n            } else if (0x38c56be1 == function_selector >> 224) {\n                registerDepositor(address);\n            } else if (0x3ccfd60b == function_selector >> 224) {\n                withdraw();\n            } else if (0x4557b4bb == function_selector >> 224) {\n                init(uint256,address,address);\n            }\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0xb1344271 == function_selector >> 224) {\n            slasher();\n        } else if (0xb6b55f25 == function_selector >> 224) {\n            deposit(uint256);\n        } else if (0xc96be4cb == function_selector >> 224) {\n            slash(address);\n        } else if (0xe8823af1 == function_selector >> 224) {\n            depositorsProxy();\n        } else if (0xeef49ee3 == function_selector >> 224) {\n            deposited();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 12:12 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _initialized; // STORAGE[0x0]\nuint256 _releaseTimestamp; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _canWithdraw; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\naddress _slasher; // STORAGE[0x1] bytes 0 to 19\naddress _depositorsProxy; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nDepositorRegistered(address, uint256);\nWithdraw(address, uint256);\nDeposit(uint256, uint256, uint256);\nSlash(address, uint256);\n\nfunction canWithdraw(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _canWithdraw[varg0];\n}\n\nfunction registerDepositor(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(!(0xff & _initialized >> 168), 'already deposited');\n    require(msg.sender == _depositorsProxy, 'Only the depositorsProxy can call this function.');\n    require(!(0xff & _canWithdraw[varg0]), 'can only register Depositor once');\n    _canWithdraw[varg0] = 0x1 | ~0xff & _canWithdraw[varg0];\n    stor_5 += 1;\n    emit DepositorRegistered(varg0, 1 + stor_5);\n}\n\nfunction withdraw() public nonPayable { \n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(0xff & _initialized >> 168, 'no deposits yet');\n    require(block.timestamp >= _releaseTimestamp, 'The deposit cannot be withdrawn yet.');\n    require(0xff & _canWithdraw[msg.sender], 'cannot withdraw from sender');\n    _canWithdraw[msg.sender] = ~0xff & _canWithdraw[msg.sender];\n    v0 = msg.sender.call().value(stor_6).gas(2300 * !stor_6);\n    require(v0); // checks call status, propagates error data on error\n    emit Withdraw(msg.sender, stor_6);\n}\n\nfunction init(uint256 varg0, address varg1, address varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == address(_initialized), 'The function can only be called by the owner');\n    require(!(0xff & _initialized >> 160), 'The contract is already initialised.');\n    require(varg0 > block.timestamp, 'The release timestamp must be in the future');\n    _releaseTimestamp = varg0;\n    _slasher = varg1;\n    _depositorsProxy = varg2;\n    _initialized = ~0xffffffffffffffffffffffffffffffffffffffff & (0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _initialized);\n}\n\nfunction owner() public nonPayable { \n    return address(_initialized);\n}\n\nfunction slasher() public nonPayable { \n    return _slasher;\n}\n\nfunction deposit(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(!(0xff & _initialized >> 168), 'already deposited');\n    require(msg.sender == _depositorsProxy, 'Only the depositorsProxy can call this function.');\n    require(stor_5 > 0, 'no depositors');\n    require(varg0 > 0, '_valuePerDepositor must be positive');\n    assert(stor_5);\n    require(varg0 == varg0 * stor_5 / stor_5, 'Overflow in depositAmount calculation');\n    require(msg.value == varg0 * stor_5, 'the deposit does not match the required value');\n    stor_6 = varg0;\n    _initialized = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & _initialized;\n    emit Deposit(msg.value, varg0, stor_5);\n}\n\nfunction slash(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(0xff & _initialized >> 168, 'no deposits yet');\n    require(msg.sender == _slasher, 'Only the slasher can call this function.');\n    require(0xff & _canWithdraw[varg0], 'cannot slash address');\n    _canWithdraw[varg0] = ~0xff & _canWithdraw[varg0];\n    v0 = 0x0.call().value(stor_6).gas(2300 * !stor_6);\n    require(v0); // checks call status, propagates error data on error\n    emit Slash(varg0, stor_6);\n}\n\nfunction depositorsProxy() public nonPayable { \n    return _depositorsProxy;\n}\n\nfunction deposited() public nonPayable { \n    return 0xff & _initialized >> 168;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(_initialized), 'The function can only be called by the owner');\n    if (varg0) {\n        _initialized = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _initialized;\n    }\n}\n\nfunction fallback() public nonPayable { \n}\n\nfunction releaseTimestamp() public nonPayable { \n    return _releaseTimestamp;\n}\n\nfunction initialized() public nonPayable { \n    return 0xff & _initialized >> 160;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8da5cb5b > function_selector >> 224) {\n            if (0xa3f013f == function_selector >> 224) {\n                releaseTimestamp();\n            } else if (0x158ef93e == function_selector >> 224) {\n                initialized();\n            } else if (0x19262d30 == function_selector >> 224) {\n                canWithdraw(address);\n            } else if (0x38c56be1 == function_selector >> 224) {\n                registerDepositor(address);\n            } else if (0x3ccfd60b == function_selector >> 224) {\n                withdraw();\n            } else if (0x4557b4bb == function_selector >> 224) {\n                init(uint256,address,address);\n            }\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0xb1344271 == function_selector >> 224) {\n            slasher();\n        } else if (0xb6b55f25 == function_selector >> 224) {\n            deposit(uint256);\n        } else if (0xc96be4cb == function_selector >> 224) {\n            slash(address);\n        } else if (0xe8823af1 == function_selector >> 224) {\n            depositorsProxy();\n        } else if (0xeef49ee3 == function_selector >> 224) {\n            deposited();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 12:12 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _initialized; // STORAGE[0x0]\nuint256 _releaseTimestamp; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _canWithdraw; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\naddress _slasher; // STORAGE[0x1] bytes 0 to 19\naddress _depositorsProxy; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nDepositorRegistered(address, uint256);\nWithdraw(address, uint256);\nDeposit(uint256, uint256, uint256);\nSlash(address, uint256);\n\nfunction canWithdraw(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _canWithdraw[varg0];\n}\n\nfunction registerDepositor(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(!(0xff & _initialized >> 168), 'already deposited');\n    require(msg.sender == _depositorsProxy, 'Only the depositorsProxy can call this function.');\n    require(!(0xff & _canWithdraw[varg0]), 'can only register Depositor once');\n    _canWithdraw[varg0] = 0x1 | ~0xff & _canWithdraw[varg0];\n    stor_5 += 1;\n    emit DepositorRegistered(varg0, 1 + stor_5);\n}\n\nfunction withdraw() public nonPayable { \n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(0xff & _initialized >> 168, 'no deposits yet');\n    require(block.timestamp >= _releaseTimestamp, 'The deposit cannot be withdrawn yet.');\n    require(0xff & _canWithdraw[msg.sender], 'cannot withdraw from sender');\n    _canWithdraw[msg.sender] = ~0xff & _canWithdraw[msg.sender];\n    v0 = msg.sender.call().value(stor_6).gas(2300 * !stor_6);\n    require(v0); // checks call status, propagates error data on error\n    emit Withdraw(msg.sender, stor_6);\n}\n\nfunction init(uint256 varg0, address varg1, address varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == address(_initialized), 'The function can only be called by the owner');\n    require(!(0xff & _initialized >> 160), 'The contract is already initialised.');\n    require(varg0 > block.timestamp, 'The release timestamp must be in the future');\n    _releaseTimestamp = varg0;\n    _slasher = varg1;\n    _depositorsProxy = varg2;\n    _initialized = ~0xffffffffffffffffffffffffffffffffffffffff & (0x10000000000000000000000000000000000000000 | ~0xff0000000000000000000000000000000000000000 & _initialized);\n}\n\nfunction owner() public nonPayable { \n    return address(_initialized);\n}\n\nfunction slasher() public nonPayable { \n    return _slasher;\n}\n\nfunction deposit(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(!(0xff & _initialized >> 168), 'already deposited');\n    require(msg.sender == _depositorsProxy, 'Only the depositorsProxy can call this function.');\n    require(stor_5 > 0, 'no depositors');\n    require(varg0 > 0, '_valuePerDepositor must be positive');\n    assert(stor_5);\n    require(varg0 == varg0 * stor_5 / stor_5, 'Overflow in depositAmount calculation');\n    require(msg.value == varg0 * stor_5, 'the deposit does not match the required value');\n    stor_6 = varg0;\n    _initialized = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & _initialized;\n    emit Deposit(msg.value, varg0, stor_5);\n}\n\nfunction slash(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _initialized >> 160, 'The contract was not initialized.');\n    require(0xff & _initialized >> 168, 'no deposits yet');\n    require(msg.sender == _slasher, 'Only the slasher can call this function.');\n    require(0xff & _canWithdraw[varg0], 'cannot slash address');\n    _canWithdraw[varg0] = ~0xff & _canWithdraw[varg0];\n    v0 = 0x0.call().value(stor_6).gas(2300 * !stor_6);\n    require(v0); // checks call status, propagates error data on error\n    emit Slash(varg0, stor_6);\n}\n\nfunction depositorsProxy() public nonPayable { \n    return _depositorsProxy;\n}\n\nfunction deposited() public nonPayable { \n    return 0xff & _initialized >> 168;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(_initialized), 'The function can only be called by the owner');\n    if (varg0) {\n        _initialized = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _initialized;\n    }\n}\n\nfunction fallback() public nonPayable { \n}\n\nfunction releaseTimestamp() public nonPayable { \n    return _releaseTimestamp;\n}\n\nfunction initialized() public nonPayable { \n    return 0xff & _initialized >> 160;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8da5cb5b > function_selector >> 224) {\n            if (0xa3f013f == function_selector >> 224) {\n                releaseTimestamp();\n            } else if (0x158ef93e == function_selector >> 224) {\n                initialized();\n            } else if (0x19262d30 == function_selector >> 224) {\n                canWithdraw(address);\n            } else if (0x38c56be1 == function_selector >> 224) {\n                registerDepositor(address);\n            } else if (0x3ccfd60b == function_selector >> 224) {\n                withdraw();\n            } else if (0x4557b4bb == function_selector >> 224) {\n                init(uint256,address,address);\n            }\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0xb1344271 == function_selector >> 224) {\n            slasher();\n        } else if (0xb6b55f25 == function_selector >> 224) {\n            deposit(uint256);\n        } else if (0xc96be4cb == function_selector >> 224) {\n            slash(address);\n        } else if (0xe8823af1 == function_selector >> 224) {\n            depositorsProxy();\n        } else if (0xeef49ee3 == function_selector >> 224) {\n            deposited();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 57.23743391036987,
	"usage": {
		"completion_tokens": 844,
		"prompt_tokens": 1760,
		"total_tokens": 2604
	}
}