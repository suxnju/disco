{
	"address": "0xe15da1ed37948205e740e365047af8b33a51cb82",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The following Solidity code is based on the decompiled code provided:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract YourContract is ReentrancyGuard, Ownable {\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(address => bool) private _isExcludedFromFee;\n    mapping(address => bool) private _isBlacklisted;\n\n    string[] private _name;\n    string[] private _symbol;\n\n    uint256 private _totalSupply;\n    uint256 private _decimals;\n\n    address private _uniswapV2Router;\n    address private _uniswapV2Pair;\n\n    bool private _inSwapAndLiquify;\n    bool private _swapAndLiquifyEnabled;\n    bool private _noFeeToTransfer;\n    bool private _noBlackList;\n\n    uint256 private _buyFee;\n    uint256 private _sellFee;\n    uint256 private _maxWalletToken;\n    uint256 private _maxTxAmount;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() Ownable() {\n        // Initialize your contract here\n    }\n\n    function symbol() public view returns (string memory) {\n        // Logic to return the symbol of the token\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        // Logic to approve an address to spend a certain amount of tokens on behalf of the msg.sender\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        // Logic to transfer a certain amount of tokens from one address to another\n    }\n\n    function totalSupply() public view returns (uint256) {\n        // Logic to return the total supply of the tokens\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        // Logic to return the balance of a certain account\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        // Logic to return the amount of tokens a spender is allowed to spend on behalf of the owner\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        // Logic to transfer a certain amount of tokens to a certain address\n    }\n\n    // Add other functions based on the decompiled code\n}\n```\n\nThis code is a boilerplate for a simple ERC20 token with some additional features, such as fees on transfer and an allowance for spending tokens on behalf of the owner. Please note that you will need to implement the logic for each function based on your specific requirements and the decompiled code provided. The decompiled code provided does not include the logic for each function, but it does provide a list of functions and state variables that your contract should have.",
				"role": "assistant"
			}
		}
	],
	"created": 1700632734,
	"id": "chatcmpl-8NaYAvDvexiCF7CwrSarPBBenQj3Y",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.18 17:39 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _@_approve_2053; // STORAGE[0x2]\nmapping (uint256 => uint256) __isExcludedFromFee; // STORAGE[0x3]\nmapping (uint256 => uint256) __isBlacklisted; // STORAGE[0x4]\nuint256[] _@name_1482; // STORAGE[0x8]\nuint256[] _@symbol_1490; // STORAGE[0x9]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __buyFee; // STORAGE[0x10]\nuint256 __sellFee; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_13; // STORAGE[0x13]\nuint256 stor_14; // STORAGE[0x14]\nuint256 __maxWalletToken; // STORAGE[0x15]\nuint256 __maxTxAmount; // STORAGE[0x17]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _noBlackList; // STORAGE[0x5] bytes 0 to 0\nuint256 _decimals; // STORAGE[0xa] bytes 0 to 0\nuint256 _@swapAndLiquify_2303; // STORAGE[0x5] bytes 1 to 20\nuint256 stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\nuint256 _uniswapV2Router; // STORAGE[0x19] bytes 0 to 19\nuint256 _uniswapV2Pair; // STORAGE[0x1a] bytes 0 to 19\nuint256 _inSwapAndLiquify; // STORAGE[0x1a] bytes 20 to 20\nuint256 _swapAndLiquifyEnabled; // STORAGE[0x1a] bytes 21 to 21\nuint256 _noFeeToTransfer; // STORAGE[0x1a] bytes 22 to 22\n\n\n// Events\nOwnershipTransferred(address, address);\nSwapAndLiquifyEnabledUpdated(bool);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction @symbol_1490() private { \n    v0 = v1 = _@symbol_1490.length >> 1;\n    if (!(_@symbol_1490.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_1490.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_1490.length >> 1;\n    if (!(_@symbol_1490.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_1490.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_1490.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_1490.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_2053(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = bool(address(varg2));\n    if (varg2) {\n        v0 = v2 = bool(address(varg1));\n    }\n    require(v0, Error('ERR: zero address'));\n    _@_approve_2053[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2264(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = _owner != address(varg1);\n    if (_owner != address(varg1)) {\n        v0 = v2 = _@swapAndLiquify_2303 != address(varg1);\n    }\n    if (v0) {\n        v0 = v3 = this != address(varg1);\n    }\n    if (v0) {\n        v0 = v4 = _uniswapV2Pair != address(varg1);\n    }\n    if (v0) {\n        v0 = v5 = stor_6_0_19 != address(varg1);\n    }\n    if (v0) {\n        v0 = v6 = _owner != address(varg2);\n    }\n    if (v0) {\n        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletToken, Error('You are trying to buy too many tokens. You have reached the limit for one wallet.'));\n    }\n    v7 = v8 = _owner != address(varg2);\n    if (_owner != address(varg2)) {\n        v7 = v9 = _owner != address(varg1);\n    }\n    if (v7) {\n        require(varg0 <= __maxTxAmount, Error('You are trying to buy more than the max transaction limit.'));\n    }\n    if (_noBlackList) {\n        v10 = v11 = !uint8(__isBlacklisted[address(varg2)]);\n        if (!bool(uint8(__isBlacklisted[address(varg2)]))) {\n            v10 = v12 = !uint8(__isBlacklisted[address(varg1)]);\n        }\n        require(v10, Error('This address is blacklisted. Transaction reverted.'));\n    }\n    v13 = v14 = bool(address(varg2));\n    if (address(varg2)) {\n        v13 = v15 = bool(address(varg1));\n    }\n    require(v13, Error('ERR: Using 0 address!'));\n    require(varg0 > 0, Error('Token value must be higher than zero.'));\n    v16 = v17 = uint8(stor_d) >= uint8(stor_d >> 8);\n    if (uint8(stor_d) >= uint8(stor_d >> 8)) {\n        v16 = v18 = !_inSwapAndLiquify;\n    }\n    if (v16) {\n        v16 = v19 = _uniswapV2Pair != address(varg2);\n    }\n    if (v16) {\n        v16 = v20 = _swapAndLiquifyEnabled;\n    }\n    if (v16) {\n        stor_d = bytes31(stor_d);\n        v21 = v22 = _balanceOf[this];\n        if (v22 > __maxTxAmount) {\n            v21 = v23 = __maxTxAmount;\n        }\n        if (v21) {\n            @swapAndLiquify_2303(v21);\n        }\n    }\n    v24 = v25 = 1;\n    v26 = v27 = uint8(__isExcludedFromFee[address(varg2)]);\n    if (!v27) {\n        v26 = v28 = uint8(__isExcludedFromFee[address(varg1)]);\n    }\n    if (!v26) {\n        v26 = v29 = _noFeeToTransfer;\n        if (v29) {\n            v26 = v30 = _uniswapV2Pair != address(varg2);\n        }\n        if (v26) {\n            v26 = v31 = _uniswapV2Pair != address(varg1);\n        }\n    }\n    if (!v26) {\n        if (address(varg2) - _uniswapV2Pair) {\n            if (!(address(varg1) - _uniswapV2Pair)) {\n                stor_f = __sellFee;\n            }\n        } else {\n            stor_f = __buyFee;\n        }\n    } else {\n        v24 = v32 = 0;\n    }\n    if (v24) {\n        require(uint8(stor_d) - uint8.max, Panic(17)); // arithmetic overflow or underflow\n        stor_d = uint8(1 + uint8(uint8(stor_d))) | ~0xff & stor_d;\n    } else {\n        v33 = v34 = !stor_f;\n        if (!bool(stor_f)) {\n            v33 = v35 = !__buyFee;\n        }\n        if (v33) {\n            v33 = !__sellFee;\n        }\n        if (!v33) {\n            stor_13 = __buyFee;\n            stor_14 = __sellFee;\n            stor_12 = stor_f;\n            __buyFee = 0;\n            __sellFee = 0;\n            stor_f = 0;\n            // Unknown jump to Block 0x1ad5B0x1a2f. Refer to 3-address code (TAC);\n        }\n        // Unknown jump to Block 0x1b06B0x1a2f. Refer to 3-address code (TAC);\n    }\n    require((stor_f == stor_f * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    v36 = _SafeSub(stor_f * varg0 / 100, varg0);\n    v37 = _SafeSub(varg0, _balanceOf[address(varg2)]);\n    _balanceOf[address(varg2)] = v37;\n    v38 = _SafeAdd(v36, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v38;\n    v39 = _SafeAdd(stor_f * varg0 / 100, _balanceOf[this]);\n    _balanceOf[this] = v39;\n    emit Transfer(address(varg2), address(varg1), v36);\n    if (v24) {\n        // Unknown jump to Block 0x310a. Refer to 3-address code (TAC);\n    } else {\n        stor_f = stor_12;\n        __buyFee = stor_13;\n        __sellFee = stor_14;\n    }\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= varg0 + varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 + varg1;\n}\n\nfunction @swapAndLiquify_2303(uint256 varg0) private { \n    _inSwapAndLiquify = 1;\n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = _uniswapV2Router.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    @_approve_2053(varg0, _uniswapV2Router, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(_uniswapV2Router.code.size));\n    v11 = _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v13 = _@swapAndLiquify_2303.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v13), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    _inSwapAndLiquify = 0;\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 <= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg1 - varg0;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_1482();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_2053(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction set_New_Router_and_Make_Pair(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* address */ v1 = varg0.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = varg0.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _uniswapV2Pair = v5;\n    _uniswapV2Router = varg0;\n}\n\nfunction noFeeToTransfer() public nonPayable { \n    return _noFeeToTransfer;\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return _uniswapV2Router;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction () public payable { \n}\n\nfunction _isBlacklisted(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isBlacklisted[varg0]));\n}\n\nfunction inSwapAndLiquify() public nonPayable { \n    return _inSwapAndLiquify;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_2264(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _@_approve_2053[varg0][msg.sender]);\n    @_approve_2053(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction set_Max_Transaction_Percent(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(10000, Panic(18)); // division by zero\n    __maxTxAmount = varg0 * _totalSupply / 10000;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction remove_Random_Tokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 - this, Error('Can not remove native token'));\n    v0, /* uint256 */ v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v2, /* bool */ v3 = varg0.transfer(varg1, v1).gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == bool(v3));\n    return bool(v3);\n}\n\nfunction set_New_Router_Address(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _uniswapV2Router = varg0;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeAdd(varg1, _@_approve_2053[msg.sender][varg0]);\n    @_approve_2053(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _buyFee() public nonPayable { \n    return __buyFee;\n}\n\nfunction excludeFromFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedFromFee[varg0] = 0x1 | bytes31(__isExcludedFromFee[address(varg0)]);\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return _uniswapV2Pair;\n}\n\nfunction swapAndLiquifyEnabled() public nonPayable { \n    return _swapAndLiquifyEnabled;\n}\n\nfunction _sellFee() public nonPayable { \n    return __sellFee;\n}\n\nfunction _set_Fees(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 <= stor_e, Error('Fee is too high!'));\n    __sellFee = varg1;\n    __buyFee = varg0;\n}\n\nfunction noBlackList() public nonPayable { \n    return _noBlackList;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction _isExcludedFromFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isExcludedFromFee[varg0]));\n}\n\nfunction _maxWalletToken() public nonPayable { \n    return __maxWalletToken;\n}\n\nfunction set_Number_Of_Transactions_Before_Liquify_Trigger(uint8 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_d = stor_d & ~0xff00 | varg0 << 8;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction Wallet_Update_Dev(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _@swapAndLiquify_2303 = varg0;\n    __isExcludedFromFee[address((address(varg0) << 8 | ~0xffffffffffffffffffffffffffffffffffffffff00 & STORAGE[0x5]) >> 8)] = 0x1 | bytes31(__isExcludedFromFee[address((address(varg0) << 8 | ~0xffffffffffffffffffffffffffffffffffffffff00 & STORAGE[0x5]) >> 8)]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction blacklist_Remove_Wallets(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max);\n    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < varg0.length) {\n        if (v0 < msg.gas) {\n            require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n            require(varg0[v2] == address(varg0[v2]));\n            if (uint8(__isBlacklisted[address(varg0[v2])])) {\n                require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n                require(varg0[v2] == address(varg0[v2]));\n                __isBlacklisted[address(varg0[v2])] = bool(0) | bytes31(__isBlacklisted[address(varg0[v2])]);\n            }\n            v0 = msg.gas - msg.gas;\n            require(v0 <= msg.gas, Panic(17)); // arithmetic overflow or underflow\n        }\n        require(v2 + 1, Panic(17)); // arithmetic overflow or underflow\n        v2 += 1;\n    }\n}\n\nfunction set_Max_Wallet_Percent(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(10000, Panic(18)); // division by zero\n    __maxWalletToken = varg0 * _totalSupply / 10000;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_1490();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _@_approve_2053[msg.sender][varg0]);\n    @_approve_2053(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction set_Transfers_Without_Fees(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _noFeeToTransfer = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_2264(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction blacklist_Add_Wallets(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max);\n    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < varg0.length) {\n        if (v0 < msg.gas) {\n            require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n            require(varg0[v2] == address(varg0[v2]));\n            if (!uint8(__isBlacklisted[address(varg0[v2])])) {\n                require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n                require(varg0[v2] == address(varg0[v2]));\n                __isBlacklisted[address(varg0[v2])] = bool(1) | bytes31(__isBlacklisted[address(varg0[v2])]);\n            }\n            v0 = msg.gas - msg.gas;\n            require(v0 <= msg.gas, Panic(17)); // arithmetic overflow or underflow\n        }\n        require(v2 + 1, Panic(17)); // arithmetic overflow or underflow\n        v2 += 1;\n    }\n}\n\nfunction blacklist_Switch(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _noBlackList = varg0;\n}\n\nfunction set_New_Pair_Address(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _uniswapV2Pair = varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _@_approve_2053[varg0][varg1];\n}\n\nfunction process_Tokens_Now(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!_inSwapAndLiquify, Error('Currently processing, try later.'));\n    require((varg0 == varg0 * _balanceOf[this] / _balanceOf[this]) | !_balanceOf[this], Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    @swapAndLiquify_2303(varg0 * _balanceOf[this] / 100);\n}\n\nfunction includeInFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedFromFee[varg0] = bytes31(__isExcludedFromFee[address(varg0)]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction set_Swap_And_Liquify_Enabled(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _swapAndLiquifyEnabled = varg0;\n    emit SwapAndLiquifyEnabledUpdated(varg0);\n}\n\nfunction @name_1482() private { \n    v0 = v1 = _@name_1482.length >> 1;\n    if (!(_@name_1482.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_1482.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_1482.length >> 1;\n    if (!(_@name_1482.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_1482.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_1482.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_1482.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x70a08231 > v0) {\n            if (0x313ce567 > v0) {\n                if (0x18160ddd > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x1282a0a0 == v0) {\n                        set_New_Router_and_Make_Pair(address);\n                    } else if (0x13fad07a == v0) {\n                        noFeeToTransfer();\n                    } else {\n                        require(0x1694505e == v0);\n                        uniswapV2Router();\n                    }\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1cdd3be3 == v0) {\n                    _isBlacklisted(address);\n                } else if (0x220f6696 == v0) {\n                    inSwapAndLiquify();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else {\n                    require(0x2e39c6c6 == v0);\n                    set_Max_Transaction_Percent(uint256);\n                }\n            } else if (0x437823ec > v0) {\n                if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x3343ab83 == v0) {\n                    remove_Random_Tokens(address,address,uint256);\n                } else if (0x36b1a1bc == v0) {\n                    set_New_Router_Address(address);\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else {\n                    require(0x40b9a54b == v0);\n                    _buyFee();\n                }\n            } else if (0x437823ec == v0) {\n                excludeFromFee(address);\n            } else if (0x49bd5a5e == v0) {\n                uniswapV2Pair();\n            } else if (0x4a74bb02 == v0) {\n                swapAndLiquifyEnabled();\n            } else if (0x590f897e == v0) {\n                _sellFee();\n            } else if (0x67cbd84c == v0) {\n                _set_Fees(uint256,uint256);\n            } else {\n                require(0x6f0941f6 == v0);\n                noBlackList();\n            }\n        } else if (0xa457c2d7 > v0) {\n            if (0x7d1db4a5 > v0) {\n                if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x715018a6 == v0) {\n                    renounceOwnership();\n                } else if (0x768dc710 == v0) {\n                    _isExcludedFromFee(address);\n                } else if (0x78109e54 == v0) {\n                    _maxWalletToken();\n                } else {\n                    require(0x7caefa89 == v0);\n                    set_Number_Of_Transactions_Before_Liquify_Trigger(uint8);\n                }\n            } else if (0x7d1db4a5 == v0) {\n                _maxTxAmount();\n            } else if (0x8824e16e == v0) {\n                Wallet_Update_Dev(address);\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x8ec0e9a1 == v0) {\n                blacklist_Remove_Wallets(address[]);\n            } else if (0x94220184 == v0) {\n                set_Max_Wallet_Percent(uint256);\n            } else {\n                require(0x95d89b41 == v0);\n                symbol();\n            }\n        } else if (0xd785d5be > v0) {\n            if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa514a07d == v0) {\n                set_Transfers_Without_Fees(bool);\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xa9de975d == v0) {\n                blacklist_Add_Wallets(address[]);\n            } else {\n                require(0xc1f61908 == v0);\n                blacklist_Switch(bool);\n            }\n        } else if (0xd785d5be == v0) {\n            set_New_Pair_Address(address);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xddbf5266 == v0) {\n            process_Tokens_Now(uint256);\n        } else if (0xea2f0b37 == v0) {\n            includeInFee(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else {\n            require(0xf7739b5f == v0);\n            set_Swap_And_Liquify_Enabled(bool);\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.18 17:39 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _@_approve_2053; // STORAGE[0x2]\nmapping (uint256 => uint256) __isExcludedFromFee; // STORAGE[0x3]\nmapping (uint256 => uint256) __isBlacklisted; // STORAGE[0x4]\nuint256[] _@name_1482; // STORAGE[0x8]\nuint256[] _@symbol_1490; // STORAGE[0x9]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __buyFee; // STORAGE[0x10]\nuint256 __sellFee; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_13; // STORAGE[0x13]\nuint256 stor_14; // STORAGE[0x14]\nuint256 __maxWalletToken; // STORAGE[0x15]\nuint256 __maxTxAmount; // STORAGE[0x17]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _noBlackList; // STORAGE[0x5] bytes 0 to 0\nuint256 _decimals; // STORAGE[0xa] bytes 0 to 0\nuint256 _@swapAndLiquify_2303; // STORAGE[0x5] bytes 1 to 20\nuint256 stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\nuint256 _uniswapV2Router; // STORAGE[0x19] bytes 0 to 19\nuint256 _uniswapV2Pair; // STORAGE[0x1a] bytes 0 to 19\nuint256 _inSwapAndLiquify; // STORAGE[0x1a] bytes 20 to 20\nuint256 _swapAndLiquifyEnabled; // STORAGE[0x1a] bytes 21 to 21\nuint256 _noFeeToTransfer; // STORAGE[0x1a] bytes 22 to 22\n\n\n// Events\nOwnershipTransferred(address, address);\nSwapAndLiquifyEnabledUpdated(bool);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction @symbol_1490() private { \n    v0 = v1 = _@symbol_1490.length >> 1;\n    if (!(_@symbol_1490.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_1490.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_1490.length >> 1;\n    if (!(_@symbol_1490.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_1490.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_1490.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_1490.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_2053(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = bool(address(varg2));\n    if (varg2) {\n        v0 = v2 = bool(address(varg1));\n    }\n    require(v0, Error('ERR: zero address'));\n    _@_approve_2053[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2264(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = _owner != address(varg1);\n    if (_owner != address(varg1)) {\n        v0 = v2 = _@swapAndLiquify_2303 != address(varg1);\n    }\n    if (v0) {\n        v0 = v3 = this != address(varg1);\n    }\n    if (v0) {\n        v0 = v4 = _uniswapV2Pair != address(varg1);\n    }\n    if (v0) {\n        v0 = v5 = stor_6_0_19 != address(varg1);\n    }\n    if (v0) {\n        v0 = v6 = _owner != address(varg2);\n    }\n    if (v0) {\n        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletToken, Error('You are trying to buy too many tokens. You have reached the limit for one wallet.'));\n    }\n    v7 = v8 = _owner != address(varg2);\n    if (_owner != address(varg2)) {\n        v7 = v9 = _owner != address(varg1);\n    }\n    if (v7) {\n        require(varg0 <= __maxTxAmount, Error('You are trying to buy more than the max transaction limit.'));\n    }\n    if (_noBlackList) {\n        v10 = v11 = !uint8(__isBlacklisted[address(varg2)]);\n        if (!bool(uint8(__isBlacklisted[address(varg2)]))) {\n            v10 = v12 = !uint8(__isBlacklisted[address(varg1)]);\n        }\n        require(v10, Error('This address is blacklisted. Transaction reverted.'));\n    }\n    v13 = v14 = bool(address(varg2));\n    if (address(varg2)) {\n        v13 = v15 = bool(address(varg1));\n    }\n    require(v13, Error('ERR: Using 0 address!'));\n    require(varg0 > 0, Error('Token value must be higher than zero.'));\n    v16 = v17 = uint8(stor_d) >= uint8(stor_d >> 8);\n    if (uint8(stor_d) >= uint8(stor_d >> 8)) {\n        v16 = v18 = !_inSwapAndLiquify;\n    }\n    if (v16) {\n        v16 = v19 = _uniswapV2Pair != address(varg2);\n    }\n    if (v16) {\n        v16 = v20 = _swapAndLiquifyEnabled;\n    }\n    if (v16) {\n        stor_d = bytes31(stor_d);\n        v21 = v22 = _balanceOf[this];\n        if (v22 > __maxTxAmount) {\n            v21 = v23 = __maxTxAmount;\n        }\n        if (v21) {\n            @swapAndLiquify_2303(v21);\n        }\n    }\n    v24 = v25 = 1;\n    v26 = v27 = uint8(__isExcludedFromFee[address(varg2)]);\n    if (!v27) {\n        v26 = v28 = uint8(__isExcludedFromFee[address(varg1)]);\n    }\n    if (!v26) {\n        v26 = v29 = _noFeeToTransfer;\n        if (v29) {\n            v26 = v30 = _uniswapV2Pair != address(varg2);\n        }\n        if (v26) {\n            v26 = v31 = _uniswapV2Pair != address(varg1);\n        }\n    }\n    if (!v26) {\n        if (address(varg2) - _uniswapV2Pair) {\n            if (!(address(varg1) - _uniswapV2Pair)) {\n                stor_f = __sellFee;\n            }\n        } else {\n            stor_f = __buyFee;\n        }\n    } else {\n        v24 = v32 = 0;\n    }\n    if (v24) {\n        require(uint8(stor_d) - uint8.max, Panic(17)); // arithmetic overflow or underflow\n        stor_d = uint8(1 + uint8(uint8(stor_d))) | ~0xff & stor_d;\n    } else {\n        v33 = v34 = !stor_f;\n        if (!bool(stor_f)) {\n            v33 = v35 = !__buyFee;\n        }\n        if (v33) {\n            v33 = !__sellFee;\n        }\n        if (!v33) {\n            stor_13 = __buyFee;\n            stor_14 = __sellFee;\n            stor_12 = stor_f;\n            __buyFee = 0;\n            __sellFee = 0;\n            stor_f = 0;\n            // Unknown jump to Block 0x1ad5B0x1a2f. Refer to 3-address code (TAC);\n        }\n        // Unknown jump to Block 0x1b06B0x1a2f. Refer to 3-address code (TAC);\n    }\n    require((stor_f == stor_f * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    v36 = _SafeSub(stor_f * varg0 / 100, varg0);\n    v37 = _SafeSub(varg0, _balanceOf[address(varg2)]);\n    _balanceOf[address(varg2)] = v37;\n    v38 = _SafeAdd(v36, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v38;\n    v39 = _SafeAdd(stor_f * varg0 / 100, _balanceOf[this]);\n    _balanceOf[this] = v39;\n    emit Transfer(address(varg2), address(varg1), v36);\n    if (v24) {\n        // Unknown jump to Block 0x310a. Refer to 3-address code (TAC);\n    } else {\n        stor_f = stor_12;\n        __buyFee = stor_13;\n        __sellFee = stor_14;\n    }\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= varg0 + varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 + varg1;\n}\n\nfunction @swapAndLiquify_2303(uint256 varg0) private { \n    _inSwapAndLiquify = 1;\n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = _uniswapV2Router.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    @_approve_2053(varg0, _uniswapV2Router, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(_uniswapV2Router.code.size));\n    v11 = _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v13 = _@swapAndLiquify_2303.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v13), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    _inSwapAndLiquify = 0;\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 <= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg1 - varg0;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_1482();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_2053(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction set_New_Router_and_Make_Pair(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* address */ v1 = varg0.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = varg0.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _uniswapV2Pair = v5;\n    _uniswapV2Router = varg0;\n}\n\nfunction noFeeToTransfer() public nonPayable { \n    return _noFeeToTransfer;\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return _uniswapV2Router;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction () public payable { \n}\n\nfunction _isBlacklisted(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isBlacklisted[varg0]));\n}\n\nfunction inSwapAndLiquify() public nonPayable { \n    return _inSwapAndLiquify;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_2264(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _@_approve_2053[varg0][msg.sender]);\n    @_approve_2053(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction set_Max_Transaction_Percent(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(10000, Panic(18)); // division by zero\n    __maxTxAmount = varg0 * _totalSupply / 10000;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction remove_Random_Tokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 - this, Error('Can not remove native token'));\n    v0, /* uint256 */ v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v2, /* bool */ v3 = varg0.transfer(varg1, v1).gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == bool(v3));\n    return bool(v3);\n}\n\nfunction set_New_Router_Address(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _uniswapV2Router = varg0;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeAdd(varg1, _@_approve_2053[msg.sender][varg0]);\n    @_approve_2053(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _buyFee() public nonPayable { \n    return __buyFee;\n}\n\nfunction excludeFromFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedFromFee[varg0] = 0x1 | bytes31(__isExcludedFromFee[address(varg0)]);\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return _uniswapV2Pair;\n}\n\nfunction swapAndLiquifyEnabled() public nonPayable { \n    return _swapAndLiquifyEnabled;\n}\n\nfunction _sellFee() public nonPayable { \n    return __sellFee;\n}\n\nfunction _set_Fees(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 <= stor_e, Error('Fee is too high!'));\n    __sellFee = varg1;\n    __buyFee = varg0;\n}\n\nfunction noBlackList() public nonPayable { \n    return _noBlackList;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction _isExcludedFromFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isExcludedFromFee[varg0]));\n}\n\nfunction _maxWalletToken() public nonPayable { \n    return __maxWalletToken;\n}\n\nfunction set_Number_Of_Transactions_Before_Liquify_Trigger(uint8 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_d = stor_d & ~0xff00 | varg0 << 8;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction Wallet_Update_Dev(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _@swapAndLiquify_2303 = varg0;\n    __isExcludedFromFee[address((address(varg0) << 8 | ~0xffffffffffffffffffffffffffffffffffffffff00 & STORAGE[0x5]) >> 8)] = 0x1 | bytes31(__isExcludedFromFee[address((address(varg0) << 8 | ~0xffffffffffffffffffffffffffffffffffffffff00 & STORAGE[0x5]) >> 8)]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction blacklist_Remove_Wallets(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max);\n    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < varg0.length) {\n        if (v0 < msg.gas) {\n            require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n            require(varg0[v2] == address(varg0[v2]));\n            if (uint8(__isBlacklisted[address(varg0[v2])])) {\n                require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n                require(varg0[v2] == address(varg0[v2]));\n                __isBlacklisted[address(varg0[v2])] = bool(0) | bytes31(__isBlacklisted[address(varg0[v2])]);\n            }\n            v0 = msg.gas - msg.gas;\n            require(v0 <= msg.gas, Panic(17)); // arithmetic overflow or underflow\n        }\n        require(v2 + 1, Panic(17)); // arithmetic overflow or underflow\n        v2 += 1;\n    }\n}\n\nfunction set_Max_Wallet_Percent(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(10000, Panic(18)); // division by zero\n    __maxWalletToken = varg0 * _totalSupply / 10000;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_1490();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _@_approve_2053[msg.sender][varg0]);\n    @_approve_2053(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction set_Transfers_Without_Fees(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _noFeeToTransfer = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_2264(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction blacklist_Add_Wallets(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max);\n    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < varg0.length) {\n        if (v0 < msg.gas) {\n            require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n            require(varg0[v2] == address(varg0[v2]));\n            if (!uint8(__isBlacklisted[address(varg0[v2])])) {\n                require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n                require(varg0[v2] == address(varg0[v2]));\n                __isBlacklisted[address(varg0[v2])] = bool(1) | bytes31(__isBlacklisted[address(varg0[v2])]);\n            }\n            v0 = msg.gas - msg.gas;\n            require(v0 <= msg.gas, Panic(17)); // arithmetic overflow or underflow\n        }\n        require(v2 + 1, Panic(17)); // arithmetic overflow or underflow\n        v2 += 1;\n    }\n}\n\nfunction blacklist_Switch(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _noBlackList = varg0;\n}\n\nfunction set_New_Pair_Address(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _uniswapV2Pair = varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _@_approve_2053[varg0][varg1];\n}\n\nfunction process_Tokens_Now(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!_inSwapAndLiquify, Error('Currently processing, try later.'));\n    require((varg0 == varg0 * _balanceOf[this] / _balanceOf[this]) | !_balanceOf[this], Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    @swapAndLiquify_2303(varg0 * _balanceOf[this] / 100);\n}\n\nfunction includeInFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedFromFee[varg0] = bytes31(__isExcludedFromFee[address(varg0)]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction set_Swap_And_Liquify_Enabled(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _swapAndLiquifyEnabled = varg0;\n    emit SwapAndLiquifyEnabledUpdated(varg0);\n}\n\nfunction @name_1482() private { \n    v0 = v1 = _@name_1482.length >> 1;\n    if (!(_@name_1482.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_1482.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_1482.length >> 1;\n    if (!(_@name_1482.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_1482.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_1482.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_1482.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x70a08231 > v0) {\n            if (0x313ce567 > v0) {\n                if (0x18160ddd > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x1282a0a0 == v0) {\n                        set_New_Router_and_Make_Pair(address);\n                    } else if (0x13fad07a == v0) {\n                        noFeeToTransfer();\n                    } else {\n                        require(0x1694505e == v0);\n                        uniswapV2Router();\n                    }\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1cdd3be3 == v0) {\n                    _isBlacklisted(address);\n                } else if (0x220f6696 == v0) {\n                    inSwapAndLiquify();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else {\n                    require(0x2e39c6c6 == v0);\n                    set_Max_Transaction_Percent(uint256);\n                }\n            } else if (0x437823ec > v0) {\n                if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x3343ab83 == v0) {\n                    remove_Random_Tokens(address,address,uint256);\n                } else if (0x36b1a1bc == v0) {\n                    set_New_Router_Address(address);\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else {\n                    require(0x40b9a54b == v0);\n                    _buyFee();\n                }\n            } else if (0x437823ec == v0) {\n                excludeFromFee(address);\n            } else if (0x49bd5a5e == v0) {\n                uniswapV2Pair();\n            } else if (0x4a74bb02 == v0) {\n                swapAndLiquifyEnabled();\n            } else if (0x590f897e == v0) {\n                _sellFee();\n            } else if (0x67cbd84c == v0) {\n                _set_Fees(uint256,uint256);\n            } else {\n                require(0x6f0941f6 == v0);\n                noBlackList();\n            }\n        } else if (0xa457c2d7 > v0) {\n            if (0x7d1db4a5 > v0) {\n                if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x715018a6 == v0) {\n                    renounceOwnership();\n                } else if (0x768dc710 == v0) {\n                    _isExcludedFromFee(address);\n                } else if (0x78109e54 == v0) {\n                    _maxWalletToken();\n                } else {\n                    require(0x7caefa89 == v0);\n                    set_Number_Of_Transactions_Before_Liquify_Trigger(uint8);\n                }\n            } else if (0x7d1db4a5 == v0) {\n                _maxTxAmount();\n            } else if (0x8824e16e == v0) {\n                Wallet_Update_Dev(address);\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x8ec0e9a1 == v0) {\n                blacklist_Remove_Wallets(address[]);\n            } else if (0x94220184 == v0) {\n                set_Max_Wallet_Percent(uint256);\n            } else {\n                require(0x95d89b41 == v0);\n                symbol();\n            }\n        } else if (0xd785d5be > v0) {\n            if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa514a07d == v0) {\n                set_Transfers_Without_Fees(bool);\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xa9de975d == v0) {\n                blacklist_Add_Wallets(address[]);\n            } else {\n                require(0xc1f61908 == v0);\n                blacklist_Switch(bool);\n            }\n        } else if (0xd785d5be == v0) {\n            set_New_Pair_Address(address);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xddbf5266 == v0) {\n            process_Tokens_Now(uint256);\n        } else if (0xea2f0b37 == v0) {\n            includeInFee(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else {\n            require(0xf7739b5f == v0);\n            set_Swap_And_Liquify_Enabled(bool);\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.18 17:39 UTC\n// Compiled using the solidity compiler version 0.8.21\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _@_approve_2053; // STORAGE[0x2]\nmapping (uint256 => uint256) __isExcludedFromFee; // STORAGE[0x3]\nmapping (uint256 => uint256) __isBlacklisted; // STORAGE[0x4]\nuint256[] _@name_1482; // STORAGE[0x8]\nuint256[] _@symbol_1490; // STORAGE[0x9]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __buyFee; // STORAGE[0x10]\nuint256 __sellFee; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_13; // STORAGE[0x13]\nuint256 stor_14; // STORAGE[0x14]\nuint256 __maxWalletToken; // STORAGE[0x15]\nuint256 __maxTxAmount; // STORAGE[0x17]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _noBlackList; // STORAGE[0x5] bytes 0 to 0\nuint256 _decimals; // STORAGE[0xa] bytes 0 to 0\nuint256 _@swapAndLiquify_2303; // STORAGE[0x5] bytes 1 to 20\nuint256 stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\nuint256 _uniswapV2Router; // STORAGE[0x19] bytes 0 to 19\nuint256 _uniswapV2Pair; // STORAGE[0x1a] bytes 0 to 19\nuint256 _inSwapAndLiquify; // STORAGE[0x1a] bytes 20 to 20\nuint256 _swapAndLiquifyEnabled; // STORAGE[0x1a] bytes 21 to 21\nuint256 _noFeeToTransfer; // STORAGE[0x1a] bytes 22 to 22\n\n\n// Events\nOwnershipTransferred(address, address);\nSwapAndLiquifyEnabledUpdated(bool);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction @symbol_1490() private { \n    v0 = v1 = _@symbol_1490.length >> 1;\n    if (!(_@symbol_1490.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@symbol_1490.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_1490.length >> 1;\n    if (!(_@symbol_1490.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@symbol_1490.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_1490.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_1490.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction @_approve_2053(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = bool(address(varg2));\n    if (varg2) {\n        v0 = v2 = bool(address(varg1));\n    }\n    require(v0, Error('ERR: zero address'));\n    _@_approve_2053[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2264(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = v1 = _owner != address(varg1);\n    if (_owner != address(varg1)) {\n        v0 = v2 = _@swapAndLiquify_2303 != address(varg1);\n    }\n    if (v0) {\n        v0 = v3 = this != address(varg1);\n    }\n    if (v0) {\n        v0 = v4 = _uniswapV2Pair != address(varg1);\n    }\n    if (v0) {\n        v0 = v5 = stor_6_0_19 != address(varg1);\n    }\n    if (v0) {\n        v0 = v6 = _owner != address(varg2);\n    }\n    if (v0) {\n        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletToken, Error('You are trying to buy too many tokens. You have reached the limit for one wallet.'));\n    }\n    v7 = v8 = _owner != address(varg2);\n    if (_owner != address(varg2)) {\n        v7 = v9 = _owner != address(varg1);\n    }\n    if (v7) {\n        require(varg0 <= __maxTxAmount, Error('You are trying to buy more than the max transaction limit.'));\n    }\n    if (_noBlackList) {\n        v10 = v11 = !uint8(__isBlacklisted[address(varg2)]);\n        if (!bool(uint8(__isBlacklisted[address(varg2)]))) {\n            v10 = v12 = !uint8(__isBlacklisted[address(varg1)]);\n        }\n        require(v10, Error('This address is blacklisted. Transaction reverted.'));\n    }\n    v13 = v14 = bool(address(varg2));\n    if (address(varg2)) {\n        v13 = v15 = bool(address(varg1));\n    }\n    require(v13, Error('ERR: Using 0 address!'));\n    require(varg0 > 0, Error('Token value must be higher than zero.'));\n    v16 = v17 = uint8(stor_d) >= uint8(stor_d >> 8);\n    if (uint8(stor_d) >= uint8(stor_d >> 8)) {\n        v16 = v18 = !_inSwapAndLiquify;\n    }\n    if (v16) {\n        v16 = v19 = _uniswapV2Pair != address(varg2);\n    }\n    if (v16) {\n        v16 = v20 = _swapAndLiquifyEnabled;\n    }\n    if (v16) {\n        stor_d = bytes31(stor_d);\n        v21 = v22 = _balanceOf[this];\n        if (v22 > __maxTxAmount) {\n            v21 = v23 = __maxTxAmount;\n        }\n        if (v21) {\n            @swapAndLiquify_2303(v21);\n        }\n    }\n    v24 = v25 = 1;\n    v26 = v27 = uint8(__isExcludedFromFee[address(varg2)]);\n    if (!v27) {\n        v26 = v28 = uint8(__isExcludedFromFee[address(varg1)]);\n    }\n    if (!v26) {\n        v26 = v29 = _noFeeToTransfer;\n        if (v29) {\n            v26 = v30 = _uniswapV2Pair != address(varg2);\n        }\n        if (v26) {\n            v26 = v31 = _uniswapV2Pair != address(varg1);\n        }\n    }\n    if (!v26) {\n        if (address(varg2) - _uniswapV2Pair) {\n            if (!(address(varg1) - _uniswapV2Pair)) {\n                stor_f = __sellFee;\n            }\n        } else {\n            stor_f = __buyFee;\n        }\n    } else {\n        v24 = v32 = 0;\n    }\n    if (v24) {\n        require(uint8(stor_d) - uint8.max, Panic(17)); // arithmetic overflow or underflow\n        stor_d = uint8(1 + uint8(uint8(stor_d))) | ~0xff & stor_d;\n    } else {\n        v33 = v34 = !stor_f;\n        if (!bool(stor_f)) {\n            v33 = v35 = !__buyFee;\n        }\n        if (v33) {\n            v33 = !__sellFee;\n        }\n        if (!v33) {\n            stor_13 = __buyFee;\n            stor_14 = __sellFee;\n            stor_12 = stor_f;\n            __buyFee = 0;\n            __sellFee = 0;\n            stor_f = 0;\n            // Unknown jump to Block 0x1ad5B0x1a2f. Refer to 3-address code (TAC);\n        }\n        // Unknown jump to Block 0x1b06B0x1a2f. Refer to 3-address code (TAC);\n    }\n    require((stor_f == stor_f * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    v36 = _SafeSub(stor_f * varg0 / 100, varg0);\n    v37 = _SafeSub(varg0, _balanceOf[address(varg2)]);\n    _balanceOf[address(varg2)] = v37;\n    v38 = _SafeAdd(v36, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v38;\n    v39 = _SafeAdd(stor_f * varg0 / 100, _balanceOf[this]);\n    _balanceOf[this] = v39;\n    emit Transfer(address(varg2), address(varg1), v36);\n    if (v24) {\n        // Unknown jump to Block 0x310a. Refer to 3-address code (TAC);\n    } else {\n        stor_f = stor_12;\n        __buyFee = stor_13;\n        __sellFee = stor_14;\n    }\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= varg0 + varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 + varg1;\n}\n\nfunction @swapAndLiquify_2303(uint256 varg0) private { \n    _inSwapAndLiquify = 1;\n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = _uniswapV2Router.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    @_approve_2053(varg0, _uniswapV2Router, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(_uniswapV2Router.code.size));\n    v11 = _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v13 = _@swapAndLiquify_2303.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v13), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    _inSwapAndLiquify = 0;\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 <= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg1 - varg0;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_1482();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_2053(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction set_New_Router_and_Make_Pair(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0, /* address */ v1 = varg0.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = varg0.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _uniswapV2Pair = v5;\n    _uniswapV2Router = varg0;\n}\n\nfunction noFeeToTransfer() public nonPayable { \n    return _noFeeToTransfer;\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return _uniswapV2Router;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction () public payable { \n}\n\nfunction _isBlacklisted(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isBlacklisted[varg0]));\n}\n\nfunction inSwapAndLiquify() public nonPayable { \n    return _inSwapAndLiquify;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_2264(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _@_approve_2053[varg0][msg.sender]);\n    @_approve_2053(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction set_Max_Transaction_Percent(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(10000, Panic(18)); // division by zero\n    __maxTxAmount = varg0 * _totalSupply / 10000;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction remove_Random_Tokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 - this, Error('Can not remove native token'));\n    v0, /* uint256 */ v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v2, /* bool */ v3 = varg0.transfer(varg1, v1).gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == bool(v3));\n    return bool(v3);\n}\n\nfunction set_New_Router_Address(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _uniswapV2Router = varg0;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeAdd(varg1, _@_approve_2053[msg.sender][varg0]);\n    @_approve_2053(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _buyFee() public nonPayable { \n    return __buyFee;\n}\n\nfunction excludeFromFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedFromFee[varg0] = 0x1 | bytes31(__isExcludedFromFee[address(varg0)]);\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return _uniswapV2Pair;\n}\n\nfunction swapAndLiquifyEnabled() public nonPayable { \n    return _swapAndLiquifyEnabled;\n}\n\nfunction _sellFee() public nonPayable { \n    return __sellFee;\n}\n\nfunction _set_Fees(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 <= stor_e, Error('Fee is too high!'));\n    __sellFee = varg1;\n    __buyFee = varg0;\n}\n\nfunction noBlackList() public nonPayable { \n    return _noBlackList;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction _isExcludedFromFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isExcludedFromFee[varg0]));\n}\n\nfunction _maxWalletToken() public nonPayable { \n    return __maxWalletToken;\n}\n\nfunction set_Number_Of_Transactions_Before_Liquify_Trigger(uint8 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_d = stor_d & ~0xff00 | varg0 << 8;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction Wallet_Update_Dev(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _@swapAndLiquify_2303 = varg0;\n    __isExcludedFromFee[address((address(varg0) << 8 | ~0xffffffffffffffffffffffffffffffffffffffff00 & STORAGE[0x5]) >> 8)] = 0x1 | bytes31(__isExcludedFromFee[address((address(varg0) << 8 | ~0xffffffffffffffffffffffffffffffffffffffff00 & STORAGE[0x5]) >> 8)]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction blacklist_Remove_Wallets(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max);\n    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < varg0.length) {\n        if (v0 < msg.gas) {\n            require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n            require(varg0[v2] == address(varg0[v2]));\n            if (uint8(__isBlacklisted[address(varg0[v2])])) {\n                require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n                require(varg0[v2] == address(varg0[v2]));\n                __isBlacklisted[address(varg0[v2])] = bool(0) | bytes31(__isBlacklisted[address(varg0[v2])]);\n            }\n            v0 = msg.gas - msg.gas;\n            require(v0 <= msg.gas, Panic(17)); // arithmetic overflow or underflow\n        }\n        require(v2 + 1, Panic(17)); // arithmetic overflow or underflow\n        v2 += 1;\n    }\n}\n\nfunction set_Max_Wallet_Percent(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require((varg0 == varg0 * _totalSupply / _totalSupply) | !_totalSupply, Panic(17)); // arithmetic overflow or underflow\n    require(10000, Panic(18)); // division by zero\n    __maxWalletToken = varg0 * _totalSupply / 10000;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_1490();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    v1[v0.length] = 0;\n    return v1;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _@_approve_2053[msg.sender][varg0]);\n    @_approve_2053(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction set_Transfers_Without_Fees(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _noFeeToTransfer = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_2264(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction blacklist_Add_Wallets(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max);\n    require(4 + varg0 + (varg0.length << 5) + 32 <= msg.data.length);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < varg0.length) {\n        if (v0 < msg.gas) {\n            require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n            require(varg0[v2] == address(varg0[v2]));\n            if (!uint8(__isBlacklisted[address(varg0[v2])])) {\n                require(v2 < varg0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                require((v2 << 5) + varg0.data + 32 - ((v2 << 5) + varg0.data) >= 32);\n                require(varg0[v2] == address(varg0[v2]));\n                __isBlacklisted[address(varg0[v2])] = bool(1) | bytes31(__isBlacklisted[address(varg0[v2])]);\n            }\n            v0 = msg.gas - msg.gas;\n            require(v0 <= msg.gas, Panic(17)); // arithmetic overflow or underflow\n        }\n        require(v2 + 1, Panic(17)); // arithmetic overflow or underflow\n        v2 += 1;\n    }\n}\n\nfunction blacklist_Switch(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _noBlackList = varg0;\n}\n\nfunction set_New_Pair_Address(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _uniswapV2Pair = varg0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _@_approve_2053[varg0][varg1];\n}\n\nfunction process_Tokens_Now(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!_inSwapAndLiquify, Error('Currently processing, try later.'));\n    require((varg0 == varg0 * _balanceOf[this] / _balanceOf[this]) | !_balanceOf[this], Panic(17)); // arithmetic overflow or underflow\n    require(100, Panic(18)); // division by zero\n    @swapAndLiquify_2303(varg0 * _balanceOf[this] / 100);\n}\n\nfunction includeInFee(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedFromFee[varg0] = bytes31(__isExcludedFromFee[address(varg0)]);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction set_Swap_And_Liquify_Enabled(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _swapAndLiquifyEnabled = varg0;\n    emit SwapAndLiquifyEnabledUpdated(varg0);\n}\n\nfunction @name_1482() private { \n    v0 = v1 = _@name_1482.length >> 1;\n    if (!(_@name_1482.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require((_@name_1482.length & 0x1) - (v0 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_1482.length >> 1;\n    if (!(_@name_1482.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require((_@name_1482.length & 0x1) - (v6 < 32), Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_1482.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_1482.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x70a08231 > v0) {\n            if (0x313ce567 > v0) {\n                if (0x18160ddd > v0) {\n                    if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0x1282a0a0 == v0) {\n                        set_New_Router_and_Make_Pair(address);\n                    } else if (0x13fad07a == v0) {\n                        noFeeToTransfer();\n                    } else {\n                        require(0x1694505e == v0);\n                        uniswapV2Router();\n                    }\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1cdd3be3 == v0) {\n                    _isBlacklisted(address);\n                } else if (0x220f6696 == v0) {\n                    inSwapAndLiquify();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else {\n                    require(0x2e39c6c6 == v0);\n                    set_Max_Transaction_Percent(uint256);\n                }\n            } else if (0x437823ec > v0) {\n                if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x3343ab83 == v0) {\n                    remove_Random_Tokens(address,address,uint256);\n                } else if (0x36b1a1bc == v0) {\n                    set_New_Router_Address(address);\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else {\n                    require(0x40b9a54b == v0);\n                    _buyFee();\n                }\n            } else if (0x437823ec == v0) {\n                excludeFromFee(address);\n            } else if (0x49bd5a5e == v0) {\n                uniswapV2Pair();\n            } else if (0x4a74bb02 == v0) {\n                swapAndLiquifyEnabled();\n            } else if (0x590f897e == v0) {\n                _sellFee();\n            } else if (0x67cbd84c == v0) {\n                _set_Fees(uint256,uint256);\n            } else {\n                require(0x6f0941f6 == v0);\n                noBlackList();\n            }\n        } else if (0xa457c2d7 > v0) {\n            if (0x7d1db4a5 > v0) {\n                if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x715018a6 == v0) {\n                    renounceOwnership();\n                } else if (0x768dc710 == v0) {\n                    _isExcludedFromFee(address);\n                } else if (0x78109e54 == v0) {\n                    _maxWalletToken();\n                } else {\n                    require(0x7caefa89 == v0);\n                    set_Number_Of_Transactions_Before_Liquify_Trigger(uint8);\n                }\n            } else if (0x7d1db4a5 == v0) {\n                _maxTxAmount();\n            } else if (0x8824e16e == v0) {\n                Wallet_Update_Dev(address);\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x8ec0e9a1 == v0) {\n                blacklist_Remove_Wallets(address[]);\n            } else if (0x94220184 == v0) {\n                set_Max_Wallet_Percent(uint256);\n            } else {\n                require(0x95d89b41 == v0);\n                symbol();\n            }\n        } else if (0xd785d5be > v0) {\n            if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa514a07d == v0) {\n                set_Transfers_Without_Fees(bool);\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xa9de975d == v0) {\n                blacklist_Add_Wallets(address[]);\n            } else {\n                require(0xc1f61908 == v0);\n                blacklist_Switch(bool);\n            }\n        } else if (0xd785d5be == v0) {\n            set_New_Pair_Address(address);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xddbf5266 == v0) {\n            process_Tokens_Now(uint256);\n        } else if (0xea2f0b37 == v0) {\n            includeInFee(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else {\n            require(0xf7739b5f == v0);\n            set_Swap_And_Liquify_Enabled(bool);\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 37.955771923065186,
	"usage": {
		"completion_tokens": 663,
		"prompt_tokens": 8791,
		"total_tokens": 9454
	}
}