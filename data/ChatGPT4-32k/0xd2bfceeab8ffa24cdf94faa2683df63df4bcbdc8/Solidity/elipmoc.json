{
	"address": "0xd2bfceeab8ffa24cdf94faa2683df63df4bcbdc8",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract interpretation of the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract TokenContract {\n    uint256 stor_0;\n    string[] _name;\n    string[] _symbol;\n    uint256 _totalEthFundRecieved;\n    uint256 _totalEthFundCollected;\n    uint256 _stakingRequirement;\n    mapping (uint256 => uint256[]) owner_6;\n    mapping (uint256 => uint256[]) _exit;\n    mapping (uint256 => uint256[]) owner_8;\n    mapping (uint256 => uint256[]) _dividendsOf;\n    mapping (uint256 => uint256[]) owner_a;\n    uint256 _totalSupply;\n    uint256 stor_c;\n    mapping (uint256 => uint256[]) _setStakingRequirement;\n    mapping (uint256 => uint256[]) _canAcceptTokens_;\n    uint8 _onlyAmbassadors;\n\n    event onWithdraw(address indexed from, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event onTokenSell(address indexed from, uint256 tokens, uint256 value);\n    event onReinvestment(address indexed from, uint256 value, uint256 tokens);\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256 c) {\n        if (b > 0) {\n            c = a * b;\n            require(c / b == a);\n        }\n    }\n\n    function buy(address to) public payable {\n        require(msg.sender == tx.origin);\n        uint256 incomingEthereum = msg.value;\n        uint256 tokens = ethereumToTokens_(incomingEthereum);\n        require(tokens > 0 && (tokens + _totalSupply) > _totalSupply);\n    }\n\n    function sell(uint256 tokens) public {\n        require(tokens > 0 && tokens <= balanceOf(msg.sender));\n        uint256 ether_ = tokensToEthereum_(tokens);\n        _totalSupply -= tokens;\n        msg.sender.transfer(ether_);\n    }\n\n    function reinvest() public {\n        uint256 dividends = myDividends(false);\n        require(dividends > 0);\n        _dividendsOf[msg.sender] = 0;\n        uint256 _tokens = ethereumToTokens_(dividends);\n        _totalSupply += _tokens;\n        emit onReinvestment(msg.sender, dividends, _tokens);\n    }\n\n    function exit() public {\n        sell(balanceOf(msg.sender));\n        withdraw();\n    }\n\n    function withdraw() public {\n        uint256 dividends = myDividends(false);\n        require(dividends > 0);\n        _dividendsOf[msg.sender] = 0;\n        msg.sender.transfer(dividends);\n    }\n\n    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\n        return _includeReferralBonus ? _dividendsOf[msg.sender] + referralBalance_[msg.sender] : _dividendsOf[msg.sender] ;\n    }\n\n    function balanceOf(address _customerAddress) public view returns(uint256) {\n        return _exit[_customerAddress];\n    }\n\n    function ethereumToTokens_(uint256 _ethereum) private view returns(uint256) {\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n        uint256 _tokens = _ethereum.mul(1e18).div(_tokenPriceInitial);\n        return _tokens;\n    }\n\n    function tokensToEthereum_(uint256 _tokens) private view returns(uint256) {\n        uint256 tokens_ = (_tokens + 1e8 - 1) / 1e8;\n        uint256 _ether = tokens_.mul(tokenPriceInitial_);\n        return _ether;\n    }\n}\n```\nNote: This is a basic translation of the decompiled code to Solidity. It might not contain all the logic of the original contract as the original EVM byte code might contain complex low-level operations that are not directly mappable to high-level Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039258,
	"id": "chatcmpl-8ChruhkJQPFq2VlYXiJHTBrNKvaGF",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 23:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalEthFundRecieved; // STORAGE[0x3]\nuint256 _totalEthFundCollected; // STORAGE[0x4]\nuint256 _stakingRequirement; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x7]\nmapping (uint256 => [uint256]) owner_8; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) owner_a; // STORAGE[0xa]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _setStakingRequirement; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _canAcceptTokens_; // STORAGE[0xf]\nuint8 _onlyAmbassadors; // STORAGE[0xe] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x1246(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    if (block.timestamp >= stor_0) {\n        _onlyAmbassadors = 0;\n    }\n    v4 = v5 = _onlyAmbassadors;\n    if (v5) {\n        v4 = v6 = (address(this)).balance - varg1 <= 0x6f05b59d3b200000;\n    }\n    if (!v4) {\n        _onlyAmbassadors = 0;\n        v7 = v8 = 5595;\n        v9 = v10 = _SafeMul(20, varg1);\n    } else {\n        v11 = v12 = 1 == 0xff & owner_6[msg.sender];\n        if (v12) {\n            v11 = v13 = varg1 + owner_a[msg.sender] <= 0x6f05b59d3b200000;\n        }\n        require(v11);\n        v14 = varg1 + owner_a[msg.sender];\n        assert(v14 >= owner_a[msg.sender]);\n        owner_a[msg.sender] = v14;\n        v7 = v15 = 4925;\n        v9 = v16 = _SafeMul(20, varg1);\n    }\n    while (!100) {\n        assert(100);\n        assert(v2 <= v0);\n        v17 = v18 = v0 - v2;\n        v19 = v20 = 4987;\n        assert(v0 <= varg1);\n        v21 = v22 = varg1 - v0;\n        assert(v0 <= v21);\n        goto {'0x137b', '0x1613'};\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        v23 = v24 = 0x18b0(v21 - v0);\n        v25 = v26 = v17 << 64;\n        v27 = v28 = v24 > 0;\n        if (v28) {\n            assert(_totalSupply + v24 >= v24);\n            v27 = v29 = _totalSupply + v24 > _totalSupply;\n        }\n        require(v27);\n        v30 = !address(varg0);\n        v31 = v32 = address(varg0);\n        if (address(varg0)) {\n            v31 = v33 = address(varg0) != msg.sender;\n        }\n        if (v31) {\n            v34 = address(varg0);\n            v31 = v35 = _exit[v34] >= _stakingRequirement;\n        }\n        if (!v31) {\n            v17 = v36 = v2 + v17;\n            assert(v36 >= v17);\n            v25 = v37 = v36 << 64;\n        } else {\n            v38 = address(varg0);\n            assert(v2 + owner_8[v38] >= owner_8[v38]);\n            v39 = address(varg0);\n            owner_8[v39] = v2 + owner_8[v38];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v24;\n        } else {\n            assert(v24 + _totalSupply >= _totalSupply);\n            _totalSupply += v24;\n            assert(v24 + _totalSupply);\n            stor_c = stor_c + (v17 << 64) / (v24 + _totalSupply);\n            assert(_totalSupply);\n            v25 = v40 = v25 - (v25 - v24 * ((v17 << 64) / _totalSupply));\n        }\n        assert(v24 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v24;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_c * v24 - v25);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v24);\n        return v23;\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        v23 = v41 = 0x18b0(v21 - v0);\n        v42 = v43 = v17 << 64;\n        v44 = v45 = v41 > 0;\n        if (v45) {\n            assert(_totalSupply + v41 >= v41);\n            v44 = v46 = _totalSupply + v41 > _totalSupply;\n        }\n        require(v44);\n        v47 = !address(varg0);\n        v48 = v49 = address(varg0);\n        if (address(varg0)) {\n            v48 = v50 = address(varg0) != msg.sender;\n        }\n        if (v48) {\n            v51 = address(varg0);\n            v48 = v52 = _exit[v51] >= _stakingRequirement;\n        }\n        if (!v48) {\n            v17 += v2;\n            assert(v17 >= v17);\n            v42 = v53 = v17 << 64;\n        } else {\n            v54 = address(varg0);\n            assert(v2 + owner_8[v54] >= owner_8[v54]);\n            v55 = address(varg0);\n            owner_8[v55] = v2 + owner_8[v54];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v41;\n        } else {\n            assert(v41 + _totalSupply >= _totalSupply);\n            _totalSupply += v41;\n            assert(v41 + _totalSupply);\n            stor_c = stor_c + (v17 << 64) / (v41 + _totalSupply);\n            assert(_totalSupply);\n            v42 = v56 = v42 - (v42 - v41 * ((v17 << 64) / _totalSupply));\n        }\n        assert(v41 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v41;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_c * v41 - v42);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v41);\n        assert(v2 <= v0);\n        v17 = v57 = v0 - v2;\n        v19 = v58 = 5651;\n        assert(v0 <= varg1);\n        v21 = varg1 - v0;\n        goto 0x1375;\n        v0 = v9 / 100;\n        goto {'0x135a', '0x133d', '0x15f8', '0x15db'};\n        assert(3);\n        v2 = v59 = v0 / 3;\n        v7 = v60 = 4954;\n        v9 = v61 = _SafeMul(5, varg1);\n        assert(3);\n        v2 = v0 / 3;\n        v7 = v62 = 5624;\n        v9 = v63 = _SafeMul(5, varg1);\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0x18b0(uint256 varg0) private { \n    v0 = v1 = 0x4140c78940f6a24fdffc78873d4490d2100000000000000 + (_totalSupply * 0xf0bdc21abb48db201e86d4000000000 + (0xde0b6b3a7640000 * _totalSupply ** 2 + varg0 * 0x59aedfc10d7279c5eed1401645400000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x204fce5e3e25026110000000 <= v0);\n    assert(0x3b9aca00);\n    return (v0 - 0x204fce5e3e25026110000000) / 0x3b9aca00 - _totalSupply;\n}\n\nfunction 0x1942(uint256 varg0) private { \n    v0 = varg0 * (0x3b9aca00 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000) + 0x218711a00);\n    v1 = 0x3b9aca00 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    require(msg.gas <= 0x2540be400);\n    v0 = 0x621(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * stor_c - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction canAcceptTokens_(address varg0) public nonPayable { \n    return 0xff & _canAcceptTokens_[varg0];\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 2026;\n    v4 = v5 = _SafeMul(20, varg0);\n    while (!100) {\n        assert(100);\n        assert(v0 <= varg0);\n        assert(v0 <= varg0 - v0);\n        v6 = 0x18b0(varg0 - v0 - v0);\n        return v6;\n        v0 = v4 / 100;\n        goto {'0x7eaB0x2c3', '0x7faB0x2c3'};\n        v2 = v7 = 2042;\n        v4 = v8 = _SafeMul(5, varg0);\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    require(varg0 <= _totalSupply);\n    v2 = 0x1942(varg0);\n    v3 = v4 = 2141;\n    v5 = v6 = _SafeMul(20, v2);\n    while (!100) {\n        assert(100);\n        assert(v0 <= v2);\n        assert(v0 <= v2 - v0);\n        return v2 - v0 - v0;\n        v0 = v5 / 100;\n        goto {'0x85dB0x2ec', '0x86dB0x2ec'};\n        v3 = v7 = 2157;\n        v5 = v8 = _SafeMul(5, v2);\n    }\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction setCanAcceptTokens(address varg0, bool varg1) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _canAcceptTokens_[varg0] = varg1 | ~0xff & _canAcceptTokens_[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0x8e4();\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(varg0);\n    require(1 == 0xff & _canAcceptTokens_[varg0]);\n    v0 = 0xde4(varg1, varg0);\n    require(v0);\n    if (varg0.code.size > 0) {\n        v1 = new array[]((?).length);\n        require(varg0.code.size);\n        v2, v3 = varg0.tokenFallback(msg.sender, varg1, v1).gas(msg.gas);\n        require(v2);\n        require(v3);\n    }\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    v0 = v1 = 0;\n    if (0 != _totalSupply) {\n        v2 = 0x1942(0xde0b6b3a7640000);\n        v3 = v4 = 2844;\n        v5 = v6 = _SafeMul(20, v2);\n        while (!100) {\n            assert(100);\n            assert(v0 <= v2);\n            assert(v0 <= v2 - v0);\n            v7 = v2 - v0 - v0;\n            v0 = v5 / 100;\n            goto {'0xb1cB0x3a6', '0xb2cB0x3a6'};\n            v3 = v8 = 2860;\n            v5 = v9 = _SafeMul(5, v2);\n        }\n    } else {\n        v7 = v10 = 0x218711a00;\n    }\n    return v7;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction giveEthFundAddress() public nonPayable { \n    return 0xd9092d94f74e6b5d408dbd3ecc88f3e5810d1e98;\n}\n\nfunction etherToSendFund() public nonPayable { \n    assert(_totalEthFundRecieved <= _totalEthFundCollected);\n    return _totalEthFundCollected - _totalEthFundRecieved;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xb7b(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction administrators(address varg0) public nonPayable { \n    return 0xff & _setStakingRequirement[varg0];\n}\n\nfunction totalEthFundCollected() public nonPayable { \n    return _totalEthFundCollected;\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    v0 = v1 = 0;\n    if (0 != _totalSupply) {\n        v2 = 0x1942(0xde0b6b3a7640000);\n        v3 = v4 = 3185;\n        v5 = v6 = _SafeMul(20, v2);\n        while (!100) {\n            assert(100);\n            assert(v0 + v2 >= v2);\n            v7 = v0 + (v0 + v2);\n            assert(v7 >= v0 + v2);\n            v0 = v5 / 100;\n            goto {'0xc81B0x4a0', '0xc71B0x4a0'};\n            v3 = v8 = 3201;\n            v5 = v9 = _SafeMul(5, v2);\n        }\n    } else {\n        v7 = v10 = 0x28fa6ae00;\n    }\n    return v7;\n}\n\nfunction setAdministrator(address varg0, bool varg1) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _setStakingRequirement[varg0] = varg1 | ~0xff & _setStakingRequirement[varg0];\n}\n\nfunction payFund() public payable { \n    assert(_totalEthFundRecieved <= _totalEthFundCollected);\n    require(_totalEthFundCollected - _totalEthFundRecieved > 1);\n    assert(_totalEthFundCollected - _totalEthFundRecieved + _totalEthFundRecieved >= _totalEthFundRecieved);\n    _totalEthFundRecieved += _totalEthFundCollected - _totalEthFundRecieved;\n    v0 = 0xd9092d94f74e6b5d408dbd3ecc88f3e5810d1e98.call().value(_totalEthFundCollected - _totalEthFundRecieved).gas(0x61a80);\n    if (!v0) {\n        assert(_totalEthFundCollected - _totalEthFundRecieved <= _totalEthFundRecieved);\n        _totalEthFundRecieved = _totalEthFundRecieved - (_totalEthFundCollected - _totalEthFundRecieved);\n    }\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xd60();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction totalEthFundRecieved() public nonPayable { \n    return _totalEthFundRecieved;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xde4(varg1, varg0);\n    return v0;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _setStakingRequirement[msg.sender]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _setStakingRequirement[msg.sender]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0xf99(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0xf99(_exit[msg.sender]);\n    }\n    0x8e4();\n}\n\nfunction buy(address varg0) public payable { \n    require(msg.gas <= 0xba43b7400);\n    v0 = 0x621(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xb7b(1);\n    require(v0 > 0);\n    v1 = 0xb7b(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x1246(0, v1 + _dividendsOf[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + _dividendsOf[msg.sender], v2);\n}\n\nfunction 0x621(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    require(msg.sender == address(tx.origin));\n    if (varg1 > 0x1bc16d674ec80000) {\n        assert(varg1 <= (address(this)).balance);\n        if ((address(this)).balance - varg1 <= 0xad78ebc5ac6200000) {\n            varg1 = v2 = 0x1bc16d674ec80000;\n            assert(v2 <= varg1);\n            v0 = varg1 - v2;\n        }\n    }\n    v3 = 0x1246(varg0, varg1);\n    if (v0 > 0) {\n        v4 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v4);\n    }\n    return 0;\n}\n\nfunction 0x8e4() private { \n    v0 = 0xb7b(1);\n    require(v0 > 0);\n    v1 = 0xb7b(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0xb7b(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * stor_c - _dividendsOf[msg.sender] >> 64) + owner_8[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * stor_c - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0xd60() private { \n    return _exit[msg.sender];\n}\n\nfunction 0xde4(uint256 varg0, uint256 varg1) private { \n    v0 = 0xd60();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = 0xb7b(1);\n    if (v1 > 0) {\n        0x8e4();\n    }\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v2 = address(varg1);\n    v3 = varg0 + _exit[v2];\n    assert(v3 >= _exit[v2]);\n    v4 = address(varg1);\n    _exit[v4] = v3;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg0 * stor_c;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + varg0 * stor_c;\n    emit Transfer(msg.sender, v4, varg0);\n    return 1;\n}\n\nfunction 0xf99(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = 0xd60();\n    require(v2 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v3 = 0x1942(varg0);\n    v4 = v5 = 4092;\n    v6 = v7 = _SafeMul(20, v3);\n    while (!100) {\n        assert(100);\n        assert(v0 <= v3);\n        assert(v0 <= v3 - v0);\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        assert(varg0 <= _totalSupply);\n        _totalSupply = _totalSupply - varg0;\n        assert(varg0 <= _exit[msg.sender]);\n        _exit[msg.sender] = _exit[msg.sender] - varg0;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v3 - v0 - v0 << 64) + varg0 * stor_c);\n        if (_totalSupply > 0) {\n            assert(_totalSupply);\n            assert((v0 << 64) / _totalSupply + stor_c >= stor_c);\n            stor_c += (v0 << 64) / _totalSupply;\n        }\n        emit onTokenSell(msg.sender, varg0, v3 - v0 - v0);\n        return ;\n        v0 = v6 / 100;\n        goto {'0x100c', '0xffc'};\n        v4 = v8 = 4108;\n        v6 = v9 = _SafeMul(5, v3);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0xf34dc16 == function_selector) {\n            canAcceptTokens_(address);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x294205b4 == function_selector) {\n            setCanAcceptTokens(address,bool);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x5e079aa5 == function_selector) {\n            giveEthFundAddress();\n        } else if (0x66042e7a == function_selector) {\n            etherToSendFund();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x76be1585 == function_selector) {\n            administrators(address);\n        } else if (0x7ff276bd == function_selector) {\n            totalEthFundCollected();\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x87c95058 == function_selector) {\n            setAdministrator(address,bool);\n        } else if (0x8974372d == function_selector) {\n            payFund();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa4d55686 == function_selector) {\n            totalEthFundRecieved();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 23:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalEthFundRecieved; // STORAGE[0x3]\nuint256 _totalEthFundCollected; // STORAGE[0x4]\nuint256 _stakingRequirement; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x7]\nmapping (uint256 => [uint256]) owner_8; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) owner_a; // STORAGE[0xa]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _setStakingRequirement; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _canAcceptTokens_; // STORAGE[0xf]\nuint8 _onlyAmbassadors; // STORAGE[0xe] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x1246(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    if (block.timestamp >= stor_0) {\n        _onlyAmbassadors = 0;\n    }\n    v4 = v5 = _onlyAmbassadors;\n    if (v5) {\n        v4 = v6 = (address(this)).balance - varg1 <= 0x6f05b59d3b200000;\n    }\n    if (!v4) {\n        _onlyAmbassadors = 0;\n        v7 = v8 = 5595;\n        v9 = v10 = _SafeMul(20, varg1);\n    } else {\n        v11 = v12 = 1 == 0xff & owner_6[msg.sender];\n        if (v12) {\n            v11 = v13 = varg1 + owner_a[msg.sender] <= 0x6f05b59d3b200000;\n        }\n        require(v11);\n        v14 = varg1 + owner_a[msg.sender];\n        assert(v14 >= owner_a[msg.sender]);\n        owner_a[msg.sender] = v14;\n        v7 = v15 = 4925;\n        v9 = v16 = _SafeMul(20, varg1);\n    }\n    while (!100) {\n        assert(100);\n        assert(v2 <= v0);\n        v17 = v18 = v0 - v2;\n        v19 = v20 = 4987;\n        assert(v0 <= varg1);\n        v21 = v22 = varg1 - v0;\n        assert(v0 <= v21);\n        goto {'0x137b', '0x1613'};\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        v23 = v24 = 0x18b0(v21 - v0);\n        v25 = v26 = v17 << 64;\n        v27 = v28 = v24 > 0;\n        if (v28) {\n            assert(_totalSupply + v24 >= v24);\n            v27 = v29 = _totalSupply + v24 > _totalSupply;\n        }\n        require(v27);\n        v30 = !address(varg0);\n        v31 = v32 = address(varg0);\n        if (address(varg0)) {\n            v31 = v33 = address(varg0) != msg.sender;\n        }\n        if (v31) {\n            v34 = address(varg0);\n            v31 = v35 = _exit[v34] >= _stakingRequirement;\n        }\n        if (!v31) {\n            v17 = v36 = v2 + v17;\n            assert(v36 >= v17);\n            v25 = v37 = v36 << 64;\n        } else {\n            v38 = address(varg0);\n            assert(v2 + owner_8[v38] >= owner_8[v38]);\n            v39 = address(varg0);\n            owner_8[v39] = v2 + owner_8[v38];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v24;\n        } else {\n            assert(v24 + _totalSupply >= _totalSupply);\n            _totalSupply += v24;\n            assert(v24 + _totalSupply);\n            stor_c = stor_c + (v17 << 64) / (v24 + _totalSupply);\n            assert(_totalSupply);\n            v25 = v40 = v25 - (v25 - v24 * ((v17 << 64) / _totalSupply));\n        }\n        assert(v24 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v24;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_c * v24 - v25);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v24);\n        return v23;\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        v23 = v41 = 0x18b0(v21 - v0);\n        v42 = v43 = v17 << 64;\n        v44 = v45 = v41 > 0;\n        if (v45) {\n            assert(_totalSupply + v41 >= v41);\n            v44 = v46 = _totalSupply + v41 > _totalSupply;\n        }\n        require(v44);\n        v47 = !address(varg0);\n        v48 = v49 = address(varg0);\n        if (address(varg0)) {\n            v48 = v50 = address(varg0) != msg.sender;\n        }\n        if (v48) {\n            v51 = address(varg0);\n            v48 = v52 = _exit[v51] >= _stakingRequirement;\n        }\n        if (!v48) {\n            v17 += v2;\n            assert(v17 >= v17);\n            v42 = v53 = v17 << 64;\n        } else {\n            v54 = address(varg0);\n            assert(v2 + owner_8[v54] >= owner_8[v54]);\n            v55 = address(varg0);\n            owner_8[v55] = v2 + owner_8[v54];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v41;\n        } else {\n            assert(v41 + _totalSupply >= _totalSupply);\n            _totalSupply += v41;\n            assert(v41 + _totalSupply);\n            stor_c = stor_c + (v17 << 64) / (v41 + _totalSupply);\n            assert(_totalSupply);\n            v42 = v56 = v42 - (v42 - v41 * ((v17 << 64) / _totalSupply));\n        }\n        assert(v41 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v41;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_c * v41 - v42);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v41);\n        assert(v2 <= v0);\n        v17 = v57 = v0 - v2;\n        v19 = v58 = 5651;\n        assert(v0 <= varg1);\n        v21 = varg1 - v0;\n        goto 0x1375;\n        v0 = v9 / 100;\n        goto {'0x135a', '0x133d', '0x15f8', '0x15db'};\n        assert(3);\n        v2 = v59 = v0 / 3;\n        v7 = v60 = 4954;\n        v9 = v61 = _SafeMul(5, varg1);\n        assert(3);\n        v2 = v0 / 3;\n        v7 = v62 = 5624;\n        v9 = v63 = _SafeMul(5, varg1);\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0x18b0(uint256 varg0) private { \n    v0 = v1 = 0x4140c78940f6a24fdffc78873d4490d2100000000000000 + (_totalSupply * 0xf0bdc21abb48db201e86d4000000000 + (0xde0b6b3a7640000 * _totalSupply ** 2 + varg0 * 0x59aedfc10d7279c5eed1401645400000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x204fce5e3e25026110000000 <= v0);\n    assert(0x3b9aca00);\n    return (v0 - 0x204fce5e3e25026110000000) / 0x3b9aca00 - _totalSupply;\n}\n\nfunction 0x1942(uint256 varg0) private { \n    v0 = varg0 * (0x3b9aca00 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000) + 0x218711a00);\n    v1 = 0x3b9aca00 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    require(msg.gas <= 0x2540be400);\n    v0 = 0x621(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * stor_c - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction canAcceptTokens_(address varg0) public nonPayable { \n    return 0xff & _canAcceptTokens_[varg0];\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 2026;\n    v4 = v5 = _SafeMul(20, varg0);\n    while (!100) {\n        assert(100);\n        assert(v0 <= varg0);\n        assert(v0 <= varg0 - v0);\n        v6 = 0x18b0(varg0 - v0 - v0);\n        return v6;\n        v0 = v4 / 100;\n        goto {'0x7eaB0x2c3', '0x7faB0x2c3'};\n        v2 = v7 = 2042;\n        v4 = v8 = _SafeMul(5, varg0);\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    require(varg0 <= _totalSupply);\n    v2 = 0x1942(varg0);\n    v3 = v4 = 2141;\n    v5 = v6 = _SafeMul(20, v2);\n    while (!100) {\n        assert(100);\n        assert(v0 <= v2);\n        assert(v0 <= v2 - v0);\n        return v2 - v0 - v0;\n        v0 = v5 / 100;\n        goto {'0x85dB0x2ec', '0x86dB0x2ec'};\n        v3 = v7 = 2157;\n        v5 = v8 = _SafeMul(5, v2);\n    }\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction setCanAcceptTokens(address varg0, bool varg1) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _canAcceptTokens_[varg0] = varg1 | ~0xff & _canAcceptTokens_[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0x8e4();\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(varg0);\n    require(1 == 0xff & _canAcceptTokens_[varg0]);\n    v0 = 0xde4(varg1, varg0);\n    require(v0);\n    if (varg0.code.size > 0) {\n        v1 = new array[]((?).length);\n        require(varg0.code.size);\n        v2, v3 = varg0.tokenFallback(msg.sender, varg1, v1).gas(msg.gas);\n        require(v2);\n        require(v3);\n    }\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    v0 = v1 = 0;\n    if (0 != _totalSupply) {\n        v2 = 0x1942(0xde0b6b3a7640000);\n        v3 = v4 = 2844;\n        v5 = v6 = _SafeMul(20, v2);\n        while (!100) {\n            assert(100);\n            assert(v0 <= v2);\n            assert(v0 <= v2 - v0);\n            v7 = v2 - v0 - v0;\n            v0 = v5 / 100;\n            goto {'0xb1cB0x3a6', '0xb2cB0x3a6'};\n            v3 = v8 = 2860;\n            v5 = v9 = _SafeMul(5, v2);\n        }\n    } else {\n        v7 = v10 = 0x218711a00;\n    }\n    return v7;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction giveEthFundAddress() public nonPayable { \n    return 0xd9092d94f74e6b5d408dbd3ecc88f3e5810d1e98;\n}\n\nfunction etherToSendFund() public nonPayable { \n    assert(_totalEthFundRecieved <= _totalEthFundCollected);\n    return _totalEthFundCollected - _totalEthFundRecieved;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xb7b(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction administrators(address varg0) public nonPayable { \n    return 0xff & _setStakingRequirement[varg0];\n}\n\nfunction totalEthFundCollected() public nonPayable { \n    return _totalEthFundCollected;\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    v0 = v1 = 0;\n    if (0 != _totalSupply) {\n        v2 = 0x1942(0xde0b6b3a7640000);\n        v3 = v4 = 3185;\n        v5 = v6 = _SafeMul(20, v2);\n        while (!100) {\n            assert(100);\n            assert(v0 + v2 >= v2);\n            v7 = v0 + (v0 + v2);\n            assert(v7 >= v0 + v2);\n            v0 = v5 / 100;\n            goto {'0xc81B0x4a0', '0xc71B0x4a0'};\n            v3 = v8 = 3201;\n            v5 = v9 = _SafeMul(5, v2);\n        }\n    } else {\n        v7 = v10 = 0x28fa6ae00;\n    }\n    return v7;\n}\n\nfunction setAdministrator(address varg0, bool varg1) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _setStakingRequirement[varg0] = varg1 | ~0xff & _setStakingRequirement[varg0];\n}\n\nfunction payFund() public payable { \n    assert(_totalEthFundRecieved <= _totalEthFundCollected);\n    require(_totalEthFundCollected - _totalEthFundRecieved > 1);\n    assert(_totalEthFundCollected - _totalEthFundRecieved + _totalEthFundRecieved >= _totalEthFundRecieved);\n    _totalEthFundRecieved += _totalEthFundCollected - _totalEthFundRecieved;\n    v0 = 0xd9092d94f74e6b5d408dbd3ecc88f3e5810d1e98.call().value(_totalEthFundCollected - _totalEthFundRecieved).gas(0x61a80);\n    if (!v0) {\n        assert(_totalEthFundCollected - _totalEthFundRecieved <= _totalEthFundRecieved);\n        _totalEthFundRecieved = _totalEthFundRecieved - (_totalEthFundCollected - _totalEthFundRecieved);\n    }\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xd60();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction totalEthFundRecieved() public nonPayable { \n    return _totalEthFundRecieved;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xde4(varg1, varg0);\n    return v0;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _setStakingRequirement[msg.sender]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _setStakingRequirement[msg.sender]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0xf99(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0xf99(_exit[msg.sender]);\n    }\n    0x8e4();\n}\n\nfunction buy(address varg0) public payable { \n    require(msg.gas <= 0xba43b7400);\n    v0 = 0x621(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xb7b(1);\n    require(v0 > 0);\n    v1 = 0xb7b(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x1246(0, v1 + _dividendsOf[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + _dividendsOf[msg.sender], v2);\n}\n\nfunction 0x621(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    require(msg.sender == address(tx.origin));\n    if (varg1 > 0x1bc16d674ec80000) {\n        assert(varg1 <= (address(this)).balance);\n        if ((address(this)).balance - varg1 <= 0xad78ebc5ac6200000) {\n            varg1 = v2 = 0x1bc16d674ec80000;\n            assert(v2 <= varg1);\n            v0 = varg1 - v2;\n        }\n    }\n    v3 = 0x1246(varg0, varg1);\n    if (v0 > 0) {\n        v4 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v4);\n    }\n    return 0;\n}\n\nfunction 0x8e4() private { \n    v0 = 0xb7b(1);\n    require(v0 > 0);\n    v1 = 0xb7b(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0xb7b(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * stor_c - _dividendsOf[msg.sender] >> 64) + owner_8[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * stor_c - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0xd60() private { \n    return _exit[msg.sender];\n}\n\nfunction 0xde4(uint256 varg0, uint256 varg1) private { \n    v0 = 0xd60();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = 0xb7b(1);\n    if (v1 > 0) {\n        0x8e4();\n    }\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v2 = address(varg1);\n    v3 = varg0 + _exit[v2];\n    assert(v3 >= _exit[v2]);\n    v4 = address(varg1);\n    _exit[v4] = v3;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg0 * stor_c;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + varg0 * stor_c;\n    emit Transfer(msg.sender, v4, varg0);\n    return 1;\n}\n\nfunction 0xf99(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = 0xd60();\n    require(v2 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v3 = 0x1942(varg0);\n    v4 = v5 = 4092;\n    v6 = v7 = _SafeMul(20, v3);\n    while (!100) {\n        assert(100);\n        assert(v0 <= v3);\n        assert(v0 <= v3 - v0);\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        assert(varg0 <= _totalSupply);\n        _totalSupply = _totalSupply - varg0;\n        assert(varg0 <= _exit[msg.sender]);\n        _exit[msg.sender] = _exit[msg.sender] - varg0;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v3 - v0 - v0 << 64) + varg0 * stor_c);\n        if (_totalSupply > 0) {\n            assert(_totalSupply);\n            assert((v0 << 64) / _totalSupply + stor_c >= stor_c);\n            stor_c += (v0 << 64) / _totalSupply;\n        }\n        emit onTokenSell(msg.sender, varg0, v3 - v0 - v0);\n        return ;\n        v0 = v6 / 100;\n        goto {'0x100c', '0xffc'};\n        v4 = v8 = 4108;\n        v6 = v9 = _SafeMul(5, v3);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0xf34dc16 == function_selector) {\n            canAcceptTokens_(address);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x294205b4 == function_selector) {\n            setCanAcceptTokens(address,bool);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x5e079aa5 == function_selector) {\n            giveEthFundAddress();\n        } else if (0x66042e7a == function_selector) {\n            etherToSendFund();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x76be1585 == function_selector) {\n            administrators(address);\n        } else if (0x7ff276bd == function_selector) {\n            totalEthFundCollected();\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x87c95058 == function_selector) {\n            setAdministrator(address,bool);\n        } else if (0x8974372d == function_selector) {\n            payFund();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa4d55686 == function_selector) {\n            totalEthFundRecieved();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 23:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalEthFundRecieved; // STORAGE[0x3]\nuint256 _totalEthFundCollected; // STORAGE[0x4]\nuint256 _stakingRequirement; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x7]\nmapping (uint256 => [uint256]) owner_8; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) owner_a; // STORAGE[0xa]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _setStakingRequirement; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _canAcceptTokens_; // STORAGE[0xf]\nuint8 _onlyAmbassadors; // STORAGE[0xe] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x1246(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    if (block.timestamp >= stor_0) {\n        _onlyAmbassadors = 0;\n    }\n    v4 = v5 = _onlyAmbassadors;\n    if (v5) {\n        v4 = v6 = (address(this)).balance - varg1 <= 0x6f05b59d3b200000;\n    }\n    if (!v4) {\n        _onlyAmbassadors = 0;\n        v7 = v8 = 5595;\n        v9 = v10 = _SafeMul(20, varg1);\n    } else {\n        v11 = v12 = 1 == 0xff & owner_6[msg.sender];\n        if (v12) {\n            v11 = v13 = varg1 + owner_a[msg.sender] <= 0x6f05b59d3b200000;\n        }\n        require(v11);\n        v14 = varg1 + owner_a[msg.sender];\n        assert(v14 >= owner_a[msg.sender]);\n        owner_a[msg.sender] = v14;\n        v7 = v15 = 4925;\n        v9 = v16 = _SafeMul(20, varg1);\n    }\n    while (!100) {\n        assert(100);\n        assert(v2 <= v0);\n        v17 = v18 = v0 - v2;\n        v19 = v20 = 4987;\n        assert(v0 <= varg1);\n        v21 = v22 = varg1 - v0;\n        assert(v0 <= v21);\n        goto {'0x137b', '0x1613'};\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        v23 = v24 = 0x18b0(v21 - v0);\n        v25 = v26 = v17 << 64;\n        v27 = v28 = v24 > 0;\n        if (v28) {\n            assert(_totalSupply + v24 >= v24);\n            v27 = v29 = _totalSupply + v24 > _totalSupply;\n        }\n        require(v27);\n        v30 = !address(varg0);\n        v31 = v32 = address(varg0);\n        if (address(varg0)) {\n            v31 = v33 = address(varg0) != msg.sender;\n        }\n        if (v31) {\n            v34 = address(varg0);\n            v31 = v35 = _exit[v34] >= _stakingRequirement;\n        }\n        if (!v31) {\n            v17 = v36 = v2 + v17;\n            assert(v36 >= v17);\n            v25 = v37 = v36 << 64;\n        } else {\n            v38 = address(varg0);\n            assert(v2 + owner_8[v38] >= owner_8[v38]);\n            v39 = address(varg0);\n            owner_8[v39] = v2 + owner_8[v38];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v24;\n        } else {\n            assert(v24 + _totalSupply >= _totalSupply);\n            _totalSupply += v24;\n            assert(v24 + _totalSupply);\n            stor_c = stor_c + (v17 << 64) / (v24 + _totalSupply);\n            assert(_totalSupply);\n            v25 = v40 = v25 - (v25 - v24 * ((v17 << 64) / _totalSupply));\n        }\n        assert(v24 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v24;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_c * v24 - v25);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v24);\n        return v23;\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        v23 = v41 = 0x18b0(v21 - v0);\n        v42 = v43 = v17 << 64;\n        v44 = v45 = v41 > 0;\n        if (v45) {\n            assert(_totalSupply + v41 >= v41);\n            v44 = v46 = _totalSupply + v41 > _totalSupply;\n        }\n        require(v44);\n        v47 = !address(varg0);\n        v48 = v49 = address(varg0);\n        if (address(varg0)) {\n            v48 = v50 = address(varg0) != msg.sender;\n        }\n        if (v48) {\n            v51 = address(varg0);\n            v48 = v52 = _exit[v51] >= _stakingRequirement;\n        }\n        if (!v48) {\n            v17 += v2;\n            assert(v17 >= v17);\n            v42 = v53 = v17 << 64;\n        } else {\n            v54 = address(varg0);\n            assert(v2 + owner_8[v54] >= owner_8[v54]);\n            v55 = address(varg0);\n            owner_8[v55] = v2 + owner_8[v54];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v41;\n        } else {\n            assert(v41 + _totalSupply >= _totalSupply);\n            _totalSupply += v41;\n            assert(v41 + _totalSupply);\n            stor_c = stor_c + (v17 << 64) / (v41 + _totalSupply);\n            assert(_totalSupply);\n            v42 = v56 = v42 - (v42 - v41 * ((v17 << 64) / _totalSupply));\n        }\n        assert(v41 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v41;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_c * v41 - v42);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v41);\n        assert(v2 <= v0);\n        v17 = v57 = v0 - v2;\n        v19 = v58 = 5651;\n        assert(v0 <= varg1);\n        v21 = varg1 - v0;\n        goto 0x1375;\n        v0 = v9 / 100;\n        goto {'0x135a', '0x133d', '0x15f8', '0x15db'};\n        assert(3);\n        v2 = v59 = v0 / 3;\n        v7 = v60 = 4954;\n        v9 = v61 = _SafeMul(5, varg1);\n        assert(3);\n        v2 = v0 / 3;\n        v7 = v62 = 5624;\n        v9 = v63 = _SafeMul(5, varg1);\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0x18b0(uint256 varg0) private { \n    v0 = v1 = 0x4140c78940f6a24fdffc78873d4490d2100000000000000 + (_totalSupply * 0xf0bdc21abb48db201e86d4000000000 + (0xde0b6b3a7640000 * _totalSupply ** 2 + varg0 * 0x59aedfc10d7279c5eed1401645400000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x204fce5e3e25026110000000 <= v0);\n    assert(0x3b9aca00);\n    return (v0 - 0x204fce5e3e25026110000000) / 0x3b9aca00 - _totalSupply;\n}\n\nfunction 0x1942(uint256 varg0) private { \n    v0 = varg0 * (0x3b9aca00 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000) + 0x218711a00);\n    v1 = 0x3b9aca00 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    require(msg.gas <= 0x2540be400);\n    v0 = 0x621(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * stor_c - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction canAcceptTokens_(address varg0) public nonPayable { \n    return 0xff & _canAcceptTokens_[varg0];\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 2026;\n    v4 = v5 = _SafeMul(20, varg0);\n    while (!100) {\n        assert(100);\n        assert(v0 <= varg0);\n        assert(v0 <= varg0 - v0);\n        v6 = 0x18b0(varg0 - v0 - v0);\n        return v6;\n        v0 = v4 / 100;\n        goto {'0x7eaB0x2c3', '0x7faB0x2c3'};\n        v2 = v7 = 2042;\n        v4 = v8 = _SafeMul(5, varg0);\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    require(varg0 <= _totalSupply);\n    v2 = 0x1942(varg0);\n    v3 = v4 = 2141;\n    v5 = v6 = _SafeMul(20, v2);\n    while (!100) {\n        assert(100);\n        assert(v0 <= v2);\n        assert(v0 <= v2 - v0);\n        return v2 - v0 - v0;\n        v0 = v5 / 100;\n        goto {'0x85dB0x2ec', '0x86dB0x2ec'};\n        v3 = v7 = 2157;\n        v5 = v8 = _SafeMul(5, v2);\n    }\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction setCanAcceptTokens(address varg0, bool varg1) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _canAcceptTokens_[varg0] = varg1 | ~0xff & _canAcceptTokens_[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0x8e4();\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(varg0);\n    require(1 == 0xff & _canAcceptTokens_[varg0]);\n    v0 = 0xde4(varg1, varg0);\n    require(v0);\n    if (varg0.code.size > 0) {\n        v1 = new array[]((?).length);\n        require(varg0.code.size);\n        v2, v3 = varg0.tokenFallback(msg.sender, varg1, v1).gas(msg.gas);\n        require(v2);\n        require(v3);\n    }\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    v0 = v1 = 0;\n    if (0 != _totalSupply) {\n        v2 = 0x1942(0xde0b6b3a7640000);\n        v3 = v4 = 2844;\n        v5 = v6 = _SafeMul(20, v2);\n        while (!100) {\n            assert(100);\n            assert(v0 <= v2);\n            assert(v0 <= v2 - v0);\n            v7 = v2 - v0 - v0;\n            v0 = v5 / 100;\n            goto {'0xb1cB0x3a6', '0xb2cB0x3a6'};\n            v3 = v8 = 2860;\n            v5 = v9 = _SafeMul(5, v2);\n        }\n    } else {\n        v7 = v10 = 0x218711a00;\n    }\n    return v7;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction giveEthFundAddress() public nonPayable { \n    return 0xd9092d94f74e6b5d408dbd3ecc88f3e5810d1e98;\n}\n\nfunction etherToSendFund() public nonPayable { \n    assert(_totalEthFundRecieved <= _totalEthFundCollected);\n    return _totalEthFundCollected - _totalEthFundRecieved;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xb7b(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction administrators(address varg0) public nonPayable { \n    return 0xff & _setStakingRequirement[varg0];\n}\n\nfunction totalEthFundCollected() public nonPayable { \n    return _totalEthFundCollected;\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    v0 = v1 = 0;\n    if (0 != _totalSupply) {\n        v2 = 0x1942(0xde0b6b3a7640000);\n        v3 = v4 = 3185;\n        v5 = v6 = _SafeMul(20, v2);\n        while (!100) {\n            assert(100);\n            assert(v0 + v2 >= v2);\n            v7 = v0 + (v0 + v2);\n            assert(v7 >= v0 + v2);\n            v0 = v5 / 100;\n            goto {'0xc81B0x4a0', '0xc71B0x4a0'};\n            v3 = v8 = 3201;\n            v5 = v9 = _SafeMul(5, v2);\n        }\n    } else {\n        v7 = v10 = 0x28fa6ae00;\n    }\n    return v7;\n}\n\nfunction setAdministrator(address varg0, bool varg1) public nonPayable { \n    require(0xff & _setStakingRequirement[msg.sender]);\n    _setStakingRequirement[varg0] = varg1 | ~0xff & _setStakingRequirement[varg0];\n}\n\nfunction payFund() public payable { \n    assert(_totalEthFundRecieved <= _totalEthFundCollected);\n    require(_totalEthFundCollected - _totalEthFundRecieved > 1);\n    assert(_totalEthFundCollected - _totalEthFundRecieved + _totalEthFundRecieved >= _totalEthFundRecieved);\n    _totalEthFundRecieved += _totalEthFundCollected - _totalEthFundRecieved;\n    v0 = 0xd9092d94f74e6b5d408dbd3ecc88f3e5810d1e98.call().value(_totalEthFundCollected - _totalEthFundRecieved).gas(0x61a80);\n    if (!v0) {\n        assert(_totalEthFundCollected - _totalEthFundRecieved <= _totalEthFundRecieved);\n        _totalEthFundRecieved = _totalEthFundRecieved - (_totalEthFundCollected - _totalEthFundRecieved);\n    }\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xd60();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction totalEthFundRecieved() public nonPayable { \n    return _totalEthFundRecieved;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xde4(varg1, varg0);\n    return v0;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _setStakingRequirement[msg.sender]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length);\n    require(0xff & _setStakingRequirement[msg.sender]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0xf99(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0xf99(_exit[msg.sender]);\n    }\n    0x8e4();\n}\n\nfunction buy(address varg0) public payable { \n    require(msg.gas <= 0xba43b7400);\n    v0 = 0x621(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xb7b(1);\n    require(v0 > 0);\n    v1 = 0xb7b(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x1246(0, v1 + _dividendsOf[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + _dividendsOf[msg.sender], v2);\n}\n\nfunction 0x621(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    require(msg.sender == address(tx.origin));\n    if (varg1 > 0x1bc16d674ec80000) {\n        assert(varg1 <= (address(this)).balance);\n        if ((address(this)).balance - varg1 <= 0xad78ebc5ac6200000) {\n            varg1 = v2 = 0x1bc16d674ec80000;\n            assert(v2 <= varg1);\n            v0 = varg1 - v2;\n        }\n    }\n    v3 = 0x1246(varg0, varg1);\n    if (v0 > 0) {\n        v4 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v4);\n    }\n    return 0;\n}\n\nfunction 0x8e4() private { \n    v0 = 0xb7b(1);\n    require(v0 > 0);\n    v1 = 0xb7b(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0xb7b(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * stor_c - _dividendsOf[msg.sender] >> 64) + owner_8[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * stor_c - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0xd60() private { \n    return _exit[msg.sender];\n}\n\nfunction 0xde4(uint256 varg0, uint256 varg1) private { \n    v0 = 0xd60();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = 0xb7b(1);\n    if (v1 > 0) {\n        0x8e4();\n    }\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v2 = address(varg1);\n    v3 = varg0 + _exit[v2];\n    assert(v3 >= _exit[v2]);\n    v4 = address(varg1);\n    _exit[v4] = v3;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg0 * stor_c;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + varg0 * stor_c;\n    emit Transfer(msg.sender, v4, varg0);\n    return 1;\n}\n\nfunction 0xf99(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = 0xd60();\n    require(v2 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v3 = 0x1942(varg0);\n    v4 = v5 = 4092;\n    v6 = v7 = _SafeMul(20, v3);\n    while (!100) {\n        assert(100);\n        assert(v0 <= v3);\n        assert(v0 <= v3 - v0);\n        assert(v0 + _totalEthFundCollected >= _totalEthFundCollected);\n        _totalEthFundCollected += v0;\n        assert(varg0 <= _totalSupply);\n        _totalSupply = _totalSupply - varg0;\n        assert(varg0 <= _exit[msg.sender]);\n        _exit[msg.sender] = _exit[msg.sender] - varg0;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v3 - v0 - v0 << 64) + varg0 * stor_c);\n        if (_totalSupply > 0) {\n            assert(_totalSupply);\n            assert((v0 << 64) / _totalSupply + stor_c >= stor_c);\n            stor_c += (v0 << 64) / _totalSupply;\n        }\n        emit onTokenSell(msg.sender, varg0, v3 - v0 - v0);\n        return ;\n        v0 = v6 / 100;\n        goto {'0x100c', '0xffc'};\n        v4 = v8 = 4108;\n        v6 = v9 = _SafeMul(5, v3);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0xf34dc16 == function_selector) {\n            canAcceptTokens_(address);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x294205b4 == function_selector) {\n            setCanAcceptTokens(address,bool);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x5e079aa5 == function_selector) {\n            giveEthFundAddress();\n        } else if (0x66042e7a == function_selector) {\n            etherToSendFund();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x76be1585 == function_selector) {\n            administrators(address);\n        } else if (0x7ff276bd == function_selector) {\n            totalEthFundCollected();\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x87c95058 == function_selector) {\n            setAdministrator(address,bool);\n        } else if (0x8974372d == function_selector) {\n            payFund();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa4d55686 == function_selector) {\n            totalEthFundRecieved();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 41.082858085632324,
	"usage": {
		"completion_tokens": 827,
		"prompt_tokens": 7384,
		"total_tokens": 8211
	}
}