{
	"address": "0x93d812bf90a575d628e246b0966505a9e466f534",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the equivalent Solidity code for the given decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract Contract {\n    mapping (address => uint) public deposited;\n    address public owner;\n    address public wallet;\n    uint public state;\n\n    function close() public {\n        require(msg.sender == owner);\n        state = 2;\n        // log info omitted for brevity\n        bool result = wallet.send(address(this).balance);\n        if (!result) {\n            revert();\n        }\n    }\n    \n    function enableRefunds() public {\n        require(msg.sender == owner);\n        require(state == 0);\n        state = 1;\n        // log info omitted for brevity\n    }\n    \n    function transferOwnership(address _newOwner) public {\n        require(msg.sender == owner);\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }\n    \n    function deposit(address _address) public payable {\n        require(msg.sender == owner);\n        require(state == 0);\n        deposited[_address] += msg.value;\n    }\n    \n    function refund(address _address) public {\n        require(state == 1);\n        uint amount = deposited[_address];\n        deposited[_address] = 0;\n        _address.transfer(amount);\n        // log info omitted for brevity\n    }\n}\n```\n\nPlease note that the above Solidity code is a simplified version of the decompiled EVM Bytecode. It omits the details of the log information and the original hashing operations on the address. Solidity automatically hashes the address in the mapping, so we don't need to hash it again. Also, Solidity events are used instead of manual log operations. \n\nFurthermore, this code is written in Solidity version 0.4.24. If you are using a different version, you may need to adjust the syntax accordingly. The contract also lacks a constructor, so you'll need to add one to set the initial state of the contract, including the `owner` and `wallet` state variables.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474207,
	"id": "chatcmpl-8MvJHVgNMrzgMJzyPJ7aB6KtBnyjZ",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x43d726d6) {\n            // Dispatch table entry for close()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00ae;\n            close();\n            stop();\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00c3;\n            var var2 = wallet();\n        \n        label_00C3:\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00c3;\n            var2 = owner();\n            goto label_00C3;\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0136;\n            var2 = state();\n            var var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp2 = var4;\n            memory[temp2:temp2 + 0x20] = var5 & 0xff;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0179;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            var2 = deposited(var2);\n            var temp4 = memory[0x40:0x60];\n            memory[temp4:temp4 + 0x20] = var2;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function close() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (storage[0x02] & ~0xff0000000000000000000000000000000000000000) | 0x02 * 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        var temp3 = address(address(this) & temp2).balance;\n        var temp4 = memory[0x40:0x60];\n        var temp5;\n        temp5, memory[temp4:temp4 + 0x00] = address(temp2 & storage[0x02]).call.gas(!temp3 * 0x08fc).value(temp3)(memory[temp4:temp4 + memory[0x40:0x60] - temp4]);\n    \n        if (temp5) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function wallet() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function enableRefunds() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (storage[0x02] & ~0xff0000000000000000000000000000000000000000) | 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function state() returns (var r0) { return storage[0x02] / 0x02 ** 0xa0 & 0xff; }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { return; }\n    \n        storage[0x00] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var0 = 0x0453;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0523(var1, var2);\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n        var var2 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        var temp2 = storage[temp1];\n        storage[temp1] = 0x00;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = memory[0x40:0x60];\n        memory[temp5:temp5 + 0x20] = var0;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function func_0523(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { assert(); }\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x43d726d6) {\n            // Dispatch table entry for close()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00ae;\n            close();\n            stop();\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00c3;\n            var var2 = wallet();\n        \n        label_00C3:\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00c3;\n            var2 = owner();\n            goto label_00C3;\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0136;\n            var2 = state();\n            var var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp2 = var4;\n            memory[temp2:temp2 + 0x20] = var5 & 0xff;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0179;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            var2 = deposited(var2);\n            var temp4 = memory[0x40:0x60];\n            memory[temp4:temp4 + 0x20] = var2;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function close() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (storage[0x02] & ~0xff0000000000000000000000000000000000000000) | 0x02 * 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        var temp3 = address(address(this) & temp2).balance;\n        var temp4 = memory[0x40:0x60];\n        var temp5;\n        temp5, memory[temp4:temp4 + 0x00] = address(temp2 & storage[0x02]).call.gas(!temp3 * 0x08fc).value(temp3)(memory[temp4:temp4 + memory[0x40:0x60] - temp4]);\n    \n        if (temp5) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function wallet() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function enableRefunds() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (storage[0x02] & ~0xff0000000000000000000000000000000000000000) | 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function state() returns (var r0) { return storage[0x02] / 0x02 ** 0xa0 & 0xff; }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { return; }\n    \n        storage[0x00] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var0 = 0x0453;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0523(var1, var2);\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n        var var2 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        var temp2 = storage[temp1];\n        storage[temp1] = 0x00;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = memory[0x40:0x60];\n        memory[temp5:temp5 + 0x20] = var0;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function func_0523(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { assert(); }\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x43d726d6) {\n            // Dispatch table entry for close()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00ae;\n            close();\n            stop();\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00c3;\n            var var2 = wallet();\n        \n        label_00C3:\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00c3;\n            var2 = owner();\n            goto label_00C3;\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0136;\n            var2 = state();\n            var var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp2 = var4;\n            memory[temp2:temp2 + 0x20] = var5 & 0xff;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0179;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            var2 = deposited(var2);\n            var temp4 = memory[0x40:0x60];\n            memory[temp4:temp4 + 0x20] = var2;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00ae;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function close() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (storage[0x02] & ~0xff0000000000000000000000000000000000000000) | 0x02 * 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        var temp3 = address(address(this) & temp2).balance;\n        var temp4 = memory[0x40:0x60];\n        var temp5;\n        temp5, memory[temp4:temp4 + 0x00] = address(temp2 & storage[0x02]).call.gas(!temp3 * 0x08fc).value(temp3)(memory[temp4:temp4 + memory[0x40:0x60] - temp4]);\n    \n        if (temp5) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function wallet() returns (var r0) { return storage[0x02] & 0x02 ** 0xa0 - 0x01; }\n    \n    function enableRefunds() {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        storage[0x02] = (storage[0x02] & ~0xff0000000000000000000000000000000000000000) | 0x02 ** 0xa0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function state() returns (var r0) { return storage[0x02] / 0x02 ** 0xa0 & 0xff; }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { return; }\n    \n        storage[0x00] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n        var var1 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        var0 = 0x0453;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0523(var1, var2);\n        memory[0x00:0x20] = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n        var var2 = storage[0x02] / 0x02 ** 0xa0 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0 & 0x02 ** 0xa0 - 0x01;\n        memory[0x00:0x20] = temp0;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = keccak256(memory[0x00:0x40]);\n        var temp2 = storage[temp1];\n        storage[temp1] = 0x00;\n        var0 = temp2;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(temp0).call.gas(!var0 * 0x08fc).value(var0)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (!temp4) { revert(memory[0x00:0x00]); }\n    \n        var temp5 = memory[0x40:0x60];\n        memory[temp5:temp5 + 0x20] = var0;\n        var temp6 = memory[0x40:0x60];\n        log(memory[temp6:temp6 + (temp5 + 0x20) - temp6], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0x02 ** 0xa0 - 0x01]);\n    }\n    \n    function func_0523(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { assert(); }\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 24.42298173904419,
	"usage": {
		"completion_tokens": 423,
		"prompt_tokens": 2927,
		"total_tokens": 3350
	}
}