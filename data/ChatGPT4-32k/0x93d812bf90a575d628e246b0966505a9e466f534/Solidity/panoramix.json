{
	"address": "0x93d812bf90a575d628e246b0966505a9e466f534",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity smart contract translation of the decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Wallet {\n    address private owner;\n    mapping (address => uint256) private deposited;\n    uint8 private state;\n    address private walletAddress;\n\n    event RefundsEnabled();\n    event Closed();\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\n\n    constructor(address _walletAddress) public {\n        owner = msg.sender;\n        walletAddress = _walletAddress;\n    }\n\n    function wallet() public view returns (address) {\n        return walletAddress;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getState() public view returns (uint8) {\n        require(state <= 2);\n        return state;\n    }\n\n    function getDeposited(address account) public view returns (uint256) {\n        return deposited[account];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n    function enableRefunds() public {\n        require(msg.sender == owner && state <= 2 && state == 0);\n        state = 1;\n        emit RefundsEnabled();\n    }\n\n    function close() public {\n        require(msg.sender == owner && state <= 2 && state == 0);\n        state = 2;\n        emit Closed();\n        (bool success,) = walletAddress.call.value(address(this).balance)(\"\");\n        require(success);\n    }\n\n    function deposit(address account) public payable {\n        require(msg.sender == owner && state <= 2 && state == 0);\n        require(msg.value + deposited[account] >= deposited[account]);\n        deposited[account] += msg.value;\n    }\n\n    function refund(address investor) public {\n        require(state <= 2 && state == 1);\n        uint256 refundAmount = deposited[investor];\n        deposited[investor] = 0;\n        (bool success,) = investor.call.value(refundAmount)(\"\");\n        require(success);\n        emit Refunded(investor, refundAmount);\n    }\n}\n```\nThis contract allows the contract's owner to deposit ether for different accounts, enable refunds, transfer the ownership, and close the contract. The owner can also refund the accounts if refunds have been enabled. The state of the contract controls whether it's possible to deposit (state 0), refund (state 1), or if the contract is closed (state 2).",
				"role": "assistant"
			}
		}
	],
	"created": 1700473556,
	"id": "chatcmpl-8Mv8mDMZYrTKaV0yIlNmXfK5VpAnf",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  state is uint8 at storage 2 offset 160\n  walletAddress is address at storage 2\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  if newOwner:\n      owner = newOwner\n\ndef enableRefunds(): # not payable\n  require owner == caller\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef close(): # not payable\n  require owner == caller\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef deposit(address account) payable: \n  require owner == caller\n  require state <= 2\n  require not state\n  require call.value + deposited[address(account)] >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  state is uint8 at storage 2 offset 160\n  walletAddress is address at storage 2\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  if newOwner:\n      owner = newOwner\n\ndef enableRefunds(): # not payable\n  require owner == caller\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef close(): # not payable\n  require owner == caller\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef deposit(address account) payable: \n  require owner == caller\n  require state <= 2\n  require not state\n  require call.value + deposited[address(account)] >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  state is uint8 at storage 2 offset 160\n  walletAddress is address at storage 2\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  if newOwner:\n      owner = newOwner\n\ndef enableRefunds(): # not payable\n  require owner == caller\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef close(): # not payable\n  require owner == caller\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef deposit(address account) payable: \n  require owner == caller\n  require state <= 2\n  require not state\n  require call.value + deposited[address(account)] >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n.",
	"status": "1",
	"time_cost": 46.599074363708496,
	"usage": {
		"completion_tokens": 523,
		"prompt_tokens": 473,
		"total_tokens": 996
	}
}