{
	"address": "0x645f0c9695f2b970e623ae29538fdb1a67bd6b6e",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.25 13:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _whaleLedger; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _gameLedger; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _gamePlayers; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _buy; // STORAGE[0xa]\nuint256[] array_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 _calculateEthereumReceived; // STORAGE[0xd]\nuint256 _totalSupply; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _openToThePublic; // STORAGE[0x2] bytes 0 to 0\nuint256 _owner; // STORAGE[0x2] bytes 1 to 20\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\nlotteryPayout(address, uint256);\nwhaleDump(uint256);\n\nfunction 0x107e(uint256 varg0, uint256 varg1) private { \n    require(tx.origin == msg.sender);\n    v0 = 0x13d1(15, varg1);\n    assert(100);\n    assert(v0 / 100 / 3 + v0 / 100 / 3 <= v0 / 100);\n    v1 = v0 / 100 - (v0 / 100 / 3 + v0 / 100 / 3);\n    v2 = 0xde0b6b3a7640000 * ((varg1 - v0 / 100) / 0x1c6bf52634000);\n    _whaleLedger[_owner] += v0 / 100 / 3 >> 1;\n    stor_c += 0xde0b6b3a7640000 * ((v0 / 100 / 3 - (v0 / 100 / 3 >> 1)) / 0x1c6bf52634000);\n    array_b.length = array_b.length + 1;\n    MEM[0] = 11;\n    STORAGE[0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db9 + array_b.length] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db9 + array_b.length];\n    v3 = v4 = v1 << 64;\n    v5 = v6 = v2 > 0;\n    if (v6) {\n        v5 = v7 = _calculateEthereumReceived + v2 > _calculateEthereumReceived;\n    }\n    require(v5);\n    v8 = !address(varg0);\n    v9 = v10 = address(varg0);\n    if (address(varg0)) {\n        v9 = v11 = msg.sender != address(varg0);\n    }\n    if (v9) {\n        v12 = address(varg0);\n        v9 = v13 = !(0xff & owner_3[v12]);\n    }\n    if (v9) {\n        v14 = address(varg0);\n        v9 = v15 = 0x4563918244f40000 <= owner_4[v14];\n    }\n    if (!v9) {\n        v1 = v16 = v0 / 100 / 3 + v1;\n        v3 = v17 = v16 << 64;\n    } else {\n        v18 = address(varg0);\n        owner_7[v18] += v0 / 100 / 3;\n    }\n    v19 = 0x1469();\n    if (_calculateEthereumReceived <= 0) {\n        _calculateEthereumReceived = v2;\n        if (!_whaleLedger[_owner]) {\n            _whaleLedger[_owner] = v19;\n        }\n    } else {\n        _calculateEthereumReceived += v2;\n        assert(v2 + _calculateEthereumReceived);\n        stor_f = stor_f + (v1 + v19 << 64) / (v2 + _calculateEthereumReceived);\n        assert(_calculateEthereumReceived);\n        v3 = v20 = v3 - (v3 - v2 * ((v1 << 64) / _calculateEthereumReceived));\n    }\n    owner_4[msg.sender] = owner_4[msg.sender] + v2;\n    owner_4[msg.sender] = owner_4[msg.sender] + (stor_f * v2 - v3);\n    emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v2);\n    return v2;\n}\n\nfunction 0x13d1(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x1435(uint256 varg0) private { \n    assert(0xde0b6b3a7640000);\n    return 0x1c6bf52634000 * (varg0 / 0xde0b6b3a7640000);\n}\n\nfunction 0x1469() private { \n    if (0xde0b6b3a7640000 > _whaleLedger[_owner]) {\n        return 0;\n    } else {\n        if (0 < array_b.length) {\n            assert(array_b.length);\n            assert(block.blockhash(block.number + ~0) % array_b.length < array_b.length);\n            owner_4[address(array_b[block.blockhash(block.number + ~0) % array_b.length])] += stor_c;\n            assert(block.blockhash(block.number + ~0) % array_b.length < array_b.length);\n            emit lotteryPayout(address(array_b[block.blockhash(block.number + ~0) % array_b.length]), stor_c);\n            _calculateEthereumReceived += stor_c;\n            stor_c = 0;\n            array_b.length = 0;\n            while (v0 + array_b.length > v1) {\n                STORAGE[v1] = 0;\n                v1 += 1;\n            }\n        }\n        _whaleLedger[_owner] = 0;\n        emit whaleDump(_whaleLedger[_owner]);\n        return _whaleLedger[_owner];\n    }\n}\n\nfunction () public payable { \n    if (!_openToThePublic) {\n        require(1 == 0xff & _buy[msg.sender]);\n    }\n    require(tx.origin == msg.sender);\n    v0 = 0x4f3(0);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return owner_4[varg0] * stor_f - _dividendsOf[varg0] >> 64;\n}\n\nfunction gamePlayers(address varg0, address varg1) public nonPayable { \n    return _gamePlayers[varg1];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    require(varg0 >= 0x1c6bf52634000);\n    v0 = 0x13d1(15, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return 0xde0b6b3a7640000 * ((varg0 - v0 / 100) / 0x1c6bf52634000);\n}\n\nfunction totalSupply() public nonPayable { \n    return _calculateEthereumReceived + stor_c + _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _calculateEthereumReceived);\n    v0 = 0x1435(varg0);\n    v1 = 0x13d1(15, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    return v0 - v1 / 100;\n}\n\nfunction openToThePublic() public nonPayable { \n    return _openToThePublic;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0x735();\n}\n\nfunction buyAndSellPrice() public nonPayable { \n    v0 = 0x13d1(15, 0x1c6bf52634000);\n    assert(100);\n    assert(v0 / 100 <= 0x1c6bf52634000);\n    return 0x1c6bf52634000 - v0 / 100;\n}\n\nfunction setGames(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    owner_3[varg0] = 0x1 | ~0xff & owner_3[varg0];\n}\n\nfunction gameLedger(address varg0) public nonPayable { \n    return _gameLedger[varg0];\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x8be(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    v0 = 0x8fa(varg0);\n    return v0;\n}\n\nfunction referralLinkRequirement() public nonPayable { \n    return 0x4563918244f40000;\n}\n\nfunction goPublic() public nonPayable { \n    require(msg.sender == _owner);\n    _openToThePublic = 1;\n    return 0xff & (0x1 | ~0xff & STORAGE[0x2]);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0x8fa(msg.sender);\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender != _owner);\n    v0 = 0x8fa(msg.sender);\n    require(v0 > 0);\n    if (!(0xff & owner_3[msg.sender])) {\n        require(tx.origin == msg.sender);\n    }\n    assert(_owner != varg0);\n    if (1 != 0xff & owner_3[msg.sender]) {\n        if (1 != 0xff & owner_3[varg0]) {\n            v1 = v2 = varg1 <= owner_4[msg.sender];\n            if (varg1 <= owner_4[msg.sender]) {\n                v1 = v3 = varg1 > 0;\n            }\n            require(v1);\n            owner_4[msg.sender] = owner_4[msg.sender] - varg1;\n            v4 = varg0;\n            owner_4[v4] += varg1;\n            owner_4[v4] = owner_4[v4] - varg1 * stor_f;\n            owner_4[v4] = owner_4[v4] + varg1 * stor_f;\n        } else {\n            v5 = v6 = varg1 <= owner_4[msg.sender];\n            if (varg1 <= owner_4[msg.sender]) {\n                v5 = v7 = varg1 > 0;\n                if (v7) {\n                    v5 = v8 = 0xde0b6b3a7640000 == varg1;\n                }\n            }\n            require(v5);\n            owner_4[msg.sender] = owner_4[msg.sender] - varg1;\n            v9 = varg0;\n            _gameLedger[v9] += varg1;\n            _totalSupply += varg1;\n            _gamePlayers[v9] += varg1;\n            _gamePlayers[v9] = _gamePlayers[v9] - varg1 * stor_f;\n        }\n    } else {\n        v10 = v11 = varg1 <= _gameLedger[msg.sender];\n        if (varg1 <= _gameLedger[msg.sender]) {\n            v10 = v12 = varg1 > 0;\n        }\n        require(v10);\n        _gameLedger[msg.sender] = _gameLedger[msg.sender] - varg1;\n        _totalSupply = _totalSupply - varg1;\n        _gameLedger[varg0] += varg1;\n        _gameLedger[varg0] = _gameLedger[varg0] + varg1 * stor_f;\n    }\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction whaleLedger(address varg0) public nonPayable { \n    return _whaleLedger[varg0];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0xd18(varg0);\n}\n\nfunction exit() public nonPayable { \n    require(msg.sender != _owner);\n    v0 = 0x8fa(msg.sender);\n    require(v0 > 0);\n    require(tx.origin == msg.sender);\n    if (owner_4[msg.sender] > 0) {\n        0xd18(owner_4[msg.sender]);\n    }\n    0x735();\n}\n\nfunction buy(address varg0) public payable { \n    if (!_openToThePublic) {\n        require(1 == 0xff & _buy[msg.sender]);\n    }\n    require(tx.origin == msg.sender);\n    v0 = 0x4f3(varg0);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x8be(1);\n    require(v0 > 0);\n    require(msg.sender != _owner);\n    require(tx.origin == msg.sender);\n    v1 = 0x8be(0);\n    v2 = 0x13d1(0x10000000000000000, v1);\n    _dividendsOf[msg.sender] += v2;\n    _dividendsOf[msg.sender] = 0;\n    v3 = 0x107e(0, _dividendsOf[msg.sender] + v1);\n    emit onReinvestment(msg.sender, _dividendsOf[msg.sender] + v1, v3);\n}\n\nfunction 0x4f3(uint256 varg0) private { \n    require(msg.sender != _owner);\n    require(tx.origin == msg.sender);\n    v0 = 0x107e(varg0, msg.value);\n    if (1 == 0xff & owner_3[msg.sender]) {\n        assert(v0 <= _calculateEthereumReceived);\n        _calculateEthereumReceived = _calculateEthereumReceived - v0;\n        assert(v0 <= owner_4[msg.sender]);\n        owner_4[msg.sender] = owner_4[msg.sender] - v0;\n        _gameLedger[msg.sender] += v0;\n        _totalSupply += v0;\n    }\n    return v0;\n}\n\nfunction 0x735() private { \n    require(msg.sender != _owner);\n    v0 = 0x8be(1);\n    require(v0 > 0);\n    require(tx.origin == msg.sender);\n    v1 = 0x8be(0);\n    v2 = 0x13d1(0x10000000000000000, v1);\n    _dividendsOf[msg.sender] += v2;\n    _dividendsOf[msg.sender] = 0;\n    v3 = msg.sender.call().value(_dividendsOf[msg.sender] + v1).gas(2300 * !(_dividendsOf[msg.sender] + v1));\n    require(v3); // checks call status, propagates error data on error\n    emit onWithdraw(msg.sender, _dividendsOf[msg.sender] + v1);\n    return ;\n}\n\nfunction 0x8be(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (owner_4[msg.sender] * stor_f - _dividendsOf[msg.sender] >> 64) + owner_7[msg.sender];\n    } else {\n        v0 = owner_4[msg.sender] * stor_f - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x8fa(uint256 varg0) private { \n    if (_owner != address(varg0)) {\n        v0 = address(varg0);\n        if (1 != 0xff & owner_3[v0]) {\n            v1 = address(varg0);\n            return owner_4[v1];\n        } else {\n            v2 = address(varg0);\n            v3 = v4 = _gameLedger[v2];\n        }\n    } else {\n        v5 = address(varg0);\n        v3 = v6 = _whaleLedger[v5];\n    }\n    return v3;\n}\n\nfunction 0xd18(uint256 varg0) private { \n    require(msg.sender != _owner);\n    v0 = 0x8fa(msg.sender);\n    require(v0 > 0);\n    require(tx.origin == msg.sender);\n    v1 = varg0 > owner_4[msg.sender];\n    v2 = v3 = varg0 <= owner_4[msg.sender];\n    if (varg0 <= owner_4[msg.sender]) {\n        v2 = v4 = varg0 > 0;\n    }\n    require(v2);\n    v5 = 0x1435(varg0);\n    assert(v5 * 15 / 100 <= v5);\n    _whaleLedger[_owner] += v5 * 15 / 100 / 3 - (v5 * 15 / 100 / 3 >> 1);\n    stor_c += 0xde0b6b3a7640000 * ((v5 * 15 / 100 / 3 >> 1) / 0x1c6bf52634000);\n    _calculateEthereumReceived = _calculateEthereumReceived - varg0;\n    owner_4[msg.sender] = owner_4[msg.sender] - varg0;\n    owner_4[msg.sender] = owner_4[msg.sender] - ((v5 - v5 * 15 / 100 << 64) + varg0 * stor_f);\n    if (_calculateEthereumReceived > 0) {\n        assert(_calculateEthereumReceived);\n        assert((v5 * 15 / 100 - v5 * 15 / 100 / 3 << 64) / _calculateEthereumReceived + stor_f >= stor_f);\n        stor_f += (v5 * 15 / 100 - v5 * 15 / 100 / 3 << 64) / _calculateEthereumReceived;\n    }\n    emit onTokenSell(msg.sender, varg0, v5 - v5 * 15 / 100);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x1d9873a == v0) {\n            gamePlayers(address,address);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x10d0ffdd == v0) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x22609373 == v0) {\n            calculateEthereumReceived(uint256);\n        } else if (0x246d4098 == v0) {\n            openToThePublic();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3daa33d5 == v0) {\n            buyAndSellPrice();\n        } else if (0x530c4ca6 == v0) {\n            setGames(address);\n        } else if (0x5f343a76 == v0) {\n            gameLedger(address);\n        } else if (0x688abbf7 == v0) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == v0) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x75ed5604 == v0) {\n            referralLinkRequirement();\n        } else if (0x8417fa2f == v0) {\n            goPublic();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x949e8acd == v0) {\n            myTokens();\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xdecbb8ba == v0) {\n            whaleLedger(address);\n        } else if (0xe4849b32 == v0) {\n            sell(uint256);\n        } else if (0xe9fad8ee == v0) {\n            exit();\n        } else if (0xf088d547 == v0) {\n            buy(address);\n        } else if (0xfdb5a03e == v0) {\n            reinvest();\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}