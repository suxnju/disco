{
	"address": "0x124635bfe95ba690fc095f6f3a0bdeac62fab8e1",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity smart contract that mimics the behavior of the decompiled EVM code. Please note that the actual contract might differ as EVM Bytecode does not contain any variable or function names:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    address private _destroy;\n    uint256 private _tokensPerETH;\n    address private _tokenReward;\n\n    event FundTransfer(address indexed to, uint256 amount, bool isContribution);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _destroy = msg.sender;\n    }\n\n    function withdrawTokens(address to, uint256 amount) public {\n        require(_destroy == msg.sender, \"Only owner can call this function.\");\n        bool success = payable(to).send(amount);\n        require(success, \"Transfer failed.\");\n    }\n\n    function withdraw(uint256 amount) public {\n        require(_destroy == msg.sender, \"Only owner can call this function.\");\n        bool success = payable(_destroy).send(amount);\n        require(success, \"Withdraw failed.\");\n        emit FundTransfer(_destroy, amount, false);\n    }\n\n    function tokenReward() public view returns(address) {\n        return _tokenReward;\n    }\n\n    function destroy() public {\n        require(_destroy == msg.sender, \"Only owner can call this function.\");\n        selfdestruct(payable(_destroy));\n    }\n\n    function owner() public view returns(address) {\n        return _destroy;\n    }\n\n    function changeEtherPrice(uint256 newPrice) public {\n        require(_destroy == msg.sender, \"Only owner can call this function.\");\n        _tokensPerETH = newPrice * 130 / 125;\n    }\n\n    function tokensPerETH() public view returns(uint256) {\n        return _tokensPerETH;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(_destroy == msg.sender, \"Only owner can call this function.\");\n        require(newOwner != address(0), \"New owner is the zero address.\");\n        emit OwnershipTransferred(_destroy, newOwner);\n        _destroy = newOwner;\n    }\n\n    fallback() external payable {\n        require(msg.value > 0, \"No ether provided.\");\n        uint256 amount = msg.value * _tokensPerETH;\n        bool success = payable(_tokenReward).send(amount);\n        require(success, \"Transfer failed.\");\n        emit FundTransfer(msg.sender, msg.value, true);\n    }\n}\n```\nThe contract contains a similar structure and functionality as the decompiled code. The contract includes functions to withdraw tokens, withdraw ETH, get the token reward address, destroy the contract, get the contract owner address, change the price of ETH in tokens, get the price of ETH in tokens, transfer the contract ownership, and a fallback function to handle incoming transactions.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459741,
	"id": "chatcmpl-8R3gzdVMX3zzSQMaQ0vjL0DSaPi4Z",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.17 16:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _tokensPerETH; // STORAGE[0x1]\naddress _destroy; // STORAGE[0x0] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nOwnershipTransferred(address, address);\n\nfunction withdrawTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_destroy == msg.sender);\n    require(varg0.code.size);\n    v0 = varg0.transfer(_destroy, varg1).gas(msg.gas);\n    require(v0);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    v0 = _destroy.call().value(varg0 * 0xde0b6b3a7640000).gas(2300 * !(varg0 * 0xde0b6b3a7640000));\n    require(v0);\n    emit FundTransfer(_destroy, varg0 * 0xde0b6b3a7640000, 0);\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction destroy() public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(_destroy);\n}\n\nfunction owner() public nonPayable { \n    return _destroy;\n}\n\nfunction changeEtherPrice(uint256 varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    _tokensPerETH = varg0 * 130 / 125;\n}\n\nfunction TokensPerETH() public nonPayable { \n    return _tokensPerETH;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_destroy, varg0);\n    _destroy = varg0;\n}\n\nfunction fallback() public payable { \n    require(msg.value);\n    require(_tokenReward.code.size);\n    v0 = _tokenReward.transfer(msg.sender, msg.value * _tokensPerETH).gas(msg.gas);\n    require(v0);\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x6b091f9) {\n            withdrawTokens(address,uint256);\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x6e66f6e9 == uint32(function_selector >> 224)) {\n            tokenReward();\n        } else if (0x83197ef0 == uint32(function_selector >> 224)) {\n            destroy();\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0x94679ce7 == uint32(function_selector >> 224)) {\n            changeEtherPrice(uint256);\n        } else if (0xe4492fcd == uint32(function_selector >> 224)) {\n            TokensPerETH();\n        } else if (0xf2fde38b == uint32(function_selector >> 224)) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.17 16:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _tokensPerETH; // STORAGE[0x1]\naddress _destroy; // STORAGE[0x0] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nOwnershipTransferred(address, address);\n\nfunction withdrawTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_destroy == msg.sender);\n    require(varg0.code.size);\n    v0 = varg0.transfer(_destroy, varg1).gas(msg.gas);\n    require(v0);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    v0 = _destroy.call().value(varg0 * 0xde0b6b3a7640000).gas(2300 * !(varg0 * 0xde0b6b3a7640000));\n    require(v0);\n    emit FundTransfer(_destroy, varg0 * 0xde0b6b3a7640000, 0);\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction destroy() public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(_destroy);\n}\n\nfunction owner() public nonPayable { \n    return _destroy;\n}\n\nfunction changeEtherPrice(uint256 varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    _tokensPerETH = varg0 * 130 / 125;\n}\n\nfunction TokensPerETH() public nonPayable { \n    return _tokensPerETH;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_destroy, varg0);\n    _destroy = varg0;\n}\n\nfunction fallback() public payable { \n    require(msg.value);\n    require(_tokenReward.code.size);\n    v0 = _tokenReward.transfer(msg.sender, msg.value * _tokensPerETH).gas(msg.gas);\n    require(v0);\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x6b091f9) {\n            withdrawTokens(address,uint256);\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x6e66f6e9 == uint32(function_selector >> 224)) {\n            tokenReward();\n        } else if (0x83197ef0 == uint32(function_selector >> 224)) {\n            destroy();\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0x94679ce7 == uint32(function_selector >> 224)) {\n            changeEtherPrice(uint256);\n        } else if (0xe4492fcd == uint32(function_selector >> 224)) {\n            TokensPerETH();\n        } else if (0xf2fde38b == uint32(function_selector >> 224)) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.17 16:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _tokensPerETH; // STORAGE[0x1]\naddress _destroy; // STORAGE[0x0] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nOwnershipTransferred(address, address);\n\nfunction withdrawTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_destroy == msg.sender);\n    require(varg0.code.size);\n    v0 = varg0.transfer(_destroy, varg1).gas(msg.gas);\n    require(v0);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    v0 = _destroy.call().value(varg0 * 0xde0b6b3a7640000).gas(2300 * !(varg0 * 0xde0b6b3a7640000));\n    require(v0);\n    emit FundTransfer(_destroy, varg0 * 0xde0b6b3a7640000, 0);\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction destroy() public nonPayable { \n    require(_destroy == msg.sender);\n    selfdestruct(_destroy);\n}\n\nfunction owner() public nonPayable { \n    return _destroy;\n}\n\nfunction changeEtherPrice(uint256 varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    _tokensPerETH = varg0 * 130 / 125;\n}\n\nfunction TokensPerETH() public nonPayable { \n    return _tokensPerETH;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_destroy == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_destroy, varg0);\n    _destroy = varg0;\n}\n\nfunction fallback() public payable { \n    require(msg.value);\n    require(_tokenReward.code.size);\n    v0 = _tokenReward.transfer(msg.sender, msg.value * _tokensPerETH).gas(msg.gas);\n    require(v0);\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x6b091f9) {\n            withdrawTokens(address,uint256);\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x6e66f6e9 == uint32(function_selector >> 224)) {\n            tokenReward();\n        } else if (0x83197ef0 == uint32(function_selector >> 224)) {\n            destroy();\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0x94679ce7 == uint32(function_selector >> 224)) {\n            changeEtherPrice(uint256);\n        } else if (0xe4492fcd == uint32(function_selector >> 224)) {\n            TokensPerETH();\n        } else if (0xf2fde38b == uint32(function_selector >> 224)) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 34.28055667877197,
	"usage": {
		"completion_tokens": 571,
		"prompt_tokens": 840,
		"total_tokens": 1411
	}
}