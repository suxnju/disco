{
	"address": "0xba1ecd051ab31d45f86bb2d7cd093715341c35a6",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code written based on the decompiled code:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Raffle {\n    mapping (address => uint256) private _balances;\n    address[] private _entrants;\n    uint256 private _numEntrants;\n    uint256 private _entryPrice;\n    uint256 private _deadline;\n    uint256 private _threshold;\n    uint256 private _percentageTaken;\n    address private _owner;\n    address private _winner;\n\n    event PlayerEntered(address indexed player, uint256 value, uint256 numEntrants);\n    event Winner(address indexed winner, uint256 amount);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function balances(address player) public view returns (uint256) {\n        return _balances[player];\n    }\n\n    function deadline() public view returns (uint256) {\n        return _deadline;\n    }\n\n    function enterRaffle() public payable {\n        require(block.timestamp <= _deadline, 'Deadline is Passed');\n        require(msg.value == _entryPrice, 'Incorrect Entry Price');\n\n        _balances[msg.sender] += msg.value;\n        _entrants.push(msg.sender);\n        _numEntrants++;\n\n        emit PlayerEntered(msg.sender, msg.value, _numEntrants);\n    }\n\n    function determineWinner() public {\n        require(msg.sender == _owner, 'You are not Owner');\n        require(block.timestamp >= _deadline, 'Deadline is not Passed');\n        require(_numEntrants >= _threshold, 'Below Thresold participant');\n        require(_winner == address(0), 'Winner is already picked');\n\n        uint256 index = (block.number - 1 + block.coinbase.balance) % _numEntrants;\n        _winner = _entrants[index];\n\n        uint256 winnerAmount = address(this).balance / _percentageTaken;\n        payable(_winner).transfer(winnerAmount);\n        payable(_owner).transfer(address(this).balance);\n\n        emit Winner(_winner, winnerAmount);\n    }\n\n    function threshold() public view returns (uint256) {\n        return _threshold;\n    }\n\n    function numEntrants() public view returns (uint256) {\n        return _numEntrants;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function winner() public view returns (address) {\n        return _winner;\n    }\n\n    function entrants(uint256 index) public view returns (address) {\n        require(index < _entrants.length, 'Invalid Index');\n        return _entrants[index];\n    }\n\n    function entryPrice() public view returns (uint256) {\n        return _entryPrice;\n    }\n\n    function withdrawFunds(uint256 amount) public {\n        require(block.timestamp >= _deadline, 'Deadline is not Passed');\n        require(_numEntrants <= _threshold, 'Above Thresold participant');\n        require(_balances[msg.sender] >= amount, 'Insufficient Balance');\n\n        _balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function percentageTaken() public view returns (uint256) {\n        return _percentageTaken;\n    }\n\n    receive() external payable {\n        enterRaffle();\n    }\n}\n```\nPlease note that the function selector logic has been omitted in the converted Solidity code. It's not necessary in Solidity because Solidity automatically creates a function selector for each public and external function.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463164,
	"id": "chatcmpl-8R4aCw3oTP0AtwZ3VVhcNpJMeLrP8",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 12:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x0]\nuint256[] _entrants; // STORAGE[0x3]\nuint256 _numEntrants; // STORAGE[0x4]\nuint256 _entryPrice; // STORAGE[0x5]\nuint256 _deadline; // STORAGE[0x6]\nuint256 _threshold; // STORAGE[0x7]\nuint256 _percentageTaken; // STORAGE[0x8]\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\naddress _winner; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nPlayerEntered(address, uint256, uint256);\nWinner(address, uint256);\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction enterRaffle() public payable { \n    0x35b();\n}\n\nfunction determineWinner() public nonPayable { \n    require(msg.sender == _owner, 'You are not Owner');\n    require(block.timestamp >= _deadline, 'Deadline is not Passed');\n    require(_numEntrants >= _threshold, 'Below Thresold participant');\n    require(_winner == 0, 'Winner is already picked');\n    require(2 > 0);\n    assert(2);\n    require(2 > 0);\n    assert(2);\n    require((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1) >= block.blockhash(block.number - 1) >> 1);\n    require(_numEntrants != 0);\n    assert(_numEntrants);\n    assert(((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1)) % _numEntrants < _entrants.length);\n    _winner = address(_entrants[((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1)) % _numEntrants]);\n    require(_percentageTaken > 0);\n    assert(stor_8_0_0);\n    v0 = _winner.call().value((address(this)).balance / _percentageTaken).gas(!((address(this)).balance / _percentageTaken) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Winner(_winner, (address(this)).balance / _percentageTaken);\n}\n\nfunction threshold() public nonPayable { \n    return _threshold;\n}\n\nfunction numEntrants() public nonPayable { \n    return _numEntrants;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction winner() public nonPayable { \n    return _winner;\n}\n\nfunction entrants(uint256 varg0) public nonPayable { \n    assert(varg0 < _entrants.length);\n    return address(_entrants[varg0]);\n}\n\nfunction entryPrice() public nonPayable { \n    return _entryPrice;\n}\n\nfunction 0x35b() private { \n    require(block.timestamp <= _deadline, 'Deadline is Passed');\n    require(msg.value == _entryPrice);\n    require(_balances[msg.sender] + msg.value >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    require(_numEntrants + 1 >= _numEntrants);\n    _numEntrants = _numEntrants + 1;\n    _entrants.length = _entrants.length + 1;\n    _entrants[_entrants.length + 1 - 1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _entrants[_entrants.length + 1 - 1];\n    emit PlayerEntered(msg.sender, msg.value, _numEntrants);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x35b();\n}\n\nfunction withdrawFunds(uint256 varg0) public nonPayable { \n    require(block.timestamp >= _deadline, 'Deadline is not Passed');\n    require(_numEntrants <= _threshold, 'Above Thresold participant');\n    require(_balances[msg.sender] >= varg0, 'You do not have enough balance');\n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction percentageTaken() public nonPayable { \n    return _percentageTaken;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x155dd5ee == function_selector) {\n            withdrawFunds(uint256);\n        } else if (0x2049eff6 == function_selector) {\n            percentageTaken();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x2cfcc539 == function_selector) {\n            enterRaffle();\n        } else if (0x33b16d93 == function_selector) {\n            determineWinner();\n        } else if (0x42cde4e8 == function_selector) {\n            threshold();\n        } else if (0x4efe0a60 == function_selector) {\n            numEntrants();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xdfbf53ae == function_selector) {\n            winner();\n        } else if (0xe7b4e5ab == function_selector) {\n            entrants(uint256);\n        } else if (0xf745adfc == function_selector) {\n            entryPrice();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 12:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x0]\nuint256[] _entrants; // STORAGE[0x3]\nuint256 _numEntrants; // STORAGE[0x4]\nuint256 _entryPrice; // STORAGE[0x5]\nuint256 _deadline; // STORAGE[0x6]\nuint256 _threshold; // STORAGE[0x7]\nuint256 _percentageTaken; // STORAGE[0x8]\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\naddress _winner; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nPlayerEntered(address, uint256, uint256);\nWinner(address, uint256);\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction enterRaffle() public payable { \n    0x35b();\n}\n\nfunction determineWinner() public nonPayable { \n    require(msg.sender == _owner, 'You are not Owner');\n    require(block.timestamp >= _deadline, 'Deadline is not Passed');\n    require(_numEntrants >= _threshold, 'Below Thresold participant');\n    require(_winner == 0, 'Winner is already picked');\n    require(2 > 0);\n    assert(2);\n    require(2 > 0);\n    assert(2);\n    require((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1) >= block.blockhash(block.number - 1) >> 1);\n    require(_numEntrants != 0);\n    assert(_numEntrants);\n    assert(((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1)) % _numEntrants < _entrants.length);\n    _winner = address(_entrants[((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1)) % _numEntrants]);\n    require(_percentageTaken > 0);\n    assert(stor_8_0_0);\n    v0 = _winner.call().value((address(this)).balance / _percentageTaken).gas(!((address(this)).balance / _percentageTaken) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Winner(_winner, (address(this)).balance / _percentageTaken);\n}\n\nfunction threshold() public nonPayable { \n    return _threshold;\n}\n\nfunction numEntrants() public nonPayable { \n    return _numEntrants;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction winner() public nonPayable { \n    return _winner;\n}\n\nfunction entrants(uint256 varg0) public nonPayable { \n    assert(varg0 < _entrants.length);\n    return address(_entrants[varg0]);\n}\n\nfunction entryPrice() public nonPayable { \n    return _entryPrice;\n}\n\nfunction 0x35b() private { \n    require(block.timestamp <= _deadline, 'Deadline is Passed');\n    require(msg.value == _entryPrice);\n    require(_balances[msg.sender] + msg.value >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    require(_numEntrants + 1 >= _numEntrants);\n    _numEntrants = _numEntrants + 1;\n    _entrants.length = _entrants.length + 1;\n    _entrants[_entrants.length + 1 - 1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _entrants[_entrants.length + 1 - 1];\n    emit PlayerEntered(msg.sender, msg.value, _numEntrants);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x35b();\n}\n\nfunction withdrawFunds(uint256 varg0) public nonPayable { \n    require(block.timestamp >= _deadline, 'Deadline is not Passed');\n    require(_numEntrants <= _threshold, 'Above Thresold participant');\n    require(_balances[msg.sender] >= varg0, 'You do not have enough balance');\n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction percentageTaken() public nonPayable { \n    return _percentageTaken;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x155dd5ee == function_selector) {\n            withdrawFunds(uint256);\n        } else if (0x2049eff6 == function_selector) {\n            percentageTaken();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x2cfcc539 == function_selector) {\n            enterRaffle();\n        } else if (0x33b16d93 == function_selector) {\n            determineWinner();\n        } else if (0x42cde4e8 == function_selector) {\n            threshold();\n        } else if (0x4efe0a60 == function_selector) {\n            numEntrants();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xdfbf53ae == function_selector) {\n            winner();\n        } else if (0xe7b4e5ab == function_selector) {\n            entrants(uint256);\n        } else if (0xf745adfc == function_selector) {\n            entryPrice();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 12:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x0]\nuint256[] _entrants; // STORAGE[0x3]\nuint256 _numEntrants; // STORAGE[0x4]\nuint256 _entryPrice; // STORAGE[0x5]\nuint256 _deadline; // STORAGE[0x6]\nuint256 _threshold; // STORAGE[0x7]\nuint256 _percentageTaken; // STORAGE[0x8]\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\naddress _winner; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nPlayerEntered(address, uint256, uint256);\nWinner(address, uint256);\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction enterRaffle() public payable { \n    0x35b();\n}\n\nfunction determineWinner() public nonPayable { \n    require(msg.sender == _owner, 'You are not Owner');\n    require(block.timestamp >= _deadline, 'Deadline is not Passed');\n    require(_numEntrants >= _threshold, 'Below Thresold participant');\n    require(_winner == 0, 'Winner is already picked');\n    require(2 > 0);\n    assert(2);\n    require(2 > 0);\n    assert(2);\n    require((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1) >= block.blockhash(block.number - 1) >> 1);\n    require(_numEntrants != 0);\n    assert(_numEntrants);\n    assert(((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1)) % _numEntrants < _entrants.length);\n    _winner = address(_entrants[((block.blockhash(block.number - 1) >> 1) + (address(block.coinbase) >> 1)) % _numEntrants]);\n    require(_percentageTaken > 0);\n    assert(stor_8_0_0);\n    v0 = _winner.call().value((address(this)).balance / _percentageTaken).gas(!((address(this)).balance / _percentageTaken) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Winner(_winner, (address(this)).balance / _percentageTaken);\n}\n\nfunction threshold() public nonPayable { \n    return _threshold;\n}\n\nfunction numEntrants() public nonPayable { \n    return _numEntrants;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction winner() public nonPayable { \n    return _winner;\n}\n\nfunction entrants(uint256 varg0) public nonPayable { \n    assert(varg0 < _entrants.length);\n    return address(_entrants[varg0]);\n}\n\nfunction entryPrice() public nonPayable { \n    return _entryPrice;\n}\n\nfunction 0x35b() private { \n    require(block.timestamp <= _deadline, 'Deadline is Passed');\n    require(msg.value == _entryPrice);\n    require(_balances[msg.sender] + msg.value >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    require(_numEntrants + 1 >= _numEntrants);\n    _numEntrants = _numEntrants + 1;\n    _entrants.length = _entrants.length + 1;\n    _entrants[_entrants.length + 1 - 1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _entrants[_entrants.length + 1 - 1];\n    emit PlayerEntered(msg.sender, msg.value, _numEntrants);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x35b();\n}\n\nfunction withdrawFunds(uint256 varg0) public nonPayable { \n    require(block.timestamp >= _deadline, 'Deadline is not Passed');\n    require(_numEntrants <= _threshold, 'Above Thresold participant');\n    require(_balances[msg.sender] >= varg0, 'You do not have enough balance');\n    require(varg0 <= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction percentageTaken() public nonPayable { \n    return _percentageTaken;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x155dd5ee == function_selector) {\n            withdrawFunds(uint256);\n        } else if (0x2049eff6 == function_selector) {\n            percentageTaken();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x2cfcc539 == function_selector) {\n            enterRaffle();\n        } else if (0x33b16d93 == function_selector) {\n            determineWinner();\n        } else if (0x42cde4e8 == function_selector) {\n            threshold();\n        } else if (0x4efe0a60 == function_selector) {\n            numEntrants();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xdfbf53ae == function_selector) {\n            winner();\n        } else if (0xe7b4e5ab == function_selector) {\n            entrants(uint256);\n        } else if (0xf745adfc == function_selector) {\n            entryPrice();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 46.80502247810364,
	"usage": {
		"completion_tokens": 703,
		"prompt_tokens": 1453,
		"total_tokens": 2156
	}
}