{
	"address": "0x57897ebbdf3b510ab1faca9a5e9348f837bbcb45",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "In Solidity, the given decompiled code can be represented as follows:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract MyContract {\n    mapping(uint256 => uint256) private _balanceOf;\n    mapping(uint256 => mapping(uint256 => uint256)) private _increaseAllowance;\n    uint256 private _totalSupply;\n    uint256[] private _name_471;\n    uint256[] private _symbol_481;\n    uint256 private _maxTransactionAmount;\n    uint256 private _swapTokensAtAmount;\n    uint256 private _maxWallet;\n    uint256 private _percentForLPBurn;\n    uint256 private _lpBurnFrequency;\n    uint256 private _lastLpBurnTime;\n    uint256 private _manualBurnFrequency;\n    uint256 private _lastManualLpBurnTime;\n    mapping(uint256 => uint256) private owner_12;\n    uint256 private _buyTotalFees;\n    uint256 private _buyMarketingFee;\n    uint256 private _buyLiquidityFee;\n    uint256 private _buyDevFee;\n    uint256 private _sellTotalFees;\n    uint256 private _sellMarketingFee;\n    uint256 private _sellLiquidityFee;\n    uint256 private _sellDevFee;\n    uint256 private _tokensForMarketing;\n    uint256 private _tokensForLiquidity;\n    uint256 private _tokensForDev;\n    mapping(uint256 => uint256) private _isExcludedFromFees;\n    mapping(uint256 => uint256) private __isExcludedMaxTransactionAmount;\n    mapping(uint256 => uint256) private _automatedMarketMakerPairs;\n    uint256 private _lpBurnEnabled;\n    uint256 private _limitsInEffect;\n    uint256 private _tradingActive;\n    uint256 private stor_11_1_2;\n    uint256 private _swapEnabled;\n    uint256 private _transferDelayEnabled;\n    address private _owner;\n    address private _marketingWallet;\n    address private _devWallet;\n    uint256 private stor_5_20_20;\n\n    event devWalletUpdated(address indexed newDevWallet, address indexed oldDevWallet);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event marketingWalletUpdated(address indexed newMarketingWallet, address indexed oldMarketingWallet);\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event ManualNukeLP();\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiq);\n    event AutoNukeLP();\n\n    // Rest of the contract code goes here, including function declarations, etc.\n}\n```\nPlease note that this is a simplified version of the contract based on the given decompiled code and the actual functionality of the functions is not represented in the code above. The function bodies need to be implemented according to the logic represented in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495659,
	"id": "chatcmpl-8VPBLVZ94SvuleYt2SzLGTk0jYAjU",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.20 01:26 UTC\n// Compiled using the solidity compiler version 0.8.9\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _increaseAllowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_471; // STORAGE[0x3]\nuint256[] _@symbol_481; // STORAGE[0x4]\nuint256 _maxTransactionAmount; // STORAGE[0x8]\nuint256 _swapTokensAtAmount; // STORAGE[0x9]\nuint256 _maxWallet; // STORAGE[0xa]\nuint256 _percentForLPBurn; // STORAGE[0xb]\nuint256 _lpBurnFrequency; // STORAGE[0xd]\nuint256 _lastLpBurnTime; // STORAGE[0xe]\nuint256 _manualBurnFrequency; // STORAGE[0xf]\nuint256 _lastManualLpBurnTime; // STORAGE[0x10]\nmapping (uint256 => uint256) owner_12; // STORAGE[0x12]\nuint256 _buyTotalFees; // STORAGE[0x14]\nuint256 _buyMarketingFee; // STORAGE[0x15]\nuint256 _buyLiquidityFee; // STORAGE[0x16]\nuint256 _buyDevFee; // STORAGE[0x17]\nuint256 _sellTotalFees; // STORAGE[0x18]\nuint256 _sellMarketingFee; // STORAGE[0x19]\nuint256 _sellLiquidityFee; // STORAGE[0x1a]\nuint256 _sellDevFee; // STORAGE[0x1b]\nuint256 _tokensForMarketing; // STORAGE[0x1c]\nuint256 _tokensForLiquidity; // STORAGE[0x1d]\nuint256 _tokensForDev; // STORAGE[0x1e]\nmapping (uint256 => uint256) _isExcludedFromFees; // STORAGE[0x1f]\nmapping (uint256 => uint256) __isExcludedMaxTransactionAmount; // STORAGE[0x20]\nmapping (uint256 => uint256) _automatedMarketMakerPairs; // STORAGE[0x21]\nuint256 _lpBurnEnabled; // STORAGE[0xc] bytes 0 to 0\nuint256 _limitsInEffect; // STORAGE[0x11] bytes 0 to 0\nuint256 _tradingActive; // STORAGE[0x11] bytes 1 to 1\nuint256 stor_11_1_2; // STORAGE[0x11] bytes 1 to 2\nuint256 _swapEnabled; // STORAGE[0x11] bytes 2 to 2\nuint256 _transferDelayEnabled; // STORAGE[0x13] bytes 0 to 0\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _marketingWallet; // STORAGE[0x6] bytes 0 to 19\nuint256 _devWallet; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_5_20_20; // STORAGE[0x5] bytes 20 to 20\n\n\n// Events\ndevWalletUpdated(address, address);\nOwnershipTransferred(address, address);\nmarketingWalletUpdated(address, address);\nExcludeFromFees(address, bool);\nManualNukeLP();\nApproval(address, address, uint256);\nSetAutomatedMarketMakerPair(address, bool);\nTransfer(address, address, uint256);\nSwapAndLiquify(uint256, uint256, uint256);\nAutoNukeLP();\n\nfunction @symbol_481() private { \n    v0 = v1 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(_@symbol_481.length & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require(_@symbol_481.length & 0x1 != v6 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_481.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_481.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction @_approve_892(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _increaseAllowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2968(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    if (varg0) {\n        if (_limitsInEffect) {\n            v0 = v1 = _owner != address(varg2);\n            if (_owner != address(varg2)) {\n                v0 = v2 = _owner != address(varg1);\n            }\n            if (v0) {\n                v0 = v3 = bool(address(varg1));\n            }\n            if (v0) {\n                v0 = v4 = 57005 != address(varg1);\n            }\n            if (v0) {\n                v0 = v5 = !stor_5_20_20;\n            }\n            if (v0) {\n                if (!_tradingActive) {\n                    v6 = v7 = uint8(_isExcludedFromFees[address(varg2)]);\n                    if (!v7) {\n                        v6 = v8 = uint8(_isExcludedFromFees[address(varg1)]);\n                    }\n                    require(v6, Error('Trading is not active.'));\n                }\n                if (_transferDelayEnabled) {\n                    v9 = v10 = _owner != address(varg1);\n                    if (_owner != address(varg1)) {\n                        v9 = v11 = address(varg1) != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n                    }\n                    if (v9) {\n                        v9 = v12 = address(varg1) != address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n                    }\n                    if (v9) {\n                        require(block.number > owner_12[tx.origin], Error('_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.'));\n                        owner_12[tx.origin] = block.number;\n                    }\n                }\n                v13 = v14 = uint8(_automatedMarketMakerPairs[address(varg2)]);\n                if (v14) {\n                    v13 = v15 = !uint8(__isExcludedMaxTransactionAmount[address(varg1)]);\n                }\n                if (!v13) {\n                    v16 = v17 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n                    if (v17) {\n                        v16 = v18 = !uint8(__isExcludedMaxTransactionAmount[address(varg2)]);\n                    }\n                    if (!v16) {\n                        if (!uint8(__isExcludedMaxTransactionAmount[address(varg1)])) {\n                            require(varg0 <= ~_balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                            require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                        }\n                    } else {\n                        require(varg0 <= _maxTransactionAmount, Error('Sell transfer amount exceeds the maxTransactionAmount.'));\n                    }\n                } else {\n                    require(varg0 <= _maxTransactionAmount, Error('Buy transfer amount exceeds the maxTransactionAmount.'));\n                    require(varg0 <= ~_balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                    require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                }\n            }\n        }\n        v19 = v20 = _balanceOf[this] >= _swapTokensAtAmount;\n        if (_balanceOf[this] >= _swapTokensAtAmount) {\n            v19 = v21 = _swapEnabled;\n        }\n        if (v19) {\n            v19 = v22 = !stor_5_20_20;\n        }\n        if (v19) {\n            v19 = v23 = !uint8(_automatedMarketMakerPairs[address(varg2)]);\n        }\n        if (v19) {\n            v19 = v24 = !uint8(_isExcludedFromFees[address(varg2)]);\n        }\n        if (v19) {\n            v19 = v25 = !uint8(_isExcludedFromFees[address(varg1)]);\n        }\n        if (v19) {\n            stor_5_20_20 = 1;\n            v26 = v27 = _balanceOf[this];\n            require(_tokensForLiquidity <= ~_tokensForMarketing, Panic(17)); // arithmetic overflow or underflow\n            require(_tokensForLiquidity + _tokensForMarketing <= ~_tokensForDev, Panic(17)); // arithmetic overflow or underflow\n            v28 = v29 = !v27;\n            if (v27) {\n                v28 = !(_tokensForLiquidity + _tokensForMarketing + _tokensForDev);\n            }\n            if (!v28) {\n                require(!(bool(20) & (_swapTokensAtAmount > 0xccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)), Panic(17)); // arithmetic overflow or underflow\n                if (v27 > 20 * _swapTokensAtAmount) {\n                    require(!(bool(20) & (_swapTokensAtAmount > 0xccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)), Panic(17)); // arithmetic overflow or underflow\n                    v26 = 20 * _swapTokensAtAmount;\n                }\n                require(!(bool(v26) & (_tokensForLiquidity > ~0 / v26)), Panic(17)); // arithmetic overflow or underflow\n                require(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(18)); // division by zero\n                require(2, Panic(18)); // division by zero\n                v30 = v26 * _tokensForLiquidity / (_tokensForLiquidity + _tokensForMarketing + _tokensForDev) >> 1;\n                v31 = _SafeSub('SafeMath: subtraction overflow', v30, v26);\n                v32 = new address[](2);\n                CALLDATACOPY(v32.data, msg.data.length, 64);\n                require(0 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v33 = v32.data;\n                v32[0] = address(this);\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v34, /* address */ v35 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH().gas(msg.gas);\n                require(bool(v34), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                require(v35 == address(v35));\n                require(1 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v32[1] = address(v35);\n                @_approve_892(v31, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                v36 = new address[](v32.length);\n                v37 = v38 = v36.data;\n                v39 = v40 = v32.data;\n                v41 = v42 = 0;\n                while (v41 < v32.length) {\n                    MEM[v37] = address(MEM[v39]);\n                    v39 += 32;\n                    v37 += 32;\n                    v41 += 1;\n                }\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v43 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).swapExactTokensForETHSupportingFeeOnTransferTokens(v31, 0, v36, address(this), block.timestamp, v44, address(this)).gas(msg.gas);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v45 = _SafeSub('SafeMath: subtraction overflow', this.balance, this.balance);\n                v46 = _SafeMul(_tokensForMarketing, v45);\n                v47 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v46);\n                v48 = _SafeMul(_tokensForDev, v45);\n                v49 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v48);\n                require(v45 >= v47, Panic(17)); // arithmetic overflow or underflow\n                require(v45 - v47 >= v49, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = 0;\n                _tokensForMarketing = 0;\n                _tokensForDev = 0;\n                v50, /* uint256 */ v51 = _devWallet.call().value(v49).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v52 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v52.data, 0, RETURNDATASIZE());\n                }\n                v53 = v54 = bool(v30);\n                if (v30) {\n                    v53 = v45 - v47 - v49 > 0;\n                }\n                if (v53) {\n                    @_approve_892(v30, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                    require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                    v55, /* uint256 */ v56, /* uint256 */ v57, /* uint256 */ v58 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).addLiquidityETH(this, v30, 0, 0, 57005, block.timestamp).value(v45 - v47 - v49).gas(msg.gas);\n                    require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    emit SwapAndLiquify(v31, v45 - v47 - v49, _tokensForLiquidity);\n                }\n                v59, /* uint256 */ v60 = _marketingWallet.call().value(this.balance).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v61 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v61.data, 0, RETURNDATASIZE());\n                }\n                // Unknown jump to Block 0x218f. Refer to 3-address code (TAC);\n            }\n            stor_5_20_20 = 0;\n        }\n        v62 = v63 = !stor_5_20_20;\n        if (!stor_5_20_20) {\n            v62 = v64 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n        }\n        if (v62) {\n            v62 = v65 = _lpBurnEnabled;\n        }\n        if (v62) {\n            require(_lastLpBurnTime <= ~_lpBurnFrequency, Panic(17)); // arithmetic overflow or underflow\n            v62 = v66 = block.timestamp >= _lastLpBurnTime + _lpBurnFrequency;\n        }\n        if (v62) {\n            v62 = v67 = !uint8(_isExcludedFromFees[address(varg2)]);\n        }\n        if (v62) {\n            _lastLpBurnTime = block.timestamp;\n            require(bool(this.code.size));\n            v68, /* uint256 */ v69 = this.balanceOf(address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).gas(msg.gas);\n            require(bool(v68), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            v70 = _SafeMul(_percentForLPBurn, v69);\n            v71 = _SafeDiv(10000, v70);\n            if (v71) {\n                @_transfer_736(v71, 57005, 0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n            }\n            require(bool((address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).code.size));\n            v72 = address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f).sync().gas(msg.gas);\n            require(bool(v72), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            emit AutoNukeLP();\n        }\n        v73 = v74 = !stor_5_20_20;\n        v75 = v76 = uint8(_isExcludedFromFees[address(varg2)]);\n        if (!v76) {\n            v75 = v77 = uint8(_isExcludedFromFees[address(varg1)]);\n        }\n        if (v75) {\n            v73 = v78 = 0;\n        }\n        v79 = v80 = 0;\n        if (v73) {\n            v81 = v82 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n            if (v82) {\n                v81 = v83 = _sellTotalFees > 0;\n            }\n            if (!v81) {\n                v84 = v85 = uint8(_automatedMarketMakerPairs[address(varg2)]);\n                if (v85) {\n                    v84 = v86 = _buyTotalFees > 0;\n                }\n                if (v84) {\n                    v87 = _SafeMul(_buyTotalFees, varg0);\n                    v79 = v88 = _SafeDiv(100, v87);\n                    require(!(bool(v88) & (_buyLiquidityFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForLiquidity <= ~(v88 * _buyLiquidityFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForLiquidity = _tokensForLiquidity + v88 * _buyLiquidityFee / _buyTotalFees;\n                    require(!(bool(v88) & (_buyDevFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForDev <= ~(v88 * _buyDevFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForDev = _tokensForDev + v88 * _buyDevFee / _buyTotalFees;\n                    require(!(bool(v88) & (_buyMarketingFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForMarketing <= ~(v88 * _buyMarketingFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForMarketing = _tokensForMarketing + v88 * _buyMarketingFee / _buyTotalFees;\n                }\n            } else {\n                v89 = _SafeMul(_sellTotalFees, varg0);\n                v79 = v90 = _SafeDiv(100, v89);\n                require(!(bool(v90) & (_sellLiquidityFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForLiquidity <= ~(v90 * _sellLiquidityFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = _tokensForLiquidity + v90 * _sellLiquidityFee / _sellTotalFees;\n                require(!(bool(v90) & (_sellDevFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForDev <= ~(v90 * _sellDevFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForDev = _tokensForDev + v90 * _sellDevFee / _sellTotalFees;\n                require(!(bool(v90) & (_sellMarketingFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForMarketing <= ~(v90 * _sellMarketingFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForMarketing = _tokensForMarketing + v90 * _sellMarketingFee / _sellTotalFees;\n            }\n            if (v79) {\n                @_transfer_736(v79, this, varg2);\n            }\n            require(varg0 >= v79, Panic(17)); // arithmetic overflow or underflow\n            varg0 = v91 = varg0 - v79;\n        }\n        @_transfer_736(varg0, varg1, varg2);\n        return ;\n    } else {\n        @_transfer_736(0, varg1, varg2);\n        return ;\n    }\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 >= varg1, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        require(!(bool(varg1) & (varg0 > ~0 / varg1)), Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(varg1 * varg0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n        return varg1 * varg0;\n    } else {\n        return 0;\n    }\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        if (v2 > v1.length) {\n            v0[v1.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction @_transfer_736(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_471();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_892(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _isExcludedMaxTransactionAmount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isExcludedMaxTransactionAmount[varg0]));\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n}\n\nfunction () public payable { \n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction updateDevWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit devWalletUpdated(varg0, _devWallet);\n    _devWallet = varg0;\n}\n\nfunction manualBurnFrequency() public nonPayable { \n    return _manualBurnFrequency;\n}\n\nfunction percentForLPBurn() public nonPayable { \n    return _percentForLPBurn;\n}\n\nfunction tokensForLiquidity() public nonPayable { \n    return _tokensForLiquidity;\n}\n\nfunction tokensForMarketing() public nonPayable { \n    return _tokensForMarketing;\n}\n\nfunction updateMaxTxnAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(1) & (_totalSupply > uint256.max)), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxTransactionAmount lower than 0.1%'));\n    require(!(bool(0xde0b6b3a7640000) & (varg0 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21)), Panic(17)); // arithmetic overflow or underflow\n    _maxTransactionAmount = 0xde0b6b3a7640000 * varg0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_2968(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _increaseAllowance[varg0][msg.sender]);\n    @_approve_892(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction updateTSESellFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _sellMarketingFee = varg0;\n    _sellLiquidityFee = varg1;\n    _sellDevFee = varg2;\n    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow\n    require(varg0 + varg1 <= ~varg2, Panic(17)); // arithmetic overflow or underflow\n    _sellTotalFees = varg0 + varg1 + varg2;\n    require(99 >= varg0 + varg1 + varg2, Error('Must keep fees at 99% or less'));\n}\n\nfunction deadAddress() public nonPayable { \n    return address(0xdead);\n}\n\nfunction lpBurnFrequency() public nonPayable { \n    return _lpBurnFrequency;\n}\n\nfunction lpBurnEnabled() public nonPayable { \n    return _lpBurnEnabled;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeAdd(varg1, _increaseAllowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateTSEBuyFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _buyMarketingFee = varg0;\n    _buyLiquidityFee = varg1;\n    _buyDevFee = varg2;\n    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow\n    require(varg0 + varg1 <= ~varg2, Panic(17)); // arithmetic overflow or underflow\n    _buyTotalFees = varg0 + varg1 + varg2;\n    require(25 >= varg0 + varg1 + varg2, Error('Must keep fees at 25% or less'));\n}\n\nfunction renounceTSEOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n}\n\nfunction limitsInEffect() public nonPayable { \n    return _limitsInEffect;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isExcludedFromFees[address(varg0)]));\n}\n\nfunction sellTotalFees() public nonPayable { \n    return _sellTotalFees;\n}\n\nfunction swapEnabled() public nonPayable { \n    return _swapEnabled;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction setAutoLPBurnSettings(uint256 varg0, uint256 varg1, bool varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 == varg2);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 >= 600, Error('cannot set buyback more often than every 10 minutes'));\n    v0 = v1 = varg1 <= 1000;\n    if (!bool(varg1 > 1000)) {\n        v0 = v2 = 1;\n    }\n    require(v0, Error('Must set auto LP burn percent between 0% and 10%'));\n    _lpBurnFrequency = varg0;\n    _percentForLPBurn = varg1;\n    _lpBurnEnabled = varg2;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _limitsInEffect = 0;\n    return bool(1);\n}\n\nfunction excludeFromMaxTransaction(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedMaxTransactionAmount[varg0] = varg1 | bytes31(__isExcludedMaxTransactionAmount[address(varg0)]);\n}\n\nfunction marketingWallet() public nonPayable { \n    return _marketingWallet;\n}\n\nfunction buyMarketingFee() public nonPayable { \n    return _buyMarketingFee;\n}\n\nfunction enableTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_11_1_2 = 257;\n    _lastLpBurnTime = block.timestamp;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction devWallet() public nonPayable { \n    return _devWallet;\n}\n\nfunction sellMarketingFee() public nonPayable { \n    return _sellMarketingFee;\n}\n\nfunction updateSwapEnabled(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _swapEnabled = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_481();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction setAutomatedMarketMakerPair(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 != address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f), Error('The pair cannot be removed from automatedMarketMakerPairs'));\n    _automatedMarketMakerPairs[varg0] = varg1 | bytes31(_automatedMarketMakerPairs[address(varg0)]);\n    emit SetAutomatedMarketMakerPair(varg0, varg1);\n}\n\nfunction buyDevFee() public nonPayable { \n    return _buyDevFee;\n}\n\nfunction lastManualLpBurnTime() public nonPayable { \n    return _lastManualLpBurnTime;\n}\n\nfunction tokensForDev() public nonPayable { \n    return _tokensForDev;\n}\n\nfunction sellDevFee() public nonPayable { \n    return _sellDevFee;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _increaseAllowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction lastLpBurnTime() public nonPayable { \n    return _lastLpBurnTime;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_2968(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateMarketingWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit marketingWalletUpdated(varg0, _marketingWallet);\n    _marketingWallet = varg0;\n}\n\nfunction automatedMarketMakerPairs(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_automatedMarketMakerPairs[varg0]));\n}\n\nfunction tradingActive() public nonPayable { \n    return _tradingActive;\n}\n\nfunction excludeFromFees(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _isExcludedFromFees[varg0] = varg1 | bytes31(_isExcludedFromFees[address(varg0)]);\n    emit ExcludeFromFees(varg0, varg1);\n}\n\nfunction updateMaxWalletAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(5) & (_totalSupply > '33333333333333333333333333333333')), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= 5 * _totalSupply / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxWallet lower than 0.5%', 'Cannot set maxWallet lower than 0.5%'));\n    require(!(bool(0xde0b6b3a7640000) & (varg0 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21)), Panic(17)); // arithmetic overflow or underflow\n    _maxWallet = 0xde0b6b3a7640000 * varg0;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction maxTransactionAmount() public nonPayable { \n    return _maxTransactionAmount;\n}\n\nfunction updateSwapTokensAtAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(1) & (_totalSupply > uint256.max)), Panic(17)); // arithmetic overflow or underflow\n    require(0x186a0, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 0x186a0, Error('Swap amount cannot be lower than 0.001% total supply.'));\n    require(!(bool(10) & (_totalSupply > 0x1999999999999999999999999999999999999999999999999999999999999999)), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(varg0 <= 10 * _totalSupply / 1000, Error('Swap amount cannot be higher than 1% total supply.'));\n    _swapTokensAtAmount = varg0;\n    return bool(1);\n}\n\nfunction buyTotalFees() public nonPayable { \n    return _buyTotalFees;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _increaseAllowance[varg0][varg1];\n}\n\nfunction swapTokensAtAmount() public nonPayable { \n    return _swapTokensAtAmount;\n}\n\nfunction disableTransferDelay() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _transferDelayEnabled = 0;\n    return bool(1);\n}\n\nfunction buyLiquidityFee() public nonPayable { \n    return _buyLiquidityFee;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction sellLiquidityFee() public nonPayable { \n    return _sellLiquidityFee;\n}\n\nfunction maxWallet() public nonPayable { \n    return _maxWallet;\n}\n\nfunction manualBurnLiquidityPairTokens(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(_lastManualLpBurnTime <= ~_manualBurnFrequency, Panic(17)); // arithmetic overflow or underflow\n    require(block.timestamp > _lastManualLpBurnTime + _manualBurnFrequency, Error('Must wait for cooldown to finish'));\n    require(varg0 <= 1000, Error('May not nuke more than 10% of tokens in LP'));\n    _lastManualLpBurnTime = block.timestamp;\n    require(bool(this.code.size));\n    v0, /* uint256 */ v1 = this.balanceOf(address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v2 = _SafeMul(varg0, v1);\n    v3 = _SafeDiv(10000, v2);\n    if (v3) {\n        @_transfer_736(v3, 57005, 0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n    }\n    require(bool((address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).code.size));\n    v4 = address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f).sync().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    emit ManualNukeLP();\n    return bool(1);\n}\n\nfunction @name_471() private { \n    v0 = v1 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(_@name_471.length & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require(_@name_471.length & 0x1 != v6 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_471.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_471.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8a8c523c > v0) {\n            if (0x2e82f1a0 > v0) {\n                if (0x199ffc72 > v0) {\n                    if (0x1694505e > v0) {\n                        if (0x6fdde03 == v0) {\n                            name();\n                        } else if (0x95ea7b3 == v0) {\n                            approve(address,uint256);\n                        } else {\n                            require(0x10d5de53 == v0);\n                            _isExcludedMaxTransactionAmount(address);\n                        }\n                    } else if (0x1694505e == v0) {\n                        uniswapV2Router();\n                    } else if (0x18160ddd == v0) {\n                        totalSupply();\n                    } else if (0x1816467f == v0) {\n                        updateDevWallet(address);\n                    } else {\n                        require(0x184c16c5 == v0);\n                        manualBurnFrequency();\n                    }\n                } else if (0x23b872dd > v0) {\n                    if (0x199ffc72 == v0) {\n                        percentForLPBurn();\n                    } else if (0x1a8145bb == v0) {\n                        tokensForLiquidity();\n                    } else if (0x1f3fed8f == v0) {\n                        tokensForMarketing();\n                    } else {\n                        require(0x203e727e == v0);\n                        updateMaxTxnAmount(uint256);\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x265d2626 == v0) {\n                    updateTSESellFees(uint256,uint256,uint256);\n                } else if (0x27c8f835 == v0) {\n                    deadAddress();\n                } else {\n                    require(0x2c3e486c == v0);\n                    lpBurnFrequency();\n                }\n            } else if (0x6a486a8e > v0) {\n                if (0x443a3b21 > v0) {\n                    if (0x2e82f1a0 == v0) {\n                        lpBurnEnabled();\n                    } else if (0x313ce567 == v0) {\n                        decimals();\n                    } else if (0x39509351 == v0) {\n                        increaseAllowance(address,uint256);\n                    } else {\n                        require(0x39520fcf == v0);\n                        updateTSEBuyFees(uint256,uint256,uint256);\n                    }\n                } else if (0x443a3b21 == v0) {\n                    renounceTSEOwnership();\n                } else if (0x49bd5a5e == v0) {\n                    uniswapV2Pair();\n                } else if (0x4a62bb65 == v0) {\n                    limitsInEffect();\n                } else {\n                    require(0x4fbee193 == v0);\n                    isExcludedFromFees(address);\n                }\n            } else if (0x751039fc > v0) {\n                if (0x6a486a8e == v0) {\n                    sellTotalFees();\n                } else if (0x6ddd1713 == v0) {\n                    swapEnabled();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else {\n                    require(0x730c1888 == v0);\n                    setAutoLPBurnSettings(uint256,uint256,bool);\n                }\n            } else if (0x751039fc == v0) {\n                removeLimits();\n            } else if (0x7571336a == v0) {\n                excludeFromMaxTransaction(address,bool);\n            } else if (0x75f0a874 == v0) {\n                marketingWallet();\n            } else {\n                require(0x7bce5a04 == v0);\n                buyMarketingFee();\n            }\n        } else if (0xb62496f5 > v0) {\n            if (0x9c3b4fdc > v0) {\n                if (0x92136913 > v0) {\n                    if (0x8a8c523c == v0) {\n                        enableTrading();\n                    } else if (0x8da5cb5b == v0) {\n                        owner();\n                    } else {\n                        require(0x8ea5220f == v0);\n                        devWallet();\n                    }\n                } else if (0x92136913 == v0) {\n                    sellMarketingFee();\n                } else if (0x924de9b7 == v0) {\n                    updateSwapEnabled(bool);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else {\n                    require(0x9a7a23d6 == v0);\n                    setAutomatedMarketMakerPair(address,bool);\n                }\n            } else if (0xa457c2d7 > v0) {\n                if (0x9c3b4fdc == v0) {\n                    buyDevFee();\n                } else if (0x9ec22c0e == v0) {\n                    lastManualLpBurnTime();\n                } else if (0x9fccce32 == v0) {\n                    tokensForDev();\n                } else {\n                    require(0xa0d82dc5 == v0);\n                    sellDevFee();\n                }\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa4c82a00 == v0) {\n                lastLpBurnTime();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else {\n                require(0xaacebbe3 == v0);\n                updateMarketingWallet(address);\n            }\n        } else if (0xdd62ed3e > v0) {\n            if (0xc876d0b9 > v0) {\n                if (0xb62496f5 == v0) {\n                    automatedMarketMakerPairs(address);\n                } else if (0xbbc0c742 == v0) {\n                    tradingActive();\n                } else if (0xc0246668 == v0) {\n                    excludeFromFees(address,bool);\n                } else {\n                    require(0xc18bc195 == v0);\n                    updateMaxWalletAmount(uint256);\n                }\n            } else if (0xc876d0b9 == v0) {\n                transferDelayEnabled();\n            } else if (0xc8c8ebe4 == v0) {\n                maxTransactionAmount();\n            } else if (0xd257b34f == v0) {\n                updateSwapTokensAtAmount(uint256);\n            } else {\n                require(0xd85ba063 == v0);\n                buyTotalFees();\n            }\n        } else if (0xf2fde38b > v0) {\n            if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe2f45605 == v0) {\n                swapTokensAtAmount();\n            } else if (0xe884f260 == v0) {\n                disableTransferDelay();\n            } else {\n                require(0xf11a24d3 == v0);\n                buyLiquidityFee();\n            }\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf6374342 == v0) {\n            sellLiquidityFee();\n        } else if (0xf8b45b05 == v0) {\n            maxWallet();\n        } else {\n            require(0xfe72b27a == v0);\n            manualBurnLiquidityPairTokens(uint256);\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 01:26 UTC\n// Compiled using the solidity compiler version 0.8.9\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _increaseAllowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_471; // STORAGE[0x3]\nuint256[] _@symbol_481; // STORAGE[0x4]\nuint256 _maxTransactionAmount; // STORAGE[0x8]\nuint256 _swapTokensAtAmount; // STORAGE[0x9]\nuint256 _maxWallet; // STORAGE[0xa]\nuint256 _percentForLPBurn; // STORAGE[0xb]\nuint256 _lpBurnFrequency; // STORAGE[0xd]\nuint256 _lastLpBurnTime; // STORAGE[0xe]\nuint256 _manualBurnFrequency; // STORAGE[0xf]\nuint256 _lastManualLpBurnTime; // STORAGE[0x10]\nmapping (uint256 => uint256) owner_12; // STORAGE[0x12]\nuint256 _buyTotalFees; // STORAGE[0x14]\nuint256 _buyMarketingFee; // STORAGE[0x15]\nuint256 _buyLiquidityFee; // STORAGE[0x16]\nuint256 _buyDevFee; // STORAGE[0x17]\nuint256 _sellTotalFees; // STORAGE[0x18]\nuint256 _sellMarketingFee; // STORAGE[0x19]\nuint256 _sellLiquidityFee; // STORAGE[0x1a]\nuint256 _sellDevFee; // STORAGE[0x1b]\nuint256 _tokensForMarketing; // STORAGE[0x1c]\nuint256 _tokensForLiquidity; // STORAGE[0x1d]\nuint256 _tokensForDev; // STORAGE[0x1e]\nmapping (uint256 => uint256) _isExcludedFromFees; // STORAGE[0x1f]\nmapping (uint256 => uint256) __isExcludedMaxTransactionAmount; // STORAGE[0x20]\nmapping (uint256 => uint256) _automatedMarketMakerPairs; // STORAGE[0x21]\nuint256 _lpBurnEnabled; // STORAGE[0xc] bytes 0 to 0\nuint256 _limitsInEffect; // STORAGE[0x11] bytes 0 to 0\nuint256 _tradingActive; // STORAGE[0x11] bytes 1 to 1\nuint256 stor_11_1_2; // STORAGE[0x11] bytes 1 to 2\nuint256 _swapEnabled; // STORAGE[0x11] bytes 2 to 2\nuint256 _transferDelayEnabled; // STORAGE[0x13] bytes 0 to 0\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _marketingWallet; // STORAGE[0x6] bytes 0 to 19\nuint256 _devWallet; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_5_20_20; // STORAGE[0x5] bytes 20 to 20\n\n\n// Events\ndevWalletUpdated(address, address);\nOwnershipTransferred(address, address);\nmarketingWalletUpdated(address, address);\nExcludeFromFees(address, bool);\nManualNukeLP();\nApproval(address, address, uint256);\nSetAutomatedMarketMakerPair(address, bool);\nTransfer(address, address, uint256);\nSwapAndLiquify(uint256, uint256, uint256);\nAutoNukeLP();\n\nfunction @symbol_481() private { \n    v0 = v1 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(_@symbol_481.length & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require(_@symbol_481.length & 0x1 != v6 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_481.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_481.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction @_approve_892(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _increaseAllowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2968(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    if (varg0) {\n        if (_limitsInEffect) {\n            v0 = v1 = _owner != address(varg2);\n            if (_owner != address(varg2)) {\n                v0 = v2 = _owner != address(varg1);\n            }\n            if (v0) {\n                v0 = v3 = bool(address(varg1));\n            }\n            if (v0) {\n                v0 = v4 = 57005 != address(varg1);\n            }\n            if (v0) {\n                v0 = v5 = !stor_5_20_20;\n            }\n            if (v0) {\n                if (!_tradingActive) {\n                    v6 = v7 = uint8(_isExcludedFromFees[address(varg2)]);\n                    if (!v7) {\n                        v6 = v8 = uint8(_isExcludedFromFees[address(varg1)]);\n                    }\n                    require(v6, Error('Trading is not active.'));\n                }\n                if (_transferDelayEnabled) {\n                    v9 = v10 = _owner != address(varg1);\n                    if (_owner != address(varg1)) {\n                        v9 = v11 = address(varg1) != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n                    }\n                    if (v9) {\n                        v9 = v12 = address(varg1) != address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n                    }\n                    if (v9) {\n                        require(block.number > owner_12[tx.origin], Error('_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.'));\n                        owner_12[tx.origin] = block.number;\n                    }\n                }\n                v13 = v14 = uint8(_automatedMarketMakerPairs[address(varg2)]);\n                if (v14) {\n                    v13 = v15 = !uint8(__isExcludedMaxTransactionAmount[address(varg1)]);\n                }\n                if (!v13) {\n                    v16 = v17 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n                    if (v17) {\n                        v16 = v18 = !uint8(__isExcludedMaxTransactionAmount[address(varg2)]);\n                    }\n                    if (!v16) {\n                        if (!uint8(__isExcludedMaxTransactionAmount[address(varg1)])) {\n                            require(varg0 <= ~_balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                            require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                        }\n                    } else {\n                        require(varg0 <= _maxTransactionAmount, Error('Sell transfer amount exceeds the maxTransactionAmount.'));\n                    }\n                } else {\n                    require(varg0 <= _maxTransactionAmount, Error('Buy transfer amount exceeds the maxTransactionAmount.'));\n                    require(varg0 <= ~_balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                    require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                }\n            }\n        }\n        v19 = v20 = _balanceOf[this] >= _swapTokensAtAmount;\n        if (_balanceOf[this] >= _swapTokensAtAmount) {\n            v19 = v21 = _swapEnabled;\n        }\n        if (v19) {\n            v19 = v22 = !stor_5_20_20;\n        }\n        if (v19) {\n            v19 = v23 = !uint8(_automatedMarketMakerPairs[address(varg2)]);\n        }\n        if (v19) {\n            v19 = v24 = !uint8(_isExcludedFromFees[address(varg2)]);\n        }\n        if (v19) {\n            v19 = v25 = !uint8(_isExcludedFromFees[address(varg1)]);\n        }\n        if (v19) {\n            stor_5_20_20 = 1;\n            v26 = v27 = _balanceOf[this];\n            require(_tokensForLiquidity <= ~_tokensForMarketing, Panic(17)); // arithmetic overflow or underflow\n            require(_tokensForLiquidity + _tokensForMarketing <= ~_tokensForDev, Panic(17)); // arithmetic overflow or underflow\n            v28 = v29 = !v27;\n            if (v27) {\n                v28 = !(_tokensForLiquidity + _tokensForMarketing + _tokensForDev);\n            }\n            if (!v28) {\n                require(!(bool(20) & (_swapTokensAtAmount > 0xccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)), Panic(17)); // arithmetic overflow or underflow\n                if (v27 > 20 * _swapTokensAtAmount) {\n                    require(!(bool(20) & (_swapTokensAtAmount > 0xccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)), Panic(17)); // arithmetic overflow or underflow\n                    v26 = 20 * _swapTokensAtAmount;\n                }\n                require(!(bool(v26) & (_tokensForLiquidity > ~0 / v26)), Panic(17)); // arithmetic overflow or underflow\n                require(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(18)); // division by zero\n                require(2, Panic(18)); // division by zero\n                v30 = v26 * _tokensForLiquidity / (_tokensForLiquidity + _tokensForMarketing + _tokensForDev) >> 1;\n                v31 = _SafeSub('SafeMath: subtraction overflow', v30, v26);\n                v32 = new address[](2);\n                CALLDATACOPY(v32.data, msg.data.length, 64);\n                require(0 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v33 = v32.data;\n                v32[0] = address(this);\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v34, /* address */ v35 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH().gas(msg.gas);\n                require(bool(v34), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                require(v35 == address(v35));\n                require(1 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v32[1] = address(v35);\n                @_approve_892(v31, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                v36 = new address[](v32.length);\n                v37 = v38 = v36.data;\n                v39 = v40 = v32.data;\n                v41 = v42 = 0;\n                while (v41 < v32.length) {\n                    MEM[v37] = address(MEM[v39]);\n                    v39 += 32;\n                    v37 += 32;\n                    v41 += 1;\n                }\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v43 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).swapExactTokensForETHSupportingFeeOnTransferTokens(v31, 0, v36, address(this), block.timestamp, v44, address(this)).gas(msg.gas);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v45 = _SafeSub('SafeMath: subtraction overflow', this.balance, this.balance);\n                v46 = _SafeMul(_tokensForMarketing, v45);\n                v47 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v46);\n                v48 = _SafeMul(_tokensForDev, v45);\n                v49 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v48);\n                require(v45 >= v47, Panic(17)); // arithmetic overflow or underflow\n                require(v45 - v47 >= v49, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = 0;\n                _tokensForMarketing = 0;\n                _tokensForDev = 0;\n                v50, /* uint256 */ v51 = _devWallet.call().value(v49).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v52 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v52.data, 0, RETURNDATASIZE());\n                }\n                v53 = v54 = bool(v30);\n                if (v30) {\n                    v53 = v45 - v47 - v49 > 0;\n                }\n                if (v53) {\n                    @_approve_892(v30, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                    require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                    v55, /* uint256 */ v56, /* uint256 */ v57, /* uint256 */ v58 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).addLiquidityETH(this, v30, 0, 0, 57005, block.timestamp).value(v45 - v47 - v49).gas(msg.gas);\n                    require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    emit SwapAndLiquify(v31, v45 - v47 - v49, _tokensForLiquidity);\n                }\n                v59, /* uint256 */ v60 = _marketingWallet.call().value(this.balance).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v61 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v61.data, 0, RETURNDATASIZE());\n                }\n                // Unknown jump to Block 0x218f. Refer to 3-address code (TAC);\n            }\n            stor_5_20_20 = 0;\n        }\n        v62 = v63 = !stor_5_20_20;\n        if (!stor_5_20_20) {\n            v62 = v64 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n        }\n        if (v62) {\n            v62 = v65 = _lpBurnEnabled;\n        }\n        if (v62) {\n            require(_lastLpBurnTime <= ~_lpBurnFrequency, Panic(17)); // arithmetic overflow or underflow\n            v62 = v66 = block.timestamp >= _lastLpBurnTime + _lpBurnFrequency;\n        }\n        if (v62) {\n            v62 = v67 = !uint8(_isExcludedFromFees[address(varg2)]);\n        }\n        if (v62) {\n            _lastLpBurnTime = block.timestamp;\n            require(bool(this.code.size));\n            v68, /* uint256 */ v69 = this.balanceOf(address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).gas(msg.gas);\n            require(bool(v68), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            v70 = _SafeMul(_percentForLPBurn, v69);\n            v71 = _SafeDiv(10000, v70);\n            if (v71) {\n                @_transfer_736(v71, 57005, 0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n            }\n            require(bool((address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).code.size));\n            v72 = address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f).sync().gas(msg.gas);\n            require(bool(v72), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            emit AutoNukeLP();\n        }\n        v73 = v74 = !stor_5_20_20;\n        v75 = v76 = uint8(_isExcludedFromFees[address(varg2)]);\n        if (!v76) {\n            v75 = v77 = uint8(_isExcludedFromFees[address(varg1)]);\n        }\n        if (v75) {\n            v73 = v78 = 0;\n        }\n        v79 = v80 = 0;\n        if (v73) {\n            v81 = v82 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n            if (v82) {\n                v81 = v83 = _sellTotalFees > 0;\n            }\n            if (!v81) {\n                v84 = v85 = uint8(_automatedMarketMakerPairs[address(varg2)]);\n                if (v85) {\n                    v84 = v86 = _buyTotalFees > 0;\n                }\n                if (v84) {\n                    v87 = _SafeMul(_buyTotalFees, varg0);\n                    v79 = v88 = _SafeDiv(100, v87);\n                    require(!(bool(v88) & (_buyLiquidityFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForLiquidity <= ~(v88 * _buyLiquidityFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForLiquidity = _tokensForLiquidity + v88 * _buyLiquidityFee / _buyTotalFees;\n                    require(!(bool(v88) & (_buyDevFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForDev <= ~(v88 * _buyDevFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForDev = _tokensForDev + v88 * _buyDevFee / _buyTotalFees;\n                    require(!(bool(v88) & (_buyMarketingFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForMarketing <= ~(v88 * _buyMarketingFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForMarketing = _tokensForMarketing + v88 * _buyMarketingFee / _buyTotalFees;\n                }\n            } else {\n                v89 = _SafeMul(_sellTotalFees, varg0);\n                v79 = v90 = _SafeDiv(100, v89);\n                require(!(bool(v90) & (_sellLiquidityFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForLiquidity <= ~(v90 * _sellLiquidityFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = _tokensForLiquidity + v90 * _sellLiquidityFee / _sellTotalFees;\n                require(!(bool(v90) & (_sellDevFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForDev <= ~(v90 * _sellDevFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForDev = _tokensForDev + v90 * _sellDevFee / _sellTotalFees;\n                require(!(bool(v90) & (_sellMarketingFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForMarketing <= ~(v90 * _sellMarketingFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForMarketing = _tokensForMarketing + v90 * _sellMarketingFee / _sellTotalFees;\n            }\n            if (v79) {\n                @_transfer_736(v79, this, varg2);\n            }\n            require(varg0 >= v79, Panic(17)); // arithmetic overflow or underflow\n            varg0 = v91 = varg0 - v79;\n        }\n        @_transfer_736(varg0, varg1, varg2);\n        return ;\n    } else {\n        @_transfer_736(0, varg1, varg2);\n        return ;\n    }\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 >= varg1, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        require(!(bool(varg1) & (varg0 > ~0 / varg1)), Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(varg1 * varg0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n        return varg1 * varg0;\n    } else {\n        return 0;\n    }\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        if (v2 > v1.length) {\n            v0[v1.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction @_transfer_736(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_471();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_892(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _isExcludedMaxTransactionAmount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isExcludedMaxTransactionAmount[varg0]));\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n}\n\nfunction () public payable { \n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction updateDevWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit devWalletUpdated(varg0, _devWallet);\n    _devWallet = varg0;\n}\n\nfunction manualBurnFrequency() public nonPayable { \n    return _manualBurnFrequency;\n}\n\nfunction percentForLPBurn() public nonPayable { \n    return _percentForLPBurn;\n}\n\nfunction tokensForLiquidity() public nonPayable { \n    return _tokensForLiquidity;\n}\n\nfunction tokensForMarketing() public nonPayable { \n    return _tokensForMarketing;\n}\n\nfunction updateMaxTxnAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(1) & (_totalSupply > uint256.max)), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxTransactionAmount lower than 0.1%'));\n    require(!(bool(0xde0b6b3a7640000) & (varg0 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21)), Panic(17)); // arithmetic overflow or underflow\n    _maxTransactionAmount = 0xde0b6b3a7640000 * varg0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_2968(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _increaseAllowance[varg0][msg.sender]);\n    @_approve_892(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction updateTSESellFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _sellMarketingFee = varg0;\n    _sellLiquidityFee = varg1;\n    _sellDevFee = varg2;\n    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow\n    require(varg0 + varg1 <= ~varg2, Panic(17)); // arithmetic overflow or underflow\n    _sellTotalFees = varg0 + varg1 + varg2;\n    require(99 >= varg0 + varg1 + varg2, Error('Must keep fees at 99% or less'));\n}\n\nfunction deadAddress() public nonPayable { \n    return address(0xdead);\n}\n\nfunction lpBurnFrequency() public nonPayable { \n    return _lpBurnFrequency;\n}\n\nfunction lpBurnEnabled() public nonPayable { \n    return _lpBurnEnabled;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeAdd(varg1, _increaseAllowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateTSEBuyFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _buyMarketingFee = varg0;\n    _buyLiquidityFee = varg1;\n    _buyDevFee = varg2;\n    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow\n    require(varg0 + varg1 <= ~varg2, Panic(17)); // arithmetic overflow or underflow\n    _buyTotalFees = varg0 + varg1 + varg2;\n    require(25 >= varg0 + varg1 + varg2, Error('Must keep fees at 25% or less'));\n}\n\nfunction renounceTSEOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n}\n\nfunction limitsInEffect() public nonPayable { \n    return _limitsInEffect;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isExcludedFromFees[address(varg0)]));\n}\n\nfunction sellTotalFees() public nonPayable { \n    return _sellTotalFees;\n}\n\nfunction swapEnabled() public nonPayable { \n    return _swapEnabled;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction setAutoLPBurnSettings(uint256 varg0, uint256 varg1, bool varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 == varg2);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 >= 600, Error('cannot set buyback more often than every 10 minutes'));\n    v0 = v1 = varg1 <= 1000;\n    if (!bool(varg1 > 1000)) {\n        v0 = v2 = 1;\n    }\n    require(v0, Error('Must set auto LP burn percent between 0% and 10%'));\n    _lpBurnFrequency = varg0;\n    _percentForLPBurn = varg1;\n    _lpBurnEnabled = varg2;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _limitsInEffect = 0;\n    return bool(1);\n}\n\nfunction excludeFromMaxTransaction(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedMaxTransactionAmount[varg0] = varg1 | bytes31(__isExcludedMaxTransactionAmount[address(varg0)]);\n}\n\nfunction marketingWallet() public nonPayable { \n    return _marketingWallet;\n}\n\nfunction buyMarketingFee() public nonPayable { \n    return _buyMarketingFee;\n}\n\nfunction enableTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_11_1_2 = 257;\n    _lastLpBurnTime = block.timestamp;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction devWallet() public nonPayable { \n    return _devWallet;\n}\n\nfunction sellMarketingFee() public nonPayable { \n    return _sellMarketingFee;\n}\n\nfunction updateSwapEnabled(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _swapEnabled = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_481();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction setAutomatedMarketMakerPair(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 != address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f), Error('The pair cannot be removed from automatedMarketMakerPairs'));\n    _automatedMarketMakerPairs[varg0] = varg1 | bytes31(_automatedMarketMakerPairs[address(varg0)]);\n    emit SetAutomatedMarketMakerPair(varg0, varg1);\n}\n\nfunction buyDevFee() public nonPayable { \n    return _buyDevFee;\n}\n\nfunction lastManualLpBurnTime() public nonPayable { \n    return _lastManualLpBurnTime;\n}\n\nfunction tokensForDev() public nonPayable { \n    return _tokensForDev;\n}\n\nfunction sellDevFee() public nonPayable { \n    return _sellDevFee;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _increaseAllowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction lastLpBurnTime() public nonPayable { \n    return _lastLpBurnTime;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_2968(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateMarketingWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit marketingWalletUpdated(varg0, _marketingWallet);\n    _marketingWallet = varg0;\n}\n\nfunction automatedMarketMakerPairs(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_automatedMarketMakerPairs[varg0]));\n}\n\nfunction tradingActive() public nonPayable { \n    return _tradingActive;\n}\n\nfunction excludeFromFees(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _isExcludedFromFees[varg0] = varg1 | bytes31(_isExcludedFromFees[address(varg0)]);\n    emit ExcludeFromFees(varg0, varg1);\n}\n\nfunction updateMaxWalletAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(5) & (_totalSupply > '33333333333333333333333333333333')), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= 5 * _totalSupply / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxWallet lower than 0.5%', 'Cannot set maxWallet lower than 0.5%'));\n    require(!(bool(0xde0b6b3a7640000) & (varg0 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21)), Panic(17)); // arithmetic overflow or underflow\n    _maxWallet = 0xde0b6b3a7640000 * varg0;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction maxTransactionAmount() public nonPayable { \n    return _maxTransactionAmount;\n}\n\nfunction updateSwapTokensAtAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(1) & (_totalSupply > uint256.max)), Panic(17)); // arithmetic overflow or underflow\n    require(0x186a0, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 0x186a0, Error('Swap amount cannot be lower than 0.001% total supply.'));\n    require(!(bool(10) & (_totalSupply > 0x1999999999999999999999999999999999999999999999999999999999999999)), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(varg0 <= 10 * _totalSupply / 1000, Error('Swap amount cannot be higher than 1% total supply.'));\n    _swapTokensAtAmount = varg0;\n    return bool(1);\n}\n\nfunction buyTotalFees() public nonPayable { \n    return _buyTotalFees;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _increaseAllowance[varg0][varg1];\n}\n\nfunction swapTokensAtAmount() public nonPayable { \n    return _swapTokensAtAmount;\n}\n\nfunction disableTransferDelay() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _transferDelayEnabled = 0;\n    return bool(1);\n}\n\nfunction buyLiquidityFee() public nonPayable { \n    return _buyLiquidityFee;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction sellLiquidityFee() public nonPayable { \n    return _sellLiquidityFee;\n}\n\nfunction maxWallet() public nonPayable { \n    return _maxWallet;\n}\n\nfunction manualBurnLiquidityPairTokens(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(_lastManualLpBurnTime <= ~_manualBurnFrequency, Panic(17)); // arithmetic overflow or underflow\n    require(block.timestamp > _lastManualLpBurnTime + _manualBurnFrequency, Error('Must wait for cooldown to finish'));\n    require(varg0 <= 1000, Error('May not nuke more than 10% of tokens in LP'));\n    _lastManualLpBurnTime = block.timestamp;\n    require(bool(this.code.size));\n    v0, /* uint256 */ v1 = this.balanceOf(address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v2 = _SafeMul(varg0, v1);\n    v3 = _SafeDiv(10000, v2);\n    if (v3) {\n        @_transfer_736(v3, 57005, 0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n    }\n    require(bool((address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).code.size));\n    v4 = address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f).sync().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    emit ManualNukeLP();\n    return bool(1);\n}\n\nfunction @name_471() private { \n    v0 = v1 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(_@name_471.length & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require(_@name_471.length & 0x1 != v6 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_471.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_471.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8a8c523c > v0) {\n            if (0x2e82f1a0 > v0) {\n                if (0x199ffc72 > v0) {\n                    if (0x1694505e > v0) {\n                        if (0x6fdde03 == v0) {\n                            name();\n                        } else if (0x95ea7b3 == v0) {\n                            approve(address,uint256);\n                        } else {\n                            require(0x10d5de53 == v0);\n                            _isExcludedMaxTransactionAmount(address);\n                        }\n                    } else if (0x1694505e == v0) {\n                        uniswapV2Router();\n                    } else if (0x18160ddd == v0) {\n                        totalSupply();\n                    } else if (0x1816467f == v0) {\n                        updateDevWallet(address);\n                    } else {\n                        require(0x184c16c5 == v0);\n                        manualBurnFrequency();\n                    }\n                } else if (0x23b872dd > v0) {\n                    if (0x199ffc72 == v0) {\n                        percentForLPBurn();\n                    } else if (0x1a8145bb == v0) {\n                        tokensForLiquidity();\n                    } else if (0x1f3fed8f == v0) {\n                        tokensForMarketing();\n                    } else {\n                        require(0x203e727e == v0);\n                        updateMaxTxnAmount(uint256);\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x265d2626 == v0) {\n                    updateTSESellFees(uint256,uint256,uint256);\n                } else if (0x27c8f835 == v0) {\n                    deadAddress();\n                } else {\n                    require(0x2c3e486c == v0);\n                    lpBurnFrequency();\n                }\n            } else if (0x6a486a8e > v0) {\n                if (0x443a3b21 > v0) {\n                    if (0x2e82f1a0 == v0) {\n                        lpBurnEnabled();\n                    } else if (0x313ce567 == v0) {\n                        decimals();\n                    } else if (0x39509351 == v0) {\n                        increaseAllowance(address,uint256);\n                    } else {\n                        require(0x39520fcf == v0);\n                        updateTSEBuyFees(uint256,uint256,uint256);\n                    }\n                } else if (0x443a3b21 == v0) {\n                    renounceTSEOwnership();\n                } else if (0x49bd5a5e == v0) {\n                    uniswapV2Pair();\n                } else if (0x4a62bb65 == v0) {\n                    limitsInEffect();\n                } else {\n                    require(0x4fbee193 == v0);\n                    isExcludedFromFees(address);\n                }\n            } else if (0x751039fc > v0) {\n                if (0x6a486a8e == v0) {\n                    sellTotalFees();\n                } else if (0x6ddd1713 == v0) {\n                    swapEnabled();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else {\n                    require(0x730c1888 == v0);\n                    setAutoLPBurnSettings(uint256,uint256,bool);\n                }\n            } else if (0x751039fc == v0) {\n                removeLimits();\n            } else if (0x7571336a == v0) {\n                excludeFromMaxTransaction(address,bool);\n            } else if (0x75f0a874 == v0) {\n                marketingWallet();\n            } else {\n                require(0x7bce5a04 == v0);\n                buyMarketingFee();\n            }\n        } else if (0xb62496f5 > v0) {\n            if (0x9c3b4fdc > v0) {\n                if (0x92136913 > v0) {\n                    if (0x8a8c523c == v0) {\n                        enableTrading();\n                    } else if (0x8da5cb5b == v0) {\n                        owner();\n                    } else {\n                        require(0x8ea5220f == v0);\n                        devWallet();\n                    }\n                } else if (0x92136913 == v0) {\n                    sellMarketingFee();\n                } else if (0x924de9b7 == v0) {\n                    updateSwapEnabled(bool);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else {\n                    require(0x9a7a23d6 == v0);\n                    setAutomatedMarketMakerPair(address,bool);\n                }\n            } else if (0xa457c2d7 > v0) {\n                if (0x9c3b4fdc == v0) {\n                    buyDevFee();\n                } else if (0x9ec22c0e == v0) {\n                    lastManualLpBurnTime();\n                } else if (0x9fccce32 == v0) {\n                    tokensForDev();\n                } else {\n                    require(0xa0d82dc5 == v0);\n                    sellDevFee();\n                }\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa4c82a00 == v0) {\n                lastLpBurnTime();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else {\n                require(0xaacebbe3 == v0);\n                updateMarketingWallet(address);\n            }\n        } else if (0xdd62ed3e > v0) {\n            if (0xc876d0b9 > v0) {\n                if (0xb62496f5 == v0) {\n                    automatedMarketMakerPairs(address);\n                } else if (0xbbc0c742 == v0) {\n                    tradingActive();\n                } else if (0xc0246668 == v0) {\n                    excludeFromFees(address,bool);\n                } else {\n                    require(0xc18bc195 == v0);\n                    updateMaxWalletAmount(uint256);\n                }\n            } else if (0xc876d0b9 == v0) {\n                transferDelayEnabled();\n            } else if (0xc8c8ebe4 == v0) {\n                maxTransactionAmount();\n            } else if (0xd257b34f == v0) {\n                updateSwapTokensAtAmount(uint256);\n            } else {\n                require(0xd85ba063 == v0);\n                buyTotalFees();\n            }\n        } else if (0xf2fde38b > v0) {\n            if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe2f45605 == v0) {\n                swapTokensAtAmount();\n            } else if (0xe884f260 == v0) {\n                disableTransferDelay();\n            } else {\n                require(0xf11a24d3 == v0);\n                buyLiquidityFee();\n            }\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf6374342 == v0) {\n            sellLiquidityFee();\n        } else if (0xf8b45b05 == v0) {\n            maxWallet();\n        } else {\n            require(0xfe72b27a == v0);\n            manualBurnLiquidityPairTokens(uint256);\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 01:26 UTC\n// Compiled using the solidity compiler version 0.8.9\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _increaseAllowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _@name_471; // STORAGE[0x3]\nuint256[] _@symbol_481; // STORAGE[0x4]\nuint256 _maxTransactionAmount; // STORAGE[0x8]\nuint256 _swapTokensAtAmount; // STORAGE[0x9]\nuint256 _maxWallet; // STORAGE[0xa]\nuint256 _percentForLPBurn; // STORAGE[0xb]\nuint256 _lpBurnFrequency; // STORAGE[0xd]\nuint256 _lastLpBurnTime; // STORAGE[0xe]\nuint256 _manualBurnFrequency; // STORAGE[0xf]\nuint256 _lastManualLpBurnTime; // STORAGE[0x10]\nmapping (uint256 => uint256) owner_12; // STORAGE[0x12]\nuint256 _buyTotalFees; // STORAGE[0x14]\nuint256 _buyMarketingFee; // STORAGE[0x15]\nuint256 _buyLiquidityFee; // STORAGE[0x16]\nuint256 _buyDevFee; // STORAGE[0x17]\nuint256 _sellTotalFees; // STORAGE[0x18]\nuint256 _sellMarketingFee; // STORAGE[0x19]\nuint256 _sellLiquidityFee; // STORAGE[0x1a]\nuint256 _sellDevFee; // STORAGE[0x1b]\nuint256 _tokensForMarketing; // STORAGE[0x1c]\nuint256 _tokensForLiquidity; // STORAGE[0x1d]\nuint256 _tokensForDev; // STORAGE[0x1e]\nmapping (uint256 => uint256) _isExcludedFromFees; // STORAGE[0x1f]\nmapping (uint256 => uint256) __isExcludedMaxTransactionAmount; // STORAGE[0x20]\nmapping (uint256 => uint256) _automatedMarketMakerPairs; // STORAGE[0x21]\nuint256 _lpBurnEnabled; // STORAGE[0xc] bytes 0 to 0\nuint256 _limitsInEffect; // STORAGE[0x11] bytes 0 to 0\nuint256 _tradingActive; // STORAGE[0x11] bytes 1 to 1\nuint256 stor_11_1_2; // STORAGE[0x11] bytes 1 to 2\nuint256 _swapEnabled; // STORAGE[0x11] bytes 2 to 2\nuint256 _transferDelayEnabled; // STORAGE[0x13] bytes 0 to 0\nuint256 _owner; // STORAGE[0x5] bytes 0 to 19\nuint256 _marketingWallet; // STORAGE[0x6] bytes 0 to 19\nuint256 _devWallet; // STORAGE[0x7] bytes 0 to 19\nuint256 stor_5_20_20; // STORAGE[0x5] bytes 20 to 20\n\n\n// Events\ndevWalletUpdated(address, address);\nOwnershipTransferred(address, address);\nmarketingWalletUpdated(address, address);\nExcludeFromFees(address, bool);\nManualNukeLP();\nApproval(address, address, uint256);\nSetAutomatedMarketMakerPair(address, bool);\nTransfer(address, address, uint256);\nSwapAndLiquify(uint256, uint256, uint256);\nAutoNukeLP();\n\nfunction @symbol_481() private { \n    v0 = v1 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(_@symbol_481.length & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@symbol_481.length >> 1;\n    if (!(_@symbol_481.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require(_@symbol_481.length & 0x1 != v6 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@symbol_481.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@symbol_481.length >> 8 << 8;\n        return v3;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction @_approve_892(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _increaseAllowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_2968(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    if (varg0) {\n        if (_limitsInEffect) {\n            v0 = v1 = _owner != address(varg2);\n            if (_owner != address(varg2)) {\n                v0 = v2 = _owner != address(varg1);\n            }\n            if (v0) {\n                v0 = v3 = bool(address(varg1));\n            }\n            if (v0) {\n                v0 = v4 = 57005 != address(varg1);\n            }\n            if (v0) {\n                v0 = v5 = !stor_5_20_20;\n            }\n            if (v0) {\n                if (!_tradingActive) {\n                    v6 = v7 = uint8(_isExcludedFromFees[address(varg2)]);\n                    if (!v7) {\n                        v6 = v8 = uint8(_isExcludedFromFees[address(varg1)]);\n                    }\n                    require(v6, Error('Trading is not active.'));\n                }\n                if (_transferDelayEnabled) {\n                    v9 = v10 = _owner != address(varg1);\n                    if (_owner != address(varg1)) {\n                        v9 = v11 = address(varg1) != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n                    }\n                    if (v9) {\n                        v9 = v12 = address(varg1) != address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n                    }\n                    if (v9) {\n                        require(block.number > owner_12[tx.origin], Error('_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.'));\n                        owner_12[tx.origin] = block.number;\n                    }\n                }\n                v13 = v14 = uint8(_automatedMarketMakerPairs[address(varg2)]);\n                if (v14) {\n                    v13 = v15 = !uint8(__isExcludedMaxTransactionAmount[address(varg1)]);\n                }\n                if (!v13) {\n                    v16 = v17 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n                    if (v17) {\n                        v16 = v18 = !uint8(__isExcludedMaxTransactionAmount[address(varg2)]);\n                    }\n                    if (!v16) {\n                        if (!uint8(__isExcludedMaxTransactionAmount[address(varg1)])) {\n                            require(varg0 <= ~_balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                            require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                        }\n                    } else {\n                        require(varg0 <= _maxTransactionAmount, Error('Sell transfer amount exceeds the maxTransactionAmount.'));\n                    }\n                } else {\n                    require(varg0 <= _maxTransactionAmount, Error('Buy transfer amount exceeds the maxTransactionAmount.'));\n                    require(varg0 <= ~_balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                    require(varg0 + _balanceOf[address(varg1)] <= _maxWallet, Error('Max wallet exceeded'));\n                }\n            }\n        }\n        v19 = v20 = _balanceOf[this] >= _swapTokensAtAmount;\n        if (_balanceOf[this] >= _swapTokensAtAmount) {\n            v19 = v21 = _swapEnabled;\n        }\n        if (v19) {\n            v19 = v22 = !stor_5_20_20;\n        }\n        if (v19) {\n            v19 = v23 = !uint8(_automatedMarketMakerPairs[address(varg2)]);\n        }\n        if (v19) {\n            v19 = v24 = !uint8(_isExcludedFromFees[address(varg2)]);\n        }\n        if (v19) {\n            v19 = v25 = !uint8(_isExcludedFromFees[address(varg1)]);\n        }\n        if (v19) {\n            stor_5_20_20 = 1;\n            v26 = v27 = _balanceOf[this];\n            require(_tokensForLiquidity <= ~_tokensForMarketing, Panic(17)); // arithmetic overflow or underflow\n            require(_tokensForLiquidity + _tokensForMarketing <= ~_tokensForDev, Panic(17)); // arithmetic overflow or underflow\n            v28 = v29 = !v27;\n            if (v27) {\n                v28 = !(_tokensForLiquidity + _tokensForMarketing + _tokensForDev);\n            }\n            if (!v28) {\n                require(!(bool(20) & (_swapTokensAtAmount > 0xccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)), Panic(17)); // arithmetic overflow or underflow\n                if (v27 > 20 * _swapTokensAtAmount) {\n                    require(!(bool(20) & (_swapTokensAtAmount > 0xccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc)), Panic(17)); // arithmetic overflow or underflow\n                    v26 = 20 * _swapTokensAtAmount;\n                }\n                require(!(bool(v26) & (_tokensForLiquidity > ~0 / v26)), Panic(17)); // arithmetic overflow or underflow\n                require(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, Panic(18)); // division by zero\n                require(2, Panic(18)); // division by zero\n                v30 = v26 * _tokensForLiquidity / (_tokensForLiquidity + _tokensForMarketing + _tokensForDev) >> 1;\n                v31 = _SafeSub('SafeMath: subtraction overflow', v30, v26);\n                v32 = new address[](2);\n                CALLDATACOPY(v32.data, msg.data.length, 64);\n                require(0 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v33 = v32.data;\n                v32[0] = address(this);\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v34, /* address */ v35 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH().gas(msg.gas);\n                require(bool(v34), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                require(v35 == address(v35));\n                require(1 < v32.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                v32[1] = address(v35);\n                @_approve_892(v31, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                v36 = new address[](v32.length);\n                v37 = v38 = v36.data;\n                v39 = v40 = v32.data;\n                v41 = v42 = 0;\n                while (v41 < v32.length) {\n                    MEM[v37] = address(MEM[v39]);\n                    v39 += 32;\n                    v37 += 32;\n                    v41 += 1;\n                }\n                require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                v43 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).swapExactTokensForETHSupportingFeeOnTransferTokens(v31, 0, v36, address(this), block.timestamp, v44, address(this)).gas(msg.gas);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v45 = _SafeSub('SafeMath: subtraction overflow', this.balance, this.balance);\n                v46 = _SafeMul(_tokensForMarketing, v45);\n                v47 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v46);\n                v48 = _SafeMul(_tokensForDev, v45);\n                v49 = _SafeDiv(_tokensForLiquidity + _tokensForMarketing + _tokensForDev, v48);\n                require(v45 >= v47, Panic(17)); // arithmetic overflow or underflow\n                require(v45 - v47 >= v49, Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = 0;\n                _tokensForMarketing = 0;\n                _tokensForDev = 0;\n                v50, /* uint256 */ v51 = _devWallet.call().value(v49).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v52 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v52.data, 0, RETURNDATASIZE());\n                }\n                v53 = v54 = bool(v30);\n                if (v30) {\n                    v53 = v45 - v47 - v49 > 0;\n                }\n                if (v53) {\n                    @_approve_892(v30, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n                    require(bool((address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)).code.size));\n                    v55, /* uint256 */ v56, /* uint256 */ v57, /* uint256 */ v58 = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).addLiquidityETH(this, v30, 0, 0, 57005, block.timestamp).value(v45 - v47 - v49).gas(msg.gas);\n                    require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n                    emit SwapAndLiquify(v31, v45 - v47 - v49, _tokensForLiquidity);\n                }\n                v59, /* uint256 */ v60 = _marketingWallet.call().value(this.balance).gas(msg.gas);\n                if (RETURNDATASIZE() != 0) {\n                    v61 = new bytes[](RETURNDATASIZE());\n                    RETURNDATACOPY(v61.data, 0, RETURNDATASIZE());\n                }\n                // Unknown jump to Block 0x218f. Refer to 3-address code (TAC);\n            }\n            stor_5_20_20 = 0;\n        }\n        v62 = v63 = !stor_5_20_20;\n        if (!stor_5_20_20) {\n            v62 = v64 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n        }\n        if (v62) {\n            v62 = v65 = _lpBurnEnabled;\n        }\n        if (v62) {\n            require(_lastLpBurnTime <= ~_lpBurnFrequency, Panic(17)); // arithmetic overflow or underflow\n            v62 = v66 = block.timestamp >= _lastLpBurnTime + _lpBurnFrequency;\n        }\n        if (v62) {\n            v62 = v67 = !uint8(_isExcludedFromFees[address(varg2)]);\n        }\n        if (v62) {\n            _lastLpBurnTime = block.timestamp;\n            require(bool(this.code.size));\n            v68, /* uint256 */ v69 = this.balanceOf(address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).gas(msg.gas);\n            require(bool(v68), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            v70 = _SafeMul(_percentForLPBurn, v69);\n            v71 = _SafeDiv(10000, v70);\n            if (v71) {\n                @_transfer_736(v71, 57005, 0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n            }\n            require(bool((address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).code.size));\n            v72 = address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f).sync().gas(msg.gas);\n            require(bool(v72), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            emit AutoNukeLP();\n        }\n        v73 = v74 = !stor_5_20_20;\n        v75 = v76 = uint8(_isExcludedFromFees[address(varg2)]);\n        if (!v76) {\n            v75 = v77 = uint8(_isExcludedFromFees[address(varg1)]);\n        }\n        if (v75) {\n            v73 = v78 = 0;\n        }\n        v79 = v80 = 0;\n        if (v73) {\n            v81 = v82 = uint8(_automatedMarketMakerPairs[address(varg1)]);\n            if (v82) {\n                v81 = v83 = _sellTotalFees > 0;\n            }\n            if (!v81) {\n                v84 = v85 = uint8(_automatedMarketMakerPairs[address(varg2)]);\n                if (v85) {\n                    v84 = v86 = _buyTotalFees > 0;\n                }\n                if (v84) {\n                    v87 = _SafeMul(_buyTotalFees, varg0);\n                    v79 = v88 = _SafeDiv(100, v87);\n                    require(!(bool(v88) & (_buyLiquidityFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForLiquidity <= ~(v88 * _buyLiquidityFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForLiquidity = _tokensForLiquidity + v88 * _buyLiquidityFee / _buyTotalFees;\n                    require(!(bool(v88) & (_buyDevFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForDev <= ~(v88 * _buyDevFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForDev = _tokensForDev + v88 * _buyDevFee / _buyTotalFees;\n                    require(!(bool(v88) & (_buyMarketingFee > ~0 / v88)), Panic(17)); // arithmetic overflow or underflow\n                    require(_buyTotalFees, Panic(18)); // division by zero\n                    require(_tokensForMarketing <= ~(v88 * _buyMarketingFee / _buyTotalFees), Panic(17)); // arithmetic overflow or underflow\n                    _tokensForMarketing = _tokensForMarketing + v88 * _buyMarketingFee / _buyTotalFees;\n                }\n            } else {\n                v89 = _SafeMul(_sellTotalFees, varg0);\n                v79 = v90 = _SafeDiv(100, v89);\n                require(!(bool(v90) & (_sellLiquidityFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForLiquidity <= ~(v90 * _sellLiquidityFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForLiquidity = _tokensForLiquidity + v90 * _sellLiquidityFee / _sellTotalFees;\n                require(!(bool(v90) & (_sellDevFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForDev <= ~(v90 * _sellDevFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForDev = _tokensForDev + v90 * _sellDevFee / _sellTotalFees;\n                require(!(bool(v90) & (_sellMarketingFee > ~0 / v90)), Panic(17)); // arithmetic overflow or underflow\n                require(_sellTotalFees, Panic(18)); // division by zero\n                require(_tokensForMarketing <= ~(v90 * _sellMarketingFee / _sellTotalFees), Panic(17)); // arithmetic overflow or underflow\n                _tokensForMarketing = _tokensForMarketing + v90 * _sellMarketingFee / _sellTotalFees;\n            }\n            if (v79) {\n                @_transfer_736(v79, this, varg2);\n            }\n            require(varg0 >= v79, Panic(17)); // arithmetic overflow or underflow\n            varg0 = v91 = varg0 - v79;\n        }\n        @_transfer_736(varg0, varg1, varg2);\n        return ;\n    } else {\n        @_transfer_736(0, varg1, varg2);\n        return ;\n    }\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 >= varg1, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        require(!(bool(varg1) & (varg0 > ~0 / varg1)), Panic(17)); // arithmetic overflow or underflow\n        require(varg1, Panic(18)); // division by zero\n        require(varg1 * varg0 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n        return varg1 * varg0;\n    } else {\n        return 0;\n    }\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0) {\n        require(varg0, Panic(18)); // division by zero\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        if (v2 > v1.length) {\n            v0[v1.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction @_transfer_736(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = @name_471();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_892(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _isExcludedMaxTransactionAmount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(__isExcludedMaxTransactionAmount[varg0]));\n}\n\nfunction uniswapV2Router() public nonPayable { \n    return address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\n}\n\nfunction () public payable { \n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction updateDevWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit devWalletUpdated(varg0, _devWallet);\n    _devWallet = varg0;\n}\n\nfunction manualBurnFrequency() public nonPayable { \n    return _manualBurnFrequency;\n}\n\nfunction percentForLPBurn() public nonPayable { \n    return _percentForLPBurn;\n}\n\nfunction tokensForLiquidity() public nonPayable { \n    return _tokensForLiquidity;\n}\n\nfunction tokensForMarketing() public nonPayable { \n    return _tokensForMarketing;\n}\n\nfunction updateMaxTxnAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(1) & (_totalSupply > uint256.max)), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxTransactionAmount lower than 0.1%'));\n    require(!(bool(0xde0b6b3a7640000) & (varg0 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21)), Panic(17)); // arithmetic overflow or underflow\n    _maxTransactionAmount = 0xde0b6b3a7640000 * varg0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_2968(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _increaseAllowance[varg0][msg.sender]);\n    @_approve_892(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction updateTSESellFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _sellMarketingFee = varg0;\n    _sellLiquidityFee = varg1;\n    _sellDevFee = varg2;\n    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow\n    require(varg0 + varg1 <= ~varg2, Panic(17)); // arithmetic overflow or underflow\n    _sellTotalFees = varg0 + varg1 + varg2;\n    require(99 >= varg0 + varg1 + varg2, Error('Must keep fees at 99% or less'));\n}\n\nfunction deadAddress() public nonPayable { \n    return address(0xdead);\n}\n\nfunction lpBurnFrequency() public nonPayable { \n    return _lpBurnFrequency;\n}\n\nfunction lpBurnEnabled() public nonPayable { \n    return _lpBurnEnabled;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeAdd(varg1, _increaseAllowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateTSEBuyFees(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _buyMarketingFee = varg0;\n    _buyLiquidityFee = varg1;\n    _buyDevFee = varg2;\n    require(varg0 <= ~varg1, Panic(17)); // arithmetic overflow or underflow\n    require(varg0 + varg1 <= ~varg2, Panic(17)); // arithmetic overflow or underflow\n    _buyTotalFees = varg0 + varg1 + varg2;\n    require(25 >= varg0 + varg1 + varg2, Error('Must keep fees at 25% or less'));\n}\n\nfunction renounceTSEOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction uniswapV2Pair() public nonPayable { \n    return address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n}\n\nfunction limitsInEffect() public nonPayable { \n    return _limitsInEffect;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isExcludedFromFees[address(varg0)]));\n}\n\nfunction sellTotalFees() public nonPayable { \n    return _sellTotalFees;\n}\n\nfunction swapEnabled() public nonPayable { \n    return _swapEnabled;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction setAutoLPBurnSettings(uint256 varg0, uint256 varg1, bool varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 == varg2);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 >= 600, Error('cannot set buyback more often than every 10 minutes'));\n    v0 = v1 = varg1 <= 1000;\n    if (!bool(varg1 > 1000)) {\n        v0 = v2 = 1;\n    }\n    require(v0, Error('Must set auto LP burn percent between 0% and 10%'));\n    _lpBurnFrequency = varg0;\n    _percentForLPBurn = varg1;\n    _lpBurnEnabled = varg2;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _limitsInEffect = 0;\n    return bool(1);\n}\n\nfunction excludeFromMaxTransaction(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    __isExcludedMaxTransactionAmount[varg0] = varg1 | bytes31(__isExcludedMaxTransactionAmount[address(varg0)]);\n}\n\nfunction marketingWallet() public nonPayable { \n    return _marketingWallet;\n}\n\nfunction buyMarketingFee() public nonPayable { \n    return _buyMarketingFee;\n}\n\nfunction enableTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    stor_11_1_2 = 257;\n    _lastLpBurnTime = block.timestamp;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction devWallet() public nonPayable { \n    return _devWallet;\n}\n\nfunction sellMarketingFee() public nonPayable { \n    return _sellMarketingFee;\n}\n\nfunction updateSwapEnabled(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _swapEnabled = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = @symbol_481();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 += 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction setAutomatedMarketMakerPair(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0 != address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f), Error('The pair cannot be removed from automatedMarketMakerPairs'));\n    _automatedMarketMakerPairs[varg0] = varg1 | bytes31(_automatedMarketMakerPairs[address(varg0)]);\n    emit SetAutomatedMarketMakerPair(varg0, varg1);\n}\n\nfunction buyDevFee() public nonPayable { \n    return _buyDevFee;\n}\n\nfunction lastManualLpBurnTime() public nonPayable { \n    return _lastManualLpBurnTime;\n}\n\nfunction tokensForDev() public nonPayable { \n    return _tokensForDev;\n}\n\nfunction sellDevFee() public nonPayable { \n    return _sellDevFee;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', varg1, _increaseAllowance[msg.sender][varg0]);\n    @_approve_892(v0, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction lastLpBurnTime() public nonPayable { \n    return _lastLpBurnTime;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_2968(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction updateMarketingWallet(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit marketingWalletUpdated(varg0, _marketingWallet);\n    _marketingWallet = varg0;\n}\n\nfunction automatedMarketMakerPairs(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_automatedMarketMakerPairs[varg0]));\n}\n\nfunction tradingActive() public nonPayable { \n    return _tradingActive;\n}\n\nfunction excludeFromFees(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _isExcludedFromFees[varg0] = varg1 | bytes31(_isExcludedFromFees[address(varg0)]);\n    emit ExcludeFromFees(varg0, varg1);\n}\n\nfunction updateMaxWalletAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(5) & (_totalSupply > '33333333333333333333333333333333')), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(0xde0b6b3a7640000, Panic(18)); // division by zero\n    require(varg0 >= 5 * _totalSupply / 1000 / 0xde0b6b3a7640000, Error('Cannot set maxWallet lower than 0.5%', 'Cannot set maxWallet lower than 0.5%'));\n    require(!(bool(0xde0b6b3a7640000) & (varg0 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21)), Panic(17)); // arithmetic overflow or underflow\n    _maxWallet = 0xde0b6b3a7640000 * varg0;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction maxTransactionAmount() public nonPayable { \n    return _maxTransactionAmount;\n}\n\nfunction updateSwapTokensAtAmount(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!(bool(1) & (_totalSupply > uint256.max)), Panic(17)); // arithmetic overflow or underflow\n    require(0x186a0, Panic(18)); // division by zero\n    require(varg0 >= _totalSupply / 0x186a0, Error('Swap amount cannot be lower than 0.001% total supply.'));\n    require(!(bool(10) & (_totalSupply > 0x1999999999999999999999999999999999999999999999999999999999999999)), Panic(17)); // arithmetic overflow or underflow\n    require(1000, Panic(18)); // division by zero\n    require(varg0 <= 10 * _totalSupply / 1000, Error('Swap amount cannot be higher than 1% total supply.'));\n    _swapTokensAtAmount = varg0;\n    return bool(1);\n}\n\nfunction buyTotalFees() public nonPayable { \n    return _buyTotalFees;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _increaseAllowance[varg0][varg1];\n}\n\nfunction swapTokensAtAmount() public nonPayable { \n    return _swapTokensAtAmount;\n}\n\nfunction disableTransferDelay() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    _transferDelayEnabled = 0;\n    return bool(1);\n}\n\nfunction buyLiquidityFee() public nonPayable { \n    return _buyLiquidityFee;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction sellLiquidityFee() public nonPayable { \n    return _sellLiquidityFee;\n}\n\nfunction maxWallet() public nonPayable { \n    return _maxWallet;\n}\n\nfunction manualBurnLiquidityPairTokens(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(_lastManualLpBurnTime <= ~_manualBurnFrequency, Panic(17)); // arithmetic overflow or underflow\n    require(block.timestamp > _lastManualLpBurnTime + _manualBurnFrequency, Error('Must wait for cooldown to finish'));\n    require(varg0 <= 1000, Error('May not nuke more than 10% of tokens in LP'));\n    _lastManualLpBurnTime = block.timestamp;\n    require(bool(this.code.size));\n    v0, /* uint256 */ v1 = this.balanceOf(address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v2 = _SafeMul(varg0, v1);\n    v3 = _SafeDiv(10000, v2);\n    if (v3) {\n        @_transfer_736(v3, 57005, 0x5df17b97f84bd9a72b385d88dfd56c6af025a01f);\n    }\n    require(bool((address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f)).code.size));\n    v4 = address(0x5df17b97f84bd9a72b385d88dfd56c6af025a01f).sync().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    emit ManualNukeLP();\n    return bool(1);\n}\n\nfunction @name_471() private { \n    v0 = v1 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(_@name_471.length & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    v3 = new bytes[](v0);\n    v4 = v5 = v3.data;\n    v6 = v7 = _@name_471.length >> 1;\n    if (!(_@name_471.length & 0x1)) {\n        v6 = v8 = v7 & 0x7f;\n    }\n    require(_@name_471.length & 0x1 != v6 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    if (!v6) {\n        return v3;\n    } else if (31 < v6) {\n        v9 = _@name_471.data;\n        do {\n            MEM[v4] = STORAGE[v9];\n            v9 += 1;\n            v4 += 32;\n        } while (v5 + v6 <= v4);\n        return v3;\n    } else {\n        MEM[v5] = _@name_471.length >> 8 << 8;\n        return v3;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8a8c523c > v0) {\n            if (0x2e82f1a0 > v0) {\n                if (0x199ffc72 > v0) {\n                    if (0x1694505e > v0) {\n                        if (0x6fdde03 == v0) {\n                            name();\n                        } else if (0x95ea7b3 == v0) {\n                            approve(address,uint256);\n                        } else {\n                            require(0x10d5de53 == v0);\n                            _isExcludedMaxTransactionAmount(address);\n                        }\n                    } else if (0x1694505e == v0) {\n                        uniswapV2Router();\n                    } else if (0x18160ddd == v0) {\n                        totalSupply();\n                    } else if (0x1816467f == v0) {\n                        updateDevWallet(address);\n                    } else {\n                        require(0x184c16c5 == v0);\n                        manualBurnFrequency();\n                    }\n                } else if (0x23b872dd > v0) {\n                    if (0x199ffc72 == v0) {\n                        percentForLPBurn();\n                    } else if (0x1a8145bb == v0) {\n                        tokensForLiquidity();\n                    } else if (0x1f3fed8f == v0) {\n                        tokensForMarketing();\n                    } else {\n                        require(0x203e727e == v0);\n                        updateMaxTxnAmount(uint256);\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x265d2626 == v0) {\n                    updateTSESellFees(uint256,uint256,uint256);\n                } else if (0x27c8f835 == v0) {\n                    deadAddress();\n                } else {\n                    require(0x2c3e486c == v0);\n                    lpBurnFrequency();\n                }\n            } else if (0x6a486a8e > v0) {\n                if (0x443a3b21 > v0) {\n                    if (0x2e82f1a0 == v0) {\n                        lpBurnEnabled();\n                    } else if (0x313ce567 == v0) {\n                        decimals();\n                    } else if (0x39509351 == v0) {\n                        increaseAllowance(address,uint256);\n                    } else {\n                        require(0x39520fcf == v0);\n                        updateTSEBuyFees(uint256,uint256,uint256);\n                    }\n                } else if (0x443a3b21 == v0) {\n                    renounceTSEOwnership();\n                } else if (0x49bd5a5e == v0) {\n                    uniswapV2Pair();\n                } else if (0x4a62bb65 == v0) {\n                    limitsInEffect();\n                } else {\n                    require(0x4fbee193 == v0);\n                    isExcludedFromFees(address);\n                }\n            } else if (0x751039fc > v0) {\n                if (0x6a486a8e == v0) {\n                    sellTotalFees();\n                } else if (0x6ddd1713 == v0) {\n                    swapEnabled();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else {\n                    require(0x730c1888 == v0);\n                    setAutoLPBurnSettings(uint256,uint256,bool);\n                }\n            } else if (0x751039fc == v0) {\n                removeLimits();\n            } else if (0x7571336a == v0) {\n                excludeFromMaxTransaction(address,bool);\n            } else if (0x75f0a874 == v0) {\n                marketingWallet();\n            } else {\n                require(0x7bce5a04 == v0);\n                buyMarketingFee();\n            }\n        } else if (0xb62496f5 > v0) {\n            if (0x9c3b4fdc > v0) {\n                if (0x92136913 > v0) {\n                    if (0x8a8c523c == v0) {\n                        enableTrading();\n                    } else if (0x8da5cb5b == v0) {\n                        owner();\n                    } else {\n                        require(0x8ea5220f == v0);\n                        devWallet();\n                    }\n                } else if (0x92136913 == v0) {\n                    sellMarketingFee();\n                } else if (0x924de9b7 == v0) {\n                    updateSwapEnabled(bool);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else {\n                    require(0x9a7a23d6 == v0);\n                    setAutomatedMarketMakerPair(address,bool);\n                }\n            } else if (0xa457c2d7 > v0) {\n                if (0x9c3b4fdc == v0) {\n                    buyDevFee();\n                } else if (0x9ec22c0e == v0) {\n                    lastManualLpBurnTime();\n                } else if (0x9fccce32 == v0) {\n                    tokensForDev();\n                } else {\n                    require(0xa0d82dc5 == v0);\n                    sellDevFee();\n                }\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa4c82a00 == v0) {\n                lastLpBurnTime();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else {\n                require(0xaacebbe3 == v0);\n                updateMarketingWallet(address);\n            }\n        } else if (0xdd62ed3e > v0) {\n            if (0xc876d0b9 > v0) {\n                if (0xb62496f5 == v0) {\n                    automatedMarketMakerPairs(address);\n                } else if (0xbbc0c742 == v0) {\n                    tradingActive();\n                } else if (0xc0246668 == v0) {\n                    excludeFromFees(address,bool);\n                } else {\n                    require(0xc18bc195 == v0);\n                    updateMaxWalletAmount(uint256);\n                }\n            } else if (0xc876d0b9 == v0) {\n                transferDelayEnabled();\n            } else if (0xc8c8ebe4 == v0) {\n                maxTransactionAmount();\n            } else if (0xd257b34f == v0) {\n                updateSwapTokensAtAmount(uint256);\n            } else {\n                require(0xd85ba063 == v0);\n                buyTotalFees();\n            }\n        } else if (0xf2fde38b > v0) {\n            if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe2f45605 == v0) {\n                swapTokensAtAmount();\n            } else if (0xe884f260 == v0) {\n                disableTransferDelay();\n            } else {\n                require(0xf11a24d3 == v0);\n                buyLiquidityFee();\n            }\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf6374342 == v0) {\n            sellLiquidityFee();\n        } else if (0xf8b45b05 == v0) {\n            maxWallet();\n        } else {\n            require(0xfe72b27a == v0);\n            manualBurnLiquidityPairTokens(uint256);\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 36.02490711212158,
	"usage": {
		"completion_tokens": 653,
		"prompt_tokens": 12284,
		"total_tokens": 12937
	}
}