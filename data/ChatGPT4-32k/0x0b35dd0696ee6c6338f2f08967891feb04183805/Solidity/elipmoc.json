{
	"address": "0x0b35dd0696ee6c6338f2f08967891feb04183805",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is an example of a Solidity contract derived from the decompiled code:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract DerivedContract {\n    mapping (uint256 => uint256[]) private _invalidOrder;\n    mapping (uint256 => uint256[]) private _tokens;\n    mapping (uint256 => uint256[]) private _admins;\n    mapping (uint256 => uint256[]) private _lastActiveTransaction;\n    mapping (uint256 => uint256[]) private _orderFills;\n    uint256 private _inactivityReleasePeriod;\n    mapping (uint256 => uint256[]) private _traded;\n    mapping (uint256 => uint256[]) private _withdrawn;\n    address private _getOwner;\n    uint160 private _feeAccount;\n    mapping (uint256 => uint256[]) private _deposit;\n\n    event SetOwner(address indexed oldOwner, address indexed newOwner);\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n\n    modifier onlyOwner() {\n        require(msg.sender == _getOwner, \"Not contract owner\");\n        _;\n    }\n\n    function setOwner(address newOwner) public onlyOwner {\n        emit SetOwner(_getOwner, newOwner);\n        _getOwner = newOwner;\n    }\n\n    // Other function implementations go here...\n\n    function _SafeSub(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function _SafeAdd(uint256 a, uint256 b) private pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n}\n```\n\nPlease note that due to the complexity of the original EVM bytecode, some details might be lost in the translation, and further adjustments might be needed depending on the specific use case and the business logic of the contract. It's also worth noting that the original bytecode might have made use of libraries or other contracts which are not visible from this single contract's bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468475,
	"id": "chatcmpl-8R5xrka6fuFWQAfheQ9QOpGQX0Hdj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 11:46 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x5]\nuint256 _inactivityReleasePeriod; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _traded; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0x9]\naddress _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x6] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n// Events\nSetOwner(address, address);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction fallback() public nonPayable { \n    revert();\n}\n\nfunction assert(bool varg0) public nonPayable { \n    require(varg0);\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(_getOwner == msg.sender);\n    emit SetOwner(_getOwner, varg0);\n    _getOwner = varg0;\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    v3 = keccak256(address(this), varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v3]));\n    _withdrawn[v3] = 0x1 | ~0xff & _withdrawn[v3];\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v4, v5 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v3), varg4 & 0xff & 0xff, varg5, varg6);\n    require(v4);\n    require(address(v5) == varg2);\n    if (varg7 > 0xb1a2bc2ec50000) {\n        v6 = v7 = 0xb1a2bc2ec50000;\n    }\n    require(_tokens[varg2] >= varg1);\n    v8 = _SafeSub(varg1, _tokens[varg2]);\n    _tokens[varg2] = v8;\n    v9 = _SafeMul(varg1, v6);\n    assert(0xde0b6b3a7640000);\n    v10 = v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount];\n    if (v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount]) {\n        v10 = v11 = v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= v9 / 0xde0b6b3a7640000;\n        goto 0x4d50x178;\n    }\n    require(v10);\n    _tokens[_feeAccount] += v9 / 0xde0b6b3a7640000;\n    v12 = _SafeMul(varg1, 0xde0b6b3a7640000 - v6);\n    assert(0xde0b6b3a7640000);\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v13, v14 = varg0.transfer(varg2, v12 / 0xde0b6b3a7640000).gas(msg.gas - 710);\n        require(v13);\n        require(v14);\n    } else {\n        v15 = varg2.call().value(v12 / 0xde0b6b3a7640000).gas(2300 * !(v12 / 0xde0b6b3a7640000));\n        require(v15);\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, v12 / 0xde0b6b3a7640000, _lastActiveTransaction[varg0]);\n    return 0;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    _lastActiveTransaction[msg.sender] = block.number;\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(_getOwner == msg.sender);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction owner() public nonPayable { \n    return _getOwner;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeSub(varg1, varg0);\n    return v0;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeMul(varg1, varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[0] = msg.sender;\n    MEM[32] = 0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction traded(bytes32 varg0) public nonPayable { \n    return 0xff & _traded[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg0 <= 0xf4240);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, varg0);\n    return v0;\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = 435;\n    v0 = v2 = MEM[64];\n    CALLDATACOPY(v2, 4, 256);\n    v0 = v3 = MEM[64];\n    CALLDATACOPY(v3, 260, 128);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 388, 64);\n    v0 = v5 = MEM[64];\n    CALLDATACOPY(v5, 452, 128);\n    v0 = v6 = 0;\n    v7 = v8 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v7 = v9 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v7);\n    require(_invalidOrder[address(MEM[v3 + 64])] <= MEM[v2 + 96]);\n    v0 = v10 = keccak256(address(this), address(MEM[v3]), MEM[v2], address(MEM[v3 + 32]), MEM[v2 + 32], MEM[v2 + 64], MEM[v2 + 96], address(MEM[v3 + 64]));\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v11, v12 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v10), MEM[v4] & 0xff, MEM[v5], MEM[v5 + 32]);\n    require(v11);\n    require(address(v12) == address(MEM[v3 + 64]));\n    v0 = v13 = keccak256(v10, MEM[v2 + 128], address(MEM[v3 + 96]), MEM[v2 + 160]);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v14, v15 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v13), MEM[v4 + 32] & 0xff, MEM[v5 + 64], MEM[v5 + 96]);\n    require(v14);\n    require(address(v15) == address(MEM[v3 + 96]));\n    require(!(0xff & _traded[v13]));\n    _traded[v13] = 0x1 | ~0xff & _traded[v13];\n    if (MEM[192 + v2] > 0x16345785d8a0000) {\n        MEM[v2 + 192] = 0x16345785d8a0000;\n    }\n    if (MEM[v2 + 224] > 0x16345785d8a0000) {\n        MEM[v2 + 224] = 0x16345785d8a0000;\n    }\n    v0 = v16 = MEM[v2];\n    v17 = v18 = _orderFills[v10];\n    v19 = v20 = 4537;\n    v21 = v22 = MEM[128 + v2];\n    while (1) {\n        v23 = v24 = v21 + v17;\n        v25 = v26 = 3227;\n        v27 = v28 = v24 >= v17;\n        if (v24 < v17) {\n            goto 0xc960x3ad;\n        }\n        if (v27) {\n            break;\n        }\n        require(v27);\n        _tokens[address(MEM[v0 + 32])] = v23;\n        v29 = v30 = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= _orderFills[address(MEM[v0 + 32])];\n        if (MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= _orderFills[address(MEM[v0 + 32])]) {\n            v29 = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= MEM[128 + v0];\n            goto 0x4d50x11afB0x16350x3ad;\n        }\n        require(v29);\n        _orderFills[v0] = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])];\n        _lastActiveTransaction[address(MEM[v0 + 64])] = block.number;\n        _lastActiveTransaction[address(MEM[v0 + 64])] = block.number;\n        return v0;\n        goto {'0x16350x3ad', '0x15960x3ad', '0x1391', '0x1234', '0x1426', '0x11b9'};\n        require(v23 <= v0);\n        require(_tokens[address(MEM[v0 + 96])] >= MEM[v0 + 128]);\n        v0 = v31 = MEM[v0];\n        v19 = v32 = 4660;\n        v23 = MEM[128 + v0] * MEM[v0 + 32];\n        v25 = v33 = 3227;\n        v27 = v34 = !MEM[v0 + 32];\n        if (MEM[v0 + 32]) {\n            assert(MEM[v0 + 32]);\n            v27 = v23 / MEM[v0 + 32] == MEM[128 + v0];\n        }\n        assert(v0);\n        require(_tokens[address(MEM[v0 + 64])] >= v23 / v0);\n        v35 = _SafeSub(MEM[v0 + 128], _tokens[address(MEM[v0 + 96])]);\n        _tokens[address(MEM[v0 + 96])] = v35;\n        v19 = v36 = 5009;\n        v17 = v37 = _tokens[address(MEM[v0 + 64])];\n        v38 = v39 = 0xde0b6b3a7640000;\n        v40 = v41 = _SafeMul(0xde0b6b3a7640000 - MEM[v0 + 192], MEM[v0 + 128]);\n        assert(v38);\n        v21 = v40 / v38;\n        continue;\n        _tokens[address(MEM[v0 + 64])] = v23;\n        v19 = v42 = 5158;\n        v17 = v43 = _tokens[_feeAccount];\n        v38 = v44 = 0xde0b6b3a7640000;\n        v40 = MEM[192 + v0] * MEM[v0 + 128];\n        v45 = v46 = !MEM[v0 + 128];\n        if (MEM[v0 + 128]) {\n            assert(MEM[v0 + 128]);\n            v45 = v40 / MEM[v0 + 128] == MEM[192 + v0];\n        }\n        require(v45);\n        goto 0x7cc0x3ad;\n        _tokens[_feeAccount] = v23;\n        v47 = v48 = !MEM[v0 + 32];\n        if (MEM[v0 + 32]) {\n            assert(MEM[v0 + 32]);\n            v47 = MEM[128 + v0] * MEM[v0 + 32] / MEM[v0 + 32] == MEM[128 + v0];\n        }\n        require(v47);\n        assert(MEM[v0]);\n        require(MEM[128 + v0] * MEM[v0 + 32] / MEM[v0] <= _tokens[address(MEM[v0 + 64])]);\n        _tokens[address(MEM[v0 + 32])] = _tokens[address(MEM[v0 + 64])] - MEM[128 + v0] * MEM[v0 + 32] / MEM[v0];\n        v19 = v49 = 5526;\n        v17 = _tokens[address(MEM[v0 + 32])];\n        v38 = v50 = 0xde0b6b3a7640000;\n        v51 = MEM[v0];\n        v52 = v53 = 5507;\n        v54 = v55 = MEM[32 + v0] * (0xde0b6b3a7640000 - MEM[v0 + 224]);\n        v56 = v57 = !(0xde0b6b3a7640000 - MEM[v0 + 224]);\n        if (0xde0b6b3a7640000 - MEM[v0 + 224]) {\n            assert(0xde0b6b3a7640000 - MEM[v0 + 224]);\n            v56 = v55 / (0xde0b6b3a7640000 - MEM[v0 + 224]) == MEM[32 + v0];\n        }\n        require(v56);\n        goto 0x157b0x3ad;\n        _tokens[address(MEM[v0 + 32])] = v23;\n        v19 = v58 = 5685;\n        v17 = v59 = _tokens[address(MEM[v0 + 32])];\n        v38 = v60 = 0xde0b6b3a7640000;\n        v51 = v61 = MEM[v0];\n        v52 = v62 = 5507;\n        v54 = MEM[32 + v0] * MEM[v0 + 224];\n        v63 = v64 = !MEM[v0 + 224];\n        if (MEM[v0 + 224]) {\n            assert(MEM[v0 + 224]);\n            v63 = v54 / MEM[v0 + 224] == MEM[32 + v0];\n        }\n        require(v63);\n        v65 = v66 = !v54;\n        if (v54) {\n            assert(v54);\n            v65 = MEM[128 + v0] * v54 / v54 == MEM[128 + v0];\n        }\n        require(v65);\n        assert(v51);\n        v40 = v67 = MEM[128 + v0] * v54 / v51;\n        assert(v38);\n        v27 = v68 = v24 >= v21;\n        goto 0x4d50x3ad;\n    }\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeSub(_lastActiveTransaction[msg.sender], block.number);\n    require(v0 >= _inactivityReleasePeriod);\n    require(_tokens[msg.sender] >= varg1);\n    v1 = _SafeSub(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v2, v3 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v2);\n        require(v3);\n    } else {\n        v4 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v4);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n        goto 0x4d50xdfe;\n    }\n    require(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x674763c) {\n            assert(bool);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x2295115b == v0) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == v0) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == v0) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x4b0bddd2 == v0) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == v0) {\n            tokens(address,address);\n        } else if (0x65e17c9d == v0) {\n            feeAccount();\n        } else if (0x83dbb27b == v0) {\n            invalidOrder(address);\n        } else if (0x893d20e8 == v0) {\n            getOwner();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa293d1e8 == v0) {\n            safeSub(uint256,uint256);\n        } else if (0xb12de559 == v0) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xd05c78da == v0) {\n            safeMul(uint256,uint256);\n        } else if (0xd0e30db0 == v0) {\n            deposit();\n        } else if (0xd5813323 == v0) {\n            traded(bytes32);\n        } else if (0xdd93c74a == v0) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xe6cb9013 == v0) {\n            safeAdd(uint256,uint256);\n        } else if (0xef343588 == v0) {\n            trade(uint256[8],address[4],uint8[2],bytes32[4]);\n        } else if (0xf31174ee == v0) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == v0) {\n            balanceOf(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 11:46 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x5]\nuint256 _inactivityReleasePeriod; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _traded; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0x9]\naddress _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x6] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n// Events\nSetOwner(address, address);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction fallback() public nonPayable { \n    revert();\n}\n\nfunction assert(bool varg0) public nonPayable { \n    require(varg0);\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(_getOwner == msg.sender);\n    emit SetOwner(_getOwner, varg0);\n    _getOwner = varg0;\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    v3 = keccak256(address(this), varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v3]));\n    _withdrawn[v3] = 0x1 | ~0xff & _withdrawn[v3];\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v4, v5 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v3), varg4 & 0xff & 0xff, varg5, varg6);\n    require(v4);\n    require(address(v5) == varg2);\n    if (varg7 > 0xb1a2bc2ec50000) {\n        v6 = v7 = 0xb1a2bc2ec50000;\n    }\n    require(_tokens[varg2] >= varg1);\n    v8 = _SafeSub(varg1, _tokens[varg2]);\n    _tokens[varg2] = v8;\n    v9 = _SafeMul(varg1, v6);\n    assert(0xde0b6b3a7640000);\n    v10 = v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount];\n    if (v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount]) {\n        v10 = v11 = v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= v9 / 0xde0b6b3a7640000;\n        goto 0x4d50x178;\n    }\n    require(v10);\n    _tokens[_feeAccount] += v9 / 0xde0b6b3a7640000;\n    v12 = _SafeMul(varg1, 0xde0b6b3a7640000 - v6);\n    assert(0xde0b6b3a7640000);\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v13, v14 = varg0.transfer(varg2, v12 / 0xde0b6b3a7640000).gas(msg.gas - 710);\n        require(v13);\n        require(v14);\n    } else {\n        v15 = varg2.call().value(v12 / 0xde0b6b3a7640000).gas(2300 * !(v12 / 0xde0b6b3a7640000));\n        require(v15);\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, v12 / 0xde0b6b3a7640000, _lastActiveTransaction[varg0]);\n    return 0;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    _lastActiveTransaction[msg.sender] = block.number;\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(_getOwner == msg.sender);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction owner() public nonPayable { \n    return _getOwner;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeSub(varg1, varg0);\n    return v0;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeMul(varg1, varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[0] = msg.sender;\n    MEM[32] = 0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction traded(bytes32 varg0) public nonPayable { \n    return 0xff & _traded[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg0 <= 0xf4240);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, varg0);\n    return v0;\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = 435;\n    v0 = v2 = MEM[64];\n    CALLDATACOPY(v2, 4, 256);\n    v0 = v3 = MEM[64];\n    CALLDATACOPY(v3, 260, 128);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 388, 64);\n    v0 = v5 = MEM[64];\n    CALLDATACOPY(v5, 452, 128);\n    v0 = v6 = 0;\n    v7 = v8 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v7 = v9 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v7);\n    require(_invalidOrder[address(MEM[v3 + 64])] <= MEM[v2 + 96]);\n    v0 = v10 = keccak256(address(this), address(MEM[v3]), MEM[v2], address(MEM[v3 + 32]), MEM[v2 + 32], MEM[v2 + 64], MEM[v2 + 96], address(MEM[v3 + 64]));\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v11, v12 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v10), MEM[v4] & 0xff, MEM[v5], MEM[v5 + 32]);\n    require(v11);\n    require(address(v12) == address(MEM[v3 + 64]));\n    v0 = v13 = keccak256(v10, MEM[v2 + 128], address(MEM[v3 + 96]), MEM[v2 + 160]);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v14, v15 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v13), MEM[v4 + 32] & 0xff, MEM[v5 + 64], MEM[v5 + 96]);\n    require(v14);\n    require(address(v15) == address(MEM[v3 + 96]));\n    require(!(0xff & _traded[v13]));\n    _traded[v13] = 0x1 | ~0xff & _traded[v13];\n    if (MEM[192 + v2] > 0x16345785d8a0000) {\n        MEM[v2 + 192] = 0x16345785d8a0000;\n    }\n    if (MEM[v2 + 224] > 0x16345785d8a0000) {\n        MEM[v2 + 224] = 0x16345785d8a0000;\n    }\n    v0 = v16 = MEM[v2];\n    v17 = v18 = _orderFills[v10];\n    v19 = v20 = 4537;\n    v21 = v22 = MEM[128 + v2];\n    while (1) {\n        v23 = v24 = v21 + v17;\n        v25 = v26 = 3227;\n        v27 = v28 = v24 >= v17;\n        if (v24 < v17) {\n            goto 0xc960x3ad;\n        }\n        if (v27) {\n            break;\n        }\n        require(v27);\n        _tokens[address(MEM[v0 + 32])] = v23;\n        v29 = v30 = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= _orderFills[address(MEM[v0 + 32])];\n        if (MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= _orderFills[address(MEM[v0 + 32])]) {\n            v29 = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= MEM[128 + v0];\n            goto 0x4d50x11afB0x16350x3ad;\n        }\n        require(v29);\n        _orderFills[v0] = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])];\n        _lastActiveTransaction[address(MEM[v0 + 64])] = block.number;\n        _lastActiveTransaction[address(MEM[v0 + 64])] = block.number;\n        return v0;\n        goto {'0x16350x3ad', '0x15960x3ad', '0x1391', '0x1234', '0x1426', '0x11b9'};\n        require(v23 <= v0);\n        require(_tokens[address(MEM[v0 + 96])] >= MEM[v0 + 128]);\n        v0 = v31 = MEM[v0];\n        v19 = v32 = 4660;\n        v23 = MEM[128 + v0] * MEM[v0 + 32];\n        v25 = v33 = 3227;\n        v27 = v34 = !MEM[v0 + 32];\n        if (MEM[v0 + 32]) {\n            assert(MEM[v0 + 32]);\n            v27 = v23 / MEM[v0 + 32] == MEM[128 + v0];\n        }\n        assert(v0);\n        require(_tokens[address(MEM[v0 + 64])] >= v23 / v0);\n        v35 = _SafeSub(MEM[v0 + 128], _tokens[address(MEM[v0 + 96])]);\n        _tokens[address(MEM[v0 + 96])] = v35;\n        v19 = v36 = 5009;\n        v17 = v37 = _tokens[address(MEM[v0 + 64])];\n        v38 = v39 = 0xde0b6b3a7640000;\n        v40 = v41 = _SafeMul(0xde0b6b3a7640000 - MEM[v0 + 192], MEM[v0 + 128]);\n        assert(v38);\n        v21 = v40 / v38;\n        continue;\n        _tokens[address(MEM[v0 + 64])] = v23;\n        v19 = v42 = 5158;\n        v17 = v43 = _tokens[_feeAccount];\n        v38 = v44 = 0xde0b6b3a7640000;\n        v40 = MEM[192 + v0] * MEM[v0 + 128];\n        v45 = v46 = !MEM[v0 + 128];\n        if (MEM[v0 + 128]) {\n            assert(MEM[v0 + 128]);\n            v45 = v40 / MEM[v0 + 128] == MEM[192 + v0];\n        }\n        require(v45);\n        goto 0x7cc0x3ad;\n        _tokens[_feeAccount] = v23;\n        v47 = v48 = !MEM[v0 + 32];\n        if (MEM[v0 + 32]) {\n            assert(MEM[v0 + 32]);\n            v47 = MEM[128 + v0] * MEM[v0 + 32] / MEM[v0 + 32] == MEM[128 + v0];\n        }\n        require(v47);\n        assert(MEM[v0]);\n        require(MEM[128 + v0] * MEM[v0 + 32] / MEM[v0] <= _tokens[address(MEM[v0 + 64])]);\n        _tokens[address(MEM[v0 + 32])] = _tokens[address(MEM[v0 + 64])] - MEM[128 + v0] * MEM[v0 + 32] / MEM[v0];\n        v19 = v49 = 5526;\n        v17 = _tokens[address(MEM[v0 + 32])];\n        v38 = v50 = 0xde0b6b3a7640000;\n        v51 = MEM[v0];\n        v52 = v53 = 5507;\n        v54 = v55 = MEM[32 + v0] * (0xde0b6b3a7640000 - MEM[v0 + 224]);\n        v56 = v57 = !(0xde0b6b3a7640000 - MEM[v0 + 224]);\n        if (0xde0b6b3a7640000 - MEM[v0 + 224]) {\n            assert(0xde0b6b3a7640000 - MEM[v0 + 224]);\n            v56 = v55 / (0xde0b6b3a7640000 - MEM[v0 + 224]) == MEM[32 + v0];\n        }\n        require(v56);\n        goto 0x157b0x3ad;\n        _tokens[address(MEM[v0 + 32])] = v23;\n        v19 = v58 = 5685;\n        v17 = v59 = _tokens[address(MEM[v0 + 32])];\n        v38 = v60 = 0xde0b6b3a7640000;\n        v51 = v61 = MEM[v0];\n        v52 = v62 = 5507;\n        v54 = MEM[32 + v0] * MEM[v0 + 224];\n        v63 = v64 = !MEM[v0 + 224];\n        if (MEM[v0 + 224]) {\n            assert(MEM[v0 + 224]);\n            v63 = v54 / MEM[v0 + 224] == MEM[32 + v0];\n        }\n        require(v63);\n        v65 = v66 = !v54;\n        if (v54) {\n            assert(v54);\n            v65 = MEM[128 + v0] * v54 / v54 == MEM[128 + v0];\n        }\n        require(v65);\n        assert(v51);\n        v40 = v67 = MEM[128 + v0] * v54 / v51;\n        assert(v38);\n        v27 = v68 = v24 >= v21;\n        goto 0x4d50x3ad;\n    }\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeSub(_lastActiveTransaction[msg.sender], block.number);\n    require(v0 >= _inactivityReleasePeriod);\n    require(_tokens[msg.sender] >= varg1);\n    v1 = _SafeSub(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v2, v3 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v2);\n        require(v3);\n    } else {\n        v4 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v4);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n        goto 0x4d50xdfe;\n    }\n    require(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x674763c) {\n            assert(bool);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x2295115b == v0) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == v0) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == v0) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x4b0bddd2 == v0) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == v0) {\n            tokens(address,address);\n        } else if (0x65e17c9d == v0) {\n            feeAccount();\n        } else if (0x83dbb27b == v0) {\n            invalidOrder(address);\n        } else if (0x893d20e8 == v0) {\n            getOwner();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa293d1e8 == v0) {\n            safeSub(uint256,uint256);\n        } else if (0xb12de559 == v0) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xd05c78da == v0) {\n            safeMul(uint256,uint256);\n        } else if (0xd0e30db0 == v0) {\n            deposit();\n        } else if (0xd5813323 == v0) {\n            traded(bytes32);\n        } else if (0xdd93c74a == v0) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xe6cb9013 == v0) {\n            safeAdd(uint256,uint256);\n        } else if (0xef343588 == v0) {\n            trade(uint256[8],address[4],uint8[2],bytes32[4]);\n        } else if (0xf31174ee == v0) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == v0) {\n            balanceOf(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 11:46 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x5]\nuint256 _inactivityReleasePeriod; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _traded; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0x9]\naddress _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x6] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n// Events\nSetOwner(address, address);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction fallback() public nonPayable { \n    revert();\n}\n\nfunction assert(bool varg0) public nonPayable { \n    require(varg0);\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(_getOwner == msg.sender);\n    emit SetOwner(_getOwner, varg0);\n    _getOwner = varg0;\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    v3 = keccak256(address(this), varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v3]));\n    _withdrawn[v3] = 0x1 | ~0xff & _withdrawn[v3];\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v4, v5 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v3), varg4 & 0xff & 0xff, varg5, varg6);\n    require(v4);\n    require(address(v5) == varg2);\n    if (varg7 > 0xb1a2bc2ec50000) {\n        v6 = v7 = 0xb1a2bc2ec50000;\n    }\n    require(_tokens[varg2] >= varg1);\n    v8 = _SafeSub(varg1, _tokens[varg2]);\n    _tokens[varg2] = v8;\n    v9 = _SafeMul(varg1, v6);\n    assert(0xde0b6b3a7640000);\n    v10 = v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount];\n    if (v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount]) {\n        v10 = v11 = v9 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= v9 / 0xde0b6b3a7640000;\n        goto 0x4d50x178;\n    }\n    require(v10);\n    _tokens[_feeAccount] += v9 / 0xde0b6b3a7640000;\n    v12 = _SafeMul(varg1, 0xde0b6b3a7640000 - v6);\n    assert(0xde0b6b3a7640000);\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v13, v14 = varg0.transfer(varg2, v12 / 0xde0b6b3a7640000).gas(msg.gas - 710);\n        require(v13);\n        require(v14);\n    } else {\n        v15 = varg2.call().value(v12 / 0xde0b6b3a7640000).gas(2300 * !(v12 / 0xde0b6b3a7640000));\n        require(v15);\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, v12 / 0xde0b6b3a7640000, _lastActiveTransaction[varg0]);\n    return 0;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    _lastActiveTransaction[msg.sender] = block.number;\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(_getOwner == msg.sender);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction owner() public nonPayable { \n    return _getOwner;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeSub(varg1, varg0);\n    return v0;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeMul(varg1, varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[0] = msg.sender;\n    MEM[32] = 0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction traded(bytes32 varg0) public nonPayable { \n    return 0xff & _traded[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = v2 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg0 <= 0xf4240);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, varg0);\n    return v0;\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = 435;\n    v0 = v2 = MEM[64];\n    CALLDATACOPY(v2, 4, 256);\n    v0 = v3 = MEM[64];\n    CALLDATACOPY(v3, 260, 128);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 388, 64);\n    v0 = v5 = MEM[64];\n    CALLDATACOPY(v5, 452, 128);\n    v0 = v6 = 0;\n    v7 = v8 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v7 = v9 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v7);\n    require(_invalidOrder[address(MEM[v3 + 64])] <= MEM[v2 + 96]);\n    v0 = v10 = keccak256(address(this), address(MEM[v3]), MEM[v2], address(MEM[v3 + 32]), MEM[v2 + 32], MEM[v2 + 64], MEM[v2 + 96], address(MEM[v3 + 64]));\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v11, v12 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v10), MEM[v4] & 0xff, MEM[v5], MEM[v5 + 32]);\n    require(v11);\n    require(address(v12) == address(MEM[v3 + 64]));\n    v0 = v13 = keccak256(v10, MEM[v2 + 128], address(MEM[v3 + 96]), MEM[v2 + 160]);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v14, v15 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v13), MEM[v4 + 32] & 0xff, MEM[v5 + 64], MEM[v5 + 96]);\n    require(v14);\n    require(address(v15) == address(MEM[v3 + 96]));\n    require(!(0xff & _traded[v13]));\n    _traded[v13] = 0x1 | ~0xff & _traded[v13];\n    if (MEM[192 + v2] > 0x16345785d8a0000) {\n        MEM[v2 + 192] = 0x16345785d8a0000;\n    }\n    if (MEM[v2 + 224] > 0x16345785d8a0000) {\n        MEM[v2 + 224] = 0x16345785d8a0000;\n    }\n    v0 = v16 = MEM[v2];\n    v17 = v18 = _orderFills[v10];\n    v19 = v20 = 4537;\n    v21 = v22 = MEM[128 + v2];\n    while (1) {\n        v23 = v24 = v21 + v17;\n        v25 = v26 = 3227;\n        v27 = v28 = v24 >= v17;\n        if (v24 < v17) {\n            goto 0xc960x3ad;\n        }\n        if (v27) {\n            break;\n        }\n        require(v27);\n        _tokens[address(MEM[v0 + 32])] = v23;\n        v29 = v30 = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= _orderFills[address(MEM[v0 + 32])];\n        if (MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= _orderFills[address(MEM[v0 + 32])]) {\n            v29 = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])] >= MEM[128 + v0];\n            goto 0x4d50x11afB0x16350x3ad;\n        }\n        require(v29);\n        _orderFills[v0] = MEM[128 + v0] + _orderFills[address(MEM[v0 + 32])];\n        _lastActiveTransaction[address(MEM[v0 + 64])] = block.number;\n        _lastActiveTransaction[address(MEM[v0 + 64])] = block.number;\n        return v0;\n        goto {'0x16350x3ad', '0x15960x3ad', '0x1391', '0x1234', '0x1426', '0x11b9'};\n        require(v23 <= v0);\n        require(_tokens[address(MEM[v0 + 96])] >= MEM[v0 + 128]);\n        v0 = v31 = MEM[v0];\n        v19 = v32 = 4660;\n        v23 = MEM[128 + v0] * MEM[v0 + 32];\n        v25 = v33 = 3227;\n        v27 = v34 = !MEM[v0 + 32];\n        if (MEM[v0 + 32]) {\n            assert(MEM[v0 + 32]);\n            v27 = v23 / MEM[v0 + 32] == MEM[128 + v0];\n        }\n        assert(v0);\n        require(_tokens[address(MEM[v0 + 64])] >= v23 / v0);\n        v35 = _SafeSub(MEM[v0 + 128], _tokens[address(MEM[v0 + 96])]);\n        _tokens[address(MEM[v0 + 96])] = v35;\n        v19 = v36 = 5009;\n        v17 = v37 = _tokens[address(MEM[v0 + 64])];\n        v38 = v39 = 0xde0b6b3a7640000;\n        v40 = v41 = _SafeMul(0xde0b6b3a7640000 - MEM[v0 + 192], MEM[v0 + 128]);\n        assert(v38);\n        v21 = v40 / v38;\n        continue;\n        _tokens[address(MEM[v0 + 64])] = v23;\n        v19 = v42 = 5158;\n        v17 = v43 = _tokens[_feeAccount];\n        v38 = v44 = 0xde0b6b3a7640000;\n        v40 = MEM[192 + v0] * MEM[v0 + 128];\n        v45 = v46 = !MEM[v0 + 128];\n        if (MEM[v0 + 128]) {\n            assert(MEM[v0 + 128]);\n            v45 = v40 / MEM[v0 + 128] == MEM[192 + v0];\n        }\n        require(v45);\n        goto 0x7cc0x3ad;\n        _tokens[_feeAccount] = v23;\n        v47 = v48 = !MEM[v0 + 32];\n        if (MEM[v0 + 32]) {\n            assert(MEM[v0 + 32]);\n            v47 = MEM[128 + v0] * MEM[v0 + 32] / MEM[v0 + 32] == MEM[128 + v0];\n        }\n        require(v47);\n        assert(MEM[v0]);\n        require(MEM[128 + v0] * MEM[v0 + 32] / MEM[v0] <= _tokens[address(MEM[v0 + 64])]);\n        _tokens[address(MEM[v0 + 32])] = _tokens[address(MEM[v0 + 64])] - MEM[128 + v0] * MEM[v0 + 32] / MEM[v0];\n        v19 = v49 = 5526;\n        v17 = _tokens[address(MEM[v0 + 32])];\n        v38 = v50 = 0xde0b6b3a7640000;\n        v51 = MEM[v0];\n        v52 = v53 = 5507;\n        v54 = v55 = MEM[32 + v0] * (0xde0b6b3a7640000 - MEM[v0 + 224]);\n        v56 = v57 = !(0xde0b6b3a7640000 - MEM[v0 + 224]);\n        if (0xde0b6b3a7640000 - MEM[v0 + 224]) {\n            assert(0xde0b6b3a7640000 - MEM[v0 + 224]);\n            v56 = v55 / (0xde0b6b3a7640000 - MEM[v0 + 224]) == MEM[32 + v0];\n        }\n        require(v56);\n        goto 0x157b0x3ad;\n        _tokens[address(MEM[v0 + 32])] = v23;\n        v19 = v58 = 5685;\n        v17 = v59 = _tokens[address(MEM[v0 + 32])];\n        v38 = v60 = 0xde0b6b3a7640000;\n        v51 = v61 = MEM[v0];\n        v52 = v62 = 5507;\n        v54 = MEM[32 + v0] * MEM[v0 + 224];\n        v63 = v64 = !MEM[v0 + 224];\n        if (MEM[v0 + 224]) {\n            assert(MEM[v0 + 224]);\n            v63 = v54 / MEM[v0 + 224] == MEM[32 + v0];\n        }\n        require(v63);\n        v65 = v66 = !v54;\n        if (v54) {\n            assert(v54);\n            v65 = MEM[128 + v0] * v54 / v54 == MEM[128 + v0];\n        }\n        require(v65);\n        assert(v51);\n        v40 = v67 = MEM[128 + v0] * v54 / v51;\n        assert(v38);\n        v27 = v68 = v24 >= v21;\n        goto 0x4d50x3ad;\n    }\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeSub(_lastActiveTransaction[msg.sender], block.number);\n    require(v0 >= _inactivityReleasePeriod);\n    require(_tokens[msg.sender] >= varg1);\n    v1 = _SafeSub(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v2, v3 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v2);\n        require(v3);\n    } else {\n        v4 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v4);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n        goto 0x4d50xdfe;\n    }\n    require(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x674763c) {\n            assert(bool);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x2295115b == v0) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == v0) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == v0) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x4b0bddd2 == v0) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == v0) {\n            tokens(address,address);\n        } else if (0x65e17c9d == v0) {\n            feeAccount();\n        } else if (0x83dbb27b == v0) {\n            invalidOrder(address);\n        } else if (0x893d20e8 == v0) {\n            getOwner();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa293d1e8 == v0) {\n            safeSub(uint256,uint256);\n        } else if (0xb12de559 == v0) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xd05c78da == v0) {\n            safeMul(uint256,uint256);\n        } else if (0xd0e30db0 == v0) {\n            deposit();\n        } else if (0xd5813323 == v0) {\n            traded(bytes32);\n        } else if (0xdd93c74a == v0) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xe6cb9013 == v0) {\n            safeAdd(uint256,uint256);\n        } else if (0xef343588 == v0) {\n            trade(uint256[8],address[4],uint8[2],bytes32[4]);\n        } else if (0xf31174ee == v0) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == v0) {\n            balanceOf(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 24.942550897598267,
	"usage": {
		"completion_tokens": 499,
		"prompt_tokens": 5405,
		"total_tokens": 5904
	}
}