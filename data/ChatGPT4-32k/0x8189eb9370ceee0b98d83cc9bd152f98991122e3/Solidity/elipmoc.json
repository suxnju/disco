{
	"address": "0x8189eb9370ceee0b98d83cc9bd152f98991122e3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a Solidity smart contract that corresponds to the provided decompiled bytecode:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function withdrawTokens(address token, uint256 amount, address to) public payable {\n        require(msg.sender == _owner, \"Not owner\");\n        IERC20 tokenContract = IERC20(token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        require(balance >= amount, \"Insufficient funds\");\n        tokenContract.transfer(to, amount);\n    }\n\n    function deposit() public payable { \n        // Accept any incoming amount\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner, \"Not owner\");\n        require(newOwner != address(0), \"New owner is zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function withdraw(uint256 amount, address payable to) public {\n        require(msg.sender == _owner, \"Not owner\");\n        require(address(this).balance >= amount, \"Insufficient balance\");\n        to.transfer(amount);\n    }\n\n    function kill() public {\n        require(msg.sender == _owner, \"Not owner\");\n        selfdestruct(msg.sender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\nPlease note that the function `__function_selector__` is not included here as it's not a part of the original Solidity code and is typically not required in Solidity, given that function dispatch is handled by the EVM based on the 4-byte function selector in the call data. The fallback function is also not included in the above contract as it simply reverts any transactions, which is the default behavior for contracts in Solidity 0.6.0 and above.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461283,
	"id": "chatcmpl-8R45rIELLeTEnGg94f3zqRPwmgaf2",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.21 14:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction withdrawTokens(address varg0, uint256 varg1, address varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 >= varg1, 'insufficient funds');\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(varg2, varg1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction deposit() public payable { \n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdraw(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg0, 'insufficient balance');\n    v0 = varg1.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction kill() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    selfdestruct(_owner);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xf714ce == function_selector >> 224) {\n            withdraw(uint256,address);\n        } else if (0x41c0e1b5 == function_selector >> 224) {\n            kill();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x9bc5c509 == function_selector >> 224) {\n            withdrawTokens(address,uint256,address);\n        } else if (0xd0e30db0 == function_selector >> 224) {\n            deposit();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.21 14:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction withdrawTokens(address varg0, uint256 varg1, address varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 >= varg1, 'insufficient funds');\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(varg2, varg1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction deposit() public payable { \n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdraw(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg0, 'insufficient balance');\n    v0 = varg1.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction kill() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    selfdestruct(_owner);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xf714ce == function_selector >> 224) {\n            withdraw(uint256,address);\n        } else if (0x41c0e1b5 == function_selector >> 224) {\n            kill();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x9bc5c509 == function_selector >> 224) {\n            withdrawTokens(address,uint256,address);\n        } else if (0xd0e30db0 == function_selector >> 224) {\n            deposit();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.21 14:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction withdrawTokens(address varg0, uint256 varg1, address varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner);\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 >= varg1, 'insufficient funds');\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(varg2, varg1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction deposit() public payable { \n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdraw(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg0, 'insufficient balance');\n    v0 = varg1.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction kill() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n    selfdestruct(_owner);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xf714ce == function_selector >> 224) {\n            withdraw(uint256,address);\n        } else if (0x41c0e1b5 == function_selector >> 224) {\n            kill();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x9bc5c509 == function_selector >> 224) {\n            withdrawTokens(address,uint256,address);\n        } else if (0xd0e30db0 == function_selector >> 224) {\n            deposit();\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 31.223132848739624,
	"usage": {
		"completion_tokens": 442,
		"prompt_tokens": 775,
		"total_tokens": 1217
	}
}