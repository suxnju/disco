{
	"address": "0x2797b0fa64cd56e45fb589fc3743177348397817",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, the corresponding Solidity code may look like the following:\n\nPlease note that the function names `0xac0`, `0xbea`, `0xd33`, `0xd69` are not valid Solidity function names, and have been replaced with `func_ac0`, `func_bea`, `func_d33`, and `func_d69` respectively. The decompiled code also indicates that the contract interacts with a token, so an ERC20 interface is included for completeness.\n\n```solidity\npragma solidity ^0.8.7;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract MyContract {\n    uint256 private _eth_seed_amount;\n    uint256 private _traded_token_seed_amount;\n    uint256 private _commission_ratio;\n    uint256 private _get_amount_sell;\n    uint256 private stor_6;\n    address private _admin;\n    bool private _eth_is_seeded;\n    bool private _traded_token_is_seeded;\n    bool private _trading_deactivated;\n    IERC20 private _traded_token;\n\n    // Constructor and functions go here\n\n    constructor(address admin, address traded_token) {\n        _admin = admin;\n        _traded_token = IERC20(traded_token);\n    }\n\n    function reactivate_trading() external {\n        require(msg.sender == _admin, \"Not admin\");\n        require(_trading_deactivated, \"Trading is not deactivated\");\n        _trading_deactivated = false;\n    }\n\n    // Other functions...\n\n    function func_ac0(uint256 varg0, address varg1) private {\n        require(varg0 <= stor_6, \"Insufficient funds\");\n        stor_6 -= varg0;\n        bool success = _traded_token.transfer(varg1, varg0);\n        require(success, \"Transfer failed\");\n    }\n\n    function func_bea(uint256 varg0, address payable varg1) private {\n        require(varg0 <= _get_amount_sell, \"Insufficient funds\");\n        _get_amount_sell -= varg0;\n        (bool success,) = varg1.call{value: varg0}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function func_d33() private {\n        require(_get_amount_sell + msg.value >= _get_amount_sell, \"Overflow\");\n        _get_amount_sell += msg.value;\n    }\n\n    function func_d69(uint256 varg0, address varg1) private {\n        uint256 v0 = stor_6 + varg0;\n        require(v0 >= stor_6, \"Overflow\");\n        stor_6 = v0;\n        bool success = _traded_token.transferFrom(varg1, address(this), varg0);\n        require(success, \"Transfer failed\");\n    }\n\n    // Other functions...\n}\n```\n\nThis contract appears to be a kind of decentralized exchange or automated market maker. It allows an admin to seed ETH and a traded token, after which users can trade between these two assets. The contract also allows the admin to deactivate and reactivate trading, and to withdraw both types of assets. The contract takes a commission on trades, the ratio of which is stored in `_commission_ratio`.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465967,
	"id": "chatcmpl-8R5JP8ovCQ1lSaQgVv0zgRz0GYaFV",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 19:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eth_seed_amount; // STORAGE[0x2]\nuint256 _traded_token_seed_amount; // STORAGE[0x3]\nuint256 _commission_ratio; // STORAGE[0x4]\nuint256 _get_amount_sell; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint8 _eth_is_seeded; // STORAGE[0x7] bytes 0 to 0\nuint8 _traded_token_is_seeded; // STORAGE[0x7] bytes 1 to 1\nuint8 _trading_deactivated; // STORAGE[0x7] bytes 2 to 2\naddress _traded_token; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    require(_trading_deactivated == 0);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    assert((_get_amount_sell + msg.value << 1) * _get_amount_sell);\n    0xd33();\n    0xac0(msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, msg.sender);\n    0xac0(msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) - msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, _admin);\n}\n\nfunction reactivate_trading() public nonPayable { \n    require(msg.sender == _admin);\n    require(_trading_deactivated);\n    _trading_deactivated = 0;\n}\n\nfunction deactivate_trading() public nonPayable { \n    require(msg.sender == _admin);\n    require(!_trading_deactivated);\n    _trading_deactivated = 1;\n}\n\nfunction withdraw_token(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    0xac0(varg0, _admin);\n}\n\nfunction withdraw_eth(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    0xbea(varg0, _admin);\n}\n\nfunction eth_is_seeded() public nonPayable { \n    return _eth_is_seeded;\n}\n\nfunction seed_eth() public payable { \n    require(msg.sender == _admin);\n    require(!_eth_is_seeded);\n    require(msg.value == _eth_seed_amount);\n    _eth_is_seeded = 1;\n    0xd33();\n}\n\nfunction traded_token_is_seeded() public nonPayable { \n    return _traded_token_is_seeded;\n}\n\nfunction get_amount_buy(uint256 varg0) public nonPayable { \n    assert((_get_amount_sell + varg0 << 1) * _get_amount_sell);\n    return varg0 * stor_6 * (_get_amount_sell + varg0 + _get_amount_sell) / ((_get_amount_sell + varg0 << 1) * _get_amount_sell);\n}\n\nfunction seed_additional_token(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    0xd69(varg0, this, msg.sender);\n}\n\nfunction sell_tokens(uint256 varg0) public nonPayable { \n    require(_trading_deactivated == 0);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    assert(stor_6 + (stor_6 + varg0));\n    0xd69(varg0, this, msg.sender);\n    0xbea((_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, msg.sender);\n    0xbea((_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) - (_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, _admin);\n}\n\nfunction commission_ratio() public nonPayable { \n    return _commission_ratio;\n}\n\nfunction traded_token() public nonPayable { \n    return _traded_token;\n}\n\nfunction get_amount_sell(uint256 varg0) public nonPayable { \n    assert(stor_6 + (stor_6 + varg0));\n    return (_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0));\n}\n\nfunction traded_token_seed_amount() public nonPayable { \n    return _traded_token_seed_amount;\n}\n\nfunction seed_additional_eth() public payable { \n    require(msg.sender == _admin);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    0xd33();\n}\n\nfunction eth_seed_amount() public nonPayable { \n    return _eth_seed_amount;\n}\n\nfunction trading_deactivated() public nonPayable { \n    return _trading_deactivated;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction seed_traded_token() public nonPayable { \n    require(msg.sender == _admin);\n    require(!_traded_token_is_seeded);\n    _traded_token_is_seeded = 1;\n    0xd69(_traded_token_seed_amount, this, msg.sender);\n}\n\nfunction 0xac0(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= stor_6);\n    stor_6 = stor_6 - varg0;\n    v0 = address(varg1);\n    require(_traded_token.code.size);\n    v1, v2 = _traded_token.transfer(v0, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    return ;\n}\n\nfunction 0xbea(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= _get_amount_sell);\n    _get_amount_sell = _get_amount_sell - varg0;\n    v0 = address(varg1).call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0xd33() private { \n    assert(_get_amount_sell + msg.value >= _get_amount_sell);\n    _get_amount_sell = _get_amount_sell + msg.value;\n    return ;\n}\n\nfunction 0xd69(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = stor_6 + varg0;\n    assert(v0 >= stor_6);\n    stor_6 = v0;\n    v1 = address(varg2);\n    v2 = address(varg1);\n    require(_traded_token.code.size);\n    v3, v4 = _traded_token.transferFrom(v1, v2, varg0).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v4);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x608a48a == function_selector) {\n            reactivate_trading();\n        } else if (0x10c452ef == function_selector) {\n            deactivate_trading();\n        } else if (0x164fa4ef == function_selector) {\n            withdraw_token(uint256);\n        } else if (0x30a95e67 == function_selector) {\n            withdraw_eth(uint256);\n        } else if (0x3bbb44ca == function_selector) {\n            eth_is_seeded();\n        } else if (0x3f5ab2fe == function_selector) {\n            seed_eth();\n        } else if (0x6f18d3f5 == function_selector) {\n            traded_token_is_seeded();\n        } else if (0x7b5825d5 == function_selector) {\n            get_amount_buy(uint256);\n        } else if (0x7e63dd86 == function_selector) {\n            seed_additional_token(uint256);\n        } else if (0x82803c22 == function_selector) {\n            sell_tokens(uint256);\n        } else if (0x877ddd77 == function_selector) {\n            commission_ratio();\n        } else if (0x8d5cc102 == function_selector) {\n            traded_token();\n        } else if (0xa45230ec == function_selector) {\n            get_amount_sell(uint256);\n        } else if (0xab004a97 == function_selector) {\n            traded_token_seed_amount();\n        } else if (0xac9c80af == function_selector) {\n            seed_additional_eth();\n        } else if (0xc0f57529 == function_selector) {\n            eth_seed_amount();\n        } else if (0xd3fd311e == function_selector) {\n            trading_deactivated();\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xf9b35ca3 == function_selector) {\n            seed_traded_token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 19:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eth_seed_amount; // STORAGE[0x2]\nuint256 _traded_token_seed_amount; // STORAGE[0x3]\nuint256 _commission_ratio; // STORAGE[0x4]\nuint256 _get_amount_sell; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint8 _eth_is_seeded; // STORAGE[0x7] bytes 0 to 0\nuint8 _traded_token_is_seeded; // STORAGE[0x7] bytes 1 to 1\nuint8 _trading_deactivated; // STORAGE[0x7] bytes 2 to 2\naddress _traded_token; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    require(_trading_deactivated == 0);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    assert((_get_amount_sell + msg.value << 1) * _get_amount_sell);\n    0xd33();\n    0xac0(msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, msg.sender);\n    0xac0(msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) - msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, _admin);\n}\n\nfunction reactivate_trading() public nonPayable { \n    require(msg.sender == _admin);\n    require(_trading_deactivated);\n    _trading_deactivated = 0;\n}\n\nfunction deactivate_trading() public nonPayable { \n    require(msg.sender == _admin);\n    require(!_trading_deactivated);\n    _trading_deactivated = 1;\n}\n\nfunction withdraw_token(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    0xac0(varg0, _admin);\n}\n\nfunction withdraw_eth(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    0xbea(varg0, _admin);\n}\n\nfunction eth_is_seeded() public nonPayable { \n    return _eth_is_seeded;\n}\n\nfunction seed_eth() public payable { \n    require(msg.sender == _admin);\n    require(!_eth_is_seeded);\n    require(msg.value == _eth_seed_amount);\n    _eth_is_seeded = 1;\n    0xd33();\n}\n\nfunction traded_token_is_seeded() public nonPayable { \n    return _traded_token_is_seeded;\n}\n\nfunction get_amount_buy(uint256 varg0) public nonPayable { \n    assert((_get_amount_sell + varg0 << 1) * _get_amount_sell);\n    return varg0 * stor_6 * (_get_amount_sell + varg0 + _get_amount_sell) / ((_get_amount_sell + varg0 << 1) * _get_amount_sell);\n}\n\nfunction seed_additional_token(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    0xd69(varg0, this, msg.sender);\n}\n\nfunction sell_tokens(uint256 varg0) public nonPayable { \n    require(_trading_deactivated == 0);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    assert(stor_6 + (stor_6 + varg0));\n    0xd69(varg0, this, msg.sender);\n    0xbea((_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, msg.sender);\n    0xbea((_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) - (_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, _admin);\n}\n\nfunction commission_ratio() public nonPayable { \n    return _commission_ratio;\n}\n\nfunction traded_token() public nonPayable { \n    return _traded_token;\n}\n\nfunction get_amount_sell(uint256 varg0) public nonPayable { \n    assert(stor_6 + (stor_6 + varg0));\n    return (_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0));\n}\n\nfunction traded_token_seed_amount() public nonPayable { \n    return _traded_token_seed_amount;\n}\n\nfunction seed_additional_eth() public payable { \n    require(msg.sender == _admin);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    0xd33();\n}\n\nfunction eth_seed_amount() public nonPayable { \n    return _eth_seed_amount;\n}\n\nfunction trading_deactivated() public nonPayable { \n    return _trading_deactivated;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction seed_traded_token() public nonPayable { \n    require(msg.sender == _admin);\n    require(!_traded_token_is_seeded);\n    _traded_token_is_seeded = 1;\n    0xd69(_traded_token_seed_amount, this, msg.sender);\n}\n\nfunction 0xac0(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= stor_6);\n    stor_6 = stor_6 - varg0;\n    v0 = address(varg1);\n    require(_traded_token.code.size);\n    v1, v2 = _traded_token.transfer(v0, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    return ;\n}\n\nfunction 0xbea(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= _get_amount_sell);\n    _get_amount_sell = _get_amount_sell - varg0;\n    v0 = address(varg1).call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0xd33() private { \n    assert(_get_amount_sell + msg.value >= _get_amount_sell);\n    _get_amount_sell = _get_amount_sell + msg.value;\n    return ;\n}\n\nfunction 0xd69(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = stor_6 + varg0;\n    assert(v0 >= stor_6);\n    stor_6 = v0;\n    v1 = address(varg2);\n    v2 = address(varg1);\n    require(_traded_token.code.size);\n    v3, v4 = _traded_token.transferFrom(v1, v2, varg0).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v4);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x608a48a == function_selector) {\n            reactivate_trading();\n        } else if (0x10c452ef == function_selector) {\n            deactivate_trading();\n        } else if (0x164fa4ef == function_selector) {\n            withdraw_token(uint256);\n        } else if (0x30a95e67 == function_selector) {\n            withdraw_eth(uint256);\n        } else if (0x3bbb44ca == function_selector) {\n            eth_is_seeded();\n        } else if (0x3f5ab2fe == function_selector) {\n            seed_eth();\n        } else if (0x6f18d3f5 == function_selector) {\n            traded_token_is_seeded();\n        } else if (0x7b5825d5 == function_selector) {\n            get_amount_buy(uint256);\n        } else if (0x7e63dd86 == function_selector) {\n            seed_additional_token(uint256);\n        } else if (0x82803c22 == function_selector) {\n            sell_tokens(uint256);\n        } else if (0x877ddd77 == function_selector) {\n            commission_ratio();\n        } else if (0x8d5cc102 == function_selector) {\n            traded_token();\n        } else if (0xa45230ec == function_selector) {\n            get_amount_sell(uint256);\n        } else if (0xab004a97 == function_selector) {\n            traded_token_seed_amount();\n        } else if (0xac9c80af == function_selector) {\n            seed_additional_eth();\n        } else if (0xc0f57529 == function_selector) {\n            eth_seed_amount();\n        } else if (0xd3fd311e == function_selector) {\n            trading_deactivated();\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xf9b35ca3 == function_selector) {\n            seed_traded_token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 19:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _eth_seed_amount; // STORAGE[0x2]\nuint256 _traded_token_seed_amount; // STORAGE[0x3]\nuint256 _commission_ratio; // STORAGE[0x4]\nuint256 _get_amount_sell; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint8 _eth_is_seeded; // STORAGE[0x7] bytes 0 to 0\nuint8 _traded_token_is_seeded; // STORAGE[0x7] bytes 1 to 1\nuint8 _trading_deactivated; // STORAGE[0x7] bytes 2 to 2\naddress _traded_token; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    require(_trading_deactivated == 0);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    assert((_get_amount_sell + msg.value << 1) * _get_amount_sell);\n    0xd33();\n    0xac0(msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, msg.sender);\n    0xac0(msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) - msg.value * stor_6 * (_get_amount_sell + msg.value + _get_amount_sell) / ((_get_amount_sell + msg.value << 1) * _get_amount_sell) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, _admin);\n}\n\nfunction reactivate_trading() public nonPayable { \n    require(msg.sender == _admin);\n    require(_trading_deactivated);\n    _trading_deactivated = 0;\n}\n\nfunction deactivate_trading() public nonPayable { \n    require(msg.sender == _admin);\n    require(!_trading_deactivated);\n    _trading_deactivated = 1;\n}\n\nfunction withdraw_token(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    0xac0(varg0, _admin);\n}\n\nfunction withdraw_eth(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    0xbea(varg0, _admin);\n}\n\nfunction eth_is_seeded() public nonPayable { \n    return _eth_is_seeded;\n}\n\nfunction seed_eth() public payable { \n    require(msg.sender == _admin);\n    require(!_eth_is_seeded);\n    require(msg.value == _eth_seed_amount);\n    _eth_is_seeded = 1;\n    0xd33();\n}\n\nfunction traded_token_is_seeded() public nonPayable { \n    return _traded_token_is_seeded;\n}\n\nfunction get_amount_buy(uint256 varg0) public nonPayable { \n    assert((_get_amount_sell + varg0 << 1) * _get_amount_sell);\n    return varg0 * stor_6 * (_get_amount_sell + varg0 + _get_amount_sell) / ((_get_amount_sell + varg0 << 1) * _get_amount_sell);\n}\n\nfunction seed_additional_token(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    0xd69(varg0, this, msg.sender);\n}\n\nfunction sell_tokens(uint256 varg0) public nonPayable { \n    require(_trading_deactivated == 0);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    assert(stor_6 + (stor_6 + varg0));\n    0xd69(varg0, this, msg.sender);\n    0xbea((_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, msg.sender);\n    0xbea((_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) - (_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0)) * (0xde0b6b3a7640000 - _commission_ratio) / 0xde0b6b3a7640000, _admin);\n}\n\nfunction commission_ratio() public nonPayable { \n    return _commission_ratio;\n}\n\nfunction traded_token() public nonPayable { \n    return _traded_token;\n}\n\nfunction get_amount_sell(uint256 varg0) public nonPayable { \n    assert(stor_6 + (stor_6 + varg0));\n    return (_get_amount_sell << 1) * varg0 / (stor_6 + (stor_6 + varg0));\n}\n\nfunction traded_token_seed_amount() public nonPayable { \n    return _traded_token_seed_amount;\n}\n\nfunction seed_additional_eth() public payable { \n    require(msg.sender == _admin);\n    v0 = v1 = _eth_is_seeded;\n    if (v1) {\n        v0 = _traded_token_is_seeded;\n    }\n    require(v0);\n    0xd33();\n}\n\nfunction eth_seed_amount() public nonPayable { \n    return _eth_seed_amount;\n}\n\nfunction trading_deactivated() public nonPayable { \n    return _trading_deactivated;\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction seed_traded_token() public nonPayable { \n    require(msg.sender == _admin);\n    require(!_traded_token_is_seeded);\n    _traded_token_is_seeded = 1;\n    0xd69(_traded_token_seed_amount, this, msg.sender);\n}\n\nfunction 0xac0(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= stor_6);\n    stor_6 = stor_6 - varg0;\n    v0 = address(varg1);\n    require(_traded_token.code.size);\n    v1, v2 = _traded_token.transfer(v0, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    return ;\n}\n\nfunction 0xbea(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= _get_amount_sell);\n    _get_amount_sell = _get_amount_sell - varg0;\n    v0 = address(varg1).call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0xd33() private { \n    assert(_get_amount_sell + msg.value >= _get_amount_sell);\n    _get_amount_sell = _get_amount_sell + msg.value;\n    return ;\n}\n\nfunction 0xd69(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = stor_6 + varg0;\n    assert(v0 >= stor_6);\n    stor_6 = v0;\n    v1 = address(varg2);\n    v2 = address(varg1);\n    require(_traded_token.code.size);\n    v3, v4 = _traded_token.transferFrom(v1, v2, varg0).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v4);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x608a48a == function_selector) {\n            reactivate_trading();\n        } else if (0x10c452ef == function_selector) {\n            deactivate_trading();\n        } else if (0x164fa4ef == function_selector) {\n            withdraw_token(uint256);\n        } else if (0x30a95e67 == function_selector) {\n            withdraw_eth(uint256);\n        } else if (0x3bbb44ca == function_selector) {\n            eth_is_seeded();\n        } else if (0x3f5ab2fe == function_selector) {\n            seed_eth();\n        } else if (0x6f18d3f5 == function_selector) {\n            traded_token_is_seeded();\n        } else if (0x7b5825d5 == function_selector) {\n            get_amount_buy(uint256);\n        } else if (0x7e63dd86 == function_selector) {\n            seed_additional_token(uint256);\n        } else if (0x82803c22 == function_selector) {\n            sell_tokens(uint256);\n        } else if (0x877ddd77 == function_selector) {\n            commission_ratio();\n        } else if (0x8d5cc102 == function_selector) {\n            traded_token();\n        } else if (0xa45230ec == function_selector) {\n            get_amount_sell(uint256);\n        } else if (0xab004a97 == function_selector) {\n            traded_token_seed_amount();\n        } else if (0xac9c80af == function_selector) {\n            seed_additional_eth();\n        } else if (0xc0f57529 == function_selector) {\n            eth_seed_amount();\n        } else if (0xd3fd311e == function_selector) {\n            trading_deactivated();\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xf9b35ca3 == function_selector) {\n            seed_traded_token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 42.66191554069519,
	"usage": {
		"completion_tokens": 688,
		"prompt_tokens": 2393,
		"total_tokens": 3081
	}
}