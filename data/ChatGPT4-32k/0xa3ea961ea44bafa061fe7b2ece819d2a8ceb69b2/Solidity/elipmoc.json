{
	"address": "0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a Solidity contract code that reflects the behavior based on the EVM Bytecode you provided:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenSale {\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) private owner_3;\n    uint256 private _ethCollected;\n    uint256 private _tokenSold;\n    address private _owner;\n    uint8 private _state;\n    address private _newOwner;\n    address private _token;\n\n    event SaleClosedFail(uint256);\n    event OwnerUpdate(address, address);\n    event SaleClosedSuccess(uint256);\n    event SaleStart();\n\n    fallback() external payable {\n        if (_state == 3) {\n            if (msg.value == 0) {\n                withdrawTokens();\n            }\n        } else if (_state == 4) {\n            if (msg.value == 0) {\n                withdrawTokens();\n            }\n        } else if (_state == 2) {\n            if (msg.value == 0) {\n                refund();\n            } else {\n                buy();\n            }\n        }\n    }\n\n    function balances(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function withdraw() public {\n        require(msg.sender == _owner && _state == 3);\n        (bool success,) = _owner.call{value: _ethCollected}(\"\");\n        require(success);\n        _ethCollected = 0;\n        _state = 4;\n    }\n\n    function COINS_PER_ETH() public pure returns (uint256) {\n        return 12000;\n    }\n\n    function tokenSold() public view returns (uint256) {\n        return _tokenSold;\n    }\n\n    function refund() public {\n        require(_state == 2 && _balances[msg.sender] > 0);\n        (bool success,) = msg.sender.call{value: owner_3[msg.sender]}(\"\");\n        require(success);\n        _balances[msg.sender] = 0;\n        owner_3[msg.sender] = 0;\n        _ethCollected -= owner_3[msg.sender];\n    }\n\n    function closeFail() public {\n        require(msg.sender == _owner && _state == 1);\n        _state = 2;\n        emit SaleClosedFail(_tokenSold);\n    }\n\n    function bonus() public pure returns (uint256) {\n        return 25;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == _newOwner);\n        emit OwnerUpdate(_owner, _newOwner);\n        _owner = _newOwner;\n        _newOwner = address(0);\n    }\n\n    function closeSuccess() public {\n        require(msg.sender == _owner && _state == 1);\n        _state = 3;\n        emit SaleClosedSuccess(_tokenSold);\n    }\n\n    function withdrawTokens() public {\n        require((_state == 3 || _state == 4) && _balances[msg.sender] > 0);\n        // Assume _token is an ERC20 contract\n        // _token.transfer(msg.sender, _balances[msg.sender]);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function buy() public payable {\n        require(_state == 1);\n        uint256 amount = msg.value * COINS_PER_ETH();\n        _balances[msg.sender] += amount;\n        owner_3[msg.sender] += msg.value;\n        _ethCollected += msg.value;\n        _tokenSold += amount;\n    }\n\n    function tokensLeft() public view returns (uint256) {\n        // Assume _token is an ERC20 contract\n        // return _token.balanceOf(address(this));\n    }\n\n    function ethCollected() public view returns (uint256) {\n        return _ethCollected;\n    }\n\n    function state() public view returns (uint8) {\n        return _state;\n    }\n\n    function newOwner() public view returns (address) {\n        return _newOwner;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner && newOwner != _owner);\n        _newOwner = newOwner;\n    }\n\n    function token() public view returns (address) {\n        return _token;\n    }\n\n    function open() public {\n        require(msg.sender == _owner && _state == 0);\n        _state = 1;\n        emit SaleStart();\n    }\n\n    function canBuy() public view returns (bool) {\n        return _state == 1;\n    }\n}\n```\n\nPlease note that this contract assumes `_token` is an ERC20 contract. Implementations for `withdrawTokens` and `tokensLeft` are commented out as they require interaction with an actual ERC20 contract which is not defined in your code. You'll need an ERC20 contract to interact with. Furthermore, the `fallback` function is not payable which might make it difficult to receive Ether directly to this contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460800,
	"id": "chatcmpl-8R3y4eLTYbgkbJu1WMvZeMwwm69HT",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 14:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 _ethCollected; // STORAGE[0x4]\nuint256 _tokenSold; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _state; // STORAGE[0x6] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x6] bytes 1 to 20\n\n// Events\nSaleClosedFail(uint256);\nOwnerUpdate(address, address);\nSaleClosedSuccess(uint256);\nSaleStart();\n\nfunction fallback() public payable { \n    v0 = v1 = _state == 3;\n    if (_state != 3) {\n        v0 = v2 = _state == 4;\n    }\n    if (v0) {\n        v0 = v3 = msg.value == 0;\n    }\n    if (!v0) {\n        v4 = v5 = _state == 2;\n        if (v5) {\n            v4 = v6 = msg.value == 0;\n        }\n        if (!v4) {\n            0x9f9();\n        } else {\n            0x6f1();\n        }\n    } else {\n        0x523();\n    }\n}\n\nfunction 0x159c(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 3);\n    v0 = _owner.call().value(_ethCollected).gas(!_ethCollected * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _ethCollected = 0;\n    _state = 4;\n}\n\nfunction COINS_PER_ETH() public nonPayable { \n    return 12000;\n}\n\nfunction tokenSold() public nonPayable { \n    return _tokenSold;\n}\n\nfunction refund() public nonPayable { \n    0x6f1();\n}\n\nfunction closeFail() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 1);\n    _state = 2;\n    emit SaleClosedFail(_tokenSold);\n}\n\nfunction bonus() public nonPayable { \n    return 25;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnerUpdate(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction closeSuccess() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 1);\n    _state = 3;\n    emit SaleClosedSuccess(_tokenSold);\n}\n\nfunction withdrawTokens() public nonPayable { \n    0x523();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction buy() public payable { \n    0x9f9();\n}\n\nfunction tokensLeft() public nonPayable { \n    require(_token.code.size);\n    v0, v1 = _token.allowance(_owner, address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction ethCollected() public nonPayable { \n    return _ethCollected;\n}\n\nfunction state() public nonPayable { \n    return _state;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != _owner);\n    _newOwner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction open() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 0);\n    _state = 1;\n    emit SaleStart();\n}\n\nfunction canBuy() public nonPayable { \n    return _state == 1;\n}\n\nfunction 0x523() private { \n    v0 = v1 = _state == 3;\n    if (_state != 3) {\n        v0 = v2 = _state == 4;\n    }\n    require(v0);\n    require(_balances[msg.sender] > 0);\n    require(_token.code.size);\n    v3, v4 = _token.transfer(msg.sender, _balances[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return ;\n}\n\nfunction 0x6f1() private { \n    require(_state == 2);\n    require(_balances[msg.sender] > 0);\n    v0 = msg.sender.call().value(owner_3[msg.sender]).gas(!owner_3[msg.sender] * 2300);\n    require(v0); // checks call status, propagates error data on error\n    require(_token.code.size);\n    v1, v2 = _token.transfer(_owner, _balances[msg.sender]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    owner_3[msg.sender] = 0;\n    owner_3[msg.sender] = 0;\n    assert(owner_3[msg.sender] <= _ethCollected);\n    _ethCollected = _ethCollected - owner_3[msg.sender];\n    return ;\n}\n\nfunction 0x9f9() private { \n    require(_state == 1);\n    v0 = 0x159c(12000, msg.value);\n    assert(0xde0b6b3a7640000);\n    v1 = 0x159c(0xde0b6b3a7640000, v0 / 0xde0b6b3a7640000);\n    assert(125 >= 25);\n    v2 = 0x159c(125, v1);\n    assert(100);\n    require(v2 / 100 > 0, 'amount must be positive');\n    require(_token.code.size);\n    v3, v4 = _token.transferFrom(_owner, address(this), v2 / 100).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(_balances[msg.sender] + v2 / 100 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v2 / 100;\n    owner_3[msg.sender] = owner_3[msg.sender] + msg.value;\n    assert(_ethCollected + msg.value >= _ethCollected);\n    _ethCollected = _ethCollected + msg.value;\n    assert(_tokenSold + v2 / 100 >= _tokenSold);\n    _tokenSold = _tokenSold + v2 / 100;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x47ee2992 == function_selector) {\n            COINS_PER_ETH();\n        } else if (0x519ee19e == function_selector) {\n            tokenSold();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x647d02d2 == function_selector) {\n            closeFail();\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x875cb3e5 == function_selector) {\n            closeSuccess();\n        } else if (0x8d8f2adb == function_selector) {\n            withdrawTokens();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xb31f8f93 == function_selector) {\n            tokensLeft();\n        } else if (0xbee2e134 == function_selector) {\n            ethCollected();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfcfff16f == function_selector) {\n            open();\n        } else if (0xff65226c == function_selector) {\n            canBuy();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 14:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 _ethCollected; // STORAGE[0x4]\nuint256 _tokenSold; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _state; // STORAGE[0x6] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x6] bytes 1 to 20\n\n// Events\nSaleClosedFail(uint256);\nOwnerUpdate(address, address);\nSaleClosedSuccess(uint256);\nSaleStart();\n\nfunction fallback() public payable { \n    v0 = v1 = _state == 3;\n    if (_state != 3) {\n        v0 = v2 = _state == 4;\n    }\n    if (v0) {\n        v0 = v3 = msg.value == 0;\n    }\n    if (!v0) {\n        v4 = v5 = _state == 2;\n        if (v5) {\n            v4 = v6 = msg.value == 0;\n        }\n        if (!v4) {\n            0x9f9();\n        } else {\n            0x6f1();\n        }\n    } else {\n        0x523();\n    }\n}\n\nfunction 0x159c(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 3);\n    v0 = _owner.call().value(_ethCollected).gas(!_ethCollected * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _ethCollected = 0;\n    _state = 4;\n}\n\nfunction COINS_PER_ETH() public nonPayable { \n    return 12000;\n}\n\nfunction tokenSold() public nonPayable { \n    return _tokenSold;\n}\n\nfunction refund() public nonPayable { \n    0x6f1();\n}\n\nfunction closeFail() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 1);\n    _state = 2;\n    emit SaleClosedFail(_tokenSold);\n}\n\nfunction bonus() public nonPayable { \n    return 25;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnerUpdate(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction closeSuccess() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 1);\n    _state = 3;\n    emit SaleClosedSuccess(_tokenSold);\n}\n\nfunction withdrawTokens() public nonPayable { \n    0x523();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction buy() public payable { \n    0x9f9();\n}\n\nfunction tokensLeft() public nonPayable { \n    require(_token.code.size);\n    v0, v1 = _token.allowance(_owner, address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction ethCollected() public nonPayable { \n    return _ethCollected;\n}\n\nfunction state() public nonPayable { \n    return _state;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != _owner);\n    _newOwner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction open() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 0);\n    _state = 1;\n    emit SaleStart();\n}\n\nfunction canBuy() public nonPayable { \n    return _state == 1;\n}\n\nfunction 0x523() private { \n    v0 = v1 = _state == 3;\n    if (_state != 3) {\n        v0 = v2 = _state == 4;\n    }\n    require(v0);\n    require(_balances[msg.sender] > 0);\n    require(_token.code.size);\n    v3, v4 = _token.transfer(msg.sender, _balances[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return ;\n}\n\nfunction 0x6f1() private { \n    require(_state == 2);\n    require(_balances[msg.sender] > 0);\n    v0 = msg.sender.call().value(owner_3[msg.sender]).gas(!owner_3[msg.sender] * 2300);\n    require(v0); // checks call status, propagates error data on error\n    require(_token.code.size);\n    v1, v2 = _token.transfer(_owner, _balances[msg.sender]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    owner_3[msg.sender] = 0;\n    owner_3[msg.sender] = 0;\n    assert(owner_3[msg.sender] <= _ethCollected);\n    _ethCollected = _ethCollected - owner_3[msg.sender];\n    return ;\n}\n\nfunction 0x9f9() private { \n    require(_state == 1);\n    v0 = 0x159c(12000, msg.value);\n    assert(0xde0b6b3a7640000);\n    v1 = 0x159c(0xde0b6b3a7640000, v0 / 0xde0b6b3a7640000);\n    assert(125 >= 25);\n    v2 = 0x159c(125, v1);\n    assert(100);\n    require(v2 / 100 > 0, 'amount must be positive');\n    require(_token.code.size);\n    v3, v4 = _token.transferFrom(_owner, address(this), v2 / 100).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(_balances[msg.sender] + v2 / 100 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v2 / 100;\n    owner_3[msg.sender] = owner_3[msg.sender] + msg.value;\n    assert(_ethCollected + msg.value >= _ethCollected);\n    _ethCollected = _ethCollected + msg.value;\n    assert(_tokenSold + v2 / 100 >= _tokenSold);\n    _tokenSold = _tokenSold + v2 / 100;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x47ee2992 == function_selector) {\n            COINS_PER_ETH();\n        } else if (0x519ee19e == function_selector) {\n            tokenSold();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x647d02d2 == function_selector) {\n            closeFail();\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x875cb3e5 == function_selector) {\n            closeSuccess();\n        } else if (0x8d8f2adb == function_selector) {\n            withdrawTokens();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xb31f8f93 == function_selector) {\n            tokensLeft();\n        } else if (0xbee2e134 == function_selector) {\n            ethCollected();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfcfff16f == function_selector) {\n            open();\n        } else if (0xff65226c == function_selector) {\n            canBuy();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 14:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 _ethCollected; // STORAGE[0x4]\nuint256 _tokenSold; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _state; // STORAGE[0x6] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x6] bytes 1 to 20\n\n// Events\nSaleClosedFail(uint256);\nOwnerUpdate(address, address);\nSaleClosedSuccess(uint256);\nSaleStart();\n\nfunction fallback() public payable { \n    v0 = v1 = _state == 3;\n    if (_state != 3) {\n        v0 = v2 = _state == 4;\n    }\n    if (v0) {\n        v0 = v3 = msg.value == 0;\n    }\n    if (!v0) {\n        v4 = v5 = _state == 2;\n        if (v5) {\n            v4 = v6 = msg.value == 0;\n        }\n        if (!v4) {\n            0x9f9();\n        } else {\n            0x6f1();\n        }\n    } else {\n        0x523();\n    }\n}\n\nfunction 0x159c(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 3);\n    v0 = _owner.call().value(_ethCollected).gas(!_ethCollected * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _ethCollected = 0;\n    _state = 4;\n}\n\nfunction COINS_PER_ETH() public nonPayable { \n    return 12000;\n}\n\nfunction tokenSold() public nonPayable { \n    return _tokenSold;\n}\n\nfunction refund() public nonPayable { \n    0x6f1();\n}\n\nfunction closeFail() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 1);\n    _state = 2;\n    emit SaleClosedFail(_tokenSold);\n}\n\nfunction bonus() public nonPayable { \n    return 25;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnerUpdate(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction closeSuccess() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 1);\n    _state = 3;\n    emit SaleClosedSuccess(_tokenSold);\n}\n\nfunction withdrawTokens() public nonPayable { \n    0x523();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction buy() public payable { \n    0x9f9();\n}\n\nfunction tokensLeft() public nonPayable { \n    require(_token.code.size);\n    v0, v1 = _token.allowance(_owner, address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction ethCollected() public nonPayable { \n    return _ethCollected;\n}\n\nfunction state() public nonPayable { \n    return _state;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != _owner);\n    _newOwner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction open() public nonPayable { \n    require(msg.sender == _owner);\n    require(_state == 0);\n    _state = 1;\n    emit SaleStart();\n}\n\nfunction canBuy() public nonPayable { \n    return _state == 1;\n}\n\nfunction 0x523() private { \n    v0 = v1 = _state == 3;\n    if (_state != 3) {\n        v0 = v2 = _state == 4;\n    }\n    require(v0);\n    require(_balances[msg.sender] > 0);\n    require(_token.code.size);\n    v3, v4 = _token.transfer(msg.sender, _balances[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return ;\n}\n\nfunction 0x6f1() private { \n    require(_state == 2);\n    require(_balances[msg.sender] > 0);\n    v0 = msg.sender.call().value(owner_3[msg.sender]).gas(!owner_3[msg.sender] * 2300);\n    require(v0); // checks call status, propagates error data on error\n    require(_token.code.size);\n    v1, v2 = _token.transfer(_owner, _balances[msg.sender]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    owner_3[msg.sender] = 0;\n    owner_3[msg.sender] = 0;\n    assert(owner_3[msg.sender] <= _ethCollected);\n    _ethCollected = _ethCollected - owner_3[msg.sender];\n    return ;\n}\n\nfunction 0x9f9() private { \n    require(_state == 1);\n    v0 = 0x159c(12000, msg.value);\n    assert(0xde0b6b3a7640000);\n    v1 = 0x159c(0xde0b6b3a7640000, v0 / 0xde0b6b3a7640000);\n    assert(125 >= 25);\n    v2 = 0x159c(125, v1);\n    assert(100);\n    require(v2 / 100 > 0, 'amount must be positive');\n    require(_token.code.size);\n    v3, v4 = _token.transferFrom(_owner, address(this), v2 / 100).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(_balances[msg.sender] + v2 / 100 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v2 / 100;\n    owner_3[msg.sender] = owner_3[msg.sender] + msg.value;\n    assert(_ethCollected + msg.value >= _ethCollected);\n    _ethCollected = _ethCollected + msg.value;\n    assert(_tokenSold + v2 / 100 >= _tokenSold);\n    _tokenSold = _tokenSold + v2 / 100;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x47ee2992 == function_selector) {\n            COINS_PER_ETH();\n        } else if (0x519ee19e == function_selector) {\n            tokenSold();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x647d02d2 == function_selector) {\n            closeFail();\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x875cb3e5 == function_selector) {\n            closeSuccess();\n        } else if (0x8d8f2adb == function_selector) {\n            withdrawTokens();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xb31f8f93 == function_selector) {\n            tokensLeft();\n        } else if (0xbee2e134 == function_selector) {\n            ethCollected();\n        } else if (0xc19d93fb == function_selector) {\n            state();\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfcfff16f == function_selector) {\n            open();\n        } else if (0xff65226c == function_selector) {\n            canBuy();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 70.88139247894287,
	"usage": {
		"completion_tokens": 1011,
		"prompt_tokens": 2202,
		"total_tokens": 3213
	}
}