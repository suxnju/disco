{
	"address": "0x16a0772b17ae004e6645e0e95bf50ad69498a34e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled EVM Bytecode is a complex series of operations that are not human-readable. Here's a simplified Solidity version of the contract:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\ncontract TransactionContract {\n    mapping(uint256 => uint256[]) private _transactions;\n    mapping(uint256 => uint256[]) private _confirmations;\n    mapping(address => bool) private _isOwner;\n    address[] private _owners;\n    uint256 private _required;\n    uint256 private _transactionCount;\n    uint256 private constant MAX_OWNER_COUNT = 5;\n\n    event Deposit(address indexed sender, uint256 value);\n    event OwnerRemoval(address indexed owner);\n    event Revocation(address indexed sender, uint256 transactionId);\n    event OwnerAddition(address indexed owner);\n    event RequirementChange(uint256 required);\n    event Confirmation(address indexed sender, uint256 transactionId);\n    event Execution(uint256 transactionId);\n    event ExecutionFailure(uint256 transactionId);\n    event Submission(uint256 transactionId);\n\n    modifier onlyOwner {\n        require(_isOwner[msg.sender], \"Caller is not an owner\");\n        _;\n    }\n\n    function addOwner(address owner) public onlyOwner {\n        require(owner != address(0), \"Invalid owner address\");\n        require(!_isOwner[owner], \"Owner already exists\");\n        require(_owners.length < MAX_OWNER_COUNT, \"Max owners reached\");\n\n        _isOwner[owner] = true;\n        _owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    function removeOwner(address owner) public onlyOwner {\n        require(_isOwner[owner], \"Not an owner\");\n        _isOwner[owner] = false;\n\n        for (uint i = 0; i < _owners.length - 1; i++)\n            if (_owners[i] == owner) {\n                _owners[i] = _owners[_owners.length - 1];\n                break;\n            }\n            \n        _owners.pop();\n        emit OwnerRemoval(owner);\n    }\n\n    function replaceOwner(address oldOwner, address newOwner) public onlyOwner {\n        require(_isOwner[oldOwner], \"Not an owner\");\n        require(newOwner != address(0), \"Invalid owner address\");\n        require(!_isOwner[newOwner], \"Owner already exists\");\n\n        for (uint i = 0; i < _owners.length; i++)\n            if (_owners[i] == oldOwner) {\n                _owners[i] = newOwner;\n                break;\n            }\n            \n        _isOwner[oldOwner] = false;\n        _isOwner[newOwner] = true;\n        emit OwnerRemoval(oldOwner);\n        emit OwnerAddition(newOwner);\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return _isOwner[owner];\n    }\n\n    function required() public view returns (uint256) {\n        return _required;\n    }\n\n    function transactionCount() public view returns (uint256) {\n        return _transactionCount;\n    }\n\n    function changeRequirement(uint256 _required) public onlyOwner {\n        require(_required <= _owners.length, \"Invalid requirement\");\n        _required = _required;\n        emit RequirementChange(_required);\n    }\n\n    // implement other functions...\n}\n```\n\nThis contract allows multiple owners to manage a list of transactions, each with its confirmations. Each owner can add, remove, or replace other owners, as well as change the required number of confirmations for a transaction. Each transaction is indexed by a unique ID and contains a list of confirmations. Each confirmation is also indexed by a unique ID.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038673,
	"id": "chatcmpl-8ChiTNEWbHM7ykV1RP6FEv8xDsv7B",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.17 15:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x12a7(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xad5(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x8130x1505B0x7afB0x1a2;\n    }\n    if (_required > _owners.length) {\n        0xf3b(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 5;\n    if (1 + _owners.length <= 5) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v4 = v5 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n        goto 0x8130x1505B0xa34B0x273;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0xad5(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length << 5) {\n        v5[v6] = v1[v6];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v13 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v14 = v15 = MEM[64];\n    if (MSIZE() >= v15) {\n        v14 = v16 = new uint256[](varg1 - varg0);\n    }\n    v14 = new uint256[](varg1 - varg0);\n    while (v17 < varg1) {\n        assert(v17 < v5.length);\n        assert(v17 - varg0 < v14.length);\n        v16[v17 - varg0 << 5] = v7[v17];\n        v17 += 1;\n    }\n    v18 = new array[](v14.length);\n    v19 = v20 = 0;\n    while (v19 < v14.length << 5) {\n        v18[v19] = v16[v19];\n        v19 += 32;\n    }\n    return v18;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v16 = 0;\n    while (v15 < v9.length << 5) {\n        v14[v15] = v11[v15];\n        v15 += 32;\n    }\n    return v14;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0xf3b(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0xfc9(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfc9(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 5;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x12a7(varg0);\n}\n\nfunction 0xad5(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb61;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf3b(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 5;\n    if (_owners.length <= 5) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfc9(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x12a7(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.17 15:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x12a7(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xad5(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x8130x1505B0x7afB0x1a2;\n    }\n    if (_required > _owners.length) {\n        0xf3b(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 5;\n    if (1 + _owners.length <= 5) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v4 = v5 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n        goto 0x8130x1505B0xa34B0x273;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0xad5(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length << 5) {\n        v5[v6] = v1[v6];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v13 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v14 = v15 = MEM[64];\n    if (MSIZE() >= v15) {\n        v14 = v16 = new uint256[](varg1 - varg0);\n    }\n    v14 = new uint256[](varg1 - varg0);\n    while (v17 < varg1) {\n        assert(v17 < v5.length);\n        assert(v17 - varg0 < v14.length);\n        v16[v17 - varg0 << 5] = v7[v17];\n        v17 += 1;\n    }\n    v18 = new array[](v14.length);\n    v19 = v20 = 0;\n    while (v19 < v14.length << 5) {\n        v18[v19] = v16[v19];\n        v19 += 32;\n    }\n    return v18;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v16 = 0;\n    while (v15 < v9.length << 5) {\n        v14[v15] = v11[v15];\n        v15 += 32;\n    }\n    return v14;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0xf3b(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0xfc9(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfc9(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 5;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x12a7(varg0);\n}\n\nfunction 0xad5(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb61;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf3b(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 5;\n    if (_owners.length <= 5) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfc9(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x12a7(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.17 15:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x12a7(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xad5(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x8130x1505B0x7afB0x1a2;\n    }\n    if (_required > _owners.length) {\n        0xf3b(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 5;\n    if (1 + _owners.length <= 5) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v4 = v5 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n        goto 0x8130x1505B0xa34B0x273;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0xad5(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length << 5) {\n        v5[v6] = v1[v6];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v13 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v14 = v15 = MEM[64];\n    if (MSIZE() >= v15) {\n        v14 = v16 = new uint256[](varg1 - varg0);\n    }\n    v14 = new uint256[](varg1 - varg0);\n    while (v17 < varg1) {\n        assert(v17 < v5.length);\n        assert(v17 - varg0 < v14.length);\n        v16[v17 - varg0 << 5] = v7[v17];\n        v17 += 1;\n    }\n    v18 = new array[](v14.length);\n    v19 = v20 = 0;\n    while (v19 < v14.length << 5) {\n        v18[v19] = v16[v19];\n        v19 += 32;\n    }\n    return v18;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v16 = 0;\n    while (v15 < v9.length << 5) {\n        v14[v15] = v11[v15];\n        v15 += 32;\n    }\n    return v14;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0xf3b(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0xfc9(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfc9(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 5;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x12a7(varg0);\n}\n\nfunction 0xad5(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb61;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf3b(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 5;\n    if (_owners.length <= 5) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfc9(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x12a7(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
	"status": "1",
	"time_cost": 38.64681839942932,
	"usage": {
		"completion_tokens": 742,
		"prompt_tokens": 4580,
		"total_tokens": 5322
	}
}