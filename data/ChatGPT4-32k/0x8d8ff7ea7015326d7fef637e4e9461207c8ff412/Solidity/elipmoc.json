{
	"address": "0x8d8ff7ea7015326d7fef637e4e9461207c8ff412",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code that corresponds to your decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ICOContract {\n    uint256 private _icoStartBlock;\n    uint256 private _icoStartTime;\n    uint256 private _purchaseCap;\n    uint256 private _minimumContribution;\n    address private _owner;\n    address private _crowdSale;\n    address private _executor;\n\n    event EtherReceived(address indexed sender, uint256 amount);\n    event PurchaseCapChanged(uint256 newCap);\n    event TokensWithdrawn(uint256 amount);\n    event CrowdSaleChanged(address newAddress);\n    event ICOStartTimeChanged(uint256 newTime);\n    event MinimumContributionChanged(uint256 newMinimumContribution);\n    event ExecutorChanged(address newExecutor);\n    event ICOPurchased(uint256 amount);\n    event ICOStartBlockChanged(uint256 newBlock);\n    \n    function icoStartBlock() public view returns (uint256) { \n        return _icoStartBlock;\n    }\n\n    function changePurchaseCap(uint256 newCap) public { \n        require(_executor == msg.sender || _owner == msg.sender, \"Unauthorized\");\n        _purchaseCap = newCap;\n        emit PurchaseCapChanged(newCap);\n    }\n\n    // Assuming varg0 is an ERC20 token\n    function withdrawTokens(address varg0) public { \n        require(_owner == msg.sender, \"Unauthorized\");\n        IERC20 token = IERC20(varg0);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(_owner, balance));\n        emit TokensWithdrawn(balance);\n    }\n\n    function changeCrowdSale(address newCrowdSale) public { \n        require(_executor == msg.sender || _owner == msg.sender, \"Unauthorized\");\n        _crowdSale = newCrowdSale;\n        emit CrowdSaleChanged(_crowdSale);\n    }\n\n    function withdrawEther() public { \n        require(_owner == msg.sender, \"Unauthorized\");\n        require(address(this).balance > 0, \"No balance\");\n        (bool success,) = _owner.call{value: address(this).balance}(\"\");\n        require(success);\n        emit EtherReceived(address(this), address(this).balance);\n    }\n\n    function crowdSale() public view returns (address) { \n        return _crowdSale;\n    }\n\n    function changeICOStartTime(uint256 newTime) public { \n        require(_executor == msg.sender || _owner == msg.sender, \"Unauthorized\");\n        _icoStartTime = newTime;\n        emit ICOStartTimeChanged(newTime);\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function changeMinimumContribution(uint256 newMinimumContribution) public { \n        require(_executor == msg.sender || _owner == msg.sender, \"Unauthorized\");\n        _minimumContribution = newMinimumContribution;\n        emit MinimumContributionChanged(newMinimumContribution);\n    }\n\n    function minimumContribution() public view returns (uint256) { \n        return _minimumContribution;\n    }\n\n    function changeExecutor(address newExecutor) public {\n        require(_owner == msg.sender, \"Unauthorized\");\n        _executor = newExecutor;\n        emit ExecutorChanged(newExecutor);\n    }\n\n    function icoStartTime() public view returns (uint256) { \n        return _icoStartTime;\n    }\n\n    function purchaseCap() public view returns (uint256) { \n        return _purchaseCap;\n    }\n\n    function executor() public view returns (address) { \n        return _executor;\n    }\n\n    function buyICO() public payable { \n        require(block.number >= _icoStartBlock && block.timestamp >= _icoStartTime, \"ICO not started\");\n        require(msg.value >= _minimumContribution && msg.value <= _purchaseCap, \"Invalid amount\");\n        _crowdSale.call{value: msg.value}(\"\");\n        emit ICOPurchased(msg.value);\n    }\n\n    function changeICOStartBlock(uint256 newBlock) public { \n        require(_executor == msg.sender || _owner == msg.sender, \"Unauthorized\");\n        _icoStartBlock = newBlock;\n        emit ICOStartBlockChanged(newBlock);\n    }\n\n    function transferOwnership(address newOwner) public { \n        require(_owner == msg.sender, \"Unauthorized\");\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\nThe code above assumes that `varg0` in the `withdrawTokens` function is an ERC20 token, and it uses the standard ERC20 interface to interact with it.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468474,
	"id": "chatcmpl-8R5xqq1SVvNnG1Gc2WdCYJGfIz1bj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _icoStartBlock; // STORAGE[0x1]\nuint256 _icoStartTime; // STORAGE[0x2]\nuint256 _purchaseCap; // STORAGE[0x5]\nuint256 _minimumContribution; // STORAGE[0x6]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _crowdSale; // STORAGE[0x3] bytes 0 to 19\naddress _executor; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nEtherReceived(address, uint256);\nPurchaseCapChanged(uint256);\nTokensWithdrawn(uint256);\nCrowdSaleChanged(address);\nICOStartTimeChanged(uint256);\nMinimumContributionChanged(uint256);\nExecutorChanged(address);\nICOPurchased(uint256);\nICOStartBlockChanged(uint256);\n\nfunction icoStartBlock() public payable { \n    assert(!msg.value);\n    return _icoStartBlock;\n}\n\nfunction changePurchaseCap(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _purchaseCap = varg0;\n    emit PurchaseCapChanged(varg0);\n}\n\nfunction withdrawTokens(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    assert(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas - 710);\n    assert(v0);\n    require(v1);\n    MEM[32 + MEM[64]] = 0;\n    assert(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas - 710);\n    assert(v2);\n    assert(v3);\n    emit TokensWithdrawn(v1);\n}\n\nfunction changeCrowdSale(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _crowdSale = varg0;\n    emit CrowdSaleChanged(_crowdSale);\n}\n\nfunction withdrawEther() public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    require((address(this)).balance);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    assert(v0);\n    emit 0x4590a28d5a843588aa29cd0037e47b18e8e1223898c124a04ab7165d68d826f((address(this)).balance);\n}\n\nfunction crowdSale() public payable { \n    assert(!msg.value);\n    return _crowdSale;\n}\n\nfunction changeICOStartTime(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _icoStartTime = varg0;\n    emit ICOStartTimeChanged(varg0);\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction changeMinimumContribution(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _minimumContribution = varg0;\n    emit MinimumContributionChanged(varg0);\n}\n\nfunction minimumContribution() public payable { \n    assert(!msg.value);\n    return _minimumContribution;\n}\n\nfunction changeExecutor(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _executor = varg0;\n    emit ExecutorChanged(varg0);\n}\n\nfunction icoStartTime() public payable { \n    assert(!msg.value);\n    return _icoStartTime;\n}\n\nfunction purchaseCap() public payable { \n    assert(!msg.value);\n    return _purchaseCap;\n}\n\nfunction executor() public payable { \n    assert(!msg.value);\n    return _executor;\n}\n\nfunction buyICO() public payable { \n    assert(!msg.value);\n    v0 = v1 = 0 != _icoStartBlock;\n    if (v1) {\n        v0 = block.number < _icoStartBlock;\n    }\n    if (!v0) {\n        v2 = v3 = _icoStartTime;\n        if (_icoStartTime) {\n            v2 = block.timestamp < _icoStartTime;\n        }\n        if (!v2) {\n            if ((address(this)).balance >= _minimumContribution) {\n                v4 = v5 = (address(this)).balance;\n                v4 = v6 = _purchaseCap;\n                if (v5 >= v6) {\n                }\n                v7 = _crowdSale.call().value(v4).gas(msg.gas - 34710);\n                assert(v7);\n                emit ICOPurchased(v4);\n                goto 0x11b0x2d4;\n            }\n        }\n    }\n}\n\nfunction changeICOStartBlock(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _icoStartBlock = varg0;\n    emit ICOStartBlockChanged(varg0);\n}\n\nfunction transferOwnership(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    if (varg0) {\n        _owner = varg0;\n        goto 0x11b0x2fb;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x12ea965d) {\n            icoStartBlock();\n        } else if (0x43062ea7 == v0) {\n            changePurchaseCap(uint256);\n        } else if (0x49df728c == v0) {\n            withdrawTokens(address);\n        } else if (0x68d324e7 == v0) {\n            changeCrowdSale(address);\n        } else if (0x7362377b == v0) {\n            withdrawEther();\n        } else if (0x7770bd15 == v0) {\n            crowdSale();\n        } else if (0x89826963 == v0) {\n            changeICOStartTime(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x92bf2bf1 == v0) {\n            changeMinimumContribution(uint256);\n        } else if (0x937e09b1 == v0) {\n            minimumContribution();\n        } else if (0x9665b658 == v0) {\n            changeExecutor(address);\n        } else if (0xa7c3d71b == v0) {\n            icoStartTime();\n        } else if (0xab0fe874 == v0) {\n            purchaseCap();\n        } else if (0xc34c08e5 == v0) {\n            executor();\n        } else if (0xc59b5562 == v0) {\n            buyICO();\n        } else if (0xe52c0f24 == v0) {\n            changeICOStartBlock(uint256);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    emit EtherReceived(msg.sender, msg.value);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _icoStartBlock; // STORAGE[0x1]\nuint256 _icoStartTime; // STORAGE[0x2]\nuint256 _purchaseCap; // STORAGE[0x5]\nuint256 _minimumContribution; // STORAGE[0x6]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _crowdSale; // STORAGE[0x3] bytes 0 to 19\naddress _executor; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nEtherReceived(address, uint256);\nPurchaseCapChanged(uint256);\nTokensWithdrawn(uint256);\nCrowdSaleChanged(address);\nICOStartTimeChanged(uint256);\nMinimumContributionChanged(uint256);\nExecutorChanged(address);\nICOPurchased(uint256);\nICOStartBlockChanged(uint256);\n\nfunction icoStartBlock() public payable { \n    assert(!msg.value);\n    return _icoStartBlock;\n}\n\nfunction changePurchaseCap(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _purchaseCap = varg0;\n    emit PurchaseCapChanged(varg0);\n}\n\nfunction withdrawTokens(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    assert(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas - 710);\n    assert(v0);\n    require(v1);\n    MEM[32 + MEM[64]] = 0;\n    assert(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas - 710);\n    assert(v2);\n    assert(v3);\n    emit TokensWithdrawn(v1);\n}\n\nfunction changeCrowdSale(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _crowdSale = varg0;\n    emit CrowdSaleChanged(_crowdSale);\n}\n\nfunction withdrawEther() public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    require((address(this)).balance);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    assert(v0);\n    emit 0x4590a28d5a843588aa29cd0037e47b18e8e1223898c124a04ab7165d68d826f((address(this)).balance);\n}\n\nfunction crowdSale() public payable { \n    assert(!msg.value);\n    return _crowdSale;\n}\n\nfunction changeICOStartTime(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _icoStartTime = varg0;\n    emit ICOStartTimeChanged(varg0);\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction changeMinimumContribution(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _minimumContribution = varg0;\n    emit MinimumContributionChanged(varg0);\n}\n\nfunction minimumContribution() public payable { \n    assert(!msg.value);\n    return _minimumContribution;\n}\n\nfunction changeExecutor(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _executor = varg0;\n    emit ExecutorChanged(varg0);\n}\n\nfunction icoStartTime() public payable { \n    assert(!msg.value);\n    return _icoStartTime;\n}\n\nfunction purchaseCap() public payable { \n    assert(!msg.value);\n    return _purchaseCap;\n}\n\nfunction executor() public payable { \n    assert(!msg.value);\n    return _executor;\n}\n\nfunction buyICO() public payable { \n    assert(!msg.value);\n    v0 = v1 = 0 != _icoStartBlock;\n    if (v1) {\n        v0 = block.number < _icoStartBlock;\n    }\n    if (!v0) {\n        v2 = v3 = _icoStartTime;\n        if (_icoStartTime) {\n            v2 = block.timestamp < _icoStartTime;\n        }\n        if (!v2) {\n            if ((address(this)).balance >= _minimumContribution) {\n                v4 = v5 = (address(this)).balance;\n                v4 = v6 = _purchaseCap;\n                if (v5 >= v6) {\n                }\n                v7 = _crowdSale.call().value(v4).gas(msg.gas - 34710);\n                assert(v7);\n                emit ICOPurchased(v4);\n                goto 0x11b0x2d4;\n            }\n        }\n    }\n}\n\nfunction changeICOStartBlock(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _icoStartBlock = varg0;\n    emit ICOStartBlockChanged(varg0);\n}\n\nfunction transferOwnership(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    if (varg0) {\n        _owner = varg0;\n        goto 0x11b0x2fb;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x12ea965d) {\n            icoStartBlock();\n        } else if (0x43062ea7 == v0) {\n            changePurchaseCap(uint256);\n        } else if (0x49df728c == v0) {\n            withdrawTokens(address);\n        } else if (0x68d324e7 == v0) {\n            changeCrowdSale(address);\n        } else if (0x7362377b == v0) {\n            withdrawEther();\n        } else if (0x7770bd15 == v0) {\n            crowdSale();\n        } else if (0x89826963 == v0) {\n            changeICOStartTime(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x92bf2bf1 == v0) {\n            changeMinimumContribution(uint256);\n        } else if (0x937e09b1 == v0) {\n            minimumContribution();\n        } else if (0x9665b658 == v0) {\n            changeExecutor(address);\n        } else if (0xa7c3d71b == v0) {\n            icoStartTime();\n        } else if (0xab0fe874 == v0) {\n            purchaseCap();\n        } else if (0xc34c08e5 == v0) {\n            executor();\n        } else if (0xc59b5562 == v0) {\n            buyICO();\n        } else if (0xe52c0f24 == v0) {\n            changeICOStartBlock(uint256);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    emit EtherReceived(msg.sender, msg.value);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _icoStartBlock; // STORAGE[0x1]\nuint256 _icoStartTime; // STORAGE[0x2]\nuint256 _purchaseCap; // STORAGE[0x5]\nuint256 _minimumContribution; // STORAGE[0x6]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _crowdSale; // STORAGE[0x3] bytes 0 to 19\naddress _executor; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nEtherReceived(address, uint256);\nPurchaseCapChanged(uint256);\nTokensWithdrawn(uint256);\nCrowdSaleChanged(address);\nICOStartTimeChanged(uint256);\nMinimumContributionChanged(uint256);\nExecutorChanged(address);\nICOPurchased(uint256);\nICOStartBlockChanged(uint256);\n\nfunction icoStartBlock() public payable { \n    assert(!msg.value);\n    return _icoStartBlock;\n}\n\nfunction changePurchaseCap(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _purchaseCap = varg0;\n    emit PurchaseCapChanged(varg0);\n}\n\nfunction withdrawTokens(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    assert(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas - 710);\n    assert(v0);\n    require(v1);\n    MEM[32 + MEM[64]] = 0;\n    assert(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas - 710);\n    assert(v2);\n    assert(v3);\n    emit TokensWithdrawn(v1);\n}\n\nfunction changeCrowdSale(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _crowdSale = varg0;\n    emit CrowdSaleChanged(_crowdSale);\n}\n\nfunction withdrawEther() public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    require((address(this)).balance);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    assert(v0);\n    emit 0x4590a28d5a843588aa29cd0037e47b18e8e1223898c124a04ab7165d68d826f((address(this)).balance);\n}\n\nfunction crowdSale() public payable { \n    assert(!msg.value);\n    return _crowdSale;\n}\n\nfunction changeICOStartTime(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _icoStartTime = varg0;\n    emit ICOStartTimeChanged(varg0);\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction changeMinimumContribution(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _minimumContribution = varg0;\n    emit MinimumContributionChanged(varg0);\n}\n\nfunction minimumContribution() public payable { \n    assert(!msg.value);\n    return _minimumContribution;\n}\n\nfunction changeExecutor(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _executor = varg0;\n    emit ExecutorChanged(varg0);\n}\n\nfunction icoStartTime() public payable { \n    assert(!msg.value);\n    return _icoStartTime;\n}\n\nfunction purchaseCap() public payable { \n    assert(!msg.value);\n    return _purchaseCap;\n}\n\nfunction executor() public payable { \n    assert(!msg.value);\n    return _executor;\n}\n\nfunction buyICO() public payable { \n    assert(!msg.value);\n    v0 = v1 = 0 != _icoStartBlock;\n    if (v1) {\n        v0 = block.number < _icoStartBlock;\n    }\n    if (!v0) {\n        v2 = v3 = _icoStartTime;\n        if (_icoStartTime) {\n            v2 = block.timestamp < _icoStartTime;\n        }\n        if (!v2) {\n            if ((address(this)).balance >= _minimumContribution) {\n                v4 = v5 = (address(this)).balance;\n                v4 = v6 = _purchaseCap;\n                if (v5 >= v6) {\n                }\n                v7 = _crowdSale.call().value(v4).gas(msg.gas - 34710);\n                assert(v7);\n                emit ICOPurchased(v4);\n                goto 0x11b0x2d4;\n            }\n        }\n    }\n}\n\nfunction changeICOStartBlock(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = _executor == msg.sender;\n    if (_executor != msg.sender) {\n        v0 = _owner == msg.sender;\n    }\n    require(v0);\n    _icoStartBlock = varg0;\n    emit ICOStartBlockChanged(varg0);\n}\n\nfunction transferOwnership(address varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    if (varg0) {\n        _owner = varg0;\n        goto 0x11b0x2fb;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x12ea965d) {\n            icoStartBlock();\n        } else if (0x43062ea7 == v0) {\n            changePurchaseCap(uint256);\n        } else if (0x49df728c == v0) {\n            withdrawTokens(address);\n        } else if (0x68d324e7 == v0) {\n            changeCrowdSale(address);\n        } else if (0x7362377b == v0) {\n            withdrawEther();\n        } else if (0x7770bd15 == v0) {\n            crowdSale();\n        } else if (0x89826963 == v0) {\n            changeICOStartTime(uint256);\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x92bf2bf1 == v0) {\n            changeMinimumContribution(uint256);\n        } else if (0x937e09b1 == v0) {\n            minimumContribution();\n        } else if (0x9665b658 == v0) {\n            changeExecutor(address);\n        } else if (0xa7c3d71b == v0) {\n            icoStartTime();\n        } else if (0xab0fe874 == v0) {\n            purchaseCap();\n        } else if (0xc34c08e5 == v0) {\n            executor();\n        } else if (0xc59b5562 == v0) {\n            buyICO();\n        } else if (0xe52c0f24 == v0) {\n            changeICOStartBlock(uint256);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    emit EtherReceived(msg.sender, msg.value);\n}\n.",
	"status": "1",
	"time_cost": 52.02663445472717,
	"usage": {
		"completion_tokens": 953,
		"prompt_tokens": 1805,
		"total_tokens": 2758
	}
}