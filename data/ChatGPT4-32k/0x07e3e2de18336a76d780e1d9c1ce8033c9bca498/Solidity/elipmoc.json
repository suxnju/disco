{
	"address": "0x07e3e2de18336a76d780e1d9c1ce8033c9bca498",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a simplified Solidity contract version of the given decompiled code:\n\n```solidity\npragma solidity 0.8.19;\n\ncontract MyContract {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    address private _owner;\n    uint256 private _totalSupply;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function _SafeAdd(uint256 a, uint256 b) private pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function _SafeSub(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function _SafeDiv(uint256 a, uint256 b) private pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balanceOf[msg.sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balanceOf[msg.sender] = _SafeSub(_balanceOf[msg.sender], amount);\n        _balanceOf[recipient] = _SafeAdd(_balanceOf[recipient], amount);\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_balanceOf[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n        require(_allowance[sender][msg.sender] >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _balanceOf[sender] = _SafeSub(_balanceOf[sender], amount);\n        _balanceOf[recipient] = _SafeAdd(_balanceOf[recipient], amount);\n        _allowance[sender][msg.sender] = _SafeSub(_allowance[sender][msg.sender], amount);\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _owner = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n}\n```\n\nPlease note that the original decompiled code contains several complex and unspecified functions that are not translated into this simplified Solidity version. The above code is more of a generic ERC20 contract with some additional functionality.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495435,
	"id": "chatcmpl-8VP7jsrghZMu4VaqIq4O0SNKdWTTp",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.19 23:37 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _removeLimits; // STORAGE[0x1]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x3]\nmapping (uint256 => uint256) _@shouldTakeFee_1281; // STORAGE[0x4]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_9; // STORAGE[0x9]\nuint256 owner_a; // STORAGE[0xa]\nuint256 owner_c; // STORAGE[0xc]\nuint256 owner_d; // STORAGE[0xd]\nuint256 owner_e; // STORAGE[0xe]\nuint256 owner_f; // STORAGE[0xf]\nuint256 owner_10; // STORAGE[0x10]\nuint256 owner_11; // STORAGE[0x11]\nuint256 owner_12; // STORAGE[0x12]\nuint256 _@takeFee_1439; // STORAGE[0x13]\nuint256 __maxTxAmount; // STORAGE[0x17]\nuint256 __maxWalletAmount; // STORAGE[0x18]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _@shouldContractSwap_987; // STORAGE[0x8] bytes 0 to 0\nuint256 _@swapTokensForETH_1261; // STORAGE[0x5] bytes 0 to 19\nuint256 _pair; // STORAGE[0x6] bytes 0 to 19\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 _manualSwap; // STORAGE[0x15] bytes 0 to 19\nuint256 stor_16_0_19; // STORAGE[0x16] bytes 0 to 19\nuint256 _enableTrading; // STORAGE[0x6] bytes 20 to 20\nuint256 stor_6_21_21; // STORAGE[0x6] bytes 21 to 21\nuint256 owner_6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc; // STORAGE[0x6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc]\nuint256 _totalSupply; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= varg0 + varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 + varg1;\n}\n\nfunction @shouldContractSwap_987(address varg0, address varg1) private { \n    v0 = v1 = !_@shouldContractSwap_987;\n    if (!_@shouldContractSwap_987) {\n        v0 = v2 = stor_6_21_21;\n    }\n    if (v0) {\n        v0 = v3 = _enableTrading;\n    }\n    if (v0) {\n        v0 = v4 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v0) {\n        v0 = v5 = _pair == varg0;\n    }\n    if (!v0) {\n        return v0;\n    } else {\n        return stor_7 >= stor_9;\n    }\n}\n\nfunction @shouldTakeFee_1281(address varg0, address varg1) private { \n    if (bool(uint8(_@shouldTakeFee_1281[address(varg1)]))) {\n        return !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    } else {\n        return !uint8(_@shouldTakeFee_1281[address(varg0)]);\n    }\n}\n\nfunction @takeFee_1439(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    varg0 = v0 = 0;\n    v1 = @getTotalFees_1307(varg1, varg2);\n    if (v1 <= v0) {\n        return varg0;\n    } else {\n        v2 = v3 = 4864;\n        v4 = v5 = @getTotalFees_1307(varg1, varg2);\n        while (1) {\n            v6 = _SafeDiv(_@takeFee_1439, varg0);\n            v7 = v8 = _SafeMul(v4, v6);\n            v9 = v10 = _pair == address(varg2);\n            if (v10) {\n                v9 = v11 = stor_16_0_19 == address(varg1);\n            }\n            if (v9) {\n                v7 = v12 = _SafeMul(0x3b9aca00, varg0);\n                stor_6_21_21 = 1;\n            }\n            v13 = _SafeAdd(v7, _balanceOf[this]);\n            _balanceOf[this] = v13;\n            v2 = v14 = 5005;\n            v4 = v15 = @getTotalFees_1307(varg1, varg2);\n        }\n        emit Transfer(address(varg2), address(this), v8);\n        v16 = v17 = owner_f > 0;\n        if (v17) {\n            v18 = @getTotalFees_1307(varg1, varg2);\n            v16 = v19 = v18 > owner_f;\n        }\n        if (v16) {\n            v7 = v20 = 5156;\n            v21 = _SafeDiv(_@takeFee_1439, varg0);\n            v22 = _SafeMul(owner_f, v21);\n            @_transfer_1623(v22, 57005);\n        }\n        v23 = _SafeSub(v7, varg0);\n        return v23;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    require((varg0 == varg0 * varg1 / varg1) | !varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 * varg1;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0, Panic(18)); // division by zero\n    return varg1 / varg0;\n}\n\nfunction @getTotalFees_1307(address varg0, address varg1) private { \n    if (varg0 - _pair) {\n        if (varg1 - _pair) {\n            return owner_12;\n        } else {\n            return owner_10;\n        }\n    } else {\n        return owner_11;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_1704(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public nonPayable { \n    MEM[32] = 2;\n    MEM[0] = 57005;\n    v0 = _SafeSub(owner_6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc, _removeLimits);\n    v1 = _SafeSub(_totalSupply, v0);\n    return v1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1623(varg2, varg1);\n    if (0 <= _allowance[varg1][msg.sender]) {\n        @_approve_1704(_allowance[varg1][msg.sender] - 0, msg.sender, varg1);\n        return bool(1);\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_@shouldTakeFee_1281[varg0]));\n}\n\nfunction () public payable { \n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    @swapTokensForETH_1261(_balanceOf[this]);\n    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction _maxWalletAmount() public nonPayable { \n    return __maxWalletAmount;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    @_checkOwner_449();\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction removeLimits() public nonPayable { \n    @_checkOwner_449();\n    __maxTxAmount = _removeLimits;\n    __maxWalletAmount = _removeLimits;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction enableTrading() public nonPayable { \n    @_checkOwner_449();\n    _enableTrading = 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1623(varg1, varg0);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction addLiquidity() public payable { \n    @_checkOwner_449();\n    v0, /* address */ v1 = _@swapTokensForETH_1261.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = _@swapTokensForETH_1261.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _pair = v5;\n    @_approve_1704(_removeLimits, _@swapTokensForETH_1261, this);\n    v6, /* uint256 */ v7, /* uint256 */ v8, /* uint256 */ v9 = _@swapTokensForETH_1261.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, msg.sender, block.timestamp).value(msg.value).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    @_checkOwner_449();\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction @_approve_1704(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 <= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg1 - varg0;\n}\n\nfunction @_transfer_1623(uint256 varg0, uint256 varg1) private { \n    require(address(v0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 <= _balanceOf[address(v0)], Error('You are trying to transfer more than your balance'));\n    v1 = v2 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    if (!bool(uint8(_@shouldTakeFee_1281[address(v0)]))) {\n        v1 = v3 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v1) {\n        require(_enableTrading, Error('tradingActive'));\n    }\n    v4 = v5 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    if (!bool(uint8(_@shouldTakeFee_1281[address(v0)]))) {\n        v4 = v6 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v4) {\n        v4 = v7 = _pair != address(varg1);\n    }\n    if (v4) {\n        v4 = v8 = 57005 != address(varg1);\n    }\n    if (v4) {\n        v9 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n        require(v9 <= __maxWalletAmount, Error('Exceeds maximum wallet amount.'));\n    }\n    v10 = v11 = varg0 <= __maxTxAmount;\n    if (varg0 > __maxTxAmount) {\n        v10 = v12 = uint8(_@shouldTakeFee_1281[address(v0)]);\n    }\n    if (!v10) {\n        v10 = v13 = uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    require(v10, Error('TX Limit Exceeded'));\n    v14 = v15 = _pair == address(varg1);\n    if (v15) {\n        v14 = v16 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    }\n    if (v14) {\n        require(stor_7 <= 1 + stor_7, Panic(17)); // arithmetic overflow or underflow\n        stor_7 += 1;\n    }\n    v17 = @shouldContractSwap_987(varg1, v0);\n    if (v17) {\n        varg1 = v18 = 3401;\n        varg0 = v19 = owner_a;\n        _@shouldContractSwap_987 = 1;\n        varg1 = v20 = owner_e;\n        varg1 = v21 = owner_d;\n        varg1 = v22 = 0;\n        varg0 = v23 = 4409;\n        varg1 = v24 = 2;\n        varg0 = v25 = 7731;\n        varg0 = v26 = 4397;\n        v27 = v28 = _SafeAdd(1, owner_c);\n        while (1) {\n            v27 += varg1;\n            require(v27 <= v27, Panic(17)); // arithmetic overflow or underflow\n            // Unknown jump to Block {'0x1e33', '0x112d'}. Refer to 3-address code (TAC);\n            require((varg1 == varg1 * v27 / v27) | !v27, Panic(17)); // arithmetic overflow or underflow\n            v29 = _SafeMul(owner_c, varg0);\n            v30 = _SafeDiv(varg1 * v27, v29);\n            v31 = _SafeSub(v30, varg0);\n            @swapTokensForETH_1261(v31);\n            v32 = _SafeSub(this.balance, this.balance);\n            v33 = _SafeSub(owner_c, varg1 * v27);\n            v34 = _SafeDiv(v33, v32);\n            v35 = _SafeMul(owner_c, v34);\n            if (v35) {\n                @_approve_1704(v30, _@swapTokensForETH_1261, this);\n                v36, /* uint256 */ v37, /* uint256 */ v38, /* uint256 */ v39 = _@swapTokensForETH_1261.addLiquidityETH(address(this), v30, 0, 0, stor_16_0_19, block.timestamp).value(v35).gas(msg.gas);\n                require(bool(v36), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n            }\n            v40 = _SafeMul(2, v34);\n            v41 = _SafeMul(owner_d, v40);\n            if (v41) {\n                require((v41 == v41 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                v42 = _manualSwap.call().value(v41 << 1).gas(2300 * !(v41 << 1));\n                require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n            if (this.balance) {\n                v43 = stor_14_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n            _@shouldContractSwap_987 = 0;\n            stor_7 = 0;\n        }\n    }\n    v44 = address(varg0);\n    v45 = _SafeSub(varg0, _balanceOf[v44]);\n    v46 = address(varg0);\n    _balanceOf[v46] = v45;\n    v47 = @shouldTakeFee_1281(varg1, varg0);\n    if (v47) {\n        varg0 = v48 = @takeFee_1439(varg0, varg1, varg0);\n    }\n    v49 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v49;\n    emit Transfer(address(varg0), address(varg1), varg0);\n    return ;\n}\n\nfunction @swapTokensForETH_1261(uint256 varg0) private { \n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = _@swapTokensForETH_1261.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    @_approve_1704(varg0, _@swapTokensForETH_1261, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(_@swapTokensForETH_1261.code.size));\n    v11 = _@swapTokensForETH_1261.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction @_checkOwner_449() private { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x4fbee193 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else {\n                require(0x313ce567 == function_selector >> 224);\n                decimals();\n            }\n        } else if (0x4fbee193 == function_selector >> 224) {\n            isExcludedFromFees(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x6c0a24eb == function_selector >> 224) {\n            _maxWalletAmount();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa8aa1b31 > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8a8c523c == function_selector >> 224) {\n            enableTrading();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa8aa1b31 == function_selector >> 224) {\n        pair();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else if (0xe8078d94 == function_selector >> 224) {\n        addLiquidity();\n    } else {\n        require(0xf2fde38b == function_selector >> 224);\n        transferOwnership(address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.19 23:37 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _removeLimits; // STORAGE[0x1]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x3]\nmapping (uint256 => uint256) _@shouldTakeFee_1281; // STORAGE[0x4]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_9; // STORAGE[0x9]\nuint256 owner_a; // STORAGE[0xa]\nuint256 owner_c; // STORAGE[0xc]\nuint256 owner_d; // STORAGE[0xd]\nuint256 owner_e; // STORAGE[0xe]\nuint256 owner_f; // STORAGE[0xf]\nuint256 owner_10; // STORAGE[0x10]\nuint256 owner_11; // STORAGE[0x11]\nuint256 owner_12; // STORAGE[0x12]\nuint256 _@takeFee_1439; // STORAGE[0x13]\nuint256 __maxTxAmount; // STORAGE[0x17]\nuint256 __maxWalletAmount; // STORAGE[0x18]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _@shouldContractSwap_987; // STORAGE[0x8] bytes 0 to 0\nuint256 _@swapTokensForETH_1261; // STORAGE[0x5] bytes 0 to 19\nuint256 _pair; // STORAGE[0x6] bytes 0 to 19\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 _manualSwap; // STORAGE[0x15] bytes 0 to 19\nuint256 stor_16_0_19; // STORAGE[0x16] bytes 0 to 19\nuint256 _enableTrading; // STORAGE[0x6] bytes 20 to 20\nuint256 stor_6_21_21; // STORAGE[0x6] bytes 21 to 21\nuint256 owner_6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc; // STORAGE[0x6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc]\nuint256 _totalSupply; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= varg0 + varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 + varg1;\n}\n\nfunction @shouldContractSwap_987(address varg0, address varg1) private { \n    v0 = v1 = !_@shouldContractSwap_987;\n    if (!_@shouldContractSwap_987) {\n        v0 = v2 = stor_6_21_21;\n    }\n    if (v0) {\n        v0 = v3 = _enableTrading;\n    }\n    if (v0) {\n        v0 = v4 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v0) {\n        v0 = v5 = _pair == varg0;\n    }\n    if (!v0) {\n        return v0;\n    } else {\n        return stor_7 >= stor_9;\n    }\n}\n\nfunction @shouldTakeFee_1281(address varg0, address varg1) private { \n    if (bool(uint8(_@shouldTakeFee_1281[address(varg1)]))) {\n        return !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    } else {\n        return !uint8(_@shouldTakeFee_1281[address(varg0)]);\n    }\n}\n\nfunction @takeFee_1439(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    varg0 = v0 = 0;\n    v1 = @getTotalFees_1307(varg1, varg2);\n    if (v1 <= v0) {\n        return varg0;\n    } else {\n        v2 = v3 = 4864;\n        v4 = v5 = @getTotalFees_1307(varg1, varg2);\n        while (1) {\n            v6 = _SafeDiv(_@takeFee_1439, varg0);\n            v7 = v8 = _SafeMul(v4, v6);\n            v9 = v10 = _pair == address(varg2);\n            if (v10) {\n                v9 = v11 = stor_16_0_19 == address(varg1);\n            }\n            if (v9) {\n                v7 = v12 = _SafeMul(0x3b9aca00, varg0);\n                stor_6_21_21 = 1;\n            }\n            v13 = _SafeAdd(v7, _balanceOf[this]);\n            _balanceOf[this] = v13;\n            v2 = v14 = 5005;\n            v4 = v15 = @getTotalFees_1307(varg1, varg2);\n        }\n        emit Transfer(address(varg2), address(this), v8);\n        v16 = v17 = owner_f > 0;\n        if (v17) {\n            v18 = @getTotalFees_1307(varg1, varg2);\n            v16 = v19 = v18 > owner_f;\n        }\n        if (v16) {\n            v7 = v20 = 5156;\n            v21 = _SafeDiv(_@takeFee_1439, varg0);\n            v22 = _SafeMul(owner_f, v21);\n            @_transfer_1623(v22, 57005);\n        }\n        v23 = _SafeSub(v7, varg0);\n        return v23;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    require((varg0 == varg0 * varg1 / varg1) | !varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 * varg1;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0, Panic(18)); // division by zero\n    return varg1 / varg0;\n}\n\nfunction @getTotalFees_1307(address varg0, address varg1) private { \n    if (varg0 - _pair) {\n        if (varg1 - _pair) {\n            return owner_12;\n        } else {\n            return owner_10;\n        }\n    } else {\n        return owner_11;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_1704(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public nonPayable { \n    MEM[32] = 2;\n    MEM[0] = 57005;\n    v0 = _SafeSub(owner_6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc, _removeLimits);\n    v1 = _SafeSub(_totalSupply, v0);\n    return v1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1623(varg2, varg1);\n    if (0 <= _allowance[varg1][msg.sender]) {\n        @_approve_1704(_allowance[varg1][msg.sender] - 0, msg.sender, varg1);\n        return bool(1);\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_@shouldTakeFee_1281[varg0]));\n}\n\nfunction () public payable { \n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    @swapTokensForETH_1261(_balanceOf[this]);\n    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction _maxWalletAmount() public nonPayable { \n    return __maxWalletAmount;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    @_checkOwner_449();\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction removeLimits() public nonPayable { \n    @_checkOwner_449();\n    __maxTxAmount = _removeLimits;\n    __maxWalletAmount = _removeLimits;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction enableTrading() public nonPayable { \n    @_checkOwner_449();\n    _enableTrading = 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1623(varg1, varg0);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction addLiquidity() public payable { \n    @_checkOwner_449();\n    v0, /* address */ v1 = _@swapTokensForETH_1261.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = _@swapTokensForETH_1261.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _pair = v5;\n    @_approve_1704(_removeLimits, _@swapTokensForETH_1261, this);\n    v6, /* uint256 */ v7, /* uint256 */ v8, /* uint256 */ v9 = _@swapTokensForETH_1261.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, msg.sender, block.timestamp).value(msg.value).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    @_checkOwner_449();\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction @_approve_1704(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 <= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg1 - varg0;\n}\n\nfunction @_transfer_1623(uint256 varg0, uint256 varg1) private { \n    require(address(v0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 <= _balanceOf[address(v0)], Error('You are trying to transfer more than your balance'));\n    v1 = v2 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    if (!bool(uint8(_@shouldTakeFee_1281[address(v0)]))) {\n        v1 = v3 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v1) {\n        require(_enableTrading, Error('tradingActive'));\n    }\n    v4 = v5 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    if (!bool(uint8(_@shouldTakeFee_1281[address(v0)]))) {\n        v4 = v6 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v4) {\n        v4 = v7 = _pair != address(varg1);\n    }\n    if (v4) {\n        v4 = v8 = 57005 != address(varg1);\n    }\n    if (v4) {\n        v9 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n        require(v9 <= __maxWalletAmount, Error('Exceeds maximum wallet amount.'));\n    }\n    v10 = v11 = varg0 <= __maxTxAmount;\n    if (varg0 > __maxTxAmount) {\n        v10 = v12 = uint8(_@shouldTakeFee_1281[address(v0)]);\n    }\n    if (!v10) {\n        v10 = v13 = uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    require(v10, Error('TX Limit Exceeded'));\n    v14 = v15 = _pair == address(varg1);\n    if (v15) {\n        v14 = v16 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    }\n    if (v14) {\n        require(stor_7 <= 1 + stor_7, Panic(17)); // arithmetic overflow or underflow\n        stor_7 += 1;\n    }\n    v17 = @shouldContractSwap_987(varg1, v0);\n    if (v17) {\n        varg1 = v18 = 3401;\n        varg0 = v19 = owner_a;\n        _@shouldContractSwap_987 = 1;\n        varg1 = v20 = owner_e;\n        varg1 = v21 = owner_d;\n        varg1 = v22 = 0;\n        varg0 = v23 = 4409;\n        varg1 = v24 = 2;\n        varg0 = v25 = 7731;\n        varg0 = v26 = 4397;\n        v27 = v28 = _SafeAdd(1, owner_c);\n        while (1) {\n            v27 += varg1;\n            require(v27 <= v27, Panic(17)); // arithmetic overflow or underflow\n            // Unknown jump to Block {'0x1e33', '0x112d'}. Refer to 3-address code (TAC);\n            require((varg1 == varg1 * v27 / v27) | !v27, Panic(17)); // arithmetic overflow or underflow\n            v29 = _SafeMul(owner_c, varg0);\n            v30 = _SafeDiv(varg1 * v27, v29);\n            v31 = _SafeSub(v30, varg0);\n            @swapTokensForETH_1261(v31);\n            v32 = _SafeSub(this.balance, this.balance);\n            v33 = _SafeSub(owner_c, varg1 * v27);\n            v34 = _SafeDiv(v33, v32);\n            v35 = _SafeMul(owner_c, v34);\n            if (v35) {\n                @_approve_1704(v30, _@swapTokensForETH_1261, this);\n                v36, /* uint256 */ v37, /* uint256 */ v38, /* uint256 */ v39 = _@swapTokensForETH_1261.addLiquidityETH(address(this), v30, 0, 0, stor_16_0_19, block.timestamp).value(v35).gas(msg.gas);\n                require(bool(v36), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n            }\n            v40 = _SafeMul(2, v34);\n            v41 = _SafeMul(owner_d, v40);\n            if (v41) {\n                require((v41 == v41 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                v42 = _manualSwap.call().value(v41 << 1).gas(2300 * !(v41 << 1));\n                require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n            if (this.balance) {\n                v43 = stor_14_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n            _@shouldContractSwap_987 = 0;\n            stor_7 = 0;\n        }\n    }\n    v44 = address(varg0);\n    v45 = _SafeSub(varg0, _balanceOf[v44]);\n    v46 = address(varg0);\n    _balanceOf[v46] = v45;\n    v47 = @shouldTakeFee_1281(varg1, varg0);\n    if (v47) {\n        varg0 = v48 = @takeFee_1439(varg0, varg1, varg0);\n    }\n    v49 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v49;\n    emit Transfer(address(varg0), address(varg1), varg0);\n    return ;\n}\n\nfunction @swapTokensForETH_1261(uint256 varg0) private { \n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = _@swapTokensForETH_1261.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    @_approve_1704(varg0, _@swapTokensForETH_1261, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(_@swapTokensForETH_1261.code.size));\n    v11 = _@swapTokensForETH_1261.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction @_checkOwner_449() private { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x4fbee193 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else {\n                require(0x313ce567 == function_selector >> 224);\n                decimals();\n            }\n        } else if (0x4fbee193 == function_selector >> 224) {\n            isExcludedFromFees(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x6c0a24eb == function_selector >> 224) {\n            _maxWalletAmount();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa8aa1b31 > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8a8c523c == function_selector >> 224) {\n            enableTrading();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa8aa1b31 == function_selector >> 224) {\n        pair();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else if (0xe8078d94 == function_selector >> 224) {\n        addLiquidity();\n    } else {\n        require(0xf2fde38b == function_selector >> 224);\n        transferOwnership(address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.19 23:37 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _removeLimits; // STORAGE[0x1]\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x3]\nmapping (uint256 => uint256) _@shouldTakeFee_1281; // STORAGE[0x4]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_9; // STORAGE[0x9]\nuint256 owner_a; // STORAGE[0xa]\nuint256 owner_c; // STORAGE[0xc]\nuint256 owner_d; // STORAGE[0xd]\nuint256 owner_e; // STORAGE[0xe]\nuint256 owner_f; // STORAGE[0xf]\nuint256 owner_10; // STORAGE[0x10]\nuint256 owner_11; // STORAGE[0x11]\nuint256 owner_12; // STORAGE[0x12]\nuint256 _@takeFee_1439; // STORAGE[0x13]\nuint256 __maxTxAmount; // STORAGE[0x17]\nuint256 __maxWalletAmount; // STORAGE[0x18]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _@shouldContractSwap_987; // STORAGE[0x8] bytes 0 to 0\nuint256 _@swapTokensForETH_1261; // STORAGE[0x5] bytes 0 to 19\nuint256 _pair; // STORAGE[0x6] bytes 0 to 19\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\nuint256 _manualSwap; // STORAGE[0x15] bytes 0 to 19\nuint256 stor_16_0_19; // STORAGE[0x16] bytes 0 to 19\nuint256 _enableTrading; // STORAGE[0x6] bytes 20 to 20\nuint256 stor_6_21_21; // STORAGE[0x6] bytes 21 to 21\nuint256 owner_6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc; // STORAGE[0x6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc]\nuint256 _totalSupply; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= varg0 + varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 + varg1;\n}\n\nfunction @shouldContractSwap_987(address varg0, address varg1) private { \n    v0 = v1 = !_@shouldContractSwap_987;\n    if (!_@shouldContractSwap_987) {\n        v0 = v2 = stor_6_21_21;\n    }\n    if (v0) {\n        v0 = v3 = _enableTrading;\n    }\n    if (v0) {\n        v0 = v4 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v0) {\n        v0 = v5 = _pair == varg0;\n    }\n    if (!v0) {\n        return v0;\n    } else {\n        return stor_7 >= stor_9;\n    }\n}\n\nfunction @shouldTakeFee_1281(address varg0, address varg1) private { \n    if (bool(uint8(_@shouldTakeFee_1281[address(varg1)]))) {\n        return !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    } else {\n        return !uint8(_@shouldTakeFee_1281[address(varg0)]);\n    }\n}\n\nfunction @takeFee_1439(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    varg0 = v0 = 0;\n    v1 = @getTotalFees_1307(varg1, varg2);\n    if (v1 <= v0) {\n        return varg0;\n    } else {\n        v2 = v3 = 4864;\n        v4 = v5 = @getTotalFees_1307(varg1, varg2);\n        while (1) {\n            v6 = _SafeDiv(_@takeFee_1439, varg0);\n            v7 = v8 = _SafeMul(v4, v6);\n            v9 = v10 = _pair == address(varg2);\n            if (v10) {\n                v9 = v11 = stor_16_0_19 == address(varg1);\n            }\n            if (v9) {\n                v7 = v12 = _SafeMul(0x3b9aca00, varg0);\n                stor_6_21_21 = 1;\n            }\n            v13 = _SafeAdd(v7, _balanceOf[this]);\n            _balanceOf[this] = v13;\n            v2 = v14 = 5005;\n            v4 = v15 = @getTotalFees_1307(varg1, varg2);\n        }\n        emit Transfer(address(varg2), address(this), v8);\n        v16 = v17 = owner_f > 0;\n        if (v17) {\n            v18 = @getTotalFees_1307(varg1, varg2);\n            v16 = v19 = v18 > owner_f;\n        }\n        if (v16) {\n            v7 = v20 = 5156;\n            v21 = _SafeDiv(_@takeFee_1439, varg0);\n            v22 = _SafeMul(owner_f, v21);\n            @_transfer_1623(v22, 57005);\n        }\n        v23 = _SafeSub(v7, varg0);\n        return v23;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    require((varg0 == varg0 * varg1 / varg1) | !varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 * varg1;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0, Panic(18)); // division by zero\n    return varg1 / varg0;\n}\n\nfunction @getTotalFees_1307(address varg0, address varg1) private { \n    if (varg0 - _pair) {\n        if (varg1 - _pair) {\n            return owner_12;\n        } else {\n            return owner_10;\n        }\n    } else {\n        return owner_11;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_1704(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction totalSupply() public nonPayable { \n    MEM[32] = 2;\n    MEM[0] = 57005;\n    v0 = _SafeSub(owner_6a9609baa168169acaea398c4407efea4be641bb08e21e88806d9836fd9333cc, _removeLimits);\n    v1 = _SafeSub(_totalSupply, v0);\n    return v1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1623(varg2, varg1);\n    if (0 <= _allowance[varg1][msg.sender]) {\n        @_approve_1704(_allowance[varg1][msg.sender] - 0, msg.sender, varg1);\n        return bool(1);\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 += 32;\n        }\n        v0[v1.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction isExcludedFromFees(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_@shouldTakeFee_1281[varg0]));\n}\n\nfunction () public payable { \n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    @swapTokensForETH_1261(_balanceOf[this]);\n    v0 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction _maxWalletAmount() public nonPayable { \n    return __maxWalletAmount;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    @_checkOwner_449();\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction removeLimits() public nonPayable { \n    @_checkOwner_449();\n    __maxTxAmount = _removeLimits;\n    __maxWalletAmount = _removeLimits;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction enableTrading() public nonPayable { \n    @_checkOwner_449();\n    _enableTrading = 1;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction pair() public nonPayable { \n    return _pair;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1623(varg1, varg0);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction addLiquidity() public payable { \n    @_checkOwner_449();\n    v0, /* address */ v1 = _@swapTokensForETH_1261.factory().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v1 == address(v1));\n    v2, /* address */ v3 = _@swapTokensForETH_1261.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = address(v1).createPair(address(this), address(v3)).gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    _pair = v5;\n    @_approve_1704(_removeLimits, _@swapTokensForETH_1261, this);\n    v6, /* uint256 */ v7, /* uint256 */ v8, /* uint256 */ v9 = _@swapTokensForETH_1261.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, msg.sender, block.timestamp).value(msg.value).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    @_checkOwner_449();\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction @_approve_1704(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 <= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg1 - varg0;\n}\n\nfunction @_transfer_1623(uint256 varg0, uint256 varg1) private { \n    require(address(v0), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 <= _balanceOf[address(v0)], Error('You are trying to transfer more than your balance'));\n    v1 = v2 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    if (!bool(uint8(_@shouldTakeFee_1281[address(v0)]))) {\n        v1 = v3 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v1) {\n        require(_enableTrading, Error('tradingActive'));\n    }\n    v4 = v5 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    if (!bool(uint8(_@shouldTakeFee_1281[address(v0)]))) {\n        v4 = v6 = !uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    if (v4) {\n        v4 = v7 = _pair != address(varg1);\n    }\n    if (v4) {\n        v4 = v8 = 57005 != address(varg1);\n    }\n    if (v4) {\n        v9 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n        require(v9 <= __maxWalletAmount, Error('Exceeds maximum wallet amount.'));\n    }\n    v10 = v11 = varg0 <= __maxTxAmount;\n    if (varg0 > __maxTxAmount) {\n        v10 = v12 = uint8(_@shouldTakeFee_1281[address(v0)]);\n    }\n    if (!v10) {\n        v10 = v13 = uint8(_@shouldTakeFee_1281[address(varg1)]);\n    }\n    require(v10, Error('TX Limit Exceeded'));\n    v14 = v15 = _pair == address(varg1);\n    if (v15) {\n        v14 = v16 = !uint8(_@shouldTakeFee_1281[address(v0)]);\n    }\n    if (v14) {\n        require(stor_7 <= 1 + stor_7, Panic(17)); // arithmetic overflow or underflow\n        stor_7 += 1;\n    }\n    v17 = @shouldContractSwap_987(varg1, v0);\n    if (v17) {\n        varg1 = v18 = 3401;\n        varg0 = v19 = owner_a;\n        _@shouldContractSwap_987 = 1;\n        varg1 = v20 = owner_e;\n        varg1 = v21 = owner_d;\n        varg1 = v22 = 0;\n        varg0 = v23 = 4409;\n        varg1 = v24 = 2;\n        varg0 = v25 = 7731;\n        varg0 = v26 = 4397;\n        v27 = v28 = _SafeAdd(1, owner_c);\n        while (1) {\n            v27 += varg1;\n            require(v27 <= v27, Panic(17)); // arithmetic overflow or underflow\n            // Unknown jump to Block {'0x1e33', '0x112d'}. Refer to 3-address code (TAC);\n            require((varg1 == varg1 * v27 / v27) | !v27, Panic(17)); // arithmetic overflow or underflow\n            v29 = _SafeMul(owner_c, varg0);\n            v30 = _SafeDiv(varg1 * v27, v29);\n            v31 = _SafeSub(v30, varg0);\n            @swapTokensForETH_1261(v31);\n            v32 = _SafeSub(this.balance, this.balance);\n            v33 = _SafeSub(owner_c, varg1 * v27);\n            v34 = _SafeDiv(v33, v32);\n            v35 = _SafeMul(owner_c, v34);\n            if (v35) {\n                @_approve_1704(v30, _@swapTokensForETH_1261, this);\n                v36, /* uint256 */ v37, /* uint256 */ v38, /* uint256 */ v39 = _@swapTokensForETH_1261.addLiquidityETH(address(this), v30, 0, 0, stor_16_0_19, block.timestamp).value(v35).gas(msg.gas);\n                require(bool(v36), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n            }\n            v40 = _SafeMul(2, v34);\n            v41 = _SafeMul(owner_d, v40);\n            if (v41) {\n                require((v41 == v41 << 1 >> 1) | !0x2, Panic(17)); // arithmetic overflow or underflow\n                v42 = _manualSwap.call().value(v41 << 1).gas(2300 * !(v41 << 1));\n                require(bool(v42), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n            if (this.balance) {\n                v43 = stor_14_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                require(bool(v43), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n            _@shouldContractSwap_987 = 0;\n            stor_7 = 0;\n        }\n    }\n    v44 = address(varg0);\n    v45 = _SafeSub(varg0, _balanceOf[v44]);\n    v46 = address(varg0);\n    _balanceOf[v46] = v45;\n    v47 = @shouldTakeFee_1281(varg1, varg0);\n    if (v47) {\n        varg0 = v48 = @takeFee_1439(varg0, varg1, varg0);\n    }\n    v49 = _SafeAdd(varg0, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v49;\n    emit Transfer(address(varg0), address(varg1), varg0);\n    return ;\n}\n\nfunction @swapTokensForETH_1261(uint256 varg0) private { \n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = _@swapTokensForETH_1261.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    @_approve_1704(varg0, _@swapTokensForETH_1261, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(_@swapTokensForETH_1261.code.size));\n    v11 = _@swapTokensForETH_1261.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction @_checkOwner_449() private { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x4fbee193 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else {\n                require(0x313ce567 == function_selector >> 224);\n                decimals();\n            }\n        } else if (0x4fbee193 == function_selector >> 224) {\n            isExcludedFromFees(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x6c0a24eb == function_selector >> 224) {\n            _maxWalletAmount();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa8aa1b31 > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8a8c523c == function_selector >> 224) {\n            enableTrading();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa8aa1b31 == function_selector >> 224) {\n        pair();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else if (0xe8078d94 == function_selector >> 224) {\n        addLiquidity();\n    } else {\n        require(0xf2fde38b == function_selector >> 224);\n        transferOwnership(address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 55.79223442077637,
	"usage": {
		"completion_tokens": 842,
		"prompt_tokens": 5844,
		"total_tokens": 6686
	}
}